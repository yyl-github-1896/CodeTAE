{"id1": "17522011", "id2": "8754809", "code1": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 0, "substitutes": {"read": ["exec", "reader", "send", "parse", "use", "feed", "load", "invoke", "readable", "check", "default", "include", "input", "connect", "start", "play", "write", "resources", "eval", "build", "type", "print", "report", "class", "find", "Read", "READ", "resource", "add", "get", "data", "process", "work", "create", "reads", "open", "reading", "select", "run"], "classLoader": ["resourceLoader", "ClassPath", "ClassLoad", "classReader", "resourceLoading", " classDir", "classDir", " classloader", "fileDir", "classLoading", " classReader", "fileLoader", "resourceReader", "classPath", "classLoad", "ClassLoading", "ClassReader", "fileloader", "ClassDir", "Classloader", "ClassLoader", " classPath", "resourceloader", "classloader", " classLoad", " classLoading", "filePath", "fileLoad"], "name": ["address", "base", "alias", "str", "comment", "id", "ame", "child", "none", "old", "path", "Name", "x", "default", "filename", "string", "time", "named", "word", "image", "prefix", "no", "large", "code", "type", "connection", "active", "class", "root", "null", "n", "NAME", "parent", "resource", "key", "search", "data", "file", "pass", "value", "home", "names", "part", "size"], "all": ["ann", "call", "allow", "ALL", "local", "left", "apply", "app", "not", "none", "sort", "am", "alls", "total", "one", "al", "auto", "named", "this", "All", "at", "global", "batch", "active", "both", "any", "with", "each", "list", "sync", "alpha", "array", "attribute", "l", "process", "and", "only", "pass", "full", "part", "f", "partial"], "sm": ["su", "cm", "im", "serv", "sv", "sw", "imm", "ms", "Sm", "sr", "gm", "rm", "sim", "zip", "sam", "smith", "bm", "mo", "sl", "ama", "fm", "si", "ym", "sa", "asm", "m", "sk", "sb", "om", "SM", "so", "km", "sym", "mm", "tm", "sn", "sy", "service", "api", "em", "hm", "wm", "sh", "source", "vm", "nm", "spe", "sp", "sum", "sf", "ss"], "enu": ["enun", " enus", "anU", "Encu", "EnU", " encu", "venus", "Enun", "enou", "anun", "anu", "enncu", "ENc", "Enu", " ennu", "enus", "enU", "ennus", "munun", "ENu", "ennnu", "munus", "Enou", "enc", "Ennu", "venou", "ennu", "Enc", "munu", "venu", "Enus", "encu", "munU", "anus", "ENou", "ENus", "venc"], "url": ["address", "base", "job", "rel", "str", "id", "zip", "URL", "path", "sl", "Url", "string", "li", "ls", "image", "layer", "ssl", "i", "r", "connection", "browser", "ll", "pull", "loc", "loader", "ur", "uri", "resource", "key", "http", "l", "in", "source", "file", "server", "plug", "download", "page", "impl", "web", "f"], "is": ["us", "im", "ais", "esi", "ip", "ins", "ois", "app", "iso", "id", "are", "isa", "was", "io", "has", "IS", "ar", "vs", "bis", "Is", "es", "ic", "abs", "ir", "cms", "ls", "ris", "inner", "image", "isl", "si", "iss", "ios", "os", "ii", "or", "ori", "i", "info", "ie", "js", "ignore", "ops", "lis", "il", "isc", "isi", "ri", "uri", "api", "p", "close", "it", "its", "iris", "http", "in", "act", "init", "as", "serv", "web", "mis"], "s": ["su", "services", "sv", "ins", "ms", "outs", "w", "sets", "e", "ts", "rs", "ws", "ions", "sl", "es", "session", "ns", "abs", "string", "ies", "ls", "u", "lines", "ks", "c", "spec", "results", "si", "als", "os", "ses", "comments", "strings", "m", "storage", "sg", "ssl", "sb", "i", "r", "ments", "g", "rows", "js", "n", "cs", "o", "ans", "ps", "S", "ows", "ds", "p", "les", "h", "its", "ips", "l", "se", "sc", "ches", "d", "details", "ss", "sf", "f", "gs", "ings"]}}
{"id1": "13644375", "id2": "6371589", "code1": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"get": ["exec", "base", "send", "client", "status", "call", "delete", "parse", "handle", "e", "transfer", "use", "invoke", "load", "put", "request", "Get", "remote", "patch", "start", "end", "set", "build", "read", "i", "print", "show", "method", "with", "find", "query", "pull", "update", "post", "service", "resource", "GET", "api", "uri", "gi", "http", "cli", "download", "create", "json", "open", "select"], "url": ["address", "base", "str", "id", "feed", "URL", "path", "request", "xml", "sl", "Url", "host", "location", "string", "name", "type", "i", "method", "connection", "route", "object", "uri", "service", "resource", "api", "http", "href", "l", "data", "file", "server", "source", "email", "download", "json"], "response": ["result", "error", "received", "status", "output", "feed", "Response", "request", "out", "success", "respond", "connection", "method", "report", "application", "object", "body", "message", "tree", "api", "resource", "wave", "document", "http", "page", "data", "resp", "server", "full", "reply", "onse", "json"], "entity": ["result", "item", "error", "ity", "el", "e", "output", "model", "xml", "environment", " entities", "node", "action", "image", "event", "element", "info", "connection", "pe", "ent", "null", "object", "body", "ale", "query", "resource", "api", "person", "content", "document", "http", "Entity", "page", "translation", "data", "source", "file", "server", "instance", "json", "collection", "ce"]}}
{"id1": "20306677", "id2": "471804", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"update": ["address", "apply", "id", "inc", "row", "core", "query", "date", "data", "value", "full", "size", "grade", "status", "save", "use", "feed", "put", "check", "patch", "bug", "lock", "write", "database", "where", "event", "object", "property", "UPDATE", "get", "append", "create", "run", "two", "result", "Update", "change", "current", "range", "fill", "find", "resource", "insert", "unit", "updated", "delete", "view", "load", "replace", "index", "more", "end", "offset", "next", "build", "ite", "connection", "latest", "edit", "diff", "future", "sync", "ul", "version", "add", "plus", "other", "up", "width", "draw", "json", "response"], "o": ["oe", "Obj", "e", "ou", "one", "oo", "mo", "ao", "out", "obj", "s", "ilo", "bot", "oid", "bo", "os", "OO", "oro", "or", "t", "i", "b", "object", "n", "ow", "od", "office", " object", "p", "ingo", " bo", " O", "article", "O", "ol", "oa", "f", "vo", "po"], "bill": ["flow", "foo", "base", "account", "project", "bean", "db", "log", "fl", "note", "conn", "ee", "bug", "order", "Bill", " contract", "bl", "BILL", "nn", "company", "business", "bird", "charge", "report", "batch", "ban", "b", "bar", "object", "user", "number", "service", "bel", "fee", "pool", "mill", "contract", "roll", "unit", "book", "f"], "pst": ["lpsp", " pct", "ppsp", "lpsts", " psts", "psth", "nst", "nsts", "jpsth", "pct", "prect", "Psth", " psth", "Psc", "lpst", "Psp", "jpst", "ppsc", "psc", "nct", "Pst", "ppst", "psts", "Psts", "Pct", "psp", "presp", "jpct", "nsp", "jpsts", "presc", "ppct", "prest", "lpct"]}}
{"id1": "13783898", "id2": "149935", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeFileToFiles", "encodeStringToFiles", "encodeFile2Stream", "encodeFiletoStream", "encodeFileFromFile", "encodeFileFromStream", "encodeFiletoFile", "encodeString2File", "encodeFiletoFiles", "encodeString2Files", "encodeFile2File", "encodeString2String", "encodeString2Stream", "encodeFileFromString", "encodeFileToString", "encodeFile2String", "encodeStringToString", "encodeFileToStream", "encodeFiletoString", "encodeStringToStream", "encodeFile2Files", "encodeStringToFile"], "infile": ["Infile", "infiles", "inputFile", "InFile", "inFile", "Infiles", "outFile", "inputfiles", "infilename", "outfilename", " infilename", "outfiles", "inputfp", "infp", " infiles", "inputfilename", " infp", "outfp", "Infilename", "inputfile"], "outfile": ["outputfilename", "newname", "Outname", "newFile", "outname", "infolder", "newfolder", " outname", "Outfolder", "outFile", "outfolder", " outfolder", "infilename", "outfilename", "outputfp", " outFile", "outputfile", " outfilename", " outfp", "newfile", "infp", "OutFile", "outputfolder", "Outfile", "outfp"], "in": ["gin", "base", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "vin", "ini", "input", "ic", "In", "s", "conn", "inner", "image", "err", "inas", "m", "a", "i", "r", "b", "again", "sin", "socket", "nin", "win", "inn", "min", "pin", "is", "into", "cin", "data", "source", "init", "inside", "rin", "pass", "ac", "con", "as"], "out": ["net", "exec", "base", "error", "OUT", "client", "outs", "cache", "job", "output", "bin", "ou", "io", "inc", "one", "session", "conn", "obj", "In", "inner", "on", "name", "to", "image", "err", "write", "off", "no", "Out", "lib", "or", "writer", "ex", "parent", "again", "o", "co", "socket", "sync", "post", "outer", "timeout", "point", "copy", "line", "source", "work", "file", "up", "home", "exit"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bb", "transfer", "feed", "raw", "fb", "input", "border", "length", "seed", "binary", "offset", "queue", "write", "len", "layer", "type", "reference", "batch", "count", "b", "null", "buf", "slice", "padding", "iter", "bytes", "wave", "flush", "data", "source", "server", "limit", "value", "split", "size", "buff"], "read": ["exec", " skip", " Read", "ip", "reader", "send", " copy", "parse", "lex", "allow", "use", "id", "feed", "io", "load", "inc", "raw", "current", "_", "check", "x", " count", "input", "connect", "start", "length", "ind", "play", "seek", "end", "write", "next", "len", "i", "count", "ride", "wait", "fill", "n", "find", "Read", "slice", "sync", "READ", "tell", " write", "ad", "iter", "close", "add", "get", "copy", "work", "sleep", "se", "limit", "reads", "pass", "reading", "size", "select", "f", "run"], "success": ["complete", "first", "result", "error", "cess", " succ", "fast", "status", "ccess", "growth", "follow", "flash", "primary", "right", "Success", "valid", "model", "func", "path", "default", " succeed", " Success", "true", "winner", "rolled", "results", "xx", "failed", "danger", " successful", "construct", "method", "null", "again", "ceed", "good", "message", "done", "rolling", "successfully", "respons", "content", "continue", "data", "warning", "successful", "pass", "roll", "initial", "better", "fail", "value", "open", "modified", "comment", "response"]}}
{"id1": "62362", "id2": "3024992", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["CONception", " deconversion", "Converted", "oconversion", "subversion", "CONverted", "unception", "subverting", "CONvert", "subverted", "unvert", "unverted", "Conception", "CONverting", " deconverting", "oconverted", "Conversion", "Converting", "CONversion", "oconvert", " deconverted", "conception", "converting", "subvert", "oconverting", "Convert", "conversion", "converted", "unversion", " deconvert"], "src": ["sys", "ource", "fp", "url", "sit", "prot", "st", "img", "reader", "gb", "tmp", "load", "cb", "proc", "scene", "path", "input", "filename", "string", "name", "obj", "s", "stream", "secure", "sth", "Source", "spec", "upload", "storage", "sel", "code", "username", "SourceFile", "ssl", "sb", "component", "Dest", "supp", "buf", "video", "sin", "attr", "back", "config", "loc", "slice", "inst", "sn", "uri", "resource", "rb", "feat", "rc", "href", "source", "fn", "sc", "file", "download", "ref", "RC", "gz", "dist", "req", "stage", "impl", "cpp", "rl", "ctx", "cmp"], "dest": ["disk", "test", "cont", "img", "bin", "tmp", "path", "target", "obj", "lib", "std", " dst", "Dest", "class", "dat", "orig", "null", "dc", "di", "source", "fn", "dir", "dist", " destination", "home", "txt", "temp"], "in": ["ins", "din", "reader", "IN", "login", "bin", "isin", "inc", "io", "ini", "val", "input", "In", "stream", "err", "doc", "inas", "t", "a", "i", "r", "ex", "n", "ps", "win", "inn", "inf", "pin", "is", "data", "source", "up", "file", "d", "pass", "as", "f"], "p": ["fp", "jp", "v", "pa", "tp", "bp", "e", "lp", "pre", "pm", "P", "py", "pr", "s", "cp", "c", "np", "m", "t", "j", "i", "r", "pe", "g", "b", "cop", "o", "ps", "per", "parser", "pd", "pg", "h", "wp", "l", "op", "pb", "d", "pc", "pp", "sp", "part", "f", "pi", "po"], "ds": ["posts", " DS", "eps", "dp", "ths", "vs", "els", "os", " ps", "dat", "ps", " sd", "pd", "uds", "data", "qs", "utils", "points", "rs", "services", "da", "groups", "db", "docs", "s", "ls", "hs", "words", "ys", "models", "cs", "ans", "di", "ld", "cons", "gs", "ins", "xs", "ges", "ts", "nas", "ks", "sts", "ded", "lines", "vals", "js", "ups", "plugins", "dates", "ants", "dds", "ss", "scripts", "tests", "ils", "ads", "sys", "Ds", "ays", "dl", "lp", "tools", "df", "ns", "styles", "dd", "gd", "des", "dos", "sync", " props", "dc", "parts", "dt", "obs", "dist", "amps", "d", "DS", "icks", "dm", "ipes", "bs"], "format": ["template", "atter", "url", "fp", "magic", "model", "path", "function", "plugin", "host", "pattern", "filename", "string", "nat", "language", "struct", "name", "prefix", "spec", "t", "type", "at", "Format", "class", "tag", "handler", "config", "layout", "sche", "table", "parser", "api", "version", "scale", "form", "feat", "fd", "data", "source", "file", "filter", "letter", "ant", "fn", "style", "act", "frame", "unit", "part", "record", "f"], "hasPixelData": ["hasByteData", "showsPixelDATA", "hasPictureSize", "haspixelSize", " hasPixelSize", " hasPixeldata", "showsByteData", "showsByteStyle", "showsBytedata", "showsPixeldata", "hasPixelSize", "hasPicturedata", "showsPixelStyle", "hasByteSize", "hasPixelDATA", "hasPictureData", "hasPixeldata", "hasByteStyle", "haspixelData", "showsByteDATA", "haspixeldata", "hasPixelStyle", "hasBytedata", "showsPixelData", "hasByteDATA"], "inflate": ["inflace", "invenATE", "Inflation", "inFlate", "inflating", "infolode", "insvenate", "inFlation", "insvenATE", "invenode", "insvenating", "inflated", "Inflated", "inadequode", "inadequate", "inffation", "invenate", "insflate", "inflATE", "Inflate", "infloated", "inFlated", "infface", "InFlate", "insflATE", "Inflace", "InFlace", "inadequATE", "insflating", "inFlace", "infloate", "InFlation", "infloation", "insvenode", "inflode", "infolATE", "infloace", "inffate", "infolate", "inflation", "invenating", "inadequating", "InFlated", "insflode", "infolating", "inffated"], "pxlen": ["mxlen", "pxsize", "mxdata", "fxlen", "pgLen", "mxcount", "pgl", "fxden", "pxdata", "fxl", "axlon", "pxl", "pxlength", "pxlon", "pnglength", "xpsize", "pplen", "mxsize", "txlon", "axln", "pclin", "camlen", "pxLen", "camdata", "fxLen", "pxden", "pglen", "pxcount", "pxpos", "fxpos", "pclen", "txlen", "pxln", "pxlin", "campos", "txln", "fxdata", "pclon", "camln", "txlin", "xplen", "xplength", "fxln", "axlin", "ppden", "mxlength", "ppl", "pgden", "pnglen", "ppLen", "pngsize", "mxpos", "pngcount", "axlen", "xpcount", "mxln", "pcln"], "out": ["sys", "v", "error", "OUT", "outs", "cache", "gen", "re", "output", "io", "log", "session", "conn", "obj", "state", "lock", "err", "Out", "step", "lib", "user", "again", "parent", "co", "query", "list", "pad", "post", "copy", "point", "store", "cli", "line", "work", "up", "server", "page", "dump", "group", "inter"]}}
{"id1": "3266833", "id2": "693636", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "label": 0, "substitutes": {"is": ["us", "im", "iv", "ais", "ins", "ip", "ib", "iso", "was", "has", "id", "isa", "IS", "bis", "ws", "Is", "es", "abs", "ir", "cms", "ris", "image", "ios", "iss", "os", "or", "i", "info", "lis", "fits", "isc", "isu", "close", "get", "iris", "its", "in", "init", "as", "bs", "mis"], "name": ["address", "url", "base", "description", "alias", "title", "ame", "id", "nice", "term", "Name", "one", "path", "space", "default", "filename", "string", "named", "word", "domain", "image", "no", "size", "prefix", "database", "memory", "this", "large", "code", "vision", "type", "format", "connection", "null", "n", "NAME", "parent", "directory", "office", "version", "min", "key", "search", "data", "source", "file", "pass", "value", "names", "part", "label", "module"], "contentType": ["ContentType", "ContentInfo", "outputType", "sourcetype", "outputName", " contentPoint", "sourceType", "documentType", "contentInfo", "contentName", "ContentPath", "documenttype", "outputTypes", "mediaName", "mediaTypes", " contentInfo", "messageType", " contenttype", "Contenttype", " contentName", "messagetype", "messageName", "ContentTypes", "contenttype", "mediaPath", "documentInfo", "contentPoint", "contentTypes", "documentPoint", "ContentName", "sourceInfo", "mediaType", "messageInfo", "sourcePoint", "contentPath", "outputPath"], "index": ["position", "address", "error", "level", "id", "inc", "none", "x", "default", "include", "input", "pointer", "string", "length", "offset", "end", "image", "write", "multi", "prefix", "axis", "expression", "type", "i", "number", "shape", "body", "pull", "slice", "weight", "list", "Index", "update", "alpha", "depth", "height", "timeout", "key", "content", "search", "page", "in", "data", "append", "width", "fix", "value", "open", "size"], "extension": ["configensions", "variensions", "Extensions", "configuration", "variance", "configension", "variuration", "Extension", "variension", "Extance", "extance", "Exturation", "exturation", "configance", "extensions"], "isImage": [" isFile", "isaFile", " isVideo", "asFile", "isaImage", "isInstance", "IsImage", "areimage", "ISFile", " isimage", " isInstance", "isimage", " isMedia", "ISImage", "isaMedia", "areImage", "asimage", "isVideo", "IsVideo", "ISVideo", " isImages", "areMedia", "isMedia", "areInstance", "isPicture", "asImage", "isFile", "ISPicture", "areFile", "IsFile", " isPicture", "IsPicture", "asInstance", "areImages", "isaImages", "isImages"], "isAux": ["isAAux", "isAcUX", "isUex", "isWaux", " isAxt", " isAx", "isWax", " isAUX", "isArrayru", "isAnux", "isAAru", "isAcxt", "isUlux", "isAsux", "isAAxt", "isAx", "isArrayUX", "isArrayux", "isWaUX", "isAAUX", " isHax", "isAslux", " isArrayux", "isAsex", "isAsUX", "isUUX", "isUux", "isAExcept", " isHaux", "isHaux", "isAnex", "asAsex", "isAex", "asAsUX", "asAsux", "isHax", "isUExcept", "asAux", "isAxt", "isAnlux", "isAnUX", "asAsExcept", "isOAlux", "isOAux", "isAlux", "isWalux", "isAsx", "asAExcept", "isHalux", "isAcux", "isAsExcept", "isOAExcept", "isOAUX", "asAex", "isArrayxt", "isAcru", " isArrayUX", " isHalux", "isHaUX", " isAlux", "asAlux", " isHaUX", " isAru", "isAUX", "isAru", "asAUX", " isArrayxt", "asAslux", " isArrayru"], "out": ["exec", "result", "base", "error", "OUT", "client", "outs", "cache", "project", "output", "exp", "io", "input", "auto", "conn", "ext", "inner", "word", "obj", "image", "next", "prefix", "off", "this", "Out", "plain", "extra", "at", "a", "user", "ex", "object", "again", "null", "o", " in", "over", "parent", "sync", "socket", "post", "outer", "array", "table", "version", "buffer", "copy", "in", "page", "data", "pool", "file", "up", "work", "source", "part", "size", "temp"], "bufferedImage": ["buffledimage", "BufferingImage", "bufferingImage", "buffledImage", "buffendedimage", "BufferedImage", "bufferingimage", "Bufferedimage", "buffendedImage", "bufferedimage", "Bufferingimage"], "inputStream": ["InputSteam", "outputBuffer", "inputstream", "outputStream", " inputSteam", "Inputstream", "inputSteam", "inputBuffer", " inputstream", "outputstream", "InputBuffer", "InputStream", " inputBuffer", "outputSteam"]}}
{"id1": "2518655", "id2": "12380475", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fnOut": ["fpOUT", "fnFile", "FNOutput", "fnIn", " fnEx", "lsOut", " fnIn", "fpOutput", "fpFile", "lsFile", " fnOUT", "fpOut", " fnFile", "FNIn", "fnOutput", "FNOut", "lsOUT", "fpIn", "fnOUT", "lsOutput", " fnOutput", "fpEx", "fnEx", "FNEx"], "writer": ["wa", "wire", "writ", "reader", "builder", "w", "output", "war", "worker", "ws", "ler", "er", "out", "inner", "driver", "word", "winner", "writing", "write", "widget", "wr", "editor", "layer", "Writer", "riter", "r", "a", "handler", "per", "walker", "socket", "loader", "nw", "outer", "parser", "buffer", "key", "fd", "work", "server", "entry", "file", "usher", "director", "writers", "temp"], "i": ["qi", "v", "z", "k", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "li", "ui", "u", "s", "hi", "multi", "ci", "c", "si", "mi", "phi", "ii", "m", "j", "type", "ie", "ori", "b", "n", "o", "bi", "ri", "uri", "p", "strength", "key", "gi", "h", "fi", "abi", "ix", "oi", "di", "chi", "ji", "part", "f", "pi"], "fInput": ["sfOutput", "sfinput", "fileinput", " fFormat", "fileFormat", "fFormat", "fileOutput", "fileInput", " fOutput", "fileSource", "fOutput", " fSource", "sfSource", "fSource", " finput", "finput", "sfFormat", "sfInput"], "in": ["gin", "ins", "reader", "din", "IN", "login", "bin", "id", "isin", "inc", "vin", "ini", "input", "out", "In", "s", "conn", "inner", "ln", "c", "inas", "connection", "b", "n", "scan", "again", "sin", "socket", "ner", "nin", "win", "inn", "version", "min", "pin", "line", "lin", "data", "cin", "inside", "kin", "init", "rin", "reading", "f"]}}
{"id1": "23118425", "id2": "932225", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 1, "substitutes": {"encrypt": ["encipher", "Encrypt", "encrypted", "Encipher", " Enccrypt", "enrypted", " Encipher", "enrypt", "Enccrypt", " Encrypt", "Encrypted", " Encrypted", "enccrypt", "enipher"], "plaintext": ["plainsource", "flatsource", "flatstring", " plainText", "plainstring", " plainstruct", " plainsource", "flattext", "protectedText", "plainText", " plainstring", "plainstruct", "broadsource", "broadText", "flatstruct", "flatText", "broadtext", "protecteddata", "plaindata", "flatdata", "broadstring", " plaindata", "protectedtext", "protectedstruct"], "md": ["mad", "MD", "mc", "dig", "sha", "ms", "metadata", "pm", "bd", "amd", "db", "am", "mo", "meta", "mb", "mt", "cmd", "hd", "pkg", "code", "mand", "m", "dd", "Cmd", "ph", "od", "mg", "mm", "message", "ma", "dc", "cd", "pd", "kg", "ad", "wd", "mac", "mp", "hm", "pg", "mod", "data", "dh", "ld", "d", "mag", "nm", "vd", "dm", "mem", "mu", " MD", "material"], "raw": ["dec", "wrap", "unsigned", "clean", "ng", "local", " hex", "RAW", "feed", "load", "row", " RAW", "input", "binary", "stream", "rew", "original", "image", "hex", "serial", "custom", "Raw", "def", "null", "buf", "unknown", "empty", "enc", "block", "pack", "message", "array", "buffer", "content", "channel", "shared", "instance", "full", "initial", "ack", "response", "partial"], "hash": ["url", "base", "sha", "header", "ash", "cache", "rh", "id", "Hash", "log", "row", "string", "kh", "image", "hex", "code", "auth", "build", "crypt", "html", "text", "empty", "block", "her", "message", "array", "version", "buffer", "key", "h", "mac", "data", "password", "secret", "value", "full", "sum", "response"]}}
{"id1": "20568568", "id2": "1586662", "code1": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "code2": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"createHTML": ["newPDF", "createH", " createH", " createCSS", "newHTML", "createCSS", "newH", "CreateH", "CreatePDF", "CreateHTML", "newCSS", " createPDF", "createPDF", "CreateCSS"], "requestPage": ["returnPage", "requestResult", " requestPC", "RequestResult", " requestRequest", " requestResult", "Requestpage", " requestPages", " requestpage", "requestPages", "pagePC", "pageResult", "returnRequest", "returnpage", "thisPages", "requestRequest", "RequestPC", "RequestPage", "pagepage", "thisRequest", "requestPC", "requestpage", "returnPages", "pagePage", "thisPage", "thispage"], "result": ["complete", "feature", "test", "header", "error", "description", "cache", "status", "output", "answer", "comment", "mark", "valid", "replace", "Result", "res", "string", "ret", "section", "err", "success", "results", "compl", "order", "event", "menu", "info", "report", "html", "root", "future", "diff", "message", "date", "resource", "detail", "content", "document", "page", "cup", "match", "data", "up", "our", "summary", "figure", "value", "json", "part", "sum", "color", "response", "msg"], "url": ["base", "feed", "io", "URL", "path", "sl", "fl", "Url", "host", "string", "name", "ls", "gl", "image", "link", "resources", "hub", "org", "ssl", "connection", "r", "class", "b", "ll", "pull", "loader", "buffer", "uri", "service", "resource", "bel", "http", "plug", "l", "in", "source", "file", "data", "up", "download", "server", "page", "src", "channel", "web", "f"], "ins": ["gin", "reader", "din", "outs", "ints", "ts", "inc", "bis", "Ins", "ws", "vs", "alls", "ks", "abs", "ls", "s", "ris", "lines", "inner", "inas", "fe", "ios", "als", "r", "rows", "vals", "ans", "ps", "ats", "plugins", "pins", "ds", "fs", "inn", "INS", "its", "ips", "is", "ains", "in", "lin", "ens", "qs", "kin", "src", "rss", "as", "limits", "bs", "cons", "ils"], "bufferedReader": ["BufferedRead", " buffenedWriter", "BuffererWriter", "buffererWriter", "BuffererReader", "buffaredIn", "BuffererRead", "buffererStream", "bufferedWriter", " bufferedWriter", "BufferedStream", " buffenedStream", "buffenedStream", "buffenedWriter", "buffledWriter", "bufferedIn", "bufferingWriter", " buffenedReader", "buffererReader", "buffaredWriter", "bufferingRead", " bufferedIn", " buffenedIn", "buffererRead", "buffaredReader", "buffaredStream", "bufferedRead", "BuffererStream", "BufferedReader", "bufferingStream", "buffenedIn", "buffledReader", "buffledRead", " bufferedStream", "bufferedStream", "buffenedReader", "bufferingReader", "buffledIn", "buffledStream", "BufferedWriter"], "cssLine": ["csvline", "csvBlock", "cssL", "styleLine", "cssStr", "CSSline", "csvStr", "ssL", "cssline", "CSSL", "CSSLine", "urlL", "rssBlock", "ssBlock", "styleline", "CSSRow", "csvLine", "cssRow", "ssline", "rssline", "styleBlock", "urlRow", "rssLine", "cssFile", "urlline", "ssLine", "cssBlock", "styleFile", "rssFile", "styleStr", "ssStr", "urlLine", "ssFile", "ssRow"], "e1": ["e9", "er3", " eone", "Eone", "ea2", "eone", "er1", " e3", "e8", "erone", "me1", "E9", "ae1", "ae8", "eOne", "me2", "er2", "ea9", " e9", "E3", "E2", "E1", "e3", " eOne", " e2", "eaone", "e2", " e8", "ea1", "me8", "meOne", "ae2", "aeOne"], "queryZoom": [" queryzooming", "queryzoom", "querySlooming", "queryXoom", " queryzoo", " queryZoo", "queryZooming", "queryExom", "queryzooming", "queryExooming", " queryzoom", "queryZoo", "queryzoo", "querySlom", "queryScooming", "queryXom", " queryzom", "querySloom", "queryScom", "queryScoom", "queryzom", "queryZom", " queryZooming", "queryXooming", "queryXoo", " queryZom", "queryExoo", "queryExoom"], "appendToHome": [" appendOnBack", " appendOnPage", "appendToRoot", "appendToBack", " append2Home", " appendFromHome", " appendFromRoot", "appendFromBack", " appendOnHome", " append2Back", " appendToPage", " appendToBack", " append2Root", " appendFromPage", "appendFromRoot", "appendToPage", " append2Page", " appendToRoot", " appendOnRoot", "appendFromHome", "appendFromPage", " appendFromBack"], "sql": ["sys", "csv", "sv", "base", "params", "job", "eps", "str", "dl", "id", "QL", "shell", "db", "log", "SQL", "res", "string", "conn", "pr", "seed", " SQL", "lock", "setup", "database", "ssl", "sq", "ql", "vals", "printf", "body", "query", "general", "table", "col", "expr", "details", "statement", "serv", "comment", "select", "msg"], "pstmt": ["psthmt", "pscct", " posttr", "pscm", "pft", "psthmd", "pctm", "Pctct", "pctt", "pptct", "postmp", "Pstnt", "pcttr", "pspmt", "pscmd", "Pctnt", " pstmd", "pfnt", "pscmt", "pstrct", " pscmt", " pstm", "pstrmt", "pstrt", " pstmp", "posttr", " pstct", "pstmd", "pstrnt", " pscpt", "postmt", " postmp", "pscpt", "pstnt", "Pstt", "pstm", "pstmp", "pspm", "pstt", "pctmt", "pfct", " pstpt", "psppt", "pctpr", " pscct", "pstpr", "psthpt", "psthct", " postmt", "pspmd", "pctmp", " pstpr", "Pctmt", "pstpt", "psthm", "pctct", "pptmt", "psttr", "postct", " pscpr", "Pstmt", "pptmp", "ppttr", " pscmd", "Pctt", " pscm", "pstct", "psthpr", " postct", " psttr", "pfmt", "pscpr", "Pstct", "pctnt"], "rs": ["relations", "mr", "sr", "eps", "rm", "rr", "RR", "res", "ks", "pr", "ls", "ris", " RS", "RS", "results", "rt", "pps", " res", "errors", "ras", "r", "rows", "cs", "ops", "runs", " Rs", "ps", "ars", "ows", "ds", "Rs", "LS", "rb", "dr", "rc", "qs", "RC", "rss", "details", "bs", "rl", "rd"]}}
{"id1": "7757297", "id2": "3945236", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"submit": ["complete", "send", "save", "login", "apply", "sub", "request", "input", "start", "write", "success", "type", "report", "update", "post", "Submit", "close", "form", " submission", "process", "accept", "execute", "init", "download", "register", "open", "run"], "uri": [" Uri", "address", "base", "description", "absolute", "id", "io", "URL", "iri", "path", "xml", "plugin", "Url", "filename", "location", "string", "ui", " URI", " ur", "database", "username", "format", "duration", "i", "report", "route", "text", "directory", "ri", "message", "resource", "api", "URI", "http", "href", "cli", "data", "file", "server", "source", "response"], "Exception": ["End", "Application", "Event", "Null", "Exit", "ceptions", "Transaction", "Except", "Response", " exception", "A", "Ex", "Exc", "Connection", "Problem", "ception", "Description", "except", "Document", "Adapter", "Request", "Error", "Timeout", "Record", "Interface"], "encodedrdf": ["encodedrre", "encodingwdbf", "encodedwdf", "encodedrde", "encodedudef", "encodedude", "encodingwdF", "encodingwdf", "encodeudrf", "encodedvrf", "encodeudef", "encodedwde", "encodingwdrf", "encodedrdef", "encoderdef", "encodedrtrf", "encoderde", "encodingrdrf", "encodedrrf", "encodedrdrf", "encodedvrF", "encodedwdbf", "encodedrdF", "encodedwdF", "encoderdrf", "encodingrdf", "encodeude", "encodedvrrf", "encodedrtf", "encodedvrbf", "encodedrtF", "encoderdf", "encodedwdrf", "encodeudf", "encodedudf", "encodingrdF", "encodedwdef", "encodingrdbf", "encodedrtbf", "encodedrref", "encodedrdbf", "encodedrrrf", "encodedudrf"], "url": ["address", "position", "base", "client", "job", "use", "URL", "proxy", "path", "Url", "session", "connect", "conn", "string", "name", "contact", "location", "image", "link", "database", "ssl", "user", "Connection", "text", "config", "loc", "socket", "service", "resource", "http", "l", "page", "source", "file", "server", "channel", "open", "control", "relation"], "connection": ["position", "client", "connected", "use", "io", "URL", "proxy", "function", "connect", "session", "conn", "string", "contact", "context", "driver", "section", "c", "link", "database", "character", "org", "or", "communication", "writer", "Connection", "application", "text", "n", "b", "directory", "number", "handler", "config", "loc", "socket", " Connection", "service", "version", "condition", "document", "http", "l", "in", "source", "channel", "server", "password", "con", "open", "response", "relation"], "lastUser": ["LastUser", " lastCategory", " lastRow", "latestRow", "LastRow", "latestCategory", "lastWord", "lastCategory", "latestUser", " lastWord", "latestWord", "LastWord", "lastRow", "LastCategory"], "out": ["external", "error", "outs", "cache", "window", "log", "name", "conn", "doc", "off", "plain", "global", "writer", "at", "flush", "data", "file", "server", "full", "part", "client", "check", "cmd", "word", "lock", "write", "prefix", "down", "Out", "user", "o", "wrapper", "key", "in", "page", "pool", "cli", "password", "dump", "comment", "result", "OUT", "w", "login", "call", "io", "obj", "inner", "err", "no", "editor", "extra", "again", "list", "socket", "outer", "office", "copy", "temp", "exec", "builder", "output", "bin", "view", "exp", "image", "sync", "commit", "line", "up", "init", "req"]}}
{"id1": "23402240", "id2": "16590954", "code1": "    public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo\" + \" SET  numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"actualizarNdivisiones": [" actualizarNiones", " actualizarMdivisione", " actualizarNionis", " actualizarMdive", " actualizarNdivisione", " actualizarNione", " actualizarNdives", " actualizarMdives", " actualizarMdivisionen", " actualizarNdivisionis", " actualizarNdivisionen", " actualizarNisionen", " actualizarNisionis", " actualizarMdivisiones", " actualizarNisione", " actualizarNdive", " actualizarMdiven", " actualizarNdivis", " actualizarMdivisionis", " actualizarMdivis", " actualizarNdiven", " actualizarNisiones", " actualizarNionen"], "idTorneo": ["idTordeoid", "idTendono", "idTenseof", "idTronof", "idTendone", "idTorneos", "idTensee", "idTornee", "idTenseo", "idTordeos", "idTorneof", "idTronos", "idFordee", "idFordeoid", "idTorneoid", "idTendonoid", "idFornee", "idTorioid", "idForneo", "idForneoid", "idTendonos", "idTrono", "idTordeof", "idTorie", "idTordee", "idFordeof", "idTordeo", "idTrone", "idFordeo", "idTorio", "idFordeos", "idTenseos", "idTorios", "idForneof", "idForneos"], "nDivisiones": ["nDIVisionES", "nDivione", "nDIVisionsales", "nDivitionES", "nDivitionions", "nDIVisionses", "nDivitionales", "nDIVisione", "nDivisione", "nDivisionsES", "nDIVisionse", "nDIVisiones", "nDivisionse", "nDivisionses", "nDiviones", "nDivionions", "nDivisionales", "nDivionES", "nDivisionES", "nDivitione", "nDivisionsions", "nDIVisionales", "nDivisionsales", "nDIVisionsES", "nDivionales", "nDivitiones", "nDivisionions"], "intResult": ["intReturn", "boolresult", "floatRes", " intresult", "INTRes", "colTr", "colRes", "floatTr", "ntResponse", "IntResponse", "ntTr", "intResponse", "colResponse", "INTResult", "IntResult", "intTr", "IntReturn", "ntRes", "boolResults", "colResult", "intresult", "intResults", " intResults", "ntResult", "boolReturn", "boolResult", "IntRes", "floatResponse", "floatResult", "intRes", " intRes", "floatReturn", " intResponse", " intReturn", "floatResults", "INTResponse", "floatresult", "INTReturn"], "sql": ["url", "base", "params", "job", "str", "dl", "zip", "QL", "shell", "db", "log", "SQL", "sl", "q", "conn", "string", "ls", "s", "cmd", "seed", " SQL", "section", "setup", "action", "database", "ssl", "sq", "repl", "ql", "printf", "query", "sync", "install", "pg", "l", "fn", "up", "pass", "serv", "comment", "select"], "connection": ["position", "lc", "mc", "client", "que", "cache", "port", "proxy", "container", "db", "environment", "function", "ctx", "index", "log", "connect", "BC", "conn", "context", "session", "tc", "section", "c", "database", "event", "communication", "ongo", "writer", "Connection", "application", "config", "loc", "socket", "query", "table", "condition", "document", "pg", "ion", "pool", "server", "coll", "con", "collection", "unit", "statement", "manager", "connected", "relation", "po"], "ps": ["processor", "params", "pa", "relations", "ms", "eps", "pse", "PS", "ts", "proxy", "rs", "proc", "vs", "pt", "ks", "pointer", "ls", "cp", "Ps", "settings", "os", "pps", "pe", "ppa", "cs", "par", "cop", "ups", "per", "ds", "pd", "p", "pg", "ips", "process", "qs", "pos", "pc", "script", "pp", "ss", "bs", "mp", "gs", "pr", "po"]}}
{"id1": "12428013", "id2": "414258", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"polishOff": [" synchronipeOn", " synchroniceOffline", " synchronishingOffline", " polishingOn", " synchronishingOn", " synchroniceDown", " polishingOffline", " synchronishingOff", " synchronipeOff", " synchronishOn", " synchronishOff", " polishOn", " synchronipeDown", " synchronishDown", " polishDown", " synchroniceOn", " polishingDown", " synchronipeOffline", " synchroniceOff", " synchronishOffline", " synchronishingDown", " polishOffline", " polishingOff"], "monitor": ["cm", "oper", "processor", "master", "mc", "stat", "mor", "client", "status", "controller", "pm", "port", "progress", "container", "cher", "log", "function", "conn", "core", "thread", "state", "driver", "umi", "callback", "image", "sm", "widget", "mon", "m", "or", "reason", "component", "duration", "username", "report", "counter", "method", "number", "watch", "object", "program", "directory", "body", "handler", "config", "loader", "period", "update", "message", "timeout", "condition", "meter", "consumer", "don", "match", "clock", "member", "dm", "annot", "timer", "unit", "runner", "control", "manager", "Monitor", "module"], "from": ["actor", "address", "url", "false", "base", "vol", "left", "id", "ou", "path", "owner", "remote", "host", "start", "name", "string", "contact", "range", "action", "prefix", "code", "org", "or", "small", "username", "at", "type", "connection", "component", "user", "route", "front", "with", "back", "loc", "uri", "attribute", "resource", "add", "by", "form", "who", "source", "channel", "server", "since", "email", "From", "about", "origin", "part", "size", "ce"], "to": ["su", "two", "address", "url", "eto", "base", "token", "site", "left", "io", "remote", "TO", "target", "location", "name", "out", "top", "range", "prefix", "database", "toc", "type", "repl", "info", "go", "connection", "user", "To", "so", "o", "with", "dest", "table", "uri", "version", "resource", "by", "key", "into", "source", "server", "file", "pos", "ref", "about", "value", "full", "until", "reply", "size", "po"], "renameTo": ["relameTo", "relenameUrl", "reageTO", "renseTo", "renalto", "renamelTo", "renseFor", "renAMEUrl", "renributeTo", "renAMEToken", "reameTO", "renewTarget", "renAMETo", "renageToken", "renenameUrl", "renamelOf", "renAMETarget", " RenAMEWill", " RenameFor", "renamelFor", "rennameTarget", "reageto", "renseTO", "renokeUrl", "renokeOf", "renameUrl", "renokeTO", "renokeFor", "relenameTo", "renameFor", "rennameTo", "renseOf", "relameto", "relameFrom", "renenameto", " RenameOf", "renameto", "relameTarget", "renamTarget", " RenAMETo", "renameFrom", "renamWill", "renenameTarget", "renameToken", "relalFrom", "reameTo", "renributeWill", "renoketo", " renAMETo", "relalTo", "renageTO", "renenameTo", " renameTarget", "renalTo", "renalFrom", "renalTarget", " RenseOf", "rennameto", " RenseFor", " renAMEFrom", "relameUrl", "renAMETO", "rennameFrom", "renewTo", "renageto", "renAMEFrom", "renalTO", "relalto", "reameToken", "renageTo", "relenameto", "renameWill", "reameto", " RenAMEFor", "renameTarget", "relalTarget", "renamFor", "reageTo", "renameOf", "renokeFrom", "renributeTarget", "renAMEto", "reageToken", " RenAMETarget", " RenameTarget", " RenameWill", "relenameFrom", "renalToken", "renributeFor", "renameTO", "renAMEWill", " RenseTo", "renenameFrom", " RenseTO", " renAMETarget", "renewFrom", "renokeTo", "renamelTO", " RenameTo", " RenameTO", "renamTo", "renAMEFor", " renameFrom"], "ftpClient": ["ftpCommunity", "ftpChannel", "ftcpChannel", " ftapiCloud", " fttpClient", "ctcpServer", " ftlClient", "ftmClient", " ftpoCenter", "ftcpResource", " ftiServer", " ftiClient", " ftpCloud", "ftpsContainer", "aftpStream", "ftbCan", " ftpiChannel", " ftapiClient", "ftfClient", "ftlCommunity", "ftpcClient", "ftcpCenter", "fttpStream", "ctpChannel", " ftpoClient", " ftapiHelper", " ftpContainer", " ftpclient", "ftfCenter", "ftpclient", "ftpcCommunity", " fttpContainer", " ftpiServer", "ftoHost", "ftpiServer", "ftcpCommunity", "ftfCloud", "fticlient", "ftcGuest", "ftlConnection", "ftoCan", "ctcpResource", " ftpChannel", "ftpoCenter", "ftcpCloud", "ftlCenter", "ftpiClient", "ctpResource", "ftpcServer", " ftpHelper", "ftcServer", "ftpGuest", "ftpcHelper", "ftfpCloud", "ftpiHost", "ftpsControl", "ftcpGuest", "ftbHost", "ftfpChannel", "ftpsClient", " ftpGuest", " ftoCan", "ftapiServer", " fttpClass", "ftcpClient", " ftnServer", "ftnHost", "afttClient", " ftpHost", "ftfpResource", "ctpServer", "ftcClient", "ftmResource", " ftnHost", " ftiGuest", "fttpHost", "ftfpServer", "afttStream", "ftiGuest", " ftlCommunity", "ftcpConnection", "ftcpHost", "ftpoCloud", "ftcpServer", "fttpContainer", "ftpoClient", "ftpsClass", " ftoServer", "fttpClass", " ftpServer", "ftfpClient", "fttpControl", " ftpConnection", "ftpResource", "ftpcControl", "ftmChannel", " ftapiServer", "ftpConnection", " ftpClass", "aftpClient", "ftapiHelper", " ftpControl", " ftpiHost", " ftnClient", "ctcpClient", "ftpHost", "ftfpCenter", "ftbServer", "ftpcClass", " ftpCenter", "ftmServer", "ftbrClient", "ftapiClient", "ftnServer", " fticlient", "ftpCloud", "fttClient", "ctcpChannel", "ftcpHelper", "ftoClient", "ftiClient", "ftiServer", "ftbClient", "fttStream", "ftbrStream", "ftoServer", " ftpCommunity", "ftcclient", "ftnClient", "ftpClass", "ftpcContainer", " ftpCan", "ftpcCloud", "fttpCan", "ftpStream", " ftoHost", " ftpiClient", "fttpChannel", "ftpiChannel", "fttpClient", " ftlConnection", "ftpServer", "ctpClient", "ftcpclient", "fttpServer", "ftpcConnection", " fttpControl", "ftpHelper", "ftpContainer", " ftpoCloud", " ftlCenter", "ftpCan", "ftapiCloud", "ftpCenter", "ftlClient", "ftpcCenter", " ftoClient", "ftpControl"], "ftpHolder": ["ftpWather", "fttpChard", "ftpWholder", "ftpcWolder", "ftphander", "fttpChander", "ftphholder", "ftphold", "ftpSholder", "fttpHook", "ftpChard", "ftpWolder", "ftpWorkather", "ftpcHather", "ftpHander", "ftpholder", "ftpShander", "ftpcHold", "ftpShard", "ftpShook", "ftpHook", "ftpWorkholder", "ftpcWather", "ftpHholder", "fttpHolder", "ftpCholder", "ftpcWholder", "ftpHather", "ftphather", "ftpHold", "fttpHander", "ftpChook", "ftpWorkolder", "ftpHard", "ftpChander", "fttpChook", "fttpCholder", "ftpcHolder", "ftpWorkold", "ftpWold", "fttpHard", "ftphard", "ftphook", "ftpcWold", "ftpcHholder"], "iter": ["ser", "oper", "result", "ipper", "iv", "ip", "ver", "collect", "ter", "chain", "reader", "itter", "enter", "finder", "e", "id", "ator", "inc", "skip", "cher", "index", "er", "former", "keep", "ir", "end", "inner", "set", "next", "err", "Iterator", "or", "ite", "i", "info", "over", "loc", "list", "walker", "gener", "ner", "outer", "it", "iterator", "its", "http", "in", "entry", "file", "izer", "init", "Iter", "limit", "coll", "size", "inter", "f", "ener"], "element": ["air", "ele", "e", "section", "empty", "option", "attribute", "document", "data", "article", "letter", "server", "coll", "value", "atom", "part", "header", "token", "child", "Element", "folder", "environment", "er", "input", "action", "or", "event", "component", "et", "definition", "number", "object", "key", "page", "match", "activity", "comment", "item", "cell", "result", "reader", "el", "container", "inner", "entity", "editor", "layer", "parent", "per", "resource", "content", "email", "variable", "member", "module", "output", "owner", "plugin", "node", "ee", "next", "this", "expression", "type", "connection", "text", "service", "optional", "line", "entry", "style", "instance"]}}
{"id1": "20011285", "id2": "19687456", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 1, "substitutes": {"copy": ["share", "save", "delete", "apply", "change", "rm", "transfer", "zip", "load", "Copy", "replace", "log", "py", "cp", "write", "link", "upload", " cp", "clone", "type", "cop", "sync", "update", "clip", "get", "move", "file", "download", "create", "split", "cat", "paste", "opy"], "sourceFile": [" sourceDir", "targetFiles", "ourceDirectory", "apiFILE", "sourceFiles", "slaveFILE", "apiFilename", " sourceTime", "slaveFile", "sourceTime", "targetFolder", " sourcePlace", "sampleFiles", " sourceFolder", "targetDir", "ourcePage", "ourceFile", "sourceFolder", "targetFile", "sourcePage", " sourceFiles", " sourcePage", " sourceFILE", "sourceFILE", "sourceFilename", "SourceSourceFile", "ourceFiles", "sourceSourceFile", "ourceBook", " sourcefile", "SourceDirectory", " sourceDirectory", "siteFiles", "ourceTime", "sourceBook", "SourceFile", "ourcefile", "targetPage", "sourcefile", "SourcePlace", "apiFiles", "ourceSourceFile", "SourceDir", "SourceTime", "targetDirectory", "sampleFilename", "sampleFile", " sourceSourceFile", " sourceBook", "sampleFILE", "SourceBook", "sourceDirectory", " sourceFilename", "siteFilename", "apiFile", "Sourcefile", "siteFile", "siteFILE", "slaveFiles", "slaveFilename", "SourceFiles", "sourceDir", "sourcePlace", "ourceFolder", "ourcePlace"], "destinationFile": ["destructionFolder", " destinatingfile", "targetinationfile", "DestinatingSourceFile", "targetinationFiles", "destinatefile", "targetinationFolder", "destinatorFILE", "destinatorSourceFile", "destwayfile", "destinatingPath", "DestinatingFile", "distinationFile", "dominatorFile", "destuationFILE", "destinateFolder", "desturationFiles", "destinatedFiles", "destinatingFile", "destuationfile", "dominationPath", "DestinationFile", "targetinatedFile", "destinationFILE", "destinatingFolder", "destwayFile", "distinationfile", "dominatorPath", "destinatorFiles", " destinationFiles", "destinatorPath", "destwayFiles", "DestinatingFiles", "destinatorDirectory", "dominatorfile", "destructionFile", "destuationFolder", "destinateFiles", "destinationDirectory", "destructionfile", "destinatorfile", "targetinatedFiles", "DestinatingDirectory", "destinatedFile", " destinationfile", "destinatingfile", "destinatorFolder", "dominatorFiles", "destinatorFile", "distructionfile", "destinationPath", "destinateFile", "destinatedFolder", "dominationfile", "desturationDirectory", "distinationFILE", "distinationFolder", "destinationFolder", "destuationFile", "destinatingSourceFile", "desturationFile", "destinatingFiles", "distructionFolder", "DestinationSourceFile", "destinationFiles", "targetinatedFolder", "DestinationFiles", "distructionFILE", "destinatePath", "destinationSourceFile", " destinationFolder", " destinatingFolder", "DestinationDirectory", "destinatingDirectory", "dominationFiles", "destwayFILE", " destinatingFile", "distructionFile", "destinatedfile", "destructionFILE", "dominationFILE", "dominatorFILE", "destinationfile", "desturationSourceFile", "targetinationFile", "destinatingFILE", "dominationFile", " destinatingFiles", "targetinatedfile"], "tmp": ["csv", "v", "stuff", "ip", "st", "img", "params", "amp", "cache", "tp", "sup", "bb", "e", "rm", "zip", "current", "nb", "db", "folder", "mo", "py", "fb", "flat", "temp", "meta", "mb", "obj", "tab", "upload", "files", "np", "storage", "t", "dat", "ppa", "buf", "dest", "handler", "slice", "list", "diff", "mm", "apps", "array", "media", "api", "p", "rb", "page", "data", "pty", "dir", "vm", "pos", "pp", "area", "split", "sp", "part", "txt", "mp", "cmp", "po"], "f": ["uf", "fp", "v", "cf", "xf", "e", "io", "x", "df", "tf", "rf", "fb", "fl", "u", "c", "this", "fe", "fa", "m", "t", "j", "fx", "info", "r", "g", "b", "o", "F", "ff", "handler", "fc", "fr", "fs", "inf", "p", "fo", "fi", "fd", "af", "lf", "l", "fn", "file", "d", "bf", "full", "conf"], "i": ["qi", "v", "lc", "ip", "ai", "ti", "vi", "I", "e", "id", "io", "iu", "xi", "x", "index", "start", "name", "li", "u", "s", "ui", "hi", "multi", "ci", "c", "si", "ij", "ii", "m", "y", "j", "ie", "info", "b", "n", "o", "bi", "ri", "uri", "p", "gi", "key", "h", "fi", "ix", "in", "oi", "di", "l", "d", "ji", "pi"], "source": ["ource", "slave", "result", "base", "client", "reader", "cache", "grade", "scope", "view", "site", "e", "use", "force", "current", "proxy", "io", "id", "sl", "input", "target", "ge", "start", "core", "secure", "stream", "Source", "this", "si", "storage", "component", "ie", "connection", "null", "parent", "back", "slice", "diff", "uri", "service", "resource", "wrapper", "get", "from", "server", "src", "ce", "SOURCE"], "destination": ["generination", "destinator", "Destinated", "estinate", "destinating", "estinator", "combinating", "combinated", "Destination", "partinator", "combination", "partination", " destinator", "partation", "combinate", "destation", "Destation", "destinate", " destinated", " destation", "generinate", "destinated", "estinating", "estination", "Destinate", "generinator", "partinated", "combinator", "generinated", "Destinating", "Destinator"]}}
{"id1": "23246123", "id2": "9687813", "code1": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"createDialogArea": ["createDialogPanel", " createButtonarea", " createHelpPanel", "createControlPanel", "createEditorArea", "createMessagearea", "createDialogGroup", "createHelpArea", " createDialogPanel", " createHelparea", " createButtonGroup", " createButtonArea", "createMessageArea", "createHelparea", "createHelpPanel", " createDialogarea", "createEditorarea", "createButtonarea", "createControlArea", "createEditorGroup", "createDialogarea", "createControlarea", "createHelpGroup", " createDialogGroup", "createMessagePanel", "createButtonArea", " createHelpArea", "createButtonGroup"], "parent": ["cl", "client", "panel", "builder", "sup", "port", "current", "child", "container", "host", "parents", "context", "section", "image", "c", "this", " sup", "comp", "self", "component", "menu", "connection", "g", "class", "null", "object", "root", "parser", "clip", "message", "resource", "p", "wrapper", "document", " child", "page", "instance", "Parent", "ctx", " scene"], "composite": ["Compositing", "complexiting", "comvalitor", "complexitable", "compposites", "compositionitor", "comositable", "Composite", "complexites", "compositive", "Complexitable", "comPOSitable", "Compositable", "compositionited", "compposited", "complexitor", "comosited", "comvalitive", "compositionites", "complexite", "Complexite", "Complexites", "comppositable", "composited", "compositor", "comppositive", "comppositionited", "compposite", "comPOSiting", "comPOSite", "comppositionitor", "compositable", "Composites", "compositing", "comppositionitive", "comvalite", "compositionite", "comppositionitable", "compositionitive", "comosite", "comppositor", "compositionitable", "comppositionite", "comPOSited", "Complexiting", "comvalites", "complexitive", "comPOSites", "compositioniting", "comppositionites", "composites", "comosites"], "content": ["complete", "exec", "cm", "address", "cont", "header", "client", "title", "output", "app", "comment", "feed", "load", "child", "model", "container", "xml", "folder", "plugin", "host", "context", "conn", "cms", "scroll", "section", "image", "code", "layer", "format", "component", "connection", "report", "html", "application", "object", "config", "loader", "message", "media", "resource", "version", "Content", "document", "copy", "page", "ez", "source", "server", "file", "create", "json", "activity", "control", "cell"], "ncol": ["nbCol", "numrow", " nblock", "Ncolumn", "Ncol", " nCol", " nrow", " ncolumn", "numcolumn", "pCol", "nbrow", "ncolumn", "Nblock", "pcol", "NCol", "numCol", "nCol", "nbcolumn", "nbcol", "pcolumn", "numcol", "pblock", "nblock", "nrow"], "layout": ["shadow", "flow", "address", "lc", "position", "base", "follow", "view", "feed", "zip", "model", "container", "xml", "font", "nl", "design", "flat", "holder", "location", "ui", "offset", "scroll", "section", "image", "lock", "widget", "where", "build", "layer", "shape", "join", "config", "edit", "list", "block", "padding", "Layout", "alpha", "mount", "scale", " layouts", "translation", "grid", "l", "lay", "data", "entry", "inline", "nav", " Layout", "figure", "draw", "board", "group", "closure", "split", "control"], "numColumns": ["numColes", "numControles", "nbcolumnows", "nbColumns", "numControln", "numcolumnn", "nbColumnes", "nbColumnn", "numColumnows", "numColumnes", "numColows", "numcolumnes", "numControlows", "nbcolumnn", "nbcolumns", "numcolumnows", "nbcolumnes", "numcolumns", "numColn", "numControls", "numCols", "numColumnn", "nbColumnows"], "browser": ["shadow", "ger", "feature", "test", "chrome", "img", "ver", "client", "flash", "finder", "window", "br", "sim", "comment", "feed", "platform", "proxy", "io", "jar", "fire", "plugin", "design", "remote", "host", "session", "binary", "driver", "image", "bot", "facebook", "lib", "editor", "Browser", "river", "webkit", "ssl", "fox", "box", "report", "html", "root", "bar", "js", "front", "iframe", "mobile", "config", "loader", "graph", "css", "uri", "agent", "http", "cookie", "page", "cart", "vert", "roller", "server", "google", "nav", "coll", "theme", "runner", "open", "web", "book", "manager"], "text": ["atter", "test", " Text", "client", "title", "str", "output", "port", "feed", "term", "path", "font", "plugin", "label", "input", "abs", "string", "name", "ext", "binary", "struct", "driver", "inner", "context", "image", "select", "pdf", "off", "editor", "format", "element", "writer", "info", "connection", "report", "user", "ut", "object", "desc", "config", "message", "service", "it", "form", "Text", "data", "vert", "letter", "source", "entry", "unit", "txt", "comment", "TEXT"], "url": ["address", "base", "rel", "re", "id", "feed", "io", "URL", "zip", "path", "sl", "Url", "host", "string", "gl", "image", "ssl", "connection", "user", "www", "config", "pull", "ur", "uri", "service", "resource", "api", "lr", "bel", "http", "page", "l", "source", "server", "file", "download", "ref", "open", "web", "f"], "in": ["gin", "ins", "reader", "din", "IN", "w", "re", "str", "login", "el", "bin", "ar", "br", "inc", "xml", "x", "ini", "er", "input", "ic", "out", "In", "s", "conn", "inner", "stream", "on", "image", "err", "c", "or", "a", "i", "b", "again", "o", "rec", "nin", "ri", "fr", "resource", "inn", "p", "min", "it", "pin", "rb", "is", "dr", "data", "l", "rc", "lin", "arin", "init", "d", "rin", "pass", "serv", "f"], "r": ["vr", "reader", "rh", "re", "sr", "mr", "rel", "br", "ar", "right", "rr", "rf", "nr", "er", "res", "out", "ir", "hr", "cr", "err", "rw", "c", "rt", "or", "m", "i", "rg", "b", "rx", "kr", "o", "ner", "ri", "fr", "ur", "ru", "lr", "rob", "p", "rb", "h", "dr", "l", "rc", "R", "ro", "gr", "d", "rar", "rss", "f", "rl", "rs", "pr"], "sb": ["bc", "bj", "sv", "xb", "ib", "sr", "bb", "gb", "ob", "bp", " SB", "lp", "db", "bm", "nl", "fb", "mb", "abs", "s", "binary", "ls", "bsp", "sth", "sm", "si", "ruby", "storage", "sa", "sg", "ssl", "SB", "lb", "b", "library", "buf", "abb", "wb", "kb", "buffer", "lr", "rob", "eb", "sn", "ab", "rb", "lab", "usb", "pb", "bh", "src", "bf", "obb", "sp", "erb", "sf", "cb", "bs"], "line": ["cl", "lc", "header", "base", "str", "el", "comment", "id", "le", "nl", "sl", "row", "ge", "string", "name", "li", "Line", "obj", "lines", "end", "character", "code", "LINE", "i", "pe", "b", "n", "object", "block", "cle", "message", "key", "lf", "l", "data", "lin", "page", "col", "entry", "char", "source", "ne", "letter", "inline", "pass", "split", "part", "se", "record", "f", "cell", "stroke"], "e": ["oe", "de", "esi", "error", "exc", "ue", "ele", "ime", "ise", "one", "ea", "ge", "er", "es", "je", "te", "ee", "err", "E", "ef", "fe", "or", "en", "ec", "ie", "i", "pe", "ite", "ce", "ception", "o", "ale", "ae", "p", "ve", "me", "ev", "se", "ke", "d", "ne", "ze", "f", "le", "be"]}}
{"id1": "9872346", "id2": "18374478", "code1": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "code2": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "label": 0, "substitutes": {"readRemoteDocument": ["loadLocalDocument", "readExternaldocument", "readLocalDocuments", "loadLocalDocuments", "readExternalDocuments", "readLocalDocument", "loadRemoteDocuments", "readServerdocument", "loadLocaldocument", "loadRemotedocument", "readRemotedocument", "loadRemoteDocument", "readServerDocuments", "readExternalDocument", "readServerDocument", "readLocaldocument", "readRemoteDocuments"], "url": ["address", "position", "lc", "base", "client", "feed", "load", "URL", "path", "xml", "sl", "remote", "Url", "host", "location", "string", "name", "filename", "image", "link", "org", "layer", "username", "ssl", "user", "ll", "www", "config", "loc", "socket", "ur", "uri", "service", "resource", "version", "http", "store", "l", " URL", "source", "file", "server", "entry", "email", "download", "page", "channel", "rl", "f"], "validate": [" validating", " validated", "validation", "Valated", "veration", "Valation", "Valate", "verating", "verate", "verated", " validation", "validating", "validated", "Valating"], "document": ["result", "degree", "system", "project", "output", "metadata", "view", "port", "dict", "valid", "model", "container", "xml", "request", "df", "function", "index", "design", "session", "node", "location", "language", "material", "word", "image", "doc", "database", "expression", "application", "null", "object", "parent", "video", " documentation", "text", "graph", "Document", "message", "office", "media", "ocument", "resource", "service", "content", "page", "data", "source", "value", "collection", "record", "f", "response"], "factory": ["pault", "affluent", "duture", "efactory", "Factory", "filler", "Folver", "hiller", "piller", "dactory", "hade", "diller", "efixture", "efiller", "huture", "sfactory", "affixture", "pluent", "sfixture", "fixture", "pixture", "infactory", "infuture", "efluent", "infiller", " fFactory", "bixture", "sfluent", "fluent", "bluent", "FFactory", "fsactory", "sfault", "folver", "affactory", "bactory", "fault", "fFactory", "dade", "future", "pactory", "fsolver", " folver", "fsFactory", "hactory", "Filler", "fsiller", "infade", "fade", "affault", "biller", " filler"], "connection": ["position", "error", "client", "reader", "system", "cache", "builder", "union", "use", "port", "io", "proxy", "current", "container", "default", "function", "creator", "index", "connect", "session", "conn", "out", "context", "response", "driver", "section", "image", "c", "link", "database", "character", "communication", "writer", "info", "user", "Connection", "application", "handler", "config", "socket", "uri", "service", "resource", "version", "wrapper", "common", "condition", "translation", "http", "channel", "server", "password", "con", "collection", "open", "connected", "relation"], "stream": ["v", "result", "cont", "reader", "client", "system", "output", "view", "feed", "io", "load", "raw", "container", "model", "path", "sl", "input", "row", "out", "string", "context", "image", "upload", "Stream", "or", "writer", "transform", "object", "body", "video", "handler", "per", "loader", "media", "resource", "version", "form", "stack", "translation", "data", "channel", "file", "source", "server", "sc", "entry", "coll", "trans", "sw", "f", "response"]}}
{"id1": "7757297", "id2": "692738", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"submit": ["complete", "send", "save", "login", "apply", "sub", "request", "input", "start", "write", "success", "type", "report", "update", "post", "Submit", "close", "form", " submission", "process", "accept", "execute", "init", "download", "register", "open", "run"], "uri": [" Uri", "address", "base", "description", "absolute", "id", "io", "URL", "iri", "path", "xml", "plugin", "Url", "filename", "location", "string", "ui", " URI", " ur", "database", "username", "format", "duration", "i", "report", "route", "text", "directory", "ri", "message", "resource", "api", "URI", "http", "href", "cli", "data", "file", "server", "source", "response"], "Exception": ["End", "Application", "Event", "Null", "Exit", "ceptions", "Transaction", "Except", "Response", " exception", "A", "Ex", "Exc", "Connection", "Problem", "ception", "Description", "except", "Document", "Adapter", "Request", "Error", "Timeout", "Record", "Interface"], "encodedrdf": ["encodedrre", "encodingwdbf", "encodedwdf", "encodedrde", "encodedudef", "encodedude", "encodingwdF", "encodingwdf", "encodeudrf", "encodedvrf", "encodeudef", "encodedwde", "encodingwdrf", "encodedrdef", "encoderdef", "encodedrtrf", "encoderde", "encodingrdrf", "encodedrrf", "encodedrdrf", "encodedvrF", "encodedwdbf", "encodedrdF", "encodedwdF", "encoderdrf", "encodingrdf", "encodeude", "encodedvrrf", "encodedrtf", "encodedvrbf", "encodedrtF", "encoderdf", "encodedwdrf", "encodeudf", "encodedudf", "encodingrdF", "encodedwdef", "encodingrdbf", "encodedrtbf", "encodedrref", "encodedrdbf", "encodedrrrf", "encodedudrf"], "url": ["address", "position", "base", "client", "job", "use", "URL", "proxy", "path", "Url", "session", "connect", "conn", "string", "name", "contact", "location", "image", "link", "database", "ssl", "user", "Connection", "text", "config", "loc", "socket", "service", "resource", "http", "l", "page", "source", "file", "server", "channel", "open", "control", "relation"], "connection": ["position", "client", "connected", "use", "io", "URL", "proxy", "function", "connect", "session", "conn", "string", "contact", "context", "driver", "section", "c", "link", "database", "character", "org", "or", "communication", "writer", "Connection", "application", "text", "n", "b", "directory", "number", "handler", "config", "loc", "socket", " Connection", "service", "version", "condition", "document", "http", "l", "in", "source", "channel", "server", "password", "con", "open", "response", "relation"], "lastUser": ["LastUser", " lastCategory", " lastRow", "latestRow", "LastRow", "latestCategory", "lastWord", "lastCategory", "latestUser", " lastWord", "latestWord", "LastWord", "lastRow", "LastCategory"], "out": ["external", "error", "outs", "cache", "window", "log", "name", "conn", "doc", "off", "plain", "global", "writer", "at", "flush", "data", "file", "server", "full", "part", "client", "check", "cmd", "word", "lock", "write", "prefix", "down", "Out", "user", "o", "wrapper", "key", "in", "page", "pool", "cli", "password", "dump", "comment", "result", "OUT", "w", "login", "call", "io", "obj", "inner", "err", "no", "editor", "extra", "again", "list", "socket", "outer", "office", "copy", "temp", "exec", "builder", "output", "bin", "view", "exp", "image", "sync", "commit", "line", "up", "init", "req"]}}
{"id1": "17161805", "id2": "4852691", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"encode": ["Enoding", "encoder", "enoding", "Enoder", "enccode", "ensode", "reode", "Enode", "enccod", "enode", "encod", "ensoder", "recode", "Encod", "enscode", "reoding", "enscod", "recod", "encoding", "Encode", "enoder"], "plaintext": [" plainText", "plainstring", " plaincontent", "bodyform", "bodytext", "plainTEXT", "plainform", "forestring", "foreText", "plainText", " plainform", " plainstring", "longform", "foretext", "battext", "longText", "bodyText", "longtext", "plaincontent", "batTEXT", " plainTEXT", "batText", "bodycontent", "foreTEXT", "longcontent", "batstring"], "md": ["mad", "MD", "mc", "sha", "ms", "metadata", "rm", "pm", "bd", "amd", "df", "um", "meta", "mb", "ind", "cmd", "hd", "sm", "rpm", "code", "mand", "m", "dd", "gd", "od", "grad", "mm", "ma", "ad", "pd", "cd", "wd", "mac", "mod", "di", "me", "dh", "d", "mag", "dm", "f", " MD", "mp", "po"], "raw": ["ghost", "dec", "unsigned", "clean", "local", "RAW", " hex", "feed", "load", "internal", "row", "input", "remote", "out", "binary", "stream", "rew", "original", "missing", "hex", "serial", "all", "custom", "pure", "Raw", "orig", "micro", "unknown", "enc", "block", "pack", "array", " Raw", "blocks", "alpha", "buffer", "shared", "instance", "initial", "ode", "ack"]}}
{"id1": "9210168", "id2": "614099", "code1": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"run": ["exec", "test", "base", "Run", "job", "call", "apply", "output", "un", "invoke", "replace", "start", "name", "out", "inner", "image", "code", "render", "launch", "running", "show", "runs", "background", "stop", "update", "display", "add", "in", "process", "work", "execute", "loop", "create", "register", "runner", "home", "unit"], "url": ["address", "base", "re", "str", "id", "URL", "path", "nr", "sl", "remote", "Url", "string", "image", "err", "ssl", "user", "b", "browser", "loc", "loader", "fr", "ur", "lr", "uri", "resource", "api", "service", "http", "plug", "l", "source", "file", "server", "rl", "f"], "fis": [" fiss", "fais", "flisa", " fIs", "flis", " fais", "fIS", "fliss", "bis", "bIs", "FIs", "biss", "fIs", "Fis", " fisa", "bais", "flIs", "pis", "Fiss", "FIS", "piss", "fiss", "pIs", "Fais", "pisa", "bIS", " fIS", "fisa"], "r": ["vr", "reader", "rh", "sr", "mr", "e", "ar", "rr", "rf", "nr", "ler", "er", "res", "ir", "cr", "s", "hr", "err", "c", "rt", "wr", "Reader", "i", "b", "kr", "rus", "rx", "tr", "ri", "fr", "ur", "ru", "resource", "p", "rb", "is", "rc", "l", "BR", "R", "d", "rar", "f", "rl", "rs", "pr"], "br": ["yr", "bc", "result", "vr", "reader", "mr", "sr", "bb", "str", "ob", "HR", "arr", "brush", "fb", "res", "cr", "hr", "bridge", "err", "bro", "bl", "rt", "wr", "Br", "b", "browser", "buf", "rx", "tr", "fr", "lr", "rb", "dr", "BR", "ch", "bh", "gr", "B", "bf", "be"], "line": ["cl", "lc", "header", "base", "column", "str", "el", "comment", "id", "shell", "le", "nl", "sl", "row", "ge", "string", "name", "li", "Line", "end", "lines", "word", "cr", "link", "bl", "character", "code", "LINE", "sel", "i", "b", "number", "buffer", "key", "lf", "l", "lin", "char", "data", "letter", "file", "style", "entry", "inline", "pass", "split", "liner", "part", "rl", "f", "cell"], "sb": ["bc", "bj", "sv", "xb", "ib", "bb", "gb", "amb", "bp", "nb", "bd", "db", "bis", "bm", "fb", "mb", "ls", "binary", "bsp", "sth", "bl", "si", "sa", "storage", "buff", "sg", "BB", "SB", "lb", "b", "buf", "bt", "abb", "wb", "sn", "buffer", "rob", "ab", "eb", "lr", "rb", "usb", "pb", "bh", "zb", "src", "bf", "obb", "erb", "sf", "cb", "bs"], "text": ["test", "result", "title", "str", "output", "id", "path", "font", "input", "string", "name", "ext", "obj", "code", "format", "info", "connection", "b", "object", "config", "buffer", "message", "content", "translation", "Text", "source", "data", "letter", "entry", "value", "txt", "comment", "TEXT"]}}
{"id1": "16572931", "id2": "13657103", "code1": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"unJar": ["putServer", "copyjar", "copyServer", "addJava", "updateTar", "updateJava", "addServer", "updateServer", "copyTar", "putTar", "putJava", "putjar", "copyJava", "addjar", "updatejar", "addTar"], "jarPath": ["relEntry", "jarFile", "JarEntry", "javaEntry", " jarName", "browserpath", "JarDir", "javaLog", "garpath", "jarpath", "erbEntry", "browserName", "garLog", "jarDir", "javaUrl", "JarUrl", "garPath", "JarFile", "browserPath", "javaName", "jarPo", "jarLog", "jarName", " jarDir", " jarUrl", "erbPath", "Jarpath", "javaFile", "javaPath", "jarUrl", " jarFile", "garEntry", "javaDir", " jarLog", "javaPo", "erbPo", "JarPath", " jarpath", "erbName", "browserEntry", "relFile", "javapath", "relDir", "JarName", " jarPo"], "jarEntry": ["JarEntry", "javaEntry", " jarName", "xmlPath", "cookPath", "dropPath", "xmlInfo", "javaLog", "cookDir", "zipDir", "Jarentry", "irName", "irentry", "jarInfo", " jarentry", "cookEntry", "aliasEnt", "jarDir", "zipUrl", "javaUrl", "javaEnt", "zipEntry", "jarJar", "jarentry", " jarInfo", " jarEnt", "javaName", "xmlEntry", "xmlLog", "irEntry", "jarLog", "aliasInfo", "jarName", " jarDir", " jarUrl", "javaPath", "javaentry", "jarUrl", " jarJar", "aliasEntry", " jarLog", "javaDir", "jarEnt", "dropEntry", "zipName", "JarPath", "dropInfo", "aliasName", "javaJar", "javaInfo", "cookEnt", "dropentry", "JarInfo", "irJar"], "path": ["address", "test", "right", "id", "model", "cel", "log", "pattern", "location", "name", "conn", "context", "core", "zone", "ph", "route", "directory", "th", "mount", "p", "ion", "data", "file", "cat", "part", "prop", "left", "folder", "patch", "string", "Path", "lock", "prefix", "dest", "key", "src", "base", "project", "str", "zip", "not", "skip", "binary", "inner", "code", "mode", "parent", "config", "loc", "uri", "resource", "it", "content", "source", "work", "dir", "home", "temp", "url", "PATH", "clean", "request", "default", "host", "out", "end", "archive", "image", "next", "this", "step", "type", "root", "text", "sync", "ath", "wd", "entry", "pass", "po"], "relPath": ["relEntry", "relpath", "relativepath", "revEntry", "relativePath", " relEntry", "RelEntry", " relName", "Relpath", "relName", "RelUrl", "relativeName", "RelName", "relType", "RelPath", "revPath", " relType", "revpath", " relpath", "relativeUrl", "relUrl", "RelType", "revType", " relUrl"], "jar": ["z", "url", "base", "drop", "ja", "job", " Jar", "car", "war", "ar", "zip", "ball", "cur", "cook", "folder", "xml", "fire", "ler", "py", "sl", "er", "plugin", "binary", "tab", "archive", "pkg", "tar", "lib", "bag", "keeper", "zone", "j", "java", "bar", "b", "browser", "gap", "gar", "her", "pack", "gi", "jo", "dr", "entry", "file", "dir", "rar", "open", "Jar", "le", "module"], "ze": ["zie", "oe", "z", "de", "ja", "ele", "zzy", "ipe", "e", "pse", "zip", "zin", "je", "ge", "kee", "sl", "te", "zed", "zen", "zes", " je", "ZE", "sle", "ie", "pe", "zer", "za", "zi", "zee", "entry", "se", "ke", "ine", "ce", "aze", "le", "zy", "be"], "bin": ["base", "bit", "gen", "login", "bb", "zip", "proxy", "isin", "bis", "spin", "log", "boot", "plugin", "abin", "binary", "inner", "lock", "bian", "len", "bot", "bas", "bon", "lib", "bed", "ban", "b", "sin", "win", "brain", "pack", "resource", "pin", "gi", "abi", "cookie", "cin", "jin", "data", "in", "file", "init", "kin", "web", "bi"]}}
{"id1": "19849797", "id2": "13333160", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 1, "substitutes": {"copyFile": ["clonefile", "copyFiles", "transferfile", "copySource", "cloneFiles", "transferSource", " copySource", "transferFiles", " copyfile", "cloneSource", "transferFile", "copyfile", "cloneFile", " copyFiles"], "sourceFile": [" sourceDir", "ourceDirectory", "sourceUrl", "ourceUrl", "srcDir", "srcFile", " sourceFolder", "sourceFolder", "ourceFile", "SourceUrl", "srcfile", " sourcefile", "destfile", "SourceDirectory", "SourceFile", "ourcefile", "sourcefile", "sourceDirectory", "srcFolder", "destUrl", "Sourcefile", "SourceFolder", "destDirectory", "sourceDir", "SourceDir"], "destFile": ["destFiles", "targetFiles", "sourceFiles", "resultDir", "destLine", "DestFiles", " destfile", "destDir", "destPoint", "DestDirectory", "resultfile", "Destfile", "srcFile", "srcDir", "targetDir", "targetFile", "foreignFile", "srcfile", "foreignPath", "DestFile", "destPath", "targetfile", "DestPoint", "destfile", "targetLine", " destFiles", "targetPath", "foreignFiles", "resultFile", "DestDir", " destPoint", "foreignfile", " destDir", "srcDirectory", " destDirectory", "DestPath", "resultLine", "sourcePoint", "destDirectory", "srcFiles", "sourceDir", "srcLine"], "source": ["ource", "slave", "url", "result", "client", "reader", "cache", "status", "scope", "output", "site", "use", "id", "view", "current", "proxy", "scene", "index", "input", "target", "session", "start", "context", "core", "seed", "remote", "stream", "inner", "secure", "image", "Source", "this", "si", "storage", "component", "reference", "connection", "ie", "root", "route", "null", "object", "parent", "sin", "dest", "config", "slice", "table", "uri", "service", "resource", "api", "wrapper", "iter", "get", "from", "channel", "file", "server", "src", "unit", "size", "manager", "ce", "SOURCE"], "destination": ["participinate", "destinator", "generination", "Destinated", "dominated", "constinator", "identination", "distination", "construction", "distion", "participinator", "Destination", "domination", " destribution", "constribution", "domation", "Destribution", "Destruction", "destribution", " destinator", "destation", "Destation", "generruction", "destion", "identinator", "destinate", " destruction", "participinated", " destinated", " destation", "destinated", "participination", "distruction", "destruction", "dominator", "distinated", "distinator", "Destion", " destion", "Destinate", "constination", "generinator", "identinate", "generinated", "Destinator", "identinated"]}}
{"id1": "9261777", "id2": "23273706", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 1, "substitutes": {"source": ["ource", "template", "address", "url", "result", "base", "token", "project", "sample", "parse", "scope", "view", "site", "use", "id", "zip", "comment", "proxy", "force", "sort", "path", "request", "index", "input", "target", "session", "start", "string", "seed", "secure", "flat", "inner", "name", "original", "image", "Source", "spec", "prefix", "missing", "element", "info", "options", "null", "text", "parent", "rule", "empty", "dest", "sin", "query", "slice", "config", "strip", "uri", "service", "resource", "copy", "single", "in", "data", "file", "se", "style", "shared", "src", "sl", "unit", "size", "SOURCE"], "destination": [" destension", "databaseinated", "databaseinations", "destinator", "Destinated", " destipping", " destignment", "destinating", "databaseuration", "dominated", "distension", "distination", "homeinated", "Destination", "domination", "homeignment", "databaseination", " destinating", "dominations", "destension", "destinations", " destinator", "dependension", "coordinator", "coordinating", "dependinated", "homeination", "coordination", "destinate", " destinated", "Destignment", "dependination", "homeinator", "destinated", "Desturation", "distinated", "distipping", " destinate", "coordinate", "desturation", "Destinate", "Destinations", "dependipping", "domuration", "destipping", "Destinating", "Destinator", "destignment"], "is": ["us", "serv", "ais", "osi", "ip", "ins", "ai", "esi", "ib", "ois", "ob", "are", "iso", "zip", "isa", "io", "was", "id", "ar", "IS", "bis", "Is", "sis", "es", "oss", "eni", "abs", "out", "ir", "ui", "s", "ris", "ic", "ci", "isl", "ios", "iss", "nis", "ii", "or", "ie", "i", "info", "ori", "ops", "sin", "lis", "isc", "isi", "ri", "ics", "fs", "api", "close", "get", "iris", "obs", "in", "cos", "se", "ens", "init", "act", "src", "as", "bs", "mis"], "os": ["sys", "us", "mos", "ais", "OS", "nos", "Os", "osi", "ob", "ot", "aos", "io", "ou", "oise", "vs", "boot", "es", "ies", "oss", "ks", "out", "s", "ls", "oes", "ios", "or", "bos", "ori", "i", "acs", "dos", "js", "ops", "so", "ose", "o", "ow", "ends", "socket", "oses", "ds", "los", "fs", "obs", "cos", "op", "ens", "oa", "pos", "ros", "as", "ss", "ol", "bs", "oS"], "buffer": ["Buffer", "address", "position", "url", "result", "header", "base", "uffer", "reader", "bb", "transfer", "feed", "border", "sequence", "binary", "string", "seed", "queue", "image", "read", "layer", "writer", "reference", "batch", "b", "number", "buf", "null", "slice", "pad", "padding", "iter", "wave", "bytes", "flush", "copy", "page", "data", "channel", "server", "limit", "value", "size", "buff"], "length": ["position", "ring", "address", "url", "reader", "level", "ob", "left", "id", "feed", "load", "volume", "total", "of", "index", "distance", "row", "start", "end", "string", "offset", "sequence", "range", "section", "lock", "lower", "len", "character", "code", "type", "Length", "duration", "count", "number", "quote", "object", "shape", "slice", "block", "weight", "strip", "division", "depth", "key", "get", "point", "age", "l", "last", "match", "power", "line", "width", "style", "data", "limit", "value", "full", "split", "part", "size", "partial"]}}
{"id1": "2217889", "id2": "23666867", "code1": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 0, "substitutes": {"getResourceAsStreamIfAny": ["getResourceAsSteamifAnything", "getResourceAsStreamOrAny", "getResourceAsSteamIfany", "getResourceAsStreamOrANY", "getResourceAsStreamIfANY", "getResourceAsSteamifANY", "getResourceAsStreamifany", "getResourceAsSteamIfANY", "getResourceAsStreamIfany", "getResourceAsStreamifANY", "getResourceAsStreamIfAnything", "getResourceAsStreamOrany", "getResourceAsStreamIFany", "getResourceAsStreamifAny", "getResourceAsStreamIFAnything", "getResourceAsSteamifAny", "getResourceAsSteamIfAnything", "getResourceAsStreamOrAnything", "getResourceAsStreamIFANY", "getResourceAsSteamifany", "getResourceAsStreamIFAny", "getResourceAsStreamifAnything", "getResourceAsSteamIfAny"], "resPath": ["resolutionPath", "resolutionLocation", "resolutionUrl", "resLocation", "ResUrl", "ResLocation", "resolutionpath", "resourcepath", " resUrl", " respath", "resourceUrl", "ResPath", "resourcePath", "Respath", "resourceLocation", "resUrl", "respath", " resLocation"], "url": ["address", "base", "job", "rel", "bb", "ob", "feed", "URL", "path", "xml", "log", "sl", "Url", "host", "location", "string", "stream", "image", "err", "event", "ssl", "element", "connection", "browser", "object", "ll", "config", "loc", "loader", "lr", "service", "resource", "uri", "api", "http", "l", "page", "data", "file", "server", "entry", "source", "ref", "instance", "src", "impl", "open", "rl", "blog", "f"]}}
{"id1": "22135199", "id2": "823074", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": ["testCodingZeroFile", "testCachingEmptyStream", "testCachingEmptyFiles", "testCodingNoFile", "testCachingOfFile", "testCachingEmptySourceFile", "testCodingOfFile", "testCodingZeroFiles", "testCodingOfSourceFile", "testCodingZeroSourceFile", "testCachingOfSourceFile", "testCodingEmptyFiles", "testCodingNoSourceFile", "testCachingOfStream", "testCodingOfStream", "testCachingEmptyFile", "testCachingOfFiles", "testCodingNoFiles", "testCodingNoStream", "testCodingEmptyStream", "testCodingZeroStream", "testCodingEmptySourceFile", "testCodingOfFiles"], "baos": ["Baoes", "baoS", "waOs", "buo", "baoa", "aaaaOs", "paoa", "BaOS", "pao", "kao", "baOs", "bioS", "bioes", "biotes", "waos", "aaaaos", " baotes", "aaaaoS", "bao", "waoS", " baoS", "BaoS", " baoes", "baotes", "buos", "waOS", "baOS", "kaos", "kaOS", "kaoa", "baoes", "BaOs", "bios", "Baos", "paos", "aaaaOS", "buOS", "buoa", "Baotes", "paOS"], "channel": ["an", "camera", "flow", "url", "cam", "reader", "console", "system", "client", "bean", "feed", "io", "container", "chan", "log", "out", "conn", "context", "stream", "sea", "queue", "c", "self", "connection", "cho", "video", "parent", "handler", "config", "socket", "service", "Channel", "data", "ch", "sc", "server", "source", "group", "can", "annels"], "params": ["processor", "Param", "proc", "Parameters", "tx", "stats", "conn", "cms", "param", " parameters", "Par", "options", "cpu", "null", "par", "ops", "ps", "config", "mm", "css", "parser", " param", "api", "http", "ams", "size", "ctx", "cmp", "settings"], "outbuf": ["Outbuffer", "Outbuff", "inputbuf", " outbuffer", "outputcb", "Outbuf", "outputbuf", "Outcb", "inputqueue", "outputbag", "outputqueue", " outcb", "outqueue", " outbuff", "inputbuff", "outcb", "outbuffer", "inputbag", "outputbuff", "outputbuffer", " outbag", "outbuff", " outqueue", "outbag"], "metrics": ["metals", "matals", "Metals", " metics", "metics", " metals", "metras", " metrix", " metras", "Metric", "monrics", "matric", "metric", "matrix", "Metras", "monics", "Metrix", "monric", "Metrics", "monras", " metric", "Metics", "matrics", "metrix"], "encoder": ["Encoser", "Encoded", "ecode", " encipher", "encoser", " encressor", "enressor", "encoded", "enccode", "ecoding", "Encler", " encoded", "ecipher", "ecler", " encoding", "ecressor", "eccode", "Encoder", "ecoder", "enoded", "encressor", "Encipher", "ecoser", "encler", " encler", "enode", "ecoded", " encode", "encipher", "Encoding", "enoser", "encoding", "Encode", "encode", " enccode", " encoser", "enoder"], "tmpFile": ["poraryfile", "mpFiles", "txtFunction", " tmpFiles", " tmpfile", "vtFile", "poraryPage", "vtfile", "tmpDir", "tmpFunction", "tmpPath", "mpPage", "mpFilename", " tmpDir", "txtFile", "tmpFolder", "mpFunction", "tempFolder", " tmpFilename", "tmpFilename", "tempFile", "testFiles", "txtfile", "mpDir", "tmpPage", "mpFile", "vtDir", " tmpFolder", "poraryFile", "poraryFunction", "testFile", "testFolder", "tempFiles", "tempfile", "mpfile", "vtFilename", "txtPage", "testfile", "tmpfile", "mpPath", "tempPath", "tmpFiles", " tmpPath"], "fout": ["fdurl", " fio", "flwrite", "flurl", "sffile", "frwrite", "ffile", "sfchannel", "Fchannel", "flagain", "frurl", " ffile", "sfio", "frout", "fio", "furl", "sfout", "Fio", "fagain", "fdagain", "Ffile", "fragain", "fwrite", "flout", "fdwrite", "Fout", "fdout"], "wrtout": ["wRTin", "wadrout", "wRTOut", "wRTn", "wrdwriter", "wrdout", "wrin", " wrcouter", "wrcouter", "wrtouter", "wRTouter", "wrout", " wrcin", "wadrwriter", "Wrtouter", "WRTin", " wrcout", "wrcOut", "Wrtn", "wrcout", "wrOut", "wrtOut", " wrtouter", "wrdouter", "wrcn", "Wrtout", "wadragain", "WRTOut", "Wrtin", "wRTagain", " wrtagain", "wadrouter", "wrtn", "wadrin", "WRTwriter", "WRTn", "WrtOut", "wrdin", "wrcagain", " wrcagain", "wrcin", "WRTouter", "wrtin", "Wrtwriter", "wrn", "wrtagain", "wRTwriter", "wrtwriter", " wrtin", "WRTout", "wRTout"], "fchannel": [" fchan", "pqueue", "bcontainer", "fqueue", "fenresource", " fcontainer", "hstream", "pcontainer", "pchan", "hresource", " fconn", "fcontainer", "fconn", "bchan", "fresource", "fstream", "pstream", "fchan", "bconn", "fenchannel", "fenstream", "pchannel", "bchannel", "fenqueue", "hchannel", "pconn", "hqueue", "presource"], "s": ["su", "v", "services", "ins", "ms", "e", "ts", "es", "ns", "abs", "string", "ls", "u", "c", "states", "os", "ses", "strings", "m", "t", "i", "r", "g", "b", "js", "n", "o", "ps", "S", "p", "l", "qs", "ss", "f", "gs", "ings", "settings"]}}
{"id1": "16511008", "id2": "20886320", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"createNewProfilingMessageSymbol": ["createNewProfilingMessageYmbol", "createNewProfilingMessageSymmbol", "createNewProfilingMessageYmb", "createNewProfilingMsgSymb", "createNewProfilingMsgSymbol", "createNewProfilingMessageSyletter", "createNewProfilingMessageSymb", "createNewProfilingMsgSymmbol", "createNewProfilingMessageSymletter", "createNewProfilingMessageYletter", "createNewProfilingMsgSymmb", "createNewProfilingMessageCyletter", "createNewProfilingMessageSymmb", "createNewProfilingMsgSymletter", "createNewProfilingMsgSyletter", "createNewProfilingMessageCymb", "createNewProfilingMessageCymbol"], "configID": [" configION", " configId", "ConfigUID", "configION", "configUID", "projectURL", "ConfigURL", " configURL", "ConfigION", "projectION", "ConfigID", "projectUID", "projectId", "configId", "configURL", "ConfigId", " configUID", "projectID"], "programMessageSymbolID": ["programMessageSyklId", "programMessageSyymName", "programMessageSyymIP", "programMessageSyklID", "programMessageSyncmbID", "programMessageSychid", "programMessageSyntaxID", "programMessageSyncmbIP", "programMessageSyncmbolIP", "programMessageSyntaxName", "programMessageSyymId", "programMessageSyncmbid", "programMessageSymbolid", "programMessageSyncmbolId", "programMessageSymbName", "programMessageSymbolName", "programMessageSyncmbId", "programMessageSymbid", "programMessageSymbId", "programMessageSyklName", "programMessageSymbolIP", "programMessageSyncmbolid", "programMessageSychID", "programMessageSyncmbolName", "programMessageSymbID", "programMessageSymbolId", "programMessageSychId", "programMessageSymbIP", "programMessageSyntaxId", "programMessageSyncmbolID", "programMessageSyntaxid", "programMessageSyymID", "programMessageSyncmbName"], "profilingMessageSymbol": ["profilingMessageSymb", "profilingFileSymletter", "profilingMessageSynmbol", "profilingMessageSymPart", "profilingMessageTymbol", "profilingApplicationSymmb", "profilingMessageCyletter", "profilingMessageSyPart", "profilingMessageCymb", "profilingApplicationSymmbol", "profilingMessageCymbol", "profilingFileSymb", "profilingMessageTymb", "profilingFileSymmbol", "profilingFileSymmb", "profilingMessageSynmb", "profilingMessageSynPart", "profilingMessageSymmb", "profilingApplicationSymbol", "profilingApplicationSymb", "profilingMessageSymletter", "profilingMessageSyletter", "profilingFileSyPart", "profilingFileSymPart", "profilingApplicationSyletter", "profilingMessageYletter", "profilingMessageYmbol", "profilingFileSymbol", "profilingMessageSymmbol", "profilingMessageTyPart", "profilingMessageYmb", "profilingApplicationSymletter", "profilingFileSyletter"], "connection": ["bc", "position", "result", "error", "client", "cache", "use", "command", "db", "environment", "ctx", "log", "engine", "index", "connect", "session", "sql", "conn", "context", "state", "response", "machine", "driver", "section", "image", "c", "lock", "database", "si", "communication", "ongo", "Connection", "application", "directory", "config", "socket", " Connection", "cond", "table", "condition", "document", "function", "ion", "pool", "server", "channel", "password", "con", "collection", "unit", "manager", "connected", "relation"], "statement": ["position", "result", "error", "Session", "stat", "Query", "str", "study", "parse", "use", "command", "volume", "db", "function", "session", "sql", "mt", "conn", "string", "state", "out", "connect", "section", "lock", "database", "si", "storage", "expression", "writer", "report", "Connection", "library", "directory", "ment", "table", "message", "ma", "timeout", "parser", "usage", "joined", "agent", "condition", "document", "commit", "se", "execute", "Statement", "summary", "pass", "collection", "unit", "part", "comment", "response", "relation"], "resultSet": ["ResultSet", "ResultSource", "dataGen", " resultS", "dataList", "ResultType", "resultType", "ResultRow", "replySplit", "resultsGen", "ResultLine", "resultRow", "resultList", "responseSet", "rowSource", " resultSource", "resultsSet", "rowSet", "dataSource", "responseRow", "ResultS", "resultSource", "resultGen", "rowType", "replyList", "ResultList", " resultList", "resultSplit", "resultsSource", " resultGen", "replySet", " resultSplit", "replyLine", "responseList", "ResultGen", "resultLine", " resultType", "dataLine", "rowS", "dataSet", "ResultSplit", "dataRow", " resultLine", "resultS"], "query": ["feature", "result", "error", "send", "eries", "description", "Query", "call", "str", "parse", "id", "command", "request", "function", "index", "sql", "q", "string", "name", "lock", "database", "code", "expression", "reason", "type", "sq", "report", "go", "ql", "root", "scan", "join", "rule", "o", "update", "message", "table", "uri", "timeout", "qu", "key", "condition", "search", "filter", "work", "question", "execute", "qs", "style", "script", " Query", "value", "comment", "select", "module"], "msg": ["ger", "map", "md", "cmp", "cap", "cm", "error", "Message", "exc", "ms", "gor", "title", "gen", "status", "str", "mr", "gm", "e", "sim", "id", "db", "rr", "log", "comm", "ge", "mt", "name", "cmd", "err", "doc", "og", "pkg", "agg", "bag", "sg", "m", "format", "reason", "cfg", "html", "g", "desc", "text", "tag", "Msg", "ug", "bg", "loc", "ag", "mg", "lang", "message", "var", "ma", "fg", "mn", "phrase", "dr", "op", "gr", "rag", "nm", "tool", "gs"]}}
{"id1": "88047", "id2": "19096138", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewwrite", "readandRewrite", "readandrewrites", "readAndSwrites", "readAndrewrite", "readAndRebrite", "readandRewwrite", "readAndrewwrite", "readAndRebrites", "readandrewwrite", "readandrewrap", "readAndSwwrite", "readandRewrap", "readandRewrites", "readAndrewrap", "readAndRewrites", "readAndrewrites", "readAndRebrap", "readAndRewrap", "readAndSwrap", "readandrewrite", "readAndSwrite", "readAndRebwrite"], "inFile": ["oldFilename", "InFiles", "Infile", "oldFiles", "loginFilename", "inputFile", "InFile", "InSourceFile", "loginFile", "infile", "oldfile", "inputFiles", "oldFile", " infile", "inputFilename", " inFilename", "loginfile", "outfile", "loginFiles", "inFilename", " inSourceFile", "outSourceFile", "inFiles", "outFiles", "outFilename", "inSourceFile", " inFiles", "inputfile"], "outFile": ["newDir", "thisfile", "outDir", "processPlace", "OutStream", "thisFILE", "OutDir", "outFILE", "newFile", "offFile", "offFILE", "thisFilename", "outputFILE", "outStream", "outputFilename", "offFilename", " outfile", "exfile", "offPlace", "processFILE", "outputPlace", "thisFile", "processFilename", " outStream", " outDir", "outputfile", "newfile", "newStream", "exFilename", "outfile", "exFILE", "outPlace", "OutFile", "processFile", "exFile", "Outfile", "outFilename", "outputFile"], "iis": ["Iis", "iiris", " iiss", "iiIs", "ciIs", "ciIS", "ciis", "Iiss", "Iais", "iniiss", "iniIs", "iiss", "iniris", "ciais", "iiiss", " iIS", "iniIS", " iais", "iIS", " iIs", "iiIS", "iIs", " iris", "iris", "ciiss", "iniis", "iiis", "IIS", "ciris", "iais"], "dcmParser": [" dcrPlugin", "dmParser", " dcmHelper", " dcmarser", "fcmHandler", "dpmPlugin", "dcrPar", "fpmParser", "dCMReader", "dcmLoader", " dcmPlugin", "dpmLanguage", "dkmParser", "fpmparser", "dcmHelper", " dpmLanguage", "dmcParser", "dbmPolicy", "dcrReader", "dmcPar", " dpmParser", "dmissionReader", "dCMHandler", " dcmparser", "dmissionPlugin", "dmPlugin", "dmmparser", "dCMParser", "dpmHandler", "dbmHelper", "dpmReader", "dpmInstallation", " dcrLoader", "dbmPlugin", " dpmarser", "dmmLoader", "dhemJar", "dmoduleparser", "DcmReader", " dcrParser", " dpmJar", "dcmPolicy", "DcmInstallation", "dhemInstallation", "dmcJar", " dpmPolicy", "dpmparser", " dpmHelper", "dmissionLanguage", "dcmPar", " dpmparser", "dcmReader", "dpmPar", "fpmHandler", "dmodulePlugin", "dkmPlugin", "dbmParser", "dcmparser", " dcmPar", "dkmPolicy", "dmoduleParser", "dcrPlugin", "fcmParser", "dCMPlugin", "dmoduleJar", "dmcarser", "dcmPlugin", "dmoduleReader", " dcmPolicy", "DcmJar", "dcrParser", " dpmPlugin", "dCMLoader", " dcrReader", "DcmParser", " dcmLanguage", "dpmJar", "dmissionParser", "dhemParser", "dcmarser", " dcmJar", "dcmInstallation", "dpmParser", "dCMparser", "dmmPlugin", "dcrLoader", "dcrarser", "fpmReader", " dpmPar", "dcrJar", "dpmLoader", " dpmLoader", "dmLoader", "dmmParser", " dpmReader", "dcmJar", "fcmReader", "dhemReader", "dkmHelper", "fcmparser", "dpmarser", "dpmHelper", "dpmPolicy", " dcmLoader", "dcmHandler", "dcmLanguage", "dmReader", " dcmReader"], "ds": ["sys", "services", "da", "Os", "ins", "Ds", "ays", "eps", "xs", "ts", "ils", "db", "vs", "tx", "ws", "nas", "ads", "df", "session", "ns", "ks", "asi", "ls", "s", "conn", "iss", "os", "dd", "Db", "gd", "des", "ys", "dat", "js", "cs", "vals", "drivers", "cdn", "ps", "sync", "pd", "dc", "parts", "uds", "ants", "dt", "dr", "di", "dds", "data", "is", "ld", "qs", "amps", "DS", "d", "src", "icks", "details", "utils", "points", "ss", "bs", "ros", "tes", "rs", "gs", "ras"], "pdReader": ["pcRead", "pcLoader", "dsreader", "hdWriter", "xdReader", "xdRead", "hdRunner", "hdStream", "pcWriter", "hdRead", "ddStream", "dsLoader", "pbRunner", "pcReader", "dsReader", "dsRead", "hdreader", "pbLoader", "hdLoader", "ddRunner", "pdLoader", "pbStream", "pdStream", "pdreader", "pdRunner", "dsWriter", "pbReader", "hdReader", "xdreader", "pdRead", "xdWriter", "ddReader", "ddLoader"], "out": ["external", "outs", "cache", "gen", "inc", "model", "session", "conn", "name", "doc", "ssl", "writer", "at", "null", "with", "data", "file", "full", "group", "part", "as", "client", "child", "term", "db", "dot", "s", "ext", "word", "to", "lock", "write", "down", "Out", "user", "object", "o", "her", "key", "store", "page", "in", "cli", "password", "device", "later", "net", "result", "base", "OUT", "w", "login", "io", "auto", "obj", "inner", "err", "lib", "code", "layer", "again", "parent", "over", "oder", "list", "outer", "copy", "director", "temp", "exec", "flow", "sys", "url", "img", "builder", "output", "exp", "default", "image", "order", "connection", "ex", " in", "co", "sync", "diff", "array", "point", "line", "up", "pass", "dev", "manager"], "dcmEncParam": ["dcmElType", "dcmEnParam", "dcmEstType", "dcmEstPar", "dcmDecPart", "dcmDecParameter", "dcmArchParameter", "dcmEnArg", "dcmEncArg", "dcmElPar", "dcmEncParameter", "dcmDecType", "dcmSecType", "dcmEncPart", "dcmDecParam", "dcmEnType", "dcmSecPart", "dcmEncType", "dcmArchParam", "dcmSecPar", "dcmEnPart", "dcmSecParam", "dcmDecArg", "dcmEnPar", "dcmEstParam", "dcmElParameter", "dcmElParam", "dcmEstParameter", "dcmDecPar", "dcmEnParameter", "dcmArchArg", "dcmEncPar"], "pdWriter": ["PDWrite", "dpWrite", "hdWriter", "htReader", "ddWrite", "dpReader", "pdWriting", "dsOutput", "dsReader", "dpWriter", "hdWrite", "PDWriter", "dpWriting", "PDReader", "htWriting", "dsWriter", "hdReader", "htWrite", "htWriter", "PDWriting", "ddWriter", "ddOutput", "hdOutput", "pdOutput", "dsWrite", "ddReader", "pdWrite"]}}
{"id1": "8000624", "id2": "4599372", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copyTo", "CopyFrom", "copyTo", " copyto", " transferTo", "CopyFile", " copyFile", "copyFrom", "copyFile", " transferFile", "Copyto", " copyFrom", " transferFrom", "copyto", " transferto"], "dest": ["rest", "test", "cont", "img", "sup", "w", "delete", "output", "bin", "tmp", "exit", "comb", "path", "folder", "target", "filename", "flat", "name", "obj", "write", "them", "Dest", "class", "transform", "orig", "object", "desc", "wb", "table", "done", "content", "source", "data", "file", "destroy", "dist", " destination", "src", "die", "later", "opt", "txt", " Dest", "temp"], "in": ["gin", "ins", "thin", "reader", "din", "IN", "re", "login", "bin", "id", "isin", "inc", "vin", "x", "ini", "input", "issue", "In", "s", "conn", "inner", "ln", "image", "fa", "ax", "lib", "m", "i", "r", "connection", "b", "n", "again", "sin", "pull", "nin", "win", "inn", "wave", "pin", "plus", "h", "l", "lin", "source", "cin", "up", "init", "inside", "kin", "rin", "pass", "con", "ac", "as", "f"], "out": ["net", "exec", "external", "url", "OUT", "client", "outs", "cache", "w", "call", "output", "bin", "app", "ou", "io", "inc", "not", "one", "x", "outside", "target", "conn", "name", "ext", "inner", "image", "err", "no", "off", "this", "Out", "lib", "or", "writer", "i", "user", "b", "ex", "n", "again", "object", "o", "socket", "sync", "nin", "outer", "timeout", "plus", "pin", "copy", "other", "data", "vert", "up", "file", "our", "part", "temp"], "c": ["v", "cm", "cl", "lc", "cf", "bc", "cy", "exc", "uc", "ca", "e", "C", "x", "ic", "pointer", "oc", "cr", "u", "ci", "cc", "code", "m", "ct", "ec", "t", "i", "r", "arc", "cu", "ce", "n", "xc", "esc", "o", "config", "fc", "enc", "buffer", "dc", "p", "content", "rc", "col", "l", "char", "ch", "sc", "d", "pc", "ac", "abc", "comment", "cb", "f"]}}
{"id1": "5620792", "id2": "17729554", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 0, "substitutes": {"SHA1": ["HA64", "SHAOne", "SHA256", "sha256", "HA1", "HA256", "shaOne", "SHA64", "sha1", "HAOne", "sha64"], "text": ["template", "address", "url", "token", "str", "transfer", "id", "path", "font", "input", "pattern", "string", "name", "length", "out", "binary", "ext", "struct", "context", "image", "prefix", "hex", "word", "code", "format", "connection", "class", "object", "config", "message", "buffer", "bytes", "key", "content", "Text", "in", "data", "source", "letter", "password", "secret", "contract", "value", "txt", "TEXT"], "HASH_VALUE_SIZE": ["HASH_SIZE_LOAD", "HASH_SIZE_size", "HASH_VALUE_LOAD", "HASH_Value_size", "HASH_VALUEFSIZE", "HASH_VALUE_Size", "HASH_VALUE_VALUE", "HASH_VALUEFsize", "HASH_VALUE2size", "HASH_Value_SIZE", "HASH_VALUE2SIZE", "HASH_Value_Size", "HASH_VALUE2LOAD", "HASH_SIZE_SIZE", "HASH_Value_VALUE", "HASH_SIZE_VALUE", "HASH_VALUE2VALUE", "HASH_VALUE_size", "HASH_VALUEFLOAD", "HASH_VALUEFVALUE"], "md": ["mad", "MD", "hash", "sha", "mc", "ms", "dig", "ng", "gen", "metadata", "rm", "pm", "bd", "valid", "amd", "am", "um", "mo", "meta", "mb", "mt", "ind", "cmd", "pkg", "sm", "code", "mand", "editor", "m", "dd", "method", "body", " MD", "od", "mg", "mm", "message", "ma", "pd", "em", "wd", "mac", "mod", "hm", "me", "data", "ld", "d", "mag", "bf", "nm", "dm", "sum", "mu", "f", "mp"], "sha1hash": ["sha1str", "ha2Hash", "ha1dig", "sha256h", "SHA1dot", "ha2dig", "sha1dig", "sha2hex", "SHA2dot", "sha256dot", "SHA1hash", "SHA2hex", "sha1Hash", "sha256hash", "sha64hash", "sha1dot", "sha2h", "sha64Hash", "sha2str", "ha1sum", "ha2str", "sha64dig", "sha2sum", "sha2hash", "ha2hash", "ha1hash", "sha1sum", "sha9hash", "sha2Hash", "ha1Hash", "sha2dot", "sha2dig", "ha1str", "sha64sum", "ha2sum", "SHA2hash", "sha256hex", "sha0dot", "sha1hex", "sha0hex", "sha9dig", "sha1h", "sha9str", "sha0h", "sha9Hash", "sha0hash", "SHA2h", "SHA1hex", "SHA1h", "sha64str"]}}
{"id1": "12349563", "id2": "12678045", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"resourceExists": [" resourceCompits", " resourceexits", " fileExists", " fileexistence", " resourceExistence", " fileexes", " resourceCompists", " fileexits", " resourceAbsits", " resourceAbses", " fileexists", " fileExits", " resourceexistence", " resourceExes", " resourceexists", " resourceExits", " fileExistence", " fileExes", " resourceCompistence", " resourceCompes", " resourceAbsists", " resourceAbsistence", " resourceexes"], "location": ["address", "position", "base", "description", "LOC", "local", "provided", "region", "path", "folder", "remote", "node", "filename", "length", "name", "string", "target", "language", "host", "pointer", "image", "layer", "operation", "type", "reference", "connection", "info", "route", "shape", "object", "directory", "loc", "layout", "message", "uri", "resource", "content", "point", "href", "data", "source", "file", "server", "Location", "area", "collection", "home", "localhost", "response"], "url": ["address", "base", "zip", "io", "URL", "path", "sl", "fl", "Url", "host", "string", "obj", "image", "c", "lib", "build", "ssl", "i", "r", "connection", "user", "b", "ll", "www", "config", "loc", "uri", "api", "resource", "http", "l", "page", "source", "file", "server", "impl", "open", "web", "blog", "f"], "cxn": ["Cxn", "cxxn", "cexn", "crexcon", "cdscon", "cdsg", "crexp", " cxp", " cxg", " crexp", " cxcon", "cuxns", " crexg", "cxxp", "cxp", "cxxne", "cexp", "cuxn", "crexn", " crexn", "cxcon", "cxne", "Cxp", "cxxns", "Cuxp", "cexg", "cexns", "cxg", "Cuxne", "Cxne", " crexcon", "Cuxn", "Cxns", "cexne", "cuxp", "cuxne", "cdsn", "cexcon", "Cuxns", "cxns", "cdsp", "crexg"], "is": ["us", "im", "ais", "ip", "ms", "ai", "does", "ois", "ob", "app", "iso", "was", "ar", "id", "isa", "has", "IS", "bis", "x", "Is", "es", "oss", "abs", "out", "ir", "s", "ui", "stream", "ris", "cms", "next", "isl", "ios", "iss", "os", "nis", "or", "ori", "i", "info", "js", "lis", "internet", "isc", "isi", "uri", "fs", "api", "close", "it", "get", "iris", "its", "http", "in", "cos", "ens", "init", "src", "as", "web", "bs"], "byteBuffer": ["bitBuffer", "bitBuff", "byteLength", "byteBB", "ByteBuff", "bitLength", " byteBuff", "ByteBB", "bitBB", " byteBB", "ByteBuffer", "byteBuff", "bitArray", " byteArray", "ByteLength", "ByteArray", "byteArray", " byteLength"]}}
{"id1": "6963063", "id2": "22879400", "code1": "    public static void main(String args[]) {\n        int[] mas = { 3, 5, 6, 9, 1, -3, -4, -88 };\n        int sort = 0;\n        for (int j = 0; j < (mas.length); j++) {\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    sort = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = sort;\n                }\n            }\n        }\n        for (int i = 0; i < mas.length; i++) {\n            System.out.print(\" \" + mas[i]);\n        }\n    }\n", "code2": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "label": 0, "substitutes": {"mas": ["ga", "mad", "mos", "las", "sha", "pa", "ms", "ra", "mc", "params", "ias", "ins", "ages", "marks", "xs", "asa", "ia", "space", "nas", "forms", "meta", "months", "ama", "ls", "missing", "spec", "inas", "fa", "bas", "sa", "asm", "MA", "lambda", "os", "afi", "central", "ras", "a", "images", "cs", "mis", "phas", "mes", "mm", "asia", "ma", "la", " ma", "alpha", "amas", "Las", "parts", "cas", "astics", "faces", "mat", "ams", "data", "ums", "ta", "amps", "pos", "mag", "cats", "names", "as", "ima", "rules", "features", "mast", "phi", "lam"], "sort": ["Sort", "position", "master", "alias", "place", "parse", "use", "id", "pre", "sign", "replace", "default", "index", "ort", "alt", "start", "ind", "s", "seq", "offset", "size", "order", "err", "lower", "axis", "ist", "lib", "ii", "type", "g", "parent", "par", "orient", "hide", "o", "loc", "diff", "list", "slice", "edit", "ul", "update", "alpha", "min", "scale", "search", "adjust", "l", "filter", "vert", "init", "style", "pos", "num", "ji", "split", "part", "label", "cmp"], "j": ["v", "z", "J", "k", "jp", "I", "jc", "xi", "x", "q", "ind", "li", "u", "ui", "ci", "si", "ij", "y", "ii", "m", "ie", "a", "b", "js", "n", "o", "p", "it", "h", "is", "l", "oi", "d", "num", "ji", "f", "bi", "pi"], "i": ["qi", "jp", "z", "v", "k", "ip", "lc", "ai", "ti", "I", "uli", "e", "id", "io", "iu", "xi", "x", "ini", "index", "ui", "li", "u", "hi", "inner", "multi", "ci", "c", "si", "mi", "ij", "phi", "ii", "m", "ie", "info", "ori", "a", "b", "o", "slice", "ri", "uri", "api", "gi", "ix", "fi", "it", "abi", "h", "oi", "in", "di", "ik", "cli", "data", "init", "ni", "yi", "ji", "f", "mu", "bi", "pi", "temp"]}}
{"id1": "6501291", "id2": "13783549", "code1": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"extractFile": ["xtractedFile", "xtractfile", "extendFile", "extressfile", "extractfile", "extractedFolder", "extressFile", "extractedFile", "extendFiles", "xtractFiles", "xtractedFiles", "extendFolder", "extractFolder", "xtractFolder", "extractedFiles", "xtractedfile", "extractFiles", "extractedfile", "xtractedFolder", "extressFiles", "xtractFile", "extendfile", "extressFolder"], "input": ["address", "url", "img", "audio", "bin", "view", "zip", "io", "load", "raw", "Input", "xml", "target", "string", "name", "binary", "stream", "inner", "archive", "image", "down", "format", "element", "i", "connection", "text", "parent", "config", "pull", "buffer", "media", "inf", "content", "single", "source", "data", "file", "init", "frame"], "output": ["complete", "external", "address", "written", "url", "result", "job", "current", "model", "xml", "remote", "target", "temp", "string", "four", "generation", "response", "generated", "write", "next", "operation", "format", "reference", "connection", "application", "directory", "example", "config", "outer", "office", "version", "document", "page", "source", "file", "letter", "style", "secret", "unit", "web", "Output", "settings"], "reader": ["IN", "der", "parse", "zip", "io", "feed", "inc", "cur", "rr", "worker", "rer", "ler", "ini", "er", "inner", "stream", "err", "editor", "read", "Reader", "writer", "i", "r", "rx", "b", "oder", "rake", "per", "loader", "ner", "ri", "her", "parser", "iter", "buffer", "rb", "plus", "h", "rc", "l", "source", "server", "file", "se", "rar", "ink", "as", "reading", "f", "author"], "in": ["url", "gin", "ins", "din", "IN", "re", "bin", "id", "io", "inc", "ini", "er", "In", "s", "inner", "stream", "image", "err", "doc", "read", "or", "writer", "i", "r", "user", "n", "socket", "loader", "win", "inn", "h", "is", "l", "data", "source", "file", "init", "ac", "as", "f"], "out": ["net", "exec", "OUT", "client", "outs", "cache", "gen", "w", "bin", "exp", "io", "inc", "raw", "log", "conn", "obj", "ext", "inner", "image", "err", "write", "off", "Out", "self", "editor", "writer", "connection", "user", "ex", "again", "parent", "o", "over", "socket", "outer", "post", "buffer", "copy", "line", "data", "source", "file", "up", "pool", "server", "instance", "temp"], "buf": ["vec", "uf", "v", "bc", "cap", "lc", "uc", "bb", "bin", "tmp", "bp", "bd", "cv", "br", "raw", "cur", "ctx", "val", "fb", "length", "seq", "queue", "c", "bl", "off", "bag", "box", "batch", "b", "ff", "loc", "pad", "buffer", "ab", "la", "bytes", "rb", "cas", "fd", "rc", "plug", "data", "bh", "bf", "lim", "cb", "buff", "bu"], "len": ["cap", "z", "lc", "url", "base", "dl", "el", "bin", "id", "pre", "Len", "val", "sl", "fl", "length", "ind", "li", "fin", "end", "ln", "no", "c", "err", "all", "en", "i", "count", "r", "n", "nt", "iter", "min", "lf", "line", "l", "lin", "data", "pos", "lt", "lim", "part", "size", "f", "le", "rev"]}}
{"id1": "21488868", "id2": "8182932", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeFileToFiles", "encodeStringToFiles", "encodeFile2Stream", "encodeFiletoStream", "encodeFileFromFile", "encodeFileFromStream", "encodeFiletoFile", "encodeString2File", "encodeFiletoFiles", "encodeString2Files", "encodeFile2File", "encodeString2String", "encodeString2Stream", "encodeFileFromString", "encodeFileToString", "encodeFile2String", "encodeStringToString", "encodeFileToStream", "encodeFiletoString", "encodeStringToStream", "encodeFile2Files", "encodeStringToFile"], "infile": ["Infile", "infiles", "inputFile", "InFile", "inFile", "Infiles", "outFile", "inputfiles", "infilename", "outfilename", " infilename", "outfiles", "inputfp", "infp", " infiles", "inputfilename", " infp", "outfp", "Infilename", "inputfile"], "outfile": ["outputfilename", "newname", "Outname", "newFile", "outname", "infolder", "newfolder", " outname", "Outfolder", "outFile", "outfolder", " outfolder", "infilename", "outfilename", "outputfp", " outFile", "outputfile", " outfilename", " outfp", "newfile", "infp", "OutFile", "outputfolder", "Outfile", "outfp"], "in": ["gin", "base", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "vin", "ini", "input", "ic", "In", "s", "conn", "inner", "image", "err", "inas", "m", "a", "i", "r", "b", "again", "sin", "socket", "nin", "win", "inn", "min", "pin", "is", "into", "cin", "data", "source", "init", "inside", "rin", "pass", "ac", "con", "as"], "out": ["net", "exec", "base", "error", "OUT", "client", "outs", "cache", "job", "output", "bin", "ou", "io", "inc", "one", "session", "conn", "obj", "In", "inner", "on", "name", "to", "image", "err", "write", "off", "no", "Out", "lib", "or", "writer", "ex", "parent", "again", "o", "co", "socket", "sync", "post", "outer", "timeout", "point", "copy", "line", "source", "work", "file", "up", "home", "exit"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bb", "transfer", "feed", "raw", "fb", "input", "border", "length", "seed", "binary", "offset", "queue", "write", "len", "layer", "type", "reference", "batch", "count", "b", "null", "buf", "slice", "padding", "iter", "bytes", "wave", "flush", "data", "source", "server", "limit", "value", "split", "size", "buff"], "read": ["exec", " skip", " Read", "ip", "reader", "send", " copy", "parse", "lex", "allow", "use", "id", "feed", "io", "load", "inc", "raw", "current", "_", "check", "x", " count", "input", "connect", "start", "length", "ind", "play", "seek", "end", "write", "next", "len", "i", "count", "ride", "wait", "fill", "n", "find", "Read", "slice", "sync", "READ", "tell", " write", "ad", "iter", "close", "add", "get", "copy", "work", "sleep", "se", "limit", "reads", "pass", "reading", "size", "select", "f", "run"], "success": ["complete", "first", "result", "error", "cess", " succ", "fast", "status", "ccess", "growth", "follow", "flash", "primary", "right", "Success", "valid", "model", "func", "path", "default", " succeed", " Success", "true", "winner", "rolled", "results", "xx", "failed", "danger", " successful", "construct", "method", "null", "again", "ceed", "good", "message", "done", "rolling", "successfully", "respons", "content", "continue", "data", "warning", "successful", "pass", "roll", "initial", "better", "fail", "value", "open", "modified", "comment", "response"]}}
{"id1": "7872659", "id2": "1473212", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    @Test\n    public void test_validate_geo_getEvents() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=geo.getevents&location=madrid&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieIndexPath", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndmovieindexfile", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndmovieIndexfile"], "completePath": ["completeHome", " completeRoot", " completeCorp", "execpath", "doneLoader", "successPath", " CompleteDir", "completeCh", " completepath", "CompletePath", "doneVol", "CompleteDir", "completeVol", " completePoint", "itePath", "flatPath", " completeDir", "donePath", "completeCorp", "iteMusic", "successCh", "execLoader", "completeFile", "iteCh", "correctPoint", " CompletePath", "completeMusic", "completeRoot", "donepath", "successMusic", "completepath", "completeLoader", "itepath", "completePoint", "progressLoader", "progresspath", "CompleteHome", " completeCh", "progressPath", " completeHome", "flatRoot", "execPath", "flatCorp", "progressVol", "completeDir", "correctPath", "flatPoint", " CompleteHome", "execVol", "correctCorp", " completeMusic", " completeFile", " CompleteFile", "correctRoot", "CompleteFile", "successpath"], "masterFile": ["masterFiles", " masterName", "MasterFilename", "MasterName", "cacheFiles", "masterName", "MasterPath", "cachePath", "masterPath", "MasterFiles", "configFilename", "mastersFile", " masterPath", "cacheFile", "masterFilename", "MasterFILE", "mastersPath", " masterFilename", "MasterFile", "configPath", "configFile", "mastersFILE", "cacheFILE", "masterFILE", "mastersFiles", "configName"], "CustRatingFileName": ["CustRatingClassPath", "CustIndexFilesVersion", "CustIndexFileName", "CustRatingFilesName", "CustRatingFilenameSize", "CustRatingFilenameName", "CustRateFileName", "CustRateFilenameDesc", "CustRatingFilesDesc", "CustRatingFileVersion", "CustRatingFileSize", "CustIndexFilesType", "CustRateFileSize", "CustIndexFilesName", "CustRatingFilenamePath", "CustRatingFullDesc", "CustRateFilenameName", "CustIndexFilesPath", "CustRateFileDesc", "CustRatingFullPath", "CustRatingLineVersion", "CustRatingClassVersion", "CustRatingFileDesc", "CustRatingLineName", "CustRatingClassName", "CustRatingFilePath", "CustRatingFilesSize", "CustRateFilePath", "CustRatingFullName", "CustRatingLineType", "CustRateFilenamePath", "CustRatingFileType", "CustRatingLinePath", "CustRatingFullSize", "CustIndexFileVersion", "CustRatingClassType", "CustIndexFileType", "CustRatingFilesPath", "CustIndexFilePath", "CustRatingFilenameDesc", "CustRatingFilesType", "CustRateFilenameSize", "CustRatingFilesVersion"], "MovieIndexFileName": ["MovieIndexPlaceFile", "MovieConfigFolderFile", "MovieIndexFileHandle", "MovieIndexClassSize", "MovieIndexFName", "MovieEditFilename", "MovieConfigFolderName", "MovieConfigFileHandle", "MovieConfigFileVersion", "MovieIndexFolderName", "MovieIndexFileVersion", "MovieIndexPlaceName", "MovieIndexClassName", "MovieIndexFSize", "MovieIndexFilesUrl", "MovieEditFname", "MovieIndexClassname", "MovieConfigFolderVersion", "MovieEditFSize", "MovieConfigFileName", "MovieEditFUrl", "MovieIndexClassUrl", "MovieConfigFileFile", "MovieIndexFILEVersion", "MovieIndexFilesname", "MovieIndexFileSize", "MovieIndexFolderHandle", "MovieIndexFilesSize", "MovieConfigFolderHandle", "MovieIndexFILEFile", "MovieIndexFname", "MovieEditFileName", "MovieIndexFolderVersion", "MovieEditFileSize", "MovieIndexFUrl", "MovieIndexFolderFile", "MovieIndexPlaceHandle", "MovieEditFName", "MovieIndexFileFile", "MovieIndexFileUrl", "MovieIndexFILEName", "MovieIndexFILEHandle", "MovieEditFileUrl", "MovieIndexPlaceVersion", "MovieIndexFilename", "MovieIndexFilesName"], "inFile": ["Infile", "inputF", "inputFile", "InFile", "InF", "incFile", "inF", "incC", "InSourceFile", "inputSourceFile", "incSourceFile", "outFile", "infile", "outC", "incfile", " inF", " infile", "outfile", " inSourceFile", "outSourceFile", "inSourceFile", "inputfile"], "inC": ["inB", "InB", "inputF", " inCL", "innerCI", "outCC", "inputFile", "InFile", "InF", "outB", "inF", " inCC", "inCL", "outFile", "outC", "inputC", "innerFile", "inputCC", " inF", "InCI", " inB", "InCC", "innerCC", "outF", "outCL", "InCL", "outCI", "inCC", "innerC", "inCI", "InC"], "outFile1": ["outputFileName", "outFName", "againCFirst", "againC3", "outputFileId", "outPlaceId", "outCFirst", "outF1", "outFileName", "outFile3", "againFile1", "outPathFirst", "outPath1", "outFiles1", "outPath2", "outFilesFirst", "outfile1", "outfileId", "outF2", "outPath3", "outFileFirst", "outPlace1", "outFiles3", "outputFile1", "againFile3", "outC3", "againC1", "outFiles2", "againFile2", "outfileName", "outPlaceName", "outFileId", "outputFile2", "outputfileName", "outputfileId", "outputfile2", "outPlace2", "outFId", "outfile2", "againC2", "againFileFirst", "outputfile1"], "outC1": ["newc1", "outC81", "outD1", "outCFirst", "outD8", "outF1", "outcFirst", "outFOne", "newC81", "outCFFirst", "outD81", "newc81", "newCFirst", "outF2", "outD2", "againB8", "againC8", "outCF81", "outCFOne", "newCOne", "outDOne", "outc1", "outB1", "againB1", "outBOne", "againCOne", "outcOne", "outB8", "newcOne", "newcFirst", "outB2", "againBOne", "outF8", "outc81", "outC8", "newC1", "againC2", "againB2", "outCOne", "outCF1", "outDFirst", "againC1"], "outFile2": ["outFile4", "outputfile5", "outFiles6", "outDirectory4", "outFile5", "againFile6", "againFile1", "outFilesTwo", "againLine1", "outDirectory2", "outFiles1", "outDirectory5", "againFileTwo", "outLineTwo", "outputFile4", "outFileTwo", "outputFile5", "outChannel2", "outChannel1", "outLine2", "outDirectoryTwo", "outChannel6", "againLine2", "outfile4", "outFiles2", "outputFileTwo", "againFile2", "outFiles5", "outLine6", "outputFile2", "outfile5", "outChannelTwo", "againLine6", "outputfile2", "outfileTwo", "outLine1", "outfile2", "outputfileTwo", "againLineTwo", "outFile6", "outFiles4", "outputfile4"], "outC2": ["outFile4", "outFTwo", "outCache1", "outCII", "outF1", "outCache2", "outFII", "outB4", "OutF1", "againC4", "outCache4", "outF2", "OutF2", "OutC1", "outFileTwo", "outCacheII", "outCTwo", "OutCII", "OutC2", "OutC4", "OutFII", "outB1", "againB1", "againCTwo", "againBTwo", "outBTwo", "outF4", "outB2", "outC4", "outFileII", "againC2", "againB2", "againB4", "OutF4", "againC1"], "fileSize": ["bufferMode", " fileMode", " fileAddress", " fileSIZE", "imageLength", "imageSize", " fileLength", "fileAddress", "bufferSize", "fileMode", "bufferLength", "FileLength", "resourceSize", "resourceSIZE", "FileSize", "FileSIZE", "FileAddress", "fileLength", "FileMode", "imageSIZE", "resourceAddress", "fileSIZE"], "totalNoDataRows": ["totalNoPageRues", "totalNoDataChOWS", "totalNoDataRrows", "totalNoPageRrows", "totalNoDataCues", "totalNoPageLOWS", "totalNoDataRues", "totalNoDataLues", "totalNoPageLrows", "totalNoDataCows", "totalNoPageLows", "totalNoDataChows", "totalNoDataLows", "totalNoDataCrows", "totalNoDataChues", "totalNoDataCOWS", "totalNoPageRows", "totalNoDataLrows", "totalNoPageROWS", "totalNoDataROWS", "totalNoDataLOWS", "totalNoDataChrows", "totalNoPageLues"], "mappedBuffer": ["mappedBuff", "mappingBuffer", "mappingFile", "mappingBuff", "mashedBuffer", "Mappedbuffer", "mippedBuff", "mappedbuffer", "MachedURL", "MappedBuff", "machedBuffer", "mappingStream", "MappingChannel", "mapedFile", "MappedStream", "mppedStream", "MachedChannel", "mappingbuffer", "mactedStream", "MappingFile", "mappedURL", "MachedBuff", "mippedURL", "mappedChannel", "MappingBuff", "Machedbuffer", "mippedStream", "mappedFile", "mapedStream", "mapedURL", "MappedBuffer", "machedURL", "MappingBuffer", "MachedBuffer", "machedFile", "MachedFile", "mashedFile", "mashedChannel", "machedStream", "mappedStream", "machedbuffer", "mapedBuff", "MappedFile", "mppedChannel", "mashedBuff", "machedChannel", "mactedBuff", "machedBuff", "mactedbuffer", "mippedBuffer", "mapedBuffer", "mactedBuffer", "MappedURL", "mappingChannel", "MachedStream", "mppedBuff", "mppedBuffer", "MappedChannel"], "startIndex": ["endPoint", "startindex", "startSection", "endInfo", "stopCode", "stopindex", "stopIndex", "StartInfo", "initindex", "useindex", "startRow", " startindex", "endRow", "endCode", "startInfo", "endSection", " startOffset", "startingPosition", "startingIndex", " startCode", "startingPoint", "endIndex", "initIndex", "StartOffset", " startPosition", "startCode", " startInfo", "startPoint", "startPosition", "StartPosition", "initOffset", "endindex", "useIndex", " startPoint", "stopRow", "usePosition", " startRow", "Startindex", " startSection", "startOffset", "StartIndex", "useInfo", "startingSection", "initInfo", "endPosition"], "count": ["first", "test", "cache", "follow", "call", "allow", "found", "id", "force", "current", "child", "old", "total", "Count", "index", "start", "length", "keep", "ind", "time", "more", "thread", "name", "max", "c", "order", "len", "self", "code", "all", "type", "i", "counter", "number", "find", "weight", "list", "depth", "close", "add", "key", "other", "col", "pool", "loop", "coll", "limit", "group", "part", "sum", "size"], "currentMovie": [" currentmovie", "currentFilm", "thismovie", "CurrentTheme", "currentmovie", "defaultMusic", "currentlyPicture", "CurrentMovie", "currentPicture", "parentMovie", "validMovie", "reportedMovie", "reportedFilm", "thisPicture", "thisMovie", "defaultFilm", "validTheme", "reportedImage", "reportedmovie", "defaultMovie", "validFilm", "CurrentFilm", "defaultImage", " currentMusic", "validmovie", "parentmovie", "currentTheme", "Currentmovie", " currentFilm", "thisFilm", "currentMusic", " currentPicture", " currentImage", "currentImage", "currentlyMovie", "reportedMusic", "parentPicture", "reportedPicture", "currentlyMusic", "parentFilm", "reportedTheme"], "movieName": ["Moviename", "filmName", "MovieName", " moviename", "camName", "filmNumber", " movieId", "voiceName", "movieInfo", "moneyName", "moneyFamily", "voicename", "moneyNumber", "voiceId", " movieFamily", "MovieFamily", "moviename", "MovieInfo", "filmname", "MovieId", "voiceInfo", "movieId", "movieNumber", "camFamily", "movieFamily", " movieInfo", "camname", "filmFamily", "MovieNumber"], "customer": ["Customer", "customor", "ustomeri", "mixer", "ustomers", "customER", "CustomER", "Customers", " customER", "mixER", "customers", " customers", " customeri", "ustomer", "mixor", "ustomER", "ustomor", "Customeri", "Customor", "customeri", "mixers"], "rating": ["score", "ring", "url", "feature", "error", "reader", "id", "rr", "string", "ranking", "range", "missing", "ruby", "rate", "type", "writer", "info", "r", "number", "rage", "rated", "Rating", "packing", "setting", "ing", "padding", "alpha", "attribute", "resource", "rolling", "rank", "http", "rc", "data", "RC", "value", "rates", "rice", "including", "reading", "comment", "radius", "writing"], "outBuf1": ["outFufCloud", "outKuf8", "outBafCloud", "outFuf1", "outBummerOne", "outFbuf01", "outBbuff8", "outBbufn", "outBbuf11", "outBaf1", "outBuf3", "outFuf91", "outBaft3", "outBbuff0", "outBuf91", "outBuff8", "outFufOne", "outBuf8", "outCuf0", "outBaf3", "outBuffCloud", "outBalth3", "outBbuf91", "outFbuf1", "outBiff91", "outBaftn", "outKufOne", "outBuf01", "outFafCloud", "outBbuf3", "outBuff3", "outBum91", "outBufOne", "outKbuffOne", "outDuff1", "outKbuff3", "outBufn", "outDuff3", "outKbuff1", "outKuf1", "outBuff1", "outDuf1", "outBaf8", "outFuf01", "outBaf0", "outBbufOne", "outBalth1", "outBaft11", "outCuf1", "outCufOne", "outFafOne", "outKbuf3", "outFbuf91", "outBbuf1", "outBuffOne", "outFbufOne", "outKuf3", "outBbuffOne", "outCuffOne", "outFaf1", "outDuff11", "outKbuff8", "outBbuf2", "outBumOne", "outBuff11", "outBuff2", "outBbuff3", "outBummerCloud", "outBuf0", "outBafOne", "outBbuff1", "outDuf11", "outBiff1", "outBbuf01", "outBiff01", "outBaft1", "outDuf3", "outDuffn", "outBiffOne", "outBuff0", "outKbuf1", "outKuf2", "outBum01", "outCuff1", "outCuff0", "outBummer1", "outDufn", "outBalth2", "outKbuf2", "outBufCloud", "outBuffn", "outBuf11", "outBum1"], "outBuf2": ["outBuf4", "outFbuf2", "outBbuffTwo", "outBuber8", "outFbufB", "outFuf1", "outBoffTwo", "outFuf20", "outBum20", "outBbuff8", "outBuber20", "outBait200", "outBbuff20", "outBbuffer4", "outBbuff0", "outBuff8", "outBuf20", "outFuf8", "outBuf8", "outBbufB", "outBufTwo", "outBum82", "outBuff4", "outWBuf200", "outFbuff20", "outBuffTwo", "outBufB", "outBbufTwo", "outWBuf8", "outFbuff4", "outWBuf2", "outWBbuff200", "outBuff12", "outBbuffer2", "outWBuff4", "outFbuff2", "outBbuff200", "outBuffB", "outBbuff4", "outBum8", "outBait2", "outBait4", "outBbuff82", "outBuber2", "outBuff1", "outFufTwo", "outBuf12", "outFbuf12", "outWBbuffTwo", "outFuf4", "outWBuff0", "outBbuf1", "outBoff8", "outFbuff1", "outBbuf4", "outWBuff8", "outBuber82", "outBait0", "outBbuf2", "outFbuf4", "outBuff2", "outBuf0", "outWBbuff8", "outBbuff1", "outBuf200", "outWBufTwo", "outBaitTwo", "outFbuff8", "outBoff200", "outFuf12", "outFuf82", "outBbuffer12", "outBuff0", "outBum2", "outBbuff2", "outFbuff82", "outBoff2", "outBbuf12", "outWBuf4", "outBuf82", "outFbuffTwo", "outBbufferB", "outFuf2", "outWBuf0", "outFufB", "outWBbuff2", "outBait8", "outWBuff2"], "endOfIndexFile": ["endOfImageFolder", "endOfDataFile", "endofindexTime", "endOfIndexFolder", "endofIndexFile", "endOfindexFile", "endOfImageFiles", "endOfDataDir", "endOfindexFiles", "endofIndexDir", "endofindexFolder", "endofLinkFiles", "endofindexFile", "endOfIndexfile", "end\n", "endOfindexTime", "ended\n", "endfile", "endOfIndexFiles", "endofindexFiles", "endedfile", "endOfIndexTime", "endOfLinkFile", "endOfIndexDir", "endOfLinkfile", " end\n", "endOfClientDir", " endfile", "endOfindexFolder", "endOfDataTime", "endOfClientFiles", "endOfClientTime", "endOfClientFile", "endofIndexFolder", "endOfindexfile", "endOfindexDir", "endOfLinkFiles", "endOfLinkDir", "Endfile", "End\n", "endOfImageTime", "endofLinkDir", "endofLinkTime", "endOfDatafile", "endOfImageFile", "endofLinkFile", "endOfLinkTime", "endofIndexFiles", "endofIndexTime"]}}
{"id1": "9449064", "id2": "20019847", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"readExp": ["readEx", "loadExp", "readEXP", "readExt", "writeExt", "loadExpl", "readexp", "ReadExp", "loadExt", " readExpl", "loadEXP", " readexp", " readEx", " readExt", "loadEx", "ReadExpl", "ReadEXP", "readExpl", " readEXP", "writeEx", "writeExpl", "loadexp", "writeexp", "Readexp"], "writeExp": [" writeCom", "readEx", " writeEx", " writeExpl", "readExt", "WriteEx", "writeExt", "readexp", "WriteExt", "Writeexp", "WriteExp", "writingCom", "readExpl", "writingEx", " writeexp", "writeCom", "WriteCom", "writingexp", "writeEx", "writeExpl", " writeExt", "writeexp", "writingExp", "WriteExpl"], "expFile": [" expDir", "xpfile", " expSourceFile", " expLine", "ExpSourceFile", " expPlace", "Expfile", "EXPLine", "expString", " experimentLine", "expressFile", " experimentPlace", "xpPlace", "xpLine", "EXPSourceFile", "xpFile", "expfile", "ExpString", "expPlace", "EXPPlace", "expressSourceFile", "expressPlace", "EXPFile", "expLine", "ExpDir", "expDir", "EXPDir", "xpDir", "xpFiles", "expressLine", "expressfile", " experimentFile", " expFiles", "ExpPlace", "expFiles", "expressDir", " experimentFiles", "EXPString", "EXPfile", "expSourceFile", "ExpFile", "xpString", "ExpLine"], "exp": ["vec", " exam", "jp", "test", "lc", "ng", "project", "scope", "str", "app", " experiment", "expl", "xp", "zip", "model", "x", "div", "prov", "host", "iz", "ext", "obj", "rep", "spec", "pl", "fe", "ef", "acc", "imp", "asm", "i", "Exp", "EXP", "example", "dj", "query", " expansion", "inst", " expand", " expanded", "inf", "p", "nz", "plus", "form", "feat", "sc", "act", "push", "expr", "serv", "f", "express", "pr"], "fi": ["qi", "fp", "cf", "osi", "fy", "ani", "xi", "ffe", "ini", "py", "fb", "eni", "li", "Fi", "ci", "si", "fe", "fa", "ifi", "ii", "sci", "afi", "i", "info", "FI", "zi", "fc", "flo", "isi", "lli", "abi", "ni", "yi", "ji", "wi", "sf", "bi", "pi", "ifa"], "oi": ["odi", "qi", "osi", "ai", "ani", "ti", "uci", "ois", "io", "omi", "oci", "ini", "eni", "cci", "asi", "ui", "ahi", "li", "ilo", "obi", "ci", "si", "oid", "ii", "ofi", "ori", "i", "avi", "ogi", "eye", "eu", "ki", "ski", "flo", "isi", "oni", "lli", "abi", "di", "shi", "edi", "oxy", "ni", "ji", "obb", "oa", "bi", "agi"], "jf": [" jfm", "jp", "Jcf", "jpb", "xf", "pfr", " jfe", "jcf", "uje", "xfp", "jfp", "Jf", "djfm", "ujfs", "jpF", " jb", "jtf", "djf", "djfx", "jjfm", "je", "JF", "Jfx", "appfx", "ujfp", "ujf", "jpfx", "jpf", "zcf", "jpcf", " jfp", "fe", " je", "appf", "jb", "Jb", "Jfe", "zf", "appcf", "jfm", "zfp", "jarb", "jjf", "ztf", "jfx", "ff", " jp", "pf", " jfr", " jfx", "ffp", "jF", " jtf", "jfe", "djcf", "xcf", "jarp", "jjfx", "pb", " jfs", "jfr", "appfe", "jfs", "xtf", "jarf", "pp", "jjcf", "jarfr", "ffs", " jF", " jcf"], "sp": ["fp", "jp", "serv", "cf", "sv", "amp", "sup", "tp", "scope", "ap", "str", "bp", "app", "space", "sl", "py", "vp", "s", "cp", "bsp", "spec", "sm", "pl", "si", "fe", "imp", "sci", "sk", "sb", "Sp", "html", "gp", "js", "so", "ps", "inst", "service", "p", "wp", "page", "sh", "op", "sc", "se", "ch", "osp", "pp", "spe", "SP", "sw", "sf", "esp", "ctx", "ep", "mp", "ss", "pr"], "e": ["v", "exc", "Event", "w", "el", "x", "es", "ext", "ee", "fe", "ef", "en", "ec", "ie", "event", "t", "pe", "et", "ent", "ception", "events", "ae", "ev", "se", "ep", "ctx", "ce"], "fo": ["foo", "FO", "ico", "osa", "ooo", "lo", "io", "olo", "mo", "py", "ao", "obj", " lo", "fe", "bo", "os", "fa", "ho", "info", "obo", "ph", "oooo", "yo", "so", "o", "zo", "co", "flo", "la", "wo", "jo", "tto", "ko", "f", "vo", "ato", "po"], "oo": ["foo", "oe", "FO", "aco", "ico", "que", "osa", "ooo", "bean", "loo", "lo", "ou", "io", "argo", "olo", "mo", "ao", "oda", "ilo", "oid", "bo", "os", "goo", "OO", "obe", "obo", "oos", "oooo", "so", "o", "co", "flo", "la", "elo", "wo", "qa", "ollo", "oh", "cro", "oto", "oa", "ko", "va", "ox", "po"], "ex": ["su", "rex", "cl", "error", "exc", "tex", "pex", "re", "aux", "lex", "com", "expl", "inc", "Exception", "EX", "tx", "x", "es", "nex", "ic", "res", "Ex", "ext", "obj", "Exc", "six", "err", " Ex", "ax", "event", "ct", "used", "def", "class", "null", "ignore", "ception", "js", "except", "ass", " exc", "ix", "act", "se", "sex", "fail", "con", "exit"]}}
{"id1": "19849797", "id2": "2807585", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"copyFile": ["clonefile", "copyFiles", "transferfile", "copySource", "cloneFiles", "transferSource", " copySource", "transferFiles", " copyfile", "cloneSource", "transferFile", "copyfile", "cloneFile", " copyFiles"], "sourceFile": [" sourceDir", "ourceDirectory", "sourceUrl", "ourceUrl", "srcDir", "srcFile", " sourceFolder", "sourceFolder", "ourceFile", "SourceUrl", "srcfile", " sourcefile", "destfile", "SourceDirectory", "SourceFile", "ourcefile", "sourcefile", "sourceDirectory", "srcFolder", "destUrl", "Sourcefile", "SourceFolder", "destDirectory", "sourceDir", "SourceDir"], "destFile": ["destFiles", "targetFiles", "sourceFiles", "resultDir", "destLine", "DestFiles", " destfile", "destDir", "destPoint", "DestDirectory", "resultfile", "Destfile", "srcFile", "srcDir", "targetDir", "targetFile", "foreignFile", "srcfile", "foreignPath", "DestFile", "destPath", "targetfile", "DestPoint", "destfile", "targetLine", " destFiles", "targetPath", "foreignFiles", "resultFile", "DestDir", " destPoint", "foreignfile", " destDir", "srcDirectory", " destDirectory", "DestPath", "resultLine", "sourcePoint", "destDirectory", "srcFiles", "sourceDir", "srcLine"], "source": ["ource", "slave", "url", "result", "client", "reader", "cache", "status", "scope", "output", "site", "use", "id", "view", "current", "proxy", "scene", "index", "input", "target", "session", "start", "context", "core", "seed", "remote", "stream", "inner", "secure", "image", "Source", "this", "si", "storage", "component", "reference", "connection", "ie", "root", "route", "null", "object", "parent", "sin", "dest", "config", "slice", "table", "uri", "service", "resource", "api", "wrapper", "iter", "get", "from", "channel", "file", "server", "src", "unit", "size", "manager", "ce", "SOURCE"], "destination": ["participinate", "destinator", "generination", "Destinated", "dominated", "constinator", "identination", "distination", "construction", "distion", "participinator", "Destination", "domination", " destribution", "constribution", "domation", "Destribution", "Destruction", "destribution", " destinator", "destation", "Destation", "generruction", "destion", "identinator", "destinate", " destruction", "participinated", " destinated", " destation", "destinated", "participination", "distruction", "destruction", "dominator", "distinated", "distinator", "Destion", " destion", "Destinate", "constination", "generinator", "identinate", "generinated", "Destinator", "identinated"]}}
{"id1": "7143591", "id2": "9267602", "code1": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"getWebByUrl": ["getWebByIdURL", "getWebByurl", "getWebbyURL", "getwebbyUrl", "getwebByLocation", "getwebbyLocation", "getwebbyurl", "getWebFromurl", "getWebbyLocation", "getWebByLocation", "getWebByIdUrl", "getWebFromLocation", "getWebByURL", "getwebByUrl", "getwebByurl", "getWebbyUrl", "getWebbyurl", "getWebFromURL", "getWebByIdurl", "getwebByURL", "getWebFromUrl", "getWebByIdLocation", "getwebbyURL"], "strUrl": ["StrUr", "objUr", "slUrl", " strBase", "srurl", "arrUr", "arrurl", "arrUrl", "slURL", "strRoute", "StrFile", "stURL", "StrLink", "strUr", "stEmail", "STRFile", "StrEmail", "sturl", " strurl", "arrURL", "arrRoute", " strLink", "wrEmail", "strLink", "strurl", "StrRoute", " strUr", "strPath", "wrURL", "StrBase", " strURL", "stUr", "objUrl", "slBase", "STRUrl", "STRUr", "objURL", " strFile", "arrPath", "strEmail", " strRoute", "StrUrl", "stUrl", "strURL", "strFile", "stFile", "srLink", " strPath", "wrUrl", "slUr", "objFile", "StrPath", "strBase", "STRURL", "wrUr", "StrURL", "srUrl", "Strurl", "srURL"], "charset": [" CharsET", "chasec", " ChARSet", " Charsec", " Charsetting", "chacterset", "chasetting", "chaset", "chARSET", " ChARSetting", "chARSec", " ChARSET", "chactersET", "charsetting", "chactersec", "chARSet", " Charset", "charsET", "chasET", " ChARSec", "chactersetting", "charsec", "chARSetting"], "fileIndex": ["webindex", "webVersion", "fileNumber", "fullindex", "fileVersion", "webIndex", " fileVersion", "fullIndex", " fileindex", "FileName", "FileIndex", " fileName", "FileVersion", "FileNumber", "fullPath", "FilePath", "fullNumber", "webName", "Fileindex", " fileNumber", "fileindex", "fileName"], "url": ["address", "base", "client", "ib", "str", "bb", "id", "zip", "URL", "proxy", "path", "sl", "fl", "Url", "host", "string", "ls", "image", "link", "org", "ssl", "connection", "r", "b", "ll", "www", "config", "loader", "ur", "uri", "service", "api", "resource", "bel", "open", "http", "l", "page", "source", "file", "server", "download", "serv", "web", "blog", "f"], "conn": ["exec", "client", "ca", "ann", "w", "cb", "connect", "Url", "conv", "cp", "c", "ci", "ssl", "connection", "r", "Connection", "b", "n", "enc", "loc", "config", "nt", "sync", "sn", "api", "open", "http", "cli", "l", "ch", "cn", "server", "con", "nc", "ac", "Conn", "serv", "conf", "ctx", "f"], "is": ["us", "im", "serv", "ais", "ins", "ip", "ai", "ib", "ob", "iso", "isa", "are", "was", "io", "ar", "jar", "IS", "bis", "x", "Is", "es", "oss", "ir", "s", "out", "ui", "ls", "ris", "li", "err", "si", "ios", "iss", "os", "ii", "ssl", "ie", "i", "info", "b", "browser", "mis", "lis", "ps", "internet", "isc", "isi", "ri", "iter", "fs", "ab", "it", "h", "iris", "http", "in", "its", "init", "src", "as", "il"], "filePath": ["fileBase", "pagePath", "baseLocation", "FileUrl", "fileLocation", "pageLocation", "baseIndex", " fileUrl", "cachePath", "basepath", "cacheIndex", "outputUrl", "pagepath", "outputBase", "FileHome", " fileHome", "basePath", "outputHome", "FilePath", "cachepath", "filepath", "FileBase", "cacheLocation", "pageIndex", "fileUrl", "fileHome", " fileBase", "outputPath"], "pw": ["Pv", "spW", "Pow", "Pb", "ppW", "pW", " pwb", "Pws", "ppw", "Pw", "ppwa", " pws", "spws", "Pwr", "pws", " pv", "Psw", "cpwa", "pwa", " psw", "psw", "ppow", "spv", " pW", "spow", "cpwr", "PW", "pwr", " pb", "ppws", "ppsw", " pwa", "spwb", " pwr", "cpW", "spw", "pb", " pow", "ppb", "Pwa", "Pwb", "pwb", "pow", "pv", "cpw"], "fos": ["FOS", " fis", "fOS", "fsos", "Fops", " faos", "fsops", "fsaos", " fOS", "Fos", "Fis", " fops", "fsis", "fis", "pops", "pOS", "fops", "pos", "faos", "Faos"], "writer": ["wt", "wa", "wire", "wrap", "reader", "writ", "builder", "w", "output", "war", "io", "worker", "ws", "xml", "er", "wer", "out", "ee", "driver", "writing", "write", "rw", "wr", "editor", "format", "Writer", "r", "riter", "null", "handler", "walker", "wb", "buffer", "wave", "fd", "store", "angler", "file", "director", "writers"], "bReader": [" bCh", "bbReader", " bWriter", "rRead", "rbRead", " bResource", "rWriter", "rbCh", "BResource", "bbWriter", "bRead", "bCh", "rCh", "BRead", "rbWriter", "BReader", "bResource", "bbResource", "bbRead", "bWriter", "rReader", "BWriter", "rbReader", " bRead"], "sb": ["xb", "ib", "stab", "bb", "gb", "bp", "tmp", "lp", "nb", "db", "bm", "fb", "mb", "bsp", "sth", "sm", "si", "bps", "sa", "sg", "ssl", "sq", "SB", "lb", "b", "bg", "abb", "wb", "kb", "rob", "ab", "rb", "lab", "wp", "usb", "pb", "zb", "src", "bf", "obb", "erb", "sf", "cb"], "rLine": ["srLine", "lrRange", "rWr", " rLin", " rWr", "rBlock", "rrLine", "srLin", "prRange", "rtLine", "arWr", "rLo", "arline", "rtWr", "rtline", "rRange", "srBlock", "lrLine", "rUrl", "prBlock", " rLo", " rBlock", " rRange", "rrUrl", "rline", " rUrl", "rrBlock", "lrBlock", "prLin", " rline", "rLin", "prLine", "arLine", "lrLin", "arLo", "rrLin", "srUrl", "rtLo"], "tmp_rLine": ["tmp_errLink", "tmp_vrline", "tmp_rtline", "tmp_rSe", "tmp_rnline", "tmp_prValue", "tmp_rItem", "tmp_vrCopy", "tmp_nrLine", "tmp_lLetter", "tmp_roLine", "tmp_rnLine", "tmp_rPage", "tmp_errline", "tmp_rRecord", "tmp_rtLine", "tmp_rtItem", "tmp_RLetter", "tmp_RFile", "tmp_roPage", "tmp_lRecord", "tmp_RSe", "tmp_rCopy", "tmp_nrBlock", "tmp_lBlock", "tmp_rValue", "tmp_rnCopy", "tmp_nrline", "tmp_lFile", "tmp_rBlock", "tmp_nrFile", "tmp_prLine", "tmp_roValue", "tmp_rLink", "tmp_rnLink", "tmp_Rline", "tmp_RItem", "tmp_errCopy", "tmp_RLine", "tmp_RRecord", "tmp_brLetter", "tmp_RPage", "tmp_prFile", "tmp_lPage", "tmp_brLine", "tmp_rtBlock", "tmp_rbBlock", "tmp_roBlock", "tmp_RBlock", "tmp_rbItem", "tmp_roSe", "tmp_rbline", "tmp_errLine", "tmp_RValue", "tmp_rbLine", "tmp_vrLink", "tmp_roRecord", "tmp_prSe", "tmp_rline", "tmp_rFile", "tmp_vrLine", "tmp_rLetter", "tmp_lLine", "tmp_brFile", "tmp_roFile"], "str_len": ["stri5pos", "str_ln", "str5pos", "dr_len", "str_length", "dr_Len", "str5ler", "str64pos", "str_pos", "stri_pos", "stri5len", "str5len", "str2pos", "stri5ler", "stri_ler", "dr_length", "stri5lin", "str_ler", "str2lin", "dr_ln", "stri_lin", "str64ler", "str_lin", "str64lin", "str2ler", "str2len", "str_Len", "str64len", "str5lin", "stri_len"]}}
{"id1": "18489832", "id2": "17974661", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "label": 0, "substitutes": {"downLoadZippedFile": [" doLoadZedFiles", " doLoadZippingFile", " doLoadZedContent", " doLoadZaggedFiles", " doLoadZippingFiles", " doLoadzippingContent", " doLoadZaggedContent", " doLoadzippingFiles", " doLoadZippedDir", " doLoadZippedContent", " doLoadzippingDir", " doLoadzippedContent", " doLoadZaggedDir", " doLoadzippedDir", " doLoadzippedFile", " doLoadzippedFiles", " doLoadZedDir", " doLoadZippingDir", " doLoadZippedFile", " doLoadZedFile", " doLoadZippingContent", " doLoadZaggedFile", " doLoadZippedFiles", " doLoadzippingFile"], "url": ["base", "client", "zip", "proxy", "URL", "log", "sl", "Url", "bug", "image", "c", "link", "lib", "or", "event", "ssl", "i", "r", "connection", "b", "route", "ll", "config", "pull", "loader", "ur", "update", "lr", "uri", "resource", "store", "http", "l", "page", "source", "file", "server", "download", "open", "web", "f"], "destDir": ["DestDIR", "destdir", "destFile", "outputDir", "outputFolder", " destDIR", "destFolder", "tmpDir", "outputdir", "outputDIR", " destFile", " destFolder", "destDIR", "DestFile", "tempFolder", "tempDir", "tempFile", "tmpDirectory", "tmpDIR", "tempDIR", "DestDir", "DestFolder", "outputDirectory", " destDirectory", "tmpdir", "destDirectory", "outputFile", " destdir"], "urlConnection": ["URLConnect", "urlNetwork", "urlConnect", "webConnection", " urlConnect", "webChannel", "downloadFactory", "fileFactory", "fileConn", "URLChannel", "URLConnection", "webconnection", "downloadConnection", "downloadConn", "urlconnection", " urlChannel", "httpConnection", "fileConnection", "urlConn", "fileNetwork", "urlFactory", "httpFactory", "downloadNetwork", "webConnect", "URLconnection", "httpNetwork", " urlconnection", "urlChannel", "httpConn"], "tmpFile": ["partDir", "destFile", "mpFiles", " tmpFiles", "destFolder", " tmpfile", "partfile", "tempLine", " tmpLine", "tmpEntry", "zipfile", "tempEntry", "tmpDir", "mpFolder", "zipFiles", "destEntry", "tmpPath", "TempPath", "TempFile", " tmpDir", "destPath", "tmpFolder", "tmpLine", "tmpWorld", "tempDir", "partFolder", "destfile", "tempFile", "destWorld", "mpDir", "zipFile", "mpFile", "Tempfile", " tmpFolder", " tmpWorld", "TempWorld", "zipLine", "tempFiles", "tempfile", "mpfile", "tmpfile", "mpPath", "tempPath", " tmpEntry", "tmpFiles", " tmpPath", "partFile"], "in": ["gin", "ins", "din", "reader", "IN", "token", "login", "bin", "id", "inc", "ini", "input", "In", "conn", "inner", "err", "c", "Out", "ax", "en", "a", "i", "r", "connection", "info", "ex", "again", "n", "pull", "socket", "sync", "nin", "win", "inn", "min", "pin", "copy", "is", "arin", "l", "lin", "cin", "up", "data", "init", "source", "kin", "file", "work", "rin", "con", "ac", "as", "f"], "out": ["exec", "OUT", "client", "outs", "IN", "call", "login", "output", "bin", "io", "inc", "check", "one", "index", "conn", "In", "obj", "name", "cmd", "inner", "ext", "err", "no", "off", "this", "Out", "at", "writer", "i", "connection", "ex", "n", "again", "null", "o", "co", "sync", "socket", "nin", "outer", "min", "copy", "point", "line", "source", "op", "file", "up", "init", "server", "download"], "localURL": ["baseUrl", " localCL", "baseURL", "externalAPI", "localUrl", " localUrl", "externalURL", "LocalURL", "localCL", "externalUrl", "remoteUrl", "baseURI", " localURI", "LocalUrl", " localFile", "baseFile", "remoteURL", "remoteFile", "externalCL", "remoteURI", " localAPI", "LocalAPI", "localAPI", "localURI", "localFile", "LocalCL"]}}
{"id1": "4481712", "id2": "14464131", "code1": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://hostname:80\");\n            URLConnection conn = url.openConnection();\n            for (int i = 0; ; i++) {\n                String headerName = conn.getHeaderFieldKey(i);\n                String headerValue = conn.getHeaderField(i);\n                if (headerName == null && headerValue == null) {\n                    break;\n                }\n                if (headerName == null) {\n                }\n            }\n        } catch (Exception e) {\n        }\n    }\n", "label": 0, "substitutes": {"deleteObject": ["deleteObj", "removeItem", "saveItem", "saveObj", "saveDB", " deleteItem", "removeObject", "saveObject", " deleteObj", "deleteItem", "deleteDB", "removeDB", " deleteDB", "removeObj"], "id": ["url", "ip", "error", "delete", "ids", "model", "path", "sql", "string", "name", "lock", "Id", "sid", "database", "oid", "type", "i", "pid", "info", "root", "object", "parent", "query", "uri", "api", "resource", "key", "it", "in", "data", "source", "create", "ident", "uid", "ID", "f", "rid"], "conn": ["exec", "cm", "lc", "cf", "mc", "error", "client", "ca", "ai", "ann", "cache", "ou", "cb", "cur", "db", "log", "comm", "connect", "sql", "host", "core", "cr", "cp", "cms", "cmd", "lock", "c", "ci", "cc", "err", "rt", "auth", "org", "ct", "ec", "ssl", "connection", "Connection", "n", "parent", "config", "loc", "co", "nt", "enc", "nw", "cond", "sync", "dc", "orp", "pg", "h", "rc", "col", "cli", "pool", "cn", "ch", "server", "act", "coll", "pc", "con", "nc", "ac", "cat", "Conn", "serv", "conf", "ctx", "cmp", "po"], "stmt": ["stm", "tmm", " stql", "pttx", "strmi", "Stmp", " stm", " stmn", "Stmd", "Stm", " stmm", "strql", "strmn", " sttx", "stql", " stmr", " stmb", "stma", "istmt", "tmt", "dmb", "strmb", "dmt", "strtx", " stma", "stmd", " stmi", "dma", "strmm", "Stmb", "sttx", "istm", "Stma", " stmp", "Stmn", "istmr", "stmr", "strmt", "stmn", "ptql", "ptmt", "strmd", "tm", "stmi", " stmit", "Stmr", "stmm", "stmit", "istmit", "strmr", "stmp", "Stmi", "ptmn", "Stmt", "dm", "Stmm", "strm", "stmb", "strmp", " stmd", "tmn", "Stmit"], "dbConn": ["bbConnection", "dbConnection", "databaseconn", "bbconn", "databaseConnect", "dbconn", "bbConn", "bdConnect", "cbConn", "dbCon", "bdCon", " dbConnect", " dbConnection", "databaseConn", "bdConnection", "cbConnection", "cbConnect", "bdConn", "bbConnect", "databaseConnection", " dbconn", " dbCon", "dbConnect", "cbCon"], "selfConnection": ["selfReference", "thisConn", "SelfConn", "passconnection", "selfconnection", " selfConnect", " selfconnection", "selfConnect", "selfConn", "passConn", "thisconnection", "thisConnection", "SelfReference", "Selfconnection", "passConnect", "parentConnection", " selfConn", "SelfConnect", "parentconnection", " selfReference", "parentConn", "parentConnect", "passReference", "passConnection", "thisConnect", "thisReference", "SelfConnection"]}}
{"id1": "17202158", "id2": "5759961", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"readZoneIDs": ["loadzoneID", "readCodeIDs", "readZoneIDS", "readLocationIDS", "readLocationID", "readCodeNames", "loadzoneNames", "loadZoneID", "readzoneIDS", "readzoneNames", "loadzoneIDS", "readZoneID", "loadZoneIDs", "readLocationIDs", "readzoneID", "readCodeIDS", "loadZoneIDS", "readLocationNames", "readCodeID", "loadzoneIDs", "readZoneNames", "readzoneIDs", "loadZoneNames"], "zoneFileName": [" zoneDirUrl", "ZonefileUrl", "zoneFilename", "zoneFullPath", "zoneFileUrl", "zoneFilesPath", "zoneFullUrl", "zoneDirUrl", "Zonefilename", "zoneClassPath", "ZoneFileName", "zonefileUrl", "zoneFullname", "zoneLineName", "ZoneFilePath", "zoneLineUrl", "ZoneFileUrl", "zonefilename", " zoneDirName", "zoneClassName", " zoneFileUrl", "zoneFullName", "zoneClassname", " zoneDirPath", "ZonefilePath", "zoneDirName", "zoneClassUrl", "zonefilePath", "ZonefileName", "zoneFilesName", "zoneLinePath", "zoneFilePath", "zonefileName", "zoneDirPath", "zoneFilesUrl", "ZoneFilename", "zoneFilesname", " zoneFilePath"], "zoneids": ["poids", "sizeid", " zoneints", "ZoneIDs", "typeips", "zipid", "ziplines", "pofiles", " zoneid", "sizeips", "zonefiles", "typeids", "typeints", "zipIDs", "zoneips", "poIDs", "sizeints", "zoneIDs", "zipids", "Zoneids", "typeid", " zonelines", " zoneIDs", "Zoneid", " zonefiles", "zoneints", "polines", " zoneips", "poid", "sizeids", "Zonefiles", "zonelines", "zoneid"], "url": ["address", "base", "reader", "client", "job", "re", "feed", "io", "URL", "ball", "path", "sl", "Url", "location", "string", "name", "stream", "hub", "this", "ssl", "connection", "r", "class", "b", "user", "loader", "ur", "buffer", "uri", "service", "resource", "api", "bel", "http", "l", "page", "source", "file", "server", "data", "channel", "f"], "lnr": ["linw", "nlb", "slb", "linn", "nlw", "nlr", "lenr", "lenw", "linp", "slrb", "nlp", "slr", "sln", "lnw", "lenp", "lnp", "lnb", "rlb", "rlrb", "rlr", "linr", "lenb", "lnn", "lnrb", "linb", "linrb", "rln"], "line": ["lc", "cl", "header", "base", "column", "str", "parse", "el", "id", "log", "nl", "row", "sl", "ge", "string", "name", "Line", "lines", "word", "no", "link", "c", "code", "LINE", "sel", "look", "number", "rule", "block", "message", "cell", "key", "jo", "lf", "page", "lin", "data", "file", "l", "entry", "col", "char", "letter", "inline", "ne", "part", "unit", "comment", "response", "le"]}}
{"id1": "10728243", "id2": "481364", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "label": 0, "substitutes": {"scramble411": ["scrambe41", "scrambe411", "scramcy411", "screamprint411", "scramprint411", "scramprint123", "screamble411", "screamprint123", "scramble41", "scramcy123", "scramble123", "scramprint5", "screamble41", "scramcy41", "scrambe5", "screamprint41", "screamprint5", "scramcy5", "scramble5", "screamble5", "scramprint41", "screamble123", "scrambe123"], "password": ["hash", "address", "sudo", "account", "token", "Password", "project", "sword", "security", "wallet", "path", "input", "filename", "string", "name", "word", "prefix", "auth", "words", "username", "crypt", "user", "number", "config", "pad", "padding", "attribute", "wd", "key", "mac", "phrase", "PASS", "channel", "dh", "secret", "email", "pass", "sum"], "seed": ["shadow", "hash", "address", "pair", "template", "sudo", "token", "alias", "id", "zip", "prime", "volume", "pattern", "machine", "string", "length", "state", "name", "offset", "driver", "prefix", "username", "mode", "crypt", "text", "slice", "eed", "pad", "padding", "key", "phrase", "finger", "Salt", "source", "secret", "device", "pass", "random", "sum", "size"], "md": ["mad", "MD", "cm", " Md", "mc", "sha", "ms", "metadata", "rm", "pm", "bd", "amd", "am", "bm", "df", "mo", "meta", "mb", "mt", "ind", "cmd", "hd", "doc", "pkg", "sm", "mi", "mand", "m", "dd", "mode", "om", "Cmd", "gd", "km", "od", "mg", "grad", "diff", "mm", "ma", "ad", "pd", "dc", "kg", "cd", "ds", "wd", "nd", "mac", "mn", "hm", "mp", "di", "addr", "ld", "dh", "mid", "d", "mag", "nm", "vd", "dm", "ht", "mem", "part", " MD", "dig", "po"], "passwordHashStage1": ["passwordHashStage4", "passwordHashstageOne", "passwordHashstage3", "passwordHashstage1", "passwordSumPhase1", "passwordSumStage1", "passwordSumPhase2", "passwordHashstage2", "passwordHashPhase1", "passwordHashPhaseOne", "passwordHashstage4", "passwordSumStage4", "passwordHashStep3", "passwordHashStage3", "passwordHashstage0", "passwordHashPhase4", "passwordHashStage0", "passwordSumPhase3", "passwordHashStageOne", "passwordSumStage2", "passwordSumPhase4", "passwordHashPhase3", "passwordSumPhase0", "passwordHashPhase0", "passwordHashStep1", "passwordSumPhaseOne", "passwordSumStage0", "passwordHashStep2", "passwordSumStageOne", "passwordHashPhase2", "passwordSumStage3"], "passwordHashStage2": ["passwordHashStage4", "passwordBlockstage2", "passwordSumPhase02", "passwordBlockstage8", "passwordHashPhase8", "passwordSumStageTwo", "passwordBlockStage2", "passwordSumStage02", "passwordHashstage1", "passwordSumPhase1", "passwordHashStage8", "passwordSumPhaseTwo", "passwordHashStage02", "passwordSumStage1", "passwordSumPhase2", "passwordHashstage2", "passwordHashstage02", "passwordHashstage4", "passwordHashPhase1", "passwordHashPhase02", "passwordBlockStage1", "passwordHashPhase4", "passwordHashstageTwo", "passwordBlockStage8", "passwordSumStage2", "passwordBlockstage1", "passwordHashStep1", "passwordHashstage8", "passwordHashPhaseTwo", "passwordHashStep4", "passwordBlockstage4", "passwordHashStageTwo", "passwordHashStep2", "passwordBlockStage4", "passwordHashPhase2", "passwordHashStep8"], "toBeXord": ["toBeYord", "tobeXors", "tobeXorder", "toBeWorkor", "toBeXords", "toBeZords", "toBeCrossords", "tobeYorder", "toBeWorkorder", "tobeXor", "toBEXords", "toBeYords", "toBeZors", "toBeZor", "toBeXors", "toBeWorkords", "tobeYor", "tobeYors", "toBEYor", "toBeYorder", "toBeCrossors", "tobeCrossord", "toBeZORD", "toBeXorder", "toBeXORD", "toBeWorkors", "tobeXords", "toBeWorkORD", "toBEXor", "toBEYords", "tobeCrossors", "toBeWorkord", "toBeXor", "tobeYord", "toBEXord", "toBeYors", "tobeXord", "toBeZord", "tobeCrossords", "toBEYORD", "toBeCrossORD", "toBEXORD", "toBeCrossor", "toBeYORD", "toBeZorder", "toBEYord", "tobeCrossor", "toBeYor", "toBeCrossord"], "numToXor": ["num2Absorer", "numToCrossorer", "numToxor", "numToAbsOR", "numToWorkors", "numToXOr", "numtoXOR", "numToAnyorer", "numToAnyOr", "numtoXor", "numToWorkOR", "num2AbsOR", "numToCrossOR", "num2Absor", "numToxors", "numToAnyOR", "numToAnyor", "numToXOR", "numToCrossors", "numtoXors", "numToxOR", "numToWorkor", "numtoXorer", "num2XOr", "numToCrossOr", "num2AbsOr", "numtoxOR", "numtoxors", "numtoxorer", "num2Xor", "numToAbsOr", "numToCrossor", "num2Xorer", "numToXors", "numToAbsor", "numToxorer", "numToWorkorer", "numToXorer", "numtoxor", "num2XOR", "numToAbsorer"], "i": ["qi", "v", "z", "k", "ip", "ai", "ti", "I", "e", "id", "io", "xi", "x", "index", "u", "li", "ui", "hi", "multi", "ci", "c", "off", "si", "ii", "y", "m", "j", "t", "a", "r", "info", "b", "n", "o", "bi", "slice", "ri", "uri", "p", "key", "gi", "h", "ix", "abi", "it", "l", "in", "oi", "di", "d", "chi", "part", "f", "pi"]}}
{"id1": "12389873", "id2": "19378010", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException {\n        final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath);\n        final Multimap<String, String> proteins = HashMultimap.create();\n        for (final String query : queries) {\n            HttpURLConnection connection = null;\n            try {\n                final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\");\n                final URL url = new URL(String.format(__urlTempl2, encoded, taxon));\n                connection = (HttpURLConnection) url.openConnection();\n                connection.setConnectTimeout(__connTimeout);\n                connection.setReadTimeout(__readTimeout);\n                connection.setRequestProperty(\"Connection\", \"close\");\n                connection.connect();\n                final InputStream stream = connection.getInputStream();\n                final Document doc = parser.parse(stream);\n                final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET);\n                if (nodes != null) {\n                    final int n = nodes.getLength();\n                    for (int i = 0; i < n; i++) {\n                        final Node node = nodes.item(i);\n                        proteins.put(node.getTextContent().trim(), query.trim());\n                    }\n                }\n            } catch (final Exception ex) {\n                continue;\n            } finally {\n                if (connection != null) connection.disconnect();\n            }\n        }\n        return proteins;\n    }\n", "label": 0, "substitutes": {"load": ["test", " reload", "Load", "loading", "save", "transfer", "ready", "write", "link", "build", "read", "construct", " Load", " loaded", "config", "sync", "add", "get", " loading", "process", "init", "download", " loads", "dump", "clone", "select", "Loading"], "conn": ["exec", "mc", "client", "ca", "ann", "cache", "util", "reg", "db", "oci", "pt", "connect", "session", "ns", "sql", "state", "ls", "cp", "cr", "c", "ci", "cc", "rt", "ct", "ec", "sb", "connection", "Exec", "Connection", "n", "config", "co", "enc", "nt", "loc", "pub", "dc", "p", "h", "pg", "dn", "col", "cn", "ch", "act", "dh", "coll", "pc", "con", "nc", "cat", "Conn", "conf", "ctx", "pr"], "stmt": ["playtr", " sttr", " stmn", "esttr", "stager", " stmr", "astmn", "atmt", "astk", "fldo", "osttr", "estmd", "strs", "Stdb", "putur", "STml", "stb", " str", "playml", "stMT", "slager", "STbl", "stmr", "Stts", "Stpl", "stbt", "atmn", " strs", "stts", "actbl", "plb", "STdb", " stor", "Stur", "ostpr", "elmt", "stmb", "STnt", " sttor", "strdo", "stm", "playmt", "tct", "estct", "slk", "StMT", "putmb", "putts", "playor", "estMT", "stql", " stmb", "acttor", "dmd", "dmt", "Sttor", "dnt", "astmt", "astql", "playmn", "themn", "Stmn", "plr", "Stpr", "slr", "slmn", "flmt", "tm", "ostmt", "STpl", "Stmr", "ostct", "flk", "stct", "Stmt", " stk", "elrs", "Stnt", "actmt", " stager", "slnt", "STMT", "Stmd", "sttor", "stnt", "str", "Sttr", "elml", "puttr", "Stth", "estmt", "STmn", " stbt", "stk", "clur", "slmt", "plnt", "Stbt", "cltr", "flmd", " stb", "stmd", " stmi", "atMT", "STct", " stdb", "plmt", "stth", "stor", "themt", "stpr", "strmt", "strmd", "atb", " stct", "stdo", " stpl", "acttr", "STmt", "Stager", "Stmc", " stth", "clmn", "stbl", "estmr", "Stor", "STmd", " stts", "STk", "estk", "Stb", "stdb", "stmc", " stql", " stm", "putmn", "putmi", "stur", "Stm", "putbt", " stMT", "strk", "elmi", "tmt", " stbl", "STager", "stpl", "putml", "clmt", "plMT", "estth", "Stbl", "ostmn", " stmc", "putrs", "Stmb", "estdo", "STql", " stnt", "ostpl", "stml", "stmn", "theb", "estql", "plmn", "dMT", "sttr", " stml", "stmi", " stpr", "themc", "playpl", "tpl", "putmt", "ostager", "Stql", "Stml", "Stct"]}}
{"id1": "13233761", "id2": "17773263", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 1, "substitutes": {"executeUpdateTransaction": [" executeUpdateTx", "executeUpdateStatement", " executeDatabaseTx", "executeUpdateTx", "executeDatabaseTransaction", "executeDatabaseTx", " executeDatabaseSession", "executeDatabaseStatement", "executeQuerySession", " executeDatabaseTransaction", "executeQueryStatement", "executeInsertSession", "executeUpdateSession", " executeUpdateSession", "executeInsertTx", "executeInsertTransaction", "executeDatabaseSession", " executeDatabaseStatement", "executeInsertStatement", " executeUpdateStatement", "executeQueryTx", "executeQueryTransaction"], "queries": ["questands", "blests", "commips", "bleries", "compests", "questires", "squeries", "commires", "squests", "squands", "quands", "questeries", "squires", "squips", "compands", "commands", "commeries", "questips", "blands", "comperies", "quips", "blips", "quests", "compips", "quires"], "autoCommit": ["AutoCommits", "AutoDebit", " autoCommitted", " autoComitted", "autocommit", "autocommmit", "autoCompits", "autoommit", "autoCommits", "autoommmit", "autoommitted", "autoDebmit", "autoDebit", "autoCommitted", "AutoDebrit", " autoComits", "AutoCommit", "autoommits", "autoComit", "autocommrit", "autoComits", " autoCommits", "autoCompmit", "AutoDebmit", " autoCommmit", "autocommits", "autoDebrit", "autoCompitted", "AutoCommmit", "AutoDebits", "autoDebits", "autoCommrit", "autoComitted", "autoCompit", "autoCommmit", "autoComrit", "AutoCommrit", " autoComit"], "iterator": ["started", "reader", "ter", "finder", "metadata", "runners", "ator", "interstitial", "vector", "series", "cher", "index", "creator", "former", "pointer", "start", "sequence", "string", "context", "end", "stream", "inner", "section", "set", "next", "database", "starter", "Iterator", "population", "step", "ie", "i", "info", "connection", "encer", "handler", "internet", "slice", "list", "walker", "gener", "inst", "loader", "division", "ski", "iter", "outer", "adder", "done", "consider", "parser", "entry", "data", "filter", "init", "loop", "instance", "later", "collection", "runner", "size", "inter"], "query": ["result", "Query", "call", "str", "command", "row", "sql", "q", "string", "sequence", "name", "action", "next", "expression", "sq", "connection", "ql", "join", "rule", "press", "update", "message", "uri", "table", "qu", "key", "condition", "search", "commit", "data", "entry", "question", "filter", "style", "record", "value", "script", "comment", "select"], "statement": ["result", "stat", "use", "command", "function", "session", "sql", "mt", "string", "start", "state", "s", "conn", "sequence", "action", "section", "next", "database", "si", "storage", "expression", "element", "connection", "join", "ment", "inst", "table", "parser", "usage", "flush", "document", "condition", "commit", "data", "execute", "style", "Statement", "script", "unit", "comment", "response"]}}
{"id1": "21642215", "id2": "9267602", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"addIDs": ["addLinks", "findIDS", "loadID", "addID", "loadIDS", "addIDS", "findLinks", " addLinks", "findID", " addID", "loadLinks", " addIDS", "loadIDs", "findIDs"], "row": ["result", "reader", "column", "job", "builder", "view", "feed", "raw", "index", "tab", "bug", "info", "r", "report", "user", "rows", "batch", "scan", "Row", "head", "tr", "query", "ow", "per", "list", "table", "post", "array", "key", "copy", "col", "entry", "up", "ry", "server", "ro", "group", "record", "item", "cell"], "name": ["description", "alias", "title", "str", "ame", "path", "Name", "filename", "start", "string", "time", "named", "word", "image", "prefix", "username", "type", "info", "connection", "number", "n", "NAME", "query", "resource", "key", "search", "filter", "file", "source", "size"], "in": ["serv", "gin", "ins", "reader", "din", "IN", "cache", "token", "gen", "re", "login", "bin", "inc", "container", "path", "xml", "ini", "input", "session", "ic", "out", "In", "s", "conn", "stream", "inner", "string", "image", "err", "c", "doc", "lock", "m", "ssl", "a", "i", "r", "at", "user", "b", "ex", "n", "again", "with", "rec", "query", "socket", "diff", "nin", "win", "update", "buffer", "iter", "inn", "resource", "min", "pin", "it", "is", "http", "l", "source", "cin", "file", "init", "con", "as", "record", "f"], "urlName": ["lName", " urlType", "lType", "urlStr", "lStr", "UrlStr", "URLname", " urlStr", "UrlPath", "filename", "urlname", "Urlname", "toolPath", "urlType", "toolname", "UrlPart", "UrlName", "URLName", " urlPart", "UrlType", "filePart", "urlPath", "toolName", "filePath", " urlPath", " urlname", "lname", "URLPath", "urlPart", "fileName", "lPath"], "url": ["base", "reader", "client", "feed", "io", "URL", "path", "sl", "input", "Url", "fl", "out", "gl", "stream", "image", "link", "hub", "org", "ssl", "connection", "r", "user", "b", "socket", "loader", "buffer", "uri", "service", "resource", "bel", "http", "l", " URL", "file", "channel", "source", "server", "open", "web", "f"], "inputLine": ["readSync", " inputSync", "typeLine", "InputSource", "indexLINE", " inputStream", "rawLine", "requestEmail", "inputWrite", "inputLo", "readLin", "dataSource", "issueLin", "dataLin", "inputStream", "accessLine", "readLine", "execUrl", "formLin", "updateLINE", "indexEntry", " inputL", "dataLink", "responseFile", "htmlLINE", "requestLINE", " inputEntry", "typeline", "inputLook", "againUrl", "InputStream", "dataLo", "inputLin", "againWrite", "requestline", "baseLINE", "Input\n", "uploadLin", "inputFile", "issueLine", "execLine", "readL", "readline", "dataUrl", "InputSync", "issueline", "dataline", "indexLine", " inputSource", " inputLink", "typeLink", " inputLo", "accessEntry", "inputRoute", " inputEmail", " inputUrl", " inputSel", "readLook", "InputLine", "requestUrl", "dataWrite", " inputline", "baseline", "updateLin", "htmlLine", "InputLo", "output\n", "dataBlock", "dataRoute", "requestLine", "inputEntry", "InputBlock", "inputString", "inputLINE", "inputEmail", "InputL", " inputLin", "searchLine", "rawFile", "updateLine", "againLINE", "htmlline", " inputString", "uploadLine", "input\n", "inputL", "updateline", "responseLINE", "dataLINE", "accessSync", " inputLINE", "searchStream", "uploadline", "InputRoute", "formLine", "inputUrl", "InputLink", " input\n", "indexSync", "dataLine", "againLine", "responseLink", "baseLine", "searchFile", " inputBlock", "inputBlock", " inputFile", "searchL", "dataSync", "requestString", "execEmail", "inputSel", "dataLook", "execline", "issueSel", "accessLINE", "inputLink", "inputSource", "readFile", "InputFile", "rawline", "responseLine", "formLINE", "InputLINE", "Inputline", "typeLINE", " inputWrite", "rawL", "inputline", "inputSync", "uploadSel", "formline", "baseFile", " inputRoute", "dataFile", "htmlString", " inputLook"], "score": ["feature", "test", "result", "error", "level", "grade", "status", "fit", "index", "core", "length", "ranking", "seed", "winner", "time", "scoring", "loss", "price", "code", "rate", "Score", "live", "count", "player", "speed", "weight", "ner", "game", "message", " Score", "gain", "rank", "key", "fee", "confidence", "cost", "match", "sc", "width", "value", "rice", "size"], "metaboliteID": ["metaboliteSize", "metovaliteIndex", "metovalriteID", "metabolidateInfo", "metabolicizeName", "metabolidateID", "metabolverseIN", "metovaliteID", "metmboliteSize", "metabolizeName", "metaboliciteName", "metabolitationId", "metovaliteIN", "metaboliteIN", "metabolidateName", "metmboliteId", "metaboliteType", "metaboliciteInfo", "metabolriteSize", "metabololeIndex", "metabololeSize", "metmbolitableID", "metmbolitableName", "metaboliqueID", "metovalriteAddress", "metabolitionId", "metaboliteIndex", "metabololeID", "metabolitableIndex", "metabolitionIndex", "metabolicizeID", "metaboliqueIDs", "metabolicizeInfo", "metabolheticAddress", "metovalriteIN", "metabolizeID", "metovaliteAddress", "metabolitationIN", "metovalriteName", "metabolverseName", "metabolriteIDs", "metaboliteInfo", "metovalriteIndex", "metabolriteId", "metmboliqueType", "metabolriteScore", "metabolriteIndex", "metmbolitableIndex", "metmboliqueId", "metabolidateScore", "metmboliteIDs", "metabolriteAddress", "metaboliteScore", "metaboliciteScore", "metabolriteType", "metabolitationName", "metabololeName", "metabolriteName", "metabolitableSize", "metabolitationID", "metabolizeScore", "metovaliteId", "metmboliqueID", "metabolitableIDs", "metabolheticID", "metmboliqueIDs", "metabolizeInfo", "metmboliteName", "metovaliteName", "metabolriteInfo", "metabolriteID", "metabolitableType", "metaboliteName", "metovalriteId", "metaboliteId", "metabolverseId", "metaboliteAddress", "metabolriteIN", "metmbolitableSize", "metmboliteID", "metaboliqueId", "metabolitableId", "metabolverseID", "metaboliqueType", "metabolheticId", "metmboliteType", "metmboliteIndex", "metaboliciteID", "metaboliteIDs", "metabolitableName", "metabolitionAddress", "metabolitionID", "metabolheticIndex", "metabolicizeScore", "metabolitableID"], "dataScore": ["doubleRank", "indexID", "numberRank", " dataRank", " dataWeight", "dataSum", "DataLevel", " dataMatch", " dataPath", "DataRank", "indexPath", "inputMatch", "doubleScore", "laPath", "DataSize", "laLevel", "videoSize", "DataPath", " dataGrade", "DataScore", "dataSource", "inputSource", "inputSize", "styleScore", "doubleWeight", "inputID", "dataGrade", "videoWeight", "dataType", "inputScore", "indexScore", "inputPath", "indexSource", "styleSize", " dataLevel", "dataPath", " dataSource", " dataID", "styleWeight", " dataType", "videoType", "dataMatch", "doubleType", "styleType", "numberLevel", " dataSum", "dataRank", "DataGrade", "dataID", " dataSize", "dataWeight", "laSum", "DataSum", "numberGrade", "DataMatch", "numberWeight", "dataLevel", "videoScore", "numberScore", "laScore", "dataSize", "numberType"], "data": ["picture", "map", "result", "error", "ata", "change", "sample", "zip", "DATA", "div", "input", "string", "ui", "image", "missing", "results", "code", "extra", "info", "batch", "dat", "number", "text", "body", "empty", "weight", "pad", "message", "array", "media", "resource", "done", "alpha", "key", "content", "buffer", "source", "style", "value", "json", "area", "split", "size", "response"], "molecularWeight": ["moleciumWidth", "moleuralSize", "moleularWeight", "mosellularFlow", "molecularSize", "mosellularWeight", "molellularFlow", "moleculeSize", "mosecularWeight", "molecularWidth", "moleculeFlow", "moleculeWeight", "molesularWidth", "moleciumFlow", "moleuralWidth", "moleularSize", "moleularWidth", "molescularSize", "moleciumWeight", "mosecularWidth", "molescularWidth", "molescularWeight", "mosecularFlow", "mosellularWidth", "moleuralWeight", "molesularWeight", "molellularWidth", "molecularFlow", "molellularWeight", "molesularSize", "moleculeWidth"]}}
{"id1": "16825994", "id2": "19096138", "code1": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"run": ["exec", " test", " call", "Run", "call", "output", "transfer", "command", " cmd", " exec", "start", "cmd", " deploy", " process", "Exec", "copy", " execute", " Run", "process", "work", "execute", "init", " exit", "runner", "unit", "exit"], "out": ["exec", "url", "result", "cl", "base", "error", "OUT", "client", "outs", "cache", "w", "output", "io", "inc", "raw", "log", "session", "conn", "string", "obj", "In", "ext", "cmd", "err", "c", "prefix", "Out", "plain", "cfg", "ssl", "info", "ex", "again", "parent", "config", "diff", "sync", "strip", "array", "cli", "up", "file", "ch", "password", "ref", "gz", "con", "part", "sum", "temp"], "srcDir": ["srcdir", "srcDIR", "rcFolder", "srcFile", "sourceFolder", "sourcedir", "rcdir", " srcDIR", "rcDir", " srcdir", "locDIR", "locDir", "locFolder", " srcDirectory", "sourceFile", "rcDIR", "rcFile", "sourceDirectory", "locDirectory", "srcFolder", "rcDirectory", " srcFile", "srcDirectory", " srcFolder", "sourceDir"], "conf": ["bc", "cm", "cl", "cf", "lc", "base", "url", "client", "ca", "cache", "com", "log", "ctx", "ini", "host", "Config", "conn", "conv", "cp", "obj", "err", "cc", "c", "cfg", "global", "info", "ssl", "def", "Conf", "config", "fs", "fi", "af", "cli", "ch", "file", "sc", "init", "ref", "cn", "con", "cb", "f"], "srcFS": ["rcfs", "sourceTS", " srcFs", "srcFs", "sourceFs", "sourcefs", "rcFs", "srcfs", "srcTS", "rcFS", "sourceFS", " srcDF", "srcDF", " srcTS", "sourceDF", " srcfs", "rcDF", "rcTS"], "contents": ["compens", "collens", "intants", "contentences", "contences", "Contors", "CONTors", "intonents", "compences", "intodes", "CONTences", "collants", "Contributes", "Contents", "intributes", "contributes", "explonents", "CONTens", "explodes", "condents", "condent", "CONTent", "Contonents", "compents", "contants", "continences", "Contodes", "continants", "contonents", "continents", "collents", "contens", "collent", "requens", "contodes", "contentants", "Content", "CONTents", "condors", "content", "contentens", "requences", "continens", "contentents", "intens", "explents", "explributes", "intences", "continent", "CONTants", "contors", "condants", "compent", "Contants", "requent", "requents", "intents"], "i": ["qi", "v", "lc", "k", "iv", "ip", "ai", "sup", "ti", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "start", "u", "li", "ui", "inner", "hi", "multi", "ci", "c", "si", "phi", "ii", "y", "m", "j", "ie", "info", "b", "o", "slice", "ri", "uri", "p", "key", "gi", "h", "fi", "abi", "it", "di", "oi", "ix", "l", "d", "yi", "ji", "f", "pi"], "in": ["gin", "ins", "din", "reader", "IN", "login", "bin", "id", "isin", "inc", "ini", "input", "In", "conn", "inner", "stream", "image", "c", "err", "inas", "ax", "r", "again", "tin", "socket", "nin", "resource", "inn", "min", "pin", "cin", "data", "lin", "source", "l", "inside", "kin", "init", "d", "rin", "con", "ac", "as", "part", "serv", "impl"]}}
{"id1": "12236729", "id2": "2668634", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" copying", "transfer", "php", "zip", "io", "Copy", " copied", "replace", "py", "cp", "upload", "clone", "cop", "sync", "diff", "clip", "p", "get", " transfer", "download", " dup", "dump", "split", "cat", " Copy", "paste", "cmp"], "inputFile": ["outputDir", "sourceFiles", "currentDir", "inputDir", " inputFiles", " inputPath", "sourcePath", "inputPath", "sourcefile", " inputfile", "sourceFile", "inputFiles", "outputFiles", "outputfile", " inputDir", "currentFiles", "currentFile", "currentfile", "inputfile", "outputPath"], "outputFile": [" outputFilename", "OutputFile", " outputDir", "outputDir", "referencefile", "inputDir", " outputDirectory", " outputfile", "outputFilename", "OutputDirectory", "tempDir", "referenceDir", "OutputDir", "tempFile", "tempDirectory", "outputfile", "referenceFile", "inputFilename", "tempfile", "outputDirectory", "Outputfile", "referenceFilename", "inputfile"], "in": ["gin", "ins", "reader", "din", "IN", "login", "bin", "e", "id", "inc", "ini", "input", "In", "s", "conn", "inner", "ln", "image", "err", "lock", "read", "a", "i", "r", "connection", "n", "again", "sin", "pull", "socket", "nin", "win", "inn", "min", "pin", "get", "is", "into", "l", "lin", "source", "up", "file", "init", "inside", "kin", "cin", "con", "as", "f"], "out": ["net", "exec", "v", "error", "OUT", "outs", "cache", "w", "output", "bin", "io", "inc", "one", "log", "outside", "conn", "obj", "write", "err", "off", "Out", "plain", "extra", "at", "writer", "i", "b", "ex", "n", "again", "parent", "o", "over", "null", "sync", "socket", "post", "outer", "plus", "line", "file", "up", "temp"], "c": ["cm", "v", "k", "cl", "lc", "cf", "cy", "uc", "e", "id", "C", "x", "pointer", "u", "cr", "ci", "cc", "character", "code", "m", "ct", "ec", "a", "i", "count", "r", "cu", "b", "n", "ce", "esc", "o", "fc", "cd", "p", "rc", "col", "line", "l", "char", "sc", "ch", "d", "pc", "xc", "f"]}}
{"id1": "23672408", "id2": "23452437", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"copyIconFiles": ["copyFileImages", " copyiconFiles", "copyIconTypes", " copyiconTypes", "copyFileFile", "copyFileTypes", "copyIconFile", "copyIconImages", "copyImageTypes", " copyIconTypes", "copyiconFiles", "copyImageImages", "copyFileFiles", " copyiconFile", " copyiconImages", "copyImageFile", " copyIconFile", " copyIconImages", "copyiconFile", "copyiconTypes", "copyImageFiles", "copyiconImages"], "clazz": ["llasse", "Closs", "helllass", " closed", "clobe", "hellasso", "Cllass", "llaz", "glaz", "slosed", "sluster", "hellobe", "Clazz", "glazz", "cluster", "Claz", "slod", "llobe", " clab", " classo", "Closer", "Clab", " clunk", "clclass", " clclass", "slazz", "CLod", " clobe", " cllass", "clance", "Cluster", "clab", "llclass", "Clclass", "clunk", " clance", "slaz", " classe", " closer", "fluster", "hellazz", "flazz", "sllass", "classe", "classo", "CLazz", "hellasse", "CLance", "plazz", "flunk", "hellance", "CLaz", " closs", "cllass", "closs", "glod", "ploser", "claz", "Clunk", "flaz", " cluster", "clod", "llab", " claz", "closed", "plclass", "hellosed", "glance", "pllass", "llasso", "sloss", "closer", "slance", "llazz"], "i16": ["i24", "I15", "io2016", "ai14", "si2016", "ii24", "l15", "ai15", "ini17", "si15", "l64", "si64", "io15", "io16", "io24", "ini15", "i15", "si14", "ini2016", "i17", "I16", "ini16", "l24", "si16", "ai2016", "ini14", "l16", "int24", "I17", "ai16", "pi24", "ii15", "int15", "ii2016", "i2016", "int16", "i14", "ii14", "i64", "si24", "ii16", "pi16", "I14", "ii17", "int2016", "pi15", "pi64"], "fileType": ["letterState", "iconLength", "fileStyle", "transferFamily", "singleTime", "playTy", " filetype", "fileSpread", " fileTime", "imageFile", "imageKey", "fileTime", "messageType", "FileLocation", "imageStyle", "fileAuth", "fileTy", "fileBlock", "imageType", "imageTime", "wordAuth", "letterTy", "filePath", "filetype", "wordType", " fileTy", "FileType", " fileLength", "feedType", "playType", "messagetype", "FileLike", " fileBlock", "fileInfo", "lettertype", "feedInfo", " fileAuth", "FileFamily", " fileFile", "documentType", "messagePath", "fileLocation", "documenttype", " fileUnit", "wordLength", "singleStyle", "imageUnit", "fileLike", "iconType", "iconKey", "documentBlock", "feedPatch", " fileInfo", "messagePatch", "iconPath", "fileFamily", "letterBlock", "iconStyle", "singleFile", "iconAuth", "fileLength", " fileKey", "feedLocation", "fileFile", "wordTy", " fileLike", "letterFamily", " fileState", " filePatch", "playFamily", " filePath", "FileStyle", "documentState", "imageFamily", "filePatch", " fileStyle", "playSpread", "transferSpread", "transferType", " fileFamily", "transferTy", "feedLike", "fileKey", "letterType", "iconTy", "feedtype", "imagePath", "feedPath", "fileState", "letterSpread", "FileInfo", "FileUnit", "singleType", " fileLocation", "fileUnit"], "desti16": ["destsi64", "destabi15", "combini15", "destf16", "targeti2016", "destI15", "combi15", "destsi32", "desti016", "destf2016", "destI2016", "destini16", "destabi016", "targetI2016", "targetI16", "desti64", "destini64", "combi16", "combini32", "combini16", "desturi64", "destini32", "destI016", "desturi16", "desti2016", "destI16", "combini64", "targeti16", "destsi16", "targetI15", "destsi15", "destf15", "targeti15", "targetI016", "destf016", "desturi15", "targeti016", "destabi2016", "combi64", "desturi32", "desti15", "destini15", "combi32", "destabi16"], "src": ["iv", "st", "tmp", "cur", "filename", "secure", "hub", "sel", "ssl", "desc", "front", "null", "pull", "usr", "thumbnails", "sc", "file", "data", "scenes", "coll", "ctrl", "https", "console", "gb", "cv", "proc", "func", "input", "target", "conv", "s", "pkg", "uv", "b", "video", "ug", "dest", "attr", "back", "grad", "rb", "http", "in", "rl", "cb", "ser", "uc", "sr", "crop", "sl", "stream", "upload", "lib", "sq", "buf", "config", "loc", "socket", "inst", "uri", "resource", "rc", "source", "bh", "download", "gz", "rss", "ource", "sys", "url", "img", "output", "view", "load", "scene", "default", "gl", "image", "r", "root", "cdn", "sync", "support", "rob", "dist", "req", "ctx", "bs", "cmp"], "dst": ["dsdr", "dsost", "idbl", "Dost", "ddest", "Dsts", " dste", "idsc", "dste", "dost", "rdput", "rdst", "idrd", "dsput", "dedst", "dbl", " dput", "dsts", "dsst", "adost", "dput", " dest", "drest", "dct", "dsl", "nste", "ddr", "adct", "adbl", " dbl", "iddest", "ldost", "ldbl", "idest", "dest", "dedput", "Dbl", "ldst", " dST", "idst", "idsl", "nst", "sdsc", "rdST", " drest", " dsc", "nrest", "Dst", "Ddr", "rdsc", "drd", " ddest", "adst", "sdbl", "deddr", "sdst", "sdsl", "dedost", "nsts", "dST", "drsc", "Dct", "sddest", "Dste", "Drest", "Dput", "drst", "dsc", "sdrd", "drST", "drput", " dsl", "sdest", " drd", "ldct", " dsts"], "i32": ["I42", "si32", "in32", "I32", "si33", "si22", "ini32", "ui31", " i34", "i35", "in33", " i33", "ini33", "ui30", "iu15", "in15", "i33", "i15", "si35", "ri32", "ui34", "in34", "ri42", "qi32", "i31", "qi33", "qi34", " i35", "ri35", "I30", "i42", " i31", "ini22", " i22", "I35", "qi15", "ui32", "I34", "I31", " i30", "i22", "ini35", " i42", "I33", "ri33", "iu32", "iu34", "i30", "iu33", "i34"], "desti32": ["destabi15", "destiu28", "destabi16", "destiu33", "destsi32", "destii33", " desti22", "destic32", " destsi22", "targeti32", "desti28", "destic15", "destsi22", " desti15", "destabi22", "desti33", " destsi15", "targetiu33", "destiu34", "destii28", "destin32", "desti22", "targetiu28", "destsi16", "destiu32", "targeti28", "destsi15", "destin28", "destabi32", "desti34", "destic16", "targetiu34", "destii34", " destsi32", "targeti34", "destin34", "targetiu32", "destin33", "desti15", "targeti33", " destsi16", "destic22", "destii32"]}}
{"id1": "14188043", "id2": "3375718", "code1": "    public static byte[] openHttpResult(String urlPath, boolean retry) throws IOException {\n        AQUtility.debug(\"net\", urlPath);\n        URL url = new URL(urlPath);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setUseCaches(false);\n        connection.setInstanceFollowRedirects(true);\n        connection.setConnectTimeout(NET_TIMEOUT);\n        int code = connection.getResponseCode();\n        if (code == 307 && retry) {\n            String redirect = connection.getHeaderField(\"Location\");\n            return openHttpResult(redirect, false);\n        }\n        if (code == -1 && retry) {\n            return openHttpResult(urlPath, false);\n        }\n        AQUtility.debug(\"response\", code);\n        if (code == -1 || code < 200 || code >= 300) {\n            throw new IOException();\n        }\n        byte[] result = AQUtility.toBytes(connection.getInputStream());\n        return result;\n    }\n", "code2": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "label": 0, "substitutes": {"openHttpResult": ["openRouteResult", "openNetworkresult", "closeHttpresult", "openSocketRequest", "openNetworkRequest", "openHTTPresult", "closeHTTPSource", "openHttpResponse", "openUrlresult", "openNetworkResult", "getHttpResult", "openSocketResponse", "getHttpRequest", "openttpResult", "getHTTPResponse", "closeHTTPresult", "openhttpRequest", "openHttpRequest", "openSocketSource", "openhttpResult", "closeHTTPRequest", "openHTTPResponse", "closeHTTPResult", "openRouteRequest", "closeHttpMessage", "openUrlResponse", "openttpMessage", "closeHttpSource", "getHTTPresult", "getHTTPResult", "openSocketResult", "closeHTTPResponse", "openttpresult", "openhttpresult", "openNetworkResponse", "openHttpSource", "openHTTPRequest", "openHttpMessage", "openRouteSource", "openhttpResponse", "closeHTTPMessage", "getHTTPRequest", "closeHttpResult", "closeHttpRequest", "openUrlResult", "openttpResponse", "openHTTPSource", "openRouteResponse", "closeHttpResponse", "openHttpresult", "openUrlMessage", "getHttpResponse", "openHTTPResult", "getHttpresult", "openHTTPMessage"], "urlPath": ["urlText", "httpPath", "UrlHome", "resourceFile", "httpHome", "uriFile", "UrlText", "UrlPath", "resourcepath", "uriPath", "lPath", "runInfo", "urlCase", "urlFile", "urlHome", "urlpath", "uriName", "lpath", " urlpath", "URLText", "urlName", " urlPoint", "uripath", "httpCase", " urlCase", " urlHome", "urlInfo", "filepath", "resourcePath", " urlInfo", "Urlpath", "fileFile", "filePath", "URLpath", "runpath", "URLPoint", "UrlPoint", "runPath", "resourceName", "URLPath", "urlPoint", "UrlCase", "fileName", "httppath", " urlText", "lInfo"], "retry": ["detry", "detrying", "refrying", "pretried", "Retried", "detri", "retone", "retrying", "refried", " retone", "retrow", "Retry", "pretri", "reltry", "refri", "retri", " retried", "pretry", "relry", "relrying", " retrow", "rtri", "rerying", "pretrow", "Retri", "relone", " retri", "rtry", "reone", " retrying", "rettry", "Retrying", "rtrow", "retried", "detried", "refry", "rtried", "rery", " rettry"], "url": ["lc", "base", "client", "util", "URL", "proxy", "path", "log", "sl", "Url", "connect", "conn", "string", "li", "image", "c", "link", "org", "ssl", "user", "www", "config", "loc", "uri", "service", "resource", "http", "l", "page", "entry", "file", "server", "channel", "source", "con", "web", "f", "relation"], "connection": ["lc", "error", "client", "cache", "connected", "union", "use", "io", "proxy", "function", "creator", "index", "connect", "session", "conn", "context", "driver", "section", "image", "c", "link", "nn", "database", "character", "event", "communication", "component", "info", "user", "Connection", "b", "application", "object", "text", "number", "body", "handler", "config", "loc", "socket", "co", " Connection", "uri", "resource", "wrapper", "close", "condition", "http", "ion", "l", "cli", "channel", "server", "con", "nc", "f", "response", "relation"], "code": ["score", "complete", "cm", "test", "error", "dec", "level", "grade", "status", "cod", "change", "call", "pri", "cycle", "id", "zip", "force", "e", "sec", "Code", "check", "one", "x", "index", "state", "bug", "success", "order", "c", "xx", "fe", "cc", "zone", "reason", "type", "ie", "mode", "count", "go", "ce", "desc", "charge", "ception", "orig", "see", "co", "message", "done", "version", "close", "key", "content", "coded", "age", "rc", "line", "last", "se", "sc", "cause", "stage", "create", "coord", "nc", "ode", "expected", "size", "codes", "response"], "redirect": ["Redirect", "codedef", "refirection", "redirection", " redirection", "redanch", " redition", "transition", "transirection", "refanch", "refrict", " redef", "codedirect", "Redanch", "Redrict", "transef", "Redirection", "codedition", "redrict", "redition", "refirect", " redrict", "transirect", "redef", "codedirection", " redanch"], "result": ["error", "cache", "grade", "status", "str", "output", "answer", "comment", "dict", "load", "Result", "request", "default", "df", "string", "ret", "image", "err", "success", "results", "report", "r", "object", "diff", "buffer", "array", "message", "resource", "content", "rc", "page", "continue", "match", "source", "work", "data", "entry", "up", "instance", "value", "record", "response"]}}
{"id1": "10131427", "id2": "14598566", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferfile", " copyChannel", "CopyFile", "CopyChannel", "CopyFiles", "transferFiles", "transferChannel", " copyfile", "Copyfile", "transferFile", "copyfile", "copyChannel", " copyFiles"], "in": ["url", "base", "ins", "reader", "IN", "login", "bin", "id", "io", "inc", "ini", "index", "input", "In", "name", "inner", "image", "c", "m", "or", "at", "a", "i", "b", "ex", "again", "config", "diff", "buffer", "inn", "resource", "min", "copy", "data", "work", "file", "source", "ac"], "out": ["exec", "external", "v", "base", "OUT", "client", "outs", "cache", "w", "output", "io", "x", "target", "name", "conn", "string", "image", "c", "prefix", "off", "Out", "at", "writer", "connection", "ex", "n", "object", "o", "dest", "buffer", "p", "copy", "point", "source", "data", "file", "part", "temp"], "sourceChannel": ["srcConnection", "SourceStream", "sourceSocket", "srcStream", " sourcechannel", "targetchannel", "sourceStream", "ourceStream", "ourcechannel", "sourceManager", " sourceStream", "sourceChan", "srcSocket", "SourceQueue", "SourceSocket", "ourceChan", "Sourcechannel", " sourceQueue", " sourceSocket", "srcChan", "SourceManager", "sourceQueue", "srcManager", "targetStream", "targetChannel", "srcQueue", " sourceChan", "SourceChannel", " sourceConnection", "SourceConnection", "ourceChannel", "srcChannel", "SourceChan", " sourceManager", "sourcechannel", "targetChan", "sourceConnection"], "destinationChannel": ["destationChan", "destationchannel", "destinatedChan", "destinatorChan", "destinationsConnection", "destinationStream", "DestinatorConnection", "destationCh", "destationChannel", "destinationschannel", "destinatorchannel", "destinatedCh", "Destinationchannel", "DestinatorChan", "destinationChan", "destinatedChannel", "Destinatorchannel", "DestinationStream", "DestinationCh", "destationConnection", "destinateStream", "destinatedConnection", "destinatorChannel", "DestinatorStream", "DestinatorCh", "destinatechannel", "destinationchannel", "destinationsStream", "DestinationChan", "DestinationConnection", "destinatorStream", "destinatorCh", "destinationsChannel", "destinateConnection", "destinatorConnection", "DestinatorChannel", "DestinationChannel", "destinationConnection", "destinateChannel", "destinationCh"]}}
{"id1": "10385815", "id2": "6421904", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["exec", "send", "change", "delete", "paste", "transfer", "zip", "Copy", "put", "replace", "Transfer", "write", "upload", "Cop", "sync", "update", "get", "process", "move", "file", "download", "create", "split", "open", " Copy", "clone", "cmp"], "fileFrom": ["ioFrom", "FileStart", "fileAs", "FileTo", "FileIn", " fileStart", "FileSource", "fileSource", "fileIn", "ioTo", "ioSource", "mailFrom", "fileStart", "FileFrom", "ioStart", " fileIn", " fileSource", "mailAs", "mailTo", " fileAs", "FileAs", "mailIn"], "fileTo": ["resourceTarget", "resourceTo", "FileTO", "resourceFile", "fpFrom", " fileFile", "FileTo", "fileto", "fpto", "fileTarget", "FileFrom", " fileTO", "FileTarget", "fpTO", "resourceFrom", " fileto", " fileTarget", "FileFile", "fileTO", "fileFile", "Fileto", "fpTo"], "inputStream": [" inputFile", "outputContext", " inputSync", "inputSteam", " inputstream", "inputFile", "InputChannel", " inputSteam", "InputSync", "InputFile", " inputContext", "outputSteam", "inputContext", "inputSync", "Inputstream", "outputstream", "outputSync", "InputSteam", "inputstream", "InputContext", "InputStream", "outputFile"], "outputStream": ["inputSocket", "OutputChan", "OutputPath", " outputSteam", "writeStream", "outputChan", "inputChan", "inputSteam", "writeSteam", "outputStreamer", "OutputChannel", "OutputSteam", "writeSocket", " outputChan", "fourStreamer", "OutputStream", "outputSocket", "referenceSocket", "outputSteam", "referenceStream", "OutputStreamer", "inputPath", "writeChannel", "fourChannel", " outputPath", "referenceSteam", " outputStreamer", "fourSteam", "referenceChannel", "fourStream", "outputPath"], "inputChannel": ["outputContext", "inputSocket", "inputCam", "outputChan", "inputChan", "parentChannel", "outputPassword", "audioStream", "outputClient", "butCommand", "butContext", "parentChan", "InputChannel", " inputChan", "outputSocket", "butChan", "audioCam", " inputPassword", " inputContext", "butChannel", "inputContext", "audioChannel", "InputSocket", "InputChan", "outputCam", "parentPassword", " inputCommand", "outputCommand", "inputCommand", " inputCam", "audioClient", "inputPassword", " inputClient", "parentStream", "inputClient", "InputContext", " inputSocket", "InputStream"], "outputChannel": ["outputContext", "OutputChan", "OutputQueue", "outputChan", "inputChan", "outContext", " outputContext", "OutputChannel", "outputchannel", "outChan", " outputChan", "outStream", "OutputStream", "inputchannel", "inputContext", " outputQueue", " outputchannel", "inputQueue", "outputQueue", "OutputContext", "Outputchannel", "outChannel"]}}
{"id1": "19584877", "id2": "5414088", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeFileToFiles", "encodeStringToFiles", "encodeFile2Stream", "encodeFiletoStream", "encodeFileFromFile", "encodeFileFromStream", "encodeFiletoFile", "encodeString2File", "encodeFiletoFiles", "encodeString2Files", "encodeFile2File", "encodeString2String", "encodeString2Stream", "encodeFileFromString", "encodeFileToString", "encodeFile2String", "encodeStringToString", "encodeFileToStream", "encodeFiletoString", "encodeStringToStream", "encodeFile2Files", "encodeStringToFile"], "infile": ["Infile", "infiles", "inputFile", "InFile", "inFile", "Infiles", "outFile", "inputfiles", "infilename", "outfilename", " infilename", "outfiles", "inputfp", "infp", " infiles", "inputfilename", " infp", "outfp", "Infilename", "inputfile"], "outfile": ["outputfilename", "newname", "Outname", "newFile", "outname", "infolder", "newfolder", " outname", "Outfolder", "outFile", "outfolder", " outfolder", "infilename", "outfilename", "outputfp", " outFile", "outputfile", " outfilename", " outfp", "newfile", "infp", "OutFile", "outputfolder", "Outfile", "outfp"], "in": ["gin", "base", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "vin", "ini", "input", "ic", "In", "s", "conn", "inner", "image", "err", "inas", "m", "a", "i", "r", "b", "again", "sin", "socket", "nin", "win", "inn", "min", "pin", "is", "into", "cin", "data", "source", "init", "inside", "rin", "pass", "ac", "con", "as"], "out": ["net", "exec", "base", "error", "OUT", "client", "outs", "cache", "job", "output", "bin", "ou", "io", "inc", "one", "session", "conn", "obj", "In", "inner", "on", "name", "to", "image", "err", "write", "off", "no", "Out", "lib", "or", "writer", "ex", "parent", "again", "o", "co", "socket", "sync", "post", "outer", "timeout", "point", "copy", "line", "source", "work", "file", "up", "home", "exit"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bb", "transfer", "feed", "raw", "fb", "input", "border", "length", "seed", "binary", "offset", "queue", "write", "len", "layer", "type", "reference", "batch", "count", "b", "null", "buf", "slice", "padding", "iter", "bytes", "wave", "flush", "data", "source", "server", "limit", "value", "split", "size", "buff"], "read": ["exec", " skip", " Read", "ip", "reader", "send", " copy", "parse", "lex", "allow", "use", "id", "feed", "io", "load", "inc", "raw", "current", "_", "check", "x", " count", "input", "connect", "start", "length", "ind", "play", "seek", "end", "write", "next", "len", "i", "count", "ride", "wait", "fill", "n", "find", "Read", "slice", "sync", "READ", "tell", " write", "ad", "iter", "close", "add", "get", "copy", "work", "sleep", "se", "limit", "reads", "pass", "reading", "size", "select", "f", "run"], "success": ["complete", "first", "result", "error", "cess", " succ", "fast", "status", "ccess", "growth", "follow", "flash", "primary", "right", "Success", "valid", "model", "func", "path", "default", " succeed", " Success", "true", "winner", "rolled", "results", "xx", "failed", "danger", " successful", "construct", "method", "null", "again", "ceed", "good", "message", "done", "rolling", "successfully", "respons", "content", "continue", "data", "warning", "successful", "pass", "roll", "initial", "better", "fail", "value", "open", "modified", "comment", "response"]}}
{"id1": "22855019", "id2": "8801182", "code1": "    public static MessageService getMessageService(String fileId) {\n        MessageService ms = null;\n        if (serviceCache == null) init();\n        if (serviceCache.containsKey(fileId)) return serviceCache.get(fileId);\n        Properties p = new Properties();\n        try {\n            URL url = I18nPlugin.getFileURL(fileId);\n            p.load(url.openStream());\n            ms = new MessageService(p);\n        } catch (Exception e) {\n            ms = new MessageService();\n        }\n        serviceCache.put(fileId, ms);\n        return ms;\n    }\n", "code2": "    private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception {\n        Properties list = new Properties();\n        list.load(new FileInputStream(fileWithListOfImages));\n        long current = 0;\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir);\n        System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\");\n        System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\");\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\");\n        }\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            URL url = new URL(uriPrefix + urlString);\n            File file = new File(outputDir + \"/\" + imageNameToFileName(urlString));\n            current++;\n            if (!file.exists()) {\n                try {\n                    BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000);\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000);\n                    int c;\n                    while ((c = in.read()) != -1) {\n                        out.write(c);\n                    }\n                    out.close();\n                    in.close();\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                    System.out.println(\"saved\");\n                } catch (Exception e) {\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage());\n                }\n            } else {\n                System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                System.out.println(\"already exists\");\n            }\n            if (current / 100 == current / 100.0) {\n                long delta = (System.currentTimeMillis() - startTime);\n                System.out.println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\");\n            }\n        }\n        long delta = (System.currentTimeMillis() - startTime);\n        System.out.println(\"Total time \" + delta + \" ms, \" + (delta / list.size()) + \" ms/file\");\n    }\n", "label": 0, "substitutes": {"getMessageService": ["getMessageServ", "getMediaFactory", "newMessageService", "getmessageFactory", "getmessageServ", "getmessageService", "newmessageService", "getMediaService", "getMediaServ", "newMessageServices", "newMessageFactory", "getMessageFactory", "newmessageFactory", "getmessageServices", "newmessageServices", "newMessageServ", "getMessageServices", "getMediaServices", "getMailServ", "newmessageServ", "getMailService", "getMailFactory", "getMailServices"], "fileId": [" fileContext", " filePart", " fileid", "fileContext", "urlInit", "moduleId", "connectionString", "logid", "ileId", "FILEEnd", "messageDef", "FILEId", "fileInit", "FILEData", "logPart", "ileData", "moduleid", "urlType", "FILEInit", "fileData", "fileid", " fileInit", "FILEContext", "ilePart", "ileEnd", "urlId", "logId", "FileId", " fileID", " fileData", "fileID", "messageid", "moduleDef", "FILEType", "FileString", "urlKey", "messageId", "filePart", " fileString", "fileType", "fileKey", "fileDef", "connectionid", "fileString", "fileEnd", " fileType", "FILEPart", " fileDef", "connectionID", "FileID", "logContext", "FILEKey", " fileEnd", "Fileid", "connectionId", "FILEid", " fileKey"], "ms": ["mos", "us", "md", "cm", "services", "mc", "MS", "xs", "e", "PS", "pm", "ts", "ils", "vs", "ws", "bm", "mo", "ims", "es", "ns", "ks", "cms", "s", "ls", "mi", "hs", "bs", "m", "ys", "models", "g", "js", "cs", "ps", "mes", "mm", "ics", "ds", "ma", "service", "fs", "Ms", "ips", "is", "me", "ams", "ports", "ems", "qs", "sp", "ss", "manager", "rs", "gs"], "p": ["fp", "jp", "ip", "pro", "cache", "tp", "ap", "bp", "e", "pm", "lp", "pre", "P", "plugin", "py", "vp", "pr", "u", "cp", "c", "np", "m", "properties", "j", "t", "i", "info", "pe", "r", "ps", "per", "parser", "api", "wp", "l", "data", "op", "pb", "pc", "pp", "sp", "f", "pi", "po"], "url": ["base", "e", "id", "feed", "zip", "URL", "path", "plugin", "sl", "fl", "Url", "string", "u", "stream", "image", "c", "org", "m", "ssl", "i", "connection", "user", "b", "browser", "config", "ur", "uri", "service", "api", "resource", "bel", "key", "http", "l", "page", "data", "file", "server", "channel", "source", "entry", "open", "web", "f"]}}
{"id1": "8046691", "id2": "23677142", "code1": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "code2": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "label": 0, "substitutes": {"retrieveFile": ["retrievingfile", "retrivefile", "retriveUrl", "retrievingFiles", "retriveFiles", "RetrieveFile", "Retrievingfile", "retireUrl", "RetrievingFile", "RetrievingUrl", "retrieveFiles", "retireFile", "retrieveUrl", "retireFiles", "retrievingFile", "RetrieveFiles", "retrievefile", "retirefile", "retrievingUrl", "retriveFile", "RetrieveUrl", "RetrievingFiles", "Retrievefile"], "url": ["address", "base", "feed", "io", "proxy", "URL", "path", "log", "sl", "Url", "host", "location", "string", "gl", "contact", "stream", "image", "org", "ssl", "connection", "html", "user", "object", "ll", "www", "config", "loc", "socket", "loader", "ur", "buffer", "uri", "service", "resource", "http", "l", "page", "source", "file", "server", "channel", "download", "email", "src"], "link": ["address", "error", "cache", "local", "linked", "LI", "model", "path", "log", "location", "name", "li", "tail", "route", "pull", "post", "message", "data", "file", "feed", "check", "remote", "machine", "bug", "lock", "or", "user", "object", "block", "loader", "http", "l", "match", "open", "comment", "lc", "base", "call", "parse", "skip", "auto", "code", "layer", "info", "config", "loc", "slice", "list", "uri", "links", "source", "low", "inline", "download", "light", "load", "plugin", "image", "set", "self", "build", "type", "connection", "task", "sync", "Link", "pack", "service", "add", "line", "entry", "style", "ref", "ink"], "httpConn": ["urlConnect", "webConnection", "pubConn", "phpCur", " httpConnect", "httpsConnection", "transConnection", "phpConn", "buildConnection", "urlConn", "baseConf", "baseConnection", "webLoc", "buildConn", "urlConnection", "buildCmd", " httpConnection", "baseCan", "phpConnect", "httpConf", "pubConnection", "webconn", "phpConnection", "userConn", "baseConn", "httpCmd", "serverMC", "userConnect", " httpLoc", "httpConfig", "HttpConnect", "httpsCon", "HttpLoc", "serverConnection", "httpCon", "perconn", "httpCan", " httpMC", " httpCan", "perConnect", "webConn", "transConnect", "HttpCur", "transConn", "workconn", "userConnection", "transCon", "httpsConnect", "httpsConn", "serverConnect", " httpCur", " httpCon", "userConf", "httpConnect", "HttpConnection", "perConn", "workConn", " httpconn", "httpMC", "pubCmd", "httpLoc", "perCon", "webConfig", " httpCmd", "urlCon", "perConf", "HttpConfig", " httpConfig", "phpCon", "serverConn", "pubCon", " httpConf", "httpsConf", "workCon", "HttpMC", "httpsCan", "serverconn", "httpConnection", "httpconn", "workConnection", "HttpConn", "perConnection", "httpCur", "webConnect", "buildCon", "buildconn"], "outs": ["rules", "services", "ins", "OUT", "groups", "cache", "output", "sets", "steps", "io", "aos", "reports", "flows", "works", "ws", "overs", "locks", "ns", "abs", "out", "conn", "ls", "lines", "results", "states", "ios", "Out", "files", "strings", "errors", "again", "ops", " out", "runs", "ups", "socket", "plugins", "bits", "boxes", "pins", "fits", "events", "css", "blocks", "timeout", "opens", "bytes", "INS", "its", "gets", "in", "lets", "data", "ports", "cos", "qs", "utils", "limits", "bs"], "bins": ["bannels", "wbains", "bin", " bin", "wbas", "sbains", " bas", "sbkins", "bains", "bints", "wbouts", "Bkins", " bints", "Bints", " bkins", "bas", "sbouts", "pannels", "Bin", "Bouts", "sbins", "pins", "Bains", "bkins", "pin", "cbouts", " bains", " bannels", "cbins", "Bins", "cbas", "pints", "wbins", "cbains", "Bannels"], "bouts": ["Buss", "bboxes", "Bboxes", " borders", " buss", "Bout", "dbout", "bborders", "borders", "wbouts", "bbins", "wbgets", "wbout", "dbboxes", "Borders", "bout", "Bouts", "bbouts", " bboxes", "dbouts", "bgets", "dbuss", "Bins", "wbins", " bgets", "bbgets", "bbout", " bout", "buss"], "postData": ["readData", "ostData", "postBytes", "objectDATA", "postString", "postUrl", " postDATA", "formData", "POSTData", "ostBody", "PostUrl", "objectBytes", "POSTBody", "readUrl", "postDATA", "POSTdata", " postBytes", "objectData", "Postdata", "POSTString", "formdata", "readdata", " postBody", "formDATA", "postdata", "objectBody", "POSTBytes", "ostdata", "PostString", "PostData", "ostDATA", "POSTDATA", "formBody", "POSTUrl", "readString", "postBody"], "mimePattern": ["Mimespattern", "MimesFilter", "MimesPattern", "mimesFilter", "mengepattern", "mengeString", "mimesPattern", "milePattern", "mimesString", "mIMEString", "MIMEpattern", "MimeFilter", "MimeString", "mimespattern", "mimesModel", "Mimepattern", "MIMEPattern", "mengeFilter", "MimeModel", "mileModel", "MimesString", "mIMEFilter", "mIMEModel", "MimePattern", "mengePattern", "milepattern", "mimepattern", "MIMEModel", "mimeString", "mimeFilter", "mIMEPattern", "mIMEpattern", "mimeModel"], "matcher": [" mather", "earmatch", "Matchers", "earchers", "matches", "patches", "patchers", "matmatch", "Matcher", "patmatch", " matches", "patche", "Matches", " matche", "Matmatch", " matchers", "Mather", "matche", "pather", "earches", "earcher", "mather", "patcher", "Matche", "matchers"], "byteBuffer": ["bitBuffer", "bitBuff", "byteLength", "byteQueue", "doubleQueue", "ByteBuff", " byteBuff", " byteHandler", "dataBuff", "doubleArray", "ByteLayer", " byteLayer", "ByteQueue", "ByteBuffer", "bitHandler", "byteBuff", "dataLength", " byteQueue", "bitArray", "dataLayer", " byteArray", "doubleBuffer", "dataBuffer", "ByteHandler", "ByteLength", "ByteArray", "doubleBuff", "byteHandler", "byteArray", "byteLayer", " byteLength"], "count": ["base", "level", "cache", "call", "allow", "now", "e", "found", "id", "current", "child", "old", "path", "Count", "index", "val", "label", "start", "length", "string", "ind", "keep", "max", "core", "more", "name", "offset", "c", "len", "code", "build", "all", "type", "i", "b", "number", "n", "parent", "list", "weight", "cond", "depth", "min", "key", "col", "match", "file", "pool", "low", "ch", "num", "coll", "limit", "group", "part", "sum", "size", "f"]}}
{"id1": "7872659", "id2": "11968328", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieIndexPath", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndmovieindexfile", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndmovieIndexfile"], "completePath": ["completeHome", " completeRoot", " completeCorp", "execpath", "doneLoader", "successPath", " CompleteDir", "completeCh", " completepath", "CompletePath", "doneVol", "CompleteDir", "completeVol", " completePoint", "itePath", "flatPath", " completeDir", "donePath", "completeCorp", "iteMusic", "successCh", "execLoader", "completeFile", "iteCh", "correctPoint", " CompletePath", "completeMusic", "completeRoot", "donepath", "successMusic", "completepath", "completeLoader", "itepath", "completePoint", "progressLoader", "progresspath", "CompleteHome", " completeCh", "progressPath", " completeHome", "flatRoot", "execPath", "flatCorp", "progressVol", "completeDir", "correctPath", "flatPoint", " CompleteHome", "execVol", "correctCorp", " completeMusic", " completeFile", " CompleteFile", "correctRoot", "CompleteFile", "successpath"], "masterFile": ["masterFiles", " masterName", "MasterFilename", "MasterName", "cacheFiles", "masterName", "MasterPath", "cachePath", "masterPath", "MasterFiles", "configFilename", "mastersFile", " masterPath", "cacheFile", "masterFilename", "MasterFILE", "mastersPath", " masterFilename", "MasterFile", "configPath", "configFile", "mastersFILE", "cacheFILE", "masterFILE", "mastersFiles", "configName"], "CustRatingFileName": ["CustRatingClassPath", "CustIndexFilesVersion", "CustIndexFileName", "CustRatingFilesName", "CustRatingFilenameSize", "CustRatingFilenameName", "CustRateFileName", "CustRateFilenameDesc", "CustRatingFilesDesc", "CustRatingFileVersion", "CustRatingFileSize", "CustIndexFilesType", "CustRateFileSize", "CustIndexFilesName", "CustRatingFilenamePath", "CustRatingFullDesc", "CustRateFilenameName", "CustIndexFilesPath", "CustRateFileDesc", "CustRatingFullPath", "CustRatingLineVersion", "CustRatingClassVersion", "CustRatingFileDesc", "CustRatingLineName", "CustRatingClassName", "CustRatingFilePath", "CustRatingFilesSize", "CustRateFilePath", "CustRatingFullName", "CustRatingLineType", "CustRateFilenamePath", "CustRatingFileType", "CustRatingLinePath", "CustRatingFullSize", "CustIndexFileVersion", "CustRatingClassType", "CustIndexFileType", "CustRatingFilesPath", "CustIndexFilePath", "CustRatingFilenameDesc", "CustRatingFilesType", "CustRateFilenameSize", "CustRatingFilesVersion"], "MovieIndexFileName": ["MovieIndexPlaceFile", "MovieConfigFolderFile", "MovieIndexFileHandle", "MovieIndexClassSize", "MovieIndexFName", "MovieEditFilename", "MovieConfigFolderName", "MovieConfigFileHandle", "MovieConfigFileVersion", "MovieIndexFolderName", "MovieIndexFileVersion", "MovieIndexPlaceName", "MovieIndexClassName", "MovieIndexFSize", "MovieIndexFilesUrl", "MovieEditFname", "MovieIndexClassname", "MovieConfigFolderVersion", "MovieEditFSize", "MovieConfigFileName", "MovieEditFUrl", "MovieIndexClassUrl", "MovieConfigFileFile", "MovieIndexFILEVersion", "MovieIndexFilesname", "MovieIndexFileSize", "MovieIndexFolderHandle", "MovieIndexFilesSize", "MovieConfigFolderHandle", "MovieIndexFILEFile", "MovieIndexFname", "MovieEditFileName", "MovieIndexFolderVersion", "MovieEditFileSize", "MovieIndexFUrl", "MovieIndexFolderFile", "MovieIndexPlaceHandle", "MovieEditFName", "MovieIndexFileFile", "MovieIndexFileUrl", "MovieIndexFILEName", "MovieIndexFILEHandle", "MovieEditFileUrl", "MovieIndexPlaceVersion", "MovieIndexFilename", "MovieIndexFilesName"], "inFile": ["Infile", "inputF", "inputFile", "InFile", "InF", "incFile", "inF", "incC", "InSourceFile", "inputSourceFile", "incSourceFile", "outFile", "infile", "outC", "incfile", " inF", " infile", "outfile", " inSourceFile", "outSourceFile", "inSourceFile", "inputfile"], "inC": ["inB", "InB", "inputF", " inCL", "innerCI", "outCC", "inputFile", "InFile", "InF", "outB", "inF", " inCC", "inCL", "outFile", "outC", "inputC", "innerFile", "inputCC", " inF", "InCI", " inB", "InCC", "innerCC", "outF", "outCL", "InCL", "outCI", "inCC", "innerC", "inCI", "InC"], "outFile1": ["outputFileName", "outFName", "againCFirst", "againC3", "outputFileId", "outPlaceId", "outCFirst", "outF1", "outFileName", "outFile3", "againFile1", "outPathFirst", "outPath1", "outFiles1", "outPath2", "outFilesFirst", "outfile1", "outfileId", "outF2", "outPath3", "outFileFirst", "outPlace1", "outFiles3", "outputFile1", "againFile3", "outC3", "againC1", "outFiles2", "againFile2", "outfileName", "outPlaceName", "outFileId", "outputFile2", "outputfileName", "outputfileId", "outputfile2", "outPlace2", "outFId", "outfile2", "againC2", "againFileFirst", "outputfile1"], "outC1": ["newc1", "outC81", "outD1", "outCFirst", "outD8", "outF1", "outcFirst", "outFOne", "newC81", "outCFFirst", "outD81", "newc81", "newCFirst", "outF2", "outD2", "againB8", "againC8", "outCF81", "outCFOne", "newCOne", "outDOne", "outc1", "outB1", "againB1", "outBOne", "againCOne", "outcOne", "outB8", "newcOne", "newcFirst", "outB2", "againBOne", "outF8", "outc81", "outC8", "newC1", "againC2", "againB2", "outCOne", "outCF1", "outDFirst", "againC1"], "outFile2": ["outFile4", "outputfile5", "outFiles6", "outDirectory4", "outFile5", "againFile6", "againFile1", "outFilesTwo", "againLine1", "outDirectory2", "outFiles1", "outDirectory5", "againFileTwo", "outLineTwo", "outputFile4", "outFileTwo", "outputFile5", "outChannel2", "outChannel1", "outLine2", "outDirectoryTwo", "outChannel6", "againLine2", "outfile4", "outFiles2", "outputFileTwo", "againFile2", "outFiles5", "outLine6", "outputFile2", "outfile5", "outChannelTwo", "againLine6", "outputfile2", "outfileTwo", "outLine1", "outfile2", "outputfileTwo", "againLineTwo", "outFile6", "outFiles4", "outputfile4"], "outC2": ["outFile4", "outFTwo", "outCache1", "outCII", "outF1", "outCache2", "outFII", "outB4", "OutF1", "againC4", "outCache4", "outF2", "OutF2", "OutC1", "outFileTwo", "outCacheII", "outCTwo", "OutCII", "OutC2", "OutC4", "OutFII", "outB1", "againB1", "againCTwo", "againBTwo", "outBTwo", "outF4", "outB2", "outC4", "outFileII", "againC2", "againB2", "againB4", "OutF4", "againC1"], "fileSize": ["bufferMode", " fileMode", " fileAddress", " fileSIZE", "imageLength", "imageSize", " fileLength", "fileAddress", "bufferSize", "fileMode", "bufferLength", "FileLength", "resourceSize", "resourceSIZE", "FileSize", "FileSIZE", "FileAddress", "fileLength", "FileMode", "imageSIZE", "resourceAddress", "fileSIZE"], "totalNoDataRows": ["totalNoPageRues", "totalNoDataChOWS", "totalNoDataRrows", "totalNoPageRrows", "totalNoDataCues", "totalNoPageLOWS", "totalNoDataRues", "totalNoDataLues", "totalNoPageLrows", "totalNoDataCows", "totalNoPageLows", "totalNoDataChows", "totalNoDataLows", "totalNoDataCrows", "totalNoDataChues", "totalNoDataCOWS", "totalNoPageRows", "totalNoDataLrows", "totalNoPageROWS", "totalNoDataROWS", "totalNoDataLOWS", "totalNoDataChrows", "totalNoPageLues"], "mappedBuffer": ["mappedBuff", "mappingBuffer", "mappingFile", "mappingBuff", "mashedBuffer", "Mappedbuffer", "mippedBuff", "mappedbuffer", "MachedURL", "MappedBuff", "machedBuffer", "mappingStream", "MappingChannel", "mapedFile", "MappedStream", "mppedStream", "MachedChannel", "mappingbuffer", "mactedStream", "MappingFile", "mappedURL", "MachedBuff", "mippedURL", "mappedChannel", "MappingBuff", "Machedbuffer", "mippedStream", "mappedFile", "mapedStream", "mapedURL", "MappedBuffer", "machedURL", "MappingBuffer", "MachedBuffer", "machedFile", "MachedFile", "mashedFile", "mashedChannel", "machedStream", "mappedStream", "machedbuffer", "mapedBuff", "MappedFile", "mppedChannel", "mashedBuff", "machedChannel", "mactedBuff", "machedBuff", "mactedbuffer", "mippedBuffer", "mapedBuffer", "mactedBuffer", "MappedURL", "mappingChannel", "MachedStream", "mppedBuff", "mppedBuffer", "MappedChannel"], "startIndex": ["endPoint", "startindex", "startSection", "endInfo", "stopCode", "stopindex", "stopIndex", "StartInfo", "initindex", "useindex", "startRow", " startindex", "endRow", "endCode", "startInfo", "endSection", " startOffset", "startingPosition", "startingIndex", " startCode", "startingPoint", "endIndex", "initIndex", "StartOffset", " startPosition", "startCode", " startInfo", "startPoint", "startPosition", "StartPosition", "initOffset", "endindex", "useIndex", " startPoint", "stopRow", "usePosition", " startRow", "Startindex", " startSection", "startOffset", "StartIndex", "useInfo", "startingSection", "initInfo", "endPosition"], "count": ["first", "test", "cache", "follow", "call", "allow", "found", "id", "force", "current", "child", "old", "total", "Count", "index", "start", "length", "keep", "ind", "time", "more", "thread", "name", "max", "c", "order", "len", "self", "code", "all", "type", "i", "counter", "number", "find", "weight", "list", "depth", "close", "add", "key", "other", "col", "pool", "loop", "coll", "limit", "group", "part", "sum", "size"], "currentMovie": [" currentmovie", "currentFilm", "thismovie", "CurrentTheme", "currentmovie", "defaultMusic", "currentlyPicture", "CurrentMovie", "currentPicture", "parentMovie", "validMovie", "reportedMovie", "reportedFilm", "thisPicture", "thisMovie", "defaultFilm", "validTheme", "reportedImage", "reportedmovie", "defaultMovie", "validFilm", "CurrentFilm", "defaultImage", " currentMusic", "validmovie", "parentmovie", "currentTheme", "Currentmovie", " currentFilm", "thisFilm", "currentMusic", " currentPicture", " currentImage", "currentImage", "currentlyMovie", "reportedMusic", "parentPicture", "reportedPicture", "currentlyMusic", "parentFilm", "reportedTheme"], "movieName": ["Moviename", "filmName", "MovieName", " moviename", "camName", "filmNumber", " movieId", "voiceName", "movieInfo", "moneyName", "moneyFamily", "voicename", "moneyNumber", "voiceId", " movieFamily", "MovieFamily", "moviename", "MovieInfo", "filmname", "MovieId", "voiceInfo", "movieId", "movieNumber", "camFamily", "movieFamily", " movieInfo", "camname", "filmFamily", "MovieNumber"], "customer": ["Customer", "customor", "ustomeri", "mixer", "ustomers", "customER", "CustomER", "Customers", " customER", "mixER", "customers", " customers", " customeri", "ustomer", "mixor", "ustomER", "ustomor", "Customeri", "Customor", "customeri", "mixers"], "rating": ["score", "ring", "url", "feature", "error", "reader", "id", "rr", "string", "ranking", "range", "missing", "ruby", "rate", "type", "writer", "info", "r", "number", "rage", "rated", "Rating", "packing", "setting", "ing", "padding", "alpha", "attribute", "resource", "rolling", "rank", "http", "rc", "data", "RC", "value", "rates", "rice", "including", "reading", "comment", "radius", "writing"], "outBuf1": ["outFufCloud", "outKuf8", "outBafCloud", "outFuf1", "outBummerOne", "outFbuf01", "outBbuff8", "outBbufn", "outBbuf11", "outBaf1", "outBuf3", "outFuf91", "outBaft3", "outBbuff0", "outBuf91", "outBuff8", "outFufOne", "outBuf8", "outCuf0", "outBaf3", "outBuffCloud", "outBalth3", "outBbuf91", "outFbuf1", "outBiff91", "outBaftn", "outKufOne", "outBuf01", "outFafCloud", "outBbuf3", "outBuff3", "outBum91", "outBufOne", "outKbuffOne", "outDuff1", "outKbuff3", "outBufn", "outDuff3", "outKbuff1", "outKuf1", "outBuff1", "outDuf1", "outBaf8", "outFuf01", "outBaf0", "outBbufOne", "outBalth1", "outBaft11", "outCuf1", "outCufOne", "outFafOne", "outKbuf3", "outFbuf91", "outBbuf1", "outBuffOne", "outFbufOne", "outKuf3", "outBbuffOne", "outCuffOne", "outFaf1", "outDuff11", "outKbuff8", "outBbuf2", "outBumOne", "outBuff11", "outBuff2", "outBbuff3", "outBummerCloud", "outBuf0", "outBafOne", "outBbuff1", "outDuf11", "outBiff1", "outBbuf01", "outBiff01", "outBaft1", "outDuf3", "outDuffn", "outBiffOne", "outBuff0", "outKbuf1", "outKuf2", "outBum01", "outCuff1", "outCuff0", "outBummer1", "outDufn", "outBalth2", "outKbuf2", "outBufCloud", "outBuffn", "outBuf11", "outBum1"], "outBuf2": ["outBuf4", "outFbuf2", "outBbuffTwo", "outBuber8", "outFbufB", "outFuf1", "outBoffTwo", "outFuf20", "outBum20", "outBbuff8", "outBuber20", "outBait200", "outBbuff20", "outBbuffer4", "outBbuff0", "outBuff8", "outBuf20", "outFuf8", "outBuf8", "outBbufB", "outBufTwo", "outBum82", "outBuff4", "outWBuf200", "outFbuff20", "outBuffTwo", "outBufB", "outBbufTwo", "outWBuf8", "outFbuff4", "outWBuf2", "outWBbuff200", "outBuff12", "outBbuffer2", "outWBuff4", "outFbuff2", "outBbuff200", "outBuffB", "outBbuff4", "outBum8", "outBait2", "outBait4", "outBbuff82", "outBuber2", "outBuff1", "outFufTwo", "outBuf12", "outFbuf12", "outWBbuffTwo", "outFuf4", "outWBuff0", "outBbuf1", "outBoff8", "outFbuff1", "outBbuf4", "outWBuff8", "outBuber82", "outBait0", "outBbuf2", "outFbuf4", "outBuff2", "outBuf0", "outWBbuff8", "outBbuff1", "outBuf200", "outWBufTwo", "outBaitTwo", "outFbuff8", "outBoff200", "outFuf12", "outFuf82", "outBbuffer12", "outBuff0", "outBum2", "outBbuff2", "outFbuff82", "outBoff2", "outBbuf12", "outWBuf4", "outBuf82", "outFbuffTwo", "outBbufferB", "outFuf2", "outWBuf0", "outFufB", "outWBbuff2", "outBait8", "outWBuff2"], "endOfIndexFile": ["endOfImageFolder", "endOfDataFile", "endofindexTime", "endOfIndexFolder", "endofIndexFile", "endOfindexFile", "endOfImageFiles", "endOfDataDir", "endOfindexFiles", "endofIndexDir", "endofindexFolder", "endofLinkFiles", "endofindexFile", "endOfIndexfile", "end\n", "endOfindexTime", "ended\n", "endfile", "endOfIndexFiles", "endofindexFiles", "endedfile", "endOfIndexTime", "endOfLinkFile", "endOfIndexDir", "endOfLinkfile", " end\n", "endOfClientDir", " endfile", "endOfindexFolder", "endOfDataTime", "endOfClientFiles", "endOfClientTime", "endOfClientFile", "endofIndexFolder", "endOfindexfile", "endOfindexDir", "endOfLinkFiles", "endOfLinkDir", "Endfile", "End\n", "endOfImageTime", "endofLinkDir", "endofLinkTime", "endOfDatafile", "endOfImageFile", "endofLinkFile", "endOfLinkTime", "endofIndexFiles", "endofIndexTime"]}}
{"id1": "742465", "id2": "10212189", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doVersionUpdate", " doVersionUpdate", " doversionCheck", "doversionScan", "doversionCheck", "doChangeCheck", "doChangecheck", " doversioncheck", "doChangeUpdate", "doversioncheck", "doVersioncheck", "doFeaturecheck", " doVersionScan", " doversionUpdate", "doversionUpdate", "doFeatureScan", "doVersionScan", "doFeatureCheck", " doversionScan", "doChangeScan", "doFeatureUpdate", " doVersioncheck"], "view": ["v", "cache", "vol", "window", "e", "port", "model", "div", "row", "session", "link", "sel", "box", "show", "query", "display", "form", "server", "fail", "value", "full", "group", "gu", "client", "use", "VIEW", "check", "input", "View", "lock", "event", "user", "object", "video", "block", "views", "vis", "by", "http", "page", "review", "pool", "comment", "can", "cell", "im", "base", "change", "el", "ou", "container", "screen", "body", "head", "config", "list", "index", "out", "ui", "image", "this", "widget", "self", "html", "see", "edit", "layout", "update", "ve", "up", "style", "manager"], "url": ["address", "base", "builder", "rel", "bb", "ob", "id", "zip", "URL", "path", "log", "sl", "Url", "host", "location", "string", "name", "ls", "gl", "stream", "bug", "length", "image", "hub", "link", "ssl", "b", "browser", "null", "ll", "www", "loc", "socket", "loader", "fr", "buffer", "uri", "ul", "resource", "http", "l", "source", "file", "server", "download", "email", "impl", "open", "web", "blog", "f"], "in": ["ins", "reader", "din", "IN", "login", "isin", "inc", "bis", "ini", "input", "out", "In", "binary", "s", "inner", "stream", "err", "doc", "m", "b", "again", "sin", "socket", "nin", "win", "buffer", "resource", "inn", "pin", "is", "cin", "lin", "data", "file", "source", "init", "rin", "con", "ac", "as"], "bin": ["bn", "gin", "reader", "din", "IN", "login", "bb", "nb", "vin", "spin", "ini", "input", "border", "out", "binary", "fin", "inner", "lock", "bot", "ruby", "lib", "oin", "ban", "b", "browser", "body", "sin", "socket", "loader", "win", "buffer", "inn", "pin", "abi", "arin", "cin", "lin", "is", "file", "init", "con", "record", "bi", "run"], "line": ["lc", "cl", "base", "ip", "job", "str", "parse", "el", "e", "id", "zip", "one", "log", "le", "val", "ge", "row", "nl", "sl", "string", "name", "end", "Line", "out", "lines", "range", "word", "write", "link", "code", "LINE", "look", "type", "pe", "definition", "b", "user", "text", "object", "block", "pin", "key", "jo", "lf", "lin", "data", "file", "page", "l", "entry", "inline", "up", "letter", "unit", "ine", "part", "comment", "cell"], "version": ["feature", "position", "v", "ver", "project", "beta", "id", "cover", "model", "plugin", "python", "patch", "host", "string", "name", "bug", "driver", "section", "image", "code", "format", "vision", "type", "release", "user", "Version", "null", "video", "latest", "pull", "install", "update", "support", "license", "date", "option", "vert", "versions", "server", "download", "VERSION", "secret", "device", "value", "dev", "unit", "author"], "build": ["uild", "ver", "job", "builder", "rel", "follow", "clean", "use", "feed", "load", "valid", "log", "boot", "make", "row", "patch", "hold", "Build", "bug", "lock", "image", "link", "lease", "info", "print", "release", "show", "tag", "built", "pull", "block", "install", "building", "update", "post", "mount", "how", "add", "get", "http", "work", "style", "help", "home", "unit", "run"]}}
{"id1": "3958807", "id2": "13886238", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadBInputContent", "loadFinaryFile", "loadFbinaryStream", "loadBinaryInput", "loadBatchInput", "loadFinaryInput", "loadBatchFile", "loadBInputStream", "loadBbinaryContent", "loadBinaryContent", "loadBInputFile", "loadFbinaryFile", "loadFinaryStream", "loadBbinaryFile", "loadBinaryFile", "loadFinaryContent", "loadFbinaryContent", "loadBatchStream", "loadFbinaryInput", "loadBatchContent", "loadBbinaryInput", "loadBInputInput", "loadBbinaryStream"], "streamName": ["StreamPath", " streamType", "streamType", "streamname", "filename", "channelKey", "StreamName", "channelPath", "resourceType", " streamKey", "Streamname", "channelName", "fileType", "fileKey", "resourcename", "resourcePath", "streamKey", "streamPath", " streamPath", "filePath", "resourceName", " streamname", "fileName"], "streamToLoad": ["objectTOUpload", "channelToload", "streamtoLoad", "streamToAdd", "objectTOLoad", "objectTOUse", "objectTORead", "objectToUpload", "streamWillAdd", "objectToRead", "streamWithRead", "streamTORead", "streamToUse", "streamToUpload", "streamTOAdd", " streamtoUse", "channeltoLoad", " streamtoLoad", "streamTOLoad", "streamWithAdd", "objectToLoad", "streamWillLoad", " streamtoRead", "streamtoAdd", "objectToUse", "streamtoRead", "channelToAdd", "streamTOUse", "streamWithLoad", "channeltoAdd", "streamtoUse", " streamToAdd", " streamtoAdd", "streamToload", "streamWillUpload", "streamTOload", "streamTOUpload", "streamToRead", "streamtoUpload", "streamWillRead", "streamtoload", "streamWillUse", "channeltoload", "streamWithUse", "channelToLoad", " streamToUse", " streamToRead"], "sz": ["szes", "ssz", "szip", "imsze", "sze", " szip", "ssze", " szi", "psze", " sze", "wszi", "ssiz", " szes", "wsz", " siz", "imsz", "wszip", "szi", "imszes", "siz", "wsze", "pszi", "pszip", "imsiz", "psz", "sszes"], "req": ["exec", "client", "Resp", "rh", "sem", "inv", "cb", "requ", "progress", "proc", "rr", "request", "input", "res", "q", "conn", "wx", "obj", "err", "rw", "pkg", "respond", "require", "report", "r", "def", "rx", "rec", "ok", "fr", "Request", "http", "download", "qt", "src", "ref", "rss", "serv", "ctx", "f", "response"], "resp": ["exec", "jp", "fp", "client", "Resp", "rel", "re", "bb", "rh", "output", "e", "zip", "circ", "Response", "proc", "cook", "request", "df", "comm", "remote", "res", "conn", "obj", "wx", "ret", "rup", "rep", "err", "respond", "prev", "report", "html", "par", "body", "rec", "wb", "rem", "api", "http", "wp", "page", "server", "download", "ref", "rss", "reply", "esp", "serv", "sp", "ctx", "response", "cmp", "rev"], "out": ["exec", "base", "img", "OUT", "outs", "cache", "output", "bin", "tmp", "zip", "aos", "io", "ws", "log", "default", "boot", "res", "conn", "s", "auto", "binary", "Out", "os", "i", "b", "null", "buf", "ops", "object", "o", "again", "co", "buffer", "p", "copy", "in", "data", "op", "fn", "pool", "gz", "serv", "response"], "bos": ["bott", "bc", "las", "osi", "osa", "bare", "bb", "ob", "bin", "lo", "aos", "bis", "boot", "zos", "bro", "bot", "ios", "obos", "bas", "bo", "os", "bps", "biz", "oos", "obo", "zo", "fits", "flo", "pins", "rob", "los", "obs", "abi", "bh", "zb", "bes", "cro", "ubis", "obb", "ros", "bs", "lol", "ko", "oops", "bi", "mis"]}}
{"id1": "4982745", "id2": "6866575", "code1": "    protected JSONObject doJSONRequest(JSONObject jsonRequest) throws JSONRPCException {\n        HttpPost request = new HttpPost(serviceUri);\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, getConnectionTimeout());\n        HttpConnectionParams.setSoTimeout(params, getSoTimeout());\n        HttpProtocolParams.setVersion(params, PROTOCOL_VERSION);\n        request.setParams(params);\n        request.addHeader(\"Authorization\", \"Basic \" + Base64Coder.encodeString(serviceUser + \":\" + servicePass));\n        HttpEntity entity;\n        try {\n            entity = new JSONEntity(jsonRequest);\n        } catch (UnsupportedEncodingException e1) {\n            throw new JSONRPCException(\"Unsupported encoding\", e1);\n        }\n        request.setEntity(entity);\n        try {\n            long t = System.currentTimeMillis();\n            HttpResponse response = httpClient.execute(request);\n            t = System.currentTimeMillis() - t;\n            Log.d(\"json-rpc\", \"Request time :\" + t);\n            String responseString = EntityUtils.toString(response.getEntity());\n            responseString = responseString.trim();\n            JSONObject jsonResponse = new JSONObject(responseString);\n            if (jsonResponse.has(\"error\")) {\n                Object jsonError = jsonResponse.get(\"error\");\n                if (!jsonError.equals(null)) throw new JSONRPCException(jsonResponse.get(\"error\"));\n                return jsonResponse;\n            } else {\n                return jsonResponse;\n            }\n        } catch (ClientProtocolException e) {\n            throw new JSONRPCException(\"HTTP error\", e);\n        } catch (IOException e) {\n            throw new JSONRPCException(\"IO error\", e);\n        } catch (JSONException e) {\n            throw new JSONRPCException(\"Invalid JSON response\", e);\n        }\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 0, "substitutes": {"doJSONRequest": ["doJSONResponse", "doHTTPOperation", "doHTTPCall", "doAPIResponse", "doHTTPRequest", " doJSONCall", " doHTTPRequest", "doAPICall", " doJSONOperation", "doHttpResponse", "doAPIRequest", "doAPIOperation", " doJSONResponse", "doHTTPResponse", " doHTTPResponse", "doJSONOperation", " doHTTPCall", "doHttpCall", "doHttpOperation", "doJSONCall", " doHTTPOperation", "doHttpRequest"], "jsonRequest": ["httprequest", "httpResponse", "sonrequest", "sonRequest", "JSONRequest", "httpQuery", "httpRequest", "jsonrequest", " jsonQuery", "sonQuery", "JSONResponse", " jsonrequest", "JSONrequest", "sonResponse", "JSONQuery", "jsonQuery"], "request": ["complete", "rest", "url", "result", "client", "builder", "call", "re", "e", "php", "transfer", "QUEST", "proxy", "child", "command", "worker", "xml", "er", "input", "q", "queue", "friend", "upload", "operation", "event", "type", "connection", "method", "r", "user", "application", "pe", "object", "head", "parent", "report", "query", "hello", "post", "message", "uri", "service", "resource", "api", "p", "get", "Request", "condition", "http", "document", "server", "push", "claim", "question", "req", "create", "trip", "json", "temp"], "params": ["address", "url", "posts", "services", "ip", "cache", "eps", "parse", "tmp", "lp", "apter", "rs", "Parameters", "xml", "manager", "default", "session", "stats", "ls", "param", "resources", "results", "database", "pps", "acl", "properties", "ssl", "afi", "arms", "options", "par", "handler", "ps", "config", "plugins", "padding", "headers", "mm", "parser", "ds", "phys", "api", "parts", "p", "array", "copy", "mac", "http", "phrase", "ams", "server", "password", "details", "json", "names", "eters", "ctx", "rules", "ras", "settings"], "entity": ["ga", "oe", "address", "url", "result", "client", "ue", "cache", "el", "e", "output", "security", "model", "environment", "xml", "ge", "issue", "node", "string", "ee", "image", "eme", "event", "element", "type", "connection", "component", "pe", "ent", "om", "object", "ale", "query", "attribute", "resource", "api", "person", "content", "document", "translation", "Entity", "data", "entry", "server", "instance", "json", "activity"], "t": ["wt", "test", "v", "tu", "started", "tw", "ti", "tp", "w", "e", "ot", "ts", "tt", "tools", "tf", "T", "tc", "te", "mt", "u", "time", "tim", "utt", "s", "tz", "tl", "set", "c", "len", "y", "m", "type", "at", "i", "r", "duration", "et", "ty", "ent", "n", "g", "ut", "o", "tick", "tm", "the", "p", "it", "h", "dt", "l", "ta", "d", "lt", "f"], "response": ["v", "result", "error", "status", "output", "feed", "Response", "res", "string", "location", "generation", "image", "success", "results", "respond", "connection", "application", "object", "body", "ception", "block", " Response", "message", "service", "resource", "wave", "document", "http", "page", "data", "resp", "server", "successful", "value", "full", "reply", "json", "onse", "collection", "relation"], "responseString": ["ResponseString", " responsestring", "ResponseBytes", "resultStr", "responsestring", "errorObject", "errorText", "responseStr", " responseData", "resourcestring", "resourceString", "helloText", " responseObject", "responseObject", "errorString", " responseStr", "resultData", "ResponseStr", " responseText", "helloBytes", "ResponseText", "resultString", " responseBytes", "ResponseObject", "Responsestring", "responseData", "errorStr", "responseBytes", "resourceStr", "responseText", "helloString", "resultText", "resourceData", "ResponseData"], "jsonResponse": ["xmlResp", "serverResponse", "sonResp", "sonSecret", "JSONResp", "javascriptPage", "responseView", "xmlView", "journalresponse", "xmlBlock", "responseResult", "jsonResp", "xmlSession", "sonRequest", "journalSecret", "JSONRequest", "jsonresponse", " jsonApplication", "javascriptRequest", "jsonSecret", "jsonResult", " jsonPage", "jsonSession", "responseResp", " jsonSecret", "journalResp", "sonSession", "sonBlock", "jsonApplication", "serverresponse", "xmlResponse", " jsonRes", "JSONView", " jsonBlock", "sonError", "sonApplication", "journalRequest", " jsonResp", "sonresponse", "JSONPage", "javascriptRes", "JSONResponse", "xmlEvent", "journalApplication", "xmlresponse", "jsonBlock", "serverSession", "JSONResult", " jsonresponse", "jsonPage", "jsonEvent", "sonEvent", "xmlResult", "responseResponse", " jsonEvent", "jsonView", "journalError", "serverError", "javascriptResponse", "journalResponse", "xmlError", "JSONRes", "sonResponse", "jsonRes"], "jsonError": [" jsonMessage", "journalerror", " jsonerror", "jsonResult", "jsonMessage", "xmlResponse", "sonerror", "jsonerror", " jsonException", "sonError", " jsonResult", "journalException", "sonResult", "jsonException", "sonException", "xmlResult", "journalError", "journalResponse", "sonMessage", "xmlError", "sonResponse", "xmlMessage"]}}
{"id1": "4164833", "id2": "4750967", "code1": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"buildDeb": ["buildLibrary", "builddeb", " rebuildDeb", "Builddeb", "BuildCredit", " buildLibrary", " builddeb", "BuildLibrary", " rebuilddeb", " rebuildCredit", "BuildDeb", "buildCredit", " buildCredit", " rebuildLibrary"], "debFile": ["debianFile", "fbFolder", "fbStyle", "rebFiles", "debianFilename", "bitcoinFiles", "rebStyle", "debianfile", "bitcoinFile", "debFilename", "bitcoinFilename", "DebFilename", "DebFiles", "debianFiles", "debfile", "DebStyle", "DebFile", "fbFile", "debFiles", "Debfile", "bitcoinfile", "debFolder", "fbFiles", "rebFolder", "debStyle", "rebFile", "DebFolder"], "controlFile": ["contactFile", "ctrlFile", "ControlFiles", "controlFolder", "ctrlPage", "ctrlFiles", "ctrlStream", "controlledfile", "controlfile", "ctrlfile", " controlFiles", "controlPage", "controlFiles", " controlPage", "Controlfile", "contactPage", "controlStream", "ControlEntry", " controlPath", "ctrlPath", "configfile", " controlEntry", "configFolder", "contactFiles", "controlledFile", "ControlFile", "ctrlInfo", "controlEntry", "ControlPath", "contactStream", "configInfo", " controlName", " controlfile", "ctrlName", "configFile", "controlledInfo", " controlStream", "controlPath", "ControlName", "ctrlFolder", "controlledFolder", "ctrlEntry", "controlName", "controlInfo"], "dataFile": ["dataLog", "datFile", "datfile", " dataPath", "controlfile", "controlStore", "configPage", "basefile", " dataFiles", "controlFiles", "configLog", "dataStore", "DataStream", "datDirectory", "Datafile", "DataPath", "datStream", "controlStream", "datafile", "dataPage", "DataFile", "datLog", "basePath", "configfile", "dataFiles", "infoFile", " dataStore", "dataPath", "infoFiles", "dataStream", "datPage", "baseFile", "infoStore", "configFile", "infofile", "controlDirectory", " datafile", "DataPage", "dataDirectory", "DataLog", "DataDirectory"], "now": ["first", " NOW", "false", "base", "after", "current", "load", "not", "old", "created", "default", "always", "function", "start", "length", "NOW", "max", "time", "name", "seed", "then", "set", "next", "this", "off", "self", "day", "or", "small", "wait", "count", "today", "Now", "ow", "currently", "ok", "post", "date", "once", "from", "age", "low", "since", "create", "and", "later", "timer", "oa", "size", "cmp"], "deb": ["error", "ib", "dp", "sem", "log", "fb", "div", "mb", "cp", "rib", "budget", "aff", "ssl", "daily", "def", "library", "ub", "pub", "eb", "github", "bang", "abc", "conf", "blog", "cm", "dec", "bb", "allow", "dep", "priv", "db", "boot", "bug", "pkg", "bank", "raf", "Deb", "broad", "b", "hide", "rb", "reb", "obb", "cb", "cf", "design", "tab", "compl", "debian", "org", "ban", "config", "loc", "av", "bel", "af", "lab", "work", "bh", "download", "plug", "exec", "img", "dl", "ob", "nb", "default", "df", "fin", "ee", "pay", "cop", "cdn", "diff", "dr", "req", "aud", "dev", "die", "web"], "control": ["exec", "flow", "address", "url", "controlled", "monitor", "error", "reader", "client", "own", "output", "controller", "feed", "io", "child", "sub", "internal", "manager", "radio", "input", "connect", "restricted", "length", "core", "conn", "stream", "regular", "correct", "Control", "down", "lib", "event", "broad", "safe", "ignore", "config", "per", "edit", "co", "media", "form", "copy", "http", "channel", "work", "group", "ack", "open", "ctrl", "select"], "buffer": ["address", "url", "result", "base", "uffer", "reader", "cache", "transfer", "comment", "feed", "request", "border", "length", "sequence", "binary", "offset", "queue", "write", "character", "layer", "broad", "writer", "reference", "batch", "count", "shape", "buf", "null", "number", "slice", "block", "pad", "array", "iter", "resource", "message", "uri", "bytes", "wave", "flush", "copy", "document", "key", "page", "entry", "server", "file", "source", "channel", "variable", "limit", "record", "capacity", "value", "size", "buff"], "read": ["id", "raw", "log", "start", "length", "core", "off", "wait", "show", "pull", "READ", "ize", "scale", "loop", "value", "pick", "size", "bind", "allow", "use", "feed", "child", "check", "input", "seek", "write", "rate", "en", "shape", "Read", "close", "key", "get", "create", "reads", "ack", "open", "run", "reader", "parse", "io", "ready", "skip", "connect", "no", "count", "fill", "find", "slice", "each", "resource", "it", "copy", "work", "reading", "ask", "flow", "ip", "send", "level", "view", "load", "readable", "request", "index", "play", "end", "next", "set", "build", "type", "ride", "text", "sync", "ok", "add", "pass", "draw", "ink", "ed", "select"], "data": ["complete", "map", "result", "base", "error", "da", "reader", "ata", "cache", "ada", "own", "view", "feed", "valid", "child", "db", "one", "function", "input", "auto", "binary", "ui", "li", "memory", "multi", "image", "write", "down", "database", "like", "extra", "writer", "dat", "object", "body", "video", "block", "aa", "pad", "update", "media", "resource", "api", "close", "done", "la", "di", "file", "download", "and", "area", "part", "open", "partial"]}}
{"id1": "11341711", "id2": "10795866", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"makeBackup": ["createbackUp", "makeBackdown", "createbackdown", "makePickup", "makebackdown", "makeCleandown", "createBackups", "makebackups", "createBackUp", "makeBackups", "makeCleanUp", "makeBackUp", "makePickdown", "makebackup", "makeCleanups", "makePickups", "createbackup", "makebackUp", "makeCleanup", "makePickUp", "createbackups", "createBackdown", "createBackup"], "dir": ["md", "url", "base", "cache", "dep", "Dir", "zip", "dict", "io", "db", "path", "folder", "log", "ir", "name", "doc", "pkg", "build", "lib", "root", "desc", "directory", "dest", "direction", "DIR", "config", "diff", "done", "source", "wd", "store", "rc", "data", "work", "file", "up", "download", "dist", "d", "init", "director", "group", "Directory", "manager", "run", "module"], "sourcedir": ["asourcedirs", "sourcesir", "ssourcediri", "sourcesdir", "ssourcedir", "sourcedirs", "sodedore", "asortedir", "ssodediri", "sortedirs", "sodediri", "sodeddir", "ssodedIR", "sodedIR", "sourcesIR", "seediri", "sourcediri", "sortedIR", "asortedore", "sourcesore", "sortedore", "ssourceddir", "asortedirs", "asortedIR", "sourceddir", "seedIR", "sourcesiri", "sodedirs", "sodedir", "sourcedore", "sourcesirs", "ssodeddir", "ssourcedIR", "seedir", "asourcedir", "sortedir", "asourcedIR", "asourcedore", "ssodedir", "seeddir", "sourcedIR"], "destinationdir": ["Destinationdir", "dominatorDir", "destinatorDir", "DestinationDir", "destinationsdir", "destinationfolder", "destificationdir", "destinateDIR", "destinateDir", "dominatorDIR", "Destinationdirection", "destinatefile", "dominationDIR", "desturationfolder", "destificationfolder", "Destificationdirection", "destinatordir", "destinationDir", "destinatedir", "Destificationfolder", "dominationDir", "destinationdirection", "dominationfile", "destinatorDIR", "destinationsDir", "Destificationdir", "destinationfile", "Destinationfolder", "desturationDir", "desturationdirection", "dominatorfile", "destinatedirection", "desturationdir", "destificationdirection", "dominatordir", "destificationDir", "destinatorfile", "destinationsDIR", "dominationdir", "destinationsfile", "destinationDIR", "DestificationDir", "destinatefolder"], "destinationDirEnding": ["destinationDirectoryEndening", "destinationPathBeginging", "destinationDirBeginning", "destinationDirSignening", "destinationDirEndging", "destinationDirBegining", "destinationDirEndining", "destinationPathBeginning", "destinationPathBeginING", "destinationDirSigning", "destinationDirEndning", "destinationDirBeginING", "destinationDirPassING", "destinationDirectoryEndining", "destinationDirSignining", "destinationDirLeadining", "destinationDirENDING", "destinationPathEndING", "destinationDirPassing", "destinationDirectorySignING", "destinationDirEndING", "destinationDirBeginining", "destinationDirectoryEnding", "destinationDirBeginening", "destinationDirPassging", "destinationDirENDing", "destinationDirPassning", "destinationDirENDging", "destinationPathEnding", "destinationPathEndging", "destinationPathBegining", "destinationDirLeading", "destinationDirectorySignening", "destinationDirLeadening", "destinationDirectoryEndING", "destinationDirLeadING", "destinationDirectorySignining", "destinationPathEndning", "destinationDirEndening", "destinationDirENDning", "destinationDirectorySigning", "destinationDirSignING", "destinationDirBeginging"], "files": ["rules", "services", "objects", "ins", "classes", "types", "groups", "output", "ids", "flows", "reports", "docs", "xml", "children", "iles", "log", "users", "locks", "index", "parents", "ls", "sections", "lines", " Files", "resources", "results", "projects", "modules", "strings", "uploads", "words", "items", "errors", "models", "rows", "images", "runs", "ps", "boxes", "events", "actions", "fs", "blocks", "books", "links", "its", "Files", "bugs", "ips", "pages", "l", "fields", "thumbnails", "file", "planes", "tests", "data", "keys", "split", "names", "balls", "features"], "checkdir": ["workDIR", "checkDir", "workdraft", "blockdraft", "blockDir", "checkfile", "CheckDIR", "CheckDir", "lockDir", "ckfile", " checklog", "ckdirectory", "checkdraft", "calldir", "ckdir", "Checkdir", "worklog", "lockdir", " checkdirectory", "checkDIR", "searchdraft", "lockFolder", "checkdirectory", "workfile", "searchdirectory", "searchDir", " checkfile", "workFolder", "checklog", " checkDir", "workfolder", " checkd", "workDir", " checkDIR", "blockdir", "ckDir", "ckfolder", "callfolder", "Checkfile", "workdir", "workdirectory", "checkd", "locklog", " checkfolder", "blockdirectory", "checkFolder", "calld", "calldirectory", "searchdir", " checkFolder", "checkfolder", "ckd"], "date": ["md", "de", "mate", "change", " Date", "now", "ime", "e", "sign", "Date", "log", "ge", "start", "name", "state", "time", "month", "contact", "image", "set", "doc", "day", "rate", "m", "zone", "event", "at", "dat", "user", "late", "tag", "config", "update", "dt", "ate", "age", "data", "file", "d", "open", "mu"], "msec": [" minsc", "Msecond", "dsecond", "Msec", "dseconds", "fmsec", "csec", "lsec", "disec", "mnif", "lseconds", "mnSec", " mSec", "mSec", "mnsc", "mseconds", "fmseconds", "mif", " minsec", "lss", "Misec", "msecond", "mnsec", "fmisec", "cseconds", " mif", "msc", " minif", "rsec", "Mseconds", "mss", "css", "rseconds", "misec", "dsec", " minSec", "lsecond", " msc", "rss", "fmsecond", "rsecond", "csecond"], "checkFile": ["checkDir", "CheckDirectory", "checkfile", "ckFiles", "CheckDir", "controlfile", "ckfile", "workFile", "workFiles", " checkFilename", "checkLine", "workfile", " checkfile", " checkDir", "changeFile", "controlLine", "workDir", "CheckFiles", "checkDirectory", "ckFile", "changeFilename", "controlFile", "checkFiles", " checkDirectory", "Checkfile", " checkFiles", "checkFilename", "changefile", " checkLine", "ckDirectory", "CheckFile", "controlFilename", "changeLine"], "i": ["qi", "v", "im", "ip", "ai", "ti", "vi", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "ui", "li", "u", "hi", "multi", "ci", "si", "phi", "ii", "y", "m", "j", "ie", "info", "b", "n", "slice", "ri", "uri", "p", "gi", "key", "fi", "ix", "is", "di", "oi", "field", "ji", "part", "mu", "bi", "pi"], "f": ["fp", "v", "cf", "fun", "w", "e", "feed", "folder", "df", "fl", "fb", "q", "u", "fe", "m", "t", "j", "fx", "r", "info", "b", "n", "o", "F", "fc", "fr", "fs", "p", "fi", "fd", "h", "l", "fn", "file", "d", "sf"], "g": ["ga", "ger", "tg", "gin", "ng", "w", "gm", "gb", "e", "reg", "gc", "gh", "ge", "eg", "q", "s", "u", "og", "sg", "gn", "m", "t", "global", "gd", "go", "rg", "G", "gp", "b", "n", "bg", "r", "ig", "mg", "gar", "p", "gi", "pg", "h", "l", "file", "gg", "d", "group", "gu", "erg", "gs", "msg", "vg"], "destinationFile": ["DestificationDirectory", "destacementFile", "destinatorDir", "DestinationDir", "destinationLocation", "DestinationFile", "destificationLocation", "destacementFilename", "destiningFile", "destinatorLocation", "destationfile", "destinatorFile", "destificationDirectory", "DestinationDirectory", "destinationsDirectory", "destacementfile", "destiningfile", "destacementDir", "destinationDir", "destationDir", "DestificationFile", "DestificationLocation", "destiningFilename", "DestationFilename", "destinationsDir", "destationFile", "DestationDir", "destinatorDirectory", "destinationfile", "destinationsFile", "DestationFile", "destationFilename", "DestinationLocation", "destinationsLocation", "destinationDirectory", "destiningDir", "DestinationFilename", "destificationDir", "destificationFile", "Destationfile", "Destinationfile", "destinationFilename", "DestificationDir"], "sourceFile": ["sourceModule", " sourceDir", "ourceDirectory", "sourceFiles", "inputDir", "srcDir", "srcFile", "ourceFile", "inputFile", " sourceFiles", "srcfile", "ourceDir", "ourceFiles", " sourceDirectory", " sourcefile", "SourceFile", "sourcefile", "inputFiles", "sourceDirectory", "inputDirectory", " sourceModule", "SourceModule", "Sourcefile", "srcModule", "sourceDir", "SourceDir"], "infile": [" indata", "Infile", "inputdata", "outdir", "inputFile", "InFile", " inFile", " instream", "inFile", "outstream", "Instream", "outFile", "difffile", "windir", "winfile", "indir", "outf", "inputf", "outdata", "indata", "diffFile", "winstream", "Inf", "diffstream", "inf", "diffdir", "inputstream", "instream", "inputfile", "winFile"], "outfile": ["Outfunction", "outpage", "outfunction", "intlive", "againstream", " outfunction", "intFile", "inputFile", "outstream", "exfile", "outFile", "outline", "exstream", "inputfunction", "Outlive", "inputline", " outFile", " outline", " outlive", "expage", " outpage", "intfile", " outstream", "outlive", "againpage", "Outstream", "againfile", "intstream", "OutFile", "exFile", "Outline", "Outfile", "againFile", "inputfile"], "c": ["v", "lc", "k", "z", "cl", "cm", "cy", "dec", "uc", "cont", "w", "e", "id", "C", "x", "index", "pointer", "string", "end", "cr", "u", "ci", "character", "code", "m", "t", "ct", "a", "r", "ec", "b", "cu", "n", "ice", "esc", "o", "enc", "p", "h", "rc", "col", "in", "l", "char", "ch", "channel", "d", "pc", "ac", "abc", "comment", "xc"]}}
{"id1": "17202158", "id2": "10445819", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"readZoneIDs": ["loadzoneID", "readCodeIDs", "readZoneIDS", "readLocationIDS", "readLocationID", "readCodeNames", "loadzoneNames", "loadZoneID", "readzoneIDS", "readzoneNames", "loadzoneIDS", "readZoneID", "loadZoneIDs", "readLocationIDs", "readzoneID", "readCodeIDS", "loadZoneIDS", "readLocationNames", "readCodeID", "loadzoneIDs", "readZoneNames", "readzoneIDs", "loadZoneNames"], "zoneFileName": [" zoneDirUrl", "ZonefileUrl", "zoneFilename", "zoneFullPath", "zoneFileUrl", "zoneFilesPath", "zoneFullUrl", "zoneDirUrl", "Zonefilename", "zoneClassPath", "ZoneFileName", "zonefileUrl", "zoneFullname", "zoneLineName", "ZoneFilePath", "zoneLineUrl", "ZoneFileUrl", "zonefilename", " zoneDirName", "zoneClassName", " zoneFileUrl", "zoneFullName", "zoneClassname", " zoneDirPath", "ZonefilePath", "zoneDirName", "zoneClassUrl", "zonefilePath", "ZonefileName", "zoneFilesName", "zoneLinePath", "zoneFilePath", "zonefileName", "zoneDirPath", "zoneFilesUrl", "ZoneFilename", "zoneFilesname", " zoneFilePath"], "zoneids": ["poids", "sizeid", " zoneints", "ZoneIDs", "typeips", "zipid", "ziplines", "pofiles", " zoneid", "sizeips", "zonefiles", "typeids", "typeints", "zipIDs", "zoneips", "poIDs", "sizeints", "zoneIDs", "zipids", "Zoneids", "typeid", " zonelines", " zoneIDs", "Zoneid", " zonefiles", "zoneints", "polines", " zoneips", "poid", "sizeids", "Zonefiles", "zonelines", "zoneid"], "url": ["address", "base", "reader", "client", "job", "re", "feed", "io", "URL", "ball", "path", "sl", "Url", "location", "string", "name", "stream", "hub", "this", "ssl", "connection", "r", "class", "b", "user", "loader", "ur", "buffer", "uri", "service", "resource", "api", "bel", "http", "l", "page", "source", "file", "server", "data", "channel", "f"], "lnr": ["linw", "nlb", "slb", "linn", "nlw", "nlr", "lenr", "lenw", "linp", "slrb", "nlp", "slr", "sln", "lnw", "lenp", "lnp", "lnb", "rlb", "rlrb", "rlr", "linr", "lenb", "lnn", "lnrb", "linb", "linrb", "rln"], "line": ["lc", "cl", "header", "base", "column", "str", "parse", "el", "id", "log", "nl", "row", "sl", "ge", "string", "name", "Line", "lines", "word", "no", "link", "c", "code", "LINE", "sel", "look", "number", "rule", "block", "message", "cell", "key", "jo", "lf", "page", "lin", "data", "file", "l", "entry", "col", "char", "letter", "inline", "ne", "part", "unit", "comment", "response", "le"]}}
{"id1": "3409084", "id2": "18358467", "code1": "    protected String getRequestContent(String urlText) throws Exception {\n        URL url = new URL(urlText);\n        HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();\n        urlcon.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream()));\n        String line = reader.readLine();\n        reader.close();\n        urlcon.disconnect();\n        return line;\n    }\n", "code2": "    public DocumentSummary parseDocument(URL url) throws IOException, DocumentHandlerException {\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n            POIOLE2TextExtractor extractor = createExtractor(inputStream);\n            SummaryInformation info = extractor.getSummaryInformation();\n            DocumentSummary docSummary = new DocumentSummary();\n            docSummary.authors = DocSummaryPOIFSReaderListener.getAuthors(info);\n            docSummary.contentReader = new StringReader(extractor.getText());\n            docSummary.creationDate = info.getCreateDateTime();\n            docSummary.keywords = new ArrayList();\n            docSummary.keywords.add(info.getKeywords());\n            docSummary.modificationDate = new Date(info.getEditTime());\n            docSummary.title = info.getTitle();\n            return docSummary;\n        } catch (IOException e) {\n            if (e.getMessage().startsWith(\"Unable to read entire header\")) {\n                throw new DocumentHandlerException(\"Couldn't process document\", e);\n            } else {\n                throw e;\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getRequestContent": ["readResponseContent", "readResponseText", "getResponseString", "getHttpBody", "readResponseString", "getHttpContent", "getHttpString", "getHttpText", "getRequestText", "readRequestString", "getrequestText", "getrequestBody", "getRequestBody", "getRequestString", "getResponseContent", "getrequestString", "readRequestText", "readRequestBody", "getResponseBody", "readResponseBody", "getrequestContent", "getResponseText", "readRequestContent"], "urlText": [" urlTEXT", "resourceContent", "resourcetext", "strTEXT", " urlContent", "httpTEXT", "pageText", "urlTEXT", "strtext", " urlString", "pageTEXT", "urlString", "urlContent", "strContent", "resourceTEXT", "resourceText", "httpText", "strText", "pageString", "httpString", "urltext", " urltext"], "url": ["bc", "base", "client", "str", "feed", "URL", "path", "log", "sl", "fl", "Url", "host", "conn", "ls", "image", "c", "this", "build", "or", "ssl", "connection", "r", "user", "b", "object", "ll", "www", "config", "ur", "lr", "uri", "resource", "api", "http", "l", "page", "server", "full", "open", "web", "rl", "blog", "f"], "urlcon": ["httpenc", "urcon", "urlfc", "httpconnect", "webCon", "httpcon", " urlenc", "webconn", " urlconnect", "webcon", "URLCon", "urlann", " urlconst", " urlrun", "UrlCon", "urconn", " urlconn", "URLcon", "urlenc", "urlconst", " urlCon", "httpconn", " urlann", "urlconn", "urlclient", "webann", "webconnect", "Urlfc", "httpCon", "httpclient", "Urlclient", "httpann", "urrun", "Urlcon", "urlCon", "urlconnect", "webenc", "urlrun", "httprun", "URLfc", "URLclient", "httpconst", "urconst", "httpfc"], "reader": ["ser", "result", "car", "finder", "io", "rr", "worker", "cher", "rer", "ler", "row", "input", "er", "stream", "inner", "keeper", "read", "Reader", "or", "editor", "bird", "writer", "i", "r", "layer", "rx", "handler", "oder", "per", "loader", "ner", "ri", "her", "buffer", "iter", "parser", "in", "data", "file", "rar", "director", "reading", "ker"], "line": ["str", "feed", "log", "row", "val", "string", "name", "end", "Line", "lines", "link", "code", "LINE", "read", "element", "user", "text", "body", "block", "message", "buffer", "content", "page", "data", "lin", "file", "inline", "letter", "entry", "char", "email", "pass", "value", "response", "cell"]}}
{"id1": "471804", "id2": "7425022", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersionUpdate", " doVersionUpdate", " doversionCheck", "doversionScan", "doversionCheck", "doChangeCheck", "doChangecheck", " doversioncheck", "doChangeUpdate", "doversioncheck", "doVersioncheck", "doFeaturecheck", " doVersionScan", " doversionUpdate", "doversionUpdate", "doFeatureScan", "doVersionScan", "doFeatureCheck", " doversionScan", "doChangeScan", "doFeatureUpdate", " doVersioncheck"], "view": ["v", "cache", "vol", "window", "e", "port", "model", "div", "row", "session", "link", "sel", "box", "show", "query", "display", "form", "server", "fail", "value", "full", "group", "gu", "client", "use", "VIEW", "check", "input", "View", "lock", "event", "user", "object", "video", "block", "views", "vis", "by", "http", "page", "review", "pool", "comment", "can", "cell", "im", "base", "change", "el", "ou", "container", "screen", "body", "head", "config", "list", "index", "out", "ui", "image", "this", "widget", "self", "html", "see", "edit", "layout", "update", "ve", "up", "style", "manager"], "url": ["address", "base", "builder", "rel", "bb", "ob", "id", "zip", "URL", "path", "log", "sl", "Url", "host", "location", "string", "name", "ls", "gl", "stream", "bug", "length", "image", "hub", "link", "ssl", "b", "browser", "null", "ll", "www", "loc", "socket", "loader", "fr", "buffer", "uri", "ul", "resource", "http", "l", "source", "file", "server", "download", "email", "impl", "open", "web", "blog", "f"], "in": ["ins", "reader", "din", "IN", "login", "isin", "inc", "bis", "ini", "input", "out", "In", "binary", "s", "inner", "stream", "err", "doc", "m", "b", "again", "sin", "socket", "nin", "win", "buffer", "resource", "inn", "pin", "is", "cin", "lin", "data", "file", "source", "init", "rin", "con", "ac", "as"], "bin": ["bn", "gin", "reader", "din", "IN", "login", "bb", "nb", "vin", "spin", "ini", "input", "border", "out", "binary", "fin", "inner", "lock", "bot", "ruby", "lib", "oin", "ban", "b", "browser", "body", "sin", "socket", "loader", "win", "buffer", "inn", "pin", "abi", "arin", "cin", "lin", "is", "file", "init", "con", "record", "bi", "run"], "line": ["lc", "cl", "base", "ip", "job", "str", "parse", "el", "e", "id", "zip", "one", "log", "le", "val", "ge", "row", "nl", "sl", "string", "name", "end", "Line", "out", "lines", "range", "word", "write", "link", "code", "LINE", "look", "type", "pe", "definition", "b", "user", "text", "object", "block", "pin", "key", "jo", "lf", "lin", "data", "file", "page", "l", "entry", "inline", "up", "letter", "unit", "ine", "part", "comment", "cell"], "version": ["feature", "position", "v", "ver", "project", "beta", "id", "cover", "model", "plugin", "python", "patch", "host", "string", "name", "bug", "driver", "section", "image", "code", "format", "vision", "type", "release", "user", "Version", "null", "video", "latest", "pull", "install", "update", "support", "license", "date", "option", "vert", "versions", "server", "download", "VERSION", "secret", "device", "value", "dev", "unit", "author"], "build": ["uild", "ver", "job", "builder", "rel", "follow", "clean", "use", "feed", "load", "valid", "log", "boot", "make", "row", "patch", "hold", "Build", "bug", "lock", "image", "link", "lease", "info", "print", "release", "show", "tag", "built", "pull", "block", "install", "building", "update", "post", "mount", "how", "add", "get", "http", "work", "style", "help", "home", "unit", "run"]}}
{"id1": "19584877", "id2": "19849797", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeFileToFiles", "encodeStringToFiles", "encodeFile2Stream", "encodeFiletoStream", "encodeFileFromFile", "encodeFileFromStream", "encodeFiletoFile", "encodeString2File", "encodeFiletoFiles", "encodeString2Files", "encodeFile2File", "encodeString2String", "encodeString2Stream", "encodeFileFromString", "encodeFileToString", "encodeFile2String", "encodeStringToString", "encodeFileToStream", "encodeFiletoString", "encodeStringToStream", "encodeFile2Files", "encodeStringToFile"], "infile": ["Infile", "infiles", "inputFile", "InFile", "inFile", "Infiles", "outFile", "inputfiles", "infilename", "outfilename", " infilename", "outfiles", "inputfp", "infp", " infiles", "inputfilename", " infp", "outfp", "Infilename", "inputfile"], "outfile": ["outputfilename", "newname", "Outname", "newFile", "outname", "infolder", "newfolder", " outname", "Outfolder", "outFile", "outfolder", " outfolder", "infilename", "outfilename", "outputfp", " outFile", "outputfile", " outfilename", " outfp", "newfile", "infp", "OutFile", "outputfolder", "Outfile", "outfp"], "in": ["gin", "base", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "vin", "ini", "input", "ic", "In", "s", "conn", "inner", "image", "err", "inas", "m", "a", "i", "r", "b", "again", "sin", "socket", "nin", "win", "inn", "min", "pin", "is", "into", "cin", "data", "source", "init", "inside", "rin", "pass", "ac", "con", "as"], "out": ["net", "exec", "base", "error", "OUT", "client", "outs", "cache", "job", "output", "bin", "ou", "io", "inc", "one", "session", "conn", "obj", "In", "inner", "on", "name", "to", "image", "err", "write", "off", "no", "Out", "lib", "or", "writer", "ex", "parent", "again", "o", "co", "socket", "sync", "post", "outer", "timeout", "point", "copy", "line", "source", "work", "file", "up", "home", "exit"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bb", "transfer", "feed", "raw", "fb", "input", "border", "length", "seed", "binary", "offset", "queue", "write", "len", "layer", "type", "reference", "batch", "count", "b", "null", "buf", "slice", "padding", "iter", "bytes", "wave", "flush", "data", "source", "server", "limit", "value", "split", "size", "buff"], "read": ["exec", " skip", " Read", "ip", "reader", "send", " copy", "parse", "lex", "allow", "use", "id", "feed", "io", "load", "inc", "raw", "current", "_", "check", "x", " count", "input", "connect", "start", "length", "ind", "play", "seek", "end", "write", "next", "len", "i", "count", "ride", "wait", "fill", "n", "find", "Read", "slice", "sync", "READ", "tell", " write", "ad", "iter", "close", "add", "get", "copy", "work", "sleep", "se", "limit", "reads", "pass", "reading", "size", "select", "f", "run"], "success": ["complete", "first", "result", "error", "cess", " succ", "fast", "status", "ccess", "growth", "follow", "flash", "primary", "right", "Success", "valid", "model", "func", "path", "default", " succeed", " Success", "true", "winner", "rolled", "results", "xx", "failed", "danger", " successful", "construct", "method", "null", "again", "ceed", "good", "message", "done", "rolling", "successfully", "respons", "content", "continue", "data", "warning", "successful", "pass", "roll", "initial", "better", "fail", "value", "open", "modified", "comment", "response"]}}
{"id1": "693636", "id2": "8801436", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createEmptyCart": ["createNewShipping", " createEmptySpot", " createEmptycart", "createEmptycart", "createNewCart", "createNewSpot", " createNewSpot", "createNewcart", "createCreatecart", "createCreateSpot", "createCreateCart", "createTempSpot", " createNewShipping", "createTempCart", "createTempcart", " createNewCart", "createEmptyShipping", " createNewcart", " createEmptyShipping", "createEmptySpot", "createCreateShipping", "createTempShipping"], "SHOPPING_ID": ["SHOPPIPIDIDS", "SHOPPIP_ID", "SHOPPIPIDid", "SHOPPINGPOIDs", "SHOPPINGIDIDs", "SHOPPING_IDS", "SHOPPING_IDs", "SHOPPIP_id", "SHOPPINGIDid", "SHOPPTING_id", "SHOPPINGPOId", "SHOPPINGPOID", "SHOPPIP_IDS", "SHOPPYING_ID", "SHOPPINGINGId", "SHOPPYING_IDS", "SHOPPINGIDId", "SHOPPIP_Id", "SHOPPINGINGid", "SHOPPYING_Id", "SHOPPTING_Id", "SHOPPIPIDId", "SHOPPIPIDIDs", "SHOPPTING_ID", "SHOPPINGPOIDS", "SHOPPING_id", "SHOPPIP_IDs", "SHOPPING_Id", "SHOPPYING_IDs", "SHOPPIPIDID", "SHOPPINGIDIDS", "SHOPPINGINGID", "SHOPPINGIDID"], "con": ["exec", "bc", "cm", "cf", "mc", "client", "ca", "uc", "ann", "can", "cache", "com", "un", "ran", "reg", "inc", "cur", "db", "wan", "log", "row", "connect", "session", "conn", "conv", "cr", "c", "ci", "cc", "fa", "en", "ec", "connection", "ex", "pen", "co", "fc", "loc", "Con", "win", "cond", "close", "cas", "CON", "rc", "commit", "col", "pool", "act", "cn", "coll", "pc", "ac", "Conn", "cons", "ctrl", "conf", "ctx", "fac"], "insert_cart": ["insert_pod", "insert_container", "install_container", "insert_center", "exec_Cart", "insertencycle", " insert_center", "insert_ox", "insertencart", "insert_payment", " insert_pod", "insertencat", "exec_payment", "insertencenter", " insert_cat", "exec_cart", "insert_conn", " insert_ox", "insert_part", " insert_conn", "install_part", "install_cart", " insert_cycle", "insert_cycle", "insert_cat", "insert_Cart"]}}
{"id1": "1133123", "id2": "7149578", "code1": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 0, "substitutes": {"openConnection": ["closeConnect", "closeConnection", "createConn", "closeConnector", "createConnect", "openConn", "closeConn", "OpenConnector", "OpenConnection", "createConnection", "OpenConn", "closeChannel", "createChannel", "createConnector", "OpenChannel", "openChannel", "openConnector", "openConnect", "OpenConnect"], "url": ["address", "base", "str", "el", "id", "URL", "proxy", "path", "log", "sl", "Url", "host", "location", "name", "image", "link", "this", "ssl", "connection", "options", "null", "object", "ll", "config", "loc", "buffer", "uri", "iter", "resource", "service", "bel", "http", "l", "source", "file", "server", "data", "channel", "limit", "f"]}}
{"id1": "11546108", "id2": "5744992", "code1": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "code2": "    public void dorequest(Map<String, String> ps, String method) throws IOException {\n        StringBuffer httpResponse = new StringBuffer();\n        URL ourl = new URL(url);\n        HttpURLConnection httpConnection = (HttpURLConnection) ourl.openConnection();\n        httpConnection.setRequestMethod(method);\n        httpConnection.setDoOutput(true);\n        this.setCookie(httpConnection);\n        OutputStream httpOutputStream = httpConnection.getOutputStream();\n        StringBuffer postParams = new StringBuffer(\"\");\n        for (Entry<String, String> entry : ps.entrySet()) {\n            postParams.append(entry.getKey());\n            postParams.append(\"=\");\n            postParams.append(entry.getValue());\n            postParams.append(\"&\");\n        }\n        httpOutputStream.write(postParams.toString().getBytes());\n        BufferedReader httpBufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n        httpResponse.append(this.readBufferedContent(httpBufferedReader));\n        text = httpResponse.toString();\n        this.readCookie(httpConnection);\n    }\n", "label": 0, "substitutes": {"run": ["exec", "test", "Run", "apply", "call", "output", "load", "request", "input", "start", "action", "write", "build", "read", "running", "print", "println", "update", "evaluate", "submit", "process", "execute", "download", "loop", "runner"], "in": ["ins", "reader", "din", "IN", "client", "token", "login", "e", "bin", "io", "inc", "isin", "ini", "input", "out", "In", "s", "fin", "stream", "inner", "cms", "c", "t", "ssl", "r", "b", "again", "socket", "loader", "nin", "fr", "buffer", "inn", "min", "h", "is", "l", "data", "pool", "lin", "source", "init", "server", "rin", "con", "serv", "f"], "ligneEnCours": ["ligneOpenAcours", "ligneEnAcourses", "ligneENCore", "ligneEncour", "ligneEnFCours", "ligneEnTOUR", "ligneOpenCours", "ligneENcurs", "ligneENAcourses", "ligneEnLCOUR", "ligneEnTours", "ligneEnLCour", "ligneEnTurs", "ligneenAcore", "ligneENAcour", "ligneEncrosse", "ligneEncours", "ligneEnAcore", "ligneenCourses", "ligneEnTour", "ligneENCourses", "ligneENAcours", "ligneEnCurs", "ligneEncOUR", "ligneenAcourses", "ligneEnAcurs", "ligneEnCour", "ligneEnTore", "ligneEnFCour", "ligneEncore", "ligneEnScourses", "ligneENcOUR", "ligneEnTourses", "ligneEnFCurs", "ligneEnSOUR", "ligneOpenCurs", "ligneENCurs", "ligneenAcour", "ligneENCrosse", "ligneEnCrosse", "ligneEnAcours", "ligneenCours", "ligneEnCourses", "ligneENcours", "ligneenCour", "ligneEnFCOUR", "ligneOpenCOUR", "ligneOpenCour", "ligneEnScours", "ligneENAcore", "ligneEnScOUR", "ligneEnLCrosse", "ligneEnCOUR", "ligneEnLCours", "ligneEnScore", "ligneEnSour", "ligneOpenAcour", "ligneEncourses", "ligneenCore", "ligneEnScrosse", "ligneENCours", "ligneENcrosse", "ligneENCOUR", "ligneENCour", "ligneEncurs", "ligneEnSours", "ligneOpenAcOUR", "ligneEnCore", "ligneOpenAcurs", "ligneEnSurs", "ligneEnAcour", "ligneEnAcOUR", "ligneenAcours", "ligneEnScour", "ligneENcour"], "i": ["qi", "v", "k", "esi", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "start", "ui", "li", "u", "ci", "c", "si", "phi", "ii", "m", "j", "t", "type", "info", "count", "counter", "b", "n", "o", "zi", "ski", "uri", "p", "gi", "di", "oi", "col", "l", "yi", "f", "bi", "pi"], "informations": ["informsators", "information", "inspectats", "inceptionats", "inspectations", "inceptionations", "inpectals", "inpectats", "incformations", "inparals", "informsations", "inpectations", "invocation", "instrumentation", "incstrumentats", "insformats", "insformals", "inspectals", "informats", "incstrumentings", "inpectators", "informsals", "inceptionation", "instrumentings", "incformation", "inparats", "insformators", "inceptionings", "incformings", "informsats", "incstrumentation", "instrumentations", "insformations", "inparations", "invocations", "informators", "instrumentats", "invocats", "invocings", "incformats", "informals", "inspectators", "incstrumentations", "informings", "inparators"], "version": ["feature", "v", "position", "ip", "ver", "description", "model", "index", "language", "prefix", "release", "Version", "number", "parent", "install", "uri", "resource", "page", "versions", "channel", "server", "source", "VERSION", "download", "unit", "comment"], "url": ["address", "position", "base", "status", "output", "URL", "path", "xml", "location", "language", "image", "prefix", "ssl", "number", "text", "config", "uri", "resource", "http", "href", "page", "source", "server", "channel", "download", "json", "comment"], "texteErreur": ["texteErrecurs", "texteErbreaser", "texteErritour", "texteErraser", "texteCurreur", "texteArrenure", "texteErrorrenuries", "texteErreUR", "texteErreurs", "texteErrecaur", "texteErruur", "texteErrecure", "texteErreuries", "texteErrorreur", "texteIrreuries", "texteErruries", "texteIrraser", "texteErreau", "texteErregur", "texteErregure", "texteCurrecurred", "texteErpreUR", "texteErreeuries", "texteErreure", "texteIrruries", "texteErreaur", "texteErrorreour", "texteErbreuries", "texteIrreaser", "texteErrecUR", "texteErbreur", "texteCurreurred", "texteErrenuries", "texteErruaser", "texteErrorrenau", "texteIrreur", "texteErritau", "texteCurreUR", "texteErregour", "texteErrenurs", "texteErreour", "texteErroUR", "texteErreeur", "texteCurrecur", "texteErrorrenur", "texteErregurs", "texteIrreour", "texteArreurs", "texteErreurred", "texteCurrecaur", "texteIrrour", "texteErreaser", "texteErpreur", "texteErrituries", "texteErrenure", "texteErrur", "texteErroaur", "texteErbreour", "texteErpreurred", "texteErrenur", "texteErrourred", "texteErpreaur", "texteErritur", "texteErrenau", "texteErruuries", "texteErrecour", "texteCurreaur", "texteArrenour", "texteErrecurred", "texteErreeour", "texteErrorreau", "texteArrenur", "texteErrecur", "texteArreour", "texteErruour", "texteErrorrenour", "texteErrenour", "texteArreur", "texteCurrecUR", "texteErrorreuries", "texteErrour", "texteArreure", "texteErreeau", "texteArrenurs", "texteIrrur"], "numErreur": ["numErrenurs", "numErrecur", "numSerreUR", "numErrecUR", "numErroeur", "numErreure", "numErroUR", "numErREur", "numEREurs", "numErreceur", "numErrenure", "numSerreure", "numSerreurs", "numEreur", "numErrours", "numErroure", "numErREeur", "numEreure", "numEreurs", "numErrenur", "numErREurs", "numSerrenure", "numEREur", "numEreeur", "numEREure", "numErreeur", "numSerreur", "numErrour", "numErreUR", "numSerrenur", "numErreurs", "numEREeur", "numErREure", "numSerrenurs", "numErrenUR", "numErrecure", "numErrecurs", "numSerrenUR"], "al": ["Al", "oper", "tal", " fal", "dal", "AL", "ral", "el", "ar", "pal", "hal", " AL", "val", " cal", "mal", " nil", " ab", "als", "all", "alist", "ali", " bell", " all", "cal", "back", "ale", "list", "il", " rel", "ul", " hal", "bal", "af", "l", " Al", "ala", "unal", " signal", "alf", "sal", "stal", "aler", "f", " ale", "alis", "alled", " ul"]}}
{"id1": "20267500", "id2": "13657103", "code1": "    public static AudioInputStream getWavFromURL(String urlstr) {\n        URL url;\n        AudioInputStream ais = null;\n        try {\n            url = new URL(urlstr);\n            URLConnection c = url.openConnection();\n            c.connect();\n            InputStream stream = c.getInputStream();\n            ais = new AudioInputStream(stream, playFormat, AudioSystem.NOT_SPECIFIED);\n            LOG.debug(\"[getWavFromURL]Getting audio from URL: {0}\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return ais;\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 0, "substitutes": {"getWavFromURL": ["getWavFromurl", "getWavefromUR", "getWavForUR", "getWavefromUrl", "getWavefromURL", "getWavFromUR", "getWavfromUrl", "getWaveFromUR", "getWavForUrl", "getWaveFromUrl", "getWaveFromurl", "getWavForurl", "getWavfromURL", "getWaveFromURL", "getWavfromurl", "getWavefromurl", "getWavFromUrl", "getWavForURL", "getWavfromUR"], "urlstr": ["fileStr", "httpStr", "urlStr", "lStr", "urlSTR", "lSTR", " urlStr", "httpstring", "filestring", "urlpath", "llstr", " urlpath", "urlstring", "filepath", "llSTR", "lstr", "lstring", "llStr", "filestr", "httpstr", " urlSTR", "httppath", "llstring", " urlstring"], "url": ["lc", "cl", "str", "ob", "e", "feed", "URL", "cur", "path", "log", "sl", "fl", "Url", "host", "oc", "string", "conn", "u", "li", "ls", "image", "build", "org", "ssl", "connection", "b", "ll", "www", "loc", "ur", "ul", "uri", "lr", "api", "resource", "http", "l", "page", "source", "file", "server", "ch", "coll", "f", "rl", "plug"], "ais": ["mos", "aaa", " ads", "ai", "audio", "ays", "bb", "ois", "ami", "aos", "rs", "ia", "ws", "xml", "oci", "ay", " tapes", " arra", "cci", "asi", "ls", "ahi", "waves", "ci", "ios", "sa", " sax", "ians", "acs", "ava", "avi", " au", " audi", " audio", "aa", "ds", "ae", "plays", "Audio", " ado", "is", "oi", "aus", "audi", "ac", "aud", "rss", " ain", "ss", "as", "gae", "au", "ait", "ras"], "c": ["cm", "bc", "cf", "cl", "mc", "lc", "client", "e", "C", "conn", "cr", "cp", "u", "cc", "ci", "m", "ct", "ec", "a", "connection", "cu", "b", "cs", "enc", "fc", "co", "cd", "dc", "api", "p", "http", "l", "channel", "ch", "cn", "coll", "pc", "con", "nc", "ac", "ctrl", "cb", "f", "cmp"], "stream": ["cm", "uc", "audio", "reader", "cache", "w", "output", "e", "feed", "zip", "io", "path", "engine", "sl", "input", "host", "string", "context", "u", "s", "Stream", "m", "connection", "b", "object", "video", "fc", "p", "uu", "h", "form", "l", "in", "data", "channel", "source", "server", "d", "src", "coll", "sw", "f"]}}
{"id1": "62362", "id2": "2009072", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "label": 0, "substitutes": {"convert": ["CONception", " deconversion", "Converted", "oconversion", "subversion", "CONverted", "unception", "subverting", "CONvert", "subverted", "unvert", "unverted", "Conception", "CONverting", " deconverting", "oconverted", "Conversion", "Converting", "CONversion", "oconvert", " deconverted", "conception", "converting", "subvert", "oconverting", "Convert", "conversion", "converted", "unversion", " deconvert"], "src": ["sys", "ource", "fp", "url", "sit", "prot", "st", "img", "reader", "gb", "tmp", "load", "cb", "proc", "scene", "path", "input", "filename", "string", "name", "obj", "s", "stream", "secure", "sth", "Source", "spec", "upload", "storage", "sel", "code", "username", "SourceFile", "ssl", "sb", "component", "Dest", "supp", "buf", "video", "sin", "attr", "back", "config", "loc", "slice", "inst", "sn", "uri", "resource", "rb", "feat", "rc", "href", "source", "fn", "sc", "file", "download", "ref", "RC", "gz", "dist", "req", "stage", "impl", "cpp", "rl", "ctx", "cmp"], "dest": ["disk", "test", "cont", "img", "bin", "tmp", "path", "target", "obj", "lib", "std", " dst", "Dest", "class", "dat", "orig", "null", "dc", "di", "source", "fn", "dir", "dist", " destination", "home", "txt", "temp"], "in": ["ins", "din", "reader", "IN", "login", "bin", "isin", "inc", "io", "ini", "val", "input", "In", "stream", "err", "doc", "inas", "t", "a", "i", "r", "ex", "n", "ps", "win", "inn", "inf", "pin", "is", "data", "source", "up", "file", "d", "pass", "as", "f"], "p": ["fp", "jp", "v", "pa", "tp", "bp", "e", "lp", "pre", "pm", "P", "py", "pr", "s", "cp", "c", "np", "m", "t", "j", "i", "r", "pe", "g", "b", "cop", "o", "ps", "per", "parser", "pd", "pg", "h", "wp", "l", "op", "pb", "d", "pc", "pp", "sp", "part", "f", "pi", "po"], "ds": ["posts", " DS", "eps", "dp", "ths", "vs", "els", "os", " ps", "dat", "ps", " sd", "pd", "uds", "data", "qs", "utils", "points", "rs", "services", "da", "groups", "db", "docs", "s", "ls", "hs", "words", "ys", "models", "cs", "ans", "di", "ld", "cons", "gs", "ins", "xs", "ges", "ts", "nas", "ks", "sts", "ded", "lines", "vals", "js", "ups", "plugins", "dates", "ants", "dds", "ss", "scripts", "tests", "ils", "ads", "sys", "Ds", "ays", "dl", "lp", "tools", "df", "ns", "styles", "dd", "gd", "des", "dos", "sync", " props", "dc", "parts", "dt", "obs", "dist", "amps", "d", "DS", "icks", "dm", "ipes", "bs"], "format": ["template", "atter", "url", "fp", "magic", "model", "path", "function", "plugin", "host", "pattern", "filename", "string", "nat", "language", "struct", "name", "prefix", "spec", "t", "type", "at", "Format", "class", "tag", "handler", "config", "layout", "sche", "table", "parser", "api", "version", "scale", "form", "feat", "fd", "data", "source", "file", "filter", "letter", "ant", "fn", "style", "act", "frame", "unit", "part", "record", "f"], "hasPixelData": ["hasByteData", "showsPixelDATA", "hasPictureSize", "haspixelSize", " hasPixelSize", " hasPixeldata", "showsByteData", "showsByteStyle", "showsBytedata", "showsPixeldata", "hasPixelSize", "hasPicturedata", "showsPixelStyle", "hasByteSize", "hasPixelDATA", "hasPictureData", "hasPixeldata", "hasByteStyle", "haspixelData", "showsByteDATA", "haspixeldata", "hasPixelStyle", "hasBytedata", "showsPixelData", "hasByteDATA"], "inflate": ["inflace", "invenATE", "Inflation", "inFlate", "inflating", "infolode", "insvenate", "inFlation", "insvenATE", "invenode", "insvenating", "inflated", "Inflated", "inadequode", "inadequate", "inffation", "invenate", "insflate", "inflATE", "Inflate", "infloated", "inFlated", "infface", "InFlate", "insflATE", "Inflace", "InFlace", "inadequATE", "insflating", "inFlace", "infloate", "InFlation", "infloation", "insvenode", "inflode", "infolATE", "infloace", "inffate", "infolate", "inflation", "invenating", "inadequating", "InFlated", "insflode", "infolating", "inffated"], "pxlen": ["mxlen", "pxsize", "mxdata", "fxlen", "pgLen", "mxcount", "pgl", "fxden", "pxdata", "fxl", "axlon", "pxl", "pxlength", "pxlon", "pnglength", "xpsize", "pplen", "mxsize", "txlon", "axln", "pclin", "camlen", "pxLen", "camdata", "fxLen", "pxden", "pglen", "pxcount", "pxpos", "fxpos", "pclen", "txlen", "pxln", "pxlin", "campos", "txln", "fxdata", "pclon", "camln", "txlin", "xplen", "xplength", "fxln", "axlin", "ppden", "mxlength", "ppl", "pgden", "pnglen", "ppLen", "pngsize", "mxpos", "pngcount", "axlen", "xpcount", "mxln", "pcln"], "out": ["sys", "v", "error", "OUT", "outs", "cache", "gen", "re", "output", "io", "log", "session", "conn", "obj", "state", "lock", "err", "Out", "step", "lib", "user", "again", "parent", "co", "query", "list", "pad", "post", "copy", "point", "store", "cli", "line", "work", "up", "server", "page", "dump", "group", "inter"]}}
{"id1": "14450108", "id2": "22035737", "code1": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "code2": "    private static void loadMappings(Configuration cfg) {\n        try {\n            Enumeration en = LoadingUtils.getResources(MAPPINGS_FILE);\n            while (en.hasMoreElements()) {\n                URL url = (URL) en.nextElement();\n                logger.info(\"Found mapping module \" + url.toExternalForm());\n                InputStream inputStream = null;\n                try {\n                    inputStream = url.openStream();\n                    HibConfiguration hm = loadModuleMappings(inputStream);\n                    configureModuleMappings(cfg, hm.getSessionFactory());\n                } catch (IOException e) {\n                    logger.warn(\"Could not load mappings file \\\"\" + url.toExternalForm() + \"\\\"\", e);\n                } catch (JAXBException e) {\n                    logger.warn(\"Unable to instantiate JAXBContext \", e);\n                } finally {\n                    try {\n                        if (inputStream != null) inputStream.close();\n                    } catch (IOException e) {\n                        logger.debug(e);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            logger.warn(\"Could not find any mappings file hibernate.mappings.xml\", e);\n        }\n    }\n", "label": 0, "substitutes": {"connect": ["exec", "bind", "client", "collect", "Connect", "direct", "login", "port", "feed", " Connect", "sign", "request", "log", "boot", "touch", "patch", "start", "conn", "session", "contact", "host", "construct", "event", " disconnect", "connection", "config", "sync", "socket", "stop", "close", "access", "init", "download", "create", "con", "open", "control", "select", "connected", "run"], "ftpe": ["fxp", " ftple", "fxpc", "wdple", "ctpc", " ftse", "fxpe", "ftper", " ftpc", "wdpe", "ctper", "aftp", "ctpe", "ftps", "ftpa", " ftPE", "ptper", "ctpa", " ftper", "gtpe", "aftPE", "ptp", "aftpe", "ftse", " ftps", "ctse", "wdp", "gtps", " ftpa", "ptpe", "fxse", "ctp", "ftple", "gtp", "wdPE", "ptpa", "ftpc", "ctps", "gtpa", "aftple", "ftPE"], "ftp": ["copp", "aftpr", " fth", "afth", "bbps", "coppe", "iftpoint", "ctpe", "ftpage", "htpr", "notport", "notc", "aftpe", "octp", " ftm", "lfp", " ftnp", "rtb", "aftpc", " ftpa", " ftb", "aftps", "ftm", "ctp", "rtp", "ufpc", "bbpe", "iptps", "ftpc", "ptport", "pullP", "ctpoint", "htpc", "afttp", "iptm", "aftg", "htpe", "ufp", "ctpc", " fto", "fth", " ftcp", "ftpr", "ftb", " ftper", "gtpe", "ftP", "ftpo", "notpe", " ftpoint", "octc", "coppc", "ottpage", "copb", "pullb", "pullpe", "ftpi", "ctP", "notp", "rttp", "ctper", "ctg", "hto", "ufcp", "ufper", "ftper", "gtpi", "ftc", "ftport", "aftp", "ottp", "ctpage", "iftb", "aftcp", " ftpo", " ftping", "ctc", "ptc", "ptp", "afto", "cttp", "pullp", "ftcp", "ctcp", "ottb", " ftc", "iftp", "ftpoint", "htpi", "octps", " ftg", "ftnp", "ftg", "coppage", "fto", "aftpo", "ftping", " ftpr", "rtcp", "ctps", "rtc", "ktp", "lfping", "aftpa", "ctnp", "ifttp", "aftc", "fttp", " ftpc", " fttp", "aftnp", "octpe", "htp", "gtpc", "ftps", "ftpa", "kth", " ftP", "coppi", "ktpa", "bbm", " ftps", "ptpe", "aftping", "ottpe", "rtnp", "bbp", "ktpe", "gtp", "iptp", "iptpe", "ctb", "lfpe", " ftport", "lfpo"], "path": ["test", "port", "folder", "session", "location", "name", "Path", "cmd", "prefix", "link", "c", "method", "root", "route", "directory", "text", "parent", "config", "uri", "data", "entry", "file", "dir", "pass", "cat", "home", "response", "temp"], "currentDir": ["resultDir", "CurrentDirectory", "activeDb", "reportedFolder", "currentdir", "currentJar", "localDir", "localDIR", " currentDb", "reportedDirectory", "resultDirectory", "reportedDIR", "CurrentJar", "currentDirectory", "currentDb", "reporteddir", "localJar", "Currentdir", "activeDirectory", "currentFolder", "activeFolder", "reportedDir", "reportedDb", "activeJar", "localDirectory", "CurrentDIR", "activeDir", "resultdir", " currentDirectory", "activeDIR", "resultDIR", "currentDIR", "CurrentDir", " currentFolder"], "reply": ["address", "result", "base", "error", "job", "grade", "status", "follow", "answer", "force", "proxy", "command", "rr", "request", "vote", "state", "ret", "lock", "next", "write", "len", "prefix", "code", "respond", "reason", "repl", "info", "connection", "route", "Reply", "ignore", "join", "query", "sync", "ply", "message", "buffer", "service", "fee", "dy", "line", "continue", "data", "resp", "server", "entry", "ry", "cause", "article", "req", " replies", "comment", "response"]}}
{"id1": "19549489", "id2": "9033641", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public void testHttpsConnection_Not_Found_Response() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            try {\n                doInteraction(connection, ss, NOT_FOUND_CODE);\n                fail(\"Expected exception was not thrown.\");\n            } catch (FileNotFoundException e) {\n                if (DO_LOG) {\n                    System.out.println(\"Expected exception was thrown: \" + e.getMessage());\n                }\n            }\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"copy": [" copying", "delete", "paste", "transfer", "zip", "io", "Copy", " copied", "Transfer", "write", "upload", "Cop", "all", "cop", "sync", "p", " transfer", " copies", "source", "move", "file", "download", "create", " move", "split", " Copy", "clone"], "sourceFile": ["sourceFiles", "resourceFile", "searchFilename", "resourcefile", " sourceFiles", " sourceFILE", "resourceDirectory", "servicefile", "sourceFILE", "resourceFiles", "sourceFilename", " sourceDirectory", "SourceDirectory", " sourcefile", "siteFiles", "SourceFile", "searchfile", "sourcefile", "siteDirectory", "serviceFiles", "serviceFilename", "SourceFILE", "sourceDirectory", "serviceFile", " sourceFilename", "Sourcefile", "searchFiles", "siteFILE", "siteFile", "SourceFiles", "searchFile"], "destinationFile": ["destinatorImage", "destinationImage", "destinatedImage", "destinatedFiles", "destinatorDir", "DestinationDir", "destinationFiles", "DestinationFiles", "destinatedFile", "distinatedFiles", "DestinationFile", "distinationImage", "destationFiles", "destationfile", "destinatorFile", "distinatedFile", "distinatedDirectory", "distinationDirectory", "destinationDir", "destinatedDir", "destationDir", "destinatorFiles", "destationImage", "DestinatorDir", "distinatedImage", "destinatedfile", "destationDirectory", "destationFile", "distinationFiles", "destinatedDirectory", "destinatorDirectory", "destinationfile", "DestinatorFiles", "distinationFile", "destinationDirectory", "DestinatorFile", "destinatorfile", "Destinatorfile", "Destinationfile"], "sourceFileChannel": ["sourceFilesChannel", "sourceLibraryChan", " sourceFilesService", "targetFileChan", "sourceDirchannel", "sourceLineSocket", "sourceDirChan", "targetLibrarySocket", "sourceFileSocket", "sourceFileContext", "sourceFileClient", "ourceStreamChannel", "sourceStreamContext", "sourceFunctionConnection", " sourceFilesConnection", "targetLibraryChan", " sourceFileContext", "sourceDirectorySocket", "sourceFunctionService", " sourceFileService", "targetFileClient", "sourceFileConnection", "sourceDirectoryChan", "sourceLibraryChannel", "sourceStreamConnection", " sourceFilesChannel", "sourceLinechannel", "sourceLibraryClient", "sourceFilesContext", "sourceFileStream", "targetLibraryChannel", "sourceStreamStream", "sourceFunctionChannel", "ourceStreamStream", "ourceFileChannel", "sourceLineChannel", "sourceStreamService", "targetFileSocket", "ourceFileChan", "sourceFilesService", "sourceFileChan", "sourceStreamchannel", "sourceStreamChan", "sourceFilesConnection", "targetLibraryClient", "sourceDirectoryClient", "targetFileChannel", "sourceDirStream", "ourceFilechannel", " sourceFilesContext", "sourceLineClient", "ourceStreamChan", "sourceLineChan", "sourceStreamChannel", "sourceLineStream", "sourceFunctionContext", "sourceFilechannel", "sourceDirChannel", "sourceDirectoryChannel", "ourceStreamchannel", "sourceFileService", " sourceFileConnection", "sourceLibrarySocket", "ourceFileStream"], "destinationFileChannel": ["destinationFilesConnection", "destinatorFileConnection", "destinationFilesChannel", "destinationLineHandler", "destinationIOCache", "destinationFilesHandler", "destinationFileService", "destinationDirectoryChannel", "destinationLineChan", "destinationLineClient", "destinationDirectoryClient", "destinationIOClient", "destinationFilesService", "destinatorFileCache", "destinationDirectoryChan", "destinatorFileHandler", "destinatorFilesHandler", "destinationDirectoryConnection", "destinationFilesChan", "destinatorFilesChan", "destinationFileClient", "destinationLineConnection", "destinationIOChannel", "destinationFilesCache", "destinatorFileChan", "destinationDirectoryHandler", "destinationLineChannel", "destinationDirectoryService", "destinatorFileClient", "destinatorFilesConnection", "destinationIOService", "destinatorFilesService", "destinationLineService", "destinationFileConnection", "destinatorFileService", "destinatorFilesChannel", "destinationFileChan", "destinationFileCache", "destinatorFileChannel", "destinationFileHandler", "destinatorFilesCache", "destinationFilesClient", "destinationDirectoryCache", "destinatorFilesClient"]}}
{"id1": "14168494", "id2": "23611770", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferfile", " copiedFile", "transferClass", "copyClass", "transferFiles", " copyClass", " copyfile", " copiedFiles", "transferFile", "copyfile", " copiedClass", " copiedfile", " copyFiles"], "dest": ["st", "sup", "output", "tmp", "transfer", "comb", "path", "target", "name", "out", "obj", "true", "this", "Dest", "class", "desc", "orig", "null", "loc", "wb", "done", "resource", "source", "data", "file", "destroy", "dir", "dist", "d", " destination", "later", "txt", " Dest", "temp"], "src": ["url", "sit", "master", "st", "img", "sup", "gb", "bin", "tmp", "sub", "sl", "target", "filename", "s", "stream", "upload", "storage", "sel", "ssl", "sb", "sq", "Dest", "sin", "config", "loc", "sync", "slice", "inst", "ds", "rob", "rb", "copy", "rc", "source", "sc", "file", "dist", "download", "split", "cb"], "srcChannel": ["srcConnection", " srcCh", "rcButton", "rcCh", " srcSection", " srcConnection", "srcStream", "srcButton", "rcStream", "rcConnection", " srcchannel", "inputSection", "sourceChan", "srcchannel", "sourceButton", "sourceChannel", "distChannel", "destChannel", "inputConnection", "inputchannel", "rcChannel", "destchannel", " srcButton", "srcChan", "destConnection", "rcSection", "srcCh", "distChan", "distStream", " srcStream", "srcSection", "distCh", "rcchannel", "sourcechannel", "inputChannel", " srcChan", "destChan", "rcChan"], "dstChannel": ["dstConnection", "dsrcchannel", "DstVideo", "dstVideo", "dDestchannel", " dstChan", "drdContext", " dstschannel", " drdChannel", "dstStream", " dstsChannel", "ddestConnection", "drdchannel", " drdContext", "ddestChannel", "dstsStream", "DstChannel", "Ddestchannel", " dstStream", "DdestVideo", " drdchannel", "dstsConnection", "dstschannel", " dstConnection", "ddestchannel", "drcVideo", " dstsStream", "dstchannel", "drdChan", " drdChan", "DdestChannel", "ddestVideo", "dsrcVideo", "ddestStream", "ddestChan", "dstContext", "drdChannel", "drcchannel", "Dstchannel", "dsrcChannel", " dstContext", "dDestChannel", " dstsConnection", "drcContext", "drcChan", "dDestStream", "dstChan", " dstchannel", "dDestConnection", "ddestContext", "drcChannel", "dstsChannel"]}}
{"id1": "884867", "id2": "6501291", "code1": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"zipname": ["zipcache", "lockname", "zsize", "clipName", "projectcache", " zipsize", "zipfile", " zipName", "gzsize", "gzName", "ziproot", "projectno", "filename", "gzfile", "fileroot", "zipsize", " zipfile", "zName", "clipcache", "clipno", "clipname", "zname", "gzname", "filefile", "lockno", " ziproot", "projectname", "zipName", "zroot", "lockcache", "zfile", "fileName", "lockName", "zipno", "projectName"], "zipout": ["zipin", "zipcontainer", "zipserver", "zipcache", "foldername", " zipin", " zipserver", "zipfile", "zenout", "copfile", "clipoutput", "zenserver", "zin", "zgen", "zengen", " zipoutput", "clipin", " zipcontainer", " zipgen", " zipfile", "clipcache", "folderout", "zserver", "copin", "clipout", "zname", "zipgen", "copout", "zenin", "zoutput", "zipoutput", "folderin", "zcache", "zout", "copname", "foldercontainer", " zipcache", "zcontainer", "zfile"], "out": ["exec", "url", "base", "error", "OUT", "client", "outs", "cache", "gen", "w", "project", "output", "bin", "window", "pre", "io", "inc", "exp", "raw", "term", "log", "name", "conn", "dot", "obj", "word", "lock", "image", "err", "doc", "write", "prefix", "Out", "code", "lib", "writer", "print", "user", "b", "ex", "n", "again", "parent", "o", "query", "co", "list", "diff", "post", "outer", "p", "plus", "flush", "point", "copy", "key", "page", "line", "pool", "up", "file", "dump", "group", "f", "msg"], "buffer": ["Buffer", "position", "url", "result", "base", "header", "uffer", "reader", "cache", "bb", "transfer", "comment", "feed", "row", "input", "border", "sequence", "binary", "offset", "seed", "queue", "image", "read", "layer", "reference", "batch", "b", "shape", "buf", "null", "number", "slice", "block", "padding", "iter", "array", "resource", "wave", "bytes", "stack", "data", "channel", "file", "source", "limit", "size", "buff"], "in": ["serv", "url", "gin", "ins", "din", "reader", "IN", "re", "login", "bin", "id", "inc", "ini", "input", "ic", "In", "conn", "inner", "image", "c", "err", "a", "i", "r", "b", "ex", "again", "rec", "diff", "nin", "win", "fr", "inn", "pin", "is", "l", "lin", "up", "init", "rin", "pass", "con", "as", "f"], "length": ["position", "url", "level", "ob", "left", "view", "force", "id", "load", "feed", "old", "total", "index", "row", "sequence", "present", "end", "string", "range", "tail", "offset", "lock", "len", "section", "angle", "character", "code", "build", "type", "Length", "component", "count", "duration", "class", "ength", "number", "shape", "body", "join", "pe", "ph", "pull", "loc", "slice", "ok", "key", "point", "l", "line", "last", "append", "width", "style", "limit", "core", "full", "part", "size", "f", "partial"]}}
{"id1": "17475530", "id2": "3024992", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinkstoPicture", "testAddLinkOfImage", "testAddLinktoImage", "testAddLinkFromLink", "testAddLinkOfLink", "testAddLinkToPicture", "testAddLinktoFile", "testAddLinkFromPicture", "testAddLinktoPicture", "testAddLinkOfFile", "testAddLinkstoLink", "testAddLinktoLink", "testAddLinkOfPicture", "testAddLinkToFile", "testAddLinkFromImage", "testAddLinksToPicture", "testAddLinkstoImage", "testAddLinksToLink", "testAddLinkstoFile", "testAddLinksToFile", "testAddLinkToLink", "testAddLinkFromFile", "testAddLinksToImage"], "in": ["exec", "serv", "url", "gin", "ins", "din", "reader", "IN", "token", "login", "el", "bin", "id", "exp", "isin", "inc", "path", "xml", "ini", "index", "input", "val", "out", "In", "conn", "name", "stream", "image", "err", "doc", "ax", "m", "or", "ssl", "at", "i", "r", "connection", "ex", "n", "again", "with", "diff", "socket", "nin", "win", "uri", "resource", "inn", "version", "min", "pin", "get", "copy", "is", "cin", "data", "source", "file", "work", "rin", "pass", "con", "ac", "as", "f"]}}
{"id1": "4468255", "id2": "18974466", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"copy": ["share", "save", "delete", "parse", "paste", "rm", "transfer", "zip", "Copy", "load", "put", "replace", "log", "cp", "write", "link", " cp", "info", "cop", "ignore", "sync", "update", "clip", "get", "process", "move", "file", "download", "create", "dump", "split", "cat", "ssh", "clone", "opy"], "from": ["url", "base", "client", "vol", "left", "e", "id", "zip", "io", "old", "path", "one", " form", "of", "log", "er", "start", "name", "context", "string", "stream", "original", "range", "c", "missing", "this", "link", "os", "normal", "code", " the", "or", "at", "connection", "html", "user", "ce", "parent", "empty", "so", "o", "with", "back", "config", "without", "the", "resource", "add", "by", "form", "http", "ate", "source", "data", "file", "before", "dir", "entry", "From", "se", " file", "part", "open", "f"], "to": ["disk", "eto", "cache", "son", "one", "path", "name", "comp", "os", "null", "front", "flo", "p", "jo", "too", "data", "file", "process", "sp", "as", "size", "client", "stat", "token", "db", "x", "TO", "target", "on", "termin", "yet", "database", "or", "tom", "pe", "user", "To", "so", "o", "back", "dis", "by", "http", "template", "two", "de", "base", "system", "io", "not", "but", "auto", "top", "no", "toc", "all", "t", "parent", "socket", "office", "resource", "me", "source", "dir", "temp", "output", "site", "load", "storage", "connection", "root", "sync", "plus", "line", "se", "tto", "about", "po"], "result": ["ure", "test", "url", "error", "ver", "cache", "status", "follow", "allow", "found", "use", "comment", "br", "current", "valid", "force", "sign", "term", "replace", "cur", "Result", "arr", "default", "function", "val", "mask", "res", "true", "length", "mer", "ret", "effect", "lock", "err", "success", "results", "compl", "card", "event", "info", "r", "method", "count", "report", "future", "diff", "ok", "var", "date", "plus", "search", "math", "rc", "continue", "match", "work", "data", "source", "accept", "up", "ult", "entry", "member", "pass", "die", "fail", "part", "sum"], "subFiles": ["subTokens", "newPages", "singfiles", "subParts", " subDir", "subFs", "Subfiles", " subParents", "newsFiles", " subPages", "newsParts", "newFile", "subPages", " subFile", "SubPages", "partFs", "newsfiles", "newParts", "singFs", "partFiles", "subContents", "ubFiles", "subFile", "partParents", "ubPages", "singFiles", " subFs", "newfiles", "subfiles", "SubContents", "subParents", "subDir", "SubParts", "ubContents", "ubDir", "ubfiles", "ubFile", " subTokens", "newsTokens", " subParts", "SubFiles", " subfiles", "singParents", "newFiles", "partfiles", "SubTokens", "SubFile", " subContents"], "i": ["v", "k", "iv", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "q", "name", "li", "u", "ui", "hi", "s", "inner", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "j", "ori", "ie", "a", "b", "n", "o", "bi", "slice", "ri", "uri", "p", "key", "it", "h", "ix", "is", "gi", "di", "oi", "l", "d", "f", "pi"], "newDir": ["nowDIR", " newD", "subQu", "NewJar", "newJar", "NewFolder", "newFile", " newDirectory", " newFolder", "oldDIR", "NewDir", "NewDirectory", "newDirectory", " newJar", "nextQu", " newDIR", "nowDirectory", "subFile", "NewFile", "subFolder", " newFile", "nextFolder", "subDirectory", "subD", "oldFolder", "subDir", "nextDirectory", "oldDir", "oldFile", "nowDir", "newDIR", "newFolder", "nextDir", "oldDirectory", "nextFile", "subJar", "nowFolder", "newQu", "newD", " newQu", "NewD"], "in": ["url", "gin", "ins", "thin", "reader", "din", "IN", "login", "re", "bin", "e", "id", "isin", "inc", "ini", "index", "input", "In", "conn", "on", "inner", "lock", "c", "image", "this", "err", "m", "a", "r", "ie", "b", "ex", "again", "o", "pull", "socket", "diff", "nin", "win", "inn", "min", "pin", "it", "is", "l", "lin", "data", "file", "up", "init", "cin", "source", "con", "part", "serv", "f"], "out": ["net", "exec", "serv", "base", "img", "OUT", "client", "outs", "cy", "w", "call", "output", "bin", "exp", "io", "ou", "inc", "one", "log", "conn", "ext", "name", "inner", "obj", "word", "on", "write", "err", "off", "c", "lock", "Out", "lib", "all", "at", "writer", "b", "ex", "n", "again", "o", "with", "co", "sync", "socket", "post", "line", "op", "file", "up", "ch", "cat", "sum", "can"], "fileLength": ["lineName", "Filelength", " fileSize", "linelength", "pageLength", "pagelength", " fileLen", "lineSize", "pageName", "baseLen", "lineLength", "FileLength", " fileName", "filelength", "fileLen", " filelength", "pageSize", "baseLength", "baseSize", "FileSize", "baselength", "fileSize", "fileName", "FileLen"], "charBuff": ["stringBuff", "charBuffer", "pairBuff", "pairMatrix", "charMatrix", "stringBuffer", "stringMatrix", " charMatrix", " charBuffer", "pairBuffer"], "len": ["lit", "bin", "id", "Len", "val", "fl", "start", "name", "li", "fin", "ln", " pos", "en", "n", "nt", "iter", "lf", "l", "line", "pos", "ni", " split", "split", "part", " Len", "cmp", "rev"], "oneChar": ["singlechar", "singleCor", " oneCar", "singleCharacter", "oneCor", "nextCor", "eachCharacter", "fourchar", "eachchar", " oneCh", "onechar", "nextCar", "singleCh", "fourChar", "singleCar", " oneCharacter", "zeroChar", "singleChar", "oneCh", " onechar", " oneCor", "zerochar", "eachChar", "eachCor", "fourCharacter", "zeroCharacter", "nextChar", "oneCar", "fourCor", "oneCharacter", "nextCh", "zeroCor"]}}
{"id1": "22993368", "id2": "13783549", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2String", "decodeStringToFile", "decodeFile2Stream", "decodeFile2Files", "decodeFileFromFiles", "decodeStringToStream", "decodeFileAsFiles", "decodeFileAsString", "decodeStringToFiles", "decodeFileFromFile", "decodeFileToStream", "decodeString2File", "decodeFileToString", "decodeFileFromString", "decodeFileFromStream", "decodeFile2String", "decodeFileAsFile", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeFile2File", "decodeString2Files", "decodeFileAsStream"], "infile": ["Inbase", "Infile", "infiles", "InFile", " inFile", " instream", "inFile", "Instream", "minstream", "inputfiles", "infilename", "inbase", "outfilename", "minfile", " infilename", "outfiles", "minbase", "inputfp", "infp", " infiles", "inputfilename", " infp", "outfp", "instream", " inbase", "inputfile", "minFile"], "outfile": ["outputfilename", "outputpath", "outpath", "inputdatabase", "infolder", "inputFile", " outpath", "outdatabase", "inFile", "outFile", "outputdatabase", "outfolder", " outfolder", "infilename", "outfilename", " outFile", "outputfile", "inputpath", " outfilename", "outputfolder", " outdatabase", "outputFile", "inputfile"], "in": ["gin", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "ini", "input", "ic", "In", "s", "conn", "inner", "err", "inas", "m", "a", "i", "r", "b", "again", "sin", "socket", "nin", "win", "inn", "min", "pin", "is", "into", "cin", "data", "source", "lin", "init", "inside", "rin", "pass", "ac", "con", "as"], "out": ["net", "exec", "base", "error", "OUT", "client", "outs", "cache", "job", "output", "bin", "ou", "io", "inc", "one", "log", "session", "conn", "obj", "In", "inner", "name", "to", "image", "write", "err", "off", "no", "Out", "lib", "or", "writer", "ex", "parent", "again", "o", "co", "socket", "sync", "post", "outer", "timeout", "point", "copy", "line", "channel", "file", "up", "work", "pass", "home", "exit"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bb", "bin", "transfer", "feed", "raw", "input", "border", "length", "seed", "binary", "offset", "queue", "write", "layer", "type", "reference", "batch", "count", "b", "null", "buf", "slice", "padding", "iter", "bytes", "wave", "flush", "data", "channel", "server", "source", "limit", "value", "split", "size", "buff"], "read": ["exec", " skip", " Read", "ip", "reader", "send", " copy", "parse", "lex", "allow", "use", "id", "feed", "io", "load", "inc", "raw", "current", "_", "check", "x", " count", "connect", "seek", "length", "ind", "play", "start", "end", "write", "next", "len", "i", "count", "ride", "wait", "r", "n", "fill", "find", "Read", "slice", "sync", "READ", "tell", " write", "ad", "iter", "add", "get", "copy", "work", "sleep", "se", "limit", "reads", "pass", "reading", "size", "select", "f", "run"], "success": ["complete", "first", "result", "positive", "error", "cess", " succ", "primary", "status", "follow", "ccess", "growth", "flash", "fast", "right", "Success", "valid", "model", "func", "path", "default", " succeed", " Success", "true", "winner", "rolled", "results", "xx", "failed", "danger", "construct", " successful", "method", "null", "again", "ceed", "good", "message", "done", "rolling", "successfully", "content", "continue", "data", "warning", "successful", "pass", "roll", "initial", "better", "fail", "value", "open", "comment", "response"]}}
{"id1": "14473781", "id2": "10158738", "code1": "        @Override\n        protected String doInBackground(Void... params) {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpContext localContext = new BasicHttpContext();\n            HttpPost httpPost = new HttpPost(urlFormated);\n            try {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n                for (int index = 0; index < POSTparamList.size(); index++) {\n                    if (POSTparamList.get(index).getName().equalsIgnoreCase(\"image\")) {\n                        entity.addPart(POSTparamList.get(index).getName(), new FileBody(new File(POSTparamList.get(index).getValue())));\n                    } else {\n                        entity.addPart(POSTparamList.get(index).getName(), new StringBody(POSTparamList.get(index).getValue()));\n                    }\n                }\n                httpPost.setEntity(entity);\n                HttpResponse response = httpClient.execute(httpPost, localContext);\n                return processAnswer(response);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doUsingContext", "doOnContext", " doUsingBackground", " doWithinBuffer", "doOnNode", " doWithinBackground", " doInContext", " doOnBuffer", " doUsingNode", " doOnBackground", "doInNode", " doInBuffer", " doWithinNode", " doOnContext", "doInBuffer", " doWithinContext", " doUsingBuffer", " doOnNode", "doOnBuffer", "doInContext", "doOnBackground", " doInNode"], "params": ["url", "ip", "parse", "Param", "Parameters", "param", "Par", "resources", "properties", "type", "i", "options", "par", "handler", "ps", "query", "config", "list", "uri", "array", "api", "page", "ams", "data", "instance", "json", "pi"], "httpClient": ["ttpClient", "httpsCall", "HttpCall", "HttpCase", "ttpProxy", " httpCall", "HttpClient", " httpProxy", "httpsPost", "HttpContext", "ttpContext", "httpsCase", "httpProxy", "httpsClient", " httpCase", "httpCase", "ttpPost", "httpCall", "HttpPost", " httpContext", "HttpProxy", "httpContext"], "localContext": ["localConfig", "Localcontext", "localPort", "LocalContext", "locContext", "httpData", "LocalClient", "globalClient", "LocalPort", " localcontext", "locConfig", " localConfig", "globalcontext", "localClient", "localcontext", "globalPort", " localData", "globalContext", "localData", "httpcontext", "loccontext", " localClient", "httpContext", " localPort", "locData", "httpConfig"], "httpPost": [" httpPOST", "cachePOST", "httpsRequest", " httppost", "ttppost", "ttpCreate", "Httppost", "phppost", "httpCreate", "requestPost", " httpRequest", "httpPOST", "httpRequest", "httpsPost", "cachePatch", "cacheRequest", "httpCopy", "cachePost", "httpsPOST", " httpCopy", "ttpCopy", "phpPOST", "ttpPost", "requestCopy", "HttpCreate", "phpCopy", "HttpPost", "httpsPatch", "httpPatch", "requestPOST", "phpPost", "httppost", " httpPatch", "HttpCopy", " httpCreate", "requestpost"], "entity": ["oe", "address", "url", "base", "ity", "el", "e", "model", "xml", "environment", "issue", "node", "image", "eme", "event", "component", "element", "connection", "om", "pe", "ent", "object", "body", "enc", "per", "post", "service", "api", "resource", "p", "person", "media", "content", "document", "translation", "http", "Entity", "line", "page", "entry", "article", "file", "channel", "email", "server", "create", "coll", "instance", "json", "collection", "part", "activity", "ce"], "index": ["address", "column", "primary", "id", "inc", "pattern", "length", "name", "section", "operation", "i", "active", "route", "date", "data", "letter", "loop", "coll", "value", "part", "size", "f", "author", "left", "old", "x", "pointer", "string", "word", "action", "prefix", "success", "axis", "number", "object", "Index", "key", "page", "in", "num", "initial", "label", "position", "argument", "all", "again", "slice", "list", "alpha", "condition", "search", "pos", "level", "view", "site", "request", "default", "ind", "offset", "image", "step", "expression", "type", "element", "connection", "batch", "edit", "diff", "weight", "update", "version", "other", "width", "second"], "response": ["v", "result", "offer", "client", "status", "output", "answer", "e", "feed", "model", "Response", "request", "image", "respond", "connection", "method", "i", "application", "object", "body", "handler", "post", "message", "array", "service", "resource", "api", "related", "respons", "http", "page", "data", "resp", "server", "value", "reply", "json", "collection", "onse"]}}
{"id1": "17627195", "id2": "7468827", "code1": "    public Document getContentAsDocument() {\n        synchronized (this.url) {\n            URLConnection connection = this.url.openConnection();\n            if (doReload(connection)) {\n                InputSource inputSource = new InputSource(connection.getInputStream());\n                DocumentBuilderFactory factory = new DocumentBuilderFactoryImpl();\n                this.document = factory.newDocumentBuilder().parse(inputSource);\n            }\n            return this.document;\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"getContentAsDocument": ["getContentOfString", "getConnectionAsString", "getConnectionasDoc", "getContentAsString", "getContentasDocument", "getContentOfDocument", "getConnectionasDocument", "getContentAsDocuments", "getConnectionAsDocument", "getContentOfDoc", "getContentAsDoc", "getContentasDocuments", "getContentInDoc", "getContentOfDocuments", "getConnectionasString", "getContentInString", "getConnectionasDocuments", "getContentInDocument", "getContentasString", "getContentInDocuments", "getConnectionAsDoc", "getConnectionAsDocuments", "getContentasDoc"], "connection": ["url", "result", "lc", "client", "reader", "builder", "connected", "which", "io", "proxy", "db", "function", "connect", "session", "pointer", "conn", "context", "driver", "section", "image", "c", "this", "database", "character", "communication", "Connection", "application", "directory", "handler", "config", "loc", "socket", "service", "condition", "ion", "source", "channel", "server", "closed", "instance", "con", "collection", "open", "ctx", "response", "relation"], "inputSource": [" inputReader", "InputConnection", " inputConnection", "inputPoint", "InputSource", "sourceSource", " inputStream", "sourceStream", "imageSource", " inputPoint", "dataSource", "inputConnection", "inputStream", " inputProvider", "dataStream", "imageConnection", "imageStream", "inputReader", "inputProvider", "dataProvider", "sourceProvider", "dataPoint", "InputReader", "sourcePoint", "InputStream", "imageReader"], "factory": ["cfuture", "confFactory", "Factory", "cfence", "found", "flesh", "confuture", " fii", " fFactory", "fence", "facactory", "confactory", "FFactory", "confound", "fFactory", "confence", "fii", "future", "facuture", "confii", "facound", "cfound", "conflesh", "facence", "cfactory", "Fii", " flesh", "Flesh"], "document": ["url", "result", "master", "cache", "project", "proxy", "model", "xml", "docs", "design", "node", "image", "doc", "database", "entity", "layer", "element", "html", "root", "application", "library", "object", "parent", "layout", "graph", "Document", "message", "media", "version", "content", "page", "source", "server", "director", "collection", "record", "response"]}}
{"id1": "16851955", "id2": "18238468", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "label": 1, "substitutes": {"testTrainingBackprop": ["testTrainBACKpointer", "testTrainBACKprop", "testTrainBACKpressure", "testTrainBackprop", "testTrainingBackpointer", "testTrainingFrontdrop", "testTrainingBACKdrop", "testTrainingBackpressure", "testTrainingFrontpointer", "testTrainBackpressure", "testTrainingBackdrop", "testTrainBackpointer", "testTrainBackdrop", "testTrainingBACKprop", "testTrainBACKdrop", "testTrainingBACKpressure", "testTrainingFrontpressure", "testTrainingBACKpointer", "testTrainingFrontprop"], "temp": ["template", "test", "emp", "v", "fake", "base", "wrap", "cache", "clean", "save", "local", "output", "tmp", "zip", "current", "io", "model", "container", "cel", "path", "folder", "font", "input", "flat", "session", "out", "archive", "lock", "tem", "this", "pdf", "storage", "porary", "writer", "dat", "ex", "directory", "parent", "empty", "stable", "dest", "config", "pipe", "buffer", "mount", "form", "copy", "http", "data", "file", "Temp", "full", "txt", "f"], "layers": ["backs", "lobs", "liacks", "flasses", " libraries", "dlacks", "bayers", "lays", "gients", "players", "Lients", "lagers", "Lobs", "flanguages", " lients", "lores", "nlikes", "lacks", "languages", "placks", "gayers", "libraries", " lasses", "lowers", "slacks", " lacks", "licagers", "dlasks", "nlayers", " lasks", "slayers", "dlayers", "liibraries", "blayers", "slays", " lobs", "gobs", " lores", "Layers", " languages", " likes", "dlibraries", "planguages", "likes", "licayers", "licibraries", "dlanguages", "blanguages", " lowers", "nlagers", "lasks", " llements", "lasses", "bowers", "liores", "dlores", "licikes", " lagers", "blasses", "bays", "slowers", "bllements", "nlibraries", "liayers", "lients", "fllements", "flayers", "plasks", "llements", " lays"], "fann": ["fana", "xfanny", "fnn", "farn", "Fannon", "elfarn", "Fanny", "sfanny", "lann", "elfnn", "fain", "larn", "sfannon", "gnn", "gana", "Fann", "xfann", "fanny", "Fain", "xfannon", "sfain", "elfana", "fannon", "garn", "lana", "lnn", "xfain", "sfann", "elfann", "gann"], "trainer": ["Trayer", "stracker", "traainer", "Tracker", "tacer", "trarain", "Triner", "Trainer", "tacker", " tracker", "strayer", "striner", "racker", "Trrain", " train", "retacer", "tracker", "trayer", "retayer", " tracer", "stracer", "traacer", "retainer", "train", "tainer", "strainer", "Tracer", "trrain", "rain", "retiner", "rainer", "tracer", "triner", "strain", "racer", "traacker"], "desiredError": ["DesireError", "desciredFailure", "deservedError", "desiredEvent", "reservedSize", "desireSize", "designedEvent", "resiredEvent", "desciredProblem", "desiringFailure", "desirableSize", "deservedOrder", "desiredSize", "desiredOrder", "desireException", "reservedError", "designedSize", "desivedException", "desirableOrder", "desizedException", "descidedProblem", "designedOrder", "desirableError", "DesireException", "descirederror", "desizedError", "descidedError", "desizedSize", "deservedSize", "desireError", "DesiredSize", "resiredOrder", "deservedEvent", "descidederror", "desidedError", "desiredProblem", "reservedEvent", "desiredException", "desiringProblem", "desiringError", "reservedOrder", "DesiredException", "descidedFailure", "despectederror", "desiredFailure", "resiredSize", "desidedProblem", "despectedFailure", "desciredError", "desivedSize", "desirederror", "despectedProblem", "resiredError", "desivedError", "designedError", "desidederror", "desiringerror", "desirableEvent", "despectedError", "DesiredError", "DesireSize", "desidedFailure"], "mse": ["fSE", "Mte", "mce", "fge", "fmze", "gmse", " mze", "MSE", " mge", "mte", " mSE", "Mce", "fmte", " mce", "Mse", "fse", "fmse", "mSE", "gmce", "gmSE", "mge", "fmce", "Mge", "fce", "Mze", "mze", "gmge", " mte"]}}
{"id1": "2009072", "id2": "4389475", "code1": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "code2": "    @Override\n    public URLConnection openConnection(URL url) throws IOException {\n        if (!url.getProtocol().equals(\"file\")) {\n            String name = url.getFile();\n            File f = new File(cacheFolder, ((name.charAt(0) == '/') ? name.substring(1) : name).replace('/', File.separatorChar));\n            if (!f.exists()) {\n                File f2 = new File(f.getParentFile(), f.getName() + \"-not_found\");\n                if (!f2.exists()) {\n                    try {\n                        f.getParentFile().mkdirs();\n                        downloadFile(url, f);\n                    } catch (IOException e) {\n                        f.delete();\n                        throw e;\n                    }\n                }\n            }\n            return f.toURI().toURL().openConnection();\n        }\n        return super.openConnection(url);\n    }\n", "label": 0, "substitutes": {"openInput": ["createContent", "createInput", "openOutput", "getContent", "createResource", "getResource", "getOutput", "createOutput", "OpenOutput", "openContent", "openResource", "OpenInput", "getInput", "OpenContent", "OpenResource"], "path": ["template", "base", "PATH", "clean", "str", "id", "sign", "relative", "xml", "request", "index", "input", "node", "pattern", "pointer", "string", "name", "s", "obj", "Path", "word", "stream", "end", "context", "c", "prefix", "inner", "next", "image", "self", "method", "transform", "root", "route", "text", "object", "parent", "user", "enc", "list", "tree", "uri", "ath", "api", "key", "content", "plus", "form", "http", "data", "filter", "file", "ref", "value", "full", "part", "txt", "temp"], "len": ["v", "lc", "base", "str", "lp", "Len", "val", "fl", "sl", "length", "end", "li", "fin", "ln", "lon", "en", "count", "n", "span", "ll", "list", "iter", "lf", "l", "line", "lin", "pos", "limit", "split", "sp", "part", "size", "le"], "p": ["fp", "jp", "v", "ip", "pa", "tp", "ap", "lp", "pre", "P", "vp", "py", "s", "cp", "param", "u", "c", "np", "m", "t", "j", "i", "pe", "o", "ps", "api", "point", "l", "pb", "pc", "pp", "sp", "ep", "f", "pr", "po"], "url": ["base", "client", "ob", "feed", "URL", "ball", "sl", "fl", "Url", "host", "location", "string", "conn", "image", "link", "ssl", "connection", "html", "user", "b", "browser", "object", "www", "uri", "resource", "api", "http", "page", "l", "source", "file", "channel", "server", "open", "web", "blog", "f"], "result": ["air", "reader", "output", "tmp", "raw", "Result", "request", "val", "res", "obj", "stream", "ret", "err", "results", "this", "event", "ssl", "report", "r", "object", "message", "uri", "array", "resource", "buffer", "api", "content", "http", "page", "data", "match", "entry", "up", "source", "instance", "open", "response"]}}
{"id1": "7006052", "id2": "23370621", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copySourceFileTo", "copyFileFrom", " copyFileFile", "copyfileTo", "copyFileFile", " copyFilesTo", "copyFilesFrom", "copySourceFileFile", "copyFileInfo", "copyFilesInfo", "copySourceFileFrom", "copyFilesTo", " copyFilesFrom", " copyFileInfo", "copyfileInfo", "copyfileFrom", "copyfileFile", " copyFilesInfo", "copySourceFileInfo", " copyFileFrom", " copyFilesFile", "copyFilesFile"], "src": ["url", "img", "sup", "sub", "old", "path", "remote", "sl", "filename", "string", "s", "stream", "archive", "image", "upload", "sel", "code", "sb", "b", "js", "sin", "config", "slice", "loc", "sync", "uri", "resource", "inf", "rb", "rc", "href", "source", "fn", "file", "sc", "data", "txt", "rs"], "dest": ["test", "result", "img", "sup", "project", "delete", "output", "bin", "tmp", "comb", "sub", "folder", "default", "target", "filename", "flat", "secure", "name", "Dest", "des", "b", "orig", "desc", "const", "route", "loc", "wb", "done", "source", "data", "dir", "dist", " destination", "die", "later", "home", "opt", "txt", " Dest", "temp"], "destFile": ["destFiles", "targetFiles", "DestFiles", " destfile", "destDir", "Destfile", "targetDir", " destinationFile", "targetFile", " destinationDir", "DestFile", " destinationF", "targetfile", "destfile", " destFiles", " destinationFiles", "destF", " destF", "DestDir", " destDir", "DestF"], "in": ["url", "gin", "ins", "thin", "din", "reader", "IN", "login", "bin", "id", "inc", "ini", "input", "In", "s", "inner", "ln", "stream", "image", "err", "i", "r", "n", "again", "socket", "diff", "nin", "win", "inn", "pin", "is", "l", "source", "lin", "up", "cin", "init", "inside", "kin", "data", "rin", "pass", "con", "trans", "impl", "f"], "out": ["net", "exec", "OUT", "client", "cache", "w", "output", "bin", "exp", "io", "inc", "one", "log", "conn", "ext", "obj", "inner", "image", "err", "off", "this", "Out", "plain", "extra", "writer", "user", "ex", "n", "again", "parent", "o", "null", "sync", "post", "outer", "copy", "other", "cos", "data", "work", "file", "up", "pool", "ac", "part"], "buf": ["Buffer", "uf", "v", "map", "cap", "bc", "vec", "result", "uc", "cache", "bin", "tmp", "br", "cv", "bd", "raw", "path", "ctx", "fb", "length", "seq", "queue", "c", "off", "bl", "bag", "box", "batch", "b", "orig", "ff", "loc", "block", "pad", "buffer", "blocks", "bytes", "rb", "cas", "rc", "data", "pool", "bh", "bf", "cb", "buff"], "len": ["cap", "lc", "url", "base", "el", "id", "pre", "Len", "val", "fl", "length", "ind", "li", "fin", "end", "ln", "no", "c", "off", "all", "en", "ie", "count", "n", "body", "nt", "iter", "min", "bytes", "fd", "lf", "line", "data", "l", "pos", "num", "coll", "lim", "split", "part", "size", "f", "rev"]}}
{"id1": "9275622", "id2": "255765", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferfile", "copyFolder", "movefile", " copyFolder", "moveFolder", "transferFolder", "transferFiles", "moveFiles", " copyfile", "moveFile", "transferFile", "copyfile", " copyFiles"], "_file1": ["_fileone", "_files01", "_files2", "_zipOne", "_zipFirst", "_File0", "_mail1", "_mail01", "_fileFirst", "_resourceOne", "_resourceone", "_fFirst", "_files0", "_fOne", "_fone", "_files1", "_File2", "_zipone", "_f1", "_mail2", "_File1", "_file01", "_mail0", "_resource1", "_File01", "_file0", "_resourceFirst", "_fileOne", "_zip1"], "_file2": [" _files4", "_play4", "_Filesecond", " _fileTwo", "_files2", "_playsecond", "_files4", "_file3", "_files3", "jmodel2", "_modelsecond", "_file5", "_play3", " _file4", "_play5", " _file3", " _filesTwo", "jfile5", "_File5", "jfile1", "jmodelsecond", " _files3", "_play1", " _files2", "_model2", "_File2", "_play2", "_fileTwo", "_File1", "_filesTwo", "_file4", "jfilesecond", "_model1", "_filesecond", "jmodel1", "jmodel5", "_playTwo", "_model5", "jfile2"], "fis": [" fiss", "fais", "cfis", "fris", "cfas", " fais", "lfais", "infis", "lfi", " fi", "Fris", "infiss", " fas", "Fos", "infils", "fils", "Fis", "fas", " fils", "afis", "cfiss", "afi", "lfis", "Fiss", "Fils", "lfiss", "Fas", "fiss", "afiss", "fi", "cfos", "cfris", "afais", "infos", " fris"], "fos": ["foes", "Fo", "feus", "infus", "gus", "fus", "gos", "infios", "Fros", "flis", "poes", "fOS", "feis", "Foos", "feos", " foos", "Fus", "Foses", " faos", "feoses", "Fos", "Fis", "fros", " fo", "infoos", "fios", "pis", "lOS", "info", "Fios", "infaos", "flOS", "floes", "lis", " fus", " fios", "infos", "goses", "los", "loes", "fo", "pOS", "infros", "gis", "flos", "foses", "pos", " fros", "faos", "Faos", "foos"], "canalFuente": ["canalFUente", "canaledFuze", "canalFuento", "canallBuence", "canallFuencia", "canalsBuencia", "canalFuze", "canaledBuze", "canaledBuente", "canallFuze", "canalSuestro", "canalFuence", "canalBuence", "canalFUze", "canalKuente", "canalKuento", "canalsBuence", "canalFUencia", "canalFuestro", "canallBuencia", "canalsBuento", "canalKuence", "canaledFuje", "canalFUestro", "canalCraencia", "canalBuze", "canaledFuestro", "canallFuence", "canalSuze", "canalsFuence", "canalFUje", "canaledFuente", "canalsFuencia", "canalBuje", "canalCraente", "canalBuento", "canalSuje", "canalsFuente", "canalBuente", "canalsFuento", "canaledBuje", "canalFuencia", "canalCraence", "canalKuencia", "canalCraento", "canallBuze", "canalKuze", "canallBuente", "canalBuestro", "canaledBuestro", "canalBuencia", "canallFuente", "canalFUence", "canalFuje", "canalSuente", "canalsBuente"]}}
{"id1": "9857412", "id2": "13368520", "code1": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "code2": "    public void sendTextFile(String filename) throws IOException {\n        Checker.checkEmpty(filename, \"filename\");\n        URL url = _getFile(filename);\n        PrintWriter out = getWriter();\n        Streams.copy(new InputStreamReader(url.openStream()), out);\n        out.close();\n    }\n", "label": 0, "substitutes": {"writeData": ["sendDATA", " writeDATA", "sendBytes", " writePart", "sendData", "sendPart", "outputPart", "writePart", "writeBytes", "outputDATA", "outputBytes", "outputData", "writeDATA", " writeBytes"], "data": ["address", "result", "reader", "cache", "sample", "load", "DATA", "input", "sequence", "binary", "memory", "queue", "image", "multi", "resources", "database", "connection", "batch", "dat", "text", "video", "body", "buf", "config", "array", "media", "timeout", "resource", "bytes", "content", "source", "value", "json", "response"], "options": ["address", "params", "cache", "groups", "scope", "ts", "io", "Options", "times", "meta", "values", "obj", "resources", "results", "files", "properties", "flags", "info", "vals", "object", "ops", "config", "bits", "headers", "table", "option", "parts", "resource", "bytes", "style", "keys", "details", "json", "opt", "settings"], "transferMetaData": ["transfermetaName", "transferDataScript", "transferDataData", "transferMetaName", "transfermetaHash", " transferMetBreak", "sendMetaData", "transferMetaDATA", " transferMetaLeft", "transfermetaDATA", "ferMetaHash", "transferDataName", "transferMetaHash", "ferMetaData", "ferMetaName", "transfermetaScript", "transferMediaBreak", "ferDataHash", "transfermetaLast", "transferMediaScript", " transferMetData", "sendMetaDATA", "sendMetaScript", "transferMetData", "ferDataData", "transferDataHash", "transferMediaDATA", "sendMetaBreak", "transfermetaBreak", "ferDataName", " transferMetaLast", "transfermetaLeft", "ferMetaScript", "transferMetaScript", "transferMetaLast", "transferMetBreak", " transferMetLast", "transferMetaLeft", "transferMetaBreak", "transferMediaData", "transfermetaData", " transferMetLeft", "transferMetLast", " transferMetaBreak", "transferMetLeft", "ferDataScript"], "startTime": ["startedTime", " startLine", "initStream", "startLine", "initLine", "initTim", "StartTime", "initTime", "startStream", "startPoint", "StartStream", "startedPoint", "StartTim", " startPoint", "startedLine", "StartPoint", " startTim", " startStream", "startTim", "StartLine"], "transferredBytesNum": ["translatedPagesNum", "transferredTokensMon", "transendedByteNum", "translatedbytesVal", "transendedBytesNum", "transendedBytesChan", "translatedBytesBu", "transferredSharesSum", "transferredbytesMon", "transendedBytesSum", "transferredbytesLen", "transferredFramesSum", "transendedByteChan", "translatedPagesLen", "translatedBytesVal", "translatedPagesMon", "transferredBytesBu", "transferredFramesChan", "transendedByteSum", "translatedBytesLen", "translatedPagesBu", "transferredByteSum", "transferredByteMon", "transferredbytesNum", "transferredbytesVal", "transferredbytesBu", "translatedBytesNum", "transferredbytesSum", "translatedbytesSum", "transferredByteVal", "transferredFilesLen", "translatedBytesSum", "transferredPagesMon", "transferredBytesSum", "transferredFilesBu", "transferredBytesChan", "transferredFilesNum", "translatedBytesMon", "transferredPagesLen", "transferredFramesNum", "transferredTokensSum", "translatedbytesNum", "transferredByteNum", "transferredFilesMon", "transendedBytesMon", "transferredByteChan", "transferredBytesVal", "transferredTokensChan", "transferredPagesNum", "transferredBytesMon", "transferredFramesMon", "transferredPagesBu", "transferredSharesNum", "transferredSharesVal", "transferredTokensNum", "transendedByteMon", "transferredBytesLen"], "elapsedTime": [" elapsedForce", "elroredForce", "elapsetime", " elavedTime", "elapsedDuration", "Elapsetime", "elavedForce", " elavedValue", "elayedTime", " elavedForce", "elivedTime", " elapsedValue", "Elapsedtime", "ElapsedTimes", "elocatedValue", "elavedTime", "ElapsedDuration", "elapsedForce", "ElapseTime", "elroredTime", "ElapsedTime", "elapsedValue", "ElapseTimes", "elapsedTimes", "elapseTimes", "elavedValue", "elapseDuration", "elroredTimes", "ElapseValue", "elroredValue", "elivedtime", "elivedDuration", "elapsedtime", "elapseForce", "elocatedTimes", "elayedDuration", "ElapseDuration", "elocatedTime", "elapseValue", "ElapsedValue", "elayedtime", "elapseTime"], "opts": ["OPtr", "opttt", "copts", "optrs", "optps", " opte", " optt", "OPfs", " optfs", "otter", "copTS", "OPTS", " optters", "optts", "opters", " oprs", "optTS", " opments", " optte", " opps", " opty", " opTS", "opments", "opte", "preters", "ottr", "OPte", "opfs", "opps", "OPty", "opty", "copments", "OPps", " optts", "oprs", "otTS", "prete", "OPter", "OPters", "opTS", "optt", "obts", "prets", "optments", "opter", "obter", "obTS", "otts", "optte", "OPts", "coprs", "prefs", "optty", "obtr", "optr", "OPtt"], "server": ["ser", "sys", "address", "client", "system", "site", "port", "Server", "path", "folder", "host", "name", "string", "localhost", "domain", "prefix", "database", "type", "ssl", "user", "socket", "uri", "service", "resource", "version", "erver", "http", "peer", "secret", "email", "value", "serv"], "username": ["address", "header", "account", "client", "token", "login", "sword", "ame", "port", "family", "path", "users", "filename", "machine", "name", "string", "profile", "ui", "prefix", "database", "character", "auth", "info", "method", "nick", "user", "mobile", "config", "uri", "attribute", "property", "person", "key", "dn", "staff", "usr", "subject", "USER", "email", "ername", "uid", "manager"], "password": ["sudo", "params", "account", "column", "token", "Password", "client", "sword", "priv", "port", "wallet", "path", "mask", "session", "name", "profile", "word", "prefix", "auth", "nick", "user", "pad", "padding", "uri", "attribute", "resource", " passwords", "key", "wd", "phrase", "PASS", "channel", "secret", "fax", "device", "pass"], "filePath": ["fileHandler", "singleInfo", " fileParent", "singlepath", "workType", "FILEParent", "baseUrl", "FileUrl", "workpath", " fileUrl", "workPath", "resourcepath", "FileName", "Filepath", "basepath", "singleName", "resourceInfo", "FILEpath", "resourceType", "FILEPoint", "basePath", "FILEUrl", "resourceUrl", "baseName", "FILEName", " fileInfo", "workName", "FilePoint", "fileType", "FilePath", "fileParent", "filepath", "fileInfo", "FILEHandler", "resourcePath", "singlePath", "filePoint", " fileType", "singleUrl", "FILEPath", "fileUrl", "FileHandler", "FileParent", " filePoint", "resourceName", " filepath", " fileHandler"], "idx": ["IDx", "pidx", "idc", "IdX", "Idx", " idn", "intv", "indc", "indX", "idn", " idy", "indxs", " idv", " idc", " idxc", "Idn", "idy", "intxs", "intX", "indn", "idX", "Idy", "indy", "IDn", "intx", "indv", "pidc", "IDX", "IDy", " idxs", "indx", "indxc", "idv", "pidX", " idX", "pidn", "idxc", "idxs", "Idxc"], "fileName": [" filePart", "sourcename", "sourcePart", "resourcePart", "FileName", "filename", "sourceName", "resourceInfo", "sourcePath", " fileInfo", "filePart", "FilePath", "FilePart", "fileInfo", "resourcePath", " filename", "FileInfo", "resourceName", "Filename"], "url": ["v", "z", "base", "client", "bb", "str", "io", "proxy", "URL", "sl", "fl", "Url", "host", "li", "gl", "build", "org", "t", "ssl", "i", "connection", "g", "b", "user", "object", "browser", "o", "www", "config", "uri", "service", "resource", "api", "p", "bel", "http", "l", "page", "json", "impl", "open", "web", "f"], "urlc": [" urlC", "httpcf", "urlcf", "urlfc", "downloadc", " urlci", "URLci", "slp", " urlp", "slci", "urlf", "urlci", "urlp", "webp", "downloadC", " urlcf", " urlac", "slcf", "httpac", "URLc", "slc", "webc", "webcode", "urlC", " urlf", "httpc", "urlcode", "serverc", "URLC", "servercode", "webfc", "webf", "httpci", "serverfc", "httpf", "downloadci", "URLfc", "downloadfc", "webac", "serverf", "httpp", " urlcode", "urlac", " urlfc"], "os": ["us", "mos", "las", "OS", "osi", "Os", "ob", "iso", "ot", "aos", "io", "boot", "oss", "conn", "out", "s", "obj", "oid", "ios", "bos", "ori", "i", "oos", "dos", "ops", "so", "o", "ps", "fits", "bits", "socket", "oses", "los", "fs", "is", "http", "cos", "obs", "oi", "pos", "ros", "oa", "bs", "ors", "oS"], "bis": ["ais", "ins", "cache", " cis", "ois", "bb", "ob", "aos", "boot", "opus", "sis", "fb", "oss", "abs", "ls", "obj", "ris", "ios", "bps", "ses", " bos", "nis", "buff", "bos", "sb", "ori", "dos", "b", "rots", "lis", "co", "bits", "lins", "pins", "ri", "los", "fs", "phys", "bytes", "uds", "abi", "obs", "cos", "oi", "is", "usb", "bes", "ubis", " Bis", "obb", "bs", "cb", "bi", "alis"], "buffer": ["Buffer", "position", "header", "uffer", "reader", "cache", "bb", "window", "FFER", "pause", "vector", "feed", "available", "border", "length", "string", "binary", "sequence", "memory", "queue", "this", "button", "layer", "reference", "batch", "b", "buf", "block", "padding", "table", "message", "timeout", "resource", "iter", "flush", "document", "channel", "source", "device", "value", "buff", "texture"], "br": ["yr", "bn", "cm", "bc", "img", "ver", "ele", "mr", "str", "el", "bp", " Br", "ber", "bd", "pre", "arr", "bre", "ler", "nr", "div", "length", "cr", "hr", "bridge", "rib", "li", "obj", "bro", "err", "next", "bl", "wr", "Br", "or", "j", "i", "r", "b", "bar", "buf", "span", "gap", "tr", "block", "aa", "fr", "lr", "bal", "p", "dr", "line", "BR", "char", "ch", "gr", "width", "bh", "bf", "ctr", "cb", "bi", "shr"]}}
{"id1": "12537270", "id2": "8665321", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"parse": ["apply", "load", "raw", "xml", "ge", "patch", " analyse", "eval", "build", "read", "format", "report", "Parser", "scan", "see", "ract", "arse", "update", "pack", "parser", "ize", "match", "process", "se", "split", "open"], "link": ["address", "base", "rel", "local", "linked", "e", "id", "URL", "load", "path", "xml", "location", "string", "name", "li", "ln", "word", "bug", "image", "lock", "like", "type", "info", "html", "connection", "route", "text", "tag", "loc", "Link", "message", "uri", "lang", "add", "links", "http", "href", "l", "line", "source", "data", "file", "page", "match", "style", "inline", "ink", "msg"], "conn": ["mc", "rn", "ai", "ca", "client", "ann", "io", "db", "pt", "er", "connect", "Config", "out", "cr", "cp", "cmd", "c", "ci", "err", "cc", "rt", "ct", "ssl", "connection", "r", "Connection", "apt", "n", "rec", "config", "loc", "socket", "nt", "enc", "dc", "p", "pg", "dr", "rc", "col", "cn", "ch", "act", "pc", "con", "nc", "ac", "Conn", "open", "ctrl", "ctx"], "rd": ["rn", "ra", "reader", "rh", "sr", "rm", "rog", "bd", "rr", "RR", "hr", "rw", "RS", "rt", "dd", "dra", "r", "rg", "rx", "RD", "fr", "ds", "ru", "lr", "dc", "rb", "wd", "nd", "fd", "dr", "rc", "RM", "xd", "ld", "adr", "rss", "rl", "rs", "rid"], "kit": ["net", "wt", "sit", "k", "base", "reader", "util", "w", "fit", "site", "feed", "io", "tools", "pot", "plugin", "py", "ku", "auto", "ui", "cr", "bug", "spec", "bot", "pit", "rt", "kt", "os", "lib", "sci", "format", "t", "ct", "info", "et", "b", "browser", "ut", "rot", "ki", "config", "nt", "Kit", "loader", "api", "p", "tk", "h", "kat", "init", "kin", "qt", "cat", "f", "tool"], "doc": ["md", "bc", "de", "base", "mc", "dec", "tt", "db", "docs", "xml", "tx", "val", "div", "out", "bug", "Doc", "m", "info", "html", "root", "desc", "text", "body", "tag", "config", "loc", "mm", "pub", "fr", "dc", "api", "dom", "document", "http", "dr", "di", "in", "data", "page", "file", "dir", "ref", "d", "coll", "pc", "pos", "ac", "DOC", "open", "f", "msg", "po"], "url": ["address", "base", "util", "el", "feed", "URL", "path", "xml", "log", "sl", "Url", "host", "location", "name", "gl", "bug", "image", "hub", "org", "ssl", "connection", "html", "ll", "cdn", "www", "pull", "loc", "config", "ur", "uri", "lr", "resource", "service", "http", "href", "l", "github", "source", "file", "server", "page", "download", "src", "rl", "blog", "f"], "it": ["v", "lit", "sit", "ip", "st", "stat", "id", "iti", "ic", "iz", "end", "mit", "ci", "It", "pit", "or", "you", "t", "ite", "r", "info", "et", "edit", "nt", "iter", " It", "p", "its", "iterator", "dit", "l", "in", "se", "init", "IT", "split", "ait"], "elem": ["Eade", " neade", "oeler", " nelem", "oelem", "Elem", "oelement", "Element", " Eler", " neler", "Elev", "Eler", "oelev", "eelem", "eelements", "eelement", " Element", "pelem", "eler", " Elem", "seject", "eject", "selements", "Elements", "element", "eeject", "elev", "elements", "pelement", "selem", "selement", "eade", "pelev", " Eade", "peler", "Eject", " nelement"], "s": ["v", "services", "sv", "sch", "params", "scope", "xs", "e", "sets", "ts", "rs", "ws", "sl", "es", "session", "ns", "string", "u", "ls", "c", "set", "spec", "si", "ses", "os", "strings", "m", "t", "ssl", "a", "sb", "r", "g", "b", "js", "n", "ops", "attr", "o", "ps", "sym", "S", "sync", "ds", "fs", "service", "p", "parts", "h", "submit", "se", "server", "d", "details", "ss", "sf", "f", "gs"], "lnk": ["olnkh", "knK", "nnk", "nlok", "lnky", "gnky", "lnks", "linke", "lenke", "gnok", "lnkh", "lenk", "dlks", "lnK", "olnk", "nnke", "nlf", "nlkh", "knkh", "olnf", "dlke", "dnk", "dlok", "linky", "nlks", "dnky", "gnk", "dlky", "olnK", "olnkr", "nlK", "nlke", "dnf", "dnku", "lnkr", "dlf", "knke", "lenks", "linf", "lnf", "olnke", "dnke", "lenky", "nnky", "nlky", "lnke", "dnkr", "gnke", "knk", "dlkr", "lenku", "lnku", "lnok", "nnku", "nlk", "dlk"], "j": ["qi", "jp", "J", "z", "uj", "im", "syn", "ja", "job", "br", "jc", "kj", "x", "index", "name", "note", "obj", "ind", "li", "si", "ij", "adj", "aj", "ii", "y", "oj", "m", "ie", "info", "a", "g", "js", "n", "o", "dj", "fr", "p", "key", "jo", "jl", "ch", "ni", "pos", "ne", "ji", "part", "jj", "pr"], "urlLink": ["urlUrl", "UrlLink", "URLPage", "UrlRel", "urlConnect", "urllink", " urlLine", "resourceConnect", " urlConnect", "strlink", "URLLink", "UrlPath", "resourceLink", "UrlHub", "strLine", "urlRel", " urllink", "urlPage", "resourcelink", "strLink", "URLUrl", " urlUrl", "resourceLine", " urlHub", "fileHub", "UrlPage", " urlPage", "fileLink", "UrlUrl", "urlPath", "strConnect", "URLRel", "urlHub", "filePath", "fileUrl", " urlPath", "urlLine", " urlRel"], "str": ["st", "dec", "sr", "br", "sta", "arr", "spr", "sl", "div", "res", "string", "name", "cr", "hr", "inner", "ext", "obj", "err", "wr", "Str", "t", "r", "b", "js", "text", "n", "kr", "tr", "STR", "enc", "inst", "strip", "fr", "dr", "line", "l", "data", "char", "stri", "elt", "txt", "coll", "pass", "sp", "ctr", "f", "pr"], "i": ["qi", "v", "ip", "ai", "ti", "vi", "I", "uli", "e", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "li", "u", "ui", "hi", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "m", "en", "ori", "info", "b", "n", "o", "zi", "bi", "slice", "ri", "uri", "p", "ix", "gi", "fi", "abi", "in", "di", "oi", "l", "init", "ni", "yi", "chi", "ji", "mu", "f", "pi"], "skip": ["complete", "error", "special", "fast", "replace", " bypass", " skipped", " skipping", "jump", " repeat", "active", "scan", "empty", " exclude", "stop", " duplicate", "iter", "Skip", "add", " scan", "copy", "ips", "append", "loop", " dup", "sp", "cmp"]}}
{"id1": "3024987", "id2": "22441244", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamForencode", "testCopy_readerToOutputStreamForencoding", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStreamForEncoder", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStream_Coder", "testCopy_readerToOutputStream_Integoded", "testCopy_readerToOutputStream_Code", "testCopy_readerToOutputStream_Coded", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStreamForencoder", "testCopy_readerToOutputStreamForencoded", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStreamForEncoding", "testCopy_readerToOutputStream_encode", "testCopy_readerToOutputStream_Encode", "testCopy_readerToOutputStreamForEncoded", "testCopy_readerToOutputStream_Integoder", "testCopy_readerToOutputStream_Integoding", "testCopy_readerToOutputStreamForEncode", "testCopy_readerToOutputStream_Integode", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStream_Coding"], "in": ["url", "ins", "din", "IN", "re", "login", "bin", "id", "io", "inc", "include", "ini", "input", "In", "inner", "image", "err", "inas", "read", "or", "m", "Reader", "a", "i", "r", "n", "again", "with", "rec", "slice", "win", "buffer", "inn", "min", "is", "arin", "data", "source", "entry", "file", "init", "inside", "rin", "pass", "reading"], "reader": ["ra", "feed", "io", "rr", "worker", "x", "rer", "ler", "er", "input", "pointer", "inner", "stream", "driver", "iner", "read", "Reader", "or", "writer", "i", "r", "b", "rx", "handler", "oder", "per", "loader", "ner", "her", "parser", "buffer", "iter", "source", "file", "rar", "ink", "reading"], "baout": ["bain", "baparent", "waoutput", "BAoutput", "BAOUT", "BAout", "vaparent", "abain", "baoutput", "dain", "abaOUT", "daOut", "vaOut", "aaOut", "daout", "waout", "aaout", "aain", "BAin", "Baout", "vain", "wain", "BaOut", "aaoutput", "abaOut", "daOUT", "vaout", "baOut", "Baparent", "waOut", "abaout", "Bain", "BAparent", "BAOut", "baOUT"], "out": ["exec", "base", "OUT", "client", "outs", "cache", "builder", "output", "io", "inc", "arr", "obj", "ext", "inner", "to", "image", "err", "write", "inas", "Out", "lib", "writer", "user", "null", "object", "again", "parent", "o", "with", "buffer", "array", "line", "pool", "file", "up", "server", "ref"], "bytes": ["objects", "classes", "outs", "Bytes", "output", "zip", "seconds", "es", "ies", "odes", "ns", "string", "binary", "values", "lines", "cells", "ls", "size", "files", "bps", "os", "ones", "comments", "strings", "items", "rows", "null", "text", "body", "bits", "pieces", "css", "android", "blocks", "parts", "les", "content", "its", "ips", "pages", "data", "units", "reads", "ipes", "bs", "tes", "codes"]}}
{"id1": "8000624", "id2": "13362846", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copyTo", "CopyFrom", "copyTo", " copyto", " transferTo", "CopyFile", " copyFile", "copyFrom", "copyFile", " transferFile", "Copyto", " copyFrom", " transferFrom", "copyto", " transferto"], "dest": ["rest", "test", "cont", "img", "sup", "w", "delete", "output", "bin", "tmp", "exit", "comb", "path", "folder", "target", "filename", "flat", "name", "obj", "write", "them", "Dest", "class", "transform", "orig", "object", "desc", "wb", "table", "done", "content", "source", "data", "file", "destroy", "dist", " destination", "src", "die", "later", "opt", "txt", " Dest", "temp"], "in": ["gin", "ins", "thin", "reader", "din", "IN", "re", "login", "bin", "id", "isin", "inc", "vin", "x", "ini", "input", "issue", "In", "s", "conn", "inner", "ln", "image", "fa", "ax", "lib", "m", "i", "r", "connection", "b", "n", "again", "sin", "pull", "nin", "win", "inn", "wave", "pin", "plus", "h", "l", "lin", "source", "cin", "up", "init", "inside", "kin", "rin", "pass", "con", "ac", "as", "f"], "out": ["net", "exec", "external", "url", "OUT", "client", "outs", "cache", "w", "call", "output", "bin", "app", "ou", "io", "inc", "not", "one", "x", "outside", "target", "conn", "name", "ext", "inner", "image", "err", "no", "off", "this", "Out", "lib", "or", "writer", "i", "user", "b", "ex", "n", "again", "object", "o", "socket", "sync", "nin", "outer", "timeout", "plus", "pin", "copy", "other", "data", "vert", "up", "file", "our", "part", "temp"], "c": ["v", "cm", "cl", "lc", "cf", "bc", "cy", "exc", "uc", "ca", "e", "C", "x", "ic", "pointer", "oc", "cr", "u", "ci", "cc", "code", "m", "ct", "ec", "t", "i", "r", "arc", "cu", "ce", "n", "xc", "esc", "o", "config", "fc", "enc", "buffer", "dc", "p", "content", "rc", "col", "l", "char", "ch", "sc", "d", "pc", "ac", "abc", "comment", "cb", "f"]}}
{"id1": "9802073", "id2": "22752444", "code1": "    public void testAutoCommit() throws Exception {\n        Connection con = getConnectionOverrideProperties(new Properties());\n        try {\n            Statement stmt = con.createStatement();\n            assertEquals(0, stmt.executeUpdate(\"create table #testAutoCommit (i int)\"));\n            con.setAutoCommit(false);\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (0)\"));\n            con.setAutoCommit(false);\n            con.rollback();\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (1)\"));\n            con.setAutoCommit(true);\n            con.setAutoCommit(false);\n            con.rollback();\n            con.setAutoCommit(true);\n            ResultSet rs = stmt.executeQuery(\"select i from #testAutoCommit\");\n            assertTrue(rs.next());\n            assertEquals(1, rs.getInt(1));\n            assertFalse(rs.next());\n            rs.close();\n            stmt.close();\n        } finally {\n            con.close();\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 0, "substitutes": {"testAutoCommit": ["testAutoComIT", "testAutoommit", "testAutoComit", "testSyncCommit", "testAutoommits", "testAutoommIT", "testSyncDebit", "testSyncCommits", "testSyncCommIT", "testSyncDebits", "testSyncDebite", "testAutoDebIT", "testAutoDebite", "testAutoCommIT", "testAutoommite", "testAutoCommits", "testAutoComits", "testSyncDebIT", "testAutoDebit", "testAutoCommite", "testAutoComite", "testSyncCommite", "testAutoDebits"], "con": ["bc", "cl", "cache", "gen", "union", "ran", "cur", "log", "session", "conn", "core", "context", "pub", "win", " CON", "col", "cn", "coll", "Conn", "ctrl", "conf", "fac", "pr", "cm", "ocon", "client", "un", "db", "cr", "conv", "lock", "c", "en", "ct", "class", "pen", "fc", "close", "pool", "fn", " conn", "ac", "can", "cf", "syn", "mc", "uc", "ca", "util", "connect", "cc", "m", "config", "Con", "cond", "min", "non", "CON", "rc", "pc", "an", "ver", "com", "platform", "pre", "tc", "sql", "connection", "crit", "Connection", "n", "co", "sync", "common", "cas", "act", "ctx"], "stmt": ["stm", "ctmb", "STMT", "Stmp", " stm", " stmn", "Stmd", "stur", "Stm", "stnt", "estmb", "storp", "estMT", " stMT", "estmt", "rmt", " stmb", "rmd", " stbl", "slmt", "slmp", "STmp", "Storp", "STsp", "STm", " stb", " stpt", "stmd", "Stbl", "estsp", "stb", "ctmt", "STpt", "Stmb", " stnt", "stMT", " stmp", "stpt", "Stmn", "STmb", "stor", "STbl", "slur", "stmn", "rorp", "slmn", " stsp", "rb", "stmp", "Stur", "Stpt", " storp", " stor", "Stmt", "STmt", "stbl", "Stnt", " stur", "stmb", "Stor", "STnt", " stmd", "ctmp", "stsp", "ctor", "Stb"], "rs": ["ins", "ra", "ms", "relations", "reader", "mr", "sr", "xs", " rows", " results", "ges", "rr", "row", " r", "res", "pr", "cr", "ls", "hr", "ris", "vers", " RS", "RS", "results", "rt", "hs", " sr", " res", "repl", "ras", "r", "errors", "rows", "acks", "cs", "rx", "runs", " Rs", "ps", "ars", "ows", "ubs", "Rs", "rc", "ry", "sc", "rys", "eers", "RC", "src", " rc", "rss", "ros", "rl", "rd"]}}
{"id1": "18339787", "id2": "8932510", "code1": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 0, "substitutes": {"reload": ["overresh", "overloading", "refresh", "prefill", "overload", "preload", "reresh", "reloading", "reffill", "refloading", "preresh", "preloading", "refill", "overfill", "refload"], "currentDate": ["CurrentTime", "reportedDate", "currentUpdate", "CurrentKey", "reportedTime", "currentDay", "CurrentName", "newKey", "newDate", "reportedName", "reportedDay", "currentTime", "CurrentUpdate", "currentName", " currentDay", " currentName", "newUpdate", "currentKey", " currentUpdate", " currentKey", "CurrentDay", "newDay", " currentTime", "CurrentDate"], "xpath": ["xPath", "xparent", "exPath", " xprop", " xPath", "Xath", "exp", "xp", "Xpath", "expath", "XPath", "Xstream", "lexparent", "exprop", "exstream", "lexpath", "xstream", "axPath", "exparent", "xath", "xprop", " xp", " xstream", "xcase", "exath", "axcase", "txstream", "axath", " xparent", "lexstream", "axpath", " xcase", "Xprop", " xath", "Xcase", "lexPath", "Xp", "txpath", "txPath"], "docBuilderFactory": ["docBuildFactor", "projectBuilderFactory", "projectbuilderInterface", "docManagerFactor", "docBuilderF", "docbuilder2", "docManager2", "projectBuilderInterface", "docbuilderService", "documentBuilderFactory", "docBuilderService", "documentBuilderService", "docBuilder2", "projectbuilderFactor", "docBuilderInterface", "docBuildService", "docBuildFactory", "docbuilderFactor", "docBuild2", "projectBuilderFactor", "documentBuilderF", "docBuilderFactor", "documentBuildF", "docBuildF", "documentBuildService", "docBuildInterface", "docbuilderF", "projectBuilder2", "docManagerFactory", "docManagerInterface", "docbuilderInterface", "documentBuildFactory", "projectbuilderFactory", "docbuilderFactory", "projectbuilder2"], "docBuilder": ["documentBuilder", "fileBook", "documentFactory", "DocParser", "xmlBuilder", "fileFactory", "docBook", "fileBuilder", "xmlBuild", "docParser", "documentBuild", "docbuilder", "documentBook", "Docbuilder", "documentbuilder", "xmlParser", " docBuild", "xmlbuilder", "docBuild", " docFactory", "DocBuild", "fileBuild", " docBook", "docFactory", "documentParser", "DocBuilder"], "conn": ["exec", "cm", "lc", "client", "uc", "ann", "URL", "cb", "db", "path", "log", "connect", "Url", "session", "out", "conv", "cp", "cmd", "lock", "c", "ci", "ct", "ssl", "connection", "Connection", "body", "config", "loc", "enc", "nt", "loader", "socket", "api", "http", "l", "cli", "channel", "server", "ch", "cn", "coll", "con", "nc", "Conn", "serv", "conf", "ctx"], "url": ["base", "client", "str", "ob", "feed", "URL", "db", "path", "log", "sl", "Url", "host", "string", "ls", "gl", "image", "err", "build", "org", "ssl", "connection", "ll", "www", "config", "loader", "fr", "uri", "resource", "bel", "http", "l", "data", "file", "channel", "server", "download", "coll", "impl", "serv", "web", "blog", "f"], "xml": ["wt", "address", "reader", "parse", "el", "php", "feed", "zip", "arr", "model", "wl", "path", "x", "log", "request", "children", "input", "node", "context", "response", "stream", "image", "doc", "event", "element", "writer", "html", "root", "example", "config", "layout", "apache", "graph", "update", "events", "office", "date", "tree", "dom", "content", "document", "http", "page", "data", "file", "email", "rss", "json", "atom", "txt", "ml", "temp"], "exchangeRateDate": ["exchangePriceFormat", "expireRateDate", "exchangeWeightKey", "exchangeRateTime", "exchangePricePrice", "exchangeRatePrice", "exchangeTimeDuration", "expirePriceKey", "excurrencyTimeTime", "excurrencyRateFile", "exchangeTimeFile", "exchangeTimeDate", "expirePriceFormat", "exchangeRateDuration", "exchangeRateFile", "exchangeFactorFile", "excurrencyTimeDuration", "excurrencyTimeFile", "exchangeWeightDate", "exchangeRatingKey", "exchangePriceDate", "exchangeRatingDate", "exchangeRateFormat", "exchangeFactorDuration", "exchangeRatingFormat", "expirePriceDate", "expirePricePrice", "expireRateKey", "excurrencyRateDate", "excurrencyRateTime", "excurrencyTimeDate", "exchangeWeightFormat", "exchangeWeightPrice", "exchangeRatingPrice", "exchangePriceKey", "expireRateFormat", "exchangeFactorTime", "expireRatePrice", "exchangeFactorDate", "exchangeTimeTime", "exchangeRateKey", "excurrencyRateDuration"], "currenciesNode": ["corenciesnode", "contractrenciesDocument", "comportsElement", "courrenciesNode", "curportsPath", "curcurrencyPath", "curportsBlock", "contractrenciesRoot", "curitiesContainer", "curratesBlock", "curportsElement", "comrenciesNode", "curlationsElement", "curcurrencyBlock", "currenciesRoot", "cururrenciesArray", "currenciesPath", "courrenciesnode", "comportsPath", "curriesNode", "curratesDocument", "courrenciesArray", "curriesRoot", "comrenciesPath", "cururrenciesNode", "currenciesnode", "cururrenciesRoot", "courrenciesContainer", "curlationsBlock", "currenciesDocument", "curatorsArray", "curlationsNode", "contractrenciesNode", "curcurrencyNode", "comrenciesBlock", "comportsNode", "contractrenciesBlock", "cururrenciesBlock", "curatorsNode", "currenciesBlock", "curportsNode", "currenciesContainer", "comportsBlock", "currenciesArray", "contracturrenciesDocument", "corenciesContainer", "curcurrencyElement", "contracturrenciesBlock", "corenciesNode", "contracturrenciesNode", "curatorsContainer", "curriesBlock", "curratesNode", "contracturrenciesRoot", "comrenciesElement", "curlationsPath", "cururrenciesDocument", "cururrenciesnode", "curitiesNode", "corenciesArray", "curratesRoot", "cururrenciesContainer", "curitiesArray", "curatorsnode", "curriesDocument", "curitiesnode", "currenciesElement"], "currencies": [" cururrencies", "carurrency", "loccoins", "curales", "urrencies", " curacters", "chales", "charries", "locrencies", "curacters", "charrency", "peracters", " curums", "chrencies", "chcoins", "curcoins", "curversions", "perums", "scheries", "charrencies", "curries", "locales", "cururrencies", "perrencies", "charurrencies", "locurrency", "scherencies", "urums", " curversions", "churrency", "urversions", "carrencies", "cururrency", "curums", "carales", "carcoins", "perversions", "uracters", "scherency", " curries", "scheurrencies", "currency", " currency"], "i": ["qi", "v", "z", "lc", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "index", "eni", "q", "start", "end", "u", "ui", "li", "hi", "multi", "c", "ci", "si", "phi", "ii", "y", "m", "t", "j", "r", "info", "g", "b", "n", "o", "bi", "slice", "ri", "uri", "p", "gi", "it", "fi", "abi", "in", "di", "oi", "l", "chi", "yi", "ji", "mu", "f", "pi"]}}
{"id1": "2982747", "id2": "15166511", "code1": "    public FileParse(String fileStr, String type) throws MalformedURLException, IOException {\n        this.inFile = fileStr;\n        this.type = type;\n        System.out.println(\"File str \" + fileStr);\n        if (fileStr.indexOf(\"http://\") == 0) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"File\")) {\n            File inFile = new File(fileStr);\n            size = inFile.length();\n            inStream = new FileInputStream(inFile);\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URL\")) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URLZip\")) {\n            URL url = new URL(fileStr);\n            inStream = new GZIPInputStream(url.openStream(), 16384);\n            InputStreamReader zis = new InputStreamReader(inStream);\n            bufReader = new BufferedReader(zis, 16384);\n        } else {\n            System.out.println(\"Unknown FileParse inType \" + type);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"fileStr": ["fileTr", "urlStr", "lineSTR", "lineBr", "logExp", "baseBr", "urlstr", "FileWr", " fileSTR", "fSTR", " fileName", " filestr", "logStream", " fileStream", "fWr", "FileString", "fileString", "resourceCh", "feedExp", "fileExp", "urlText", "fstr", "FileUrl", " fileTr", "fileText", " fileUrl", "imageSTR", "urlExp", " fileCh", " fileWr", "FileCh", "imageStream", " fileString", "urlTr", "resourceStr", "baseStr", "fileUrl", "filestr", "fileName", "urlUrl", "fileStream", "FileStr", "baseSTR", "resourceString", "mailSTR", "fileCh", " fileBr", "mailStr", "imageWr", "feedStream", "baseName", "logSTR", "FileSTR", "resourcestr", "mailStream", "feedStr", "logStr", "mailWr", "feedSTR", "imageStr", "lineStr", "fileWr", "baseString", "FileText", "urlSTR", "FileName", "fileBr", "urlStream", "urlString", "basestr", "FileTr", "linestr", " fileText", "fileSTR", "Filestr", "fStr"], "type": ["address", "error", "types", "title", "right", "id", "port", "model", "path", "name", "link", "off", "like", "format", "method", "post", "api", "file", "value", "part", "status", "function", "on", "state", "action", "lock", "ype", "or", "pe", "class", "shape", "object", "attr", "block", "key", "by", "page", "comment", "TYPE", "ping", "base", "rel", "call", "str", "current", "py", "no", "code", "y", "t", "info", "role", "parent", "media", "resource", "phase", "non", "source", "unit", "ver", "level", "site", "pre", "none", "index", "time", "year", "ty", "Type", "phrase", "typ", "style"], "inFile": ["indexFile", "iniPath", "winUrl", "InFiles", "Infile", "inputF", "InStream", "indexStream", "iniFile", " inPath", "inputFile", "InFile", " inLine", "incFile", "inF", "incUrl", "iniUrl", "inUrl", "inifile", "outStream", "InPath", " inFolder", "INLine", "outFile", "infile", "inputStream", " inUrl", "inputLine", "incF", "winFolder", "InUrl", "incFolder", "winFile", "inFolder", " infile", "INStream", "inputUrl", "inLine", "outfile", "winF", "INFolder", "indexFiles", "inPath", "inFiles", "outFiles", "inputFolder", "INFile", "indexfile"], "url": ["base", "client", "job", "cache", "util", "ob", "use", "force", "feed", "zip", "URL", "proxy", "path", "log", "fl", "sl", "Url", "session", "host", "conn", "string", "gl", "image", "link", "build", "lib", "or", "ssl", "connection", "user", "object", "ll", "www", "config", "pull", "socket", "loc", "loader", "sync", "ur", "ul", "uri", "service", "resource", "update", "http", "l", "page", "source", "file", "channel", "server", "work", "download", "ref", "coll", "impl", "open", "web", "blog", "f", "tool"], "urlconn": ["collconn", "fileconn", "httpconnect", "resourceconn", "URLconn", "webconn", " urlconnect", "webcon", "fileConn", "resourceConn", "httpconf", " urlConn", "webconnection", "URLcon", "filecon", "resourcecon", "urlconnection", "blogconf", "blogconn", " urlconf", "httpconn", "URLconnect", "webconnect", "urlConn", "URLConn", "collconnection", "blogConn", "resourcepool", "collConn", "URLconnection", "urlcon", "urlconf", "urlconnect", "blogconnect", " urlconnection", "webConn", "filepool", "urlpool", "httpConn", "collcon", "webpool"], "inStream": ["innForm", "binStreamer", " inSt", "InReader", "outForm", "dinSocket", "innView", "outFile", "inSocket", "inputStream", " inForm", "INSocket", "binSteam", "inputView", "incContent", "outSteam", "InSt", "inSt", "inContent", "inputSteam", "InStream", "exStream", "dinReader", "InSocket", "inputFile", "incSt", "againStream", "InForm", "INSteam", "INStream", "innSteam", " inContent", "inPath", "againUpload", "exStreamer", "binStream", "InView", "inView", "outStreamer", " inSteam", "InContent", " instream", "icStream", "outStream", "exSteam", "ginPath", "inputPath", "icSteam", "dinStream", "INReader", "inputForm", "outPath", "inUpload", " inUpload", "exFile", "inReader", "againSteam", "inForm", "inStreamer", "icUpload", "innStream", "againstream", " inPath", "ginStream", "Instream", "outstream", "inSteam", "icstream", "ginSteam", "incStream", "dinSteam", "InSteam", "ginstream", "incstream", "binFile", "instream"], "bufReader": ["bufLoader", " bufWriter", "buffWriter", "ufStream", "buffReader", "bufferStream", "funcReader", "cfWriter", " bufRead", " bufLoader", "funcRead", "bufferRead", "cfLoader", "ufReader", "bufferWriter", "funcLoader", "ufLoader", "cfReader", "bufWriter", "buffStream", "cfRead", "buffRead", "ufRead", "funcWriter", "bufRead", "bufStream", "bufferReader", " bufStream", "ufWriter"], "size": ["address", "position", "base", "load", "path", "Size", "name", "length", "max", "offset", "storage", "large", "small", "count", "parent", "empty", "SIZE", "speed", "loc", "ize", "scale", "bytes", "content", "fee", "page", "file", "width", "capacity"], "zis": [" zos", "Ziz", "zos", "Zos", "Zi", "azais", "azos", "azi", "aziz", "ziz", "jIs", "zais", "zi", "Zais", "Zis", "azIs", "jis", "azis", "jiz", "ji", "ZIs", "zIs", " zais", " ziz"]}}
{"id1": "4468255", "id2": "7149578", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"copy": ["share", "save", "delete", "parse", "paste", "rm", "transfer", "zip", "Copy", "load", "put", "replace", "log", "cp", "write", "link", " cp", "info", "cop", "ignore", "sync", "update", "clip", "get", "process", "move", "file", "download", "create", "dump", "split", "cat", "ssh", "clone", "opy"], "from": ["url", "base", "client", "vol", "left", "e", "id", "zip", "io", "old", "path", "one", " form", "of", "log", "er", "start", "name", "context", "string", "stream", "original", "range", "c", "missing", "this", "link", "os", "normal", "code", " the", "or", "at", "connection", "html", "user", "ce", "parent", "empty", "so", "o", "with", "back", "config", "without", "the", "resource", "add", "by", "form", "http", "ate", "source", "data", "file", "before", "dir", "entry", "From", "se", " file", "part", "open", "f"], "to": ["disk", "eto", "cache", "son", "one", "path", "name", "comp", "os", "null", "front", "flo", "p", "jo", "too", "data", "file", "process", "sp", "as", "size", "client", "stat", "token", "db", "x", "TO", "target", "on", "termin", "yet", "database", "or", "tom", "pe", "user", "To", "so", "o", "back", "dis", "by", "http", "template", "two", "de", "base", "system", "io", "not", "but", "auto", "top", "no", "toc", "all", "t", "parent", "socket", "office", "resource", "me", "source", "dir", "temp", "output", "site", "load", "storage", "connection", "root", "sync", "plus", "line", "se", "tto", "about", "po"], "result": ["ure", "test", "url", "error", "ver", "cache", "status", "follow", "allow", "found", "use", "comment", "br", "current", "valid", "force", "sign", "term", "replace", "cur", "Result", "arr", "default", "function", "val", "mask", "res", "true", "length", "mer", "ret", "effect", "lock", "err", "success", "results", "compl", "card", "event", "info", "r", "method", "count", "report", "future", "diff", "ok", "var", "date", "plus", "search", "math", "rc", "continue", "match", "work", "data", "source", "accept", "up", "ult", "entry", "member", "pass", "die", "fail", "part", "sum"], "subFiles": ["subTokens", "newPages", "singfiles", "subParts", " subDir", "subFs", "Subfiles", " subParents", "newsFiles", " subPages", "newsParts", "newFile", "subPages", " subFile", "SubPages", "partFs", "newsfiles", "newParts", "singFs", "partFiles", "subContents", "ubFiles", "subFile", "partParents", "ubPages", "singFiles", " subFs", "newfiles", "subfiles", "SubContents", "subParents", "subDir", "SubParts", "ubContents", "ubDir", "ubfiles", "ubFile", " subTokens", "newsTokens", " subParts", "SubFiles", " subfiles", "singParents", "newFiles", "partfiles", "SubTokens", "SubFile", " subContents"], "i": ["v", "k", "iv", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "q", "name", "li", "u", "ui", "hi", "s", "inner", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "j", "ori", "ie", "a", "b", "n", "o", "bi", "slice", "ri", "uri", "p", "key", "it", "h", "ix", "is", "gi", "di", "oi", "l", "d", "f", "pi"], "newDir": ["nowDIR", " newD", "subQu", "NewJar", "newJar", "NewFolder", "newFile", " newDirectory", " newFolder", "oldDIR", "NewDir", "NewDirectory", "newDirectory", " newJar", "nextQu", " newDIR", "nowDirectory", "subFile", "NewFile", "subFolder", " newFile", "nextFolder", "subDirectory", "subD", "oldFolder", "subDir", "nextDirectory", "oldDir", "oldFile", "nowDir", "newDIR", "newFolder", "nextDir", "oldDirectory", "nextFile", "subJar", "nowFolder", "newQu", "newD", " newQu", "NewD"], "in": ["url", "gin", "ins", "thin", "reader", "din", "IN", "login", "re", "bin", "e", "id", "isin", "inc", "ini", "index", "input", "In", "conn", "on", "inner", "lock", "c", "image", "this", "err", "m", "a", "r", "ie", "b", "ex", "again", "o", "pull", "socket", "diff", "nin", "win", "inn", "min", "pin", "it", "is", "l", "lin", "data", "file", "up", "init", "cin", "source", "con", "part", "serv", "f"], "out": ["net", "exec", "serv", "base", "img", "OUT", "client", "outs", "cy", "w", "call", "output", "bin", "exp", "io", "ou", "inc", "one", "log", "conn", "ext", "name", "inner", "obj", "word", "on", "write", "err", "off", "c", "lock", "Out", "lib", "all", "at", "writer", "b", "ex", "n", "again", "o", "with", "co", "sync", "socket", "post", "line", "op", "file", "up", "ch", "cat", "sum", "can"], "fileLength": ["lineName", "Filelength", " fileSize", "linelength", "pageLength", "pagelength", " fileLen", "lineSize", "pageName", "baseLen", "lineLength", "FileLength", " fileName", "filelength", "fileLen", " filelength", "pageSize", "baseLength", "baseSize", "FileSize", "baselength", "fileSize", "fileName", "FileLen"], "charBuff": ["stringBuff", "charBuffer", "pairBuff", "pairMatrix", "charMatrix", "stringBuffer", "stringMatrix", " charMatrix", " charBuffer", "pairBuffer"], "len": ["lit", "bin", "id", "Len", "val", "fl", "start", "name", "li", "fin", "ln", " pos", "en", "n", "nt", "iter", "lf", "l", "line", "pos", "ni", " split", "split", "part", " Len", "cmp", "rev"], "oneChar": ["singlechar", "singleCor", " oneCar", "singleCharacter", "oneCor", "nextCor", "eachCharacter", "fourchar", "eachchar", " oneCh", "onechar", "nextCar", "singleCh", "fourChar", "singleCar", " oneCharacter", "zeroChar", "singleChar", "oneCh", " onechar", " oneCor", "zerochar", "eachChar", "eachCor", "fourCharacter", "zeroCharacter", "nextChar", "oneCar", "fourCor", "oneCharacter", "nextCh", "zeroCor"]}}
{"id1": "9109613", "id2": "20920051", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fileCopy": ["fileUpload", "folderTransfer", "foldercopy", "Filecopy", "fileTransfer", "folderUpload", "FileTransfer", " fileTransfer", " fileUpload", "folderCopy", "filecopy", "FileUpload", "FileCopy", " filecopy"], "from_name": ["fromTheword", " from_no", " from_space", "fromametime", "from_size", "from__Name", " from_key", "from_Name", "from_no", "fromTheName", "from_time", "fromFullname", "fromqName", "fromFullName", "from__name", " from_alias", "fromqname", "from_path", " from_Name", "from_address", "from_image", "from_alias", "from_filename", " from__alias", "fromFulladdress", " from_time", "from_key", " from__Name", " from_size", "fromThename", " from_image", " from__name", "from_word", " from__address", "fromameno", "from__alias", " from_path", "fromamename", "fromThespace", " from_filename", "fromqpath", " from_address", "fromameName", " from_resource", "from__address", "from_resource", "fromqfilename", "from_space", "fromFullalias", " from_word"], "to_name": ["To_common", "tokname", "to_path", "to_Name", "to_file", "to_names", "To_Name", "from_path", "to_common", "tokcommon", "from_names", "to_key", " to_file", "To_name", "tokName", "from_Name", " to_key"], "fromFile": ["asFile", "FromFile", "oneFile", "fromFolder", "oneDir", "FromLine", "onePage", " fromDirectory", " fromFunction", "sourcePage", "fromPage", "fromFiles", "onefile", "ofFolder", "fromPackage", "oneFunction", "FromFolder", "connectionFile", "autoPage", " fromPage", "toLine", "fromLine", "fromfile", "FromDir", "tofile", "oneModel", " fromFactory", "asFiles", "fromDir", " fromPackage", "oneFolder", "ofFile", " fromFolder", "fromLibrary", " fromFiles", "asfile", "fromModel", "sourceFile", "sourceLibrary", "autoFile", "asFactory", "Fromfile", "FromPage", "FromModel", "connectionPackage", "FromLibrary", " fromfile", " fromModel", "FromDirectory", "connectionfile", "sourceDirectory", "toFactory", "fromFactory", " fromLine", " fromDir", "autoFolder", "FromFiles", "ofPackage", "FromFunction", "connectionFolder", "fromDirectory", "toFiles", "fromFunction", "offile", "autofile", " fromLibrary", "toFunction"], "toFile": [" toFolder", "soPage", "fromFiles", "toLine", "ofTable", "targetfile", "tempFile", " toSourceFile", "toLibrary", "ToPlace", " toPage", "targetSourceFile", " toFunction", "ToDirectory", "toFiles", "nofile", "toPlace", "toFunction", "ofDir", "baseTable", " toFactory", "targetFolder", "noFile", "toTable", "TOPage", "coFile", "baseDir", "TOFile", "aDir", "targetPage", " toFiles", "sofile", "targetFactory", "soLibrary", "TOPlace", " toLine", " toTable", " toDirectory", "targetDir", "basefile", "targetFile", "noLibrary", "tempFolder", "fromDir", "afile", "Tofile", "ToLibrary", "toDir", "cofile", "toPage", "ToPage", "fromDirectory", "offile", "coFunction", "tempFactory", "toFolder", "toDirectory", "ToDir", "aFile", "targetPlace", "ToLine", " tofile", "fromPage", "fromLine", "noPage", "ToFiles", "fromfile", "tofile", "soFile", "ofFile", "ToFactory", "ToFile", "toSourceFile", "ToSourceFile", "aFiles", "ToFunction", "baseFile", "toFactory", " toDir", "tempfile", "coDirectory", "TODir"], "parent": ["address", "test", "pa", "port", "id", "inc", "path", "div", "session", "location", "name", "section", "g", "null", "directory", "option", "api", "p", "col", "data", "file", "server", "full", "Parent", "part", "pr", "complete", "client", "child", "term", "remote", "patch", "string", "or", "pe", "class", "user", "shape", "rule", "guard", "key", "page", "pool", "ac", "lc", "paren", "current", "valid", "pt", "parents", "large", "loc", "resource", "content", "search", "source", "home", "url", "master", "ip", "region", "exp", "owner", "out", "type", "connection", "root", "par", "any", "point", "line", "and", "manager"], "dir": ["url", "dec", "ver", "rel", "dep", "Dir", "exp", "dict", "inc", "container", "cur", "db", "path", "folder", "div", "keep", "name", "out", "ir", "lock", "doc", "lib", "build", "or", "r", "def", "root", "class", "directory", "attr", "rec", "DIR", "per", "loc", "block", "iter", "dc", "dis", "wd", "fd", "mod", "dr", "di", "col", "file", "dist", "d", "director", "coll", "die", "dev", "group", "cat", "home", "manager", "f"], "from": ["cm", "url", "de", "base", "ra", "client", "clean", "bean", "vol", "parse", "left", "e", "view", "ou", "io", "module", "when", "old", "one", "auto", "name", "conn", "out", "cr", "stream", "range", "start", "c", "link", "this", "self", "normal", "or", "component", "connection", "user", "so", "empty", "o", "with", "query", "per", "hand", "without", "flo", "fr", "wh", "api", "add", "by", "form", "get", "in", "who", "source", "channel", "file", "se", "ch", "low", "From", "con", "part", "can", "ce", "po"], "to": ["su", "two", "be", "eto", "base", "ver", "token", "cache", "output", "port", "io", "proxy", "not", "db", "one", "fb", "TO", "target", "auto", "out", "name", "on", "top", "no", "again", "tom", "or", "via", "type", "connection", "go", "b", "object", "To", "so", "o", "see", "co", "with", "sync", "flo", "office", "will", "api", "by", "plus", "copy", "store", "page", "http", "source", "op", "file", "too", "tto", "about", "until", "size", "fat", "pi", "po"], "buffer": ["Buffer", "address", "position", "result", "header", "uffer", "reader", "cache", "transfer", "feed", "vector", "available", "total", "default", "row", "border", "length", "string", "binary", "seed", "memory", "queue", "character", "read", "layer", "duration", "reference", "batch", "shape", "buf", "number", "null", "block", "padding", "table", "message", "iter", "resource", "bytes", "flush", "document", "page", "data", "channel", "server", "variable", "device", "value", "comment", "buff", "texture"], "bytes_read": ["classesavavailable", "bytesESSreceived", " bytes_load", "bytesavavailable", "classes_READ", "bytes___READ", "bytes_READ", "classes_available", "classesavview", " bytes_written", "lines_received", "classes_read", "lines_read", "bytesavview", "bytesavread", "classes_view", "bytesESSput", "bytes_available", "bytesESSread", "bytes_load", "lines_written", "bytes_received", " bytes_write", "bytes_put", "bytes_write", "bytes___view", "bytesavREAD", "bytesESSwritten", "bytes_written", "bytesayput", "lines_put", "bytes___read", "classesavREAD", "classesavread", "bytesayreceived", "bytesayread", "bytes_view", "bytesaywritten", "bytes___available"]}}
{"id1": "20128728", "id2": "13516684", "code1": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "moveStream", "movefile", "CopySourceFile", "CopyFile", "CopyStream", "copySourceFile", " copyfile", "moveFile", "Copyfile", "copyStream", "moveSourceFile", "copyfile", " copySourceFile"], "src": ["ource", "url", "sit", "st", "img", "path", "sl", "input", "filename", "start", "core", "conn", "s", "obj", "ls", "stream", "image", "upload", "files", "sel", "sb", "sq", "b", "buf", "front", "sin", "dest", "config", "loc", "inst", "uri", "inf", "rb", "rc", "in", "source", "server", "file", "sc", "download", "dist"], "dst": [" dft", "fdst", "idst", "ddest", "idut", "Dsts", "fput", "fdest", "dft", "Dput", " dut", "fdut", "Dst", "dput", "fsts", "fst", "idft", "fdsts", " ddest", " dput", "dsts", "Ddest", "dut", "fdft", " dsts", "idsts"], "inChannel": ["inClient", "outClient", "outQueue", "innerClient", " inchannel", "inputChan", " inQueue", "inChan", "inQueue", " inClient", "dinChannel", "innerChannel", "outChan", "dinchannel", "InChannel", "inchannel", "outchannel", "outStream", "inputchannel", "inputStream", "inputLanguage", "INChan", " inStream", "INchannel", "dinChan", "inStream", "INChannel", "InQueue", "innerStream", " inChan", "INStream", "dinLanguage", "InChan", "innerChan", "Inchannel", "inputChannel", "inLanguage", "INLanguage"], "outChannel": ["againChannel", "outputStream", "Outchannel", "outputChan", "outContext", " outConnection", "inChan", "OutStream", " outChan", "outputchannel", "againchannel", " outContext", "outChan", "OutConnection", "inchannel", "outchannel", "outputChannel", "outStream", "inSocket", "outConnection", "againStream", "inStream", "againChan", " outStream", "OutContext", "inConnection", " outchannel", "outSocket", "OutChan", " outSocket", "OutChannel", "inContext", "againSocket"]}}
{"id1": "6421904", "id2": "20920051", "code1": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"addRecord": [" addRec", "createRecord", "createFile", "addRec", " addFile", "createrecord", "appendRecord", " addrecord", "appendRec", "createRec", "appendFile", "addrecord", "appendrecord", "addFile"], "input": ["exec", "flow", "error", "reader", "audio", "php", "current", "load", "raw", "progress", "Input", "xml", "request", "session", "out", "conn", "context", "stream", "image", "this", "storage", "hole", "active", "null", "text", "back", "config", "buffer", "media", "resource", "inf", "form", "document", "http", "data", "source", "up", "instance", "value", "temp"], "temporary": ["temmanent", "transporary", "typoral", "Temperature", "Temmanent", "emporal", "theemporary", "emporary", "separporal", "temperature", "mporary", "typerature", "transperature", "timemporary", "Temporal", "separperature", "transolute", "semporary", "semporal", "thetemp", "timermanent", "tempporary", "tmporary", "temermanent", "exporal", "temolute", "formtemp", "timperature", "tempemporary", "tmperature", "tememporary", "destporal", "mporal", "temacher", "experature", "tporal", "tmemporary", "theermanent", "temptemp", "formmanent", "mperature", "theporal", "emperature", "exolute", "semperature", "tempperature", "tporary", "tytemp", "timporal", "temporal", "tmacher", "destemporary", "tomporal", "Temporary", "tommanent", "temtemp", "timolute", "tempporal", "timporary", "Temtemp", "semmanent", "formporal", "formporary", "separporary", "tymanent", "tacher", "tmtemp", "tmermanent", "theporary", "destporary", "theperature", "tmporal", "typorary", "tomporary", "transporal", "exporary", "destacher", "tomperature", "separmanent"], "tempId": ["tmpID", "tmpId", " tempid", "tmpPath", "TempPath", "inputId", "inputid", "TempId", "fakeid", "TempID", "tempid", "inputID", "fakeId", "tempID", "inputPath", "Tempid", "TempName", "poraryId", "tempName", "fakeName", "tempPath", "tmpid", " tempName", "poraryid"], "length": ["position", "url", "result", "audio", "description", "ob", "id", "load", "volume", "path", "total", "distance", "filename", "string", "sequence", "time", "name", "driver", "range", "angle", "lock", "section", "len", "write", "code", "read", "duration", "Length", "type", "count", "library", "shape", "number", "text", "offset", "slice", "loc", "array", "version", "key", "content", "l", "data", "width", "style", "download", "ext", "limit", "capacity", "value", "full", "json", "open", "size"], "digest": [" digested", "signEST", "fests", "digraph", "signest", "fester", " Digester", " digests", "generEST", " digraph", "digEST", "fest", " digester", "digester", " digEST", "decest", "digests", "signests", "DigEST", "digested", "Digester", "signester", "Digest", "decested", "digist", "signraph", "Digested", "generist", "Digist", "fraph", " DigEST", "generested", "decist", "signested", "generest", "decEST", " Digest"], "output": ["external", "address", "result", "console", "exit", "put", "log", "Output", "target", "export", "out", "binary", "queue", "image", "write", "tube", "plain", "operation", "writer", "connection", "application", "null", "object", "config", "socket", "outer", "message", "office", "resource", "copy", "document", "other", "data", "channel", "source", "letter", "unit", "web", "control", "response", "cut", "temp"], "file": ["FILE", "cache", "local", "e", "force", "id", "model", "path", "log", "filename", "name", "queue", "plain", "File", "show", "null", "directory", "message", "p", "document", "data", "letter", "server", "full", "f", "complete", "fp", "use", "feed", "child", "folder", "function", "string", "word", "lock", "fe", "or", "pe", "class", "user", "object", "rule", "buffer", "get", "http", "single", "l", "page", "pool", "let", "create", "open", "comment", "picture", "base", "place", "php", "zip", "current", "auto", "binary", "lib", "entity", "code", "per", "socket", "uri", "resource", "it", "source", "work", "dir", "home", "unit", "temp", "url", "view", "play", "time", "image", "ile", "this", "self", "type", "live", "connection", "real", "handler", "future", "other", "line", "up", "style", "po"], "parent": ["base", "master", "pa", "cache", "id", "port", "current", "child", "container", "path", "remote", " Parent", "parents", "out", "name", "location", "to", "image", "large", "or", "type", "root", "class", "null", "directory", "handler", "per", "block", "resource", "p", "key", "copy", "data", "source", "dir", "and", "create", "full", "Parent", "home", "part", "unit", "fat", "temp"], "now": ["first", " NOW", "gen", "view", "cycle", "id", "current", "load", "not", "cur", "always", "node", "start", "auto", "NOW", "max", "time", "next", "set", "this", "ci", "comp", "day", "or", "ct", "type", "info", "wait", "active", "today", "Now", "co", "ow", "currently", "post", "date", "once", "from", "age", "last", "low", "since", "night", "lim", "hour", "size", "cmp"]}}
{"id1": "838844", "id2": "17996547", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"convert": ["CONception", " deconversion", "Converted", "oconversion", "subversion", "CONverted", "unception", "subverting", "CONvert", "subverted", "unvert", "unverted", "Conception", "CONverting", " deconverting", "oconverted", "Conversion", "Converting", "CONversion", "oconvert", " deconverted", "conception", "converting", "subvert", "oconverting", "Convert", "conversion", "converted", "unversion", " deconvert"], "src": ["sys", "ource", "fp", "url", "sit", "prot", "st", "img", "reader", "gb", "tmp", "load", "cb", "proc", "scene", "path", "input", "filename", "string", "name", "obj", "s", "stream", "secure", "sth", "Source", "spec", "upload", "storage", "sel", "code", "username", "SourceFile", "ssl", "sb", "component", "Dest", "supp", "buf", "video", "sin", "attr", "back", "config", "loc", "slice", "inst", "sn", "uri", "resource", "rb", "feat", "rc", "href", "source", "fn", "sc", "file", "download", "ref", "RC", "gz", "dist", "req", "stage", "impl", "cpp", "rl", "ctx", "cmp"], "dest": ["disk", "test", "cont", "img", "bin", "tmp", "path", "target", "obj", "lib", "std", " dst", "Dest", "class", "dat", "orig", "null", "dc", "di", "source", "fn", "dir", "dist", " destination", "home", "txt", "temp"], "in": ["ins", "din", "reader", "IN", "login", "bin", "isin", "inc", "io", "ini", "val", "input", "In", "stream", "err", "doc", "inas", "t", "a", "i", "r", "ex", "n", "ps", "win", "inn", "inf", "pin", "is", "data", "source", "up", "file", "d", "pass", "as", "f"], "p": ["fp", "jp", "v", "pa", "tp", "bp", "e", "lp", "pre", "pm", "P", "py", "pr", "s", "cp", "c", "np", "m", "t", "j", "i", "r", "pe", "g", "b", "cop", "o", "ps", "per", "parser", "pd", "pg", "h", "wp", "l", "op", "pb", "d", "pc", "pp", "sp", "part", "f", "pi", "po"], "ds": ["posts", " DS", "eps", "dp", "ths", "vs", "els", "os", " ps", "dat", "ps", " sd", "pd", "uds", "data", "qs", "utils", "points", "rs", "services", "da", "groups", "db", "docs", "s", "ls", "hs", "words", "ys", "models", "cs", "ans", "di", "ld", "cons", "gs", "ins", "xs", "ges", "ts", "nas", "ks", "sts", "ded", "lines", "vals", "js", "ups", "plugins", "dates", "ants", "dds", "ss", "scripts", "tests", "ils", "ads", "sys", "Ds", "ays", "dl", "lp", "tools", "df", "ns", "styles", "dd", "gd", "des", "dos", "sync", " props", "dc", "parts", "dt", "obs", "dist", "amps", "d", "DS", "icks", "dm", "ipes", "bs"], "format": ["template", "atter", "url", "fp", "magic", "model", "path", "function", "plugin", "host", "pattern", "filename", "string", "nat", "language", "struct", "name", "prefix", "spec", "t", "type", "at", "Format", "class", "tag", "handler", "config", "layout", "sche", "table", "parser", "api", "version", "scale", "form", "feat", "fd", "data", "source", "file", "filter", "letter", "ant", "fn", "style", "act", "frame", "unit", "part", "record", "f"], "hasPixelData": ["hasByteData", "showsPixelDATA", "hasPictureSize", "haspixelSize", " hasPixelSize", " hasPixeldata", "showsByteData", "showsByteStyle", "showsBytedata", "showsPixeldata", "hasPixelSize", "hasPicturedata", "showsPixelStyle", "hasByteSize", "hasPixelDATA", "hasPictureData", "hasPixeldata", "hasByteStyle", "haspixelData", "showsByteDATA", "haspixeldata", "hasPixelStyle", "hasBytedata", "showsPixelData", "hasByteDATA"], "inflate": ["inflace", "invenATE", "Inflation", "inFlate", "inflating", "infolode", "insvenate", "inFlation", "insvenATE", "invenode", "insvenating", "inflated", "Inflated", "inadequode", "inadequate", "inffation", "invenate", "insflate", "inflATE", "Inflate", "infloated", "inFlated", "infface", "InFlate", "insflATE", "Inflace", "InFlace", "inadequATE", "insflating", "inFlace", "infloate", "InFlation", "infloation", "insvenode", "inflode", "infolATE", "infloace", "inffate", "infolate", "inflation", "invenating", "inadequating", "InFlated", "insflode", "infolating", "inffated"], "pxlen": ["mxlen", "pxsize", "mxdata", "fxlen", "pgLen", "mxcount", "pgl", "fxden", "pxdata", "fxl", "axlon", "pxl", "pxlength", "pxlon", "pnglength", "xpsize", "pplen", "mxsize", "txlon", "axln", "pclin", "camlen", "pxLen", "camdata", "fxLen", "pxden", "pglen", "pxcount", "pxpos", "fxpos", "pclen", "txlen", "pxln", "pxlin", "campos", "txln", "fxdata", "pclon", "camln", "txlin", "xplen", "xplength", "fxln", "axlin", "ppden", "mxlength", "ppl", "pgden", "pnglen", "ppLen", "pngsize", "mxpos", "pngcount", "axlen", "xpcount", "mxln", "pcln"], "out": ["sys", "v", "error", "OUT", "outs", "cache", "gen", "re", "output", "io", "log", "session", "conn", "obj", "state", "lock", "err", "Out", "step", "lib", "user", "again", "parent", "co", "query", "list", "pad", "post", "copy", "point", "store", "cli", "line", "work", "up", "server", "page", "dump", "group", "inter"]}}
{"id1": "15745420", "id2": "12171364", "code1": "    private void download(String address, String localFileName) throws UrlNotFoundException, Exception {\n        String ext = G_File.getExtensao(address);\n        if (ext.equals(\"jsp\")) {\n            throw new Exception(\"Erro ao baixar pagina JSP, tipo negado.\" + address);\n        }\n        File temp = new File(localFileName + \".tmp\");\n        if (temp.exists()) temp.delete();\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            try {\n                URL url = new URL(address);\n                conn = url.openConnection();\n                in = conn.getInputStream();\n            } catch (FileNotFoundException e2) {\n                throw new UrlNotFoundException();\n            }\n            out = new BufferedOutputStream(new FileOutputStream(temp));\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n        } catch (UrlNotFoundException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        File oldArq = new File(localFileName);\n        if (oldArq.exists()) {\n            oldArq.delete();\n        }\n        oldArq = null;\n        File nomeFinal = new File(localFileName);\n        temp.renameTo(nomeFinal);\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"download": ["exec", " Download", "save", "handle", "transfer", "output", "zip", "load", "Download", " upload", "binary", "archive", "upload", "release", "update", "copy", "data", "process", " downloading", "source", "append", "gz", "dump", "register", "open", " transfer"], "address": ["position", "Address", "base", "ip", "enter", "output", "region", "port", "ace", "ress", "path", "request", "remote", "index", "host", "pointer", "location", "string", "name", "target", "image", "prefix", "order", "type", "mode", "reference", "route", "number", "object", "config", "message", "uri", "array", "resource", "attribute", "service", "key", "content", "point", "page", "data", "source", "addr", "server", "email", "localhost"], "localFileName": ["localFileLocation", "localPageType", "localfileType", "localFileAddress", "localFilePath", "localPlacename", " localFileSize", "localFilenameLocation", "localStreamName", "localPagePath", " localFileInfo", "localFileNames", "localDirInfo", "localImageName", "globalFileName", "localFilesName", "localfileLocation", "localSourceFileAddress", "localPageName", "localStreamname", " localPageSize", "localFileType", " localPlaceName", "localFilenameName", "localSourceFileType", "localSourceFileLocation", "localPlaceName", "localPlacePath", "localFileSize", " localPlaceLocation", "globalSourceFileAddress", "localSourceFilePath", "localSourceFileNames", "localDirAddress", " localFilename", "LocalSourceFileNames", "globalFilePath", "LocalFileLocation", "localFilesInfo", "localFilesPath", "LocalFileName", "localImageSize", "localSourceFileSize", "localFilenameNames", "localSourceFileInfo", " localPlacePath", "LocalFileType", " localFileType", "LocalSourceFileName", "globalFileInfo", "globalSourceFileName", "localPlaceLocation", "localDirName", "LocalSourceFileType", " localPageName", "localSourceFileName", "localImageInfo", " localPlacename", "localStreamPath", "localStreamLocation", "localfileName", "localFilesAddress", "globalSourceFilePath", "localPageInfo", "localFileInfo", "localPageLocation", "localDirPath", " localFileLocation", "localFilenameType", "LocalFileNames", "LocalSourceFileLocation", " localPageInfo", "localPageSize", "globalSourceFileInfo", "localPagename", "globalFileAddress", " localFilePath", " localPageType", "localfileNames", "localImageType", "localFilename"], "ext": ["fort", "prot", "test", "str", "app", "exp", "zip", "expl", "xp", "path", "x", "alt", "string", "name", "Ext", "word", "err", "ect", "extra", "format", "type", "xt", "info", "fx", "ex", "text", "config", "enc", "EXT", "content", "data", "file", "addr", "dist", "qt", "req", "txt", "f"], "temp": ["template", "emp", "v", " temporary", "test", "base", "wrap", "cache", "tp", "clean", "local", "now", "w", "output", "tmp", "zip", "valid", "wl", "old", "folder", "Tem", "input", "er", "flat", "session", "cp", "original", "memory", "lock", "c", "tem", "this", "porary", "t", "null", "ex", "parent", "empty", "stable", "pipe", "loc", "iter", "api", "mount", "p", "it", "form", "store", "wp", "txt", "data", "source", "file", "server", "Temp", "ht", "full", "home", "unit", "fake", "f"], "out": ["exec", "net", "on", "OUT", "client", "outs", "w", "login", "call", "output", "bin", "exp", "io", "inc", "not", "log", "obj", "s", "In", "inner", "name", "lock", "write", "err", "prefix", "off", "image", "Out", "plain", "this", "lib", "or", "ssl", "writer", "connection", "i", "b", "null", "again", "ex", "o", "parent", "socket", "sync", "outer", "key", "copy", "other", "line", "cli", "file", "up", "server", "password", "init", "and", "con", "part", "Output"], "conn": ["exec", "fp", "cm", "client", "ai", "uc", "cache", "URL", "inc", "func", "connect", "Url", "conv", "cp", "cmd", "obj", "c", "ci", "nn", "ct", "ssl", "connection", "Connection", "b", "n", "ll", "enc", "config", "socket", "nt", "sync", "fr", "open", "close", "l", "cli", "ch", "cn", "server", "act", "init", "coll", "con", "nc", "ac", "Conn", "impl"], "in": ["exec", "ins", "din", "reader", "IN", "client", "login", "bin", "id", "isin", "inc", "ini", "index", "input", "In", "s", "inner", "lock", "image", "lib", "or", "i", "connection", "r", "n", "again", "pull", "socket", "diff", "sync", "nin", "win", "inn", "min", "pin", "get", "by", "it", "is", "l", "lin", "cli", "data", "source", "init", "cin", "up", "kin", "con", "ac", "part", "f"], "url": ["base", "client", "ob", "URL", "db", "path", "sl", "Url", "host", "ls", "string", "image", "layer", "ssl", "connection", "i", "r", "b", "n", "ll", "cdn", "www", "loc", "socket", "uri", "bel", "http", "l", "source", "file", "channel", "server", "impl", "open", "web", "rl", "blog", "f"], "buffer": ["Buffer", "uf", "position", "result", "slave", "uffer", "reader", "cache", "bb", "bin", "transfer", "FFER", "feed", "row", "input", "border", "length", "sequence", "binary", "offset", "memory", "queue", "read", "layer", "reference", "batch", "b", "number", "buf", "null", "slice", "block", "pad", "padding", "iter", "message", "bytes", "wave", "flush", "data", "limit", "value", "comment", "buff"], "numRead": ["numWrite", "nBuild", "NumReader", " numBuild", "Numread", "nRead", "umRead", "numBuild", "numReader", "NumWrite", "numberBuild", "numread", "umWritten", "umWrite", "numberRead", "NumWritten", "commonWrite", " numWrite", "commonReader", "nWritten", " numReader", "nread", "NumRead", "commonRead", "numberWritten", " numread", "commonWritten", "nWrite", "numberread"], "numWritten": ["numwritten", "numWrite", "numberOutput", "numWrit", "NumOutput", "multiWrit", "multiWritten", " numOutput", "numOutput", "NumWrite", "multiwritten", " numwritten", "numberWrite", "numberRead", "NumWritten", " numWrite", "NumRead", "multiWrite", "numberWritten", " numWrit", "NumWrit", "Numwritten"], "oldArq": ["oldARg", "oldARqs", "OldArqu", "oldAcque", "oldAcp", "oldARQ", "OldARqu", "OldArque", "OldArp", "oldArp", "oldAcq", " oldParg", " oldArQ", "oldarqu", "oldarch", " oldParque", "oldArQ", "oldDarque", "oldArqs", "OldARQ", "oldAcQ", "oldArque", "oldArch", "oldARqu", "oldarq", "OldAcq", "oldArtQ", "oldARquest", "oldParg", "OldArq", "OldAcqs", "oldArg", " oldParq", "oldArtqs", "oldArtque", "oldDarch", " oldArg", "OldArQ", "oldParq", " oldParQ", "OldARp", "oldArquest", "OldAcQ", "oldarQ", "OldAcquest", "OldArquest", "OldARch", "oldARch", "oldArtp", "oldAcquest", "OldARq", "oldarque", "oldDarq", "OldArqs", "oldDarqu", "oldParque", "oldarg", "oldParQ", "oldARq", "oldARp", "oldArtquest", "oldAcqs", "OldARque", "oldArtq", " oldArque", "oldARque", "oldArqu", "OldArch"], "nomeFinal": ["nomesfinal", "nomenFinal", "nukeFin", " nomesFin", "nukeFinal", "nomenFin", "nukefinal", "naveFinal", "NomeFinal", " nomesfinal", " nomesFinal", "nomefinal", "nomesFin", "nomeFin", "Nomesfinal", "NomesFinal", "noeFinal", " nomeFin", "noefinal", "nomenfinal", " nomefinal", "Nomefinal", "nomesFinal", "navefinal"]}}
{"id1": "8515891", "id2": "20519261", "code1": "    protected String readUrl(String svnUrl) throws IOException {\n        URL url = new URL(svnUrl);\n        URLConnection uc = url.openConnection();\n        if (url.getProtocol().equals(\"https\")) {\n            String userPassword = user + \":\" + password;\n            String encoding = new sun.misc.BASE64Encoder().encode(userPassword.getBytes());\n            uc.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        InputStream is = null;\n        String in = null;\n        try {\n            is = uc.getInputStream();\n            in = read(is);\n        } finally {\n            try {\n                is.close();\n            } catch (Exception e) {\n            }\n        }\n        return in;\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 0, "substitutes": {"readUrl": ["processQuery", "readURL", "ReadUrl", "readQuery", "getUrl", "processPage", "ReadPage", "processURL", "readPage", "processUrl", "getQuery", "getURL", "ReadQuery", "ReadURL", "getPage"], "svnUrl": ["svlEl", "svpnUrl", "svnUr", "svNURL", "svnFile", "svpnFile", "svcnURL", "svNEl", " svnUr", " svNURL", " svNUrl", "svlURL", " svnStr", "svcnStr", " svnEl", " svnFile", " svnURL", "svbUr", "svpnUr", " svNUr", "svlUrl", "svnURL", "svNStr", " svNStr", " svNFile", "svlStr", "svNFile", "svbUrl", "svnEl", "svNUr", "svNUrl", "svnStr", "svcnUrl", " svNEl", "svbFile", "svcnEl", "svpnURL", "svbURL"], "url": ["bc", "cl", "client", "util", "bb", "ob", "feed", "URL", "cur", "path", "log", "sl", "Url", "context", "conn", "stream", "bug", "c", "this", "org", "ssl", "connection", "r", "user", "b", "www", "config", "fc", "pull", "loc", "ur", "ul", "uri", "resource", "http", "plug", "l", "page", "server", "up", "open", "web", "blog", "f"], "uc": ["exec", "us", "bc", "cl", "cf", "lc", "mc", "client", "uci", "cur", "roc", "tc", "connect", "oc", "conn", "cci", "soc", "cp", "bug", "c", "cc", "hub", "ec", "ssl", "connection", "auc", "uca", "cu", "ub", "co", "fc", "loc", "anc", "ul", "uri", "UC", "cas", "ucc", "http", "rc", "sc", "up", "userc", "pc", "coll", "ac", "con", "usc", "ocr"], "userPassword": ["userpassword", "Userpassword", "useAuth", "currentpassword", " userPass", "userAuth", "useSecret", " userSecret", "usepassword", "UserAuth", "currentPass", "usePassword", "userPass", " userAuth", "userSecret", " userpassword", "usePass", "UserPass", "currentPassword", "UserPassword", "currentSecret"], "encoding": ["encoder", "enoding", "Encoded", "Encasing", "engoding", "encoded", "engasing", " encoded", "enasing", "Encording", "engoder", "Encoder", "enoded", " encoder", "encasing", "engoded", "encording", "Encoding", " encording", "enording", "enoder"], "is": ["us", "serv", "ais", "ins", "ip", "ms", "ib", "ois", "iso", "id", "isa", "was", "are", "has", "IS", "bis", "vs", "ws", "Is", "es", "abs", "ir", "out", "ui", "ls", "ris", "s", "ci", "isl", "si", "iss", "ios", "os", "nis", "ori", "i", "info", "ie", "irc", "cs", "lis", "isc", "isi", "ri", "uri", "fs", "api", "it", "its", "iris", "init", "src", "as"], "in": ["gin", "ins", "din", "reader", "IN", "atin", "login", "re", "bin", "id", "isin", "inc", "raw", "vin", "ini", "input", "out", "In", "string", "inner", "inas", "oin", "read", "m", "i", "edIn", "again", "rec", "tin", "nin", "inn", "pin", "into", "cin", "source", "line", "arin", "inside", "kin", "rin", "pc", "con", "reading", "f"]}}
{"id1": "19810820", "id2": "9033639", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"copyFileChannel": ["transferfilechannel", "copyfileChannel", "transferfileChannel", "copyfileStream", "copyStreamChannel", "copyStreamStream", "transferFileStream", "copyfileChan", "copyfilechannel", "copyDirectorychannel", "copyDirectoryChannel", "transferFileChan", "copyFilechannel", "transferfileStream", "copyDirectoryStream", "transferFilechannel", "transferFileChannel", "copyStreamchannel", "transferfileChan", "copyDirectoryChan", "copyFileStream", "copyStreamChan", "copyFileChan"], "src": ["sys", "rest", "url", "sit", "st", "img", "client", "sup", "tmp", "sub", "cur", "scene", "path", "func", "sl", "input", "filename", "start", "conn", "s", "ls", "stream", "sth", "Source", "lower", "upload", "ruby", "ses", "sel", "ssl", "sb", "sq", "b", "sin", "dest", "config", "loc", "slice", "sync", "inst", "rb", "rc", "source", "server", "sc", "dist", "download", "RC", "ctx", "rs", "SOURCE"], "dst": ["fdput", "fdst", " dST", "DST", "bst", "tst", "bput", "fdrc", "Dost", "ddest", "stST", "bST", "start", "brc", "ldost", "dST", "drc", "lddest", "tlt", "adput", "adrc", "dlt", "dost", "bart", "dart", "Dst", "ldst", " dost", "blt", "ldST", "tST", "fdST", "adst", " ddest", "stst", "stlt", "adST", "Ddest", "tart", "dput"], "preserveModificationTime": ["preserveModifiedTime", "preserveMinifiedtime", "preserveModationFile", "preserveModifyingTime", "preserveModationTime", "preserveModifytime", "preserveMinificationtime", "preserveMinificationFile", "preserveModifyTime", "preserveMinifiedFile", "preserveModificationtime", "preserveMinifiedTime", "preserveModificationFile", "preserveModifiedFile", "preserveModifyingtime", "preserveModifyingFile", "preserveModifiedtime", "preserveModationtime", "preserveMinificationTime"], "inputChannel": ["inputSocket", "Inputchannel", "outputStream", " inputConnection", "outputBuffer", "requestChan", "outputChan", "inputChan", "outputConsole", "imagechannel", " inputStream", "fileConsole", "outputchannel", " inputBuffer", "inputGate", "outputCache", " inputCode", " inputchannel", "outputConnection", "InputChannel", "inputCode", " inputChan", "requestCode", "outputSocket", "binarychannel", "imageChan", "requestChannel", "inputConnection", "inputStream", "inputchannel", "binaryGate", "binaryChan", "fileChannel", "inputConsole", " inputConsole", "fileConnection", "outputCode", "errorStream", "errorCache", "imageGate", "InputSocket", "InputChan", "binaryChannel", "InputBuffer", "requestStream", "outputGate", "InputQueue", "errorChannel", "errorChan", "inputQueue", "outputQueue", "inputBuffer", "inputCache", " inputQueue", "fileChan", " inputSocket", "imageChannel", " inputCache"], "outputChannel": ["inputManager", " outputButton", "writeChan", "OutputChan", "outputStream", "OutputQueue", "writeStream", "outputChan", "inputChan", "outputchannel", " outputStream", "OutputChannel", "outChan", " outputChan", "outchannel", "outStream", "OutputStream", "outButton", "inputStream", "outputButton", "writeManager", "writeChannel", " outputQueue", " outputchannel", "writeQueue", "outputQueue", "inputButton", "Outputchannel", " outputManager", "outChannel", "outputManager"], "length": ["complete", "slave", "position", "result", "base", "php", "id", "current", "load", "child", "available", "volume", "session", "start", "sequence", "max", "offset", "end", "section", "lock", "len", "next", "build", "duration", "Length", "type", "count", "number", "text", "head", "join", "with", "pull", "block", "buffer", "delay", "form", "l", "last", "style", "width", "limit", "value", "full", "part", "sum", "size", "partial"], "total": ["complete", "less", "result", "base", "error", "found", "id", "current", "valid", "available", "cur", "always", "start", "max", "offset", "multi", "set", "no", "len", "toc", "failed", "all", "duration", "type", "otal", "count", "i", "used", "info", "Total", "done", "scale", "key", "translation", "last", "limit", "full", "part", "sum", "size", "partial"]}}
{"id1": "8062076", "id2": "12306305", "code1": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 0, "substitutes": {"updateUser": ["updatePerson", "UpdateAccount", "UpdateRole", "UPDATERole", "UpdateUser", "updateRole", "UPDATEAccount", "changeUser", "changePerson", "updateAccount", "UpdatePerson", "changeAccount", "UPDATEPerson", "changeRole", "UPDATEUser"], "portalUserBean": ["portalUserBEam", "portalUserPeane", "portalFileBAN", "portalUserDeAN", "portalUserPeean", "portalGroupBeans", "portalUserPean", "portalUserEan", "portalGroupBEans", "portalUserBoin", "portalUserBeAN", "portalUserBEan", "portalUserEAN", "portalUserBane", "portalUserPlean", "portalUserBeane", "portalGroupBean", "portalUserBeam", "portalGroupBEAN", "portalUserPlane", "portalFileBane", "portalFileBin", "portalUserDeans", "portalFileBeAN", "portalClientBeane", "portalUserBoane", "portalUserDean", "portalUserBoan", "portalUserBann", "portalUserBEane", "portalUserBoam", "portalUserBeans", "portalClientBEans", "portalUserBans", "portalUserBin", "portalFileBeane", "portalUserBEann", "portalUserBEans", "portalUserDeane", "portalClientBEAN", "portalUserBEAN", "portalUserBegann", "portalUserBeean", "portalUserBegan", "portalUserBam", "portalClientBEan", "portalUserBoAN", "portalUserPlAN", "portalClientBean", "portalFileBean", "portalUserPeans", "portalUserPlan", "portalFileBan", "portalUserBeann", "portalFileBans", "portalUserBein", "portalUserPeAN", "portalFileBeean", "portalClientBeAN", "portalUserEans", "portalClientBeam", "portalUserBegAN", "portalUserEane", "portalGroupBeAN", "portalClientBEane", "portalUserEin", "portalUserBegans", "portalUserBan", "portalUserBoans", "portalGroupBEan", "portalFileBein", "portalClientBeans", "portalGroupBeann", "portalUserBAN", "portalFileBeans", "portalGroupBEann", "portalClientBEam"], "authSession": [" authsession", " authConn", "authConnection", "uthClient", " authConnection", "uthSession", "AuthClient", "AuthSession", "authClient", "Authsession", "uthConn", "AuthConn", "httpsession", "httpConnection", "authStream", "httpStream", "AuthStream", "AuthConnection", " authStream", "authsession", "authConn", " authClient", "httpSession", "uthsession"], "dbDyn": ["dbdYN", "dbBsyn", "dbSyn", "dbCodyn", "dbByr", "cbBien", "dbDoyan", "libDys", " dbBsyn", "dbDsyn", "bbDYN", "dbdyn", "DbPyr", "DbSyn", "dbIyan", "dbFyr", "dbCym", "dbNYN", "DbSyl", "cbDien", "dbCodyr", "dbFsyn", "dbCynam", "dbPyr", "DbDyl", "dbDoynam", " dbDoynam", "DbCYN", "dbDoyn", "dbDoyr", "cbDYN", "dbDoneYN", "dbDefym", "cbByn", "dbWYN", "dbDefys", "dbBSyn", "bbDyn", "dbBYN", "dbCYN", "dbBynam", "dbdgn", "dbIsyn", "DbDYN", "dbWyn", "dbDosyn", "dbFYN", "DbCyn", "dbFyn", "bbFyn", "dbCyn", "dbBien", "cbBYN", "cbBynam", "dbWsyn", " dbBynam", "dbCodSyn", "DbCynam", "dbDoneyn", " dbDoyan", " dbByr", "dbDSyn", "DbPSyn", "DbPyn", "DbDyr", "dbWSyn", "DbDahn", "dbCSyn", "dbSyl", "dbDefSyn", "dbByn", "dbPahn", "bbDSyn", "dbdynam", "dbFSyn", "dbdyl", "bbFSyn", "dbBahn", "dbDgn", "dbIynam", " dbDyan", "cbDynam", "dbDyl", "dbDynam", "libDSyn", "libDym", "dbIyn", "bbFsyn", "dbPyn", "dbDym", "libDyn", " dbDyr", "dbNyl", "dbDyr", "dbDien", "dbFynam", "dbDoneien", "DbDSyn", "dbdSyn", " dbDsyn", "dbSgn", "DbCSyn", "dbNyn", "dbNgn", "DbDyn", "dbDefyn", "dbPSyn", "cbDyn", "bbDsyn", " dbDosyn", "DbSgn", "dbDYN", "dbCys", "DbSYN", "bbFYN", " dbByn", "dbDahn", " dbDynam", "DbPahn", "dbSYN", "DbDynam", "dbDoneynam", " dbDoyn", "DbDgn", "dbDyan", "dbDys", "dbFyan", "dbCodahn"], "ps": ["jp", "posts", "ins", "pa", "ms", "eps", "pse", "PS", "pre", "ts", "proxy", "rs", "ils", "vs", "ws", "py", "ns", "res", "ks", "s", "ls", "lines", "this", "Ps", "pl", "fe", "where", "os", "pers", "PD", "pps", "hs", "als", "properties", "ras", "pe", "js", "cs", "ops", "cop", "ppa", "ups", "per", "css", "post", "ds", "aps", "fs", "p", "les", "pg", "ips", "http", "its", "ons", "pb", "ports", "qs", "pos", "pc", "pp", "details", "as", "sp", "ss", "pes", "bs", "mp", "gs", "pr", "po"], "sql": ["sys", "csv", "su", "fp", "url", "sol", "sv", "params", "description", "util", "job", "rel", "eps", "str", "dl", "ob", "id", "zip", "shell", "db", "log", "function", "nl", "SQL", "sl", "session", "string", "conn", "ls", "s", "seed", "ln", "pr", " SQL", "lock", "setup", "spec", "serial", "os", "sg", "ssl", "sq", "sb", "repl", "html", "ql", "printf", "ll", "join", "query", "sync", "general", "http", "l", "fn", "details", "statement", "sf", "comment", "select", "msg", "acl"], "idList": ["addressLIST", "idSet", "IdList", "IdTree", "userLIST", "dateList", "userSet", "idTree", "IdColl", "dateColl", "userList", " idColl", "IdSet", " idInfo", "dateInfo", "IdLIST", "userlist", "dateTree", "IdInfo", " idTree", "idlist", "idInfo", "addressList", "addresslist", "idLIST", "idColl", "addressSet", "Idlist"], "num": ["su", "sol", "result", "gen", "nb", "inc", "Num", "one", "nov", "um", "gru", "div", "index", "nom", "node", "nr", "nam", "uni", "umi", "multi", "off", "nn", "len", "no", "np", "hex", "dim", "mon", "miss", "numbered", "norm", "i", "count", "NUM", "number", "n", "nu", "mult", "oct", "loc", "ord", "begin", "lang", "sn", "du", "dom", "form", "mn", "non", "fn", "init", "pos", "coord", "loop", "con", "lim", "unit", "sum", "size", "zero", "uu", "temp"], "i1": ["I1", " i11", "I5", "i81", "I0", "ii11", "xi81", "ii4", "I81", " i81", "xi11", " i0", "ci0", "i0", "ii81", "i4", "i11", "xi4", " i4", "ii1", "i5", " i5", "ci5", "ci1", "xi1", "ci81"]}}
{"id1": "8216539", "id2": "21827619", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"getFileContentAsString": ["getFileContentasStream", "getFileContentAsStr", "getFilecontentInStr", "getFileContentasText", "getFilecontentInStream", "getFileContentasString", "getFileContentInStr", "getFileContentFromText", "getFileContentAsText", "getFileContentAsStream", "getFilecontentAsString", "getFileContentFromStr", "getFileContentFromString", "getFileContentInStream", "getFilecontentAsText", "getFileContentFromStream", "getFilecontentInText", "getFileContentInText", "getFileContentasStr", "getFilecontentAsStr", "getFileContentInString", "getFilecontentInString", "getFilecontentAsStream"], "filePath": ["fileStr", "singlepath", "baseLocation", "FileStr", "baseUrl", "FileUrl", "fileLocation", " fileUrl", "resourcepath", "FileName", "Filepath", "basepath", "FileLocation", " fileStr", "basePath", "baseName", "FilePath", "filepath", "singlePath", "resourcePath", "baseStr", "singleUrl", "singleLocation", "resourceLocation", "fileUrl", "resourceName", " filepath", "fileName"], "encoding": ["Encging", "decoding", "equoding", "coding", "Encoded", "equpling", "encpling", "Encryption", "Encasing", "encging", "decasing", "encoded", "languageging", "casing", "languagepling", "decoded", "encryption", "Enclocking", "Encpling", "languagelocking", "enclocking", "equging", "encasing", "coded", "decryption", "languageoding", "Encoding", "equlocking", "cryption"], "testURL": ["appUR", " testUrl", "testingTL", "testUrl", "testURI", "testUR", "testingRL", "appURL", "testurl", " testRL", " testURI", "testTL", "fileRL", "Testurl", "appUrl", "shortTL", "shorturl", "TestUrl", "testingurl", " testurl", "TestUR", "fileURL", "shortUrl", "testingURI", "fileURI", "testingUR", "testingURL", "appurl", "TestURL", "fileUrl", "testingUrl", "shortURL", " testTL", "testRL"], "input": ["exec", "flow", "url", "result", "error", "img", "reader", "client", "audio", "output", "bin", "ou", "current", "inc", "feed", "raw", "Input", "path", "xml", "but", "out", "conn", "binary", "stream", "inner", "image", "this", "upload", "acl", "type", "ssl", "i", "connection", "active", "element", "null", "text", "parent", "enc", "config", "socket", "pull", "through", "dc", "resource", "inf", "wrapper", "api", "form", "get", "http", "rc", "in", "data", "source", "act", "qa", "entry", "file", "inside", "init", "instance", "op", "ac", "ink", "ack", "temp"], "sw": ["wt", "fp", "sv", "tw", "wrap", "aw", "w", "now", "ib", " SW", "io", "ws", "sl", "cr", "wx", "stream", "hw", "rew", "ww", "rw", "sm", "sa", "wr", "we", "en", "writer", "sb", "sk", "rx", "SW", "WS", "ow", "ew", "wb", "nw", "sn", "wrapper", "wp", "iw", "sh", "rc", "work", "sc", "web", "sf", "Sw"]}}
{"id1": "19738435", "id2": "23677142", "code1": "    public Resource parse(URL url, IRDFContainer target) throws RDFException, IOException {\n        parseURL = url;\n        URLConnection connection = url.openConnection();\n        if (charset == null) {\n            charset = Charset.forName(\"UTF-8\");\n        }\n        Reader reader = new InputStreamReader(connection.getInputStream(), charset);\n        return internalParse(reader, target);\n    }\n", "code2": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "label": 0, "substitutes": {"parse": ["apply", "load", "replace", "request", "start", "set", "link", "read", "format", "Parser", "find", "arse", "parser", "pack", "resource", "add", "get", "from", " parser", "match", "process", "se", "source", "create", "instance", "open", "run"], "url": ["address", "base", "error", "client", "absolute", "str", "e", "feed", "io", "URL", "proxy", "path", "request", "input", "Url", "location", "string", "conn", "host", "stream", "image", "link", "ssl", "element", "r", "object", "text", "config", "loader", "ur", "buffer", "uri", "resource", "api", "document", "http", "l", " URL", "source", "file", "server", "entry", "page", "channel", "src"], "target": ["address", "result", "arget", "project", "output", "current", "container", "path", " Target", "node", "pointer", "context", "host", "to", "resources", "this", "format", "t", "Target", "reference", "component", "event", "class", "root", "object", "parent", "config", "timeout", "resource", "content", "document", "source", "data", "collection", "ctx", "response"], "parseURL": ["parserType", "parseResource", "readURL", "parseUrl", "parserUrl", "parseType", " parseUrl", "parserURL", " parseResource", "readUrl", "readResource", " parseType", "parserResource", "readType"], "connection": ["bc", "client", "connected", "which", "io", "container", "db", "function", "creator", "connect", "conn", "out", "context", "section", "c", "database", "character", "normal", "or", "writer", "Connection", "application", "text", "directory", "body", "handler", "config", "uri", "service", "resource", "timeout", "ion", "source", "channel", "pool", "director", "con", "open", "ctx", "response", "relation"], "charset": ["choipsET", "charsetter", "Charsect", "chasec", "chansET", "chansec", "Chasec", "Charset", "Charsec", "Charsetter", "chARSect", "ChARSet", "choipset", "chaseting", "chasets", "chipsET", "chipseting", "ChARSec", "chaset", "chARSET", "CharsET", "chipsets", "chipset", "ChARSect", "chARSec", "Chasetter", "choarset", "chansect", "choipseting", "charsets", "chipsect", "chaptersetter", "chasetter", "chARSet", "choipsets", "charsET", "chapterset", "Chaset", "chasET", "choarseting", "chaptersec", "choarsets", "choarsET", "charseting", "charsect", "chARSetter", "chaptersET", "charsec", "chanset", "chipsec", "ChasET", "ChARSET"], "reader": ["feed", "io", "container", "rr", "worker", "x", "ler", "row", "input", "er", "pointer", "context", "stream", "driver", "keeper", "read", "Reader", "or", "writer", "r", "i", "object", "handler", "oder", "per", "loader", "parser", "iter", "resource", "in", "data", "channel", "source", "entry", "server", "director", "rar", "reading"]}}
{"id1": "2668853", "id2": "19096138", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFiletoStream", "decodeStringToFile", "decodeFile2Stream", "decodeFile2Files", "decodeStringToStream", "decodeFileAsFiles", "decodeFiletofile", "decodeStringToFiles", "decodeString2file", "decodeFileToStream", "decodeString2File", "decodeFileTofile", "decodeStringTofile", "decodeFiletoFiles", "decodeFile2file", "decodeFileAsFile", "decodeString2Stream", "decodeFiletoFile", "decodeFileToFiles", "decodeFile2File", "decodeString2Files", "decodeFileAsStream", "decodeFileAsfile"], "infile": ["minfp", "infiles", "inputFile", " inFile", "inFile", "minfilename", "outFile", "inputfiles", "infilename", "outfilename", "minfile", " infilename", "outfiles", "inputfp", "infp", " infiles", "inputfilename", "outfp", "inputfile", "minFile"], "outfile": ["outfull", "outputfilename", " outfull", "infolder", "Outfull", "Outfolder", "outFile", "outfolder", " outfolder", "infilename", "outfilename", "outputfp", " outFile", "outputfile", " outfilename", " outfp", "infp", "OutFile", "outputfolder", "Outfile", "outfp", "outputfull", "outputFile"], "in": ["gin", "ins", "din", "reader", "IN", "re", "login", "bin", "e", "inc", "ini", "input", "ic", "In", "s", "conn", "inner", "image", "err", "this", "inas", "m", "a", "i", "r", "b", "ex", "again", "socket", "nin", "win", "inn", "min", "pin", "is", "cin", "data", "source", "up", "lin", "init", "inside", "rin", "con", "ac", "as", "f"], "out": ["net", "exec", "on", "base", "error", "OUT", "client", "outs", "cache", "output", "bin", "exp", "io", "inc", "session", "target", "conn", "obj", "ext", "s", "inner", "In", "to", "lock", "write", "no", "off", "err", "image", "Out", "lib", "writer", "b", "ex", "again", "o", "co", "sync", "socket", "post", "outer", "name", "point", "copy", "other", "line", "work", "file", "up", "op", "pass", "home", "as", "exit"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "bb", "bin", "transfer", "pause", "feed", "row", "input", "border", "length", "seed", "binary", "offset", "memory", "queue", "layer", "reference", "batch", "b", "shape", "buf", "null", "slice", "pad", "padding", "iter", "resource", "bytes", "wave", "flush", "data", "source", "server", "limit", "value", "split", "size", "buff"], "read": [" Read", " copy", " sleep", "id", "inc", "start", "length", " load", "wait", " parse", "READ", "tell", " write", " reader", "limit", "size", " check", " reach", "allow", "use", "feed", " find", "check", "x", "input", " r", "seek", "write", "Read", "get", "reads", "open", "run", "k", "reader", "parse", "lex", " use", "current", "skip", "connect", "count", "fill", "find", "copy", "sleep", "work", "reading", " receive", "exec", "send", " connect", "load", "index", "play", "ind", "end", "next", " send", "ride", "r", "sync", " get", "ad", "iter", "add", "line", " ride", "se", "pass", " request", "select"], "success": ["complete", "first", "result", "error", "cess", "job", "fast", "status", "ccess", "follow", " succ", "selected", "found", "yes", "Success", "valid", "func", "default", " succeed", " Success", "true", "winner", "rolled", "results", "correct", "failed", "danger", " successful", "construct", "safe", "null", "again", "ceed", "good", "ok", "done", "rolling", "successfully", "content", "continue", "data", "accept", "warning", "successful", "fail", "full", "initial", "better", "pass", "roll", "value", "zero", "response"]}}
{"id1": "5237257", "id2": "20100809", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"download": ["exec", "complete", "url", "delete", "output", "transfer", "zip", "load", "Download", "log", "start", "archive", "upload", "release", "report", "update", "pack", "submit", "process", " downloading", "file", "dump", "register", "open", "paste", "select", "run"], "fileName": [" fileCode", "FileType", "FileUrl", "resourceCode", "resourceFolder", " fileUrl", "resourceDirectory", "FileName", "FileCode", "resourceType", "resourceUrl", " fileFolder", "fileFolder", "fileDirectory", "FileDirectory", "fileType", "fileCode", "FilePath", "FileFolder", "resourcePath", " fileType", " fileDirectory", "fileUrl", "resourceName"], "filePath": [" filePart", "resourceFile", " fileFile", "fileLocation", "resourcePart", "resourcepath", "FileName", "Filepath", "FileLocation", "filePart", "FilePath", "FilePart", "filepath", "resourcePath", "FileFile", " filepath", "resourceLocation", "resourceName", " fileLocation", "fileFile"], "in": ["url", "gin", "ins", "din", "reader", "IN", "re", "login", "bin", "id", "io", "inc", "isin", "spin", "x", "ini", "input", "issue", "In", "name", "on", "inner", "image", "err", "this", "ax", "m", "a", "i", "r", "b", "n", "again", "socket", "sync", "nin", "win", "inn", "resource", "pin", "copy", "is", "l", "source", "cin", "file", "up", "data", "init", "cgi", "work", "lin", "rin", "inside", "con", "ac", "as", "f"], "out": ["exec", "net", "on", "url", "base", "error", "OUT", "client", "outs", "cache", "IN", "call", "output", "bin", "view", "id", "exp", "io", "path", "one", "x", "log", "name", "conn", "ext", "cmd", "In", "obj", "to", "string", "err", "write", "off", "this", "image", "Out", "prefix", "lib", "extra", "or", "at", "writer", "user", "ex", "n", "null", "again", "o", "with", "sync", "socket", "nin", "outer", "office", "option", "inner", "by", "copy", "point", "line", "source", "up", "server", "file", "password"]}}
{"id1": "15896098", "id2": "22479286", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"getSHA256Checksum": ["getSHA256Chechecksam", "getSHA256Chechecksum", "getSHA256Cheicksums", "getSHA256Checksam", "getSHA256Chcksums", "getSHA256Cheicksum", "getSHA256Checksumber", "getSHA256Chechecksumber", "getSHA256Chcksumber", "getSHA256Checsam", "getSHA256Cheicksumber", "getSHA256Chcksum", "getSHA256Checsums", "getSHA256Checksums", "getSHA256Chechecksums", "getSHA256Chchecksumber", "getSHA256Checsumber", "getSHA256Chchecksam", "getSHA256Chcksam", "getSHA256Cheicksam", "getSHA256Checsum", "getSHA256Chchecksums", "getSHA256Chchecksum"], "source": ["ource", "fp", "url", "result", "base", "reader", "cache", "output", "path", "input", "target", "string", "seed", "length", "Source", "code", "format", "connection", "text", "object", "dest", "config", "slice", "ources", "buffer", "message", "uri", "resource", "service", "content", "from", "data", "file", "src", "size", "SOURCE"], "checksum": [" checksums", "hsum", "hsums", "cs256", "csum", "checksup", "cssum", "check256", "cksums", "ckssum", "cksum", "checkssum", " checksumption", "checksam", "csup", " checks256", "hsam", " checkssum", "ckset", "checkum", "checks256", "checksumption", "hexet", " checksam", "checkup", "hssum", "checkset", "cksam", "checksums", " checksup", " checkset", "cksumption", "hexsum", "hexum", "hexumption"], "md": ["MD", "hash", "cm", "mc", "dig", "ms", "metadata", "rm", "pm", "bd", "amd", "am", "df", "mo", "MB", "um", "mb", "mt", "ind", "cmd", "M", "hd", "sm", "rpm", "mand", "m", "dd", "Cmd", "gd", "od", "grad", "mm", "pd", "wd", "mac", "hm", "dh", "vm", "d", "mag", "bf", "vd", "dm", "nm", "f", " MD", "mp"], "byteData": ["numberDATA", "connectionData", "wordBytes", "ipArray", " byteInfo", " byteSize", "bitNumber", "characterText", "wordArray", "characterData", "pixeldata", " byteNumber", "bitList", "wordInfo", "connectionDATA", "byteList", " byteString", "byteNumber", "numberData", "byteString", "ByteSize", "ByteInfo", "ipNumber", " byteDATA", "pixelDATA", "numberdata", " byteList", "connectionSize", "pixelData", "pixelString", "ByteData", " byteBytes", "byteInfo", "bitData", " byteArray", "bitArray", "byteDATA", "characterArray", "ipDATA", "bytedata", "wordData", "numberString", "bitDATA", "ByteBytes", "connectionArray", " byteText", "ByteDATA", "bitText", "byteText", " bytedata", "ByteArray", "ipData", "byteArray", "characterList", "byteBytes", "byteSize"], "sb": ["bc", " eb", "sv", "xb", "bb", "gb", "ob", "bp", " SB", "bd", "nb", "db", "bm", "ws", "fb", "mb", "ls", "binary", "bsp", "si", "sg", "buff", "BB", "SB", "lb", "sq", "b", "buf", "ub", "bg", "bt", "abb", "wb", "kb", "buffer", "ab", "eb", "rb", "pb", "usb", "bh", "src", "bf", "sf", "cb", "bs"], "i": ["qi", "v", "k", "ip", "ai", "ti", "w", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "q", "li", "u", "ui", "hi", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "j", "ie", "r", "info", "ori", "b", "n", "o", "slice", "ri", "uri", "p", "ix", "key", "h", "it", "is", "gi", "l", "oi", "data", "di", "abi", "in", "ni", "d", "ji", "f", "bi", "pi"], "hexString": ["formString", " hexstring", "hexArray", "hexstring", " hexCode", "rawService", " hexStr", " hexService", "hashCode", "hexStr", "exString", "charBuffer", "shortArray", "formstring", "charArray", "rawString", "hexBuffer", "crossFile", "checkString", "rawstring", "shortBuffer", "rawArray", "formArray", "hexFile", "crossString", " hexBuffer", "hexService", "hexCode", " hexArray", "checkArray", "charString", "charStr", "exBuffer", "hashString", "hashService", "formService", "crossBuffer", "shortString", "checkService", "hashArray", "exStr", " hexFile", "exFile", "crossStr", "shortStr", "checkCode"], "hex": ["hash", "lit", "digit", "rex", "ip", "pex", "bit", "rh", "str", "pixel", "bin", "id", "exp", "zip", "raw", "none", "utf", "cross", "string", "length", "comp", "character", "serial", "color", "format", "transform", "ex", "text", "null", "oct", "sync", "pack", "alpha", "wh", "form", "http", "nexus", "cookie", "data", "char", "letter", "shift", "sex", "num", "coord", "closure", "sum", "buff", "cmp", "temp"]}}
{"id1": "22264586", "id2": "16719805", "code1": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"copyFiles": [" copyChildren", "CopyFile", "CopyChildren", "copyChildren", "transferfiles", "cloneFiles", "transferFiles", "copyFile", "cloneFile", " copyPages", "transferChildren", "Copyfiles", "CopyFiles", " copyfiles", "transferPages", "clonePages", " copyFile", "copyfiles", "clonefiles", "copyPages", "transferFile"], "strPath": ["stripath", "striFile", "StrFile", "STRFile", "StrName", "stPath", "strpath", "STRpath", "strName", "striPath", " strFile", "stpath", "StrLog", "STRPath", "Strpath", "striLog", "strFile", "STRLog", "stFile", "stName", " strName", " strpath", "strLog", "StrPath"], "dstPath": ["sdndpath", "dstFile", "dndDir", "dndName", "dndPath", "sdstpath", "ddestPath", "ddestpath", "fstsFile", "fstFile", "dstsPath", "sdstName", "drcName", "ddestFile", "dstName", "ddestName", "sdndName", "sdstPath", "dstDir", "fstPath", "dblpath", "sdndPath", "ddestDir", "fstsDir", "dblDir", "dblFile", "dstsFile", "fstsPath", "dblPath", "dndpath", "dstsDir", "dstspath", "fstspath", "fstDir", "drcpath", "drcPath", "fstpath", "sdndDir", "sdstDir", "dstpath", "drcDir"], "src": ["ource", "sys", "url", "sit", "iv", "obl", "st", "img", "client", "sup", "project", "scripts", "tmp", "sub", "cur", "sort", "path", "ctx", "sl", "input", "host", "secure", "ls", "s", "stream", "Source", "upload", "this", "ruby", "self", "sel", "ssl", "sb", "sq", "front", "sin", "back", "config", "loc", "slice", "sync", "ources", "inst", "rob", "reverse", "rb", "rc", "in", "source", "sc", "dist", "RC", "download", "split", "txt", "cb", "rs", "cmp", "SOURCE"], "dest": ["rest", "slave", "test", "de", "result", "thin", "img", "sup", "prop", "project", "delete", "dep", "tmp", "comb", "zip", "db", "folder", "default", "div", "target", "flat", "out", "secure", "dd", "Dest", "des", "gd", "dat", "desc", "front", "cdn", "wb", "ds", "wh", "dc", "du", "done", "wd", "di", "source", "destroy", "style", "dist", "d", "later", "home", "trans", "cat", "txt", " Dest", "temp"], "list": ["pair", "test", "cl", "id", "path", "lists", "name", "queue", "like", "remove", "LIST", "null", "ll", "la", "p", "is", "data", "filter", "keys", "coll", "full", "group", "part", "size", "map", "stat", "status", "members", "string", "ls", "s", "write", "strings", "read", "www", "key", "l", "run", "lc", "base", "cont", "str", "val", "parents", "stream", "lines", "bl", "files", "code", "all", "info", "parent", "config", "listed", "stack", "source", "dir", "url", "chain", "delete", "dl", "load", "arr", "none", "sort", "set", "type", "batch", "diff", "array", "version", "entry", "json", "split", "names"], "i": ["qi", "v", "ip", "ai", "ti", "I", "e", "id", "io", "xi", "x", "index", "start", "length", "u", "ui", "li", "hi", "multi", "ci", "c", "si", "phi", "ii", "m", "y", "j", "type", "ie", "r", "info", "a", "b", "n", "o", "slice", "ri", "uri", "p", "gi", "ix", "key", "abi", "di", "oi", "data", "me", "ji", "f", "part", "mu", "bi", "pi"], "dest1": ["Dest1", "home1", "src0", "dest0", "DestOne", "homeone", "source2", "sourceone", "dest2", "Dest0", "destOne", "sourceOne", "destone", "Dest2", " destone", "source1", "source0", "srcOne", "src2"], "src1": ["rc1", "rcOne", "source2", "rcone", "sourceone", " srcone", "sourceOne", " srcOne", "rc2", " src2", "source1", "srcOne", "src2", "srcone"], "sourceChannel": ["SourceStream", "srcStream", "srcContext", " sourcechannel", "ourceStream", "sourceStream", "targetchannel", "sourceContext", " sourceStream", "sourceChan", " sourceContext", "ourceChan", "Sourcechannel", "targetContext", "SourceContext", "srcChan", "targetStream", " sourceChan", "SourceChannel", "ourceContext", "ourceChannel", "srcChannel", "SourceChan", "sourcechannel", "targetChan"], "targetChannel": [" targetChan", "argetManager", " targetContext", "destContext", "targetManager", "targetchannel", " targetManager", "sourceContext", " targetConnection", "sourceChan", "TargetContext", "destChannel", "targetContext", "TargetChannel", "Targetchannel", "destConnection", "TargetChan", "TargetManager", "argetChan", "targetConnection", "sourcechannel", "argetChannel", "targetChan", "destChan", "argetchannel", " targetchannel", "TargetConnection"]}}
{"id1": "15799935", "id2": "18489832", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttPartbody", "saveAppensionFile", "saveAttensionPart", "saveAttPartPart", "saveAttensionFile", "saveAttensionbody", "saveAttachedPart", "saveAttachedbody", "saveAttachedFile", "saveAppachmentBody", "saveAttPartFile", "saveAppachmentFile", "saveAttensionBody", "saveAttachedBody", "saveAttachmentPart", "saveAppensionPart", "saveAttachmentbody", "saveAppensionbody", "saveAttachmentFile", "saveAttPartBody", "saveAppachmentPart", "saveAppensionBody", "saveAppachmentbody"], "context": ["template", "processor", "cf", "mc", "client", "ca", "reader", "cache", "system", "project", "view", "current", "container", "request", "environment", "manager", "input", "host", "cms", "state", "contact", "present", "driver", "queue", "c", "event", "component", "community", "connection", "cca", "definition", "center", "front", "parent", "kernel", "text", "config", "concept", "support", "message", "service", "media", "resource", "version", "Context", "document", "translation", "content", "channel", "subject", "coll", "network", "collection", "ctx", "ce"], "part": ["position", "base", "place", "art", "pod", "app", "pre", "partial", "patch", "start", "name", "state", "chapter", "section", "to", "image", "Parts", "upload", "plan", "PART", "or", "event", "component", "type", "connection", "html", "object", "body", "parent", "per", "block", "message", "parts", "media", "service", "p", "mission", " parts", "point", "from", "translation", " Part", "phase", "source", "channel", "file", "area", "Part", "comment", "po"], "localAttachment": ["localAttribution", "localInstension", " localPartribution", "localAttachribution", "localAttachachment", " localAttachention", "localInstachment", "localExtacher", "LocalAttment", "LocalAssment", " localExtention", "localAttention", " localExtachment", "localAssail", "localattachment", " localAttacher", "localInstention", "localAssention", "localattrollment", "localExtacement", " localPartachment", "localArtachment", "localAddment", "localAttacher", "localAvacement", " localAttachrollment", "localAttacement", "localPartension", "localArtention", "localAvacher", "localPartention", " localAttension", "localAttachacher", "localattment", "localAddachment", "localAssachment", "localExtention", "localAttrollment", " localPartention", "localAttachrollment", "localAvention", " localExtacement", "localExtachment", " localAttachachment", "localattention", " localAttrollment", "localAttachension", "localPartribution", "LocalAssention", "localAttachacement", " localExtacher", "LocalAttail", "LocalAttachment", " localPartension", " localAttment", "localArtail", " localAttribution", "localArtment", "localAddail", "localAttail", " localAttacement", "localInstribution", "localAttment", "localAttension", "localAddention", "localPartachment", " localAttention", "LocalAssachment", "LocalAttention", "localAvachment", "localAttachention", "localAddrollment", "LocalAssail", "localAssment"], "accountId": [" accountid", "AccountID", "contractName", " accountID", "accInfo", "appid", "contractid", "accountInfo", "contractId", "jobId", "feedName", "contactid", "accountName", "accountID", "Accountid", "jobID", "appID", "feedid", "accID", " accountName", "AccountName", "contactId", "accountid", "appId", "contactName", "appInfo", "feedId", "jobid", " accountInfo", "accId", "AccountId", "accid", "jobName", "feedID"], "attachmentId": ["attentionid", "attachmentIndex", "attociationType", "attensionID", "attmissionID", "addachmentUrl", "attociationID", "attmissionid", "attagramId", "attmissionSource", "attptionInfo", "attachmentUrl", "attlementId", "attlementName", "attentionId", "extachmentId", "adachmentInfo", "attentionSource", "addachmentID", "attociationUrl", "attociationId", "atociationName", "attlementID", "attlementReference", "adentionIndex", "adachmentId", "atociationID", "attachedID", "extensionID", "adachmentIndex", "attagramInfo", "adentionInfo", "adachmentID", "attmentID", "atociationId", "addentionType", "attensionSource", "attachmentReference", "extachmentID", "attachmentID", "attensionid", "extensionid", "attachedType", "atachmentReference", "addachmentId", "addentionId", "attagramIndex", "extachmentid", "attachedId", "addentionID", "attachmentid", "attptionIndex", "addachmentType", "attmissionId", "attmentName", "atachmentId", "extachmentSource", "atociationReference", "adentionID", "attachmentName", "attachmentInfo", "attentionUrl", "attmentReference", "attachmentSource", "attensionId", "attentionType", "extensionId", "attentionID", "attociationName", "attociationReference", "adentionId", "attentionIndex", "addentionUrl", "atachmentName", "extensionSource", "attentionInfo", "atachmentID", "attmentId", "attptionId", "attagramID", "attachmentType", "attachedUrl", "attptionID"], "in": ["url", "gin", "ins", "din", "reader", "IN", "login", "bin", "id", "inc", "load", "ini", "input", "In", "conn", "inner", "image", "err", "or", "a", "i", "info", "again", "pull", "slice", "socket", "nin", "inn", "p", "pin", "plus", "copy", "it", "is", "cin", "data", "source", "file", "up", "init", "inside", "pass", "con", "ac", "as", "f"], "saveIn": ["writeIN", "stageAs", "savAs", "savein", " savein", "savIn", "stageOut", "aveIn", "savin", "SaveOut", "aveOut", "stageIn", "SaveAs", "saveOut", " saveIns", "writeIn", "stageIns", " saveOut", " saveIN", "saveIns", "writein", "saveIN", "SaveIn", "savOut", "aveAs", "writeOut", "avein", "SaveIns", "aveIN"], "saveAs": ["saveFile", " saveAS", "copyAS", "createAt", "openAs", "createAs", "openFile", " saveas", "saveas", "SaveOut", "Saveas", "copyIn", "copyAs", "openAS", "openAt", "SaveAs", " saveAt", "saveOut", " saveFile", "writeIn", "saveAt", " saveOut", "saveAS", "writeAS", "SaveAS", "SaveIn", "createFile", "writeOut", "writeAs", "copyas", "createAS"], "out": ["exec", "flow", "v", "OUT", "client", "outs", "cache", "output", "bin", "io", "inc", "path", "default", "string", "s", "conn", "inner", "name", "ext", "to", "image", "c", "err", "this", "off", "Out", "at", "a", "writer", "null", "again", "ex", "o", "sync", "outer", "plus", "copy", "other", "line", "data", "source", "file", "up", "page", "init", "as", "temp"], "copySize": ["Copysize", "openSIZE", "saveAddress", "CopyTime", " copyLength", "byteLength", "copyTime", "bytesize", "CopyLength", "CopySize", "leLength", " copySIZE", "leSIZE", " copyTime", "openSize", "copySIZE", "byteAddress", " copysize", "saveSize", "leSize", "copyLength", "openLength", "copyAddress", "copysize", "opensize", "byteTime", "saveLength", "lesize", "savesize", " copyAddress", "byteSize"], "contentUriString": ["contentIrisstring", "contentUioInt", "contentUuriByte", "contentIiString", "contentUriInt", "contentUrisInt", "contentIrisStr", "contentIriUnit", "contentUrisString", "contentUriStr", "contentIrisString", "contentUiniStr", "contentIriStr", "contentUrisStr", "contentUiStr", "contentUrisUnit", "contentIrisUnit", "contentIriInt", "contentUridString", "contentUpiString", "contentUriNumber", "contentUiString", "contentIriNumber", "contentUiniNumber", "contentUriUnit", "contentIrisInt", "contentIristring", "contentUiUnit", "contentUiNumber", "contentIiNumber", "contentIiByte", "contentUiostring", "contentIriString", "contentUiniByte", "contentUpiInt", "contentUioString", "contentUioStr", "contentUpistring", "contentIiStr", "contentUuriNumber", "contentUuriString", "contentUiniString", "contentUridUnit", "contentUrisstring", "contentUpiStr", "contentUriByte", "contentUuriStr", "contentUristring", "contentUridStr", "contentIriByte", "contentUiByte"], "mSize": ["pName", "cName", "cCount", "pLength", "pSize", "iSize", "mLength", "pCount", "iName", "iLength", "cSize", "mName", "iCount", "mCount", "cLength"], "mContentUri": ["mContentIri", "mContentUci", "mContentUris", "mContentOUris", "mContentIci", "mContentIris", "mContentOUri", "mContentIric", "mContentOUric", "mResourceIci", "mResourceUci", "mContentUrci", "mContentUrris", "mContentOUci", "mResourceUri", "mContentUrri", "mResourceUris", "mContentUrric", "mResourceUric", "mResourceIris", "mContentUric", "mResourceIri", "mResourceIric"], "cv": ["csv", "v", "cm", "lc", "sv", "cf", "mc", "fp", "vr", "ca", "cap", "que", "uc", "cover", "cb", "vs", "lv", "um", "ctx", "vp", "keep", "core", "conv", "cp", "cr", "bc", "CV", "c", "cc", "uv", "nv", "iq", "auc", "cu", "xc", "cs", "GV", "buf", "co", "fc", "av", "loc", "enc", "cd", "iv", "content", "rc", "vc", "pb", "sc", "vv", "vm", "VC", "coll", "nc", "ctrl", "ov"], "uri": ["qi", " Uri", "address", "url", "iv", "base", "gb", "metadata", "id", "proxy", "iri", "path", "environment", "location", "string", "ui", " URI", "range", "uni", "ci", "prefix", " ur", "oid", "mi", "storage", "format", "username", "i", "route", "query", "ri", "attribute", "resource", "api", "URI", "point", "http", "href", "cli", "data", " url", "uid", "universal", "pi", " scheme"]}}
{"id1": "22801734", "id2": "5989666", "code1": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "code2": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"setup": ["test", "clean", "prep", "parse", "load", "Setup", "software", "boot", "strap", "set", "upload", "build", "construct", "info", "handler", "config", "install", "ize", "copy", " Setup", "up", "process", "init", "download", "figure", "exit", "run"], "path": ["address", "url", "base", "PATH", "cache", "alias", "platform", "zip", "folder", "host", "filename", "location", "string", "name", "context", "pointer", "Path", "archive", "pattern", "image", "prefix", "code", "format", "root", "route", "directory", "dest", "loc", "loader", "uri", "ath", "resource", "content", "source", "data", "file", "dir", "home", "temp"], "jarFile": ["jaDir", "jafile", "zipF", " jarF", "jaPlace", "jaFile", "JarDir", "rarBody", "zipPath", "zipfile", "zipDir", "jarF", "jarPath", "zipLibrary", "jarBody", "JarLibrary", "rarFile", "javaPlace", " jarBody", " jarPath", " jarLibrary", "jarDir", " jarfile", "JarFile", "jarLibrary", "zipFile", "JarF", " jarDir", "javafile", "javaFile", "Jarfile", "javaDir", "rarfile", "jarfile", "zipBody", "rarPath", "jarPlace", " jarPlace"], "f": ["v", "fp", "cf", "base", "url", "cache", "w", "e", "feed", "io", "folder", "x", "df", "tf", "fb", "rf", "flat", "fm", "s", "c", "fe", "files", "fa", "m", "t", "i", "r", "g", "b", "o", "F", "fc", "fr", "fs", "p", "h", "fd", "fi", "af", "l", "lf", "file", "dir", "fw", "d", "bf", "framework", "full", "sf"], "parent": ["test", "url", "base", "ip", "pa", "paren", "cache", "port", "child", "folder", "function", "host", "target", "location", "parents", "name", "offset", "to", "image", "prefix", "type", "root", "directory", "loc", "css", "resource", "p", "point", "line", "source", "pool", "file", "dir", "and", "Parent", "home", "part", "ctx", "fat", "cmp", "acl"], "buf": ["Buffer", "uf", "bc", "cap", "v", "header", "img", "exc", "bb", "gb", "ob", "bin", "tmp", "br", "cv", "bd", "bp", "func", "fb", "seq", "queue", "len", "bag", "batch", "lb", "Buff", "b", "config", "loc", "pad", "padding", "wb", "buffer", "ab", "la", "bytes", "rb", "fd", "data", "pool", "bh", "src", "bf", "lim", "abc", "cb", "buff", "bu"], "zipinputstream": ["zipimportsource", "zipinfcontrol", "zinputthread", "archiveInputstream", "zipInputstream", "archiveinputsample", "zipviewchannel", "fileoutputsource", "fileInputproblem", "zinputchannel", "fileoutputStream", "fileinputsteam", "zipviewstream", "zipinputthread", "zipinputchannel", "forceinputStream", "zipoutputsource", "zipoutputstream", "zipInputsource", "zipInputchannel", "zipoutputchannel", "zipentryStream", "fileoutputsteam", "zInputcontrol", "zipimportStream", "zipstreamStream", "zipoutputproblem", "archiveInputStream", "zipstreamsteam", "zipoutputsample", "zipinputsource", "zInputStream", "zipoutputsteam", "zipinputStream", "forceinputstream", "forceentryStream", "archiveinputstream", "zipinputsample", "zInputchannel", "zipinfStream", "zipimportstream", "zipbitStream", "zInputstream", "zipentrysteam", "zipInputproblem", "fileinputsource", "forceentrystream", "archiveinputStream", "zipbatchproblem", "fileinputproblem", "zipInputsteam", "forceinputsteam", "zipinputsteam", "zinputStream", "zipInputsample", "zipentrystream", "zipviewStream", "zinputcontrol", "zipbitthread", "zipoutputcontrol", "zipimportsample", "fileinputstream", "zipInputStream", "archiveInputsample", "zipinfstream", "zipoutputthread", "zipstreamstream", "forceentrysteam", "zInputthread", "fileinputStream", "zipoutputStream", "zipinputcontrol", "fileInputStream", "zipbatchStream", "zipinputproblem", "zipbitstream", "zipInputthread", "zinputstream", "zipbatchstream", "zipInputcontrol", "fileInputstream"], "zipentry": ["lockelement", "zipenter", "seaEntry", "zipelement", "Zipconnection", "Zipentry", "zipconnection", " zipconnection", "filearchive", "Zipenter", "ziparchive", "feedentry", "ceentry", "seaelement", "zoneentry", " zipEntry", "ceenter", "zoneapi", " ziparchive", "zarchive", "zEntry", "zipreader", "zipEntry", "zipapi", "cereader", "feedconnection", " zipenter", "ceEntry", "seaentry", "zipinner", "seaenter", "fileentry", " zipinner", " zipapi", "Ziparchive", "lockEntry", "installelement", "ZipEntry", "lockentry", " zipelement", "installinner", "Zipreader", "zoneEntry", "Zipapi", "installentry", "Zipelement", "feedEntry", "feedarchive", "fileelement", "zonereader", "lockenter", "zentry", "fileEntry", "zreader", "Zipinner", "installEntry", " zipreader"], "entryName": ["nextname", "fieldPart", "fieldname", " entryType", "imageEl", " entryPath", "EntryType", "nextPath", "imagename", "Entryname", "resourcePart", "nextEl", "fieldPath", "entryPath", "resourceType", "EntryPart", " entryname", " entryPart", "imageName", "entryPart", "entryEl", " entryEl", "nextName", "imagePath", "entryname", "fieldName", "EntryEl", "EntryPath", "resourceName", "EntryName", "resourceEl", "entryType"], "n": ["an", "v", "z", "k", "ng", "w", "N", "left", "e", "un", "nb", "x", "nl", "nr", "ns", "name", "s", "nor", "u", "ln", "c", "no", "len", "nn", "y", "m", "all", "t", "en", "j", "i", "r", "g", "b", "number", "nu", "o", "nt", "ner", "sn", "p", "h", "dn", "l", "na", "in", "pos", "num", "d", "ne", "nc"], "fileoutputstream": ["fileoutputtrack", "fileoutputuser", "filetextform", "filedownloaduser", "fileOutputtrack", "fileinformationview", "resourceoutputview", "zipOutputStream", "zipinputpool", "fileinputstream", "zipOutputtrack", "resourceoutputstream", "filetextStream", "fileinputfile", "fileinputmess", "fileconnectionStream", "zipOutputmess", "filetextpool", "fileconnectionuser", "fileinformationStream", "fileoutputform", "fileupdatestream", "fileoutStream", "fileOutputmess", "resourceOutputstream", "fileOutputuser", "fileoutputStream", "resourceOutputStream", "zipoutputtrack", "fileoutform", "fileoutstream", "resourceOutputfile", "fileinputpool", "zipOutputstream", "filetextstream", "fileoutputfile", "fileinformationfile", "fileupdatemess", "filedownloadstream", "fileinputStream", "zipoutputStream", "fileinputform", "zipoutputmess", "fileOutputstream", "fileOutputStream", "fileoutputpool", "filedownloadtrack", "fileconnectionstream", "fileinputview", "zipinputStream", "filedownloadStream", "fileoutpool", "fileoutputmess", "zipinputform", "fileOutputview", "resourceoutputStream", "fileinformationstream", "fileupdateStream", "zipoutputuser", "fileOutputfile", "resourceoutputfile", "fileconnectiontrack", "zipoutputstream", "zipOutputuser", "fileoutputview", "zipoutputpool", "resourceOutputview", "zipoutputform"], "newFile": ["newDir", "largeLine", "nextEntry", "oldLine", "updateDir", " newPlace", "baseFolder", " newEntry", "basefile", " newFolder", "newLine", "NewPlace", "newChild", "nextfile", "updateLine", " newDir", "NewDir", "newEntry", "updatePlace", "NewFile", "updateFile", "largeFolder", " newfile", "nextFolder", " newChild", "oldFolder", "largeFile", "baseFile", "oldFile", "oldChild", "newfile", "newPlace", "newFolder", "nextFile", "largeChild", "baseEntry", "NewLine", " newLine"], "arch": ["ure", "url", "error", "ver", "art", "app", "id", "platform", "dict", "ar", "ace", "model", "family", "ress", "boot", "itect", "host", "patch", "ext", "archive", "hard", "Arch", "code", "auth", "build", "chart", "archs", "type", "release", "arc", "aug", "library", "cast", "arm", "tag", "back", "anc", "oct", "install", "inst", "ARCH", "var", "array", "version", "mount", "mac", " architecture", "rc", "work", "addr", "ch", "act", "urn", "ror", "brand", "ith", "cat", "ask"], "key": ["pair", "k", "base", "client", "prop", "str", "id", "nice", "country", "x", "val", "KEY", "name", "string", "word", "section", "link", "character", "lease", "type", "ie", "connection", "rule", "Property", "option", "attribute", "service", "search", "Key", "col", "data", "char", "entry", "letter", "style", "secret", "keys", "field", "variable", "value", "part", "item"], "property": ["feature", "address", "position", "description", "prop", "model", "term", "function", "filename", "string", "language", "profile", "name", "section", "lock", "prefix", "argument", "character", "expression", "properties", "operation", "lease", "type", "username", "info", "ie", "class", "number", "object", "Property", "integer", "option", "attribute", "resource", "p", "service", "translation", "data", "style", "variable", "contract", "field", "value", "unit", "part", "item", "module"], "x64": [" x68", "xp68", "rx32", "xx224", "rx224", "ux59", "x58", "x224", "rx64", "xx48", "rx48", "rex64", "xx64", "rex32", "x48", "ex32", " x59", "ux58", "x59", "x32", "wx64", " x32", "xp58", "xp32", "rex68", " x58", "ex224", "wx59", "x68", "ex48", "xx32", "wx58", "xp64", "ux64", "rex58", "ex64"]}}
{"id1": "2518655", "id2": "16215393", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"fnOut": ["fpOUT", "fnFile", "FNOutput", "fnIn", " fnEx", "lsOut", " fnIn", "fpOutput", "fpFile", "lsFile", " fnOUT", "fpOut", " fnFile", "FNIn", "fnOutput", "FNOut", "lsOUT", "fpIn", "fnOUT", "lsOutput", " fnOutput", "fpEx", "fnEx", "FNEx"], "writer": ["wa", "wire", "writ", "reader", "builder", "w", "output", "war", "worker", "ws", "ler", "er", "out", "inner", "driver", "word", "winner", "writing", "write", "widget", "wr", "editor", "layer", "Writer", "riter", "r", "a", "handler", "per", "walker", "socket", "loader", "nw", "outer", "parser", "buffer", "key", "fd", "work", "server", "entry", "file", "usher", "director", "writers", "temp"], "i": ["qi", "v", "z", "k", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "li", "ui", "u", "s", "hi", "multi", "ci", "c", "si", "mi", "phi", "ii", "m", "j", "type", "ie", "ori", "b", "n", "o", "bi", "ri", "uri", "p", "strength", "key", "gi", "h", "fi", "abi", "ix", "oi", "di", "chi", "ji", "part", "f", "pi"], "fInput": ["sfOutput", "sfinput", "fileinput", " fFormat", "fileFormat", "fFormat", "fileOutput", "fileInput", " fOutput", "fileSource", "fOutput", " fSource", "sfSource", "fSource", " finput", "finput", "sfFormat", "sfInput"], "in": ["gin", "ins", "reader", "din", "IN", "login", "bin", "id", "isin", "inc", "vin", "ini", "input", "out", "In", "s", "conn", "inner", "ln", "c", "inas", "connection", "b", "n", "scan", "again", "sin", "socket", "ner", "nin", "win", "inn", "version", "min", "pin", "line", "lin", "data", "cin", "inside", "kin", "init", "rin", "reading", "f"]}}
{"id1": "1421557", "id2": "5414088", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeFileToFiles", "encodeStringToFiles", "encodeFile2Stream", "encodeFiletoStream", "encodeFileFromFile", "encodeFileFromStream", "encodeFiletoFile", "encodeString2File", "encodeFiletoFiles", "encodeString2Files", "encodeFile2File", "encodeString2String", "encodeString2Stream", "encodeFileFromString", "encodeFileToString", "encodeFile2String", "encodeStringToString", "encodeFileToStream", "encodeFiletoString", "encodeStringToStream", "encodeFile2Files", "encodeStringToFile"], "infile": ["Infile", "infiles", "inputFile", "InFile", "inFile", "Infiles", "outFile", "inputfiles", "infilename", "outfilename", " infilename", "outfiles", "inputfp", "infp", " infiles", "inputfilename", " infp", "outfp", "Infilename", "inputfile"], "outfile": ["outputfilename", "newname", "Outname", "newFile", "outname", "infolder", "newfolder", " outname", "Outfolder", "outFile", "outfolder", " outfolder", "infilename", "outfilename", "outputfp", " outFile", "outputfile", " outfilename", " outfp", "newfile", "infp", "OutFile", "outputfolder", "Outfile", "outfp"], "in": ["gin", "base", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "vin", "ini", "input", "ic", "In", "s", "conn", "inner", "image", "err", "inas", "m", "a", "i", "r", "b", "again", "sin", "socket", "nin", "win", "inn", "min", "pin", "is", "into", "cin", "data", "source", "init", "inside", "rin", "pass", "ac", "con", "as"], "out": ["net", "exec", "base", "error", "OUT", "client", "outs", "cache", "job", "output", "bin", "ou", "io", "inc", "one", "session", "conn", "obj", "In", "inner", "on", "name", "to", "image", "err", "write", "off", "no", "Out", "lib", "or", "writer", "ex", "parent", "again", "o", "co", "socket", "sync", "post", "outer", "timeout", "point", "copy", "line", "source", "work", "file", "up", "home", "exit"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bb", "transfer", "feed", "raw", "fb", "input", "border", "length", "seed", "binary", "offset", "queue", "write", "len", "layer", "type", "reference", "batch", "count", "b", "null", "buf", "slice", "padding", "iter", "bytes", "wave", "flush", "data", "source", "server", "limit", "value", "split", "size", "buff"], "read": ["exec", " skip", " Read", "ip", "reader", "send", " copy", "parse", "lex", "allow", "use", "id", "feed", "io", "load", "inc", "raw", "current", "_", "check", "x", " count", "input", "connect", "start", "length", "ind", "play", "seek", "end", "write", "next", "len", "i", "count", "ride", "wait", "fill", "n", "find", "Read", "slice", "sync", "READ", "tell", " write", "ad", "iter", "close", "add", "get", "copy", "work", "sleep", "se", "limit", "reads", "pass", "reading", "size", "select", "f", "run"], "success": ["complete", "first", "result", "error", "cess", " succ", "fast", "status", "ccess", "growth", "follow", "flash", "primary", "right", "Success", "valid", "model", "func", "path", "default", " succeed", " Success", "true", "winner", "rolled", "results", "xx", "failed", "danger", " successful", "construct", "method", "null", "again", "ceed", "good", "message", "done", "rolling", "successfully", "respons", "content", "continue", "data", "warning", "successful", "pass", "roll", "initial", "better", "fail", "value", "open", "modified", "comment", "response"]}}
{"id1": "22320592", "id2": "13891080", "code1": "    private static void loadDefaultPreferences() {\n        try {\n            URL url = ClassLoader.getSystemResource(\"OpenDarkRoom.defaults.properties\");\n            preferences.load(url.openStream());\n        } catch (FileNotFoundException e) {\n            log.error(\"Default preferences file not found\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"loadDefaultPreferences": ["loadStandardPrefels", "loadDefaultPreSettings", "loadStandardPrefs", "loadStandardPrefSettings", "loadDefaultConferences", "loadStandardPreels", "loadDefaultPreels", "loadDefaultConfSettings", "loadDefaultpreels", "loadDefaultPrefSettings", "loadDefaultConfs", "loadStandardPreferences", "loadDefaultpreSettings", "loadDefaultPrefs", "loadDefaultPrefels", "loadStandardPreerences", "loadStandardPres", "loadDefaultPres", "loadDefaultpres", "loadDefaultpreerences", "loadDefaultPreerences", "loadDefaultConfels", "loadStandardPreSettings"], "url": ["address", "base", "reader", "rel", "el", "e", "id", "feed", "URL", "jar", "path", "xml", "sl", "Url", "location", "string", "name", "gl", "stream", "image", "org", "ssl", "element", "user", "b", "browser", "object", "config", "loader", "buffer", "uri", "service", "resource", "bel", "http", "page", "l", "source", "file", "server", "data", "entry", "ref", "f"]}}
{"id1": "5436973", "id2": "20920051", "code1": "    public String httpToStringStupid(String url) throws IllegalStateException, IOException, HttpException, InterruptedException, URISyntaxException {\n        String pageDump = null;\n        getParams().setParameter(ClientPNames.COOKIE_POLICY, org.apache.http.client.params.CookiePolicy.BROWSER_COMPATIBILITY);\n        getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpGet httpget = new HttpGet(url);\n        httpget.getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpResponse response = execute(httpget);\n        HttpEntity entity = response.getEntity();\n        pageDump = IOUtils.toString(entity.getContent(), \"UTF-8\");\n        return pageDump;\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"httpToStringStupid": ["httpToStringstrict", "httpToPageCored", "httpToStringstomp", "httpToStringStored", "httpToStringUupid", "httpToStringCrict", "httpToPageStupid", "httpToPageCrict", "httpToStringCupid", "httpToStringUomp", "httpToStringUored", "httpToStringStomp", "httpToPageStrict", "httpToStringCored", "httpToStringStrict", "httpToPageCupid", "httpToPageStored", "httpToStringComp", "httpToStringstored", "httpToPageStomp", "httpToStringstupid", "httpToStringUrict", "httpToPageComp"], "url": ["address", "https", "base", "str", "id", "feed", "URL", "path", "request", "sl", "Url", "host", "location", "string", "name", "ls", "domain", "image", "ssl", "i", "connection", "html", "route", "www", "config", "uri", "service", "resource", "api", "version", "http", "href", "page", "l", "source", "server", "file", "channel", "secret", "f"], "IOException": ["DownloadException", "DownloadError", "ConfigurationError", "ConfigurationException", "IOError", "Configurationception", "Downloadception", " IOception", " IOError", "IOception"], "HttpException": ["HTTPException", "httpException", "DownloadException", "Httpception", "Downloadception", "HTTPception", "httpception"], "InterruptedException": [" InterruptExit", "InterIOExcept", "InterruptedExcept", "InterruptedExit", " InterruptError", "InterIOExit", "InterruptExit", "InterruptError", "InterSleepError", " InterruptedError", " InterruptException", "InterruptExcept", "InterruptedError", "InterSleepExit", " InterruptExcept", "InterIOError", "InterSleepExcept", " InterruptedExit", "InterIOException", "InterSleepException", "InterruptException", " InterruptedExcept"], "URISyntaxException": ["URISyntaxError", "URISyntaxEx", "URISyntixception", "URISlaxException", "URISlaxception", "URISyntixError", "URISyntntaxException", "URISyntaxception", "URISyntaceException", "URISlntaxEx", "URISyntaceception", "URISyntixException", "URISyntntaxception", "URISlntaxception", "URISlaxError", "URISyntaceError", "URISlntaxException", "URISyntntaxError", "URISlntaxError", "URISlaxEx", "URISyntaceEx", "URISyntixEx", "URISyntntaxEx"], "pageDump": [" pageBash", " pageDumps", "pageDsumm", " pageDumping", " pageBump", "pageBash", "pageFash", "pageLumper", "pageDumping", "pageDash", " pageBumping", "pagedumps", "pageDoumping", " pageDash", "pageLumps", "pageBumm", "pagedumper", " pageBumper", "pageDsumper", "pageDoumper", "pageDoump", "pageLump", "pageFump", "pageDsump", "pageFumps", " pageBumps", "pageBumps", "pagedump", "pageDumper", "pageLumping", "pageDumps", "pageBumping", "pageDumm", " pageDumper", "pageBumper", "pageBump", " pageDumm", "pageDoumm", "pageDsumps", "pageDoumps", "pagedash", " pageBumm", "pageFumper"], "httpget": ["httpstart", "httprequest", "hrstart", "phget", "Httprequest", " httpfind", "httGET", " httpGet", "phstart", "phGet", "httfind", "urlget", " httprequest", "phpGET", " httpset", "phgot", "urlrequest", "HttpGet", "phpget", "httpfind", "httstart", " httpstart", "hrget", "Httpget", "httpGET", "httpgot", " httpGET", "urlGet", "httpGet", "phpfind", "httpset", "hrGet", "hrgot", "phpstart", " httpgot", "urlset", "httget", "Httpset"], "response": ["result", "error", "received", "status", "output", "e", "Response", "request", "environment", "res", "success", "respond", "connection", "method", "application", "object", "body", "ception", "message", "uri", "resource", "api", "get", "document", "http", "page", "data", "resp", "server", "full", "reply", "json", "collection", "onse", "relation"], "entity": ["result", "error", "ity", "output", "e", "security", "model", "Response", "xml", "environment", " entities", "image", "event", " Entity", "component", "connection", "element", "ent", "object", "body", "query", "message", "service", "resource", "person", "agent", "content", "document", "translation", "Entity", "page", "data", "resp", "server", "article", "entry", "instance", "json", "collection", "unit"]}}
{"id1": "19494842", "id2": "7166270", "code1": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "code2": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "label": 1, "substitutes": {"callService": ["callservice", "testServices", "callServices", " callProxy", "testservice", " callServices", "Callservice", "CallProxy", "callProxy", " callservice", "testProxy", "CallService", "testService", "CallServices"], "url": ["address", "base", "client", "e", "feed", "URL", "path", "log", "sl", "Url", "host", "string", "conn", "stream", "queue", "this", "ssl", "connection", "r", "i", "user", "b", "ll", "socket", "ur", "uri", "service", "resource", "http", "l", "source", "file", "server", "json", "open", "web", "blog", "f"], "in": ["gin", "ins", "reader", "din", "IN", "client", "re", "login", "bin", "id", "inc", "ini", "fb", "input", "out", "In", "s", "stream", "inner", "image", "c", "err", "doc", "ssl", "i", "r", "b", "again", "socket", "win", "buffer", "inn", "h", "is", "into", "line", "data", "lin", "file", "source", "init", "kin", "impl", "f"], "inputLine": ["requestLine", " inputRow", "requestline", "inputString", "requestString", "inputFrame", "InputFrame", "InputL", "readRow", "inputRow", " inputString", "readline", "streamString", "streamLine", "outputRow", "streamline", "inputL", "readValue", "InputString", "Inputline", "readLine", "inputline", "inputValue", "requestL", " inputL", "InputLine", " inputline", " inputFrame", "outputLine", "streamFrame", " inputValue", "outputValue", "outputline"], "buf": ["Buffer", "uf", "bc", "result", "fp", "base", "header", "exc", "cf", "cache", "builder", "fun", "bb", "aux", "gb", "br", "ob", "cv", "nb", "db", "log", "ctx", "fb", "abs", "string", "context", "conv", "binary", "queue", "pkg", "bag", "buff", "sb", "b", "ff", "pad", "wb", "buffer", "array", "ab", "rb", "cas", "af", "data", "pb", "append", "bh", "pool", "coll", "bf", " buffer", "cb", "f", "bu"], "answer": ["complete", "su", "address", "stuff", "result", " answers", "side", "knowledge", "description", "cache", "status", "site", "issue", "session", "name", "word", "order", "prefix", "blank", "settings", "username", "say", "empty", "install", "sn", "message", "array", "option", "uri", "update", "attribute", "search", "entry", "question", "server", "answered", "fix", "value", "reply", "swers", "ask", "response", "Answer"]}}
{"id1": "339517", "id2": "1508161", "code1": "    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n        URL url = getClass().getResource(name);\n        InputStream in = url.openStream();\n        try {\n            return ClassFile.read(in);\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "label": 0, "substitutes": {"getClassFile": ["getCacheCode", "getSourceLoader", "createCodeCode", "createClassCode", "getCacheLoader", "getClassFiles", "getClassLoader", "getSourceFile", "getCacheFile", "getCodeCode", "getSourceFiles", "createClassFile", "getSourceCode", "createCodeFiles", "createClassLoader", "getCacheFiles", "getCodeFile", "getCodeLoader", "getClassCode", "createClassFiles", "createCodeFile", "createCodeLoader", "getCodeFiles"], "name": ["address", "base", "str", "ame", "id", "path", "Name", "request", "default", "filename", "string", "named", "size", "prefix", "this", "type", "i", "info", "connection", "class", "definition", "n", "object", "parent", "config", "loader", "uri", "resource", "key", "data", "source", "file", "pass", "names", "part", "NAME"], "url": ["base", "reader", "el", "found", "id", "feed", "io", "URL", "sl", "Url", "host", "string", "ls", "image", "resources", "this", "ssl", "i", "r", "connection", "class", "b", "user", "ll", "rule", "config", "loader", "uri", "service", "resource", "http", "l", "source", "file", "server", "page", "instance", "open", "rl", "f"], "in": ["gin", "ins", "din", "reader", "IN", "token", "login", "bin", "id", "isin", "inc", "ini", "input", "out", "In", "s", "stream", "inner", "image", "err", "inas", "ax", "read", "ssl", "i", "r", "b", "ex", "n", "again", "socket", "nin", "win", "resource", "inn", "is", "data", "lin", "source", "inside", "init", "rin", "con", "ac", "as", "f"]}}
{"id1": "22441244", "id2": "7087108", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"send": ["exec", "address", "delete", "parse", "transfer", "export", "Send", "start", "end", "write", "set", "build", "text", "post", "message", "add", "get", "from", "submit", "append", "execute", "create", "reply", "sent", "open", "mail"], "hsession": ["hessions", "HSSession", "hhort", "HSession", "hessession", "hSession", "openssession", "hesession", "opensess", "opensort", "HSessions", "hmessions", "hmession", "hhessions", "hession", "hssession", "hhSession", "hhession", "hhsession", "hsess", "hhess", "hsSession", "hmsession", "hesort", "hesess", "opensession", "opensessions", "hsessions", "opensSession", "hmSession", "HSsession", "hsort"], "session": ["Session", "client", "cache", "project", "site", "port", "security", "proxy", "chat", "sl", "host", "context", "state", "response", "event", "connection", "class", "application", "parent", "essions", "message", "resource", "document", "server", "ession", "manager", "mail"], "repositoryName": ["repoitoryEmail", "reposessionNAME", "repoositoryAddress", "reposicationFamily", "reposicationAddress", "repoositoryEmail", "repositoryPath", "reposicationEmail", "repoositoryPath", "reposessionName", "reposositoryPath", "repoitoryName", "reposositoryFamily", "repoitoryAddress", "repoitoryPath", "reposessionPath", "reposicleFamily", "repoitoryFamily", "repositoryNAME", "repositiveEmail", "repoositoryNAME", "reposositoryName", "repositoryFamily", "reposicationName", "repoitoryNAME", "reposositoryEmail", "reposessionEmail", "reposositoryNAME", "repositoryEmail", "reposicleAddress", "repositiveNAME", "reposicleEmail", "repositivePath", "repositiveName", "repositoryAddress", "repoositoryFamily", "repoositoryName", "reposicleName", "reposositoryAddress"], "ideIdint": ["ideAuthInt", "ideInint", "ideIdn", "ideTimeout", "ideTimeint", "ideNamenumber", "ideAuthn", "ideInn", "ideInfoInt", "ideIdints", "IDEIdout", "ideInfonumber", "IDEidInt", "ideInfoout", "ideNameInt", "ideAuthints", "ideidInt", "ideNameint", "ideAuthint", "ideInints", "IDEidint", "IDEidn", "ideInInt", "ideidints", "IDEIdInt", "ideidn", "IDENameout", "ideIdInt", "IDEIdints", "ideidint", "IDEidints", "IDENamenumber", "ideIdnumber", "ideTimenumber", "IDENameInt", "ideIdout", "IDEIdint", "ideTimeInt", "ideNameout", "IDEIdnumber", "IDEIdn", "ideInfoint", "IDENameint"], "to": ["template", "address", "client", "account", "token", "title", "phone", "site", "po", "sub", "TO", "target", "location", "name", "contact", "top", "response", "prefix", "company", "options", "To", "with", "mobile", "message", "office", "uri", "by", "from", "tel", "source", "summary", "about", "reply", "mail", "settings"], "cc": ["address", "lc", "cl", "cf", "client", "ca", "uc", "account", "phone", "tc", "contact", "cr", "c", "ci", "company", "card", "code", "ct", "ec", "cca", "cs", "cus", "dc", "from", "ck", "rc", "sc", "cn", "password", "nc", "ac", "CC", "comment", "cb", "ce"], "bcc": ["bce", "abck", "bc", " brc", "abcc", "fck", "bbc", " bck", "abce", "bck", " bce", "brc", "bbrc", "fcc", "bbcc", "fc", "frc", "pck", "pcc", "pce", "pc", " bc", "abc", "bbck"], "subject": ["template", "header", "description", "title", "phone", "sub", "request", "filename", "host", "state", "response", "ject", "prefix", "username", "format", "reason", "method", "object", "head", "message", "uri", "mail", "content", "reply", "Subject", "comment", "author"], "body": ["template", "url", "header", "base", "description", "left", "pod", "view", "foot", "Body", "zip", "shell", "function", "money", "name", "string", "length", "inner", "lock", "bound", "plain", "code", "normal", "reason", "connection", "html", "text", "object", "empty", "message", "tree", "media", "resource", "how", "wrapper", "content", "line", "source", "data", "style", "secret", "summary", "password", "pass", "part", "comment", "response"], "attachments": ["Attachents", "messments", "messings", "Attachments", "attachings", "embedents", "attachents", "messents", "embedment", "Attachment", "embedments", "Attachings", "messment", "embedings"], "isHtml": ["isWhhtml", " isWhive", "isChive", "isCail", "isChtml", "isHahtml", " isHttp", "isHaail", " isHhtml", "isHail", "isHatml", "isHhtml", "isChttp", "isCive", "isWhtml", " isWhtml", "isPhhtml", " isHail", "isChail", "isHttp", "isPhtml", "isChhtml", " isChtml", " isWhhtml", "isPhttp", "isHattp", " isHive", "isPhail", "isWhail", "isHive", " isChhtml", " isChail", "isCtml", "isWhive", " isChttp", " isWhail"], "charset": ["chacksET", "charspace", "cheansetter", "charsetter", "chasheset", "chearsetting", "charsete", "chasesetting", "chearsetter", "chansET", "chaseset", "chashesetter", "Charset", "chacksete", "chARSeting", "chARSete", "chansete", "chaseting", "chasets", "chearsete", "chasetting", "chaset", "chARSET", "chansetter", "cheanspace", "CharsET", "chansetting", "chaseseting", "Charsetting", "chasesET", "charsetting", "cheanset", "chanspace", "charsets", "chARSets", "chaspace", "chARSet", "chasetter", "Charseting", "charsET", "chasET", "cheansET", "chearspace", "chearset", "Charsets", "chacksetting", "charseting", "cheansete", "chashesET", "chanset", "chashespace", "chearsET", "cheansetting", "chARSetting", "chackset"], "headers": ["header", " messages", " emails", "ers", "params", "types", "groups", "classes", "status", " recipients", "metadata", "authors", "users", " cookies", "lines", "files", "comments", "strings", "properties", "errors", "mails", "options", "content", "names", "writers", "settings"], "priority": ["template", "level", "title", "status", " recipients", "phone", "security", "length", "language", "state", "queue", " title", "prefix", " severity", "code", "comments", "reason", "mode", "class", "quote", "lang", "date", "secret", "theme", "reply", "comment", "author"], "email": ["external", "template", "address", "url", "result", "oe", "base", "test", "account", "gmail", "enter", "lex", "el", "output", "view", "e", "zip", "pm", "model", "xml", "default", "engine", "export", "auto", "name", "note", "contact", "ext", "core", "ilo", "business", "entity", "generic", "username", "event", "element", "en", "info", "ssl", "html", "print", "text", "object", "online", "example", "install", "update", "message", "mail", "office", "service", "em", "document", "line", "international", "data", "article", "letter", "server", "password", "fax", "create", "Email", "liner", "response"], "user": ["ip", "account", "client", "token", "e", "use", "id", "model", "User", "creator", "users", "er", "name", "string", "plugin", "profile", "friend", "character", "username", "type", "info", "connection", "role", "object", "unknown", "mobile", "person", "resource", "me", "consumer", "data", "USER", "member", "uid", "people", "author"], "identity": ["entityifier", "identonymous", "IDENTITY", "authorifier", "entityity", "identiciary", "idITY", "publiciciary", "identifier", "identITY", "identities", "IDENTity", "idifier", "installonymous", "IDENTities", "personITY", "authorITY", "electricity", "installentity", "ethniciciary", "authentifier", "installITY", "idity", "ethnicication", "electricITY", "authorities", "IdentITY", "ethnicITY", "Idententity", "entityization", "authentity", "Identities", "installity", "authentITY", "idententity", "personentity", "personity", "Identity", "authorentity", "idication", "identication", "authorication", "publicentity", "publicity", "IDENTentity", "entityonymous", "personifier", "publicITY", "idization", "ethnicentity", "idonymous", "electriconymous", "authentication", "ethnicifier", "authoriciary", "authentonymous", "ethnicity", "electricentity", "authority", "identization", "authentization", "authoronymous"], "_returnPath": ["_successId", "_relationId", "_resultTo", "_backName", "_returnName", "_backUrl", " _backTo", " _returnPart", "_backPath", "_returnNode", "_inputMid", "_returnPart", " _backHalf", "_correctPath", "_replyPath", "_relationText", "_returnUrl", "_backPart", " _backUrl", "_displayUrl", "_correctDirectory", "_returnpath", "_displayPath", "_resultName", "_relationDirectory", "_returnText", "_displayPart", "_responsepath", "_correctId", "_displayMid", "_relationPath", "_addpath", "_returnType", "_successDirectory", "_replyNode", "_replyPart", " _returnHalf", " _backPart", "_responseType", "_returnHalf", "_correctText", "_returnMid", "_backType", "_resultPath", "_resultHalf", "_inputNode", "_addType", "_successPath", "_backpath", "_inputPath", " _returnTo", " _returnName", "_replyUrl", "_replyMid", "_successText", "_returnTo", "_displayNode", "_responsePath", " _backName", "_inputUrl", "_backHalf", "_backTo", "_returnId", " _returnUrl", " _backPath", "_returnDirectory", "_addPath"], "_from": ["workwho", " _for", "_with", " _with", "_for", "blockerror", "existingowner", "_who", "blockfrom", "workfrom", " _who", " _source", "workto", "placefor", " _error", "existingfrom", "existingto", " _owner", "_source", "placefrom", "_error", "_owner", "worksource", "_From", "blockto", "placeowner", "existingfor", " _From", "blockFrom", "placeto"], "_replyTo": ["_replyAddress", "_reasonTo", "_respondPoint", "_addTo", "_reasonTO", "_replyUrl", "_respondAddress", "_closeTO", "_reasonFrom", "_replyTO", "_respondTO", " _returnFrom", "_returnAddress", "_returnTo", "_closeOf", "_commentTO", " _replyUrl", "_addFrom", "_respondUrl", "_addPoint", "_returnOf", " _returnUrl", "_commentTo", "_reasonUrl", "_commentFrom", " _replyFrom", "_returnTO", "_returnUrl", "_returnFrom", "_replyFrom", "_closeFrom", " _replyTO", " _returnTo", "_returnPoint", "_commentOf", "_respondTo", "_closeTo", "_replyPoint", "_replyOf", "_addAddress", "_respondFrom", " _returnTO"], "_to": ["Jto", " _target", "Jfrom", " _about", "Jabout", "_target", "_about", "Jtarget"], "_cc": ["_ce", " _ce", " _cd", "_cd", "_cf", " _cf"], "_bcc": [" _bc", " _abc", " _abce", " _abcs", "_abcs", "_abc", "_rbcc", " _abcc", "_bce", "_bc", " _bce", "_abce", "_abcc", "_sbc", "_rbce", "_sbcs", "_bcs", "_sbce", " _bcs", "_sbcc", "_rbc", "_rbcs"]}}
{"id1": "20735941", "id2": "14450108", "code1": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"getFile": ["openfile", "openFile", "openFiles", "createfile", "createFile", "createResource", "getResource", "newResource", "newFiles", "getfile", "getFiles", "openResource", "newFile", "newfile", "createFiles"], "home": ["first", "base", "project", "family", "path", "folder", "log", "include", "default", "owner", "host", "location", "name", "domain", "hub", "this", " HOME", "build", "HOME", "Home", "user", "root", "library", "directory", "parent", "class", "join", "bar", "www", "back", "resource", "plus", "h", "search", "store", "server", "dir", "up", "house", "f"], "fileName": ["FileType", " filePart", "fullPart", "remotePath", " filePath", "fileNum", " fileUrl", "filename", "FileName", "remoteName", "singleName", "fullname", "remoteUrl", "urlname", "singlename", "resourceUrl", " fileNum", "urlName", "fullPath", "filePart", "fileType", "FilePath", "FileNum", "FilePart", "urlPath", "singlePath", "fullName", "resourcePath", " filename", " fileType", "urlNum", "filePath", "fileUrl", "singleType", "resourceName", "Filename"], "file": ["fp", "FILE", "base", "job", "place", "local", "output", "e", "use", "el", "feed", "zip", "current", "child", "model", "db", "path", "folder", "log", "function", "money", "filename", "name", "play", "image", "lock", "ile", "fe", "plain", "run", "lib", "or", "File", "type", "live", "connection", "class", "user", "object", "parent", "rule", "handler", "table", "buffer", "uri", "resource", "it", "get", "http", "store", "l", "line", "source", "work", "up", "data", "dir", "letter", "full", "part", "f", "le", "be"], "url": ["ource", "address", "base", "job", "bb", "ob", "el", "feed", "io", "URL", "zip", "path", "log", "sl", "Url", "host", "location", "string", "name", "ls", "conn", "image", "lib", "org", "ssl", "i", "r", "connection", "b", "object", "rule", "www", "pull", "loc", "socket", "ur", "fr", "uri", "service", "api", "resource", "lr", "http", "l", "source", "server", "data", "page", "download", "coll", "impl", "web", "rl", "f", "il"], "in": ["gin", "ins", "reader", "din", "IN", "login", "bin", "e", "io", "inc", "isin", "ini", "input", "In", "s", "stream", "inner", "image", "c", "a", "i", "r", "b", "n", "again", "pull", "socket", "resource", "inn", "plus", "is", "into", "l", "data", "line", "up", "source", "inside", "init", "lin", "ac", "as", "f"], "out": ["net", "exec", "flow", "base", "OUT", "client", "outs", "IN", "output", "bin", "exp", "io", "inc", "conn", "ext", "In", "inner", "to", "write", "err", "this", "Out", "plain", "writer", "i", "b", "again", "object", "ex", "o", "null", "co", "socket", "sync", "resource", "copy", "is", "line", "data", "source", "up", "init", "serv"]}}
{"id1": "886783", "id2": "12171364", "code1": "    private static void doGet(LNISoapServlet lni, String itemHandle, String packager, String output, String endpoint) throws java.rmi.RemoteException, ProtocolException, IOException, FileNotFoundException {\n        String itemURI = doLookup(lni, itemHandle, null);\n        URL url = LNIClientUtils.makeDAVURL(endpoint, itemURI, packager);\n        System.err.println(\"DEBUG: GET from URL: \" + url.toString());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setDoInput(true);\n        fixBasicAuth(url, conn);\n        conn.connect();\n        int status = conn.getResponseCode();\n        if (status < 200 || status >= 300) {\n            die(status, \"HTTP error, status=\" + String.valueOf(status) + \", message=\" + conn.getResponseMessage());\n        }\n        InputStream in = conn.getInputStream();\n        OutputStream out = new FileOutputStream(output);\n        copyStream(in, out);\n        in.close();\n        out.close();\n        System.err.println(\"DEBUG: Created local file \" + output);\n        System.err.println(\"RESULT: Status=\" + String.valueOf(conn.getResponseCode()) + \" \" + conn.getResponseMessage());\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"doGet": [" doGET", "DoGET", "toPut", " doPut", "Doget", "doGET", "toGet", "DoPut", "doPut", "toGET", " doget", "doget", "DoGet", "toget"], "lni": ["ldi", "Lii", " lti", "rni", "Lni", "iolti", "lti", "iolni", "rdi", "rii", "Lti", "iolii", " lii", "Ldi", "rti", "ioldi", "lii", " ldi"], "itemHandle": ["pageHandle", "pageAddress", "ItemHand", " itemHand", "itemAddress", "itemsHandler", "ItemHandle", "itemHand", "ItemHandler", "ItemFile", "Itemhandle", " itemHandler", "itemhandle", " itemAddress", " itemFile", "pageURI", "pagehandle", "itemHandler", "itemFile", "itemsHandle", "itemsFile", "itemsHand", "ItemURI", "ItemAddress", " itemhandle"], "packager": ["packageagger", "ackagger", "importaging", "packageatter", "Packager", "packaging", "paramenger", "paramagers", "packenger", "Packagger", "importagers", "importenger", "packatter", "packagers", "paramager", "packageaging", "installager", "ackager", "installaging", "packagger", "ackaging", "packageager", "Packaging", "Packatter", "installagers", "importager", "paramaging", "installenger", "ackatter"], "output": ["external", "address", "written", "header", "console", "model", "path", "xml", "log", "environment", "Output", "input", "target", "filename", "string", "profile", "four", "ilo", "queue", "generated", "write", "prefix", "image", "format", "reference", "connection", "application", "null", "online", "config", "outer", "message", "debug", "buffer", "resource", "office", "version", "document", "page", "source", "file", "summary", "web", "control", "response", "il", "module"], "endpoint": [" Endpoint", "endPoint", "Endbase", " Endbase", "endedpath", " endbase", "endbase", "endpath", " endpoints", " endocol", "restPoint", " Endpoints", "EndPoint", "endedend", "Endpoint", "endedPoint", "endend", "restpoint", "restpath", "Endpath", "Endpoints", "endedpoint", " Endocol", "restend", "Endocol", "Endend", "endocol", "endpoints"], "ProtocolException": ["ProtoBase", "ProtocolHandler", "ProtportException", "InterocolFailure", "ProtoException", "ProtportHandler", "ProtoHandler", "ProtocolBase", "InterocolHandler", "InterportException", "ProtInterfaceFailure", "ProtportBase", "ProtocolFailure", "InterocolBase", "ProtoFailure", "ProtInterfaceHandler", "InterportFailure", "ProtInterfaceBase", "InterportBase", "InterocolException", "ProtportFailure", "InterportHandler", "ProtInterfaceException"], "IOException": ["IOError", "RemoteEx", "SecurityEx", "SecurityError", " IOError", "SecurityException", "RemoteException", " IOEx", "RemoteError", "IOEx"], "FileNotFoundException": ["FileNotfoundExcept", "FileNotFoundError", "FileIsAvailableError", "FileNotfoundException", "FileNotAvailableError", "FileIsFoundExcept", "FileIsFoundError", "FileNotAvailableExcept", "FileIsAvailableExcept", "FileNotAvailableException", "FileNotfoundError", "FileNotFoundExcept", "FileIsAvailableException", "FileIsFoundException"], "itemURI": ["objectUrl", "containerURI", "objecturi", "itemURL", "objectURI", " itemUrl", "containerRI", "ItemRI", "Itemuri", "itemuri", "itemUrl", " itemRI", "ItemURL", "objectURL", "itemRI", "ItemURI", " itemuri", "containerURL", "containeruri", "ItemUrl", " itemURL"], "url": ["address", "base", "client", "job", "bb", "ob", "el", "id", "zip", "io", "URL", "db", "path", "log", "sl", "Url", "host", "location", "ls", "li", "stream", "image", "c", "hub", "org", "ssl", "connection", "i", "method", "user", "object", "ll", "www", "loc", "ur", "uri", "resource", "key", "http", "l", "page", "entry", "file", "server", "channel", "download", "source", "coll", "impl", "web", "rl", "f", "il"], "conn": ["exec", "cm", "cf", "error", "client", "ca", "uc", "ann", "ai", "io", "not", "db", "ctx", "connect", "oss", "sql", "conv", "cp", "core", "ci", "c", "err", "rt", "adj", "auth", "ct", "ssl", "en", "connection", "ec", "Connection", "n", "enc", "co", "socket", "nt", "sync", "config", "sn", "dc", "api", "open", "close", "orp", "dn", "http", "rc", "cli", "col", "oa", "cn", "ch", "act", "fn", "server", "coll", "pc", "fail", "con", "nc", "Conn", "serv", "conf", "cb", "connected", "po"], "status": ["score", "cm", "result", "header", "error", "stat", "Status", "level", "received", "grade", "sr", "ity", "str", "login", "site", "id", "zip", "pre", "current", "progress", "xml", "index", "state", "size", "err", "success", "prefix", "si", "code", "rate", "reason", "type", "ssl", "method", "active", "class", "sync", "message", "date", "version", "api", "ix", "content", "cli", "source", "server", "sex", "stage", "warning", "fail", "json", "response", "msg"], "in": ["gin", "ins", "din", "reader", "IN", "login", "bin", "id", "isin", "inc", "io", "ini", "input", "In", "inner", "stream", "or", "a", "i", "r", "rx", "n", "again", "o", "pull", "socket", "nin", "win", "inn", "min", "pin", "cin", "lin", "data", "up", "source", "inside", "init", "rin", "con"], "out": ["exec", "net", "gin", "img", "OUT", "client", "outs", "cache", "w", "bin", "exp", "io", "inc", "ou", "log", "ext", "obj", "on", "doc", "err", "off", "this", "Out", "plain", "self", "lib", "extra", "at", "writer", "user", "ex", "again", "parent", "n", "o", "co", "sync", "outer", "min", "plus", "copy", "line", "file", "up", "ch", "temp"]}}
{"id1": "21125261", "id2": "6188784", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"test": [" testing", " solve", " verify", " tests", " eval", " analyse", " validate", " simulate", " deploy", " process", "Test", " train", "train", "evaluate", " example", " evaluate", " run", " sample", "execute", "Train", "Main", " check", "tests", "run"], "is": ["serv", "ais", "ins", "ai", "does", "iso", "isa", "has", "id", "IS", "bis", "ws", "Is", "es", "res", "ir", "out", "s", "ls", "ris", "stream", "si", "iss", "ios", "os", "ses", "i", "info", "lis", "ps", "isi", "ics", "fs", "opens", "its", "gets", "iris", "in", "ists", "src", "as", "mis"], "byteArrayOutputStream": ["byteStringInputPath", "byteArrayoutputStream", "byteArrayByteStream", "byteStringInputContext", "byteArrayOutputPath", "byteArrayFileStream", "byteArrayOutputSteam", "byteStringInputString", "byteArrayByteFile", "byteArrayInputPath", "byteStringInputSteam", "byteArrayOutputContext", "byteArrayFileString", "byteArrayOutputString", "byteArrayFileSteam", "byteArrayOutputFile", "byteArrayByteSteam", "byteArrayoutputSteam", "byteArrayIOString", "byteArrayInputContext", "byteArrayInputFile", "byteStringOutputPath", "byteArrayIOSteam", "byteStringInputFile", "byteArrayInputStream", "byteArrayIOFile", "byteArrayInputString", "byteArrayIOStream", "byteArrayFileContext", "byteArrayByteString", "byteStringOutputFile", "byteArrayoutputContext", "byteStringOutputContext", "byteArrayInputSteam", "byteStringOutputSteam", "byteStringOutputString", "byteStringInputStream", "byteArrayFileFile", "byteArrayFilePath", "byteStringOutputStream", "byteArrayoutputPath"], "def": ["md", "defined", "de", "da", "base", "pro", "re", "der", "parse", "e", "id", "default", "df", "obj", "define", "decl", "spec", "this", "dem", "info", "des", "definition", "class", "bus", "report", "desc", "config", "Def", "di", "data", "entry", "file", "init", "dist", "ref", "d", "dir", "DE", "frame", "dev", "DEF", "conf", "f"], "se": ["ser", "su", "de", "parse", "lex", "pse", "sem", "zip", "site", "e", "sec", "ste", "sl", "es", "ge", "SE", "te", "s", "sea", "est", "si", "fe", "ses", "sel", "sle", "ase", "ie", "sk", "pe", "so", "see", "ane", "ine", "per", "sche", "cle", "inse", "sed", "service", "ve", "sh", "me", "entry", "ke", "sc", "ade", "ne", "spe", "sp", "ss", "ze", "ce", "le", "be"], "linkId": ["lockById", "lineById", "feedLength", "linkid", "LinkLength", " linkById", "LinkInfo", "feedid", "linkById", " linkid", " linkLength", "lockId", "lockInfo", "linkLength", "feedId", "lineId", "LinkId", "feedInfo", "linkInfo", "lineInfo", "Linkid", " linkInfo"], "segmentId": ["sementId", "segmentsType", "segmentInfo", "selementType", "sementType", "segmentsInfo", " segmentID", "selementId", " segmentsID", "sementID", "segmentsNumber", "negmentId", " segmentsId", "negementCount", "sementNumber", "negementInfo", " segmentType", "segmentCount", " segmentCount", "segmentsID", "segementNumber", "segmentType", "selementID", " segmentsType", "negementId", "negmentNumber", "negementNumber", "sementInfo", "segmentID", "sementCount", "segmentsId", "segementCount", "segementId", "negmentCount", "segmentNumber", "segmentsCount", "selementCount", "segementInfo", "negmentInfo", " segmentsCount"], "linkSegments": ["linkEngines", "linkConnectment", "linkFragments", "linkFraggments", "linkFragures", "lineSegines", "lineSeggments", "lineFragment", "linkIncrements", "linkEnggments", "linkConnectures", "linkEngures", "lineFragments", "linkSeggments", "linkIncrement", "linkSegines", " linkEnggments", "linkSegles", "linkFragines", "linkSegures", "linkEngles", "linkIncreles", "linkEngments", " linkEngures", " linkSegures", "linkConnectgments", " linkEngment", " linkSegment", "lineFragles", " linkSeggments", "linkSegment", "lineSegment", "lineFragines", "lineSegments", "lineSegles", "lineFraggments", "linkIncregments", "linkFragles", "linkConnectments", " linkEngments", "linkEngment", "linkFragment", "linkIncreines"], "segments": ["gegment", "Segments", "scheplings", "pegment", "Seggment", "gegs", "segs", "pegs", "schements", "geplings", "Seggements", "gements", "segment", "Seggments", "pegements", "pements", "seplings", "pegments", "segements", "gegements", "begs", "gegments", "begments", "schegment", "bements", "begment", "peplings", "sements", "schegments"], "frameProperties": ["framePropps", "frameProps", " frameproperties", "framePromperties", "frameproproperties", "frameproeters", " frameProblems", " frameProproperties", " frameproblems", "frameProproperties", "framePromproperties", " frameProps", "framePropblems", " frameProeters", "framePromps", "frameproblems", "framePropeters", "framePrometers", "framePropperties", " frameproproperties", "framePropproperties", " frameprops", "frameprops", "frameProblems", " frameproeters", "frameproperties", "frameProeters"], "time": ["v", "change", "now", "ime", "e", "id", "port", "times", "x", "money", "start", "length", "play", "Time", "tim", "name", "end", "image", "c", "TIME", "step", "rate", "t", "type", "duration", "live", "count", "event", "video", "ice", "speed", "weight", "date", "depth", "timeout", "delay", "h", "once", "age", "cost", "data", "work", "file", "clock", "sleep", "loop", "value", "vel", "f", "activity", "timer", "size", "etime"], "vehicle": ["vertology", "Vehicles", "Vehology", "venicle", " vehology", "bridical", "driicle", "Vehish", "venical", " vehish", "Vehicular", "verticles", " mobicle", "vehicular", " vehicles", "vehicles", "Vehicle", "driical", " vehicular", "bridometry", "verticular", " mobline", "driocity", " mobish", "vehocity", " vehline", "vehical", "venometry", "bridicle", "bridocity", "driometry", "vehline", "vehometry", "verticle", "Vehline", "venocity", " mobicles", "vehish", "vehology"]}}
{"id1": "1357662", "id2": "4798332", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"copyFileTo": ["copyChannelFile", "copyFileFrom", " copyfileTo", "copyChannelFrom", " copyFileFile", " copyfileFile", "copyChannelTO", "copyfileTo", "copyFileFile", "copyFilesFrom", " copyfileFrom", "copyChannelTo", "copyFilesTo", "copyFilesTO", " copyfileTO", "copyfileFrom", "copyfileFile", " copyFileTO", "copyfileTO", " copyFileFrom", "copyFileTO", "copyFilesFile"], "destination": ["separination", "destinator", "separinated", "separinator", "targetinations", " Destribution", "distined", "distination", "targetinate", "Destination", " destribution", "targetination", "Destribution", " destinations", "sourceinated", "Destined", "targetruction", " Destination", "destinations", "destribution", "distinations", " destinator", "configinator", "sourceinations", "sourceination", "destinate", "separinations", " destruction", " Destinator", "sourceinator", "destinated", "distruction", "distinate", "destruction", " destinate", "destined", "distinator", "configination", " destined", "configinations", "Destinations", "configinated", "Destinator"], "srcChannel": ["srcConnection", " srcConnection", "srcContext", "rcConnection", " srcchannel", "sourceContext", "sourceChan", "srcchannel", "sourceChannel", " srcContext", "destchannel", "rcChannel", "srcChan", "destConnection", "rcContext", "rcchannel", "sourcechannel", " srcChan", "destChan", "sourceConnection", "rcChan"], "destChannel": ["srcConnection", " destchannel", "DestConnection", "descButton", "srcButton", " destButton", "restChannel", "sourceChan", " destChan", "restChan", "DestChannel", "srcchannel", "sourceChannel", "DestChan", "destchannel", "srcChan", "Destchannel", "destConnection", "descChannel", " destConnection", "restchannel", "sourcechannel", "destButton", "descchannel", "destChan", "sourceConnection"]}}
{"id1": "1769771", "id2": "14047629", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferfile", " copyChannel", "CopyFile", "CopyChannel", "CopyFiles", "transferFiles", "transferChannel", " copyfile", "Copyfile", "transferFile", "copyfile", "copyChannel", " copyFiles"], "in": ["url", "base", "ins", "reader", "IN", "login", "bin", "id", "io", "inc", "index", "input", "In", "name", "inner", "image", "c", "lock", "m", "i", "ex", "again", "config", "query", "diff", "win", "inn", "min", "pin", "l", "source", "lin", "file", "work", "data", "f"], "out": ["exec", "external", "v", "base", "OUT", "outs", "cache", "w", "call", "output", "io", "x", "default", "target", "conn", "ext", "name", "dot", "string", "image", "write", "c", "off", "prefix", "Out", "plain", "extra", "writer", "user", "b", "ex", "n", "again", "o", "resource", "p", "point", "file", "server", "up"], "inChannel": ["inClient", "outClient", " inchannel", "inputChan", "insChannel", "inChan", " inClient", "InStream", "binClient", "outChan", "InChannel", "winStream", "inchannel", "outchannel", "outStream", "inputStream", "inputchannel", "winchannel", " inStream", "INChan", "InClient", "INchannel", "winChannel", "inStream", "INChannel", " inChan", "winChan", "INStream", "insStream", "InChan", "insClient", "binChannel", "Inchannel", "binChan", "binchannel", "inputChannel", "binStream", "insChan"], "outChannel": ["inManager", "inController", "Outchannel", "outputCh", " outCh", "outputChan", "inputChan", "outputStream", " outConnection", "inChan", " outChan", "nStream", "outCh", "outputchannel", "outChan", "OutConnection", "inchannel", "outchannel", "outputChannel", "outStream", "inputController", "nChan", "inputchannel", "nManager", "outConnection", "inCh", "inStream", " outStream", "outController", "nChannel", "inConnection", " outchannel", "OutChan", "OutChannel", " outManager", "inputChannel", "outManager", "outputController"]}}
{"id1": "14877116", "id2": "20100809", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"cpFile": [" cpFiles", "CopyCode", " copyCode", " cpCode", "CopyFile", " copyFile", "CopyFiles", " copyfile", "Copyfile", "cpFiles", "cpfile", "cpCode", " copyFiles", " cpfile"], "source": ["ource", "template", "url", "base", "client", "token", "grade", "project", "scope", "view", "site", "use", "force", "zip", "current", "scene", "path", "remote", "host", "start", "name", "string", "seed", "secure", "stream", "context", "archive", "image", "Source", "this", "database", "self", "Target", "type", "reference", "connection", "element", "component", "route", "null", "object", "parent", "directory", "dest", "node", "config", "slice", "ources", "table", "iter", "service", "resource", "from", "document", "channel", "file", "server", "se", "subject", "unit", "ce", "SOURCE"], "target": ["ource", "external", "template", "url", "result", "master", "base", "client", "token", "alias", "arget", "project", "output", "site", "port", "force", "current", "proxy", "path", "folder", "owner", "boot", "remote", "host", "name", "top", "archive", "range", "to", "tail", "next", "database", "self", "format", "Target", "global", "reference", "type", "connection", "component", "transform", "root", "route", "object", "parent", "null", "dest", "config", "sync", "nt", "table", "iter", "service", "resource", "it", "content", "copy", "other", "file", "server", "download", "director", "origin", "tor", "home"], "replace": ["complete", "reset", "share", "change", "place", "apply", "allow", "rel", "delete", "multiple", "use", "force", "rm", "cover", "include", "protect", "repeat", "stall", "range", "same", "write", "follow", "remove", "repl", "align", "root", "route", "fill", "hide", "sync", "update", "array", "add", "copy", "insert", "store", "other", "match", "append", "move", "inline", "compatible", "only", "reply", "split", "flash", "placed", "re"], "bufferSize": ["serverSize", "flushLen", "queueLen", "queuesize", "queueSize", "bytesize", "bufferCount", "serverSIZE", " bufferSIZE", " bufferCount", "bufferSIZE", " bufferLen", "byteCount", "buffersize", "queueCount", " buffersize", "flushSIZE", "byteLen", "serversize", "bufferLen", "flushsize", "serverLen", "flushSize", "byteSize"], "src": ["ource", "sys", "bc", "url", "result", "ser", "sr", "flash", "gb", "tmp", "zip", "proxy", "cb", "sub", "cur", "proc", "sl", "input", "start", "secure", "obj", "stream", "archive", "Source", "ruby", "rt", "sel", "ssl", "sb", "sq", "dest", "rec", "loc", "socket", "sync", "ources", "inst", "resource", "rb", "copy", "rc", "in", "sh", "fn", "sc", "server", "reflect", "gz", "RC", "req", "ctx"], "tarn": [" taro", "taur", " tarp", "ttron", "Taran", "ttarp", "thern", "etaran", "yarn", " taran", "tarm", "etarn", "Trn", " tarm", "ttarm", " taur", "taran", "Tron", "Tarn", "ttaur", " taron", "tharo", "tann", "tron", "ntarp", "etann", "Tarm", " tern", "yarm", "ttern", "tarp", "tern", "tharn", "ntann", "ttaron", "ttrn", "wtarm", "etreen", "ttaro", " tron", " trn", "ntaron", "ntarn", "ttann", "Treen", "taron", "ttarn", "trn", " treen", "yaran", "wtarn", " tann", "yern", "taro", "wtern", "treen", "Tann", "wtaran", "thaur"], "tardir": ["Tartart", "Tartir", "tartirs", "tardsirs", "tardsir", "sardsirt", "Tardpath", "tartirt", "tartiri", "sardar", "tarart", "tartar", "Tardirs", "Tardiri", "tarpar", "tartart", "tarar", "tardedirs", "tardsar", "tartire", "tardar", "tardart", "tartpath", "Tardar", "tariri", "tardiri", "tarddir", "tartdir", "tardirs", "sardsir", "tardsdir", "tildart", "tardedir", "Tartiri", "tardpath", "sardire", "tarpirt", "tardedpath", "Tarddir", "Tartar", "Tartpath", "tardspath", "sardirt", "tartir", "tarpire", "tildiri", "Tartirs", "Tartdir", "sardir", "tardsirt", "tardirt", "tildir", "sardsire", "tildar", "tardsire", "tarir", "tardeddir", "Tardir", "sardsar", "tardire", "tarpir", "Tardart"], "n": ["v", "z", "k", " i", "rn", "ng", "N", "e", "un", "nb", "none", "x", "nl", "ns", "conn", "u", "nor", "ln", "c", "nn", "pn", "m", "norm", "j", "en", "i", "g", "number", "nu", "o", "nt", "nw", "sn", "p", "min", "dn", "mn", "in", "na", "fn", "cn", "l", "ni", "d", "num", "ne", "coll", "nc"], "tar": ["csv", "tg", "test", "sv", "ra", "ca", "car", "sr", "flash", "war", "tmp", "ar", "zip", "transfer", "jar", "skip", "tf", "tc", "tan", "cr", "archive", "raf", "large", "ray", "safe", "box", "shape", "par", "dest", "tr", "cloud", "Tar", "pack", "buffer", "copy", "dr", "sh", "cos", "di", "file", "tif", "gz", "rar", "cro", "cat", "trans", "sum", "shr", "temp"], "bytes": ["objects", "classes", "outs", "Bytes", "bles", "eps", "steps", "io", "seconds", "vs", "boot", "es", "out", "values", "ls", "lines", "cells", "resources", "files", "bps", "os", "ones", "words", "items", "b", "vals", "rows", "ops", "runs", "ps", "bits", "pieces", "nets", "blocks", "frames", "les", "pages", "data", "keys", "reads", "ipes", "tes", "bs"], "readn": ["readne", "writeno", "writens", "writene", "readns", " readl", "findlen", "readno", "readN", " readlen", "readlen", "findne", "Readl", "Readlen", "passns", "runn", "passno", "writeN", "runN", " readne", "runns", "writen", "ReadN", " readN", "findn", "runlen", "readl", "passn", "findN", "runl", "runno", "passN", "writelen", "Readn"]}}
{"id1": "5998352", "id2": "755203", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"testStandardTee": ["teststandardMae", "testStandardMae", "testStandardBeed", "teststandardMee", "testStandardTae", "testStandardBees", "testStandardFees", "testStandardFee", "testStandardMee", "testStandardBae", "teststandardTae", "teststandardMeed", "testStandardMeed", "testStandardTeed", "testStandardTees", "testStandardMees", "teststandardTees", "teststandardMees", "teststandardTee", "testStandardBee", "teststandardTeed", "testStandardFae", "testStandardFeed"], "reference": ["external", "address", "test", "pair", "url", "description", "primary", "re", "output", "proxy", "relative", "path", "request", "index", "distance", "target", "pointer", "location", "name", "string", "sequence", "filename", "binary", "archive", "memory", "length", "prefix", "c", "order", "database", "code", "format", "type", "connection", "report", "forward", "ference", "number", "directory", "Reference", "see", "REF", "hello", "specified", "message", "buffer", "attribute", "resource", "version", "uri", "copy", " Reference", "single", "document", "compatible", "server", "remote", "ref", "variable", "References", "rice", "collection", "relation"], "source": ["ource", "url", "result", "reader", "output", "e", "view", "io", "proxy", "input", "target", "temp", "string", "context", "driver", "Source", "fe", "code", "writer", "i", "ie", "r", "g", "connection", "object", "text", "parent", "config", "slice", "table", "buffer", "iter", "service", "resource", "copy", "se", "server", "ref", "src", "ce", "SOURCE"], "destination1": ["constinator1", "constination1", "destinator01", "DestinateOne", "destension0", "constinator01", "destension1", "destentionOnce", "destinate01", "destention1", "destaration0", "destributionOne", "destinateOnce", "destinator1", "destinatorOne", "DestinateOnce", "destinator2", "Destination1", "destinationOnce", "destination0", "DestinationOne", "destinationsOne", "Destension0", "destination01", "destinatorOnce", "destribution0", "destinate2", "Destension1", "Destinate1", "destinations2", "constinationOne", "destinations01", "destribution1", "destensionOne", "DestensionOne", "constination2", "Destination0", "constination01", "destentionOne", "constinatorOne", "destinationOne", "constinator2", "destarationOne", "destinateOne", "DestinationOnce", "destinations1", "destaration1", "destinate1"], "destination2": ["desticationSecond", "destication8", "coordinationSecond", "destignment2", "destationtwo", "descinationsSecond", "destication22", "descination02", "descination1", "destinations02", "Destinate4", "destination02", "destignment1", "destribution8", "destignmentSecond", "destinating4", "destribution22", "destribution2", "coordination8", "destication2", "destinate8", "destributionSecond", "destinationtwo", "destinate22", "destination22", "Destination4", "Destination1", "coordinate2", "destation1", "destinationsSecond", "destinatetwo", "destinatingtwo", "descinations1", "coordinate8", "destinateSecond", "destinationSecond", "Destinatetwo", "coordination22", "descinationSecond", "destinate2", "destation4", "Destinate1", "destinations2", "destination4", "Destination2", "destinate02", "descinations2", "destinating1", "coordination2", "coordinate22", "destinate4", "Destinate2", "destinating2", "Destinationtwo", "descination2", "destination8", "coordinateSecond", "descinations02", "destation2", "destignment02", "destinations1", "destinate1"], "tee": ["cec", "teae", "lei", "eeec", "ettef", "tec", " tei", " teae", "lef", "tei", "eeffe", "eee", "teea", "chei", "chef", "leec", "teee", "eeee", "sef", "etteee", "leffe", "lee", "TEea", "chepe", "chee", " teee", "seee", "TEe", " tec", " teffe", "TEee", "see", "ceee", "etteae", "seae", "lepe", "TEc", "tepe", "tef", "teec", "ettee", "cee", " tef", "teffe", "ceea", "leee", " tepe", " teec", " teea"]}}
{"id1": "7981642", "id2": "10385815", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"update": ["exec", "address", "url", "Update", "send", "change", "save", "updated", "delete", "login", "apply", "sign", "put", "replace", "check", "end", "u", "set", "write", "setup", "build", "auth", "user", "text", "config", "edit", "post", "add", "UPDATE", "key", "insert", "copy", "h", "data", "append", "up", "init", "password", "create", "push", "and", "register", "sum"], "mail": ["address", "url", "md", "ip", "gmail", "login", "local", "phone", "view", "id", "zip", "proxy", "model", "old", "xml", "folder", "dial", "ge", "alt", "host", "name", "string", "contact", "lock", "company", "Mail", "m", "username", "mails", "user", "html", "text", "front", "hello", "gal", "ul", "message", "uri", "office", "date", "who", "source", "server", "file", "dir", "password", "fax", "Email", "value", "group", "label", "msg"], "email": ["address", "url", "md", "ip", "gmail", "description", "login", "enter", "el", "phone", "id", "zip", "model", "old", "xml", "log", "folder", "alt", "host", "name", "note", "li", "archive", "inet", "Mail", "username", "en", "element", "info", "nick", "class", "mails", "text", "n", "eu", "cdn", "online", "hello", "message", "uri", "office", "wd", "dn", "line", "addr", "cn", "dir", "password", "server", "fax", "file", "Email", "ail", "home"], "pwd": ["cpWD", " pWD", "ppass", "Ppass", " ppassword", "Pwh", " ppass", "pppass", "Pws", "ppwd", "pwt", " pws", "pws", "PWD", "hWD", "pwa", "Pwd", "hwa", "cpwt", "pWD", " pwh", " pwt", "Ppassword", "pppassword", "Pwt", "hwd", "cpws", "pwh", " pwa", "cpwd", "Pwa", "ppassword", "ppwh", "hpass"], "firstname": ["newuser", "newname", "firstuser", "firstName", "caseemail", "lastpass", "casepass", " firstemail", "casename", " firstuser", " firstpass", "firstpass", " firstName", "newnames", "caseName", "firstemail", "hostemail", "lastnames", "hostname", "firstnames", " firstnames", "lastemail", "lastkey", "lastuser", "hostName", " firstkey", "lastName", "firstkey", "hostkey"], "lastname": ["firstday", "secondkey", "firstName", "lastaddress", " lastkey", "fulln", "fullname", "lastn", "lastday", " lastday", "secondName", "firstaddress", " lastnames", "fullday", "secondname", "lastnames", "fullnames", "firstnames", " lastaddress", "fullName", "secondaddress", "lastkey", " lastName", " lastn", "firstn", "lastName", "firstkey"], "connection": ["bc", "lc", "cf", "client", "ca", "system", "db", "manager", "function", "creator", "index", "connect", "session", "conn", "context", "response", "c", "cc", "this", "database", "m", "management", "communication", "Connection", "application", "object", "b", "directory", "handler", "config", " Connection", "graph", "condition", "h", "document", "ion", "di", "pool", "sc", "server", "con", "nc", "Conn", "connected", "relation"], "attrs": ["atr", "addras", " attars", "attps", "attRs", " attks", "atributes", "addps", "attras", "addRs", "Attrs", " attps", "atps", " attRS", "attars", " attRs", "attks", "matributes", "addrs", "addRS", "atacts", "atars", "AttRs", "atRS", "attRS", "attr", " attacts", "Attps", "addributes", "matars", "atks", "addks", "matrs", "addars", "atrs", "attacts", "addr", "attributes", "Attars", "Attacts", "matps", "Attributes", "Attr", "Attras", " attributes", "atras", " attr"], "sha": ["ga", "md", "wa", "da", "pa", "base", "ca", "asha", "alias", "ua", "ami", "volume", " SHA", "meta", "hi", "sm", "si", "sa", "SHA", "lambda", "eta", "ka", "a", "ha", "ema", "sche", "mm", "ma", "alpha", "la", "mac", "h", "ya", "pg", "shi", "sh", "na", "password", "HA", "sum", "va", "pi", "acl"], "digest": [" digested", "Digcode", " digests", " digcode", " diged", "mdest", "digEST", "moded", "diggest", " digester", "Diggest", "digester", "Diged", " diggest", " digEST", "digests", "Digests", "diged", "modEST", "tagester", "tagested", "digested", "DigEST", "mdested", "Digester", "tagest", "modest", "Digest", "mdgest", "Digested", "digcode", "tagcode", "modests", "mdester"], "hash": ["url", "base", "ash", "rh", "bin", "cover", "raw", "Hash", "kh", "image", "hex", "code", "auth", "build", "html", "user", "body", "hed", "enc", "block", "ag", "her", "message", "array", "version", "key", "mac", "h", "sh", "match", "bh", "password", "secret", "value", "json", "sum", "ha", "dig"], "ctx": ["bc", "lc", "cl", "cf", "jp", "cm", "mc", "client", "ca", " c", "cv", " cx", "cb", "tx", " cs", "tc", "cci", "context", "conn", "conv", "cr", "cp", "hw", "c", "ci", "cc", "pkg", "ct", "sq", "cca", "cu", "cs", "config", "loc", "anc", " context", "cas", "Context", "ck", "rc", "vc", "qa", "cn", "sc", "fw", " conn", "pc", " rc", "ctrl", "xc", "cmp"], "newName": ["oldAddress", "newEmail", " newname", "Newname", "newAddress", "newname", "NewAddress", "NewName", "NewEmail", " newEmail", " newAddress", "oldname", "oldEmail"], "oldName": ["OldAddress", "newEmail", "OldName", " oldAddress", "oldEmail", "Oldname", "OldEmail", "oldname", " oldname", "oldAddress", " oldHome", "newAddress", "oldPath", "newHome", "origPath", "OldHome", "origEmail", "origName", "OldPath", " oldPath", "oldHome", " oldEmail", "origname"]}}
{"id1": "3375724", "id2": "22552318", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" importarEmissoresDosTitulosf", " importarEmissoresDosTitularf", " importarEmissoresDosTitulof", " importarEmissoresDosTitULoF", " importarEmissoresDosTitulasF", " importarEmissoresDosTituloF", " importarEmissoresDosTitULosf", " importarEmissoresDosTituloFe", " importarEmissoresDosTitulosPF", " importarEmissoresDosTitulasf", " importarEmissoresDosTitularPF", " importarEmissoresDosTitULosFe", " importarEmissoresDosTitulosFe", " importarEmissoresDosTitulasFe", " importarEmissoresDosTitularF", " importarEmissoresDosTitULosF", " importarEmissoresDosTitulasPF", " importarEmissoresDosTitULosPF", " importarEmissoresDosTitularFe", " importarEmissoresDosTitulosF", " importarEmissoresDosTituloPF", " importarEmissoresDosTitULoPF", " importarEmissoresDosTitULoFe", " importarEmissoresDosTitULof"], "pArquivoTXT": ["pArquivaTXT", "pArquivaFEXT", "pArquivDLS", "pArquivoTLS", "pArquivoOTXT", "pArquivoDBT", "pArquivoQBT", "pArquivaTxt", "pArquivoLBT", "pArquivoLLS", "pArquivaFBT", "pArquivoBTP", "pArquivoFEXT", "pArquivoQEXT", "pArquivoDEXT", "pArquivoBLS", "pArquivoFxt", "pArquivaFEMP", "pArquivoFEMP", "pArquivDXT", "pArquivTBT", "pArquivoLxt", "pArquivoTxt", "pArquivoFXT", "pArquivoQxt", "pArquivoOTxt", "pArquivDxt", "pArquivoDLS", "pArquivaTEMP", "pArquivoTBT", "pArquivoFTP", "pArquivTXT", "pArquivTxt", "pArquivoBEMP", "pArquivoFBT", "pArquivaFxt", "pArquivaFXT", "pArquivDBT", "pArquivoBXT", "pArquivoLXT", "pArquivoBBT", "pArquivoBxt", "pArquivaFTP", "pArquivaTEXT", "pArquivTLS", "pArquivoTEXT", "pArquivoTEMP", "pArquivoOTEMP", "pArquivoQXT", "pArquivoOTTP", "pArquivaTTP", "pArquivoTTP", "pArquivaTBT", "pArquivoDxt", "pArquivoDXT"], "pAndamento": [" pAndamentos", " pAndentionoo", " pOrementos", " pOrementoo", " pAndentiono", " pAndentionos", " pOramentO", " pAndementos", " pOremento", " pAndmentoo", " pOramento", " pAndmento", " pOrementO", " pAndamentoo", " pAndmentos", " pOramentos", " pAndamentO", " pAndemento", " pAndentionO", " pOramentoo", " pAndementoo", " pAndmentO", " pAndementO"], "numeroDoRegistro": ["numeroDoregestro", "numeroDoRegiftrano", "numeroDoregistro", "numeroDoRegpectorno", "numeroDoRegistorno", "numeroDoRegistrano", "numeroDoRegpectros", "numeroDoRegiftro", "numeroDoRegestro", "numeroDoregestorno", "numeroDoregistros", "numeroDoregistrano", "numeroDoregestrano", "numeroDoRegestros", "numeroDoRegpectrano", "numeroDoregestros", "numeroDoRegpectro", "numeroDoregistorno", "numeroDoRegestorno", "numeroDoRegestrano", "numeroDoRegiftros", "numeroDoRegistros", "numeroDoRegiftorno"], "in": ["url", "cl", "ins", "reader", "IN", "login", "bin", "inc", "ini", "session", "out", "In", "s", "ln", "err", "c", "m", "t", "i", "r", "connection", "g", "b", "ex", "n", "scan", " out", "again", "with", "span", "query", "config", "slice", "nin", "ner", "inn", "is", "l", " IN", "data", "cin", "kin", "rin", "con", "part", "conf", "f"], "stmtLimpezaInicialDestino": ["stmtLimpezaIniciaDestination", "stmtLimpezaInicialDestao", "stmtLimpezaInicialCombao", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialdestania", "stmtLimpezaInicialDestaco", "stmtLimpezaInicialDesino", "stmtLimpezaInicioDestino", "stmtLimpezaInicialdestino", "stmtLimpezaInicialDesao", "stmtLimpezaInicialdestao", "stmtLimpezaInicialdestination", "stmtLimpezaInicialCombania", "stmtLimpezaInicialdestario", "stmtLimpezaInicialDesaco", "stmtLimpezaInicialdestaco", "stmtLimpezaInicioDestario", "stmtLimpezaInicioDestaco", "stmtLimpezaInicioCombaco", "stmtLimpezaInicialDesario", "stmtLimpezaInicialDestario", "stmtLimpezaInicioCombario", "stmtLimpezaInicioCombino", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialDestania", "stmtLimpezaIniciaDestania", "stmtLimpezaInicialCombination", "stmtLimpezaInicialDestination", "stmtLimpezaInicialCombino", "stmtLimpezaInicialCombaco", "stmtLimpezaInicialCombario", "stmtLimpezaInicioCombao", "stmtLimpezaInicioDestao"], "sql": ["sys", "csv", "url", "result", "sol", "sv", "params", "rl", "stat", "description", "util", "eps", "dl", "el", "id", "zip", "QL", "kl", "term", "shell", "db", "software", "log", "nl", "SQL", "sl", "filename", "string", "seed", "s", "ls", "cmd", "liquid", " SQL", "err", "setup", "spec", "where", "sg", "ssl", "sq", "sb", "html", "ql", "body", "query", "socket", "layout", "install", "sn", "lua", "search", "http", "l", "data", "fn", "expr", "details", "json", "statement", "sf", "comment", "select", "msg", "acl"], "stmtDestino": ["stmtDestin", "stmtDistania", "stmCampino", "stmdDestinos", "stmtdestaco", "stmtCampaco", "stmCampania", "stmtdestorno", "stmtDestorno", "stmtCamporno", "stmDestorno", "stmtCampino", "stmdDestorno", "stmDestino", "stmtDistinos", "stmtDestania", "stmtdestino", "stmCamporno", "stmdDestin", "stmdDestino", "stmtDestinos", "stmtDistaco", "stmtCampania", "stmCampaco", "stmDestaco", "stmtDistorno", "stmtDistin", "stmDestania", "stmtDistino", "stmtDestaco", "stmtdestania", "stmtdestinos", "stmtdestin"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABECALLCO", "TAMANHO_DO_CABECARHOU", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABECALSHI", "TAMANHO_DO_CABISCALHO", "TAMANHO_DO_CABECARCO", "TAMANHO_DO_CABECALSCO", "TAMANHO_DO_CABOCALCO", "TAMANHO_DO_CABISCALHOU", "TAMANHO_DO_CABECALHOU", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABISCALLHO", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABISCALLHOU", "TAMANHO_DO_CABECALCO", "TAMANHO_DO_CABECALLHOU", "TAMANHO_DO_CABECALSHOU", "TAMANHO_DO_CABOCALSHOU", "TAMANHO_DO_CABOCALSCO", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECULHOU", "TAMANHO_DO_CABOCALHOU", "TAMANHO_DO_CABISCALHI", "TAMANHO_DO_CABOCALSHO", "TAMANHO_DO_CABECALSHO", "TAMANHO_DO_CABOCALHO", "TAMANHO_DO_CABISCALLHI"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAPJDO", "TAMANHO_DO_RODAPEJTO", "TAMANHO_DO_RODAPJPO", "TAMANHO_DO_RODAPE_TO", "TAMANHO_DO_RODAPEECDo", "TAMANHO_DO_RODAP_TO", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPEJPO", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAP_PO", "TAMANHO_DO_RODAPE__TO", "TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAPE_PO", "TAMANHO_DO_RODAPJdo", "TAMANHO_DO_RODAPJDo", "TAMANHO_DO_RODAPEECPO", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPE__DO", "TAMANHO_DO_RODAPJTO", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAPE__Do", "TAMANHO_DO_RODAPEECDO", "TAMANHO_DO_RODAPE__do", "TAMANHO_DO_RODAPEJdo"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADANDOS___", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADADOAD", "TAMANHO_DOS_METADADOSJ", "TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADADOSAD", "TAMANHO_DOS_METADANDO___", "TAMANHO_DOS_METADADOTS_", "TAMANHO_DOS_METADANDOJ", "TAMANHO_DOS_METADADOJ", "TAMANHO_DOS_METADADIES_", "TAMANHO_DOS_METADADosAD", "TAMANHO_DOS_METADADIESJ", "TAMANHO_DOS_METADADOPS___", "TAMANHO_DOS_METADANDOS_", "TAMANHO_DOS_METADADIES___", "TAMANHO_DOS_METADADOS___", "TAMANHO_DOS_METADANDO_", "TAMANHO_DOS_METADADOPS_", "TAMANHO_DOS_METADADO___", "TAMANHO_DOS_METADANDOAD", "TAMANHO_DOS_METADANDOSJ", "TAMANHO_DOS_METADANDOSAD", "TAMANHO_DOS_METADADOPSJ", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADADOTSAD"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_POR_REGAS", "TAMANHO_MEDIO_PORPRegIES", "TAMANHO_MEDIO_POR_EGIES", "TAMANHO_MEDIO_POR_REGIES", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_PORPREGAS", "TAMANHO_MEDIO_POR_RegIS", "TAMANHO_MEDIO_PORPRECIS", "TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_POR_RegIES", "TAMANHO_MEDIO_POR_EGIT", "TAMANHO_MEDIO_POR_GIC", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_POR_GIS", "TAMANHO_MEDIO_PORPRECIES", "TAMANHO_MEDIO_PORPRegIT", "TAMANHO_MEDIO_PORPREGES", "TAMANHO_MEDIO_PORPREGIC", "TAMANHO_MEDIO_PORPRECIC", "TAMANHO_MEDIO_PORPRECAS", "TAMANHO_MEDIO_PORPREGIT", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_POR_EGES", "TAMANHO_MEDIO_POR_EGIS", "TAMANHO_MEDIO_PORPREGIS", "TAMANHO_MEDIO_PORPREGIES", "TAMANHO_MEDIO_POR_GAS", "TAMANHO_MEDIO_POR_GIES", "TAMANHO_MEDIO_PORPRegES", "TAMANHO_MEDIO_POR_RECIES", "TAMANHO_MEDIO_POR_RegIT", "TAMANHO_MEDIO_POR_RECAS", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_POR_REGIT", "TAMANHO_MEDIO_POR_RegAS", "TAMANHO_MEDIO_PORPRegIS"], "tamanhoDosArquivos": ["tamanhoDosArqivos", "tamanhoDosArqIVos", "tamanhoDosArqivlos", "tamanhoDosArquivo", "tamanhoDosArquivalo", "tamanhoDosArqIVlos", "tamanhoDosArquervo", "tamanhoDosArquievos", "tamanhoDosArquivalos", "tamanhoDosArquIVos", "tamanhoDosArquivaloes", "tamanhoDosArQUivo", "tamanhoDosArquievOs", "tamanhoDosArquervos", "tamanhoDosArquervoes", "tamanhoDosArQUivos", "tamanhoDosArquIVoes", "tamanhoDosArquievo", "tamanhoDosArQUervlos", "tamanhoDosArQUivOs", "tamanhoDosArquIVo", "tamanhoDosArqivoes", "tamanhoDosArQUervOs", "tamanhoDosArQUervos", "tamanhoDosArquIVOs", "tamanhoDosArquervOs", "tamanhoDosArquivOs", "tamanhoDosArquivlos", "tamanhoDosArquIVlos", "tamanhoDosArqivo", "tamanhoDosArquievlos", "tamanhoDosArquivallos", "tamanhoDosArquivoes", "tamanhoDosArQUivlos", "tamanhoDosArQUervo", "tamanhoDosArqIVo", "tamanhoDosArquervlos", "tamanhoDosArqIVoes"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstimmante", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstimante", "quantidadeDeRegistrosEstivado", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstivante", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstipante", "quantidadeDeRegistrosEstimmada"], "registro": [" registration", "regestulo", "regestration", " registulo", " regestro", "regastro", " regestulo", "regustration", " registros", "regestro", "regastros", "regustro", "regustulo", "regestros", " regestration", "regastulo", " regestros", "registulo", "registros", "regastration", "regustros", "registration"], "campos": [" campo", "CampOS", " caso", "Campas", "campo", " casos", "campOS", "Campos", " campas", " casOS", " casas", "campas", " campOS", "Campo"]}}
{"id1": "13783898", "id2": "8430178", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeFileToFiles", "encodeStringToFiles", "encodeFile2Stream", "encodeFiletoStream", "encodeFileFromFile", "encodeFileFromStream", "encodeFiletoFile", "encodeString2File", "encodeFiletoFiles", "encodeString2Files", "encodeFile2File", "encodeString2String", "encodeString2Stream", "encodeFileFromString", "encodeFileToString", "encodeFile2String", "encodeStringToString", "encodeFileToStream", "encodeFiletoString", "encodeStringToStream", "encodeFile2Files", "encodeStringToFile"], "infile": ["Infile", "infiles", "inputFile", "InFile", "inFile", "Infiles", "outFile", "inputfiles", "infilename", "outfilename", " infilename", "outfiles", "inputfp", "infp", " infiles", "inputfilename", " infp", "outfp", "Infilename", "inputfile"], "outfile": ["outputfilename", "newname", "Outname", "newFile", "outname", "infolder", "newfolder", " outname", "Outfolder", "outFile", "outfolder", " outfolder", "infilename", "outfilename", "outputfp", " outFile", "outputfile", " outfilename", " outfp", "newfile", "infp", "OutFile", "outputfolder", "Outfile", "outfp"], "in": ["gin", "base", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "vin", "ini", "input", "ic", "In", "s", "conn", "inner", "image", "err", "inas", "m", "a", "i", "r", "b", "again", "sin", "socket", "nin", "win", "inn", "min", "pin", "is", "into", "cin", "data", "source", "init", "inside", "rin", "pass", "ac", "con", "as"], "out": ["net", "exec", "base", "error", "OUT", "client", "outs", "cache", "job", "output", "bin", "ou", "io", "inc", "one", "session", "conn", "obj", "In", "inner", "on", "name", "to", "image", "err", "write", "off", "no", "Out", "lib", "or", "writer", "ex", "parent", "again", "o", "co", "socket", "sync", "post", "outer", "timeout", "point", "copy", "line", "source", "work", "file", "up", "home", "exit"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bb", "transfer", "feed", "raw", "fb", "input", "border", "length", "seed", "binary", "offset", "queue", "write", "len", "layer", "type", "reference", "batch", "count", "b", "null", "buf", "slice", "padding", "iter", "bytes", "wave", "flush", "data", "source", "server", "limit", "value", "split", "size", "buff"], "read": ["exec", " skip", " Read", "ip", "reader", "send", " copy", "parse", "lex", "allow", "use", "id", "feed", "io", "load", "inc", "raw", "current", "_", "check", "x", " count", "input", "connect", "start", "length", "ind", "play", "seek", "end", "write", "next", "len", "i", "count", "ride", "wait", "fill", "n", "find", "Read", "slice", "sync", "READ", "tell", " write", "ad", "iter", "close", "add", "get", "copy", "work", "sleep", "se", "limit", "reads", "pass", "reading", "size", "select", "f", "run"], "success": ["complete", "first", "result", "error", "cess", " succ", "fast", "status", "ccess", "growth", "follow", "flash", "primary", "right", "Success", "valid", "model", "func", "path", "default", " succeed", " Success", "true", "winner", "rolled", "results", "xx", "failed", "danger", " successful", "construct", "method", "null", "again", "ceed", "good", "message", "done", "rolling", "successfully", "respons", "content", "continue", "data", "warning", "successful", "pass", "roll", "initial", "better", "fail", "value", "open", "modified", "comment", "response"]}}
{"id1": "3584508", "id2": "539195", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copyResource": [" downloadUrl", "transferUrl", " downloadresource", " copyFile", "copyresource", "transferresource", "copyFile", "transferFile", " copyresource", "copyUrl", "transferResource", " copyUrl", " downloadResource", " downloadFile"], "url": ["ource", "address", "base", "re", "id", "feed", "URL", "path", "xml", "sl", "Url", "host", "remote", "string", "name", "ls", "stream", "image", "ssl", "connection", "r", "object", "www", "loc", "loader", "uri", "lr", "resource", "bel", "http", "l", "page", "source", "file", "data", "server", "download", "ref", "src", "web", "f"], "input": ["exec", "address", "base", "error", "reader", "audio", "client", "cache", "bb", "bin", "parse", "feed", "current", "inc", "load", "progress", "Input", "xml", "request", "index", "session", "but", "out", "context", "binary", "stream", "inner", "image", "this", "upload", "element", "ssl", "i", "active", "connection", "config", "pull", "socket", "buffer", "resource", "inf", "api", "form", "plus", "get", "http", "in", "l", "source", "data", "accept", "qa", "act", "file", "instance", "ack", "open", "f", "temp"], "output": ["flow", "external", "address", "result", "console", "cache", "ou", "current", "put", "log", "default", "environment", "Output", "target", "production", "out", "binary", "stream", "queue", "image", "write", "operation", "layer", "writer", "connection", "application", "object", "config", "socket", "outer", "buffer", "resource", "copy", "document", "other", "source", "data", "file", "network", "unit", "web", "control", "response"], "b": ["bc", "k", "v", "base", "bit", "bb", "ob", "bin", "e", "br", "nb", "db", "x", "fb", "mb", "abs", "binary", "c", "m", "a", "sb", "batch", "lb", "i", "bar", "buf", "r", "n", "buffer", "ab", "p", "rb", "h", "line", "l", "pb", "file", "d", "B", "bf", "f", "bs", "cb", "bi", "be"]}}
{"id1": "6188784", "id2": "23666867", "code1": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["map", " copying", "change", "transfer", "zip", "Copy", "put", "replace", "cp", "to", "lock", "Cop", " cp", "cop", "sync", "clip", "p", " transfer", "move", "file", "download", "create", "split", " Copy", "clone", "cmp"], "source": ["ource", "base", "ins", "reader", "cache", "site", "use", "id", "path", "remote", "input", "target", "start", "name", "stream", "inner", "Source", "down", "ie", "i", "connection", "route", "parent", "sin", "slice", "sync", "ources", "iter", "resource", "from", "file", "up", "src", "origin", "unit", "SOURCE"], "dest": ["test", "de", "result", "cont", "thin", "img", "sup", "delete", "bin", "tmp", "comb", "which", "folder", "target", "flat", "down", "Dest", "desc", "orig", "wb", "done", "dc", "destroy", "dir", "dist", "style", "d", " destination", "src", "coord", "die", "later", "home", "exit", "temp"], "in": ["url", "gin", "base", "ins", "thin", "din", "reader", "IN", "client", "login", "bin", "id", "isin", "inc", "include", "ini", "plugin", "input", "issue", "In", "s", "conn", "inner", "name", "image", "err", "c", "m", "ie", "i", "r", "connection", "again", "n", "parent", "sin", "pull", "socket", "nin", "win", "inn", "resource", "min", "pin", "plus", "it", "into", "cin", "work", "file", "up", "inside", "init", "src", "pc", "con", "ac", "as", "f"], "out": ["exec", "net", "OUT", "client", "outs", "w", "call", "output", "bin", "id", "ou", "io", "exp", "not", "one", "outside", "conn", "ext", "name", "inner", "obj", "prefix", "err", "off", "no", "write", "Out", "plain", "this", "lib", "down", "extra", "at", "writer", "connection", "i", "ex", "n", "parent", "again", "o", "socket", "sync", "outer", "buffer", "option", "timeout", "other", "pool", "file", "up", "channel", "password", "vert", "our", "cat", "part"], "size": ["address", "send", "e", "transfer", "sec", "x", "Size", "export", "start", "length", "iz", "name", "offset", "end", "seek", "time", "clear", "order", "len", "si", "max", "small", "en", "mode", "count", "shape", "number", "ice", "n", "SIZE", "sized", "any", "empty", "loc", "speed", "sync", "depth", "ize", "open", "close", "scale", "bytes", "content", "flush", "add", "width", "capacity", "unit", "sum", "izes"], "buf": ["Buffer", "uf", "map", "bc", "vec", "cf", "ra", "uc", "bin", "br", "bd", "cv", "ctx", "fb", "ba", "seq", "pkg", "len", "bag", "box", "b", "ha", "ff", "buffer", "BU", "fam", "la", "bytes", "rb", "cas", "feat", "data", "coll", "bf", "src", "cb", "buff", "cmp"]}}
{"id1": "8452134", "id2": "2009072", "code1": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "code2": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "label": 0, "substitutes": {"exists": ["xist", "resist", "exist", "esist", "actisting", "Existing", "resisting", "resists", "actistent", "esisting", "Existent", "xits", "Exist", "existing", "existent", "esists", "xists", "exits", "xisting", "Exists", "Exits", "actists", "resits", "esistent", "actist"], "fileToCheck": ["filetocheck", "entryTocheck", "stringToTest", "entryToChe", "entryTOChe", "fileTOChe", "entryTOcheck", "fileToChe", "fileToTest", "fileTOCheck", "filetoTest", "filetoChe", "fileTocheck", "entryToCheck", "entryTOCheck", "entryTOTest", "stringToCheck", "fileTOcheck", "filetoCheck", "stringTocheck", "entryToTest", "fileTOTest"], "ftp": ["fftp", "mailpc", "lfps", "oftp", "uft", "ntp", " fta", "ftip", "uffp", "ftfp", " ftpb", "lfp", "FTap", "alttp", "aftpc", " ftpa", " ftb", "FTps", "lftp", " ftt", "ctp", "rtp", "tta", "ftpc", "mailp", "ftap", "rta", "afttp", "fp", "ftw", "nta", "ufp", "ftpb", " ftcp", "ftb", "ftpo", "ft", "ttcp", "fta", "ftbr", "uttp", "ftsp", "cfps", "ffpo", "fcp", "ctpo", "altpc", "ufcp", "ttp", "ktpc", "oftip", "aftp", " ftw", " ftip", "aftcp", " ftpo", "utpc", "rtpc", "cftp", "htip", "cttp", "ntcp", "ftcp", "ctcp", "ffp", "mailtp", "ktp", "ftsps", "kta", "fpc", " ftap", "ffcp", "fttp", " fttp", " ftpc", "altw", "utp", "htpa", " ftfp", "utw", "htp", "htbr", "ftps", "ftpa", "ttps", "ntps", "altp", "ftsb", "rtpb", " ftps", "oftbr", "mailcp", "ktpb", "FTb", "oftpa", "FTp", "cfpo", "ftsap", "ftt", "cfp", " ftbr", "lfpo"], "found": ["first", "defined", "result", "error", "received", "local", "updated", "finder", "left", "connected", "valid", "old", "default", "index", "fl", "flat", "val", "length", "locked", "Found", "bug", "given", "ret", "err", "success", "len", "failed", "read", "checked", "all", "confirmed", "count", "used", "active", "find", "built", "nt", "good", "iter", "loaded", "broken", "search", "fd", "finding", "l", "fixed", "pos", "successful", "full", "f", "sent", "expected", "response"], "reply": ["address", "result", "base", "error", "send", "received", " response", "status", "call", "answer", "comment", "force", "rr", "request", "index", "length", "next", "err", "len", "write", "link", "bot", "prefix", "code", "respond", "read", "reason", "repl", "info", "connection", "report", "Reply", "text", "echo", "query", "sync", "post", "message", "ply", "buffer", "service", "dy", "lying", "match", "resp", "continue", "server", "cause", "data", " replies", " replied", "part", "sent", "zero", "response"]}}
{"id1": "9272325", "id2": "335223", "code1": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"sendPost": ["postpost", "postPOST", "sendPOST", "dopost", "sendpost", "doPOST", "SendMethod", "sendMethod", "Sendpost", "doMethod", "doPost", "SendPOST", "postMethod", "postPost", "SendPost"], "reqUrl": ["requestLine", " reqRoute", "reqURL", "downloadEmail", "requUrl", "downloadUrl", "requestUr", "requestEmail", "downloadURL", "reqLine", "requLine", "requURL", "requUr", "requestRoute", "downloadLine", "requestURL", "requEmail", "reqEmail", "requestUrl", " reqURL", "reqRoute", "requRoute", "reqUr", " reqUr"], "parameters": ["paramsams", "paramsations", "pareters", "arameter", "parations", "paramams", "paramations", "paramseter", "paramsParameters", "mandeter", "parameter", "aramams", "mandeters", "mandParameters", "arameters", "paramseters", "pareter", "mandations", "parParameters", "paramParameters"], "urlConn": ["URLConnect", "urlConnect", "reqComm", "webConnection", " urlConnect", "obConnection", "buildConnector", "lconn", "returnConn", "httpExec", "elConnect", "webContainer", "buildConnection", "baseConnection", "blogConnection", "logConnect", "buildConn", "urlConnection", "blogContainer", "elCon", "returnConnect", "httpConn", "bbCon", "URLClose", "bbConnection", "logCon", "webCon", "urlReg", " urlConnection", "webconn", "httpSync", "userConn", "baseConn", "userConnect", " urlconn", "returnCon", "httpCon", " urlReg", "urlContainer", "urlExec", "returnConnection", "webConn", "userConnection", " urlContainer", "baseConnect", "lComm", "lConn", "bbConn", "obReg", "elConn", "httpConnect", "urlSync", "webSync", " urlSync", "urlComm", "URLConn", "blogConn", "webClose", "baseCon", "logConnection", " urlInfo", "urlCon", "urlConnector", "webExec", "httpConnector", "httpComm", "URLconn", "obConnect", " urlClose", "httpReg", "reqConnection", "bbConnector", " urlCon", "httpConnection", "httpconn", "urlconn", "reqConn", "logConn", "lConnection", "elConnection", "webConnect", "buildCon", "urlInfo", "httpInfo", "blogCon", "urlClose", " urlExec", "obConn", "reqconn", "userInfo"], "params": ["posts", "Param", "tmp", "URL", "tags", "Parameters", "_", "request", "Url", "res", "string", "s", "Par", "param", "lines", "prefix", "resources", "database", "bps", "properties", "options", "par", "body", "ps", "query", "config", "apps", "uri", "parts", "api", "array", "bytes", "http", "ams", "l", "data", "pages", "req", "json", "points", "names", "manager", "rules", "response", "settings"], "url": ["lc", "base", "job", "ob", "URL", "path", "log", "sl", "Url", "host", "Config", "string", "conn", "ls", "obj", "gl", "c", "orb", "layer", "ssl", "i", "r", "connection", "n", "ll", "www", "config", "loc", "ur", "lr", "uri", "api", "resource", "bel", "http", "l", " URL", "data", "page", "server", "source", "web", "rl", "blog", "f"], "b": ["v", "base", "bb", "ob", "gb", "e", "bin", "br", "bd", "nb", "emb", "db", "boot", "ba", "fb", "mb", "binary", "obj", "c", "bl", "buff", "a", "i", "r", "lb", "sb", "null", "buf", "body", "bar", "wb", "buffer", "ab", "bytes", "rb", "l", "data", "pb", "B", "bf", "bs", "f"]}}
{"id1": "18504192", "id2": "3958807", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "in": ["url", "base", "ins", "reader", "IN", "login", "bin", "id", "io", "inc", "old", "ini", "index", "input", "In", "name", "inner", "image", "c", "m", "or", "at", "i", "info", "b", "again", "parent", "diff", "buffer", "inn", "min", "copy", "data", "file", "d", "src", "ac", "part"], "out": ["exec", "external", "base", "OUT", "client", "outs", "cache", "w", "call", "output", "io", "inc", "target", "name", "conn", "obj", "string", "c", "err", "prefix", "Out", "writer", "connection", "b", "ex", "n", "object", "again", "o", "dest", "p", "copy", "point", "line", "data", "file", "password", "part", "temp"], "source": ["ource", "slave", "reader", "client", "project", "scope", "view", "use", "proxy", "sl", "input", "target", "start", "core", "secure", "stream", "Source", "settings", "self", "storage", "clone", "ssl", "ie", "i", "connection", "component", "writer", "null", "parent", "sin", "dest", "slice", "sync", "ources", "iter", "service", "get", "copy", "from", "channel", "se", "server", "src", "origin", "unit", "size", "SOURCE"], "destination": ["destinator", "testinations", "Destinated", "Destification", "Destining", " destining", "Destination", "testinated", "dependification", " destinations", "destinations", "declification", "declinated", " destinator", "declinator", "contining", "dependinated", "testination", " destinated", "declination", "dependination", "destinated", "testinator", "destining", "contination", "dependinator", "destification", "Destinations", "continated", "Destinator", "continator"]}}
{"id1": "3731077", "id2": "7425022", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferSourceFile", "transferfile", "importFile", "transferFiles", "copySourceFile", " copyfile", "importSourceFile", "importfile", "transferFile", "importFiles", "copyfile", " copySourceFile", " copyFiles"], "from": ["address", "url", "base", "client", "ca", "left", "id", "io", "old", "path", " form", "of", "remote", "start", "name", "range", "original", "c", "this", "or", "at", "a", "user", "front", "ce", "o", "with", "back", "config", "without", "resource", "add", "by", "form", "source", "before", "file", "se", "data", "From", "d", "src", "about", "origin", "part", "as", "f"], "to": ["two", "eto", "base", "client", "token", "output", "site", "io", "one", "of", "TO", "target", "temp", "location", "auto", "name", "top", "this", "database", "toc", "storage", "os", "or", "t", "at", "type", "root", "b", "null", "parent", "To", "so", "o", "dest", "object", "with", "again", "socket", "office", "api", "p", "by", "copy", "into", "point", "source", "too", "file", "about", "until", "as", "size", "f", "po"], "parentDir": ["ParentFolder", "ParentDir", " parentdir", "rootDirectory", "rootFolder", "parentDirectory", "currentDir", "outDir", "outFolder", " parentFolder", "currentdir", "ParentDirectory", "ParentFile", "Parentdir", "parentFile", "outFile", "outDirectory", " parentDirectory", " parentFile", "currentFolder", "rootDir", "rootFile", "currentFile", "parentdir", "parentFolder"], "in": ["exec", "url", "gin", "ins", "din", "reader", "IN", "login", "bin", "id", "pre", "io", "inc", "isin", "vin", "ini", "plugin", "input", "In", "conn", "on", "inner", "image", "err", "m", "or", "ie", "i", "r", "trial", "again", "o", "rec", "fc", "sync", "diff", "with", "nin", "win", "inn", "min", "it", "pin", "form", "rc", "cin", "l", "source", "work", "lin", "init", "kin", "inside", "arin", "pc", "rin", "con", "ac", "part"], "out": ["net", "exec", "gin", "ico", "OUT", "client", "outs", "cy", "w", "call", "output", "bin", "app", "ot", "io", "inc", "ou", "plugin", "input", "on", "conn", "auto", "inner", "c", "off", "Out", "org", "or", "at", "writer", "user", "again", "ex", "o", "co", "sync", "win", "outer", "option", "p", "other", "cin", "vert", "channel", "op", "init", "about", "ac", "can"], "ic": ["bc", "lc", "cl", "mc", "ico", "ai", "uc", "io", "inc", "input", "iac", "conn", "auto", "IC", "ci", "c", "cc", "or", "ec", "ct", "i", "acs", "irc", "icc", "ex", "cu", "cs", "voc", "o", "co", "enc", "ig", "aic", "fc", "ics", "loc", "anc", "cus", "sync", "dc", "ix", "pic", "cin", "vc", "ik", "op", "rc", "pc", "ac", "nic", "xc"], "oc": ["OC", "bc", "oco", "ocon", "aco", "mc", "cy", "uc", "ca", "can", "oca", "ob", "io", "inc", "circ", "cur", "roc", "oci", "soc", "ci", "c", "cc", "og", "toc", "nic", "wic", "alloc", "org", "or", "ec", "i", "acs", "voc", "o", "co", "fc", "loc", "enc", "mic", "anc", "cus", "aic", "dc", "ocol", "vc", "op", "sc", "pc", "ac", "ack", "AC", "xc"]}}
{"id1": "14303294", "id2": "16556717", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"getServerHash": ["getserverHash", "getSecureHash", " getServerSalt", "getSessionSHA", "getSessionAddress", "getSecureAddress", "getSecureSalt", " getServerSHA", "getserverSalt", "getSessionHash", " getSecureSHA", "getServerAddress", "getserverSHA", " getSecureAddress", "getServerSalt", "getserverAddress", "getSecureSHA", " getSecureSalt", "getServerSHA", " getSecureHash", " getServerAddress", "getSessionSalt"], "passwordHash": ["Passwordhash", "PasswordCode", "passwordSalt", "privatehash", " PasswordCode", " passwordPassword", "privateSalt", " passwordCode", "privateHash", "passwordPass", " passwordhash", " PasswordHash", "PasswordPass", "privatePassword", " passwordSalt", "PasswordPassword", "passwordhash", "passwordCode", " PasswordPass", "PasswordHash", " passwordPass", "passwordPassword"], "PasswordSalt": ["PASS256", " passwordSecret", "passwordSalt", "PasswordSecret", " Password256", " PasswordSecret", " PasswordPassword", " passwordPassword", "password256", "PASSSalt", "PASSPassword", "passwordSecret", " PasswordHash", " passwordSalt", "PasswordPassword", "PASSHash", "PasswordHash", "Password256", "passwordPassword"], "hash": ["address", "url", "result", "base", "sha", "error", "dig", "ash", "cache", "change", "check", "Hash", "log", "row", "string", "kh", "image", "hex", "build", "auth", "code", "crypt", "html", "user", "number", "block", "update", "message", "array", "buffer", "her", "key", "content", "h", "copy", "search", "mac", "sh", "data", "pool", "work", "password", "value", "sum", "size", "ha", "response"], "digest": [" digested", "hashest", "integall", "hashener", " digusher", "signest", " digher", "Digger", "digall", "mdest", "signger", "signher", " digester", "digester", " digall", "digusher", "integested", "digher", "generall", "integester", "Digusher", "hasher", "Digher", "digested", "mdested", "Diger", "Digester", "integest", "hashester", "signester", "diger", "Digest", " diger", "mdusher", "digger", "signer", "Digested", "Digener", "generester", " digener", " digger", "generested", "generest", "digener", "mdester"]}}
{"id1": "7945594", "id2": "12039034", "code1": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "code2": "    public static ArrayList<RoleName> importRoles(String urlString) {\n        ArrayList<RoleName> results = new ArrayList<RoleName>();\n        try {\n            URL url = new URL(urlString);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            StringBuffer buff = new StringBuffer();\n            String line;\n            while ((line = in.readLine()) != null) {\n                buff.append(line);\n                if (line.equals(\"</RoleName>\")) {\n                    RoleName name = ProfileParser.parseRoleName(buff.toString());\n                    results.add(name);\n                    buff = new StringBuffer();\n                } else {\n                    buff.append(NL);\n                }\n            }\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        } catch (ParsingException e) {\n        }\n        return results;\n    }\n", "label": 1, "substitutes": {"fileDownload": [" filedownload", "urlPull", "urlDownload", "filePull", " filePull", " fileURL", "urldownload", "folderdownload", "folderURL", "folderPull", "fileURL", "folderDownload", "urlURL", "filedownload"], "fAddress": ["sfMessage", "bEmail", "urladdress", " fOrder", " fLocation", "FLocation", "rfLocation", "bAdd", " faddress", "fMessage", "fOrder", "fileLocation", "fingAddress", "fileAddress", " faddr", "sfaddress", "urlAddress", " fMessage", "fingAdd", "urlOrder", "sfOrder", " fPath", "fingaddr", "fingEmail", " fAdd", "rfAddress", "bPath", "rfaddress", "FAdd", "FAddress", "sfLocation", "baddr", "fLocation", "baddress", "sfAddress", "fPath", "urlAdd", "faddress", "rfMessage", "faddr", "fAdd", "bLocation", "fileAdd", " fEmail", "fEmail", "sfAdd", "bAddress", "sfPath"], "destinationDir": ["destributionDirectory", "DestributionArea", "destributionPath", "declinatedDur", "destativeDIR", "declinatedPath", "DestinationDir", "destinatedPath", "destributionDar", "destributionDur", "destineDur", "DestinationArea", "destativeDirectory", "destinationArea", "destineDir", "DestinationDirectory", "destippingDirectory", "declinationDir", "DestributionDirectory", "DestributionDIR", "destinePath", "destinationPath", "declinatedDir", "destinatedDir", "declinatedDar", "declinationPath", "destativeArea", "destativeDir", "destippingDir", "DestinationDIR", "destinatedDar", "DestributionDir", "destinationDur", "declinationDur", "destinationDar", "destinationDirectory", "destributionDIR", "destributionDir", "destinatedDur", "destributionArea", "destineDar", "destippingArea", "declinationDar", "destippingDIR", "destinationDIR"], "slashIndex": ["slargeLength", "sllashLength", "slargeCount", "slashedLength", "slashedCount", "SlashedLength", "Slashindex", "slushindex", "SlashLength", "slashedIndex", "slashindex", "SlashedCount", "slargeindex", "slashLength", "Slashedindex", "slushIndex", "slashCount", "sllashCount", "slashedindex", "sllashindex", "SlashCount", "slargeIndex", "SlashIndex", "slushLength", "SlashedIndex", "sllashIndex"], "periodIndex": ["periodindex", "moneyStart", " periodOffset", "periodStart", "moneyIndex", "moneyOffset", "dollarStart", "dollarindex", "periodOffset", " periodindex", " periodStart", "dollarIndex", "dollarOffset", "moneyindex"], "fileName": ["fPath", "fName", " filename", " fileAddress", "filename", "fname", "FileName", "FileAddress", "filePath", "FilePath", " filePath", "Filename", "fileAddress"], "url": ["base", "rel", "re", "str", "ob", "feed", "ou", "proxy", "URL", "path", "log", "sl", "fl", "Url", "oc", "string", "conn", "li", "u", "bug", "image", "c", "link", "org", "ssl", "connection", "user", "ll", "www", "config", "loc", "socket", "ur", "ul", "uri", "service", "api", "resource", "bel", "uu", "http", "plug", "l", "page", "up", "ch", "channel", "server", "download", "open", "web", "rl", "blog", "f"], "uc": ["bc", "lc", "mc", "exc", "uci", "unc", "union", "com", "ou", "cur", "um", "tc", "oc", "conn", "cci", "u", "soc", "stream", "c", "ci", "cc", "hub", "ec", "connection", "auc", "cu", "anc", "fc", "cus", "ul", "UC", "ucc", "http", "rc", "sc", "pc", "con", "ac", "nc", "usc", "uu"], "in": ["gin", "ins", "reader", "din", "IN", "login", "bin", "io", "inc", "ini", "input", "In", "conn", "s", "stream", "inner", "image", "c", "err", "this", "i", "r", "b", "n", "again", "socket", "nin", "inn", "it", "is", "rc", "into", "data", "source", "up", "init", "inside", "lin", "cin", "con", "ac", "f", "cli"], "file": ["fp", "base", "FILE", "place", "output", "e", "zip", "io", "path", "folder", "log", "filename", "name", "to", "ile", "this", "files", "fe", "File", "connection", "class", "b", "parent", "rule", "o", "per", "socket", "resource", "line", "data", "l", "page", "source", "letter", "up", "dir", "full", "book", "f"], "fos": ["fileops", "Fo", "FOS", "fileos", " fOs", " fis", "sfOS", "fOS", "sfos", "fileOs", " fob", "Fops", " fOS", "Fos", "Fis", " fo", " fops", "Fob", "fis", "sfo", "fo", "fileob", "fOs", "fops", "FOs", "fob", "sfis"], "out": ["exec", "net", "OUT", "outs", "w", "output", "bin", "ou", "io", "inc", "log", "string", "s", "inner", "to", "write", "err", "down", "Out", "plain", "writer", "b", "again", "o", "sync", "block", "outer", "update", "flush", "copy", "line", "data", "work", "up", "init", "f"], "inputLine": [" inputRow", "InputBlock", "inputEl", "inputLINE", "outputLINE", "InputL", "outputEl", "InputChar", "inputRow", "errorRow", "outputRow", "errorLine", "outputBlock", "inputL", "Inputline", " inputLINE", "inputline", " inputEl", " inputL", "errorL", "InputLine", "InputEl", "inputChar", "outputline", " inputline", "errorLINE", "outputChar", " inputChar", "outputLine", "outputL", " inputBlock", "inputBlock"]}}
{"id1": "13122204", "id2": "19322941", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"unzipModel": ["UnzipModel", "unzipmodel", "unarchiveProject", "Unzipmodel", "unpatchmodel", "unarchivemodel", "unarchiveModel", "UnarchiveFile", "UnarchiveProject", "unpatchFile", "UnzipFile", "unpatchProject", "unzipFile", "unarchiveFile", "UnzipProject", "unzipProject", "unpackmodel", "UnarchiveModel", "unpackProject", "unpackModel", "unpackFile", "unpatchModel", "Unarchivemodel"], "filename": ["fp", "url", "FILE", "title", "fil", "kl", "model", "path", "folder", "utf", "nil", "location", "string", "name", "database", "files", "jet", "username", "SourceFile", "File", "directory", "loc", "fits", "uri", "fd", "l", "source", "fn", "file", "download", "src", "bf", "txt", "Filename", "f", "il", "module"], "tempdir": ["tmpdirectory", "Tempdirectory", " tempfolder", "tmpDir", " tempDir", "temdir", "TempDir", "temfolder", "tempDir", "temppath", "tmpfolder", "tempfolder", "temDir", "Tempdir", "tmpDIR", " tempdirectory", "TempDIR", "tmppath", " temppath", "Tempfolder", "tempDIR", "temdirectory", "tempdirectory", " tempDIR", "tmpdir", "tempath"], "dest": ["rest", "test", "result", "de", "cont", "st", "sup", "prop", "gen", "delete", "builder", "output", "transfer", "tmp", "zip", "exit", "comb", "proc", "folder", "log", "walk", "default", "export", "target", "flat", "session", "ui", "obj", "inner", "tar", "std", "Dest", "transform", "dat", "desc", "cdn", "handler", "loc", "walker", "nt", "sync", "wb", "done", "dc", "store", "di", "source", "file", "usr", "dist", "dir", "src", "die", "later", "home", "trans", "opt", "txt", " Dest", "temp"], "fis": ["filebis", " fiss", "flisa", "fid", "flis", "liss", "fliss", "fileisa", "fsisa", "fsbis", " fi", "fileis", "li", "lid", "fileid", "fsiss", " fid", "fsis", "filei", "lis", "fbis", "fiss", "fileiss", "fi", "flbis", "fisa"], "BUFFER": ["UPFF", " BUVER", "SAPER", "BUUCK", "BUFER", "BUFF", "CUVER", "TAPER", "BOFFER", "BOPER", "CUUCK", "SAUCK", "CUFFER", "TAVER", "UPFFER", " BUFER", " BUVEN", "CUVEN", "CUPER", " BUFIX", "BOFIX", "CUFF", "SAFFER", "TAFFER", "MAFIX", " BUFF", "MAPER", "BUPER", " BUUCK", "BUFIX", "UPVEN", "BUVEN", "MAFER", "MAFFER", "BOFER", "SAVER", " BUPER", "UPVER", "BUVER", "TAUCK"], "zis": ["zipis", " zists", " zbis", "zipisa", " zisa", "xiss", "diss", " zii", "zins", "Zas", "xis", " zos", "zin", "zii", "xi", "Zisa", " ziss", "zas", " zIS", "yis", "zipIS", "zipas", "zos", "zists", "Zins", "xii", "yin", " zin", "jos", "yIS", "jists", "zi", "Zis", "xos", "jis", "zipins", "dis", "zIS", "yisa", "xists", "zbis", "dbis", "zisa", " zas", "xbis", "dii", " zins", "ji", "zipin", " zi", "ziss"], "entry": ["de", "result", "lc", "reader", "enter", "e", "id", "zip", "feed", "inc", "ace", "ou", "valid", "cel", "je", "ge", "row", "name", "end", "li", "inner", "archive", "image", "next", "spec", "si", "or", "element", "ie", "info", "way", "pe", "ent", "connection", "Entry", "nt", "porter", "her", "pack", "la", "iterator", "jo", "rc", "line", "file", "ry", "se", "match", "source", "server", "ident", "ries", "cat", "part", "record", "ce", "module"], "count": ["base", "cache", "allow", "e", "use", "id", "feed", "current", "_", "Count", "log", "val", "index", "start", "length", "name", "max", "time", "end", "core", "ind", "c", "write", "len", "next", "code", "read", "type", "writer", "i", "counter", "b", "number", "list", "weight", "cond", "buffer", "iter", "add", "key", "line", "in", "file", "last", "low", "pos", "limit", "coll", "part", "sum", "size", "f"], "data": ["result", "base", "reader", "str", "id", "feed", "load", "raw", "DATA", "index", "input", "start", "length", "name", "image", "next", "write", "size", "len", "read", "format", "a", "info", "batch", "dat", "number", "body", "block", "message", "pack", "buffer", "media", "array", "bytes", "alpha", "content", "la", "shift", "pos", "d", "value", "record", "zero"], "fos": ["foes", "dfoes", "fOS", "dfoos", "afos", " foos", "xoes", "afOS", "bis", "xoos", "bOS", " fOS", "dfos", " fops", "afis", "bos", "dfops", "bops", "xos", "fops", " foes", "xops", "afops", "foos"]}}
{"id1": "1362", "id2": "22752444", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubbleOrder", "bubblesort", "bubblerSort", "ubblesort", "ubbleOrder", "ubblingOrder", "bubblingCompare", "bubblingSort", "ubbleCompare", "ubblingSort", "bubbleCompare", "bubblingsort", "ubblingsort", "bubblessort", "bubblingOrder", "bubblesOrder", "ubbleSort", "bubblersort", "ubblingCompare", "bubblerCompare", "bubblesSort", "bubblerOrder", "bubblesCompare"], "a": ["an", "ga", "aaa", "address", "result", "img", "ata", "aw", "sup", "aux", "e", "am", "ba", "index", "abs", "ama", "A", "something", "auto", "s", "u", "another", "c", "sa", "aj", "m", "all", "au", "at", "active", "b", "empty", "any", "o", "ans", "aa", "list", "ma", "alpha", "la", "ab", "ae", "array", "p", "apps", "ad", "access", "tta", "l", "na", "data", "oa", "work", "d", "ac", "area", "f", "ack", "as", "va"], "swapped": ["rewapping", "Swapped", "waps", "swaps", "waped", "Swoped", "wapping", "rewaped", "rewapped", " swaps", "rewoped", "flapping", " swap", "rewaps", "wapped", "flapped", "rewap", "floped", " swapping", "swapping", "Swapping", "wap", "flap", "swap", "Swap", "Swaped", "swoped", "swaped", " swaped"], "i": ["qi", "v", "k", "iv", "ip", "ai", "sup", "ti", "mini", "I", "e", "ami", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "start", "ind", "u", "ui", "li", "hi", "multi", "ci", "next", "anti", "uni", "si", "mi", "ii", "y", "m", "j", "adi", "ie", "info", "ori", "b", "ki", "bi", "ri", "uri", "api", "p", "key", "gi", "h", "ix", "it", "fi", "in", "oi", "l", "di", "init", "ni", "d", "f", "pi", "module"], "tmp": ["foo", "emp", "v", "stuff", " ff", "test", "xxx", "st", "amp", "sup", "bb", "opp", "yy", "pre", "nb", "tt", "vt", "x", "tc", "obj", "angle", "kk", "m", "t", "j", "ie", "prev", "b", "front", "tv", "dest", "pad", "qq", "alpha", "p", "mmm", "addr", "append", "pp", "area", "part", "txt", "f", "mp", "cmp", "temp"]}}
{"id1": "1362", "id2": "1357662", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubbleOrder", "bubblesort", "bubblerSort", "ubblesort", "ubbleOrder", "ubblingOrder", "bubblingCompare", "bubblingSort", "ubbleCompare", "ubblingSort", "bubbleCompare", "bubblingsort", "ubblingsort", "bubblessort", "bubblingOrder", "bubblesOrder", "ubbleSort", "bubblersort", "ubblingCompare", "bubblerCompare", "bubblesSort", "bubblerOrder", "bubblesCompare"], "a": ["an", "ga", "aaa", "address", "result", "img", "ata", "aw", "sup", "aux", "e", "am", "ba", "index", "abs", "ama", "A", "something", "auto", "s", "u", "another", "c", "sa", "aj", "m", "all", "au", "at", "active", "b", "empty", "any", "o", "ans", "aa", "list", "ma", "alpha", "la", "ab", "ae", "array", "p", "apps", "ad", "access", "tta", "l", "na", "data", "oa", "work", "d", "ac", "area", "f", "ack", "as", "va"], "swapped": ["rewapping", "Swapped", "waps", "swaps", "waped", "Swoped", "wapping", "rewaped", "rewapped", " swaps", "rewoped", "flapping", " swap", "rewaps", "wapped", "flapped", "rewap", "floped", " swapping", "swapping", "Swapping", "wap", "flap", "swap", "Swap", "Swaped", "swoped", "swaped", " swaped"], "i": ["qi", "v", "k", "iv", "ip", "ai", "sup", "ti", "mini", "I", "e", "ami", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "start", "ind", "u", "ui", "li", "hi", "multi", "ci", "next", "anti", "uni", "si", "mi", "ii", "y", "m", "j", "adi", "ie", "info", "ori", "b", "ki", "bi", "ri", "uri", "api", "p", "key", "gi", "h", "ix", "it", "fi", "in", "oi", "l", "di", "init", "ni", "d", "f", "pi", "module"], "tmp": ["foo", "emp", "v", "stuff", " ff", "test", "xxx", "st", "amp", "sup", "bb", "opp", "yy", "pre", "nb", "tt", "vt", "x", "tc", "obj", "angle", "kk", "m", "t", "j", "ie", "prev", "b", "front", "tv", "dest", "pad", "qq", "alpha", "p", "mmm", "addr", "append", "pp", "area", "part", "txt", "f", "mp", "cmp", "temp"]}}
{"id1": "18631594", "id2": "5723876", "code1": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"getMD5_Base64": ["getMD5_SHA64", "getMD5_base58", "getMD5_Meta8", "getMD5_base8", "getMD5Bybase58", "getMD5Bybase62", "getMD5_base62", "getMD5_Base58", "getMD5_Base62", "getMD5_Meta64", "getMD5ByBase8", "getMD5_Meta58", "getMD5_SHA58", "getMD5ByBase64", "getMD5ByBase62", "getMD5_SHA62", "getMD5_Meta62", "getMD5_SHA8", "getMD5ByBase58", "getMD5_base64", "getMD5Bybase64", "getMD5_Base8", "getMD5Bybase8"], "input": ["address", "url", "base", "reader", "IN", "str", "output", "raw", "Input", "request", "xml", "pattern", "string", "out", "s", "image", "prefix", "this", "format", "type", "ssl", "i", "null", "text", "empty", "list", "buffer", "array", "alpha", "inf", "addin", "plus", "form", "document", "in", "data", "source", "file", "accept", "inside", "password", "value", "temp"], "msgDigest": ["msgSignend", "msgPullester", "msgdigest", "msgDigEST", "msgdigend", "msgMixested", "msgMixester", "MsgDigester", "docdigested", "cmddigest", "MsgDigener", "msgSignEST", "cmdDigex", "msgDer", "msgDend", "MsgDested", "msgdigester", "msgDEST", "msgMixest", "MsgDigested", "cmdDiger", "msgDigester", "docdigest", "MsgDester", "docdigEST", "cmddigester", "cmdDigester", "cmddigex", "msgDigener", "msgCommested", "msgdigested", "docdigender", "msgDiger", "msgDex", " msgDigester", "msgPuller", "msgMDender", "MsgDigest", "docDigested", "msgSignester", "msgDigested", "docDigEST", "msgMDEST", "msgSignest", " msgDigEST", "msgPullex", "msgCommester", "msgMDested", "msgCommest", "msgdigender", "msgCommener", " msgSignester", "msgDest", "MsgDest", "msgDener", " msgSignend", "docDigender", "msgDester", " msgSignEST", "msgdigex", "msgMDest", "msgdiger", " msgDigend", "docDigest", "msgDigend", "cmddiger", "cmdDigest", "msgMixener", " msgSignest", "msgDigender", "msgPullest", "msgDigex", "msgdigEST", "MsgDener", "msgDested"], "rawData": ["packageData", "packageString", "RAWCode", "rawBytes", "RawBytes", "RAWData", "rawCode", "RawText", " rawText", "rawString", " rawByte", "RAWBytes", " rawBytes", "packageText", "rawText", "RawData", " rawCode", "RAWByte", "rawByte", " rawString", "RawCode", "RawByte", "RawString"], "encoded": ["decoding", "encrypted", "encoder", "enoding", "Encoded", "engrypted", "decoder", "engoding", "Encrypted", "ecoding", "Enccoded", "enrypted", "engcoded", "decoded", "Encoder", "enoded", "ecrypted", "decrypted", "enccoded", "ecoded", "engoded", "Encoding", "eccoded", "encoding", "enoder"], "retValue": ["returnVal", "newData", "retString", "RetValue", "resultValue", "resultVal", "returnValues", " retText", "retData", " retString", "newValue", "RetData", " retVal", "retValues", " retValues", "RetText", "resultString", " retData", "newText", "RetString", "resultValues", "returnString", "newString", "retVal", "retText", "returnValue"]}}
{"id1": "12306305", "id2": "7908169", "code1": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"doCopyFile": ["doTransferfile", "doCopyfile", "doCopyFiles", "DoCopfile", "doCopfile", "docopyDirectory", "docopyfile", "DoCopFile", "DoCopDirectory", "docopyFile", "DoCopyDirectory", "doCopFile", "doTransferDirectory", "docopyFiles", "doCopFiles", "DoCopyfile", "doTransferFile", "DoCopyFile", "doCopyDirectory", "DoCopFiles", "DoCopyFiles", "doTransferFiles", "doCopDirectory"], "srcFile": ["destFiles", "instFile", "sourceFiles", " srcfile", "srcPage", "destDir", "srcDir", " srcPage", "destPage", "instPage", "sourcePage", "srcfile", "srcFilename", " srcFiles", "accessPath", "instDir", "destPath", "rcDir", "destfile", "srcPath", "sourcefile", " srcDirectory", "sourceFile", "accessPage", "rcfile", "destFilename", " srcPath", "instfile", "accessFile", "rcFile", "sourceDirectory", " srcFilename", "accessFilename", " srcDir", "rcDirectory", "srcDirectory", "rcPage", "srcFiles", "sourceDir"], "destFile": ["optfile", "destFiles", "optSourceFile", "targetFiles", " DestTime", "flatFile", "flatFilename", " destPage", "DestFiles", "descTitle", " destfile", "destDir", "destFolder", "DestDirectory", "optPath", "descFolder", "Destfile", "srcDir", "descFile", "srcSourceFile", "destSourceFile", "destPage", "targetFile", "sourcePage", "destTitle", "srcfile", " destFolder", "restTime", " DestFile", "DestFile", "destPath", "destTime", "targetfile", " destTitle", "flatFolder", "destfile", " destFiles", " destFilename", " DestDir", " Destfile", "sourceDir", "optFile", "targetPath", " destTime", " destSourceFile", "sourceFile", "descFilename", "targetSourceFile", "DestTime", "destFilename", "flatTitle", "targetDirectory", "DestDir", "sourceDirectory", "homeDir", " destPath", " destDir", "homeFile", "restSourceFile", "restDirectory", "srcDirectory", " destDirectory", "homeFiles", "DestPage", "destDirectory", "srcFiles", "homefile", "srcTime", "restFile"], "preserveFileDate": ["preservedTimeDay", "preserveFilesDay", "preserveFilesTime", "preserveLineDate", "preserveUnitdate", "preserveUnitDate", "preserveDirectoryDay", "preserveFilesSince", "preserveFilesDate", "preservingFileDate", "preserveDirectorydate", "preserveFileSince", "preservedTimedate", "preservingFileSince", "preservingFilesdate", "preservedFileDay", "preservedTimeTime", "preserveDirectoryTime", "preserveLinedate", "preservingFiledate", "preserveTimedate", "preserveFiledate", "preservedFileDate", "preserveTimeDay", "preservingFilesDate", "preserveTimeTime", "preserveFileTime", "preserveFileDay", "preservedFileTime", "preserveFilesdate", "preservingFilesSince", "preservedTimeDate", "preservedFiledate", "preserveTimeDate", "preserveDirectoryDate", "preserveUnitSince", "preserveLineSince"], "input": ["exec", "address", "url", "ip", "error", "reader", "audio", "client", "view", "feed", "io", "current", "child", "Input", "internal", "request", "out", "context", "conn", "stream", "inner", "binary", "image", "upload", "this", "self", "event", "i", "connection", "active", "null", "parent", "config", "socket", "buffer", "api", "form", "copy", "in", "source", "channel", "file", "data", "up", "instance", "open", "temp"], "output": ["external", "flow", "oper", "address", "console", "audio", "ou", "io", "current", "child", "put", "feed", "environment", "Output", "target", "out", "four", "core", "ilo", "queue", "image", "write", "next", "operation", "writer", "connection", "application", "null", "again", "parent", "video", "object", "o", "config", "socket", "outer", "office", "version", "copy", "other", "source", "channel", "file", "download", "unit", "control", "response"]}}
{"id1": "1798720", "id2": "21656668", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"save": ["change", "apply", "transfer", "load", "make", "archive", "setup", "upload", "build", "release", "report", "transform", "Save", "install", "update", "pack", "copy", "store", "data", "process", "move", "stage", "saving", "create", "dump", "open", "clone"], "packageName": ["modulePath", " packagePart", "moduleName", "sourcename", "pluginName", "moduleInfo", "directoryPath", " packagePath", "packagePart", " packagename", "sourceName", "packageInfo", "packagename", "directoryname", "sourcePath", "directoryName", " packageNames", "PackagePath", "PackageName", "directoryInfo", "packageNames", "directoryDir", "directoryPart", "pluginDir", "pluginPart", "PackageDir", "directoryNames", "pluginPath", "packagePath", " packageInfo", "moduleDir", "PackageNames", "sourceDir", "PackageInfo"], "fileContents": ["getContents", "getNames", "FileContent", "imageNames", " fileHours", "imageParts", " fileContent", "ileContents", "fileSources", " fileTextures", "FileContents", "ileNames", "fileContent", "ileTextures", " fileSources", "imageContents", "FileSources", "fileParts", "fileHours", "imageHours", "fileTextures", "FileTextures", "ileSources", "FileNames", "FileHours", "getParts", "getContent", "FileParts", " fileParts"], "fileNames": ["fileTypes", "FileTypes", "fNumbers", "pagenames", "viewTypes", "pageNames", "filenames", "playName", "FileName", "fullContents", "FileContents", "fTypes", "pageTypes", "playContents", "logNames", " fileName", "fName", "logName", "fullNames", "fNames", " filenames", "logTypes", "fullTypes", "fullName", "logContents", "viewnames", "FileNames", "viewNames", "playNames", " fileTypes", "fileNumbers", "fileName", "FileNumbers", " fileNumbers"], "dirBase": ["directoryBased", "packageRoot", "folderBase", "directoryBase", "DirDir", "modulebase", " dirbase", "Dirbase", "dirRoot", "DirKit", " dirRoot", "dirBased", "directoryKit", "moduleBased", "packageBase", " dirPath", "directorybase", "dirbase", "dirDir", "dirPath", "packagebase", "DirBase", "directoryDir", "folderBased", "DirRoot", "moduleKit", "folderbase", "DirPath", "packagePath", "moduleDir", "folderDir", "dirKit", "moduleBase"], "packageDir": ["modulePath", "folderBase", "directoryFolder", " packagePath", "directoryPath", "directoryUrl", "PackageDirectory", "folderPath", "packageDirectory", "packageFolder", "parentFile", "directoryFile", "parentDir", "packageBase", "PackageFile", "PackagePath", "directoryDirectory", " packageBase", "directoryDir", "packageUrl", " packageUrl", "PackageDir", " packageFile", "packagePath", "packageLib", " packageFolder", "folderLib", "moduleDir", "moduleLib", "parentUrl", " packageDirectory", "folderDir", "parentFolder", "packageFile", " packageLib", "moduleBase"], "created": ["result", "controlled", "edited", "required", "established", "needed", "formed", "updated", "left", "found", "activated", "path", "creator", "paid", "Created", "true", "released", "creation", " Created", "made", "aaaa", "generated", "failed", "added", "confirmed", "used", "null", "icated", "produced", "existent", "loaded", "raised", "founded", "owned", " existed", "create", "were", "successful", "worked", "authorized", "called", "ed"], "currentPath": ["newPath", "CurrentDirectory", "newpath", "currentLocation", "CurrentPath", "currentPage", "newLocation", "CurrentRoot", " currentLocation", "CurrentPage", " currentRoot", "currentlypath", "Currentpath", "currentlyDirectory", " currentPage", "currentDirectory", "currentRoot", "currentlyPath", " currentpath", "currentlyPage", "newRoot", "CurrentLocation", " currentDirectory", "currentpath"], "i": ["qi", "v", "z", "k", "ip", "ai", "ti", "I", "e", "id", "io", "current", "iu", "xi", "x", "ini", "index", "eni", "start", "name", "ui", "li", "u", "hi", "inner", "s", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "j", "ie", "info", "ori", "b", "n", "bi", "zi", "slice", "isi", "ri", "uri", "p", "gi", "ix", "it", "h", "fi", "key", "di", "oi", "me", "init", "d", "yi", "ji", "part", "mu", "f", "pi"], "file": ["fp", "base", "place", "feed", "io", "child", "path", "folder", "log", "filename", "out", "name", "s", "play", "ile", "files", "fe", "or", "File", "pe", "b", "rule", "per", "il", "ul", "uri", "resource", "http", "l", "source", "work", "up", "dir", "entry", "letter", "data", "full", "unit", "book", "f", "le"], "fos": ["foes", "ufos", " fosh", "Fou", "vops", "flou", "flis", " fis", "voes", "fou", "flops", " fob", "Fops", "Fosh", "Fos", "ofosh", "Fis", "ofos", " fo", "flosh", "cfob", " fops", "ufob", "fios", "Foes", "Fios", "fosh", "vios", "ufoes", "ufo", "fis", "cfo", " fios", "vos", "ofou", "fo", "cfoes", "cfos", "fops", "flos", " foes", "ofops", "fob"], "fileSrc": ["fileDrs", "fileDrec", "fileSsrc", "fileSrec", "fileAsrec", "FileSrc", "fileAsource", "fileNRC", " fileSrs", "fileDrc", "fileSrs", "fileAsRC", " fileDRC", "fileAssrc", " fileSsrc", "FileSource", "FileDRC", "fileSource", "FileDrec", " fileDsrc", " fileDrs", "fileAsrc", "fileSRC", "fileAsrs", "FileSRC", "fileNrs", "fileDource", " fileSRC", "fileNsrc", "fileDRC", "fileNrc", "FileDrc", "FileSrec", "FileDource", " fileDrc", "fileDsrc"], "fileDst": ["fileDsc", "FileSsc", "FileFst", "fileSsrc", "fileEnsc", "FileSrc", "fileSst", "fileFST", "fileDrc", "fileEnST", "fileNsc", "FileDST", "FileDsc", "fileSST", "fileFst", "FileFST", "fileDaysc", "fileDayrc", "FileDst", "fileFrc", "FileFsc", "fileDST", "fileNst", "FileFrc", "fileNsrc", "fileNrc", "FileDrc", "FileSst", "fileEnrc", "FileDsrc", "FileSsrc", "fileSsc", "fileFsc", "fileDayst", "fileDaysrc", "fileEnst", "fileDsrc"], "reader": ["audio", "builder", "re", "e", "right", "io", "rr", "worker", "rer", "ler", "row", "er", "stream", "driver", "inner", "editor", "read", "Reader", "keeper", "or", "layer", "r", "report", "rx", "handler", "oder", "per", "loader", "ner", "ri", "parser", "iter", "buffer", "rc", "data", "entry", "ro", "ry", "server", "rar", "director", "reading", "book", "author"], "writer": ["ger", "wa", "written", "wire", "master", "maker", "writ", "builder", "w", "output", "e", "war", "worker", "ws", "ler", "er", "out", "inner", "driver", "word", "write", "rw", "widget", "wr", "editor", "words", "element", "Writer", "riter", "r", "connection", "player", "o", "with", "handler", "per", "walker", "socket", "loader", "outer", "parser", "buffer", "message", "office", "wrapper", "key", "document", "writers", "data", "entry", "server", "width", "sheet", "work", "value", "later", "book", "author", "writing"], "line": ["url", "lc", "header", "error", "column", "job", "str", "id", "feed", "model", "log", "le", "ge", "row", "string", "name", "end", "Line", "response", "lines", "word", "cr", "write", "link", "character", "code", "LINE", "look", "type", "connection", "definition", "text", "object", "rule", "block", "sync", "cle", "message", "buffer", "key", "jo", "lf", "page", "data", "lin", "entry", "source", "l", "letter", "char", "style", "inline", "pass", "part", "unit", "comment", "item", "cell", "stroke"]}}
{"id1": "8770016", "id2": "88047", "code1": "    public InputStream loadResource(String location) throws GenericConfigException {\n        URL url = getURL(location);\n        try {\n            return url.openStream();\n        } catch (java.io.IOException e) {\n            throw new GenericConfigException(\"Error opening URL resource at location [\" + url.toExternalForm() + \"]\", e);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"loadResource": ["createURL", "readURL", "loadFile", "loadUrl", "newURL", "newUrl", "newResource", "createFile", "createResource", "readFile", "loadURL", "readUrl", "readResource", "newFile", "createUrl"], "location": ["address", "position", "base", "level", "description", "local", "region", "URL", "path", "remote", "uration", "target", "filename", "length", "language", "name", "pointer", "string", "link", "operation", "layer", "type", "reference", "route", "directory", "config", "loc", "layout", "loader", "uri", "timeout", "resource", "property", "content", "point", "href", "l", "source", "file", "ocation", "Location", "area", "collection", "localhost", "response"], "url": ["external", "address", "base", "job", "rel", "ob", "e", "site", "URL", "jar", "path", "xml", "log", "sl", "remote", "Url", "string", "name", "image", "link", "this", "build", "org", "layer", "event", "ssl", "element", "connection", "i", "route", "null", "object", "config", "loc", "loader", "buffer", "uri", "resource", "http", "plug", "l", "page", "source", "file", "server", "ref", "web", "rl", "f"]}}
{"id1": "16931472", "id2": "13981689", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"handler": [" handling", " response", "handle", " serve", " handle", " success", " init", " next", "callback", " load", " rewrite", " setup", "Handler", " callback", " complete", " redirect", " on", " notify", " processing", "process", " fire", " done", " f", " transfer", " fn", " dispatch", " finish"], "result": ["complete", "map", "feature", "cache", "status", "re", "output", "view", "dict", "Result", "row", "session", "res", "order", "results", "event", "report", "list", "table", "message", "array", "buffer", "resource", "document", "page", "data", "source", "match", "json", "group", "record", "manager", "response"], "target": ["external", "template", "base", "master", "client", "token", "arget", "project", "output", "site", "current", "proxy", "request", "goal", " Target", "environment", "owner", "session", "location", "host", "tail", "image", "next", "link", "this", "database", "Target", "type", "reference", "connection", "event", "html", "class", "route", "object", "parent", "favorite", "task", "config", "layout", "the", "resource", "version", "it", "content", "http", "page", "source", "data", "server", "style", "download", "about", "theme", "that", "unit", "manager", "response"], "url": ["address", "base", "str", "view", "feed", "io", "URL", "path", "sl", "Url", "string", "stream", "build", "org", "ssl", "connection", "user", "browser", "socket", "loader", "buffer", "uri", "service", "resource", "http", "page", "l", "file", "server", "source", "channel", "blog"], "reader": ["builder", "e", "feed", "io", "rr", "worker", "rer", "ler", "row", "er", "input", "stream", "driver", "err", "editor", "read", "Reader", "bird", "layer", "writer", "i", "report", "rx", "over", "loader", "ner", "ri", "buffer", "iter", "parser", "iterator", "http", "rc", "in", "ry", "file", "server", "reading", "f"], "line": ["cl", "error", "e", "id", "log", "nl", "row", "name", "li", "link", "strip", "message", "data", "file", "limit", "header", "status", "lo", "lined", "string", "lock", "LINE", "or", "pe", "user", "definition", "rule", "o", "block", "buffer", "key", "l", "page", "liner", "comment", "rl", "cell", "lc", "base", "str", "parse", "el", "zip", "sl", "range", "lines", "err", "no", "code", "info", "body", "non", "lf", "lin", "source", "inline", "email", "home", "ine", "side", "view", "site", "plugin", "end", "profile", "Line", "look", "live", "text", "sync", "iter", "point", "style", "frame", "response", "le"], "entry": ["builder", "enter", "e", "feed", "term", "owner", "row", "ge", "string", "inner", "archive", "section", "link", "entity", "editor", "layer", "extra", "or", "element", "writer", "ie", "counter", "ent", "connection", "Entry", "per", "ner", "her", "uri", "service", "resource", "key", "rc", "page", "ry", "data", "se", "source", "match", "member", "value", "part", "exit", "ener", "cell"], "fromIndex": ["sourceSection", "startIndex", "fromPoint", "FromLength", "fromLength", "FromOffset", "FromIndex", "toIndex", "fromSection", "startLength", " fromLength", "fromPosition", " fromPosition", " fromSection", "FromPoint", "startPosition", " fromOffset", "toPoint", "FromSection", "toPosition", "fromOffset", " fromPoint", "FromPosition", "startOffset", "sourcePoint", "toOffset", "sourceIndex", "sourcePosition"], "r": ["v", "vr", "w", "re", "sr", "mr", "e", "ar", "rr", "nr", "er", "res", "q", "u", "cr", "range", "c", "m", "rg", "b", "attr", "ner", "ri", "fr", "ru", "lr", "array", "p", "rb", "rc", "l", "R", "d", "f", "rl", "rs", "pr"]}}
{"id1": "3046085", "id2": "8490297", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 0, "substitutes": {"s": ["speech", "v", "services", "params", "w", "sample", "str", "e", "south", "sets", "sound", "path", "es", "ns", "string", "name", "ses", "strings", "m", "t", "a", "i", "r", "sb", "g", "b", "n", "text", "S", "parts", "joined", "p", "content", "is", "in", "data", "source", "ss", "f", "gs"], "tokenizer": ["okenator", "widgetiser", "generiser", "tuner", "finizable", "logizable", " tokeniter", "tunner", "statizers", "initialiser", "normalizable", "finer", "loginer", "okeniter", "tooliner", "toolize", "okenzer", "optimizer", "okenization", "tokenization", "Tokenizer", "statiter", "tokenister", "tokenize", "tunizer", "Tokenized", "okenizer", "Tokenener", "tokenizers", " tokenzer", "okeniser", " tokenized", "optimiser", "Tokenizers", "widgetizer", "Tokenister", "okenizable", " tokenener", "tokeniter", "generizer", "okenener", "finize", "tokenener", "okenister", "logize", "normalize", "generized", "tokenator", "Tokenizable", "Tokeniser", " tokenizers", "initialiner", "tokenzer", "normalizer", "statizer", "Tokeniner", "widgetizable", "okeniner", "widgetiner", "Tokener", " tokener", " tokenner", "finizer", "tokenner", "toolizable", "tokeniner", "normaliner", " tokenizable", "optimizable", " tokeniser", "initializable", "okenner", "okenize", "initialize", "logizer", "Tokenize", "initialization", "okenizers", "tokener", "initializer", "tunzer", " tokenization", " tokenator", "okener", "tokenized", "statator", "toolizer", " tokenister", " tokenize", "tokenizable", "tokeniser", "optiminer", "generize"], "title": ["url", "audio", "description", "metadata", "art", "owner", "music", "meta", "filename", "name", "string", "profile", "prefix", "Title", "bot", "company", "editor", "layer", "format", "username", "type", "genre", "text", "tag", "song", "license", "media", "resource", "album", "source", "data", "summary", "theme", "team", "label", "author"], "artist": ["master", "audio", "voice", "alias", "metadata", "art", "episode", "cover", "music", "creator", "target", "patch", "filename", "archive", "winner", "image", "prefix", "chart", "layer", "username", "player", "genre", "video", "tag", "song", "Artist", "media", "album", "track", "source", "piece", " artists", "season", "theme", "photo", "author"], "location": ["address", "position", "url", "level", "audio", "description", "region", "path", "length", "language", "time", "image", "layer", "motion", "tag", "mobile", "loc", "layout", "lang", "message", "media", "album", "content", "Location", "gallery", "area", "photo", "theme"], "rating": ["score", "playing", "audio", "description", "resolution", "fps", "repeat", "ranking", "scoring", "training", "sharing", "rate", "boarding", "live", "genre", "weight", "padding", "game", "breaking", "alpha", "media", "album", "rank", "style", "rising", "random", "season", "tracking"], "overplay": ["offload", "overlay", "offledge", "oplay", "offplay", "reload", "opplay", "overload", "offlay", "replay", "reledge", "opledge", "opload", "relay", "overledge"], "temp": ["template", "test", "emp", " temporary", "base", "cache", " tmp", "str", "tmp", "current", "partial", "path", "font", "music", "tc", "pt", "flat", "string", "name", "sequence", "original", "prefix", "testing", "format", "type", "tag", "body", "empty", "stable", "loc", "list", "layout", "message", "media", "content", "track", "txt", "data", "source", "style", "stage", "Temp", "part", "unit", "fake"], "tags": ["relations", "types", "packages", "assets", "archives", "ids", "authors", "reports", "videos", "users", "stats", "styles", "sections", "resources", "files", "terms", "comments", "strings", "modules", "words", "properties", "stars", "Tags", "images", "plugins", "bots", "events", "dates", "bugs", "fields", "phones", "thumbnails", "tracks", "products", "names", "notes", "tests", "features"], "bytes": ["objects", "params", "outs", "Bytes", "seconds", "letters", "videos", "es", "values", "lines", "tes", "files", "notes", "bps", "comments", "strings", "words", "errors", "body", "bits", "pieces", "parts", "blocks", "articles", "les", "gets", "ips", "fee", "pages", "data", "units", "keys", "balls", "size", "codes"], "hasher": ["hanher", " hashers", "Hashed", "hanest", "hashest", "hadhandler", "hashers", "hahers", "haher", "havehandler", " haser", "haer", "hadher", "Haser", "haser", "Hasher", "hashr", "haveer", "Hasest", "hanhr", " hashed", "hahed", "hashed", "haner", "hasumper", "haest", "hashhandler", "hadest", " hashr", "haveumper", "hashandler", " hasest", "haveher", "hadumper", "hasest", "havehr", "hashher", "hashumper", "Hashers", "haveest"]}}
{"id1": "6341264", "id2": "15905041", "code1": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "code2": "    public void createPartControl(Composite parent) {\n        viewer = new ScrollingGraphicalViewer();\n        viewer.setRootEditPart(new ScalableRootEditPart());\n        viewer.setEditPartFactory(new BlockEditPartFactory());\n        viewer.setEditDomain(new EditDomain());\n        viewer.createControl(parent);\n        viewer.setKeyHandler(new GraphicalViewerKeyHandler(viewer));\n        ActionRegistry actionRegistry = new ActionRegistry();\n        createActions(actionRegistry);\n        ContextMenuProvider cmProvider = new BlockContextMenuProvider(viewer, actionRegistry);\n        viewer.setContextMenu(cmProvider);\n        Block b = new Block();\n        b.addChild(new ChartItem());\n        viewer.setContents(b);\n        System.err.println(\"!!! \" + viewer.getContents().getChildren().get(0));\n        viewer.select((EditPart) viewer.getContents().getChildren().get(0));\n        PaletteRoot root = new PaletteRoot();\n        PaletteGroup toolGroup = new PaletteGroup(\"Chart Tools\");\n        List toolList = new ArrayList();\n        ToolEntry tool = new SelectionToolEntry();\n        toolList.add(tool);\n        root.setDefaultEntry(tool);\n        tool = new MarqueeToolEntry();\n        toolList.add(tool);\n        toolGroup.addAll(toolList);\n        PaletteGroup templateGroup = new PaletteGroup(\"Templates\");\n        List templateList = new ArrayList();\n        CombinedTemplateCreationEntry entry = new CombinedTemplateCreationEntry(\"Rect\", \"Rect\", new ChartItem(), new SimpleFactory(ChartItem.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        CombinedTemplateCreationEntry entry1 = new CombinedTemplateCreationEntry(\"Line\", \"Line\", new ChartLine(), new SimpleFactory(ChartLine.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        templateList.add(entry);\n        templateList.add(entry1);\n        templateGroup.addAll(templateList);\n        List rootList = new ArrayList();\n        rootList.add(toolGroup);\n        rootList.add(templateGroup);\n        root.addAll(rootList);\n        final PaletteViewer v = new PaletteViewer();\n        v.setPaletteRoot(root);\n        v.createControl(parent);\n        v.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(\"selectionChanged \" + v.getActiveTool());\n            }\n        });\n        deleteAction.setSelectionProvider(viewer);\n        viewer.getEditDomain().setPaletteViewer(v);\n        viewer.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(event.getSelection());\n                deleteAction.update();\n            }\n        });\n        viewer.getEditDomain().getCommandStack().addCommandStackEventListener(new CommandStackEventListener() {\n\n            public void stackChanged(CommandStackEvent event) {\n                undoAction.setEnabled(viewer.getEditDomain().getCommandStack().canUndo());\n                redoAction.setEnabled(viewer.getEditDomain().getCommandStack().canRedo());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"getJarEntry": ["getZipEntry", "getZipInfo", "getFolderInfo", "getZipentry", "getFolderSource", "GetJarFile", "getFolderEntry", "loadZipentry", "getjarEnt", "GetJarSource", "getZipEnt", "loadZipFile", "getJarEnt", "GetZipEntry", "GetZipInfo", "loadJarEntry", "getEntryEntry", "loadJarEnt", "GetJarInfo", "loadZipEntry", "getEntryFile", "GetZipFile", "getJarFile", "loadJarentry", "getEntryEnt", "GetZipSource", "getFolderFile", "getjarEntry", "getjarentry", "getJarInfo", "getEntryentry", "getJarentry", "getZipFile", "getZipSource", "getJarSource", "getjarFile", "GetJarEntry", "loadZipEnt", "loadJarFile"], "jarName": ["jarId", "browserId", "browserUrl", "jarPath", " jarID", "jarID", "javaAlias", "javaId", "browserName", " jarPath", "javaUrl", "browserAlias", "javaName", "jarAlias", " jarUrl", "javaPath", " jarId", "jarUrl", "JarPath", " jarAlias", "JarID", "JarName", "javaID", "JarAlias"], "entry": ["address", "description", "enter", "str", "id", "zip", "feed", "jar", "ticket", "path", "plugin", "host", "filename", "start", "string", "name", "offset", "archive", "image", "type", "ie", "connection", "element", "route", "Entry", "query", "uri", "service", "resource", "key", "data", "file", "server", "source", "ry", "secret", "ident"], "port": ["address", "position", "ip", "PORT", "project", "Port", "path", "ort", "host", "patch", "length", "name", "string", "offset", "time", "target", "type", "count", "pid", "direction", "uri", "timeout", "service", "version", "delay", "key", "point", "ports", "file", "server", "password", "pos", "limit"], "b": ["v", "base", "xb", "ib", "bb", "ob", "e", "beta", "br", "nb", "bd", "emb", "bp", "db", "boot", "fb", "mb", "binary", "s", "c", "orb", "buff", "a", "i", "r", "erb", "sb", "bar", "library", "lb", "buf", "abb", "wb", "buffer", "ab", "eb", "p", "bytes", "reb", "l", "pb", "zb", "B", "d", "bf", "obb", "bs", "cb", "f"], "codebase": ["coreBase", " codeb", "workb", "CodeBase", " codeBase", "workBase", "broadBase", "queb", "Codebase", "quebas", "workbase", "codebas", "queBase", " codebas", "broadb", "corebar", "quebase", "workfull", "codeb", " codefull", "codefull", "codeBase", "Codebas", "Codebar", "Codeb", "broadfull", " codebar", "corebase", "corebas", "codebar", "broadbase"], "protocol": ["protology", "predology", "proocol", "propport", "prourl", "Protost", "ocolurl", "proport", "Protore", "ocolocol", "proology", "verbost", "ocolore", "Protology", "propocol", "Proturl", "ocolology", "protost", "predocol", "predore", "verburl", "verbocol", "protport", " proturl", "propology", "protore", " protology", "Protocol", "Protport", "proturl", "predurl", " protost", "propurl", "verbology"], "x": ["xes", "v", "z", "xf", "xxx", "w", "lex", "xs", "id", "exp", "xp", "X", "xi", "check", "tx", "ctx", "cross", "index", "val", "es", "max", "wx", "ww", "xx", "xa", "dx", "ax", "y", "m", "en", "xxxxxxxx", "xt", "fx", "pe", "rx", "ex", "xxxx", "p", "ix", "h", "work", "xd", "pos", "d", "xc", "f"], "s2": ["satter", "qs2", "patter", "ssecond", " s62", "qs1", "stwo", "o2", "vatter", "stringtwo", "xls", "p1", "vtwo", "string1", "xii", "p2", "s1", "stringatter", "e1", "string2", "o62", " s1", "v1", "osecond", "sii", "e62", "sls", "qsls", "esecond", "e2", "v2", " ssecond", "ptwo", " sls", "qsii", "x1", "o1", "s62", " sii"], "x2": ["X1", "tx2", " x52", " x0", " x1", "x6", "index1", "XSecond", "tx52", "index2", " xSecond", "index0", "ix6", "index6", "xSecond", "txSecond", "X52", "tx1", "ix0", "ix2", "x52", "x0", " x6", "X2", "ix1", "x1"], "downloadHost": ["writePort", " downloadhost", "writeHost", "DownloadAddress", " downloadPath", "downloadDomain", "transferPath", "urlPort", " downloadAddress", "downloadhost", "transferPort", "DownloadHost", "updateRoot", " downloadPort", "urlHost", "updateAddress", "downloadAddress", "updateHost", "urlDomain", "writehost", "downloadPath", "transferhost", "transferRoot", "transferHost", "writeDomain", "Downloadhost", " downloadRoot", "transferAddress", "downloadRoot", "downloadPort", " downloadDomain", "DownloadPath", "updatehost", "urlhost"], "url": ["base", "util", "rel", "bb", "ob", "el", "zip", "ball", "URL", "jar", "log", "sl", "fl", "Url", "ls", "li", "contact", "gl", "obj", "image", "orb", "link", "lock", "build", "org", "j", "ssl", "connection", "user", "ll", "www", "loc", "ur", "ul", "uri", "service", "resource", "http", "l", "source", "file", "server", "control", "coll", "web", "rl", "f", "il"], "jurl": ["jetURL", "Jjob", "jeturl", "JURL", "Jurl", "gurl", "jpURL", "jjurl", "nurl", " jjob", "jjfile", " jcoll", "ajURL", "ajurl", "Jfile", "Juri", " jfile", "ajfile", "jhttp", " jhttp", "nURL", "jUrl", "nconnection", "jeturi", "jconnection", "jjURL", "jpjob", "jphttp", "juri", "jjob", "Jcoll", "Jconnection", "jetfile", "gUrl", "gconnection", "Jhttp", "jpurl", " jURL", "jfile", "nUrl", "gURL", "jjcoll", "ajuri", "jcoll", "JUrl", "jURL"], "je": ["su", "oe", "jp", "esi", "ja", "Obj", " ze", "pse", "e", "zip", "jar", "py", "kee", "ju", "Je", "li", "obj", "ee", "si", "j", "ie", "java", "js", "fr", "opy", "la", "jen", "jo", "elt", "oi", "jl", "se", "ni", "ne", "ji", "ze", "jj"], "is": ["address", "ais", "ai", "ib", "ois", "bb", "ob", "iso", "isa", "are", "isin", "zip", "jar", "IS", "vs", "Is", "es", "oss", "ir", "ui", "s", "ris", "li", "state", "obj", "isl", "si", "ios", "iss", "os", "ses", "nis", "ii", "self", "ie", "i", "ori", "info", "js", "so", "sin", "lis", "il", "isi", "ri", "uri", "api", "iris", "its", "http", "in", "cos", "src", "as", "bs", "mis"], "bis": ["serv", "base", "oris", "ois", "bb", "ob", "bin", "zip", "isin", "proxy", "IS", "Is", "boot", "fb", "oss", "abs", "ls", "binary", "ris", "obj", "inner", "s", "lock", "iss", "ios", "ses", "bps", "nis", "os", "bos", "afi", "i", "ori", "sb", "bus", "connection", "ignore", "sin", "lis", "slice", "bits", "ri", "uri", "uds", "iris", "abi", "di", "cos", "obs", "http", "usb", "download", "bes", "ubis", "obb", "bs", "cb", "bi", "mis", "pi"], "size": ["cm", "address", "cl", "send", "grade", "now", "use", "sec", "term", "cel", "Size", "iz", "name", "cr", "core", "length", "range", "time", "len", "hh", "ci", "si", "large", "err", "rate", "small", "en", "mode", "esc", "shape", "body", "SIZE", "sized", "enc", "co", "loc", "sync", "eng", "speed", "sn", "ize", "close", "scale", "form", "content", "rc", "act", "se", "init", "width", "capacity", "area", "unit", "sum"], "rb": ["RB", "vr", "ra", "xb", "rh", "sr", "bb", "gb", "ob", "nb", "io", "rr", "rf", "nr", "fb", "cr", "range", "orb", "ruby", "rt", "sb", "r", "lb", "rg", "rab", "buf", "rub", "rx", "abb", "loc", "wb", "ri", "ru", "rob", "lr", "eb", "reb", "rc", "pb", "adr", "zb", "src", "bf", " rc", "rar", "area", "obb", "erb", "rl", "cb", "rd"], "chunk": ["chack", "punk", "chunks", " chack", "choy", "chink", "cloy", "bunk", "qurow", "CHunc", "cheunk", " Chunks", " Chack", "bone", "quunk", "schunk", "punky", "CHunk", "quunky", "shink", "clink", "chunky", "CHunks", "clunk", "clone", "cheink", "Chunk", "Chunks", "quask", "clunc", "chrow", "schunky", "cheunc", "chask", "boy", "chone", " chunks", "CHink", "schrow", "Chack", "chunc", "shoy", "shone", "cheunks", "pask", "shunk", "schask", "clunks", " Chunk", "bink", "prow"]}}
{"id1": "8132219", "id2": "9727056", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    @Override\n    public OBJModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        OBJModel model = loadModel(url.openStream(), skin);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "inFile": ["InFilename", "Infile", "binfile", "inputFile", "InFile", "INfile", "InSourceFile", "INSourceFile", "infile", "binPlace", "inputFiles", "inPlace", " infile", "binFiles", " inFilename", "inputPlace", "outfile", "outPlace", "inFilename", " inSourceFile", "binFile", "inFiles", "outFiles", "inSourceFile", "INFile", "inputfile", "INFilename"], "outFile": ["againFilename", " outFilename", "againPlace", "outputFilename", " outfile", "infile", " outPlace", "outputPlace", "outputFiles", "outputfile", " outFiles", "outfile", "againfile", "outPlace", "inFilename", "inFiles", "outFiles", "outFilename", "againFile", "outputFile"], "in": ["url", "base", "ins", "reader", "din", "IN", "bin", "id", "io", "inc", "x", "ini", "index", "input", "ic", "In", "name", "inner", "image", "c", "like", "m", "a", "i", "connection", "n", "again", "config", "inn", "pin", "is", "data", "source", "file", "work", "rin", "part", "as", "f"], "out": ["exec", "external", "v", "OUT", "client", "outs", "cache", "w", "call", "output", "bin", "io", "x", "log", "default", "conn", "name", "ext", "string", "dot", "obj", "to", "image", "write", "c", "prefix", "Out", "plain", "writer", "user", "b", "null", "n", "ex", "o", "buffer", "version", "resource", "p", "copy", "line", "data", "file", "part", "Output"], "inChannel": ["inputChan", " inchannel", "sinFlow", "inChan", " inSocket", "iniStream", " inConnection", "sinChan", "outChan", "winStream", "inchannel", "outchannel", "INFlow", "inichannel", "outStream", "inSocket", "inputStream", "inputchannel", "winLanguage", "outConnection", "winchannel", "INChan", "INSocket", "INchannel", "winChannel", "INChannel", "inStream", "sinChannel", "iniLanguage", "outLanguage", " inChan", "iniChannel", "INStream", "sinSocket", " inFlow", "inConnection", "INConnection", "inFlow", "inputChannel", "inLanguage"], "outChannel": ["againChannel", "Outchannel", "outputChan", "outContext", " outConnection", "inChan", "OutStream", " outChan", "outputchannel", "againchannel", "newContext", "outChan", " outContext", "OutConnection", "inchannel", "outchannel", "outputChannel", "outStream", "outConnection", "againChan", " outStream", "newChannel", "againPath", "OutContext", "inConnection", "newStream", " outchannel", "outPath", "OutChan", "newChan", "OutChannel", "inPath", " outPath"]}}
{"id1": "14047629", "id2": "22401746", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "label": 0, "substitutes": {"source": ["ource", "exec", "fp", "result", "processor", "reader", "status", "project", "parse", "transfer", "load", "proxy", "proc", "path", "request", "remote", "input", "session", "target", "out", "cp", "stream", "inner", "image", "Source", "comp", "info", "connection", "class", "text", "object", "parent", "config", "ources", "loader", "buffer", "service", "resource", "content", "document", "in", "file", "server", "src", "SOURCE"], "process": ["exec", "result", "processor", "master", "share", "cess", "console", "system", "job", "project", "call", "status", "output", "use", "port", "app", "command", "progress", "proc", "worker", "path", "index", "target", "python", "machine", "session", "node", "thread", "image", "method", "pid", "class", "object", "parent", "program", "task", "pipe", "press", "the", "post", "parser", "display", "resource", "p", "copy", "document", "file", "processing", "work", "loop", "Process", "script", "open", "run"], "processStdOut": ["processStdinOut", "processSTdinOUT", "processSTdOut", "processStdOutput", "processSTdinOut", "processStdOUT", "processStdinOUT", "processStDOUT", "processStDObj", "processStdinObj", "processSttObj", "processStDOut", "processStdObj", "processStDOutput", "processSttOutput", "processSTdinObj", "processSTdOUT", "processSttOut", "processSttOUT", "processSTdObj", "processSTdinOutput", "processSTdOutput", "processStdinOutput"], "processStdIn": ["processStdinOut", "processStrdIn", "processSttin", "processStsin", "processSttInput", "processStrdIns", "processStsIn", "processStbin", "processStbIns", "processSttIN", "processStdIN", "processStrdInput", "processStrtIn", "processStbIn", "processStdInput", "processStdin", "processSttIn", "processStsInput", "processStrdin", "processStsIns", "processStbIN", "processStrtIns", "processSttOut", "processStdinIn", "processStbOut", "processStrtInput", "processStbInput", "processStdinIN", "processStdIns", "processSttIns", "processStrtin", "processStdinin"]}}
{"id1": "693636", "id2": "12417893", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"createEmptyCart": ["createNewShipping", " createEmptySpot", " createEmptycart", "createEmptycart", "createNewCart", "createNewSpot", " createNewSpot", "createNewcart", "createCreatecart", "createCreateSpot", "createCreateCart", "createTempSpot", " createNewShipping", "createTempCart", "createTempcart", " createNewCart", "createEmptyShipping", " createNewcart", " createEmptyShipping", "createEmptySpot", "createCreateShipping", "createTempShipping"], "SHOPPING_ID": ["SHOPPIPIDIDS", "SHOPPIP_ID", "SHOPPIPIDid", "SHOPPINGPOIDs", "SHOPPINGIDIDs", "SHOPPING_IDS", "SHOPPING_IDs", "SHOPPIP_id", "SHOPPINGIDid", "SHOPPTING_id", "SHOPPINGPOId", "SHOPPINGPOID", "SHOPPIP_IDS", "SHOPPYING_ID", "SHOPPINGINGId", "SHOPPYING_IDS", "SHOPPINGIDId", "SHOPPIP_Id", "SHOPPINGINGid", "SHOPPYING_Id", "SHOPPTING_Id", "SHOPPIPIDId", "SHOPPIPIDIDs", "SHOPPTING_ID", "SHOPPINGPOIDS", "SHOPPING_id", "SHOPPIP_IDs", "SHOPPING_Id", "SHOPPYING_IDs", "SHOPPIPIDID", "SHOPPINGIDIDS", "SHOPPINGINGID", "SHOPPINGIDID"], "con": ["exec", "bc", "cm", "cf", "mc", "client", "ca", "uc", "ann", "can", "cache", "com", "un", "ran", "reg", "inc", "cur", "db", "wan", "log", "row", "connect", "session", "conn", "conv", "cr", "c", "ci", "cc", "fa", "en", "ec", "connection", "ex", "pen", "co", "fc", "loc", "Con", "win", "cond", "close", "cas", "CON", "rc", "commit", "col", "pool", "act", "cn", "coll", "pc", "ac", "Conn", "cons", "ctrl", "conf", "ctx", "fac"], "insert_cart": ["insert_pod", "insert_container", "install_container", "insert_center", "exec_Cart", "insertencycle", " insert_center", "insert_ox", "insertencart", "insert_payment", " insert_pod", "insertencat", "exec_payment", "insertencenter", " insert_cat", "exec_cart", "insert_conn", " insert_ox", "insert_part", " insert_conn", "install_part", "install_cart", " insert_cycle", "insert_cycle", "insert_cat", "insert_Cart"]}}
{"id1": "9275622", "id2": "12066447", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferfile", "copyFolder", "movefile", " copyFolder", "moveFolder", "transferFolder", "transferFiles", "moveFiles", " copyfile", "moveFile", "transferFile", "copyfile", " copyFiles"], "_file1": ["_fileone", "_files01", "_files2", "_zipOne", "_zipFirst", "_File0", "_mail1", "_mail01", "_fileFirst", "_resourceOne", "_resourceone", "_fFirst", "_files0", "_fOne", "_fone", "_files1", "_File2", "_zipone", "_f1", "_mail2", "_File1", "_file01", "_mail0", "_resource1", "_File01", "_file0", "_resourceFirst", "_fileOne", "_zip1"], "_file2": [" _files4", "_play4", "_Filesecond", " _fileTwo", "_files2", "_playsecond", "_files4", "_file3", "_files3", "jmodel2", "_modelsecond", "_file5", "_play3", " _file4", "_play5", " _file3", " _filesTwo", "jfile5", "_File5", "jfile1", "jmodelsecond", " _files3", "_play1", " _files2", "_model2", "_File2", "_play2", "_fileTwo", "_File1", "_filesTwo", "_file4", "jfilesecond", "_model1", "_filesecond", "jmodel1", "jmodel5", "_playTwo", "_model5", "jfile2"], "fis": [" fiss", "fais", "cfis", "fris", "cfas", " fais", "lfais", "infis", "lfi", " fi", "Fris", "infiss", " fas", "Fos", "infils", "fils", "Fis", "fas", " fils", "afis", "cfiss", "afi", "lfis", "Fiss", "Fils", "lfiss", "Fas", "fiss", "afiss", "fi", "cfos", "cfris", "afais", "infos", " fris"], "fos": ["foes", "Fo", "feus", "infus", "gus", "fus", "gos", "infios", "Fros", "flis", "poes", "fOS", "feis", "Foos", "feos", " foos", "Fus", "Foses", " faos", "feoses", "Fos", "Fis", "fros", " fo", "infoos", "fios", "pis", "lOS", "info", "Fios", "infaos", "flOS", "floes", "lis", " fus", " fios", "infos", "goses", "los", "loes", "fo", "pOS", "infros", "gis", "flos", "foses", "pos", " fros", "faos", "Faos", "foos"], "canalFuente": ["canalFUente", "canaledFuze", "canalFuento", "canallBuence", "canallFuencia", "canalsBuencia", "canalFuze", "canaledBuze", "canaledBuente", "canallFuze", "canalSuestro", "canalFuence", "canalBuence", "canalFUze", "canalKuente", "canalKuento", "canalsBuence", "canalFUencia", "canalFuestro", "canallBuencia", "canalsBuento", "canalKuence", "canaledFuje", "canalFUestro", "canalCraencia", "canalBuze", "canaledFuestro", "canallFuence", "canalSuze", "canalsFuence", "canalFUje", "canaledFuente", "canalsFuencia", "canalBuje", "canalCraente", "canalBuento", "canalSuje", "canalsFuente", "canalBuente", "canalsFuento", "canaledBuje", "canalFuencia", "canalCraence", "canalKuencia", "canalCraento", "canallBuze", "canalKuze", "canallBuente", "canalBuestro", "canaledBuestro", "canalBuencia", "canallFuente", "canalFUence", "canalFuje", "canalSuente", "canalsBuente"]}}
{"id1": "810342", "id2": "16623181", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersionUpdate", " doVersionUpdate", " doversionCheck", "doversionScan", "doversionCheck", "doChangeCheck", "doChangecheck", " doversioncheck", "doChangeUpdate", "doversioncheck", "doVersioncheck", "doFeaturecheck", " doVersionScan", " doversionUpdate", "doversionUpdate", "doFeatureScan", "doVersionScan", "doFeatureCheck", " doversionScan", "doChangeScan", "doFeatureUpdate", " doVersioncheck"], "view": ["v", "cache", "vol", "window", "e", "port", "model", "div", "row", "session", "link", "sel", "box", "show", "query", "display", "form", "server", "fail", "value", "full", "group", "gu", "client", "use", "VIEW", "check", "input", "View", "lock", "event", "user", "object", "video", "block", "views", "vis", "by", "http", "page", "review", "pool", "comment", "can", "cell", "im", "base", "change", "el", "ou", "container", "screen", "body", "head", "config", "list", "index", "out", "ui", "image", "this", "widget", "self", "html", "see", "edit", "layout", "update", "ve", "up", "style", "manager"], "url": ["address", "base", "builder", "rel", "bb", "ob", "id", "zip", "URL", "path", "log", "sl", "Url", "host", "location", "string", "name", "ls", "gl", "stream", "bug", "length", "image", "hub", "link", "ssl", "b", "browser", "null", "ll", "www", "loc", "socket", "loader", "fr", "buffer", "uri", "ul", "resource", "http", "l", "source", "file", "server", "download", "email", "impl", "open", "web", "blog", "f"], "in": ["ins", "reader", "din", "IN", "login", "isin", "inc", "bis", "ini", "input", "out", "In", "binary", "s", "inner", "stream", "err", "doc", "m", "b", "again", "sin", "socket", "nin", "win", "buffer", "resource", "inn", "pin", "is", "cin", "lin", "data", "file", "source", "init", "rin", "con", "ac", "as"], "bin": ["bn", "gin", "reader", "din", "IN", "login", "bb", "nb", "vin", "spin", "ini", "input", "border", "out", "binary", "fin", "inner", "lock", "bot", "ruby", "lib", "oin", "ban", "b", "browser", "body", "sin", "socket", "loader", "win", "buffer", "inn", "pin", "abi", "arin", "cin", "lin", "is", "file", "init", "con", "record", "bi", "run"], "line": ["lc", "cl", "base", "ip", "job", "str", "parse", "el", "e", "id", "zip", "one", "log", "le", "val", "ge", "row", "nl", "sl", "string", "name", "end", "Line", "out", "lines", "range", "word", "write", "link", "code", "LINE", "look", "type", "pe", "definition", "b", "user", "text", "object", "block", "pin", "key", "jo", "lf", "lin", "data", "file", "page", "l", "entry", "inline", "up", "letter", "unit", "ine", "part", "comment", "cell"], "version": ["feature", "position", "v", "ver", "project", "beta", "id", "cover", "model", "plugin", "python", "patch", "host", "string", "name", "bug", "driver", "section", "image", "code", "format", "vision", "type", "release", "user", "Version", "null", "video", "latest", "pull", "install", "update", "support", "license", "date", "option", "vert", "versions", "server", "download", "VERSION", "secret", "device", "value", "dev", "unit", "author"], "build": ["uild", "ver", "job", "builder", "rel", "follow", "clean", "use", "feed", "load", "valid", "log", "boot", "make", "row", "patch", "hold", "Build", "bug", "lock", "image", "link", "lease", "info", "print", "release", "show", "tag", "built", "pull", "block", "install", "building", "update", "post", "mount", "how", "add", "get", "http", "work", "style", "help", "home", "unit", "run"]}}
{"id1": "23310397", "id2": "15768167", "code1": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        mButton1 = (Button) findViewById(R.id.myButton1);\n        mButton2 = (Button) findViewById(R.id.myButton2);\n        mTextView1 = (TextView) findViewById(R.id.myTextView1);\n        mButton1.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpPost httpRequest = new HttpPost(uriAPI);\n                List<NameValuePair> params = new ArrayList<NameValuePair>();\n                params.add(new BasicNameValuePair(\"str\", \"post string\"));\n                try {\n                    httpRequest.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n        mButton2.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpGet httpRequest = new HttpGet(uriAPI);\n                try {\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        strResult = eregi_replace(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"\", strResult);\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"onCreate": ["ONCreate", " onCreated", "OnCreated", "jobCreated", "onCreating", "onClick", "onCre", "OnCreate", " onCre", "OnCreating", "ONClick", "jobCre", "jobClick", "jobCreate", " onCreating", "onCreated", "OnCre", "OnClick", "ONCreated", "ONCreating", " onClick"], "savedInstanceState": ["savedInstStates", "savedInstConfig", "savedInstInfo", "savingInstData", "savedanceState", "savedInstanceData", "savingInstConfig", "savedinstanceStates", "savedCaseInfo", "savedInstanceInfo", "savingInstStates", "savingInstanceStates", "savedCaseStates", "savingInstState", "savingInstanceState", "savedinstanceData", "savedInstData", "savedanceStates", "savingInstanceConfig", "savingInstanceInfo", "savedInstanceConfig", "savingInstanceData", "savedCaseState", "savedanceInfo", "savingInstInfo", "savedCaseConfig", "savedanceData", "savedinstanceConfig", "savedinstanceState", "savedinstanceInfo", "savedInstState", "savedInstanceStates"], "mButton1": ["mBorder2", "mChannel01", "mButtonFirst", "mActionOne", "MChannel2", "mChannel2", "mActionId", "mButtonId", "MActionOne", "mChannelId", "MAction2", "MButtonId", "mBorder01", "MChannelFirst", "mText01", "mAction2", "mOptionId", "mBorder1", "mAction1", "MButtonOne", "mButton01", "mTextFirst", "MButton01", "MButton2", "mChannel1", "MActionId", "MButton1", "mChannelFirst", "MButtonFirst", "mText1", "mOption2", "mChannelOne", "mBorderFirst", "MChannel01", "MAction1", "mButtonOne", "MChannel1", "mOptionOne", "mText2", "mOption1"], "mButton2": ["mActionTwo", " mEditorTwo", "mLabel1", "mAction02", "mButton02", " mEditor2", "mEditorTwo", " mText2", " mEditor1", "mTextTwo", "mLabelTwo", "mOptionTwo", "mAction2", "mAction1", "mLabel2", "mButtonTwo", "mOption02", " mButtonTwo", "mText1", "mOption2", " mText1", "mEditor2", " mTextTwo", "mEditor1", "mText02", "mText2", "mOption1", " mText02", " mButton02"], "mTextView1": ["mTextForm1", "mTextView11", "mContextView1", "mTextVIEW11", "mTEXTview2", "mTextStream0", "mTextView8", "mTEXTViewOne", "mTextStream11", "mTextForm2", "mTextForm11", "mTextStream1", "mTEXTview4", "mContextview1", "mContextview11", "mTextview0", "mTextContainer11", "mTEXTView1", "mTEXTview8", "mContextViewp", "mTextDisplayOne", "mTextviewOne", "mTextview4", "mTextContainer1", "mTEXTview5", "mTEXTview11", "mContextView5", "mTEXTView4", "mTextField2", "mTEXTView11", "mTextViewp", "mTextForm8", "mContextview5", "mTextview8", "mTextView4", "mTextVIEW0", "mTEXTviewOne", "mTextview1", "mTextviewp", "mTextview11", "mContextView0", "mTextDisplay2", "mTextContainer2", "mTextField1", "mTextVIEW5", "mTEXTView2", "mTextVIEW1", "mTextDisplay1", "mTextViewOne", "mTextVIEWp", "mTEXTView5", "mTextStreamp", "mTextView5", "mTextVIEW2", "mTextContainer8", "mContextview2", "mContextview0", "mTextField5", "mTEXTview1", "mTextView0", "mContextviewp", "mTextVIEW4", "mTextview2", "mTextDisplay4", "mTextVIEWOne", "mTEXTView8", "mTextDisplay5", "mTextStream2", "mContextView2", "mTextView2", "mTextview5", "mContextView11"], "v": ["env", "sv", "w", "view", "e", "port", "model", "Value", "vs", "x", "function", "val", "conv", "c", "m", "en", "j", "t", "i", "g", "b", "Version", "n", "video", "version", "p", "ve", "Ev", "V", "h", "l", "page", "server", "vv", "value", "f"], "uriAPI": ["durationPython", "uriapi", "riSSL", "uriAP", "urlCA", "durationAP", "riAPI", "urlPA", "URIPA", "uiPython", "idPA", "URICA", "riAP", "uriPA", "uriSSL", "cliapi", "riapi", "URISSL", "URIAP", "uriPython", "uriCA", "directorySSL", "cliPython", "uiAPI", "URIapi", "riPython", "directoryAPI", "URIPython", "urlAPI", "cliAPI", "uiapi", "directoryapi", "URIAPI", "idCA", "durationAPI", "idAPI"], "httpRequest": ["httpAsk", "httprequest", "ttpClient", "externalResponse", " httpReturn", "httpsRequest", "uriCause", "externalrequest", "htmlCause", "urirequest", "HttpResponse", "Httprequest", "externalAsk", "httpCause", "ttpReturn", "buildrequest", " httpCause", "ttprequest", "saferequest", "safeRequest", " httprequest", "htmlResponse", "ttpRequest", "httpReturn", "htmlRequest", "HttpRequest", "externalRequest", "httpClient", "htmlrequest", "httpsrequest", "httpsClient", "buildMessage", "httpsReturn", " httpClient", " httpMessage", "safeAsk", "HttpMessage", "uriRequest", "buildRequest", "httpMessage", "safeResponse", "uriResponse", " httpAsk", "buildResponse"], "params": ["url", "result", "posts", "services", "relations", "ip", "eps", "Parameters", "vs", "request", "string", "values", "param", "resources", "results", "changes", "properties", "type", "items", "i", "arms", "options", "par", "body", "ps", "query", "config", "list", "pins", "apps", "array", "uri", "api", "parts", "http", "ams", "data", "pos", "keys", "json", "details", "names", "rules", "response", "ras", "settings"], "httpResponse": ["HttpResult", "serverResponse", "serverRequest", "ttpClient", "httpresponse", "externalResponse", "HttpServer", "htmlResult", "HttpResponse", " httpResp", "httpResult", "serverResp", "HTTPRequest", "httpServer", "externalClient", "htmlResp", "externalResult", "htmlResponse", "HttpClient", "ttpRequest", " httpresponse", "htmlServer", "HttpRequest", " httpResult", "HTTPResp", "ttpResult", "externalRequest", "httpClient", "ttpResp", "HTTPReply", "httpResp", "ttpResponse", "HttpResp", "Httpresponse", "HTTPResponse", " httpReply", "htmlReply", "htmlresponse", "httpReply", "ttpReply", "ttpServer", "serverResult", "HttpReply"], "strResult": ["Strresult", "StrResponse", "stringResponse", "strresult", "stringresult", "stringResult", "StrResult", " strResults", "stringResults", " strResponse", "StrResults", " strresult", "strResponse", "strResults"]}}
{"id1": "12236729", "id2": "18974466", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"copy": [" copying", "transfer", "php", "zip", "io", "Copy", " copied", "replace", "py", "cp", "upload", "clone", "cop", "sync", "diff", "clip", "p", "get", " transfer", "download", " dup", "dump", "split", "cat", " Copy", "paste", "cmp"], "inputFile": ["outputDir", "sourceFiles", "currentDir", "inputDir", " inputFiles", " inputPath", "sourcePath", "inputPath", "sourcefile", " inputfile", "sourceFile", "inputFiles", "outputFiles", "outputfile", " inputDir", "currentFiles", "currentFile", "currentfile", "inputfile", "outputPath"], "outputFile": [" outputFilename", "OutputFile", " outputDir", "outputDir", "referencefile", "inputDir", " outputDirectory", " outputfile", "outputFilename", "OutputDirectory", "tempDir", "referenceDir", "OutputDir", "tempFile", "tempDirectory", "outputfile", "referenceFile", "inputFilename", "tempfile", "outputDirectory", "Outputfile", "referenceFilename", "inputfile"], "in": ["gin", "ins", "reader", "din", "IN", "login", "bin", "e", "id", "inc", "ini", "input", "In", "s", "conn", "inner", "ln", "image", "err", "lock", "read", "a", "i", "r", "connection", "n", "again", "sin", "pull", "socket", "nin", "win", "inn", "min", "pin", "get", "is", "into", "l", "lin", "source", "up", "file", "init", "inside", "kin", "cin", "con", "as", "f"], "out": ["net", "exec", "v", "error", "OUT", "outs", "cache", "w", "output", "bin", "io", "inc", "one", "log", "outside", "conn", "obj", "write", "err", "off", "Out", "plain", "extra", "at", "writer", "i", "b", "ex", "n", "again", "parent", "o", "over", "null", "sync", "socket", "post", "outer", "plus", "line", "file", "up", "temp"], "c": ["cm", "v", "k", "cl", "lc", "cf", "cy", "uc", "e", "id", "C", "x", "pointer", "u", "cr", "ci", "cc", "character", "code", "m", "ct", "ec", "a", "i", "count", "r", "cu", "b", "n", "ce", "esc", "o", "fc", "cd", "p", "rc", "col", "line", "l", "char", "sc", "ch", "d", "pc", "xc", "f"]}}
{"id1": "6371607", "id2": "13233761", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"removeRealm": ["removerealme", "removeBroadms", "removeBroadM", "removeLocalms", "removeLocalM", "deleterealms", "deleterealm", "removeLocalm", "delRealme", "removeRealms", "removeRelm", "deleteRealm", "removeSchem", "removeRealM", "removeBroadm", "removeSchems", "removerealam", "removeRelam", "removeLocalam", "delRealM", "deleterealam", "deleteRealms", "delRealm", "removeRelM", "removeScheM", "delBroadM", "delBroadme", "removeRealme", "removeBroadme", "delBroadm", "deleteRealM", "removeRealam", "delBroadms", "removeScheme", "removerealm", "deleterealM", "deleteRealam", "removerealM", "removerealms", "removeRelms", "delRealms"], "realmIds": ["realMByIds", "realmIntos", "realmPaths", "realmPathes", "realMPaths", "realMByIdls", "realmIdls", "realmRefls", "realMIdList", "realmIntes", "realMPathes", "realmRefids", "realmByIds", "realmRefList", "realmPathids", "realmIDes", "realMPathos", "realMPathids", "realMByIdes", "realmIDList", "realMIdids", "realmPathos", "realMIdes", "realmByIdList", "realMIds", "realmRefes", "realmIdes", "realMByIdList", "realmIdids", "realmByIdls", "realmRefs", "realmIdos", "realmIntids", "realMIdls", "realmRefos", "realmInts", "realmIdList", "realMIdos", "realmByIdes", "realmIDs", "realmIDls"], "psImpl": ["dsimpl", " psimpl", "cssIter", "epsHelper", " psHelper", "epsExpl", "dsImpl", "psIter", "cssimpl", "csimpl", " psExpl", "qsHelper", "epsIter", "psExpl", "dsHelper", "cssImpl", "psimpl", "csHelper", " psIter", "qsImpl", "epsimpl", "cssExpl", "psHelper", "epsImpl", "csImpl", "qsimpl"], "iter": ["reader", "ter", "upper", "itter", "enter", "parse", "finder", "el", "e", "ator", "inc", "sort", "cher", "ler", "index", "er", "former", "ir", "end", "apper", "inner", "err", "next", "ite", "i", "ie", "cer", "loc", "list", "walker", "gener", "ner", "outer", "it", "iterator", "page", "in", "entry", "line", "izer", "init", "Iter", "loop", "coll", "limit", "inter"], "realmId": ["realmcId", "realrmInt", "workfNum", "realmrHash", "RealmsId", "realmeID", "workmId", "realdmId", " realmnConfig", "ironmRef", "realmsId", "RealmsID", "RealmID", "realmConfig", "ironmaRef", "realmOffset", "realmaRef", "realarmID", "ironmaId", "realmePath", " realmHash", "realmrConfig", " realmnHash", "realdmOffset", "realmcID", "realmInt", "RealmsName", "workfid", "workmID", "realdmConfig", "realmrNum", "RealmName", "realmsName", "realmaID", "realmrid", "realmID", "realmeName", "ironmInt", "realfNum", "ironmID", "realrmID", "realmeId", "realmnConfig", " realmnId", "realmcRef", "realmrID", "workfId", "realmid", " realmOffset", "ironmaInt", "realarmId", " realmConfig", "realfId", "realmsID", "realfid", "workmNum", "realamID", "RealmId", "RealmsPath", "workfID", "realmnId", "realarmName", "workmid", "RealmPath", "realfID", "realmaId", "ironmaID", " realmnOffset", "realmNum", "realmRef", "realmHash", "realmrOffset", "realmnOffset", "realmnHash", "realmName", "realamNum", "realdmHash", "realrmRef", "realmaInt", "realmsPath", "realamId", "realmcInt", "ironmId", "realamid", "realmPath", "realarmPath", "realmrId", "realrmId"]}}
{"id1": "21979462", "id2": "3809087", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"downloadURLtoString": [" downloadURLintoString", " downloadURLtoStr", " downloadUrltoString", " downloadURLasstring", " downloadUrltoStr", " downloadURLtoLong", " downloadURLintostring", " downloadURLasStr", " downloadURLintoStr", " downloadUrlasStr", " downloadUrlasString", " downloadURL2Str", " downloadURL2string", " downloadURLintoLong", " downloadURLtostring", " downloadURL2String", " downloadUrlasstring", " downloadURL2Long", " downloadUrltoLong", " downloadUrltostring", " downloadURLasLong", " downloadURLasString", " downloadUrlasLong"], "url": ["address", "base", "job", "el", "URL", "path", "sl", "remote", "Url", "name", "gl", "image", "link", "ssl", "connection", "user", "b", "rule", "config", "loc", "loader", "buffer", "uri", "service", "resource", "lr", "bel", "http", "l", "page", "source", "file", "server", "data", "ref", "f"], "in": ["gin", "ins", "din", "reader", "IN", "re", "login", "bin", "isin", "inc", "db", "ini", "fb", "input", "ic", "out", "In", "s", "cms", "inner", "ln", "ilo", "err", "read", "ssl", "at", "i", "r", "b", "rx", "n", "again", "nin", "fr", "buffer", "inn", "min", "it", "h", "af", "is", "into", "lin", "source", "data", "init", "ac", "impl", "as", "f"], "sb": ["bc", " eb", "sv", "xb", "ib", "bb", "gb", "amb", "bp", " SB", "bd", "nb", "db", "bm", "fb", "mb", "s", "ls", "bsp", "sth", "si", "sa", "buff", "sg", "BB", "SB", "lb", "b", "buf", "ub", "bt", "abb", "wb", "kb", "buffer", "lr", "eb", "rb", "lab", "usb", "pb", "bh", "zb", "B", "src", "bf", "Bs", "obb", "erb", "sf", "cb", "bs"], "str": ["result", "cl", "lc", "st", "sr", "br", "exp", "arr", "cur", "sl", "div", "string", "name", "s", "obj", "cr", "err", "doc", "spec", "bl", "wr", "Str", "read", "ct", "i", "r", "b", "text", "n", "tr", "STR", "enc", "list", "fr", "iter", "key", "dr", "line", "l", "data", "char", "stri", "coll", "pass", "sp", "txt", "f", "pr"]}}
{"id1": "16048516", "id2": "6371589", "code1": "    public static SVNConfiguracion load(URL urlConfiguracion) {\n        SVNConfiguracion configuracion = null;\n        try {\n            XMLDecoder xenc = new XMLDecoder(urlConfiguracion.openStream());\n            configuracion = (SVNConfiguracion) xenc.readObject();\n            configuracion.setFicheroConfiguracion(urlConfiguracion);\n            xenc.close();\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        }\n        return configuracion;\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"load": ["Load", "save", "parse", "check", "start", "set", "upload", "build", "read", "loads", "LOAD", "show", "transform", "install", "loader", "update", "oad", "loaded", "add", "get", "content", "process", "init", "download", "create", "dump", "open"], "urlConfiguracion": ["urlconfigurator", "urlConfureation", "urlConfigURacion", "urlConfigutator", "urlConfigurateator", "urlConfigutabet", "urlConfureator", "urlConfigurabet", "urlConfigURaton", "urlConfuraci", "urlConfuration", "urlConfigurado", "urlConfuracion", "urlConfigureator", "urlConfurator", "urlconfigaurator", "urlConfigurateation", "urlConfigutacion", "urlConfigureabet", "urlconfigauraton", "urlConfigaurator", "urlConfigureado", "urlConfigutado", "urlConfigURaci", "urlConfigureation", "urlConfigurerator", "urlConfigurateacion", "urlConfigauraci", "urlConfiguraton", "urlconfigauracion", "urlconfiguracion", "urlconfiguraci", "urlConfigureracion", "urlConfigureacion", "urlconfigauraci", "urlConfigurateaci", "urlConfigauracion", "urlConfiguration", "urlconfiguraton", "urlConfigauraton", "urlConfiguraci", "urlConfigurator", "urlConfigureaci", "urlConfigurerabet", "urlConfigureaton", "urlConfigURator", "urlConfigURation", "urlConfureacion", "urlConfigurerado", "urlConfureaci"], "configuracion": ["Configureaci", "configuration", "configutacion", "configauraci", "configoracion", "caluraci", "configoration", "Configuracion", "configauracion", "configurab", "configuralant", "configaurab", "Configureant", "configureaci", "Configuraci", "configuraateur", "configureator", "configutaton", "Configuration", "configurant", "configuralator", "configureation", "configureab", "configutaci", "Configurateur", "configauraton", "configureateur", "configuraacion", "configuralaci", "configuralation", "configaurateur", "Configureator", "Configureacion", "configoraci", "configaurator", "configuraator", "configuralaton", "caluraton", "Configureateur", "Configurab", "Configureation", "configauration", "calureacion", "configuraci", "Configureaton", "configureant", "configuraton", "configuralacion", "calureaci", "configurateur", "caluration", "calureation", "Configurator", "configurator", "Configureab", "configutant", "Configurant", "configureacion", "configuraab", "Configuraton", "configoraton", "calureaton", "caluracion", "configureaton"], "xenc": ["exec", "Xenv", "xEnc", "XEnc", "fxenz", "xenv", "fxenc", "ixstream", "xmlens", "Xenz", "xens", " xenv", "exstream", "xstream", "xec", " xstream", "xmlenv", "xmlenc", " xenz", "ixec", " xens", "Xenc", "exsen", "xmlEnc", "xenz", "fxens", "xsen", "fxEnc", "Xens", " xEnc", " xec", "ixsen", "exenc", " xsen", "ixenc"]}}
{"id1": "8064604", "id2": "7761195", "code1": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"init": ["exec", "reset", "client", "activate", "transfer", "load", "boot", "start", "setup", "set", "build", "launch", "construct", "info", "Init", "connection", "config", "install", "update", "it", "cli", "sleep", "create", "initial", "open"], "mgr": ["marr", "pigr", "pgr", " mrr", "mr", " mr", "carr", "Marr", "amgr", " mbr", "pbr", "mbr", " mtr", "mrr", "Mr", "amigr", "cr", "migr", "mtr", "ambr", "cgr", "prr", "Mtr", " migr", " marr", "amrr", "ctr", "Mgr"], "cfg": [" conf", "map", "cf", "mc", "chain", " configuration", "cache", " config", "gen", " cf", "db", "bm", "Hash", "MC", " ssh", " cache", "g", "gp", " chain", "Conf", "Msg", "config", " img", "file", "gate", "password", "mem", "conf", "cb"], "sock": ["sink", "gesock", "gesink", " socket", "Socket", "gesocket", "Sib", "Socks", "opensocket", "opensib", "gesocks", "Sock", "opensock", "socket", " socks", " sib", " sink", "sib", "opensocks", "Sink", "socks"], "_cman": ["_gfg", "_mcfg", "_cgr", "_gmn", "_mcman", "_mman", "_cfg", "_mfg", " _cfg", "_mcmn", "_mmn", " _mcgr", "_ggr", "_mgr", " _mcman", " _mcfg", "_gman", " _cmn", " _mcmn", " _cgr", "_mcgr", "_cmn"], "_sock": ["_nsock", "_serve", "_asocks", "_nsocks", "_bort", "_sort", "_unsdk", "_socket", "_dort", "_csockets", "_Svc", "_svc", "longsocks", "longsock", "_docket", "_opensort", "_Sock", "_sockets", " _svc", "_opensvc", "_asrc", "_bocks", "_jsock", "_csrc", "longnsock", "_nsockets", "_csocks", "_unsocket", "_opensock", "_Socks", "_sdk", "_opensocket", "longsrc", "_jsocket", "_unsock", "longnsocks", " _socks", "_jsdk", "_Socket", "longnsrc", "_jsocks", "_bocket", "_bock", "_openserve", "_docks", "longsockets", "_Serve", "_nsrc", "_asockets", " _serve", "longnsockets", "_src", "_opensocks", "_dock", "_unsocks", "_asock", "_socks", "_csock", "_Sdk"], "i": ["qi", "v", "k", "ip", "ai", "ti", "I", "my", "e", "id", "io", "iu", "xi", "x", "ini", "index", "q", "li", "u", "s", "ui", "hi", "inner", "multi", "ci", "si", "mi", "phi", "y", "ii", "m", "j", "ie", "info", "r", "b", "n", "o", "bi", "slice", "ri", "uri", "p", "gi", "h", "ix", "is", "it", "l", "in", "oi", "di", "ni", "d", "field", "chi", "value", "ji", "f", "pi"], "key": ["pair", "cy", "id", "row", "name", "length", "section", "link", "ie", "query", "mix", "mac", "fee", "data", "value", "pick", "token", "check", "KEY", "patch", "string", "lock", "prefix", "number", "rule", "ki", "ck", "match", "char", "label", "kid", "k", "base", "change", "str", "nice", "ace", "cert", "kh", "code", "pid", "search", "source", "shift", "secret", "field", "sum", "ask", "temp", "qi", "wire", "ip", "sign", "index", "q", "order", "type", "connection", "root", "text", "trust", "point", "Key", "phrase", "entry", "op", "fix", "json"], "_sout": ["_sbio", "_sio", "_SOut", "_sOut", "_seOut", "_sin", "_Sin", "_Sio", "_sein", "_sbin", "_sbOut", "_Sout", "_seout", "_seio", "_sbout"], "_sinp": ["_srer", "_disb", "_inpc", "_inb", "_dispc", "_diser", "_srp", "_srb", "_sinb", "_disp", "_iner", "_inp", "_srpc", "_sinpc", "_siner"], "seed": ["shadow", "slave", "test", "kid", "digit", "address", "sudo", "sha", "token", "sample", "id", "zip", "feed", "prime", "folder", "row", "input", "host", "pattern", "sql", "string", "name", "kh", "index", "driver", "ruby", "serial", "dd", "username", "black", "root", "shape", "slice", "eed", "pad", "parser", "scale", "delay", "cookie", "finger", "data", "source", "sleep", "shift", "password", "secret", "char", "random", "theme", "json", "pick", "sum", "grain"], "rand": ["chain", "gen", "rh", "ng", "der", "sample", "re", "id", "reg", "rr", "start", "ind", "cr", "max", "range", "next", "bot", "bird", "r", "go", "gram", "user", "grad", "win", "min", "nd", "dr", "rc", "round", "who", "dist", "NG", "rar", "random", "roll", "dev", "draw", "pick", " random", "Rand"], "hex": ["sha", "cube", "id", "raw", "cross", "row", "div", "pattern", "length", "box", "ph", "oct", "mix", "scale", "form", "cookie", "letter", "loop", "buff", "rex", "token", "pex", "check", "x", "string", "lock", "serial", "auth", "alph", "pad", "char", "num", "closure", "shadow", "lit", "cf", "rh", "zip", "ticket", "kh", "code", "hess", "loc", "wh", "alpha", "shift", "sex", "secret", "sum", "temp", "digit", "ip", "chain", "view", "bin", "exp", "index", "batch", "transform", "ex", "text", "pack", "iter", "ch", "tri", "quant", "json", "cmp"], "pass": ["test", "Password", "gen", "flash", "parse", "allow", "handle", "login", "feed", "sign", "ress", "proc", "worker", "skip", "path", "cross", "oss", "session", "lock", "prefix", "step", "code", "auth", "read", "ride", "report", "route", "task", "oct", "ass", "press", "strip", "post", "service", "access", "line", "PASS", "process", "push", "act", "password", "secret", "fix", "fail", "rss", "ss", "Pass", "mail", "run"], "md5": ["ma2", "mand2", "MD85", "md\n", "MD3", "MD512", "md85", " md\t", "ma5", "mand5", "md512", "sha7", "MD4", "sha5", "sha512", "sha2", " MD\t", "MD2", "MD7", "MD\n", " md85", "MD\t", " md512", "mandody", "md2", " mdody", "md\t", " md2", " md\n", "ma85", "MDody", "sha3", " md7", "ma4", "sha4", "mdody", " md4", "md7", "mand3", "md3", "md4", "MD5", " md3", " MD\n"], "hash": ["url", "base", "sha", "header", "ash", "cache", "rh", "id", "db", "alt", "host", "string", "kh", "lock", "ruby", "code", "build", "auth", "html", "text", "hed", "block", "her", "version", "h", "mac", "addr", "password", "secret", "sum", "ha", "dig"], "banner": ["plann", "Banorer", "planning", "banler", "bannel", "ironners", "ironning", "annners", "warnker", "binn", "warnnel", "planners", "banning", "bluenel", "blueker", "ironnet", "Bann", "binner", "planorer", "bluener", "planner", "bann", "banners", "warnler", "Banler", "ironner", "Banner", "warnner", "binorer", "plannet", "blueler", "banker", "annnet", "annning", "Banning", "bannet", "binning", "Bannel", "Banker", "banorer", "annner"], "txt": ["test", "gold", "xxx", "thin", "img", "str", "tmp", "zip", "vt", "git", "htm", "tx", "xml", "fb", "flat", "ext", "obj", "struct", "lines", "utt", "pdf", "bot", "kt", "notes", "rpm", "np", "xt", "info", "rx", "js", " text", "text", "buf", "ff", "TEXT", "config", "tin", "diff", "parser", "hea", "bytes", "wd", "elt", "Text", "tty", "data", "file", "pty", "email", "qt", "gz", "rss", "json", "details", "cb", "buff"], "sname": ["vesname", "esnamed", "nsnamed", "nsdata", "snamed", " sName", " sdata", "vesnames", "esname", "sName", "nsname", "sdata", "vesnamed", "esName", " snames", " snamed", "asnamed", "nsnames", "snames", "asnames", "esnames", "vesName", "asname", "asdata"], "spass": ["espass", "sposs", "aspasses", "aspash", "spasses", "slill", "splad", "splash", "splasses", "slass", "espasses", "aspad", "SPasses", "spash", "slasses", "espad", "SPass", "spill", "espash", "SPoss", "spad", "Spasses", "Spass", "aspass", "SPill", "splass", "sloss", "Sposs", "Spill"], "sseed": ["Sgrain", "sgrain", "skey", " stoken", "gseed", "gskey", "sslave", "dentry", "Seed", "Skey", "ssseed", "dtoken", "Sseed", "gsseed", "symkey", "spassword", "pseed", "symgrain", "ssecret", "psseed", "submitseed", "sentry", "proot", "submitpassword", "psslave", "sroot", " sentry", "gsgrain", "psecret", "dpassword", "pssecret", "ssslave", "submitentry", "submittoken", " spassword", "pslave", "dseed", "stoken", "ssroot", "sssecret", "symeed", "psroot", "symseed"], "items": ["photos", "posts", "objects", "params", "groups", "rooms", "ids", "flows", "members", "xml", "locks", "abs", "lists", "values", "styles", "cells", "lines", "results", "projects", "files", "loads", "models", "rows", "images", "js", "ops", "owners", "ends", "bits", "plugins", "pieces", "boxes", "pins", "events", "apps", "orders", "parts", "opens", "bytes", "articles", "links", "ips", "ants", "pages", "data", "phones", "units", "qs", "keys", "Items", "cats", "names", "item"]}}
{"id1": "21092340", "id2": "21125261", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addToAsive", "addToSlIVE", "addtoAsives", "addToArchively", "addToAsively", "addToAsives", "addtoArchive", "addToAdaptively", "addToSlive", "addToAsIVE", "addToAdaptives", "addtoAsIVE", "addToArchIVE", "addToArchives", "addToAdaptive", "addtoArchIVE", "addToAdaptIVE", "addtoArchively", "addToSlively", "addToSlives", "addtoAsive", "addtoArchives", "addtoAsively"], "pod": ["ods", "cache", "project", "bean", "tmp", "module", "zip", "child", "po", "proc", "pot", "plugin", "node", "host", "pkg", "pl", "component", "cer", "pid", "pe", "ce", "object", "od", "per", "pad", "loader", "post", "table", "ad", "p", "peer", "pc", "part", "product", "plug", "pi", "Pod"], "podArchiveOutputStream": ["podArchIVEInputFile", "podArchivesFileResource", "podArchiveByteSteam", "podArchivingOutputStream", "podArchiveInputSteam", "podArchivingOutputFile", "podArchIVEOutputStream", "podArchiveByteFile", "podArchiveInputStream", "podArchivingWriteStream", "podArchivesOutputFile", "podArchiveOutputSteam", "podArchiveWriteFile", "podArchiveOutputResource", "podArchiveFileResource", "podArchIVEInputSteam", "podArchiveIOResource", "podArchIVEOutputSteam", "podArchiveOutputDirectory", "podArchivesOutputSteam", "podArchiveByteDirectory", "podArchIVEOutputFile", "podArchivesFileStream", "podArchivesFileSteam", "podArchivesFileFile", "podArchivesOutputStream", "podArchivingOutputPath", "podArchiveFilePath", "podArchiveWriteStream", "podArchiveIOSteam", "podArchiveInputPath", "podArchiveFileFile", "podArchiveIODirectory", "podArchivingWriteSteam", "podArchiveIOFile", "podArchIVEOutputDirectory", "podArchiveOperationSteam", "podArchIVEInputDirectory", "podArchiveFileSteam", "podArchiveWritePath", "podArchiveInputDirectory", "podArchiveFileStream", "podArchiveOperationResource", "podArchivingWriteFile", "podArchiveWriteSteam", "podArchIVEInputStream", "podArchivingWritePath", "podArchiveOperationStream", "podArchiveInputFile", "podArchiveIOStream", "podArchivesOutputResource", "podArchiveByteStream", "podArchiveOperationFile", "podArchiveFileDirectory", "podArchiveOutputPath", "podArchiveOutputFile", "podArchivingOutputSteam"], "filename": ["fp", "url", "FILE", "alias", "title", "dll", "fil", "which", "kl", "platform", "ename", "path", "folder", "nil", "label", "location", "string", "sequence", "name", "binary", "archive", "word", "named", "prefix", "database", "files", "username", "SourceFile", "route", "ppa", "directory", "application", "loader", "uri", "property", "kn", "l", "fn", "file", "subject", "download", "sf", "Filename", "f", "il", "module"], "source": ["ource", "slave", "url", "result", "reader", "output", "use", "zip", "proxy", "path", "sl", "input", "target", "string", "seed", "stream", "archive", "driver", "image", "Source", "connection", "text", "parent", "config", "slice", "loader", "uri", "service", "resource", "copy", "document", "stack", "file", "src", "unit", "SOURCE"], "entry": ["address", "result", "reader", "e", "zip", "feed", "child", "path", "row", "ge", "index", "pointer", "auto", "string", "obj", "stream", "archive", "image", "this", "or", "event", "element", "ie", "connection", "r", "object", "parent", "Entry", "post", "resource", "add", "it", "iterator", "line", "file", "data", "se", "article", "letter", "record"]}}
{"id1": "16590954", "id2": "11005804", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"createJAR": ["createJPJar", "createAMARS", "createJJar", "createJAP", "createPHAP", " createJAP", "createPHAR", " createPHJar", "createAMJar", "createAMAR", " createPHAR", "createAMAP", "createJPARS", " createJARS", " createPHAP", "createJPAR", "createPHJar", " createJJar", "createPHARS", "createJPAP", "createJARS", " createPHARS"], "fileString": ["fileStr", "basestring", "lineName", "fileStream", "FileStr", " fileFile", "FileText", "baseString", " fileArray", "resourceString", "linestring", "fileText", "modelText", "modelStream", "loadstring", "FileName", "filestring", "loadName", "resourceStream", "fileArray", " fileStr", " fileName", "lineString", "loadText", "FileArray", "FileString", "resourceText", "baseFile", "Filestring", "lineArray", "FileFile", "modelString", "FileStream", "resourceStr", "baseStr", " filestring", " fileText", "loadString", "modelStr", "fileName", "fileFile"], "ext": ["external", "v", "url", "prot", "str", "dep", "app", "exp", "zip", "exe", "path", "x", "filename", "name", "end", "Ext", "ax", "code", "extra", "format", "type", "xt", "info", "class", "desc", "text", "ex", "enc", "config", "EXT", "version", "content", "data", "append", "dist", " Ext", "req", "txt"], "file": ["ger", "fp", "url", "test", "FILE", "base", "cache", "place", "change", "local", "output", "use", "force", "zip", "module", "model", "jar", "db", "path", "folder", "log", "flat", "filename", "name", "binary", "queue", "doc", "ile", "fe", "files", "build", "File", "pe", "class", "b", "bar", "parent", "per", "socket", "buffer", "resource", "wave", "it", "get", "h", "http", "single", "l", "page", "source", "work", "up", "line", "let", "full", "part", "unit", "f", "le"], "i": ["qi", "v", "ip", "ai", "mini", "I", "iu", "xi", "x", "ini", "index", "eni", "ind", "ui", "li", "hi", "uni", "ci", "multi", "c", "si", "mi", "phi", "ii", "j", "ori", "slice", "uri", "p", "key", "it", "abi", "di", "l", "ni", "limit", "yi", "f", "pi"], "dir": ["url", " directory", "base", "rel", "str", "output", "Dir", "id", "zip", "tmp", "jar", "cur", "db", "path", "folder", "div", "filename", "name", "string", "ir", "domain", "prefix", "doc", "pkg", "lib", "format", "type", "info", "class", "directory", "DIR", "config", "direction", "loc", "uri", "data", "dist", "src", "coll", "area", "manager", "module"], "jarFile": ["archiveDir", " jarLine", "archiveFile", " jarFiles", "archiveFolder", "tarFile", "jarF", "sessionSourceFile", " jarSourceFile", "javaFolder", "reportfile", "javaF", "javaSourceFile", "jarDir", "reportSourceFile", "jarSourceFile", "tarfile", "tarF", "tarLine", " jarfile", " jarFolder", " jarDir", "javafile", "javaFile", "reportFile", "javaDir", "sessionLine", "jarFolder", "jarfile", "archiveFiles", "jarFiles", "tarSourceFile", "javaFiles", "reportF", "sessionFile", "sessionfile", "jarLine"], "fstrm": ["fgrM", "fstum", " fsrum", " fsrm", "fsrM", "fsrum", "Fstrm", "Fstrmd", " fstrM", " fstrcm", "fstM", "fsrcm", "fstrmd", "fstrM", "Fsrm", "fstmd", " fstrum", "FstrM", "fbrcm", "fstcm", "fbrum", "Fsrcm", "fstrcm", " fsrcm", "fstrum", "Fstrcm", "fbrm", "fgrmd", " fsrM", "fstm", "Fsrmd", "fgrcm", "fsrmd", "fbrM", "FsrM", "fsrm", "fgrm"], "in": ["gin", "ins", "din", "reader", "IN", "login", "bin", "id", "io", "inc", "input", "In", "conn", "s", "stream", "inner", "binary", "to", "image", "c", "read", "m", "or", "r", "n", "again", "pull", "sync", "socket", "nin", "inn", "p", "min", "pin", "is", "into", "l", "up", "init", "inside", "rin", "ac", "part", "f"], "out": ["net", "flow", "v", "OUT", "client", "outs", "call", "output", "bin", "exp", "io", "inc", "outside", "conn", "inner", "to", "image", "c", "doc", "off", "err", "this", "Out", "plain", "self", "m", "all", "writer", "connection", "user", "b", "again", "null", "sync", "outer", "resource", "plus", "line", "source", "channel", "pool", "init", "up", "server", "group", "part"], "temp": ["template", "v", "test", " temporary", "emp", "base", "wrap", "cache", "clean", "w", " tmp", "local", "output", "tmp", "controller", " Temp", "zip", "db", "path", "folder", "input", "export", "archive", "doc", "c", "tem", "storage", "build", "porary", "or", "writer", "directory", "dest", "config", "pipe", "buffer", "iter", "api", "p", "it", "get", "form", "key", "store", "single", "source", "server", "Temp", "dump", "full", "home", "unit", "fake", "f", "Output"], "fstrm2": ["fstM1", "fstrmr002", "fstrmr1", "fhrm1", "fstrms2", "fstrmr2", "fhrms002", "fhrm02", "fstrM1", "fstm1", "fstrms02", "fstrp1", "fstrm0", "fhrms2", "fstrp0", "fstrM2", "fstrms1", "fstrM02", "fhrm002", "fstrm02", "fstrM0", "fstrms0", "fstrm1", "fstM0", "fstrms002", "fstm2", "fstm0", "fstM2", "fstrm002", "fstrp2", "fstrmr02", "fhrm2", "fhrms02", "fhrms1", "fstrM002"], "ostrm": ["ostrem", "obsrm", "otherrt", "oscrt", "obsrob", "obsrt", "oscmr", "oodrt", "odrm", "odm", "oodrem", "oscm", "istrt", "obrm", "ostrob", "ophrm", "othermr", "oodrob", "ooprm", "obmr", "oopmr", "istmr", "ophrt", "ooprom", "oscrm", "ostrt", "oodrm", "otherrm", "obrt", "istrm", "otherrom", "istrom", "ooprt", "odrt", "ostrom", "odmr", "ophm", "ostm", "ophmr", "obrom", "ostmr", "obsrem"], "docFile": ["docF", "DocF", "documentFile", " docFiles", "documentDir", "docDir", "documentF", "documentFiles", "docFiles", " docF", "DocFiles", "DocFile", "DocDir", " docDir"]}}
{"id1": "19849797", "id2": "189963", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": ["clonefile", "copyFiles", "transferfile", "copySource", "cloneFiles", "transferSource", " copySource", "transferFiles", " copyfile", "cloneSource", "transferFile", "copyfile", "cloneFile", " copyFiles"], "sourceFile": [" sourceDir", "ourceDirectory", "sourceUrl", "ourceUrl", "srcDir", "srcFile", " sourceFolder", "sourceFolder", "ourceFile", "SourceUrl", "srcfile", " sourcefile", "destfile", "SourceDirectory", "SourceFile", "ourcefile", "sourcefile", "sourceDirectory", "srcFolder", "destUrl", "Sourcefile", "SourceFolder", "destDirectory", "sourceDir", "SourceDir"], "destFile": ["destFiles", "targetFiles", "sourceFiles", "resultDir", "destLine", "DestFiles", " destfile", "destDir", "destPoint", "DestDirectory", "resultfile", "Destfile", "srcFile", "srcDir", "targetDir", "targetFile", "foreignFile", "srcfile", "foreignPath", "DestFile", "destPath", "targetfile", "DestPoint", "destfile", "targetLine", " destFiles", "targetPath", "foreignFiles", "resultFile", "DestDir", " destPoint", "foreignfile", " destDir", "srcDirectory", " destDirectory", "DestPath", "resultLine", "sourcePoint", "destDirectory", "srcFiles", "sourceDir", "srcLine"], "source": ["ource", "slave", "url", "result", "client", "reader", "cache", "status", "scope", "output", "site", "use", "id", "view", "current", "proxy", "scene", "index", "input", "target", "session", "start", "context", "core", "seed", "remote", "stream", "inner", "secure", "image", "Source", "this", "si", "storage", "component", "reference", "connection", "ie", "root", "route", "null", "object", "parent", "sin", "dest", "config", "slice", "table", "uri", "service", "resource", "api", "wrapper", "iter", "get", "from", "channel", "file", "server", "src", "unit", "size", "manager", "ce", "SOURCE"], "destination": ["participinate", "destinator", "generination", "Destinated", "dominated", "constinator", "identination", "distination", "construction", "distion", "participinator", "Destination", "domination", " destribution", "constribution", "domation", "Destribution", "Destruction", "destribution", " destinator", "destation", "Destation", "generruction", "destion", "identinator", "destinate", " destruction", "participinated", " destinated", " destation", "destinated", "participination", "distruction", "destruction", "dominator", "distinated", "distinator", "Destion", " destion", "Destinate", "constination", "generinator", "identinate", "generinated", "Destinator", "identinated"]}}
{"id1": "6987642", "id2": "9398454", "code1": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"encodePassword": ["enodedPass", " enodePassword", "enodedAuth", "enressPassword", "enodePass", " enodePass", "enodeAuth", "enodedPassword", "enressAuth", "enodeString", " encodeString", "encodePass", " encodeAuth", " enodeString", "enressString", "encodeString", "enressPass", "enodedString", " enodeAuth", "enodePassword", "encodeAuth", " encodePass"], "password": ["hash", "address", "sha", "token", "Password", "sword", "path", "input", "pattern", "string", "name", "out", "word", "prefix", "database", "code", "auth", "words", " Password", "username", "SHA", "crypt", "confirmed", "user", "number", "text", "padding", "message", "p", "wd", "content", " passwords", "phrase", "data", "PASS", "secret", "pass", "value", "Pass"], "md": ["mad", "MD", "hash", " Md", "mc", "sha", "ms", "ng", "metadata", "rm", "pm", "bd", "amd", "am", "mo", "mb", "mt", "ind", "cmd", "hd", "sm", "mand", "m", "dd", "Cmd", "gd", "od", "mg", "grad", "mm", "ma", "ad", "pd", "nd", "mac", "mp", "mod", "dr", "me", "hm", "data", "mn", "dh", "di", "d", "mag", "vd", "dm", " MD", "dig"], "encodedPassword": ["enccodedPassword", "encodingPassword", "encodedUser", "Enccodedpassword", "enryptedString", "encodingString", "enryptedText", "encachedString", "encachedSecret", "Encodedpassword", "encodedText", "enodedPassword", "EnccodedString", "encodedString", "encodepassword", "encryptedSecret", "encodeUser", "enccodedString", "encryptedString", "enryptedPassword", "EncodedUser", "encodingSecret", "encodedpassword", "EnccodedUser", "encachedText", "encryptedPassword", "EncodedPassword", "encodeString", "EncodedString", "encryptedUser", "enodedString", "enryptedSecret", "enodedText", "encryptedText", "enodedSecret", "encodedSecret", "enccodedpassword", "encodingText", "encachedPassword", "encryptedpassword", "EnccodedPassword", "enccodedUser"]}}
{"id1": "10451698", "id2": "3806532", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["drop", "share", "change", "delete", "paste", "rm", "transfer", "zip", "Copy", "load", "replace", "remote", "py", "cp", "archive", "lock", "write", " cp", "type", "cop", "ignore", "parent", "sync", "list", "update", "clip", "get", "process", "move", "file", "download", "create", "dump", "split", "cat", "ssh", "part", "clone", "run"], "source": ["ource", "slave", "url", "result", "reader", "client", "cache", "project", "scope", "view", "site", "use", "current", "proxy", "model", "path", "folder", "remote", "target", "filename", "start", "name", "seed", "string", "secure", "stream", "flat", "archive", "section", "image", "Source", "storage", "ie", "info", "connection", "class", "root", "null", "directory", "object", "parent", "config", "slice", "iter", "service", "resource", "plus", "from", "document", "data", "file", "server", "src", "unit", "sf", "ce", "SOURCE"], "destinationDirectory": ["destributionDirectory", "destructionFolder", "DestributionHome", "destributionPath", "DestinationFolder", "DestinationDir", "destributionHome", "destructionDir", " destinationFolder", " destinationFile", " destinationsFolder", "destarationPoint", " destinationDir", "DestinationHome", "DestributionFolder", "destificationDirectory", "destinationFile", "DestinationDirectory", "destippingDirectory", "destinatorPoint", "destinationsDirectory", "destinationPath", "destinationDir", "DestributionDirectory", " destinationsFile", "destinationHome", "destippingFolder", "destinatorPath", "destificationFolder", "destippingHome", "destinationsDir", "destinationsFolder", "DestributionPath", "destippingDir", "DestributionDir", " destinationsDir", "destinatorDirectory", "destarationDirectory", "destinationsFile", "destructionDirectory", "destributionFolder", "DestributionPoint", "destructionFile", "destinationFolder", "destarationPath", " destinationsDirectory", "destinationPoint", "destributionPoint", "destificationHome", "destributionDir", "destributionFile", "destificationDir", "DestinationPoint", "DestinationPath"], "newDir": ["NewFolder", " newDirectory", " newFolder", "NewDir", "NewDirectory", "newDirectory", " newdir", "nextdir", "NewFile", "Newdir", "nextFolder", "nextDirectory", "newFolder", "nextDir", "newdir", "nextFile"], "children": ["rules", "iv", "url", "ins", "uc", "packages", "iblings", "roots", "which", "when", "ren", "child", "current", "sub", "members", "sort", "father", "kids", "filename", "parents", "values", "projects", "files", "words", "items", "ools", "rows", "parent", "loc", "each", "list", "begin", "ul", "events", "blocks", "mount", "opens", "content", "other", "pages", " Children", "data", "ums", "Children", "scenes", "balls", "collection", "names", "web", "pes", "tests"], "i": ["qi", "v", "lc", "k", "iv", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "q", "start", "end", "li", "ui", "u", "hi", "inner", "multi", "ci", "si", "mi", "ii", "m", "y", "j", "type", "ie", "info", "ori", "b", "n", "o", "slice", "ri", "uri", "p", "gi", "key", "h", "ix", "fi", "it", "di", "in", "oi", "d", "ji", "part", "mu", "f", "pi"], "newFile": ["createDir", "Newfile", "NewFiles", "oldFiles", " newDirectory", "nextfile", "createfile", "nextFiles", "NewDir", "NewDirectory", "newDirectory", "createSource", " newSourceFile", "NewFile", " newfile", "NewSource", "oldDir", " newFiles", "oldFile", "nextSource", "newfile", "newSource", "NewSourceFile", "nextSourceFile", "nextDir", "oldDirectory", "nextFile", "createFile", "newFiles", "newSourceFile"], "output": ["complete", "external", "flow", "address", "result", "oper", "error", "console", "change", "after", "current", "ou", "put", "Output", "target", "out", "core", "binary", "generation", "four", "ilo", "generated", "image", "write", "operation", "writer", "connection", "application", "object", "parent", "kernel", "o", "again", "config", "socket", "outer", "update", "display", "service", "resource", "option", "other", "page", "file", "unit", "web", "control", "response", "temp"], "input": ["exec", "flow", "error", "client", "reader", "audio", "feed", "current", "inc", "child", "raw", "Input", "operator", "request", "index", "keep", "out", "context", "stream", "inner", "image", "this", "self", "storage", "connection", "print", "text", "parent", "config", "pull", "socket", "buffer", "resource", "inf", "plus", "form", "http", "in", "data", "work", "before", "instance", "ink", "ack", "temp"], "buff": ["bind", "uf", "cf", "cod", "bb", "gb", "ob", "bin", "comb", "feed", "load", "cur", "boot", "fb", "length", "cp", "bug", "cmd", "bound", "fe", "info", "ph", "batch", "count", "b", "shape", "buf", "text", "cast", "Buff", "ff", "back", "oct", "slice", "pad", "hello", "buffer", "pack", "uff", "rb", "flush", "data", "char", "gz", "txt", "comment", "cb", "f"], "read": ["exec", "k", "ip", "send", "reader", "allow", "parse", "lex", "use", "id", "feed", "io", "load", "transfer", "check", "skip", "x", "readable", "ask", "index", "reading", "start", "length", "ind", "end", "seek", "play", "write", "next", "len", " load", "rate", "en", "type", "wait", "count", "b", "fill", "text", "n", "find", "Read", "config", "sync", "slice", "READ", "ok", "buffer", " write", "iter", "close", "add", "get", "se", "loop", "and", "reads", "pass", "ink", "open", " count", "size", "select", "f", "run"]}}
{"id1": "5543349", "id2": "20568568", "code1": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "code2": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"loadMFileViaWeb": ["loadMFileViaweb", "loadMFileviaWeb", "loadMFilesviaweb", "loadMFilesviaWeb", "loadMFilesViaWeb", "loadMFilesViaweb", "loadMFileviaweb", "loadMFileUsingweb", "loadMFileUsingWeb"], "codeBase": [" codeFile", "codeFile", " codeLocation", "CodeBase", "knowledgeLocation", "knowledgeName", "CodeFile", "codeLocation", "addressUrl", "Codebase", "CodeLocation", "knowledgebase", "knowledgeBase", "codeUrl", "CodeUrl", "knowledgeFile", "addressBase", "addressName", "CodeName", "codeName", "knowledgeUrl", "codebase", "addressbase", " codebase"], "directoryAndFile": ["directoryandSourceFile", "filenameAndFilename", "directoryandFiles", "directoryWithFiles", "directoryWithFilename", "DirectoryOrSourceFile", "DirectoryAndFile", "directoryOrFile", "filenameAndFile", "DirectoryAndFilename", "directoryAndFiles", "filenameandFilename", "directoryOrSourceFile", "directoryOrfile", "directoryOrFiles", "filenameandfile", "filenameAndFiles", "filenameandFile", "directoryFromFilename", "directoryandFilename", "directoryAndSourceFile", "DirectoryOrfile", "filenameAndfile", "directoryWithFile", "directoryandfile", "directoryFromSourceFile", "directoryWithfile", "directoryAndfile", "DirectoryAndSourceFile", "directoryAndFilename", "directoryFromfile", "directoryFromFile", "filenameandFiles", "DirectoryOrFilename", "DirectoryAndfile", "directoryandFile", "DirectoryOrFile", "directoryOrFilename"], "mFileName": ["mClassName", "pFileName", "mFilesKey", "mBasePath", "MClassData", "pFunctionInfo", "MSourceFileHandle", "MClassPath", "mStringName", "mClassPath", "pFunctionName", "MFileHandle", "mStringKey", "mLibraryYear", "cmFilesname", "mFileHandle", "mClassFile", "mFilenameHandle", "mFunctionName", "mFilenamePath", "mClassKey", "pFilePath", "mStringname", "mFileFile", "mFileInfo", "mSourceFilePath", "cmFilePath", "mLibraryName", "MClassName", "mClassname", "mClassData", "MFileFile", "pFunctionPath", "mBaseData", "mClassType", "MClassFile", "mSourceFileName", "mFilesPath", "pFileType", "cmFilesKey", "mFilename", "mStringPath", "MSourceFileYear", "MFileYear", "cmFilesName", "mFileType", "mFileData", "mFilesType", "MFileName", "MFilePath", "MSourceFileName", "cmFilename", "mSourceFileHandle", "mSourceFileYear", "mFileYear", "cmFileKey", "mLibraryHandle", "cmFileName", "mFilenameName", "mBaseFile", "mFilesInfo", "mFunctionInfo", "mFilesName", "mFilesname", "mBaseName", "mFilenameData", "mLibraryPath", "mFilenameFile", "mClassInfo", "pFunctionType", "pFileInfo", "mFilePath", "MSourceFilePath", "mFilenameYear", "mFunctionType", "MFileData", "mFileKey", "cmFilesPath", "mFunctionPath"], "code": ["test", "address", "error", "id", "name", "length", "method", "ce", " Code", "message", "age", "data", "file", "cause", "loop", "script", "f", "header", "status", "cod", "use", "Code", "func", "check", "x", "string", "c", "java", "class", "number", "escape", "buffer", "key", "coded", "page", "create", "closure", "comment", "result", "xxx", "call", "now", "zip", "info", "count", "go", "body", "content", "module", "exec", "callback", "expression", "type", "text", "n", "co", "done", "frame", "fore", "codes"], "function": [" functionality", "feature", " module", "result", "fp", "error", "job", "fun", "call", "output", " library", "func", "python", "string", "word", "functional", "section", "action", "callback", "expression", "lambda", "operation", "lib", "event", "element", "component", "connection", "role", "class", "library", "number", "object", "rule", "handler", "array", "service", " object", "form", "document", "fn", "file", "Function", "variable", "instance", "value", "unit", "f", "ctor", "module"], "url": ["address", "base", "reader", "feed", "URL", "ball", "jar", "path", "log", "sl", "er", "Url", "string", "stream", "image", "ssl", "i", "r", "connection", "user", "b", "browser", "socket", "loader", "ur", "update", "uri", "resource", "bel", "key", "http", "plug", "l", "source", "file", "server", "data", "channel", "page", "download", "web", "blog", "f"], "in": ["gin", "ins", "reader", "din", "IN", "client", "login", "bin", "ar", "io", "inc", "ini", "input", "er", "out", "In", "inner", "stream", "image", "err", "c", "read", "Reader", "ssl", "a", "i", "r", "b", "socket", "loader", "fr", "buffer", "inn", "af", "is", "arin", "data", "file", "ac", "as", "serv", "f"], "inReader": ["inWriter", "inParser", "InStream", "InReader", "InFile", " inFile", "INWriter", "inFile", "incParser", "outStream", " inRead", "InRead", " inParser", " inStream", " inWriter", "inStream", "inRead", "outReader", "InWriter", "outParser", "INReader", "incRead", "incReader", "incWriter", "InParser", "outWriter", "INFile", "INRead"], "line": ["lc", "cl", "error", "column", "re", "str", "e", "id", "model", "page", "include", "row", "lined", "sl", "string", "name", "cr", "Line", "word", "lines", "c", "link", "write", "character", "LINE", "type", "i", "r", "pe", "connection", "number", "text", "message", "key", "content", "lf", "l", "data", "entry", "file", "lin", "col", "letter", "char", "source", "inline", "frame", "record", "pass", "liner", "part", "comment", "cell"], "end": ["complete", "End", "e", "id", "load", "start", "END", "name", "set", "ending", "all", "en", "info", "ended", "stop", "block", "begin", "add", "append", "init", "pos", "create", "open"]}}
{"id1": "14783950", "id2": "11562165", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressWithJar", "compressedWithJar", "compresswithSax", "compressedUsingJar", "compressInSax", "compressUsingJar", "compressedUsingSax", "compresswithJar", "compressInZip", "compressedUsingZip", "compressUsingZip", "compresswithZip", "compressUsingSax", "compressedWithZip", "compressedWithSax", "compressWithSax", "compressInJar"], "fileList": ["FileChain", "ziplist", "wordString", "fileStream", "modelList", " fileChain", "Filelist", "stringList", "modelStream", "stringChain", "zipSet", "modelEx", "FileName", "FileSet", "stringName", " fileCollection", "inputEx", "inputStream", " fileSet", "modelCollection", "fileChain", "fileEx", "inputList", " fileStream", "stringlist", "FileString", " fileString", "zipList", "fileCollection", "wordName", "fileString", " fileEx", "FileStream", "zipName", "inputCollection", " filelist", "FileList", "wordList", "fileSet", "wordStream", "filelist"], "zipFileName": ["archiveFileDir", "zipFileNames", "folderGlobalPath", "zipFullNames", "zipFilePath", "archiveDirName", "folderGlobalName", "zipPackageDir", "archiveFilePath", "zipFullname", "zipGlobalPath", "zipDirName", "folderGlobalname", "zipGlobalNames", "zipPackageName", "zipGlobalname", "folderFilePath", "zipFullPath", "folderFileName", "zipDirNames", "archiveDirPath", "archiveFileName", "zipFilename", "archiveDirDir", "zipFullName", "folderGlobalNames", "zipGlobalName", "zipPackagePath", "zipFullDir", "folderFileNames", "folderFilename", "zipFileDir", "zipDirDir", "zipDirname", "zipDirPath"], "fos": ["afaos", " fosh", "flis", "afos", "infis", "Fosh", "Fos", "foS", "Fis", "flosh", "afis", "fosh", "infaos", "afoS", "infoS", "infos", "FoS", "flos", "faos", "Faos"], "zos": ["z", "osi", "outs", "zzy", "onz", "ZA", "zar", "kos", "zip", "seconds", "bis", "zers", "spin", "chini", "es", "zon", "budget", "tz", "uz", "jobs", "zen", "zes", "os", "ses", "bag", "zl", "phi", "webkit", "bos", "zan", "dos", "zer", "iframe", "zo", "ozo", "zi", "LOS", "fits", "lins", "oses", "css", "zx", "nz", "zz", "fi", "zag", "rez", "abi", "cos", "inos", "jas", "zb", "ZI", "gz", "loop", "packs", "bes", "zik", "closure", "obb", "ros", "lol", "zy"], "iter": ["ser", "oper", "test", "ip", "chain", "ter", "upper", "itter", "enter", "parse", "finder", "el", "e", "ator", "inc", "sort", "cher", "index", "er", "former", "keep", "iz", "ir", "end", "inner", "liter", "set", "err", "next", "order", "iner", "Iterator", "ie", "i", "ite", "fer", "loc", "list", "walker", "gener", "ner", "inse", "outer", "slice", "fr", "it", "iterator", "is", "http", "file", "izer", "Iter", "coll", "inter", "f", "ener"], "fileName": ["FileType", " filePart", "FileLine", "fPart", "currentname", "localname", "localPart", "FileUrl", " filePath", "currentData", "localPath", "pageName", "filenameInfo", " fileUrl", "filename", "FileName", "currentUrl", "currentName", "fileOpen", "pagename", "fileLine", "filenamename", " fileFull", "fileData", " fileOpen", "simpleOpen", "filenameName", "fName", " fileData", " fileInfo", "fullPath", "fullOpen", "FileString", "filePart", "fileType", " fileString", "FilePath", "filenameFull", "FilePart", "fileInfo", "fLine", "fileFull", "fullName", "fileString", " filename", "FileFull", " fileLine", " fileType", "fname", "simplePath", "simpleName", "filePath", "FileInfo", "localName", "pageString", "FileData", "fileUrl", "pageType", "Filename"], "ind": ["bind", "mind", "z", "id", "inc", "Ind", "x", "index", "div", "val", "pt", "start", "length", "ded", "pend", "end", "rib", "ci", "len", "ii", "j", "i", "count", "eff", "pull", "loc", "ord", "cond", "fr", "ad", "inn", "wind", "ix", "nd", "in", "vert", "ld", "dir", "mid", "pos", "IND", "d"], "shortName": ["ShortPath", "smallName", "longName", "ShortPart", "fullLine", "smallname", "shortPart", "longPart", "smallPart", "longname", "smallPath", "shortname", "fullString", "fullname", "longPath", " shortString", "fullPath", " shortname", " shortLine", "ShortString", "fullName", "shortString", "Shortname", "shortPath", " shortPath", "longLine", "shortLine", "ShortName"], "fis": [" fiss", "fris", "cfis", "gisa", "afos", "Fos", " fisa", "Fis", "fios", "afis", "cfiss", "pis", "Fiss", "gios", "pris", "Fs", " fios", "fs", "gris", "fiss", " fs", "afiss", "cfos", "gis", "afris", "cfris", "cfs", "pisa", " fris", "pios", "fisa"], "buf": ["vec", "uf", "bc", "v", "uc", "bb", "bin", "tmp", "br", "bd", "cv", "bp", "cur", "fb", "ba", "seq", "queue", "bl", "bag", "box", "batch", "Buff", "lb", "b", "grab", "ff", "loc", "wb", "buffer", "done", "la", "bytes", "rb", "fd", "feat", "rc", "data", "pb", "bh", "bf", "lim", "cb", "buff", "bu"], "bytesRead": [" bytesSkip", "flowsLength", "bitsSkip", "secondsRead", "tesSkip", "secondsNeed", "secondsWrite", "wordsRead", "bitsRead", "secondsLength", "flowsRead", "flowsNeed", "tesWrite", "wordsWrite", "bytesSkip", " bytesUse", " bytesWrite", "bytesWrite", "bytesLength", " bytesLength", "flowsWrite", "bitsLoad", "bitsWrite", "tesLoad", "wordsUse", " bytesNeed", "bytesUse", "tesRead", " bytesLoad", "wordsLength", "bytesNeed", "bitsUse", "bytesLoad", "bitsLength"]}}
{"id1": "5759961", "id2": "1371265", "code1": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "code2": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"saveUser": ["SaveUser", "SavePerson", "savePerson", " savePerson", "saveuser", "saveAccount", "submitAccount", "submitUser", "submitPerson", "SaveAccount", " saveuser", "Saveuser", " saveAccount", "submituser"], "user": ["result", "base", "account", "ver", "job", "clean", "project", "e", "use", "force", "app", "valid", "model", "replace", "db", "one", "request", "log", "User", "student", "users", "plugin", "creator", "name", "string", "profile", "bug", "word", "this", "facebook", "self", "book", "editor", "or", "username", "you", "used", "class", "object", "parent", "rule", "query", "per", "config", "service", "resource", "person", "content", "me", "usr", "data", "up", "entry", "USER", "password", "style", "tool", "full", "group", "home", "uid", "team", "record", "blog", "author", "module"], "digest": ["digit", "signEST", "signest", "mdEST", "genest", "bigest", "genge", "mdit", "Digge", " digge", "mdest", "digEST", "Digert", "bigester", " digester", "digester", "digert", "digge", " digEST", "mdge", "DigEST", "bigge", " digert", "genit", "Diger", "Digester", "signester", "diger", "Digest", " diger", "signer", "biger", "Digit", "genEST", "bigert"], "hash": ["url", "base", "sha", "ash", "cache", "id", "current", "db", "check", "Hash", "total", "index", "string", "max", "memory", "image", "hex", "build", "code", "count", "html", "fill", "number", "empty", "query", "block", "her", "message", "array", "update", "version", "depth", "key", "mac", "math", "search", "h", "match", "password", "num", "full", "sum"], "bigInt": ["hashInt", "Bigint", "largeInteger", "bigint", "hashUrl", "BigInt", "hugeInteger", "hugeint", "BigInteger", "hashint", "largeint", "bigInteger", "bigString", "bigUrl", " bigUrl", "largeInt", " bigInteger", "hugeInt", "largeString", "hugeUrl", "BigString", " bigint", "hashInteger", " bigString"], "hashtext": ["hashword", "sumText", "sumfeed", "ashstring", " hashword", " hashText", " hashstring", "ashText", " hashpath", "sumtext", "ashpath", " hashTEXT", "hashText", "ashfeed", "sumTEXT", "ashtext", "sumstring", "hashTEXT", "hashfeed", "Hashstring", "Hashpath", "HashTEXT", "hashstring", "HashText", "Hashword", "ashTEXT", "hashpath", "ashword", "sumword", "Hashfeed", "Hashtext"]}}
{"id1": "8000624", "id2": "659316", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copyTo", "CopyFrom", "copyTo", " copyto", " transferTo", "CopyFile", " copyFile", "copyFrom", "copyFile", " transferFile", "Copyto", " copyFrom", " transferFrom", "copyto", " transferto"], "dest": ["rest", "test", "cont", "img", "sup", "w", "delete", "output", "bin", "tmp", "exit", "comb", "path", "folder", "target", "filename", "flat", "name", "obj", "write", "them", "Dest", "class", "transform", "orig", "object", "desc", "wb", "table", "done", "content", "source", "data", "file", "destroy", "dist", " destination", "src", "die", "later", "opt", "txt", " Dest", "temp"], "in": ["gin", "ins", "thin", "reader", "din", "IN", "re", "login", "bin", "id", "isin", "inc", "vin", "x", "ini", "input", "issue", "In", "s", "conn", "inner", "ln", "image", "fa", "ax", "lib", "m", "i", "r", "connection", "b", "n", "again", "sin", "pull", "nin", "win", "inn", "wave", "pin", "plus", "h", "l", "lin", "source", "cin", "up", "init", "inside", "kin", "rin", "pass", "con", "ac", "as", "f"], "out": ["net", "exec", "external", "url", "OUT", "client", "outs", "cache", "w", "call", "output", "bin", "app", "ou", "io", "inc", "not", "one", "x", "outside", "target", "conn", "name", "ext", "inner", "image", "err", "no", "off", "this", "Out", "lib", "or", "writer", "i", "user", "b", "ex", "n", "again", "object", "o", "socket", "sync", "nin", "outer", "timeout", "plus", "pin", "copy", "other", "data", "vert", "up", "file", "our", "part", "temp"], "c": ["v", "cm", "cl", "lc", "cf", "bc", "cy", "exc", "uc", "ca", "e", "C", "x", "ic", "pointer", "oc", "cr", "u", "ci", "cc", "code", "m", "ct", "ec", "t", "i", "r", "arc", "cu", "ce", "n", "xc", "esc", "o", "config", "fc", "enc", "buffer", "dc", "p", "content", "rc", "col", "l", "char", "ch", "sc", "d", "pc", "ac", "abc", "comment", "cb", "f"]}}
{"id1": "6906419", "id2": "9550506", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["encryptpassword", "decryptpassword", "encrateHash", "decryptString", "encipherPassword", "decipherHash", "encipherString", "enccryptString", "enccryptpassword", "encratepassword", "encratePassword", "decryptHash", "encryptHash", "enccryptPassword", "encipherpassword", "encipherHash", "encryptString", "decipherpassword", "enccryptHash", "encrateString", "decipherPassword", "decipherString", "decryptPassword"], "password": ["address", "token", "Password", "project", "sword", "path", "input", "pattern", "string", "name", "seed", "word", "prefix", "database", "auth", "words", "username", "crypt", "confirmed", "user", "text", "padding", "buffer", "message", "array", "p", "wd", "key", "content", " passwords", "phrase", "data", "PASS", "secret", "pass"], "digest": [" digested", "diffester", "initText", " digText", "hashest", "signEST", "signest", "initest", "digeter", "digText", " digests", "digEST", " digester", "digester", " digEST", "digests", "DigText", "Digests", "diffEST", "diffest", "diffested", "hasher", "DigEST", "digested", "initests", "Diger", "Digester", "hasheter", "hashester", "signester", " digeter", "diger", "Digest", " diger", "signer", "Digested", "initEST", "Digeter"], "hash": ["map", "address", "url", "header", "sha", "error", "ash", "cache", "handle", "bin", "id", "cover", "check", "Hash", "log", "mask", "index", "kh", "bug", "memory", "image", "hex", "ashes", "build", "code", "auth", "batch", "html", "count", "history", "number", "body", "hed", "query", "diff", "block", "buffer", "array", "message", "version", "wave", "key", "h", "search", "sh", "filter", "char", "match", "bh", "secret", "value", "f", "sum", "ha"], "buf": ["Buffer", "uf", "fp", "bc", "v", "cap", "url", "vec", "img", "uc", "vr", "builder", "bb", "aux", "ob", "bin", "tmp", "port", "cv", "nb", "func", "db", "cur", "ctx", "fb", "ba", "out", "conv", "queue", "pkg", "uv", "bag", "buff", "sb", "box", "Buff", "uber", "b", "abb", "config", "pad", "wb", "buffer", "ab", "la", "rb", "cas", "af", "data", "pb", "append", "bh", "va", "fw", "coll", "bf", "src", "abc", "runner", "home", "cb", "f", "bu", "cmp"], "i": ["qi", "v", "ip", "ai", "ti", "mini", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "length", "li", "u", "ui", "hi", "multi", "ci", "c", "uni", "si", "phi", "ii", "j", "type", "a", "count", "info", "ie", "b", "n", "o", "slice", "ri", "uri", "p", "key", "gi", "h", "ix", "abi", "fi", "l", "oi", "di", "it", "init", "d", "ji", "mu", "f", "pi"], "halfbyte": ["superbit", "halfurl", "thirdsecond", "thirdnumber", "postbit", "quarterurl", "littlebit", " halfbit", " halfreference", "quarterByte", "Halfbit", "littleByte", "littlereference", "thirdbyte", "superchar", "wardurl", " halfnumber", " halfchar", "superbyte", "quarterbyte", "postbyte", "halfnumber", "halfsecond", " halfByte", "quarterbytes", "sideByte", "quartersecond", "sidebyte", "HalfByte", "Halfbyte", "halfbytes", "quarternumber", "wardbyte", " halfurl", "Halfchar", "halfByte", "sidereference", "halfabyte", "sidebit", "postabyte", " halfsecond", "halfbit", "quarterbit", "littlebyte", " halfabyte", "wardbytes", "halfreference", "quarterabyte", " halfbytes", "halfchar"], "two_halfs": ["two_commonrows", "two_halfions", "two_quarterows", "two_hatows", "two_Halfrows", "two_Halfs", "two_thirdbytes", "two_quarters", "two_quarterrows", "two_halfbytes", "two_halfows", "two_halfis", "two_hatrows", "two_parts", "two_commons", "two_partrows", "two_thirdrows", "two_commonions", "two_commonows", "two_hats", "two_partbytes", "two_halfrows", "two_Halfbytes", "two_thirdis", "two_hations", "two_quarterions", "two_thirds", "two_Halfis", "two_partis"]}}
{"id1": "14567939", "id2": "10715601", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"baseHash": [" generateFile", "basehash", "Basehash", "BaseFile", "BaseHash", " generatehash", " generateHash", "BaseSecret", "baseSecret", " chainSecret", " chainHash", "baseFile", " chainFile", " generateSecret", " chainhash"], "name": ["hash", "address", "base", "account", "alias", "ame", "id", "Name", "path", "host", "string", "named", "word", "image", "prefix", "normal", "type", "class", "user", "definition", "n", "object", "parent", "hello", "resource", "key", "data", "file", "style", "secret", "member", "create", "names", "part", "NAME"], "password": ["hash", "account", "token", "Password", "sword", "priv", "security", "wallet", "path", "input", "pattern", "string", "seed", "profile", "word", "prefix", "code", "auth", "words", "username", "crypt", "text", "diff", "padding", "attribute", "key", "wd", "phrase", "data", "PASS", "source", "secret", "device", "pass", "value", "paste", "stroke"], "digest": [" digested", " digusher", "signest", "mdEST", "Digger", "modested", "digEST", "mdest", "modester", "signger", " digester", "digester", "decest", "decester", "digusher", "decr", "mdr", "Digusher", "digested", "DigEST", "digr", "Diger", "Digester", "modest", "signester", "diger", "Digest", " diger", "signer", "digger", "Digested", "moder", " digger", "Digr", "signusher", "decEST", "mdester"]}}
{"id1": "4501356", "id2": "6517139", "code1": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "code2": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "label": 1, "substitutes": {"calculateProfileDiffDigest": ["calculateProfileDiffMDHash", "calculateProfilediffDigests", "calculateProfilediffdigr", "calculateProfileDiffCodest", "calculateProfileDiffDigHash", "calculateProfilediffdigests", "calculateProfilediffDigHash", "calculateProfileDiffDigr", "calculateProfileDiffMDest", "calculateProfilediffDigest", "calculateProfileDiffCodr", "calculateProfilediffDigr", "calculateProfileDiffMDests", "calculateProfileDiffdigest", "calculateProfileDiffdigHash", "calculateProfileDiffdigests", "calculateProfileDiffCodests", "calculateProfileDiffdigr", "calculateProfileDiffCodHash", "calculateProfilediffdigest", "calculateProfileDiffMDr", "calculateProfilediffdigHash", "calculateProfileDiffDigests"], "profileDiff": [" profilediff", "stylediff", "settingsDust", "summaryEdit", "familyDiff", " profileInfo", "messagePath", "imageDie", "profPath", "profilePath", "imageDelta", "familyInf", "pictureInfo", "familyEdit", "settingsDiff", " profileDie", "styleDiff", "profileInfo", "profdiff", "summaryInf", " profileDelta", "messagediff", " profileEdit", " profileName", "imageDiff", "pictureDiff", "settingsDie", " profilePath", "imageDust", " profileDust", "profilediff", "styleName", "pictureName", "profileDie", "summaryInfo", "profInfo", "profileDelta", "profileDust", "profileName", "profDiff", "styleInfo", " profileInf", "settingsDelta", "profileEdit", "summaryDiff", "picturediff", "messageInfo", "messageDiff", "familyInfo", "profileInf"], "normaliseWhitespace": ["normaliseWhitesspace", "normaliseWhpacepaces", "normaliseWhipspaces", "normaliseWhpacespace", "normaliseWhpacespaced", "normaliseWpacespace", "normaliseWpacespaced", "normaliseWpacespaces", "normaliseWhickspaced", "normaliseWpacesspace", "normaliseWhitespaced", "normaliseWitespace", "normaliseWhipespaces", "normaliseWhpacespaces", "normaliseWitesspace", "normaliseWpacesSpace", "normaliseWitespaces", "normaliseWitespaced", "normaliseWhicksspace", "normaliseWhpaceSpace", "normaliseWhipspace", "normaliseWhipsspace", "normaliseWhpacepace", "normaliseWhipsSpace", "normaliseWhipesspace", "normaliseWhitesSpace", "normaliseWhpacesSpace", "normaliseWhpacesspace", "normaliseWhickspaces", "normaliseWhipespaced", "normaliseWitesSpace", "normaliseWhitespaces", "normaliseWhickspace", "normaliseWhipespace"], "md": ["mad", "MD", "hash", "mc", "sha", "dig", "metadata", "rm", "pm", "bd", "amd", "db", "df", "meta", "mb", "mt", "cmd", "hd", "mand", "editor", "m", "dd", "Cmd", "gd", "b", "sd", " MD", "od", "diff", "mg", "mm", "message", "ma", "pd", "cd", "ds", "wd", "mac", "me", "d", "mag", "bf", "dm", "f", "mp", "msg"]}}
{"id1": "15362793", "id2": "1235538", "code1": "    public static String ReadURL(URL url, boolean textonly) {\n        try {\n            URLConnection uconn = url.openConnection();\n            Object ucont = uconn.getContent();\n            if (ucont instanceof InputStream) return ReadInputStream((java.io.InputStream) ucont, textonly); else return \"\" + ucont;\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 0, "substitutes": {"ReadURL": ["GetString", "GetUrl", " ReadString", "readURL", "ReadUrl", "ReadString", " ReadHTTP", "readString", "ReadHTTP", "GetURL", "readHTTP", "readUrl", " ReadUrl", "GetHTTP"], "url": ["address", "base", "str", "io", "URL", "jar", "path", "sl", "Url", "host", "conn", "string", "secure", "bug", "image", "err", "link", "this", "or", "ssl", "connection", "user", "twitter", "ll", "config", "loc", "ur", "fr", "uri", "service", "resource", "api", "http", "l", "page", "source", "server", "file", "impl", "web"], "textonly": [" textOnly", " textempty", "extonly", "textOnly", "Textonly", "extOnly", "TextOnly", "Textempty", "textempty", "extempty"], "uconn": ["oucon", "Uconn", " uConn", "Uopen", "luconn", "Uconnect", " uconnection", "Uconnection", "UConn", " ucon", "cuconn", "cuopen", "cuconnection", "luconnect", "luconnection", "ucon", "ouConn", "uconnect", "uopen", "Ucon", "cuconnect", "ouconn", "uConn", "uconnection", "luopen", "ouconnection"], "ucont": ["uuCont", "acent", "uclontent", "uscCont", "ucouch", "ucet", "aucont", "cuent", "unicant", "ucond", "uccnt", "uclouch", "ucnt", "acont", "ucCont", "cuont", "uccront", "acnt", "aucotton", "uscotton", "acotton", "bcont", "uccet", "unicouch", "unicront", "bcnt", "uclont", "uccant", "uscond", "bcront", "uuont", "aucCont", "aucond", "unicontent", "cuotton", "ucent", "ucant", "uccont", "unicet", "aucent", "ucront", "ucontent", "uccouch", "uuotton", "uclet", "uccontent", "aucnt", "uscont", "uuond", "unicont", "unicnt", "cunt", "ucotton", "bcant"]}}
{"id1": "5676111", "id2": "19687456", "code1": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 0, "substitutes": {"get": ["exec", "output", " download", "export", "start", " extract", "end", " upload", "build", "info", "print", " it", " quit", "close", "it", "process", "let", "init", "download", " this", " exit", "open", "run"], "cnt": ["rcnt", "Cwd", "cnn", "fount", "cst", "Cnc", "cnd", " cnd", "rcnd", "Cst", "encNT", "Count", " count", "cwd", " cnc", "fwd", "cNT", " cst", "count", "encnn", " cnn", "rcNT", "fnt", "encnt", "CNT", "Cnn", "Cnt", " cNT", " cwd", "rcnc", "fNT", "encst", "Cnd", "cnc"], "url": ["client", "cache", "str", "bb", "URL", "git", "cur", "path", "log", "sl", "Url", "host", "session", "ir", "ls", "name", "image", "c", "org", "ssl", "connection", "r", "b", "ll", "www", "config", "loc", "socket", "ur", "uri", "resource", "bel", "http", "l", "page", "source", "file", "server", "channel", "download", "coll", "impl", "open", "web", "blog", "f"], "conn": ["exec", "cm", "client", "ai", "ann", "ca", "ob", "io", "not", "cur", "ctx", "connect", "oss", "out", "conv", "cp", "c", "ci", "err", "os", "org", "en", "ec", "ct", "connection", "ssl", "Connection", "n", "enc", "co", "loc", "socket", "dc", "api", "p", "http", "col", "cli", "ch", "server", "init", "cn", "act", "coll", "ens", "con", "nc", "Conn", "open", "cb"], "is": ["us", "im", "ais", "ip", "ai", "ib", "ois", "ob", "are", "isa", "iso", "io", "id", "IS", "bis", "ws", "Is", "es", "res", "ir", "s", "ui", "ris", "ci", "isl", "ios", "iss", "os", "or", "ssl", "ie", "i", "info", "lis", "loc", "isc", "isi", "ri", "uri", "iter", "api", "open", "close", "iris", "http", "in", "init", "src", "as", "bs", "il"], "filename": ["fp", "title", "login", "output", "fil", "family", "ename", "path", "folder", "utf", "nl", "nil", "location", "name", "string", "length", "queue", "size", "prefix", "files", "username", "format", "connection", "class", "directory", "loc", "uri", "key", "fd", "phrase", "l", "source", "fn", "file", "password", "ername", "sf", "Filename", "f", "il"], "fos": ["Fo", " foss", "gos", "fus", "fdo", "fdicks", " fis", "loses", "lo", "Fus", "Foses", "foss", "lios", "efose", "efos", "Fos", "Fis", " fo", "Foss", "fios", "fose", "go", "gios", "Fios", "fis", "Ficks", "fdos", " fus", "los", "goses", "fo", "ficks", " ficks", " fose", "efoss", "fdis", "Fose", "foses", "efus"], "buffer": ["Buffer", "position", "address", "result", "base", "header", "uffer", "reader", "cache", "bb", "output", "transfer", "pause", "feed", "vector", "fb", "border", "input", "length", "sequence", "binary", "offset", "seed", "memory", "queue", "read", "layer", "duration", "reference", "batch", "counter", "b", "shape", "buf", "null", "number", "padding", "iter", "bytes", "wave", "flush", "document", "phrase", "page", "data", "channel", "file", "source", "server", "limit", "size", "buff"]}}
{"id1": "4599372", "id2": "411595", "code1": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"readFixString": ["readfixstring", "createFixString", "readFixedArray", "readfixArray", "readFixContent", "createFixedContent", "createFixedString", "readFixedContent", "readFixstring", "readfixContent", "readfixString", "readAdjuststring", "readAdjustArray", "readFixedstring", "readAdjustString", "createFixArray", "createFixedstring", "readFixArray", "readAdjustContent", "createFixstring", "readFixedString", "createFixedArray", "createFixContent"], "len": ["lc", "lit", "base", "str", "el", "e", "lp", "Len", "val", "sl", "length", "string", "li", "ln", "code", "en", "i", "count", "n", "body", "ll", "enc", "loc", "list", "lf", "l", "line", "lin", "fn", "file", "data", "pos", "lt", "limit", "split", "part", "size", "f", "le"], "sw": ["wt", "wa", "serv", "sv", "tw", "aw", "w", "sr", "bb", " SW", "zip", "io", "lv", "ws", "sl", "es", "fl", "wx", "stream", "hw", "ww", "rw", "sa", "wr", "writer", "sb", "null", "SW", "so", "WS", "ow", "ew", "wb", "nw", "sn", "wh", "wp", "iw", "sh", "sc", "fw", "wra", "ss", "sf", "sp", "Sw"]}}
{"id1": "4686922", "id2": "19147281", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"extractResourceToFile": ["extractResourcesAsfile", "extractResourceInResource", "extractResourceInFile", "extractResourceToResource", "extractResourceInfile", "extractResourceToFiles", "extractResourceInFiles", "extractResourcesToFiles", "extractResourceAsResource", "extractResourcesToResource", "extractResourcesAsFile", "extractResourceAndResource", "extractResourceAsFiles", "extractResourceAsFile", "extractResourcesAsResource", "extractResourcesAsFiles", "extractResourceAndfile", "extractResourceAndFiles", "extractResourceAsfile", "extractResourcesToFile", "extractResourcesTofile", "extractResourceTofile", "extractResourceAndFile"], "resourcePath": ["servicepath", "sourceUrl", "ResourceId", " resourceId", "serviceFolder", "resourceFolder", "resourcepath", " resourcepath", "sourceId", " resourceUrl", "sourcePath", "stringpath", "servicePath", "ResourcePath", "resourceUrl", "stringPath", "sourcepath", "stringFolder", "Resourcepath", " resourceFolder", "resourceId", "ResourceUrl"], "dest": ["sac", "result", "de", "img", "prop", "sup", "project", "output", "tmp", "comb", "transfer", "path", "folder", "default", "target", "filename", "flat", "resources", "Dest", "class", "route", "desc", "const", "config", "wb", "done", "resource", "content", "store", "data", "destroy", "file", "source", "dist", " destination", "src", "contract", "die", "later", "home", "trans", "txt", " Dest", "temp"], "in": ["url", "gin", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "ini", "input", "In", "conn", "inner", "image", "c", "this", "like", "i", "r", "connection", "b", "n", "again", "sin", "rec", "socket", "nin", "win", "resource", "inn", "plus", "is", "arin", "cin", "source", "lin", "up", "file", "init", "inside", "kin", "rin", "pass", "con", "as", "f"], "out": ["net", "exec", "ins", "OUT", "client", "outs", "cache", "w", "output", "bin", "app", "io", "inc", "one", "boot", "outside", "auto", "conn", "s", "In", "ext", "obj", "image", "err", "this", "off", "Out", "ax", "lib", "norm", "all", "at", "writer", "i", "a", "user", "b", "ex", "n", "null", "again", "o", "co", "parent", "sync", "socket", "outer", "copy", "cookie", "cos", "source", "file", "up", "server", "f", "temp"]}}
{"id1": "21125261", "id2": "23452437", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"test": [" testing", " solve", " verify", " tests", " eval", " analyse", " validate", " simulate", " deploy", " process", "Test", " train", "train", "evaluate", " example", " evaluate", " run", " sample", "execute", "Train", "Main", " check", "tests", "run"], "is": ["serv", "ais", "ins", "ai", "does", "iso", "isa", "has", "id", "IS", "bis", "ws", "Is", "es", "res", "ir", "out", "s", "ls", "ris", "stream", "si", "iss", "ios", "os", "ses", "i", "info", "lis", "ps", "isi", "ics", "fs", "opens", "its", "gets", "iris", "in", "ists", "src", "as", "mis"], "byteArrayOutputStream": ["byteStringInputPath", "byteArrayoutputStream", "byteArrayByteStream", "byteStringInputContext", "byteArrayOutputPath", "byteArrayFileStream", "byteArrayOutputSteam", "byteStringInputString", "byteArrayByteFile", "byteArrayInputPath", "byteStringInputSteam", "byteArrayOutputContext", "byteArrayFileString", "byteArrayOutputString", "byteArrayFileSteam", "byteArrayOutputFile", "byteArrayByteSteam", "byteArrayoutputSteam", "byteArrayIOString", "byteArrayInputContext", "byteArrayInputFile", "byteStringOutputPath", "byteArrayIOSteam", "byteStringInputFile", "byteArrayInputStream", "byteArrayIOFile", "byteArrayInputString", "byteArrayIOStream", "byteArrayFileContext", "byteArrayByteString", "byteStringOutputFile", "byteArrayoutputContext", "byteStringOutputContext", "byteArrayInputSteam", "byteStringOutputSteam", "byteStringOutputString", "byteStringInputStream", "byteArrayFileFile", "byteArrayFilePath", "byteStringOutputStream", "byteArrayoutputPath"], "def": ["md", "defined", "de", "da", "base", "pro", "re", "der", "parse", "e", "id", "default", "df", "obj", "define", "decl", "spec", "this", "dem", "info", "des", "definition", "class", "bus", "report", "desc", "config", "Def", "di", "data", "entry", "file", "init", "dist", "ref", "d", "dir", "DE", "frame", "dev", "DEF", "conf", "f"], "se": ["ser", "su", "de", "parse", "lex", "pse", "sem", "zip", "site", "e", "sec", "ste", "sl", "es", "ge", "SE", "te", "s", "sea", "est", "si", "fe", "ses", "sel", "sle", "ase", "ie", "sk", "pe", "so", "see", "ane", "ine", "per", "sche", "cle", "inse", "sed", "service", "ve", "sh", "me", "entry", "ke", "sc", "ade", "ne", "spe", "sp", "ss", "ze", "ce", "le", "be"], "linkId": ["lockById", "lineById", "feedLength", "linkid", "LinkLength", " linkById", "LinkInfo", "feedid", "linkById", " linkid", " linkLength", "lockId", "lockInfo", "linkLength", "feedId", "lineId", "LinkId", "feedInfo", "linkInfo", "lineInfo", "Linkid", " linkInfo"], "segmentId": ["sementId", "segmentsType", "segmentInfo", "selementType", "sementType", "segmentsInfo", " segmentID", "selementId", " segmentsID", "sementID", "segmentsNumber", "negmentId", " segmentsId", "negementCount", "sementNumber", "negementInfo", " segmentType", "segmentCount", " segmentCount", "segmentsID", "segementNumber", "segmentType", "selementID", " segmentsType", "negementId", "negmentNumber", "negementNumber", "sementInfo", "segmentID", "sementCount", "segmentsId", "segementCount", "segementId", "negmentCount", "segmentNumber", "segmentsCount", "selementCount", "segementInfo", "negmentInfo", " segmentsCount"], "linkSegments": ["linkEngines", "linkConnectment", "linkFragments", "linkFraggments", "linkFragures", "lineSegines", "lineSeggments", "lineFragment", "linkIncrements", "linkEnggments", "linkConnectures", "linkEngures", "lineFragments", "linkSeggments", "linkIncrement", "linkSegines", " linkEnggments", "linkSegles", "linkFragines", "linkSegures", "linkEngles", "linkIncreles", "linkEngments", " linkEngures", " linkSegures", "linkConnectgments", " linkEngment", " linkSegment", "lineFragles", " linkSeggments", "linkSegment", "lineSegment", "lineFragines", "lineSegments", "lineSegles", "lineFraggments", "linkIncregments", "linkFragles", "linkConnectments", " linkEngments", "linkEngment", "linkFragment", "linkIncreines"], "segments": ["gegment", "Segments", "scheplings", "pegment", "Seggment", "gegs", "segs", "pegs", "schements", "geplings", "Seggements", "gements", "segment", "Seggments", "pegements", "pements", "seplings", "pegments", "segements", "gegements", "begs", "gegments", "begments", "schegment", "bements", "begment", "peplings", "sements", "schegments"], "frameProperties": ["framePropps", "frameProps", " frameproperties", "framePromperties", "frameproproperties", "frameproeters", " frameProblems", " frameProproperties", " frameproblems", "frameProproperties", "framePromproperties", " frameProps", "framePropblems", " frameProeters", "framePromps", "frameproblems", "framePropeters", "framePrometers", "framePropperties", " frameproproperties", "framePropproperties", " frameprops", "frameprops", "frameProblems", " frameproeters", "frameproperties", "frameProeters"], "time": ["v", "change", "now", "ime", "e", "id", "port", "times", "x", "money", "start", "length", "play", "Time", "tim", "name", "end", "image", "c", "TIME", "step", "rate", "t", "type", "duration", "live", "count", "event", "video", "ice", "speed", "weight", "date", "depth", "timeout", "delay", "h", "once", "age", "cost", "data", "work", "file", "clock", "sleep", "loop", "value", "vel", "f", "activity", "timer", "size", "etime"], "vehicle": ["vertology", "Vehicles", "Vehology", "venicle", " vehology", "bridical", "driicle", "Vehish", "venical", " vehish", "Vehicular", "verticles", " mobicle", "vehicular", " vehicles", "vehicles", "Vehicle", "driical", " vehicular", "bridometry", "verticular", " mobline", "driocity", " mobish", "vehocity", " vehline", "vehical", "venometry", "bridicle", "bridocity", "driometry", "vehline", "vehometry", "verticle", "Vehline", "venocity", " mobicles", "vehish", "vehology"]}}
{"id1": "3309233", "id2": "19322946", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    @Test\n    public void test_lookupType_FullSearch_MatchingWordInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupType/cluster\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":29055,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":29056,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29065,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":29066,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29069,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":29070,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29095,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":29096,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":21013,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Sensor Cluster\\\",\\\"icon\\\":\\\"54_03\\\"},{\\\"itemTypeID\\\":21014,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":32241,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Drive Cluster EDF-285\\\",\\\"icon\\\":\\\"24_11\\\"},{\\\"itemTypeID\\\":5279,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"F-23 Reciprocal Sensor Cluster Link\\\",\\\"icon\\\":\\\"03_09\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11534,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":17340,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11536,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":17333,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11535,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":17345,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6218,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6222,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected LADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6226,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6230,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Multi-Frequency Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6234,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected RADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":7895,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7893,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7914,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7896,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Omni Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7892,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Radar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11537,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":17336,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Gravimetric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6241,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed LADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Magnetometric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6239,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Multi-Frequency Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6225,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed RADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":20238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20244,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20250,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20260,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20240,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20246,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20252,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20262,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":21722,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Sleeper Nanite Cluster\\\",\\\"icon\\\":\\\"55_15\\\"},{\\\"itemTypeID\\\":20242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20248,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20254,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20264,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"doInBackground": ["buildInBackground", " doAsyncBackground", " doUsingBackground", " doAsyncConsole", "buildUsingStudio", " doAsBackground", "buildUsingBackground", " doAsConsole", " doAsyncAsync", " doInConsole", " doUsingAsync", " doUsingStudio", " doAsyncStudio", "buildInAsync", " doAsStudio", " doInAsync", "buildUsingConsole", " doInStudio", "buildUsingAsync", " doUsingConsole", "buildInStudio", "buildInConsole", " doAsAsync"], "params": ["address", "services", "objects", "posts", "types", "eps", "parse", "Param", "pm", "reports", "Parameters", "py", "values", "ls", "Par", "lines", "s", "resources", "results", "files", "comments", "strings", "properties", "type", "i", "arms", "options", "par", "ps", "config", "mes", "pins", "ds", "los", "parts", "p", "phrase", "ams", "page", "source", "data", "keys", "json", "details", "sp", "names", "ctx", "settings"], "param": ["cm", "address", "monitor", "lc", "mor", "amp", "project", "Param", "comment", "pm", "pri", "model", "camp", "proc", "am", "path", "default", "prem", "conn", "name", "string", "prom", "cp", "iam", "Parameter", "mand", "connection", "gram", "null", "object", "par", "parent", "arm", "km", "config", "mm", "rem", "option", "p", " parameter", "meter", "single", "aram", "channel", "pool", "pb", "ams", "vm", "password", "page", "contract", "pc", "ram", "part", "conf", "ctx", "temp"], "client": ["cm", "url", "cl", "base", "project", "app", "force", "proxy", "request", "plugin", "session", "host", "connect", "conn", "secure", "cp", "c", "comp", "self", "bird", "ssl", "connection", "handler", "Client", "config", "apache", "service", "api", "resource", "p", "http", "cli", "channel", "server", "google", "help", "con", "ce", "response"], "post": ["base", "send", "e", "pod", "zip", "pre", "load", "feed", "put", "proc", "request", "patch", "hop", "next", "set", "c", "upload", "dd", "head", "body", "query", "install", "api", "p", "add", "form", "http", "wp", "submit", "entry", "op", "pb", "push", "Post", "server", "pos", "create", "and", "posted", "POST", "pp", "json", "part", "comment", "f", "response"], "resp": ["exec", "error", "Resp", "received", " response", "status", "re", "rh", "rel", "e", "Response", "request", "comm", "res", "conn", "obj", "rep", "success", "err", "respond", "par", "body", "handler", "rec", "enc", "fc", "api", "resource", "content", "http", "page", "server", "download", "ref", "req", "reply", "json", "sp", "serv", "response"], "entity": ["base", "status", "ity", "output", "e", "el", "model", "xml", "node", "string", "conn", "obj", "code", "ec", "event", "element", "connection", "ent", "object", "body", "enc", "attribute", "resource", "person", "agent", "content", "translation", "Entity", "line", "data", "entry", "article", "instance", "coll", "json", "activity", "unit", "response"], "result": ["address", "url", "description", "place", "status", "output", "Result", "default", "row", "res", "string", "location", "name", "ret", "success", "results", "report", "desc", "object", "text", "message", "resource", "property", "content", "translation", "page", "line", "entry", "data", "match", "source", "record", "instance", "value", "json", "details", "response"]}}
{"id1": "10445819", "id2": "7927042", "code1": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "code2": "    private void loadDynamically(File result, String extraPath) {\n        URL url = null;\n        InputStream is = null;\n        FileOutputStream fos = null;\n        try {\n            url = new URL(homeServerUrl + extraPath);\n            is = url.openStream();\n            fos = new FileOutputStream(result);\n            byte[] buff = new byte[8192];\n            int nbRead;\n            while ((nbRead = is.read(buff)) > 0) fos.write(buff, 0, nbRead);\n        } catch (IOException e) {\n            throw new StellariumException(\"Cannot dynamically load \" + result + \" from \" + url);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getReader": ["getreader", "loadStream", "readParser", "newreader", "loadreader", "newParser", "newReader", "newStream", "readreader", "loadParser", "getStream", "readReader", "getParser", "loadReader", "readStream"], "stream": ["v", "url", "cont", "reader", "clean", "output", "window", "port", "feed", "zip", "valid", "child", "raw", "sl", "input", "host", "upload", "ream", "serial", "Stream", "read", "null", "object", "body", "slice", "sync", "draft", "resource", "open", "wrapper", "content", "form", "document", "http", "data", "channel", "file", "source", "pool", "instance", "coll", "draw", "roll", "trans", "sw", "impl", "control", "f", "temp"]}}
{"id1": "17999474", "id2": "15409512", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipAtfile", "getZipasPlace", "getZipasfile", "getTempAsDir", "getZipAsfile", "getTempAsPlace", "getZipAtPlace", "getZipAtDir", "getTempAsFile", "getZipasDir", "getTempAsfile", "getZipasFile", "getZipAsDir", "getZipAsPlace", "getZipAtFile"], "digOb": [" digOl", "dimObj", "signObject", "DigOb", "digObj", " digob", " digOB", " digObject", "DigObj", "ditob", "ditOb", "DigObject", "signob", "digOB", "DigOl", "digObject", "signOb", "ditOB", "ditObject", "digob", "digOl", "signOB", " digObj", "dimOl", "dimObject", "dimOb", "signObj", "Digob"], "folderName": ["foldername", "foldPath", "FolderInfo", " foldername", "foldname", "Foldername", " folderDir", "folderPath", "filename", "packagename", " folderPath", "foldInfo", "FolderName", "FolderDir", "packageDir", "fileInfo", "packagePath", "filePath", "FolderPath", "folderInfo", "packageName", "foldName", "folderDir", "fileName"], "tmpFolder": [" temporaryfolder", "mpfolder", " tmpDirectory", "mpDirectory", "tmpDir", "mpFolder", " tmpManager", " tmpDir", "tmpManager", "tempFolder", "tempDir", "tmpDirectory", "tmpfolder", "mpDir", "tempfolder", "tempDirectory", " temporaryManager", " tmpfolder", "tempManager", " temporaryFolder", " temporaryDirectory"], "zip": ["flow", "fp", "z", "url", "cf", "ip", "wrap", " zipper", "job", "lex", "tmp", "io", "proxy", "feed", " ZIP", "jar", "ress", "ulp", "folder", "xml", "ipped", "sl", "py", "flat", "seed", "archive", "lock", "pkg", "upload", "bag", "lib", "zone", "ie", "cop", "ce", "ignore", "pipe", "slice", "install", "pack", "clip", "p", "copy", "source", "file", "download", "gz", "Zip", "json", "ze", "f", "temp"], "out": ["flow", "z", "result", "url", "base", "OUT", "client", "outs", "cache", "gen", "output", "io", "child", "path", "log", "conn", "obj", "write", "err", "this", "upload", "Out", "plain", "os", "writer", "info", "a", "connection", "user", "box", "null", "object", "again", "ex", "o", "parent", "sync", "socket", "loader", "flush", "copy", "is", "in", "page", "line", "cli", "file", "source", "download", "gz", "f", "temp"]}}
{"id1": "8150996", "id2": "19134229", "code1": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "in": ["url", "base", "ins", "reader", "din", "IN", "cache", "bin", "id", "io", "inc", "ini", "input", "In", "name", "inner", "image", "c", "or", "m", "a", "i", "r", "b", "again", "sin", "inn", "min", "it", "cin", "lin", "source", "file", "data", "init", "src", "part", "f"], "out": ["exec", "base", "OUT", "outs", "cache", "project", "output", "exp", "io", "one", "x", "conn", "s", "ext", "dot", "name", "to", "lock", "write", "prefix", "off", "err", "doc", "Out", "plain", "lib", "at", "writer", "user", "b", "ex", "null", "again", "object", "o", "p", "point", "line", "data", "cos", "file", "server", "pos", "part"], "is": ["us", "im", "ais", "osi", "ins", "ip", "ai", "ms", "ib", "ois", "ob", "iso", "isa", "ar", "are", "was", "io", "id", "has", "IS", "app", "isin", "Is", "ini", "es", "oss", "ic", "abs", "ir", "s", "ui", "eni", "ci", "isl", "err", "si", "ios", "iss", "nis", "like", "or", "ori", "i", "info", "ie", "js", "cs", "ops", "loc", "isi", "ri", "ics", "uri", "fs", "get", "its", "iris", "http", "cos", "ens", "init", "as", "bs", "mis"], "os": ["sys", "us", "mos", "OS", "osi", "Os", "nos", "ois", "ot", "aos", "io", "bis", "vs", "boot", "es", "oss", "ks", "ns", "ls", "oes", "ios", "or", "bos", "ori", "oos", "dos", "des", "js", "ops", "ose", "so", "o", "ans", "ows", "fits", "oses", "los", "fs", "ols", "opens", "obs", "cos", "op", "ens", "pos", "ros", "as", "ss", "ol", "bs", "ors", "oS"], "buffer": ["Buffer", "position", "address", "result", "header", "uffer", "reader", "cache", "bin", "transfer", "FFER", "feed", "fb", "input", "border", "length", "sequence", "binary", "seed", "queue", "read", "layer", "reference", "batch", "b", "null", "buf", "block", "padding", "iter", "resource", "wave", "bytes", "flush", "data", "source", "split", "size", "buff"], "len": ["lc", "dl", "el", "id", "Len", "val", "fl", "start", "length", "li", "fin", "offset", "ln", "err", "bl", "en", "ie", "count", "n", "nt", " length", "iter", "min", "bytes", "fd", "lf", "line", "data", "lin", "l", "fn", "pos", "num", "limit", "f", "part", "size", " Len", "le", " el"], "ok": ["md", "k", "result", "error", "clean", "allow", "yes", "found", "id", "valid", "load", "ready", "check", "log", "always", "boot", "val", "bool", "auto", "hack", "bug", "ak", "lock", "err", "c", "oks", "pl", "OK", "self", "code", "or", "o", " cool", "sync", "good", "work", "op", "req", "coll", "fail", "full", "Ok", "ack", "ko", "cb", "f"]}}
{"id1": "10281203", "id2": "5707205", "code1": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "            public void run() {\n                Log.d(LOG_TAG, \"Fetching \" + url);\n                WebDbAdapter dbHelper = new WebDbAdapter(mContext);\n                dbHelper.open();\n                boolean errorOccurred = true;\n                int notifyId = 0;\n                String host = AppUtils.getHostFromUrl(url);\n                try {\n                    if (host == null) {\n                        Log.d(LOG_TAG, \"Bad url \" + url);\n                        errorOccurred = true;\n                    } else {\n                        notifyId = showNotification(\"Fetching \" + host, \"Fetching \" + host, android.R.drawable.stat_sys_download, 0);\n                        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);\n                        String userAgent = sp.getString(mContext.getString(R.string.pref_key_user_agent), mContext.getString(R.string.default_user_agent));\n                        Log.d(LOG_TAG, \"Using user agent=\" + userAgent);\n                        AndroidHttpClient ahc = AndroidHttpClient.newInstance(mContext, url, userAgent);\n                        URI uri = new URI(url);\n                        URI norm = new URI(uri.getScheme().toLowerCase(), uri.getUserInfo(), uri.getHost().toLowerCase(), uri.getPort(), uri.getPath(), uri.getQuery(), null);\n                        norm = norm.normalize();\n                        HttpUriRequest get = new HttpGet(norm);\n                        HttpResponse response = ahc.execute(get);\n                        if (response.getStatusLine().getStatusCode() == 200) {\n                            HttpEntity entity = response.getEntity();\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            entity.writeTo(baos);\n                            String data = baos.toString();\n                            for (int i = 0; i < undesirables.length; i++) {\n                                Pattern p = Pattern.compile(undesirables[i], Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n                                data = data.replaceAll(p.pattern(), \"\");\n                            }\n                            long sysMillis = System.currentTimeMillis();\n                            String newFileName = getPath(sysMillis, sp.getBoolean(mContext.getString(R.string.pref_key_store_sdcard), false));\n                            FileOutputStream strm = new FileOutputStream(newFileName);\n                            Log.d(LOG_TAG, \"Writing to \" + newFileName + \" for url \" + url);\n                            String jsData = AppUtils.fromRawResourceFile(R.raw.retain_loadcolors, mContext);\n                            jsData = jsData.replaceAll(\"@css_file\", RETAIN_COLORS_CSS);\n                            strm.write(jsData.getBytes());\n                            strm.write(data.getBytes());\n                            strm.write(jsData.getBytes());\n                            strm.flush();\n                            strm.close();\n                            String entryName = getTitle(newFileName, url);\n                            long newRowId = dbHelper.createEntry(entryName, newFileName, url, sysMillis);\n                            postToast(\"Downloaded \\\"\" + entryName + \"\\\"\");\n                            errorOccurred = false;\n                            if (deleteRowId != 0) {\n                                Log.d(LOG_TAG, \"Deleting rowId=\" + deleteRowId);\n                                dbHelper.deleteEntry(deleteRowId);\n                                if (url == null) postToast(\"Item Deleted\");\n                                mContext.startActivity(new Intent(mContext, RetainActivity.class));\n                            } else {\n                                showNotification(\"Download Complete\", entryName, android.R.drawable.stat_sys_download_done, newRowId);\n                            }\n                        } else {\n                            Log.e(LOG_TAG, \"Response code=\" + String.valueOf(response.getStatusLine().getStatusCode()));\n                        }\n                    }\n                } catch (IOException ioe) {\n                    Log.e(LOG_TAG, \"RETAIN IOException: \" + ioe.getMessage());\n                } catch (URISyntaxException u) {\n                    Log.e(LOG_TAG, \"RETAIN URISyntaxException: \" + u.getMessage());\n                } catch (OutOfMemoryError oome) {\n                    Log.e(LOG_TAG, \"RETAIN OutOfMemoryError: \" + oome.getMessage());\n                } catch (Exception e) {\n                    Log.e(LOG_TAG, \"RETAIN Exception: \" + e.getMessage());\n                }\n                hideNotification(notifyId);\n                if (errorOccurred && host != null) {\n                    showNotification(\"Error Downloading\", host, android.R.drawable.stat_notify_error, 0);\n                    postToast(\"Error fetching \" + host);\n                }\n                dbHelper.close();\n            }\n", "label": 0, "substitutes": {"makeRead": [" manageREAD", " makeREAD", " makeWrite", "doRead", " manageRead", "doWrite", " manageWrite", " executeSet", " executeRead", " executeREAD", " makeSet", "doREAD", "doSet", " executeWrite", " manageSet"], "user": ["url", "job", "alias", "pod", "use", "comment", "site", "human", "log", "owner", "User", "row", "users", "host", "creator", "string", "name", "month", "bug", "word", "write", "username", "custom", "pid", "nick", "install", "post", "date", "admin", "usr", "server", "USER", "password", "field", "uid", "home", "record", "blog", "author"], "databaseID": ["collectionID", " databaseIDS", "DatabaseId", "connectionIDs", "DatabaseID", "dbID", "collectionId", " databaseName", "DatabaseName", "connectionName", "dbName", "databaseIDs", "databaseIDS", "databaseId", "collectionName", " databaseIDs", "connectionID", "dbIDs", "databaseName", "DatabaseIDS", " databaseId", "collectionIDS"], "time": ["ip", "ime", "comment", "id", "port", "times", "money", "host", "start", "string", "length", "Time", "tim", "name", "month", "end", "tz", "set", "TIME", "year", "rate", "read", "duration", "type", "mode", "counter", "table", "post", "date", "timeout", "delay", "key", "sleep", "clock", "value", "home", "timer", "size", "etime"], "query": ["result", "params", "error", "eries", "Query", "call", "answer", "command", "request", "function", "sql", "q", "string", "conn", "name", "cmd", "database", "code", "sq", "connection", "report", "ql", "scan", "rule", "join", "general", "update", "post", "message", "uri", "condition", "search", "commit", "work", "question", "execute", "script", "json", "comment", "select"], "statement": ["slave", "result", "st", "stat", "alias", "status", "str", "study", "use", "command", "volume", "db", "function", "session", "sql", "mt", "conn", "note", "state", "s", "start", "language", "section", "database", "si", "storage", "expression", "connection", "i", "rule", "join", "general", "inst", "table", "parser", "ma", "media", "agent", "usage", "joined", "message", "condition", "document", "jo", "commit", "di", "server", "execute", "style", "password", "Statement", "instance", "script", "unit", "part", "comment", "response", "relation"], "count": ["base", "error", "cache", "handle", "found", "id", "force", "inc", "child", "total", "Count", "index", "start", "length", "state", "offset", "c", "set", "err", "code", "type", "i", "batch", "number", "find", "diff", "list", "cond", "table", "depth", "key", "get", "by", "age", "process", "limit", "part", "sum", "size", "expected"]}}
{"id1": "18793482", "id2": "16590954", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"modifyApplicationMessage": ["modifyAppmessage", "modifyAppMessage", "modifiedApplicationMessage", "modifyAppMsg", "modifyApplicationContent", "modifiedApplicationContent", "modifiedapplicationContent", "modifiedapplicationmessage", "modifyExternalMsg", "modifyapplicationMsg", "modifyapplicationmessage", "modifyApplicationmessage", "modifyapplicationMessage", "modifyapplicationContent", "modifiedapplicationMsg", "modifiedapplicationMessage", "modifiedApplicationmessage", "modifiedApplicationMsg", "modifyAppContent", "modifyExternalContent", "modifyExternalmessage", "modifyExternalMessage", "modifyApplicationMsg"], "locale": ["localator", "locator", "placeALE", "locationALE", "placeale", "localue", "localale", "localame", "Locator", "locationales", "Locales", " locator", "locales", "Locame", "locue", " locame", "LocALE", " locales", "locationale", "Locale", "placeales", "locALE", "placeame", "localales", "localALE", "locationue", "locame", "Locue"], "messageName": ["MessageKey", "MessageValue", " messagename", "messageKey", " messageKey", "msgName", "MessageName", "messageType", "phraseName", "reasonname", "msgValue", "phraseKey", "msgType", "Messagename", "MessageType", " messageType", "msgKey", "phraseType", "reasonName", "reasonValue", "messagename", "phraseValue", "reasonType"], "messageValue": ["responseType", "MessageValue", "msgName", "MessageName", "MessageVal", "messageType", "msgValue", "msgType", "responseValue", " messageType", "MessageType", "responseVal", " messageVal", "responseName", "messageVal", "msgVal"], "properties": ["params", "pro", "prop", "metadata", "tmp", "xml", "py", "stats", "obj", "resources", "options", "ops", "Pro", "ps", "config", "Property", " props", "property", "api", "perties", "ips", " Properties", "data", "pb", "json", "txt", "conf", "settings"], "i18nPath": ["i18nPart", "i18bStr", "i18nsUrl", "i18nCorp", "i18bPath", "i18fCorp", "i18naPart", "i18fPath", "i18ninFile", "i16nPart", "i18naStr", "i18fpath", "i18bPart", "i11fPath", "i18nLocation", "i18nUrl", "i18nsFile", "i16npath", "i18onPath", "i11nCorp", "i16nStr", "i18onLocation", "i18nsPart", "i18nepath", "i11fUrl", "i18onFile", "i18nspath", "i18naPath", "i32nUrl", "i18ninUrl", "i18nsLocation", "i11nUrl", "i18bpath", "i32ninPath", "i16nsStr", "i18nsPath", "i32ninFile", "i18neUrl", "i18ninLocation", "i32nPath", "i18ninPath", "i32nLocation", "i32ninUrl", "i18onUrl", "i18npath", "i11fCorp", "i18neCorp", "i18nePath", "i32nFile", "i16nsPath", "i16nspath", "i18nStr", "i18nsCorp", "i11fpath", "i18nFile", "i32ninLocation", "i18nsStr", "i16nPath", "i16nsPart", "i18napath", "i11npath", "i18fUrl", "i11nPath"], "englishFile": ["languagefile", "languageFiles", "EnglishPath", "exampleFile", " englishDir", "examplePath", "examplefile", "propertiesPath", "propertiesFolder", "ianaPath", "ianaJar", "languageJar", "EnglishFile", "englishJar", "propertiesfile", " englishJar", "ianaDir", "languageFile", "ianaFile", "exampleFolder", "englishDir", " englishFiles", "EnglishFiles", "englishFolder", "languagePath", "propertiesFile", "EnglishFolder", "languageDir", " englishPath", "Englishfile", "englishFiles", "englishPath", " englishfile", "englishfile"], "propertiesFilePath": ["propertiesSourceFileName", "pertiesfilepath", "propertiesFileName", "propertiesFilesUrl", "pertiesfilePath", "propertiesSourceFilepath", "propertiesFileURL", "pertiesDirUrl", "pertiesfileName", "pertiesFileUrl", "propertiesfilepath", "propertiesFilesURL", "propertiesfileUrl", "pertiesFileName", "propertiesFileUrl", "propertiesDirpath", "propertiesFilesName", "pertiesFilepath", "pertiesFilePath", "propertiesfileURL", "propertiesFilespath", "propertiesDirName", "propertiesfileName", "propertiesSourceFilePath", "propertiesFilesPath", "pertiesFileURL", "pertiesDirName", "propertiesDirUrl", "propertiesDirPath", "pertiesDirpath", "pertiesDirPath", "propertiesfilePath", "propertiesFilepath", "propertiesSourceFileURL", "pertiesfileURL"], "file": ["FILE", "force", "model", "path", "one", "log", "filename", "name", "format", "File", "show", "directory", "message", "p", "data", "letter", "full", "part", "f", "fp", "use", "child", "folder", "function", "string", "word", "lock", "fe", "or", "pe", "class", "b", "object", "buffer", "property", "http", "single", "l", "page", "base", "reader", "php", "zip", "language", "binary", "stream", "files", "entity", "parent", "socket", "media", "resource", "it", "content", "source", "field", "unit", "book", "module", "url", "play", "ile", "connection", "application", "text", "handler", "future", "h", "up", "die", "le"], "in": ["gin", "ins", "reader", "din", "IN", "login", "bin", "io", "inc", "isin", "ini", "input", "er", "ic", "In", "s", "inner", "image", "err", "or", "i", "r", "b", "n", "again", "sin", "nin", "ri", "win", "inn", "p", "pin", "plus", "it", "into", "l", "lin", "cin", "inside", "kin", "init", "d", "rin", "con", "f"], "out": ["net", "exec", "v", "error", "OUT", "outs", "builder", "w", "output", "bin", "ou", "io", "inc", "exp", "one", "string", "s", "end", "inner", "word", "ext", "to", "image", "err", "write", "Out", "plain", "lib", "i", "r", "b", "ex", "n", "again", "o", "co", "sync", "socket", "outer", "p", "by", "cli", "work", "up", "and", "full", "home", "part", "f"], "c": ["v", "bc", "k", "cl", "cf", "lc", "cy", "uc", "dec", "cont", "w", "C", "cur", "x", "pointer", "cr", "ci", "cc", "character", "code", "ct", "ec", "a", "i", "t", "r", "arc", "b", "cu", "n", "ice", "esc", "o", "enc", "dc", "p", "h", "rc", "col", "l", "char", "ch", "sc", "d", "pc", "ac", "con", "abc", "f", "size", "xc", "ce"], "is": ["us", "ais", "ins", "ib", "re", "str", "does", "iso", "are", "has", "id", "isa", "IS", "bis", "Is", "es", "res", "ir", "ui", "s", "stream", "ris", "si", "ios", "iss", "os", "i", "info", "ps", "ri", "isu", "iter", "api", "it", "get", "its", "as", "serv"], "breader": [" cakeER", "breaditer", "brewiter", " cakeler", " Breader", "breaders", " breaders", " cakeer", " cakeers", "feediter", "webiter", "breadamer", "feedamer", " BreadER", "breadler", " breadler", "brewer", "webr", " Breaders", "weber", "feeder", "breadER", " Breadler", "brewamer", "breadr", "feedr", " breadER", "webamer", "brewr"], "line": ["url", "lc", "header", "ip", "error", "base", "status", "phrase", "str", "parse", "el", "lo", "feed", "model", "one", "log", "le", "row", "nl", "lined", "sl", "plugin", "string", "name", "Line", "response", "lines", "word", "section", "end", "li", "no", "link", "write", "next", "character", "code", "look", "LINE", "day", "band", "definition", "text", "body", "rule", "block", "sync", "strip", "message", "key", "lf", "page", "lin", "data", "l", "letter", "style", "inline", "entry", "frame", "pass", "value", "split", "liner", "part", "comment", "side", "item", "cell"], "strBuilder": ["stringbuilder", " strBuilding", "StrBuffer", "stringBuilding", "stringBuild", "stringBuilder", "brbuilder", "brBuild", "StrBuild", "brBlock", "strBuild", "strBuffer", "Strbuilder", " strBuild", "StrBlock", "StrBuilding", " strBlock", "strbuilder", "brBuffer", "brBuilder", "StrBuilder", " strbuilder", "strBlock", "stringBuffer", " strBuffer", "brBuilding", "strBuilding"], "pieces": ["services", "objects", "tops", "groups", "marks", "steps", "seconds", "letters", "places", "flows", "forms", "lists", "values", "sections", "cells", "lines", "styles", "files", "rings", "words", "strings", "circle", "items", "vals", "ops", "tips", "bits", "pots", "pins", "nets", "boxes", "apps", "parts", "blocks", "cards", "bytes", "ips", "pages", "planes", "phones", "piece", "keys", "packs", "cuts", "bones", "split", "names", "features"], "found": ["first", "defined", "result", "required", "updated", "left", "filled", "valid", "not", "old", "got", "created", "based", "val", "fl", "true", "identified", "Found", "made", "given", "err", "missing", "failed", "normal", "all", "lost", "confirmed", "used", "count", "null", "changed", "find", "built", "still", "matched", "fall", " Found", "broken", "loaded", "successfully", "search", "l", "letter", "fixed", "printed", "successful", "full", "f", "sent", "expected", "finding", "temp"]}}
{"id1": "19206412", "id2": "7372311", "code1": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 1, "substitutes": {"md5String": ["md512String", " md5Bytes", "md4string", "md5string", "md512string", "md4String", " md5Str", "md6Bytes", "md6Str", " md512string", "md6String", "md6string", " md5string", "md512Bytes", " md512Str", "md5Bytes", "md512Str", " md512Bytes", "md4Str", " md512String", "md4Bytes", "md5Str"], "str": ["url", "result", "st", "re", "sr", "e", "br", "exp", "dict", "arr", "er", "string", "out", "s", "obj", "hr", "name", "err", "doc", "this", "self", "Str", "strings", "r", "kr", "text", "tr", "STR", "enc", "star", "fr", "bytes", "dr", "stri", "data", "char", "pass", "sp", "txt", "f", "msg"], "md": ["MD", "map", " Md", "mc", "dig", "ms", "metadata", "pm", "bd", "amd", "db", "am", "df", "mo", "um", "mk", "mb", "mt", "cmd", "hd", "sm", "rpm", "code", "mand", "m", "dd", "Cmd", "od", "mg", "mm", "ma", "ad", "pd", "mail", "cd", "wd", "mac", "hm", "mod", "me", "data", "ld", "dh", "d", "mag", "vd", "dm", "sum", "mu", " MD", "mp", "cmp"], "hash": ["address", "url", "header", "sha", "base", "error", "ver", "ash", "cache", "rh", "chip", "bin", "id", "arr", "check", "Hash", "index", "host", "dot", "kh", "range", "memory", "image", "hex", "code", "count", "html", "print", "number", "body", "ha", "tr", "diff", "block", "her", "array", "key", "h", "search", "sh", "filter", "char", "value", "part", "sum", "f"], "hexChars": ["hexCHats", "hexchats", "hexchars", "hexCHacters", "hexKhars", "hashchARS", "hexCHARS", "hashchacters", "hashChash", " hexchashes", "hexCARS", "hexKhash", "hexKhARS", "hexChash", "hexCharashes", "hexCHashes", "hexCHases", "hashCHars", "hexChARS", "hashCHashes", " hexchats", "hexChats", " hexChARS", "hashChashes", "hashchases", "hexCashes", "hexChashes", "hexchashes", "hashChases", "hexCharARS", "hexCash", "hexCharases", "hexchacters", "hexchases", "hashChars", " hexChats", "hashChacters", " hexChashes", "hashChARS", "hashchars", "hashCHARS", "hexCharacters", "hexCHars", "hashCHash", "hexCars", "hexchARS", "hexChases", "hexCharars", "hexCharats", "hexChacters", "hexKhashes", "hexCHash", " hexchars", " hexchARS"], "res": ["Results", "us", "rules", "rex", "result", "cache", "re", "resolution", "reg", "arr", "ress", "Result", "vs", "es", "Res", "out", "string", "s", "vers", "ris", "abs", "ret", "err", "RS", "results", "pers", "bs", "ras", "r", "des", "vals", "rus", "rows", "cs", "ps", "css", "Rs", "RES", "bytes", "rez", "data", "resp", "pres", "req", "rss", "details", "ss", "ros", "cons", "rs", "response", "rev"], "i": ["qi", "v", "k", "base", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "index", "length", "u", "li", "ui", "hi", "multi", "c", "ci", "si", "phi", "code", "ii", "y", "m", "j", "a", "info", "ie", "b", "o", "bi", "diff", "ri", "uri", "p", "it", "gi", "h", "ix", "abi", "in", "oi", "di", "l", "d", "field", "ji", "part", "mu", "f", "pi", "temp"]}}
{"id1": "11341711", "id2": "14785308", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"makeBackup": ["createbackUp", "makeBackdown", "createbackdown", "makePickup", "makebackdown", "makeCleandown", "createBackups", "makebackups", "createBackUp", "makeBackups", "makeCleanUp", "makeBackUp", "makePickdown", "makebackup", "makeCleanups", "makePickups", "createbackup", "makebackUp", "makeCleanup", "makePickUp", "createbackups", "createBackdown", "createBackup"], "dir": ["md", "url", "base", "cache", "dep", "Dir", "zip", "dict", "io", "db", "path", "folder", "log", "ir", "name", "doc", "pkg", "build", "lib", "root", "desc", "directory", "dest", "direction", "DIR", "config", "diff", "done", "source", "wd", "store", "rc", "data", "work", "file", "up", "download", "dist", "d", "init", "director", "group", "Directory", "manager", "run", "module"], "sourcedir": ["asourcedirs", "sourcesir", "ssourcediri", "sourcesdir", "ssourcedir", "sourcedirs", "sodedore", "asortedir", "ssodediri", "sortedirs", "sodediri", "sodeddir", "ssodedIR", "sodedIR", "sourcesIR", "seediri", "sourcediri", "sortedIR", "asortedore", "sourcesore", "sortedore", "ssourceddir", "asortedirs", "asortedIR", "sourceddir", "seedIR", "sourcesiri", "sodedirs", "sodedir", "sourcedore", "sourcesirs", "ssodeddir", "ssourcedIR", "seedir", "asourcedir", "sortedir", "asourcedIR", "asourcedore", "ssodedir", "seeddir", "sourcedIR"], "destinationdir": ["Destinationdir", "dominatorDir", "destinatorDir", "DestinationDir", "destinationsdir", "destinationfolder", "destificationdir", "destinateDIR", "destinateDir", "dominatorDIR", "Destinationdirection", "destinatefile", "dominationDIR", "desturationfolder", "destificationfolder", "Destificationdirection", "destinatordir", "destinationDir", "destinatedir", "Destificationfolder", "dominationDir", "destinationdirection", "dominationfile", "destinatorDIR", "destinationsDir", "Destificationdir", "destinationfile", "Destinationfolder", "desturationDir", "desturationdirection", "dominatorfile", "destinatedirection", "desturationdir", "destificationdirection", "dominatordir", "destificationDir", "destinatorfile", "destinationsDIR", "dominationdir", "destinationsfile", "destinationDIR", "DestificationDir", "destinatefolder"], "destinationDirEnding": ["destinationDirectoryEndening", "destinationPathBeginging", "destinationDirBeginning", "destinationDirSignening", "destinationDirEndging", "destinationDirBegining", "destinationDirEndining", "destinationPathBeginning", "destinationPathBeginING", "destinationDirSigning", "destinationDirEndning", "destinationDirBeginING", "destinationDirPassING", "destinationDirectoryEndining", "destinationDirSignining", "destinationDirLeadining", "destinationDirENDING", "destinationPathEndING", "destinationDirPassing", "destinationDirectorySignING", "destinationDirEndING", "destinationDirBeginining", "destinationDirectoryEnding", "destinationDirBeginening", "destinationDirPassging", "destinationDirENDing", "destinationDirPassning", "destinationDirENDging", "destinationPathEnding", "destinationPathEndging", "destinationPathBegining", "destinationDirLeading", "destinationDirectorySignening", "destinationDirLeadening", "destinationDirectoryEndING", "destinationDirLeadING", "destinationDirectorySignining", "destinationPathEndning", "destinationDirEndening", "destinationDirENDning", "destinationDirectorySigning", "destinationDirSignING", "destinationDirBeginging"], "files": ["rules", "services", "objects", "ins", "classes", "types", "groups", "output", "ids", "flows", "reports", "docs", "xml", "children", "iles", "log", "users", "locks", "index", "parents", "ls", "sections", "lines", " Files", "resources", "results", "projects", "modules", "strings", "uploads", "words", "items", "errors", "models", "rows", "images", "runs", "ps", "boxes", "events", "actions", "fs", "blocks", "books", "links", "its", "Files", "bugs", "ips", "pages", "l", "fields", "thumbnails", "file", "planes", "tests", "data", "keys", "split", "names", "balls", "features"], "checkdir": ["workDIR", "checkDir", "workdraft", "blockdraft", "blockDir", "checkfile", "CheckDIR", "CheckDir", "lockDir", "ckfile", " checklog", "ckdirectory", "checkdraft", "calldir", "ckdir", "Checkdir", "worklog", "lockdir", " checkdirectory", "checkDIR", "searchdraft", "lockFolder", "checkdirectory", "workfile", "searchdirectory", "searchDir", " checkfile", "workFolder", "checklog", " checkDir", "workfolder", " checkd", "workDir", " checkDIR", "blockdir", "ckDir", "ckfolder", "callfolder", "Checkfile", "workdir", "workdirectory", "checkd", "locklog", " checkfolder", "blockdirectory", "checkFolder", "calld", "calldirectory", "searchdir", " checkFolder", "checkfolder", "ckd"], "date": ["md", "de", "mate", "change", " Date", "now", "ime", "e", "sign", "Date", "log", "ge", "start", "name", "state", "time", "month", "contact", "image", "set", "doc", "day", "rate", "m", "zone", "event", "at", "dat", "user", "late", "tag", "config", "update", "dt", "ate", "age", "data", "file", "d", "open", "mu"], "msec": [" minsc", "Msecond", "dsecond", "Msec", "dseconds", "fmsec", "csec", "lsec", "disec", "mnif", "lseconds", "mnSec", " mSec", "mSec", "mnsc", "mseconds", "fmseconds", "mif", " minsec", "lss", "Misec", "msecond", "mnsec", "fmisec", "cseconds", " mif", "msc", " minif", "rsec", "Mseconds", "mss", "css", "rseconds", "misec", "dsec", " minSec", "lsecond", " msc", "rss", "fmsecond", "rsecond", "csecond"], "checkFile": ["checkDir", "CheckDirectory", "checkfile", "ckFiles", "CheckDir", "controlfile", "ckfile", "workFile", "workFiles", " checkFilename", "checkLine", "workfile", " checkfile", " checkDir", "changeFile", "controlLine", "workDir", "CheckFiles", "checkDirectory", "ckFile", "changeFilename", "controlFile", "checkFiles", " checkDirectory", "Checkfile", " checkFiles", "checkFilename", "changefile", " checkLine", "ckDirectory", "CheckFile", "controlFilename", "changeLine"], "i": ["qi", "v", "im", "ip", "ai", "ti", "vi", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "ui", "li", "u", "hi", "multi", "ci", "si", "phi", "ii", "y", "m", "j", "ie", "info", "b", "n", "slice", "ri", "uri", "p", "gi", "key", "fi", "ix", "is", "di", "oi", "field", "ji", "part", "mu", "bi", "pi"], "f": ["fp", "v", "cf", "fun", "w", "e", "feed", "folder", "df", "fl", "fb", "q", "u", "fe", "m", "t", "j", "fx", "r", "info", "b", "n", "o", "F", "fc", "fr", "fs", "p", "fi", "fd", "h", "l", "fn", "file", "d", "sf"], "g": ["ga", "ger", "tg", "gin", "ng", "w", "gm", "gb", "e", "reg", "gc", "gh", "ge", "eg", "q", "s", "u", "og", "sg", "gn", "m", "t", "global", "gd", "go", "rg", "G", "gp", "b", "n", "bg", "r", "ig", "mg", "gar", "p", "gi", "pg", "h", "l", "file", "gg", "d", "group", "gu", "erg", "gs", "msg", "vg"], "destinationFile": ["DestificationDirectory", "destacementFile", "destinatorDir", "DestinationDir", "destinationLocation", "DestinationFile", "destificationLocation", "destacementFilename", "destiningFile", "destinatorLocation", "destationfile", "destinatorFile", "destificationDirectory", "DestinationDirectory", "destinationsDirectory", "destacementfile", "destiningfile", "destacementDir", "destinationDir", "destationDir", "DestificationFile", "DestificationLocation", "destiningFilename", "DestationFilename", "destinationsDir", "destationFile", "DestationDir", "destinatorDirectory", "destinationfile", "destinationsFile", "DestationFile", "destationFilename", "DestinationLocation", "destinationsLocation", "destinationDirectory", "destiningDir", "DestinationFilename", "destificationDir", "destificationFile", "Destationfile", "Destinationfile", "destinationFilename", "DestificationDir"], "sourceFile": ["sourceModule", " sourceDir", "ourceDirectory", "sourceFiles", "inputDir", "srcDir", "srcFile", "ourceFile", "inputFile", " sourceFiles", "srcfile", "ourceDir", "ourceFiles", " sourceDirectory", " sourcefile", "SourceFile", "sourcefile", "inputFiles", "sourceDirectory", "inputDirectory", " sourceModule", "SourceModule", "Sourcefile", "srcModule", "sourceDir", "SourceDir"], "infile": [" indata", "Infile", "inputdata", "outdir", "inputFile", "InFile", " inFile", " instream", "inFile", "outstream", "Instream", "outFile", "difffile", "windir", "winfile", "indir", "outf", "inputf", "outdata", "indata", "diffFile", "winstream", "Inf", "diffstream", "inf", "diffdir", "inputstream", "instream", "inputfile", "winFile"], "outfile": ["Outfunction", "outpage", "outfunction", "intlive", "againstream", " outfunction", "intFile", "inputFile", "outstream", "exfile", "outFile", "outline", "exstream", "inputfunction", "Outlive", "inputline", " outFile", " outline", " outlive", "expage", " outpage", "intfile", " outstream", "outlive", "againpage", "Outstream", "againfile", "intstream", "OutFile", "exFile", "Outline", "Outfile", "againFile", "inputfile"], "c": ["v", "lc", "k", "z", "cl", "cm", "cy", "dec", "uc", "cont", "w", "e", "id", "C", "x", "index", "pointer", "string", "end", "cr", "u", "ci", "character", "code", "m", "t", "ct", "a", "r", "ec", "b", "cu", "n", "ice", "esc", "o", "enc", "p", "h", "rc", "col", "in", "l", "char", "ch", "channel", "d", "pc", "ac", "abc", "comment", "xc"]}}
{"id1": "6009527", "id2": "12783713", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadInstachment", "doFinishloadAttachment", "doFinishLoadInstortion", "doFinishLoadInstment", "doFinishloadAttment", "doFinishloadAttachments", "doFinishLoadInstments", "doFinishloadAttments", "doFinishloadAttortion", "doFinishLoadAttachortion", "doFinishLoadAssment", "doFinishLoadAttment", "doFinishloadAttachortion", "doFinishLoadAssments", "doFinishLoadAttachments", "doFinishLoadAttachachment", "doFinishLoadAssachment", "doFinishLoadAssortion", "doFinishLoadAttortion", "doFinishloadAttachachment", "doFinishLoadAttments"], "attachmentId": ["attentionType", "adociationId", "attlementType", "attentionid", "attentionID", "adachmentId", "adachmentPath", "attimagePath", "ttachmentId", "attachmentid", "ttachmentid", "AttachmentID", "attociationID", "attimageInfo", "attociationPath", "attachmentPath", "attentionPath", "attociationInfo", "adociationPath", "ttociationID", "adociationInfo", "adachmentID", "attentionInfo", "attimageID", "ttachmentID", "Attachmentid", "attlementId", "ttociationid", "attachmentType", "adociationID", "attplementationID", "attentionId", "attachmentID", "AttachmentId", "attachmentInfo", "AttachmentType", "attplementationId", "adachmentInfo", "attplementationid", "attimageId", "attociationid", "attociationId", "attlementID", "ttociationId", "attlementid"], "attachment": ["adment", "attached", "assention", "instachment", "instruction", "attachention", "adached", "attment", "assment", " adaptention", "appachment", "attachruction", " attment", "instment", "assached", "adachment", "appention", "adention", "appruction", "attociation", "attruction", " attociation", "attachachment", " attention", "attachached", "appment", "attention", " adaptociation", " adaptment", "instention", "assachment", "association", " adaptachment"], "attachmentUri": ["attachmentAri", "attachmentAti", "attachmentSuris", "attachmentSuURI", "attachmentURI", "attachmentCuuri", "attachmentSuti", "attmentUuri", "attachmentEri", "attachmentEti", "attachedARI", "attachedUri", "attachmentEuri", "attachedUuri", "attachmentERI", "attmentIURI", "attachmentCuri", "attachmentIri", "attachmentUris", "attmentUris", "attachmentSuRI", "attachmentUti", "attachedAuri", "attachmentUURI", "attmentIri", "attachedURI", "attachmentIris", "attachmentIuri", "attachedUti", "attachmentSuuri", "attmentUURI", "attachedAri", "attachmentARI", "attachmentUuri", "attachmentSuri", "attachmentAuri", "attmentIris", "attmentIuri", "attachmentCuURI", "attachmentCuris", "attmentUri", "attachedAti", "attachmentIURI"], "contentUri": ["contentIuri", "resourceUri", "contentFileuri", "resourceUi", "contentCuri", "contentIri", "contentURi", "contentIi", "contentURI", "contentSuris", "contentCri", "resourceURI", "contentUuri", "contentSuri", "resourceIi", "resourceIri", "contentUdi", "contentSudi", "resourceUris", "contentURuri", " contentSuri", "resourceIRI", "resourceUuri", " contentSuris", "contentUi", "contentUsri", " contentSudi", "contentUsris", " contentSuRI", "contentCRI", " contentURI", "contentUsRI", "contentCi", "contentFileRI", "contentFileri", "contentIris", "contentFileris", "contentIRI", "resourceIuri", "contentCdi", "contentURris", "resourceIris", "contentURri", " contentUdi", "contentUsdi", "contentSuRI", "contentUsuri", "contentUris", " contentUris", "contentCris"], "file": ["ger", "picture", "fp", "url", "base", "FILE", "reader", "cache", "local", "output", "view", "use", "zip", "io", "load", "child", "model", "path", "folder", "log", "input", "filename", "auto", "name", "binary", "able", "stream", "to", "image", "this", "upload", "files", "entity", "via", "File", "connection", "pe", "b", "object", "handler", "socket", "buffer", "uri", "resource", "get", "copy", "content", "single", "line", "data", "source", "up", "letter", "work", "create", "unit", "book", "f", "le"], "in": ["url", "gin", "ins", "din", "reader", "IN", "login", "e", "bin", "id", "io", "inc", "ini", "input", "In", "s", "conn", "inner", "binary", "image", "c", "err", "this", "m", "or", "a", "i", "r", "connection", "b", "again", "o", "pull", "socket", "sync", "nin", "win", "inn", "pin", "copy", "cli", "data", "source", "up", "init", "ac", "con", "as", "f"], "out": ["net", "exec", "base", "OUT", "client", "outs", "IN", "cache", "output", "bin", "view", "io", "inc", "one", "log", "conn", "s", "on", "inner", "In", "ext", "to", "lock", "err", "image", "this", "Out", "writer", "connection", "i", "b", "null", "again", "ex", "o", "socket", "sync", "nin", "outer", "resource", "by", "copy", "line", "data", "page", "up", "source", "cli", "init"], "intent": ["activation", "feature", "ani", "Activity", "activate", "animate", " Intent", "term", "xml", "request", "ents", "context", "language", "contact", "effect", "action", "spirit", "this", "anim", "acc", "entity", "event", "element", "ent", "text", "object", "impact", "category", "enc", "anc", "eng", "concept", "vent", "inst", "advert", "android", "agent", "it", "content", "document", "feat", "entry", "focus", "act", "ant", "init", "ink", "intention", "activity", "ctx", "response"]}}
{"id1": "12782570", "id2": "22977189", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"logging": ["configger", "loging", " loging", "Loguring", "configging", "Logging", "Logger", "configuring", "configing", "loguring", "Loging", " logger", " loguring", "logger"], "wrap": ["wa", "wire", "util", "cache", "w", "now", "parse", "flash", "war", "handle", "use", "force", "zip", "cover", "ws", "div", "core", "binary", "stream", "word", "image", "lock", "builder", "widget", "self", "build", "rap", "bag", "we", "format", "or", "box", "html", "transform", "b", "handler", "pipe", "ow", "nw", "wb", "message", "ad", "api", "p", "wrapper", "get", "h", "wp", "process", "web", "work", "init", "create", "frame", " Wrap", "sw", "wra", " wrapped", "f", "run"], "buffer": ["Buffer", "template", "result", "header", "base", "reader", "cache", "builder", "flash", "bb", "view", "bin", "transfer", "pause", "feed", "nb", "cover", "surface", "shell", "bm", "log", "manager", "fb", "bridge", "binary", "queue", " buf", "layer", " buffers", "writer", "reference", "print", "report", "batch", "b", "bar", "buf", "object", "player", "pad", "loader", "table", "iter", "BU", "message", "wrapper", "copy", "http", "source", "pb", "server", "ref", "frame", "reply", "board", "cb", "buff", "response", "msg"], "encoding": ["coder", "decoding", "encoder", "coding", "enoding", "Encoded", "encaching", "decoder", "ecording", "Encryption", "cording", "encoded", "ecoding", "decoded", "encryption", "Encoder", "enoded", "ecoder", "challoder", "decaching", "challoding", "ecoded", "challoded", "coded", "ecryption", "decryption", "encording", "Encoding", "challaching", "enording", "enaching", "enoder"], "getEncoding": ["getCocol", " getEncression", " getEnasing", " getEnression", "getCompoding", "getencoding", "getCression", "getCasing", "getEnocol", " getEnoder", " getEncocol", "getEnoded", "getEnasing", " getEnocol", " getEncoder", "getEncression", "getCoder", " getEncasing", "getEnoder", " getEncoded", "getCoded", "getEnoding", "getencocol", "getCompression", "getCoding", "getEncocol", "getCompoded", "getCompoder", "getencoder", " getEnoding", "getEnression", "getEncoded", "getEncasing", "getEncoder", " getEnoded", "getencasing"], "headers": ["workers", "objects", "header", "ppers", "params", "ers", "types", "relations", "ints", "groups", "str", "ids", "dict", "host", "s", "values", "lines", "files", "strings", "properties", "vals", "breaks", "options", "head", "body", "caps", "bits", "plugins", "padding", "events", "frames", "parts", "blocks", "wrapper", "links", "h", "http", "fields", "ports", "keys", "details", "names", "heads", "rs", "features", "writers", "ings", "settings"], "is": ["us", "las", "ais", "ins", "ms", "tis", "ois", "isol", "iso", "isa", "was", "are", "has", "aos", "IS", "bis", "ws", "Is", "sis", "es", "oss", "abs", "out", "cms", "ui", "s", "ris", "isl", "ios", "iss", "ses", "os", "nis", "bas", "or", "ori", "i", "js", "ops", "so", "lis", "isi", "fs", "api", "iris", "its", "obs", "in", "http", "ists", "as", "bs", "mis"], "bos": ["shadow", "bott", "mos", "bc", "osi", "mobi", "osa", "tis", "outs", "ois", "ob", "was", "aos", "proxy", "bis", "ws", "opus", "abs", "zos", "cms", "obi", "oks", "oes", "bot", "ios", "obos", "os", "bo", "bas", "ses", " Bos", "org", "bps", "oos", "obo", "beans", "js", "ops", "so", "zo", "bi", "bits", "fits", "lins", "bots", "oses", "pins", "ubs", "los", "fs", "android", "kb", "uds", "obs", "cos", "abi", "bh", "bes", "ubis", "bones", "home", "ros", "ko", "oops", "bs", "mis"], "e": ["oe", "de", "esi", "error", "exc", "ele", "re", "one", "x", "ea", "je", "er", "ee", "err", "c", "E", "fe", "ec", "type", "ie", "i", "a", "pe", "ite", "element", "ce", "ception", "o", "ale", "ae", "p", "ev", "ke", "se", "d", "ne", "die", "ze", "f", "be"]}}
{"id1": "22977189", "id2": "20924119", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"in": ["url", "gin", "ins", "reader", "din", "IN", "re", "login", "bin", "id", "isin", "inc", "ini", "input", "er", "In", "inner", "ln", "image", "err", "c", "this", "read", "i", "r", "g", "b", "n", "again", "socket", "nin", "win", "inn", "min", "plus", "is", "source", "data", "up", "lin", "init", "inside", "cin", "pass", "con", "as", "f"], "out": ["error", "outs", "cache", "window", "app", "inc", "raw", "log", "conn", "name", "off", "plain", "at", "writer", "a", "query", "strip", "flush", "data", "file", "server", "part", "as", "f", "client", "s", "ext", "word", "prefix", "write", "Out", "user", "b", "object", "o", "block", "key", "page", "pool", "password", "comment", "OUT", "w", "call", "io", "obj", "inner", "err", "editor", "again", "parent", "list", "outer", "copy", "temp", "exec", "flow", "output", "bin", "default", "this", "self", "connection", "r", "ex", "n", "sync", "point", "up", "init"], "line": ["url", "cl", "lc", "header", "column", "str", "id", "feed", "log", "row", "sl", "string", "name", "end", "Line", "lines", "word", "lock", "c", "next", "link", "write", "character", "code", "LINE", "i", "pe", "text", "rule", "block", "message", "key", "content", "lf", "page", "lin", "data", "file", "l", "char", "letter", "style", "source", "inline", "entry", "pass", "value", "unit", "comment", "f", "cell"]}}
{"id1": "15241397", "id2": "6403868", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", "handleGET", "didget", " doPut", "didGET", "handlePut", "doGET", "didGet", "handleget", " doget", "didPut", "doget", "doPut", "handleGet"], "request": ["complete", "url", "result", "client", "reader", "received", "QUEST", "xml", "input", "er", "context", "queue", "image", "event", "type", "connection", "method", "report", "info", "application", "user", "object", "query", "message", "uri", "buffer", "resource", "Request", "document", "http", "data", "server", "subject", "req", "instance", "initial", "web"], "response": ["result", "error", "esi", "client", "status", "output", "view", "site", "model", "Response", "function", "host", "session", "out", "generation", "queue", "image", "next", "results", "respond", "writer", "connection", "report", "application", "object", "body", "parent", "message", "resource", "version", "wave", "document", "other", "page", "data", "resp", "server", "pool", "full", "reply", "onse", "json", "collection"], "rewrittenQueryString": ["rewwrittenQueryStr", "rewrittenUrlString", "rewrittenRequestString", "rewrittenPageArray", "rewwrittenRequestString", "rewwrittenQueryString", "rewrittenQuestionText", "rewwrittenQueryArray", "rewrittenQuestionArray", "rewrittenqueryString", "rewwrittenRequestService", "rewrittenQueryStr", "rewwrittenQueryText", "rewwrittenQueryService", "rewrittenqueryService", "rewrittenQueryList", "rewrittenRequestLine", "rewrittenUrlText", "rewrittenRequestText", "rewwrittenQueryList", "rewrittenRequestArray", "rewrittenUrlService", "rewrittenRequestList", "rewrittenQueryLine", "rewrittenQuestionLine", "rewrittenqueryLine", "rewrittenQueryArray", "rewrittenQuestionString", "rewrittenRequestStr", "rewwrittenRequestText", "rewrittenQueryText", "rewrittenqueryText", "rewwrittenRequestArray", "rewrittenPageString", "rewrittenUrlLine", "rewrittenRequestService", "rewrittenQuestionStr", "rewwrittenQueryLine", "rewrittenPageList", "rewrittenqueryStr", "rewwrittenRequestLine", "rewwrittenRequestList", "rewwrittenRequestStr", "rewrittenPageLine", "rewrittenQuestionList", "rewrittenQueryService"], "rewrittenUrl": ["RewrittenJar", "RewwrittenText", "rerittenLanguage", "rewardedURL", "rewardedUr", "rewmatchedURL", "rewrapedURL", "rewwrittenServer", "rewwrittenURL", "rerittenUrl", "rewardedLanguage", "rewmatchedFile", "rewedUr", "rewilledUrl", "rewrapedFile", "RewwrittenServer", "rewilledJar", "rewcraftedLocation", "rewodedUrl", "rewardedFile", "RewrittenURL", "rewatchedUrl", "rewatchedURL", "RewrittenServer", "rewrittenInt", "Rewwrittenurl", "rewodedFile", "rewriteText", "RewwrittenUrl", "rewardedJar", "rewedurl", "rewcraftedURL", "rewcraftedUr", "rewwrittenUr", "rewrittenLocation", "RewrittenFile", "RewwrittenURL", "rewardedInt", "rewmatchedUrl", "rewrittenJar", "RewrittenText", "rerittenFile", "rewrapedUr", "rewrittenServer", "rewatchedServer", "RewwrittenJar", "rewardedLocation", "rewwrittenLanguage", "rewedFile", "RewrittenInt", "rewrittenFile", "rewedURL", "rewwrittenFile", "rewardedUrl", "RewrittenUr", "rewrittenUr", "rewriteServer", "rewatchedText", "rewrittenText", "RewwrittenInt", "rewodedLanguage", "RewwrittenLocation", "rewwrittenJar", "RewrittenUrl", "rewilledInt", "rewmatchedurl", "Rewrittenurl", "rewilledURL", "RewwrittenFile", "rewwrittenurl", "rewriteURL", "rerittenUr", "rewcraftedUrl", "rerittenURL", "RewrittenLocation", "rewwrittenUrl", "rewrittenURL", "rewrittenurl", "rewwrittenLocation", "rewrapedUrl", "rewrittenLanguage", "rewodedURL", "rewwrittenInt", "RewwrittenUr", "rewedUrl", "rewwrittenText", "rewriteUrl"], "httpURLConnection": ["httpSSLConn", " httpURConnect", " httpStreamCurrent", "webURLConnection", "HttpURLConnection", " httpUrlConn", " httpURLConn", "httpURIconnection", "httpWebConnection", "webSSLConnection", "httpURLContext", "httpURLConn", "httpWebConnect", "httpELConn", "httpURLService", " httpURLConnect", " httpURConn", "httpURLconnection", "httpURLClient", "webURLClient", "httpGEconnection", "httpURIConnection", " httpStreamConnection", "httpPathconnection", "httpGEConnect", "httpurlSession", " httpURLSession", "httpWebConn", "httpUrlconnection", "httpCLConn", "httpURLCode", "httpUrlConnection", "httpURConn", "httpELConnection", "httpURIConn", "httpChannelConnection", "apacheURLconnection", "httpURconnection", "httpUrlContext", "HttpURLService", "httpStreamconnection", "httpUrlConnect", "httpurlConnection", "webURLConn", "httpChannelConnect", "httpURLSession", "httpPathSession", "httpURConnection", "httpStreamConnection", "httpELConnect", "apacheGEConnect", " httpURLCurrent", "httpurlCurrent", "httpSSLClient", "webSSLConn", " httpURConnection", " httpStreamconnection", " httpURLconnection", "httpChannelconnection", "HttpURLconnection", "httpURIFlow", "webSSLClient", "httpURIContext", "httpPathCurrent", "apacheGEconnection", "httpStreamCurrent", "httpGEFlow", " httpStreamSession", "httpURLFlow", "httpCLCode", "apacheGEFlow", " httpURLCode", "httpurlConnect", "httpurlFlow", "apacheGEConnection", "webSSLContext", "httpGEConnection", " httpUrlCode", "apacheURLConnect", "HttpChannelConnection", "httpUrlService", "httpurlConn", "httpurlCode", "apacheURLFlow", "httpSSLContext", "httpURLCurrent", "httpUrlConn", "httpurlconnection", "httpURConnect", "httpURIClient", "httpUrlClient", "httpURService", "HttpChannelService", "httpPathConnection", "httpURIConnect", "httpSSLConnection", "webURLContext", " httpUrlConnection", "HttpURLConnect", "httpUrlCode", "httpCLConnection", "HttpChannelConnect", "HttpChannelconnection", "httpStreamSession", "httpChannelService", "httpURLConnect", "apacheURLConnection"], "header": ["hash", "feature", "pair", "result", "item", "master", "error", "column", "token", "ter", "metadata", "after", "cover", "default", "function", "index", "er", "string", "bridge", "driver", "queue", "section", "next", "character", "layer", "event", "component", "writer", "info", "reference", "definition", "player", "head", "rule", "handler", "Header", "back", "list", "block", "headers", "outer", "buffer", "message", "iter", "version", "date", "her", "attribute", "key", "document", "dr", "line", "consumer", "entry", "filter", "server", "channel", "data", "match", "member", "director", "field", "second", "group", "part", "comment", "author"], "value": ["v", "sv", "description", "now", "current", "valid", "child", "Value", "model", "default", "function", "val", "label", "string", "name", "values", "end", "language", "set", "expression", "format", "type", "VALUE", "info", "element", "object", "text", "parent", "hello", "message", "office", "media", "version", "option", "property", "attribute", "key", "content", "V", "gi", "get", "document", "entry", "data", "server", "letter", "password", "variable", "field", "json", "comment", "item"], "inputStream": ["pullStreamer", "pullSteam", "inputSteam", "outputStreamer", "pullStream", "resourcestream", "InputChannel", "resourceSteam", "outputChannel", "resourceStream", "resourceChannel", "outputSteam", "InputStreamer", "Inputstream", "outputstream", "InputSteam", "inputstream", "inputChannel", "inputStreamer", "pullstream", "InputStream"], "outputStream": ["OutputFile", " outputSteam", "inputSteam", "outputStreamer", "OutputChannel", "OutputSteam", "externalStream", "outputChannel", "OutputStream", "externalstream", "externalSteam", "responseSteam", "outputSteam", "OutputStreamer", "responseStream", "outputstream", "responseChannel", "externalStreamer", "Outputstream", "responseFile", " outputChannel", " outputFile", "inputstream", "inputStreamer", "outputFile"]}}
{"id1": "22046596", "id2": "471804", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"copy": ["exec", " copying", "transfer", "zip", "io", "Copy", "put", " copied", "Transfer", "cp", "to", "write", "upload", " cp", "all", "sync", "clip", "p", "get", " transfer", " copies", "file", "download", " dup", " Copy", "paste"], "s": ["v", "less", "services", "sv", "ins", "outs", "w", "xs", "e", "south", "ts", "x", "es", "sl", "input", "ns", "ls", "u", "c", "si", "files", "os", "ses", "storage", "m", "ssl", "sb", "a", "i", "g", "b", "sin", "o", "ps", "S", "ds", "fs", "p", "is", "l", "source", "sh", "se", "src", "ss", "as", "sf", "f", "gs"], "t": ["template", "v", "z", "tp", "e", "ot", "ts", "tf", "x", "T", "pt", "target", "tc", "to", "c", "down", "y", "m", "at", "i", "r", "ty", "b", "g", "n", " T", "object", "o", "tr", "p", "it", "l", "tty", "file", "ta", "tor", "f", "temp"], "in": ["url", "ins", "din", "reader", "IN", "login", "bin", "e", "id", "io", "inc", "input", "In", "conn", "inner", "c", "m", "ssl", "i", "r", "g", "b", "n", "again", "sin", "pull", "socket", "sync", "nin", "win", "inn", "p", "min", "pin", "h", "is", "l", "source", "file", "up", "init", "d", "rin", "as", "f"], "out": ["net", "v", "OUT", "client", "outs", "w", "call", "output", "bin", "io", "inc", "not", "x", "conn", "ext", "obj", "image", "c", "err", "off", "Out", "plain", "at", "writer", "connection", "g", "b", "ex", "n", "again", "parent", "o", "user", "null", "sync", "p", "l", "channel", "file", "d", "f", "temp"]}}
{"id1": "14820302", "id2": "22411381", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"innerProcess": [" innerWrite", "subprocess", "binaryConnect", "innerprocess", "binaryWrite", "binaryprocess", " innerConnect", "subProcess", "innerWrite", "subConnect", "binaryProcess", " innerprocess", "innerConnect", "subWrite"], "curi": ["furi", "lcURI", "cri", "lURI", " cURI", "lcunit", "cgui", "Cui", "CURI", "lcuri", "pri", "fri", "firi", "Curi", "fui", " cui", " cgui", "luri", "Cunit", "lcui", "capi", "Cgui", "Cri", "cURI", "pURI", "Capi", " cri", "lri", "lcri", "cui", "Curl", " capi", "Ciri", "lcgui", "papi", "curl", " cunit", " curl", "ciri", "cunit", "lciri", "fURI", "lurl", "puri"], "regexpr": ["pregexer", "renexpr", "pregexpl", "reggexr", "Regexpre", "reggexper", "Renexpre", "renexper", "reggexpl", "recer", "relexPR", "recrepl", "recreer", "reggexpr", "relexpre", "regnexpr", "regexer", "pregexpr", "rerer", "rerepl", "rereper", "RenexPR", "regexPR", "Regexpr", "regnexr", "renexer", "prenexer", "recrepr", "prenexpl", "recrepre", "Renexp", "renexpl", "pregexp", "recrep", "renexr", "regexp", "recrePR", "renexPR", "reruer", "renexp", "Renexpr", "regexr", "prenexp", "receper", "relexpr", "rerupl", "rerupr", "regexpl", "regnexper", "relexp", "regexpre", "renexpre", "regexper", "recepr", "regnexpl", "Regexp", "RegexPR", "prenexpr", "rerepr", "recepl", "rerup"], "cs": ["Cs", "bc", "lc", "cm", "cf", "ins", "ms", "ca", "cache", "cers", "CS", "cb", "rs", "vs", "tc", "es", "ns", "ks", "conn", "cms", "cr", "ls", "cells", "cing", "cp", "cks", "c", "cc", "ci", "spec", "ios", "os", "ec", "acts", "codes", "cer", "acs", "acks", "js", "ps", "ars", "sync", "ced", "cus", "css", "ces", "ds", "ics", "fs", "cas", "wcs", "rc", "cos", "sc", "cn", "ches", "qs", "icks", "coll", "pc", "ac", "cases", "details", "ss", "bs", "cons", "ctx", "ce", "gs"], "digest": [" digested", "bigEST", " digity", "digit", "hashest", "signEST", "igity", "signest", "Digity", "bigest", " digests", "hashcher", "digcher", "logester", "Digger", " digcher", "digEST", "igest", "signger", "diggest", "biggest", " digester", "digester", " diggest", "Digcher", " digEST", "digests", "igester", "logger", "signests", "signgest", " digit", "digity", "hashger", "digested", "Diger", "Digester", "logit", "hashester", "signester", "diger", "igested", "Digest", " diger", "signer", "digger", "Digested", "logest", "Digit", "bigests", " digger", "signested"], "s": ["su", "v", "address", "services", "ms", "groups", "str", "e", "sets", "rs", "ws", "sl", "ns", "abs", "string", "u", "ls", "binary", "c", "states", "si", "ses", "os", "strings", "t", "sum", "sb", "r", "g", "b", "js", "n", "o", "ans", "ps", "sym", "S", "sync", "ds", "p", "bytes", "h", "obs", "is", "l", "data", "ss", "bs", "f", "gs", "settings"], "m": ["map", "cm", "v", "mc", "imm", "ms", "mr", "gm", "e", "rm", "pm", "am", "bm", "mo", "machine", "string", "fm", "man", "M", "c", "sm", "mi", "ym", "om", "r", "mm", "tm", "p", "hm", "wm", "me", "match", "vm", "nm", "dm"], "newDigestValue": ["newDigesterKey", "newDigestValues", "newDigestedValues", "newSignestValue", "newDigestVal", "newDigESTKey", "newDigestKey", "newSignestedValues", "newDigeterString", "newSignestValues", "newSignestedValue", "newSignestString", "newDigestedKey", "newSignestKey", "newSignestedString", "newDigESTValue", "newDigeterValue", "newDigestedValue", "newDigESTValues", "newDigesterVal", "newSignestedKey", "newDigestedVal", "newDigeterKey", "newDigesterString", "newDigeterVal", "newDigesterValues", "newDigesterValue", "newDigestedString", "newDigESTString", "newDigestString"]}}
{"id1": "2668634", "id2": "10795866", "code1": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"inputName": [" inputFile", "imagename", "inputFile", " inputname", "InputPath", "inputAddress", "imageFile", " inputPath", "outputUrl", "inputname", "InputFile", "InputUrl", "InputName", "inputPath", " inputUrl", " inputAddress", "imageName", "imageAddress", "Inputname", "inputUrl", "InputAddress", "outputFile", "outputPath"], "outputName": [" outputname", "OutputFile", " outputDir", "outputDir", "OutputPath", "inputDir", "inputFile", "applicationPath", "applicationFile", "OutputDir", "outputname", "inputPath", "applicationname", "OutputName", "applicationDir", "Outputname", " outputFile", "applicationName", "outputFile", "outputPath"], "stripLoggers": [" striplogger", "striplogging", "stripDebugger", " striplogging", "stripLogging", "stripDebugters", "stripColger", "stripColgers", "stripColters", "stripLogters", "striploggers", " stripLogging", " stripLogger", "striplogters", "stripColging", " striploggers", "stripLogger", " stripLogters", "stripDebuggers", "striplogger", " striplogters", "stripDebugging"], "tempFile": ["poraryFiles", "poraryfile", "TempFiles", "tempMessage", " tempStream", "inputDir", "tmpDir", "TempMessage", "inputFile", " tempDir", "TempFile", " temporaryfile", "inputPage", "TempDir", "tempDir", "tempPage", "tmpFile", " temporaryFile", " temporaryStream", " tempMessage", " tempFiles", "tmpPage", "poraryMessage", "Tempfile", " tempPage", "poraryFile", "tempStream", "tempFiles", "tempfile", "tmpfile", "tmpFiles", " tempfile", " temporaryFiles", "TempStream", "inputfile"], "jin": ["su", "jp", "sit", "Mu", "gin", "thin", "din", "ja", "icer", "util", "hn", "bin", "jun", "fil", "zip", "zin", "Skin", "skin", "vin", "spin", "ini", "plugin", "Ru", "Intern", "hin", "john", "ln", "zon", "jing", "raf", "jan", "lib", "lu", "zn", " Jin", "nu", "sin", "jack", "pillar", "tin", "Kit", "NI", "nin", "nir", "Js", "Mos", "jen", "irin", "pin", "inx", "arin", "cli", "in", "lin", "cin", "jl", "cos", "kin", "ni", "rin", "NJ", "rio", "zik", "unin", "fen"], "jout": [" jouter", " jOut", "Jout", "JOut", "narray", "jetOut", "nOUT", " jarray", "nout", "ujouter", "jetarray", "jOUT", "ujOut", "Jouter", "ujout", "nOut", "jOut", "jetout", "jouter", " jOUT", "jetOUT", "jarray"], "srcChannel": ["sourceCh", "sourceChan", "srcChan", " srcCh", "rcCh", "rcchannel", "srcchannel", "sourceChannel", "sourcechannel", " srcChan", " srcchannel", "rcChannel", "srcCh", "rcChan"], "dstChannel": [" dstCh", "dndChan", " dstChan", "ddestChannel", "ddestCh", "dspCh", "dstCh", "dndchannel", " ddestCh", "dndChannel", "ddestchannel", "dstchannel", " ddestChan", "ddestChan", " ddestChannel", "dspChannel", " ddestchannel", "dspchannel", "dspChan", "dstChan", "dndCh", " dstchannel"], "portletApplicationName": ["portletApplicationsInfo", "portletAppPath", "portalPlatformPath", "portalApplicationType", "portletAppType", "portletPlatformCode", "portletAppUrl", "portletsApplicationPath", "portletapplicationUrl", "portletsApplicationInfo", "portletPlatformName", "portletApplicationCode", "portletApplicationsPath", "portalPlatformName", "portletAppName", "portletPlatformUrl", "portletsAppPath", "portalApplicationUrl", "portletApplicationsName", "portletapplicationName", "portletsApplicationCode", "portalPlatformUrl", "portletAppCode", "portletApplicationsCode", "portletapplicationType", "portletPlatformPath", "portletPlatformType", "portletApplicationUrl", "portletAppInfo", "portletApplicationPath", "portalApplicationName", "portalPlatformType", "portletapplicationPath", "portletPlatformInfo", "portletApplicationType", "portletsAppInfo", "portletsAppCode", "portletApplicationInfo", "portletsAppName", "portletsApplicationName", "portalApplicationPath"], "webXml": ["webHiel", "webxml", "webWorkaml", " webXaml", "webXxml", "webEcpl", "webHml", " webXxml", "webCrossul", "webXli", "webXaml", "webxML", "contextXML", "webCrossml", "contextCrossML", "webxlass", "contextClass", "webWorkML", "webXMxml", "webXlass", "webEciel", "webXiel", "webClass", "webHML", " webXMxml", "webWorkxml", "webXMML", "contextCML", "contextCml", "contextCxml", " webXMml", "webXML", "webEcML", "webWorkli", "webxxml", "webXMaml", "contextXlass", "contextCrossml", "contextXul", "webCrossli", "webCxml", " webXMaml", "webXpl", "webHpl", "WebXML", "webXMml", "contextCrossul", "webEcml", "webXul", "WebXMml", "webXMpl", " webXMML", "contextXxml", " webXML", "WebXMpl", "WebXml", "contextXli", "WebXpl", "contextCrossli", "WebXMiel", "webCML", "webxaml", "webCml", "webCrossML", "WebXMML", "WebXiel", "webWorkul", "webXMiel", "webWorkml"], "portletXml": ["portletSyaml", "portletCML", "portletsYng", "portletXmal", "portfileHmos", "portletYmal", "portletsXML", "portletEML", "portletXMml", "portletxml", "portleXxml", "portletXaml", "portletSyml", "portleSyml", "portletYml", "portletEmal", "portletsYmal", "portfileHxml", "portletSyncml", "portleSyxml", "portletXMtml", "portletXng", "portletHxml", "portletXMML", "portletYng", "portletXMng", "portletHmos", "portletxML", "portletCmos", "portletSyncxml", "portfileXml", "portfileXML", "portleSytml", "portletsXml", "portletEml", "portletSytml", "portleXaml", "portletXMaml", "portfileXmos", "portletXmos", "portfileHML", "portletXxml", "portletXMxml", "portletsXng", "portletYML", "portletxxml", "portleXml", "portletsYml", "portletHml", "portletSyxml", "portletXMmal", "portletEng", "portfileHml", "portletXML", "portletHML", "portletCxml", "portfileXxml", "portletSyncaml", "portleSyaml", "portletsYML", "portletXtml", "portleXtml", "portletxmos", "portletSynctml", "portletCml", "portletsXmal"], "contextXml": ["contextUla", " contextXML", "contextHwl", "contextAxML", "conceptHwl", " contextXl", " contextAxl", "contextXl", "contextHml", "conceptHxml", "contextHxml", "contextXMaml", "contextXMxml", "contextXMwl", "contextExml", "contextxxml", "contextUl", "contextAxla", "contextExla", "contextXla", " contextAxla", "contextExML", "contextxwl", "conceptHml", " contextAxml", "contextUml", "conceptXwl", "contextXMml", "contextXML", "contextHaml", "conceptXxml", "contextxaml", "conceptXml", "conceptHaml", "contextXaml", "contextXwl", "contextAxl", "conceptXaml", " contextXla", "contextxml", "contextXxml", " contextAxML", "contextExl", "contextAxml", "contextUML"], "src": ["ource", "ser", "prot", "url", "sit", "result", "lit", "rest", "img", "st", "cont", "uc", "sup", "rel", "sr", "gb", "zip", "jar", "sub", "cur", "sl", "host", "secure", "obj", "s", "Source", "spec", "lower", "ruby", "comp", "ses", "sel", "username", "ssl", "ie", "i", "r", "sb", "sq", "sin", "dest", "rec", "config", "loc", "socket", "slice", "sync", "inst", "ri", "ur", "sn", "uri", "resource", "rb", "http", "rc", "in", "href", "entry", "sc", "bh", "dist", "gz", "req", "rin", "rss", "rl", "ctx", "rs", "SOURCE"], "source": ["ource", "fp", "url", "sit", "result", "thin", "reader", "client", "token", "gen", "sr", "scope", "status", "view", "e", "use", "zip", "proxy", "xml", "function", "sl", "input", "session", "start", "out", "string", "core", "secure", "stream", "inner", "driver", "context", "Source", "resources", "spec", "this", "comp", "storage", "reason", "component", "ie", "i", "connection", "null", "text", "parent", "sin", "handler", "slice", "ources", "loader", "uri", "service", "resource", "iter", "wrapper", "get", "from", "in", "form", "stack", "rc", "file", "channel", "kin", "sp", "unit", "size", "ce", "SOURCE"], "zipEntries": ["zipentries", "zipEnrations", "zipCurions", "zipEntions", "zipEndry", " zipEntrations", "ZipEntrys", "zipentrys", "zipEndlines", "sliceEntries", "zipIntegrations", "zipentions", "sliceEntresses", "sliceElines", "sliceEries", "zipIntegry", "zipEntrations", "zipEnrys", " zipEntrys", "zipCurries", " zipEntry", "sliceEresses", "zipCurlements", "zipElines", "zipEntry", "zipEries", "zipEnresses", "zipEnlines", "zipEresses", "zipEndresses", "zipEntrys", "zipCurrys", "zipIntegries", "sliceEntlines", "zipIntegrys", "ZipEntlements", "zipentlements", "zipEnries", "ZipEntries", "zipEntlements", "zipEntresses", "zipEndries", "sliceEry", "ZipEntions", "zipEntlines", "zipEnry", "zipEry", "sliceEntry"], "target": ["external", "template", "address", "arget", "project", "rel", "scope", "output", "site", "platform", "current", "wrong", "path", "goal", "remote", "filename", "host", "context", "name", "location", "top", "string", "hop", "flat", "tail", "prefix", "next", "format", "Target", "type", "component", "method", "class", "route", "object", "tag", "dest", "config", "loc", "nt", "resource", "it", "content", "feat", "href", "data", "file", "bh", "style", "match", "compatible", "value", "theme", "unit"], "webRewriter": [" webRewitcher", "webRewitcher", "New", " webrewriter", "webrewrite", "webReprite", " webrewitcher", "webReporter", "app", " webrewrite", "webResitcher", "webRepitcher", "_", "webreworter", "s", "webrewriter", "webrewitcher", "webResorter", "this", "webReworter", "application", "Entry", "webRewrite", "webResriter", " webRewrite", "http", "webRepriter", " webreworter", " webReworter", "webResrite"]}}
{"id1": "17158020", "id2": "8788371", "code1": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encryptpassword", "decryptpassword", "decryptPass", "decryptString", "encressPassword", "encipherPassword", "encipherString", "encresspassword", "decipherPass", "encressString", "encipherPass", "encipherpassword", "encryptString", "decipherpassword", "encressPass", "decipherPassword", "decipherString", "decryptPassword", "encryptPass"], "passwordString": ["PasswordString", " passwordBytes", "passText", " passwordPassword", "PasswordText", "passwordText", "PasswordBytes", " passwordText", "PasswordStr", "passPassword", "passwordStr", "passwordBytes", " passwordStr", "passBytes", "PasswordPassword", "passString", "passwordPassword", "passStr"], "digest": [" digested", "mainit", "Digse", "digit", "signEST", "generer", "signest", "heder", "mainest", " digse", "compested", "hedester", "compest", "signse", "digEST", "mainested", "diggest", " digester", "Diggest", "digester", " diggest", " digEST", " digHash", "mainHash", "digse", " digit", "DigEST", "digested", "Diger", "Digester", "digHash", "signester", "diger", "Digest", " diger", "signer", "compHash", "Digested", "genergest", "compit", "hedest", "hedested", "generester", "generest"], "raw": ["dec", "wrap", "unsigned", "clean", "ng", "local", "RAW", "feed", "load", "none", "row", "input", "out", "aws", "binary", "rew", "original", "image", "missing", "hex", "serial", "pure", "Raw", "null", "unknown", "empty", "enc", "block", "buffer", "array", "alpha", "wrapper", "channel", "secret", "shared", "instance", "random", "full", "initial", "temp"], "hash": ["url", "header", "sha", "base", "ash", "cache", "rh", "id", "Hash", "utf", "index", "row", "input", "response", "kh", "image", "hex", "ashes", "ruby", "auth", "html", "hed", "block", "her", "message", "array", "version", "key", "mac", "h", "sh", "data", "secret", "pass", "sum", "ha", "dig"]}}
{"id1": "6341264", "id2": "9347451", "code1": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 0, "substitutes": {"getJarEntry": ["getZipEntry", "getZipInfo", "getFolderInfo", "getZipentry", "getFolderSource", "GetJarFile", "getFolderEntry", "loadZipentry", "getjarEnt", "GetJarSource", "getZipEnt", "loadZipFile", "getJarEnt", "GetZipEntry", "GetZipInfo", "loadJarEntry", "getEntryEntry", "loadJarEnt", "GetJarInfo", "loadZipEntry", "getEntryFile", "GetZipFile", "getJarFile", "loadJarentry", "getEntryEnt", "GetZipSource", "getFolderFile", "getjarEntry", "getjarentry", "getJarInfo", "getEntryentry", "getJarentry", "getZipFile", "getZipSource", "getJarSource", "getjarFile", "GetJarEntry", "loadZipEnt", "loadJarFile"], "jarName": ["jarId", "browserId", "browserUrl", "jarPath", " jarID", "jarID", "javaAlias", "javaId", "browserName", " jarPath", "javaUrl", "browserAlias", "javaName", "jarAlias", " jarUrl", "javaPath", " jarId", "jarUrl", "JarPath", " jarAlias", "JarID", "JarName", "javaID", "JarAlias"], "entry": ["address", "description", "enter", "str", "id", "zip", "feed", "jar", "ticket", "path", "plugin", "host", "filename", "start", "string", "name", "offset", "archive", "image", "type", "ie", "connection", "element", "route", "Entry", "query", "uri", "service", "resource", "key", "data", "file", "server", "source", "ry", "secret", "ident"], "port": ["address", "position", "ip", "PORT", "project", "Port", "path", "ort", "host", "patch", "length", "name", "string", "offset", "time", "target", "type", "count", "pid", "direction", "uri", "timeout", "service", "version", "delay", "key", "point", "ports", "file", "server", "password", "pos", "limit"], "b": ["v", "base", "xb", "ib", "bb", "ob", "e", "beta", "br", "nb", "bd", "emb", "bp", "db", "boot", "fb", "mb", "binary", "s", "c", "orb", "buff", "a", "i", "r", "erb", "sb", "bar", "library", "lb", "buf", "abb", "wb", "buffer", "ab", "eb", "p", "bytes", "reb", "l", "pb", "zb", "B", "d", "bf", "obb", "bs", "cb", "f"], "codebase": ["coreBase", " codeb", "workb", "CodeBase", " codeBase", "workBase", "broadBase", "queb", "Codebase", "quebas", "workbase", "codebas", "queBase", " codebas", "broadb", "corebar", "quebase", "workfull", "codeb", " codefull", "codefull", "codeBase", "Codebas", "Codebar", "Codeb", "broadfull", " codebar", "corebase", "corebas", "codebar", "broadbase"], "protocol": ["protology", "predology", "proocol", "propport", "prourl", "Protost", "ocolurl", "proport", "Protore", "ocolocol", "proology", "verbost", "ocolore", "Protology", "propocol", "Proturl", "ocolology", "protost", "predocol", "predore", "verburl", "verbocol", "protport", " proturl", "propology", "protore", " protology", "Protocol", "Protport", "proturl", "predurl", " protost", "propurl", "verbology"], "x": ["xes", "v", "z", "xf", "xxx", "w", "lex", "xs", "id", "exp", "xp", "X", "xi", "check", "tx", "ctx", "cross", "index", "val", "es", "max", "wx", "ww", "xx", "xa", "dx", "ax", "y", "m", "en", "xxxxxxxx", "xt", "fx", "pe", "rx", "ex", "xxxx", "p", "ix", "h", "work", "xd", "pos", "d", "xc", "f"], "s2": ["satter", "qs2", "patter", "ssecond", " s62", "qs1", "stwo", "o2", "vatter", "stringtwo", "xls", "p1", "vtwo", "string1", "xii", "p2", "s1", "stringatter", "e1", "string2", "o62", " s1", "v1", "osecond", "sii", "e62", "sls", "qsls", "esecond", "e2", "v2", " ssecond", "ptwo", " sls", "qsii", "x1", "o1", "s62", " sii"], "x2": ["X1", "tx2", " x52", " x0", " x1", "x6", "index1", "XSecond", "tx52", "index2", " xSecond", "index0", "ix6", "index6", "xSecond", "txSecond", "X52", "tx1", "ix0", "ix2", "x52", "x0", " x6", "X2", "ix1", "x1"], "downloadHost": ["writePort", " downloadhost", "writeHost", "DownloadAddress", " downloadPath", "downloadDomain", "transferPath", "urlPort", " downloadAddress", "downloadhost", "transferPort", "DownloadHost", "updateRoot", " downloadPort", "urlHost", "updateAddress", "downloadAddress", "updateHost", "urlDomain", "writehost", "downloadPath", "transferhost", "transferRoot", "transferHost", "writeDomain", "Downloadhost", " downloadRoot", "transferAddress", "downloadRoot", "downloadPort", " downloadDomain", "DownloadPath", "updatehost", "urlhost"], "url": ["base", "util", "rel", "bb", "ob", "el", "zip", "ball", "URL", "jar", "log", "sl", "fl", "Url", "ls", "li", "contact", "gl", "obj", "image", "orb", "link", "lock", "build", "org", "j", "ssl", "connection", "user", "ll", "www", "loc", "ur", "ul", "uri", "service", "resource", "http", "l", "source", "file", "server", "control", "coll", "web", "rl", "f", "il"], "jurl": ["jetURL", "Jjob", "jeturl", "JURL", "Jurl", "gurl", "jpURL", "jjurl", "nurl", " jjob", "jjfile", " jcoll", "ajURL", "ajurl", "Jfile", "Juri", " jfile", "ajfile", "jhttp", " jhttp", "nURL", "jUrl", "nconnection", "jeturi", "jconnection", "jjURL", "jpjob", "jphttp", "juri", "jjob", "Jcoll", "Jconnection", "jetfile", "gUrl", "gconnection", "Jhttp", "jpurl", " jURL", "jfile", "nUrl", "gURL", "jjcoll", "ajuri", "jcoll", "JUrl", "jURL"], "je": ["su", "oe", "jp", "esi", "ja", "Obj", " ze", "pse", "e", "zip", "jar", "py", "kee", "ju", "Je", "li", "obj", "ee", "si", "j", "ie", "java", "js", "fr", "opy", "la", "jen", "jo", "elt", "oi", "jl", "se", "ni", "ne", "ji", "ze", "jj"], "is": ["address", "ais", "ai", "ib", "ois", "bb", "ob", "iso", "isa", "are", "isin", "zip", "jar", "IS", "vs", "Is", "es", "oss", "ir", "ui", "s", "ris", "li", "state", "obj", "isl", "si", "ios", "iss", "os", "ses", "nis", "ii", "self", "ie", "i", "ori", "info", "js", "so", "sin", "lis", "il", "isi", "ri", "uri", "api", "iris", "its", "http", "in", "cos", "src", "as", "bs", "mis"], "bis": ["serv", "base", "oris", "ois", "bb", "ob", "bin", "zip", "isin", "proxy", "IS", "Is", "boot", "fb", "oss", "abs", "ls", "binary", "ris", "obj", "inner", "s", "lock", "iss", "ios", "ses", "bps", "nis", "os", "bos", "afi", "i", "ori", "sb", "bus", "connection", "ignore", "sin", "lis", "slice", "bits", "ri", "uri", "uds", "iris", "abi", "di", "cos", "obs", "http", "usb", "download", "bes", "ubis", "obb", "bs", "cb", "bi", "mis", "pi"], "size": ["cm", "address", "cl", "send", "grade", "now", "use", "sec", "term", "cel", "Size", "iz", "name", "cr", "core", "length", "range", "time", "len", "hh", "ci", "si", "large", "err", "rate", "small", "en", "mode", "esc", "shape", "body", "SIZE", "sized", "enc", "co", "loc", "sync", "eng", "speed", "sn", "ize", "close", "scale", "form", "content", "rc", "act", "se", "init", "width", "capacity", "area", "unit", "sum"], "rb": ["RB", "vr", "ra", "xb", "rh", "sr", "bb", "gb", "ob", "nb", "io", "rr", "rf", "nr", "fb", "cr", "range", "orb", "ruby", "rt", "sb", "r", "lb", "rg", "rab", "buf", "rub", "rx", "abb", "loc", "wb", "ri", "ru", "rob", "lr", "eb", "reb", "rc", "pb", "adr", "zb", "src", "bf", " rc", "rar", "area", "obb", "erb", "rl", "cb", "rd"], "chunk": ["chack", "punk", "chunks", " chack", "choy", "chink", "cloy", "bunk", "qurow", "CHunc", "cheunk", " Chunks", " Chack", "bone", "quunk", "schunk", "punky", "CHunk", "quunky", "shink", "clink", "chunky", "CHunks", "clunk", "clone", "cheink", "Chunk", "Chunks", "quask", "clunc", "chrow", "schunky", "cheunc", "chask", "boy", "chone", " chunks", "CHink", "schrow", "Chack", "chunc", "shoy", "shone", "cheunks", "pask", "shunk", "schask", "clunks", " Chunk", "bink", "prow"]}}
{"id1": "6906419", "id2": "3187685", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encryptpassword", "decryptpassword", "encrateHash", "decryptString", "encipherPassword", "decipherHash", "encipherString", "enccryptString", "enccryptpassword", "encratepassword", "encratePassword", "decryptHash", "encryptHash", "enccryptPassword", "encipherpassword", "encipherHash", "encryptString", "decipherpassword", "enccryptHash", "encrateString", "decipherPassword", "decipherString", "decryptPassword"], "password": ["address", "token", "Password", "project", "sword", "path", "input", "pattern", "string", "name", "seed", "word", "prefix", "database", "auth", "words", "username", "crypt", "confirmed", "user", "text", "padding", "buffer", "message", "array", "p", "wd", "key", "content", " passwords", "phrase", "data", "PASS", "secret", "pass"], "digest": [" digested", "diffester", "initText", " digText", "hashest", "signEST", "signest", "initest", "digeter", "digText", " digests", "digEST", " digester", "digester", " digEST", "digests", "DigText", "Digests", "diffEST", "diffest", "diffested", "hasher", "DigEST", "digested", "initests", "Diger", "Digester", "hasheter", "hashester", "signester", " digeter", "diger", "Digest", " diger", "signer", "Digested", "initEST", "Digeter"], "hash": ["map", "address", "url", "header", "sha", "error", "ash", "cache", "handle", "bin", "id", "cover", "check", "Hash", "log", "mask", "index", "kh", "bug", "memory", "image", "hex", "ashes", "build", "code", "auth", "batch", "html", "count", "history", "number", "body", "hed", "query", "diff", "block", "buffer", "array", "message", "version", "wave", "key", "h", "search", "sh", "filter", "char", "match", "bh", "secret", "value", "f", "sum", "ha"], "buf": ["Buffer", "uf", "fp", "bc", "v", "cap", "url", "vec", "img", "uc", "vr", "builder", "bb", "aux", "ob", "bin", "tmp", "port", "cv", "nb", "func", "db", "cur", "ctx", "fb", "ba", "out", "conv", "queue", "pkg", "uv", "bag", "buff", "sb", "box", "Buff", "uber", "b", "abb", "config", "pad", "wb", "buffer", "ab", "la", "rb", "cas", "af", "data", "pb", "append", "bh", "va", "fw", "coll", "bf", "src", "abc", "runner", "home", "cb", "f", "bu", "cmp"], "i": ["qi", "v", "ip", "ai", "ti", "mini", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "length", "li", "u", "ui", "hi", "multi", "ci", "c", "uni", "si", "phi", "ii", "j", "type", "a", "count", "info", "ie", "b", "n", "o", "slice", "ri", "uri", "p", "key", "gi", "h", "ix", "abi", "fi", "l", "oi", "di", "it", "init", "d", "ji", "mu", "f", "pi"], "halfbyte": ["superbit", "halfurl", "thirdsecond", "thirdnumber", "postbit", "quarterurl", "littlebit", " halfbit", " halfreference", "quarterByte", "Halfbit", "littleByte", "littlereference", "thirdbyte", "superchar", "wardurl", " halfnumber", " halfchar", "superbyte", "quarterbyte", "postbyte", "halfnumber", "halfsecond", " halfByte", "quarterbytes", "sideByte", "quartersecond", "sidebyte", "HalfByte", "Halfbyte", "halfbytes", "quarternumber", "wardbyte", " halfurl", "Halfchar", "halfByte", "sidereference", "halfabyte", "sidebit", "postabyte", " halfsecond", "halfbit", "quarterbit", "littlebyte", " halfabyte", "wardbytes", "halfreference", "quarterabyte", " halfbytes", "halfchar"], "two_halfs": ["two_commonrows", "two_halfions", "two_quarterows", "two_hatows", "two_Halfrows", "two_Halfs", "two_thirdbytes", "two_quarters", "two_quarterrows", "two_halfbytes", "two_halfows", "two_halfis", "two_hatrows", "two_parts", "two_commons", "two_partrows", "two_thirdrows", "two_commonions", "two_commonows", "two_hats", "two_partbytes", "two_halfrows", "two_Halfbytes", "two_thirdis", "two_hations", "two_quarterions", "two_thirds", "two_Halfis", "two_partis"]}}
{"id1": "3683344", "id2": "12106167", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    public static void init(Locale lng) {\n        try {\n            Locale toLoad = lng != null ? lng : DEFAULT_LOCALE;\n            URL url = ClassLoader.getSystemResource(\"locales/\" + toLoad.getISO3Language() + \".properties\");\n            if (url == null) {\n                url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n            }\n            PROPS.clear();\n            PROPS.load(url.openStream());\n        } catch (IOException ioe) {\n            try {\n                URL url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n                PROPS.clear();\n                PROPS.load(url.openStream());\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(99);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(99);\n        }\n    }\n", "label": 0, "substitutes": {"genRandomGUID": [" genRandomGID", " genRandGUID", " genRandomGUIP", " genRandomGUUID", " genRandomUIP", " genRandomIGIP", " genRandomGIP", " genRandomUuid", " genRandomUUID", " genRandomIGUID", " genRandUID", " genRandGIP", " genRandGuid", " genRandomIGuid", " genRandomIGID", " genRandUIP", " genRandomGuid", " genRandomGUuid", " genRandUuid", " genRandGID", " genRandomUID", " genRandUUID"], "secure": ["sys", "https", "encrypted", "weak", "exclusive", "client", "Secure", "fast", "str", "allow", "force", "zip", "security", "proxy", "sec", " Secure", "deep", "remote", "protect", "host", "session", "q", "seed", "sensitive", "require", "forced", "ssl", "safe", "active", "stable", "config", "debug", "timeout", "depth", "close", "smart", "server", "password", "secret", " insecure", "random", "ssh"], "valueBeforeMD5": ["valueBeforeMD1", "valueBeforeMC85", "valueBeforemd85", "valueBeforeMP2", "valueBeforeMD85", "valueBeforeMD20", "valueBeforeMP3", "valueAfterMC3", "valueBeforeSHA1", "valueBeforeMT5", "valueAfterMS5", "valueBeforeMC3", "valueBeforeM5", "valueBeforeMD55", "valueAfterMS1", "valueBeforeMR85", "valueAfterMC85", "valueBeforeSHA3", "valueAfterMS3", "valueBeforeMP5", "valueAfterMD2", "valueAfterMS2", "valueBeforeM2", "valueBeforeMR3", "valueBeforeMT2", "valueBeforeMT20", "valueAfterMD8", "valueBeforeMT55", "valueBeforeMT05", "valueBeforeMS1", "valueBeforeM1", "valueAfterMD05", "valueBeforemd3", "valueBeforeMD05", "valueAfterMD20", "valueAfterMC8", "valueAfterMD3", "valueBeforeMD8", "valueBeforeSHA5", "valueBeforeMS5", "valueBeforeMT3", "valueBeforeMD2", "valueBeforeMD3", "valueBeforeAMD5", "valueBeforeAMD05", "valueBeforeMR8", "valueBeforeMC8", "valueAfterMC5", "valueAfterMD55", "valueBeforeAMD3", "valueBeforeSHA2", "valueBeforeMP55", "valueBeforeMC5", "valueBeforeMR5", "valueBeforeM3", "valueBeforemd5", "valueAfterMD1", "valueBeforeAMD20", "valueBeforemd8", "valueBeforeMS2", "valueBeforeMS3", "valueAfterMD85"], "valueAfterMD5": ["valueBeforeMP05", "valueBeforeMP3", "valueBeforeAST5", "valueBeforeMC3", "valueBeforeASTody", "valueBeforeAST2", "valueBeforeMP5", "valueAfterDF005", "valueAfterMP005", "valueBeforeAST005", "valueAfterMPTE", "valueAfterMC2", "valueBeforeMD512", "valueAfterMP1", "valueAfterDM512", "valueBeforeVM005", "valueAfterM1", "valueAfterMP2", "valueAfterGM005", "valueAfterMT3", "valueAfterDF3", "valueAfterAMD005", "valueAfterASTody", "valueBeforeMD1", "valueAfterAMD5", "valueAfterAST3", "valueAfterMC3", "valueAfterMTql", "valueBeforeMDody", "valueAfterHTML3", "valueBeforeMP1", "valueBeforeMPTE", "valueAfterVM005", "valueAfterMD005", "valueAfterMD2", "valueBeforeVM3", "valueBeforeMCql", "valueAfterMP3", "valueBeforeMD2", "valueBeforeVM5", "valueAfterHTML512", "valueBeforeMC5", "valueAfterMFTE", "valueBeforeAST3", "valueAfterMDTE", "valueBeforeMP2", "valueAfterM5", "valueAfterGM3", "valueAfterHTML5", "valueAfterMDql", "valueAfterMF05", "valueAfterVM5", "valueAfterHTML05", "valueBeforeMD05", "valueAfterMD3", "valueAfterDM5", "valueAfterAMD3", "valueAfterHTMLody", "valueAfterAST005", "valueBeforeMDql", "valueAfterAST512", "valueBeforeMD3", "valueAfterAST2", "valueAfterMP05", "valueAfterMC5", "valueAfterGM5", "valueAfterMC1", "valueBeforeMD005", "valueAfterMF3", "valueAfterVM3", "valueAfterM2", "valueAfterMDody", "valueAfterM3", "valueAfterMF5", "valueAfterDM3", "valueBeforeMDTE", "valueAfterDMody", "valueAfterMP5", "valueBeforeAST512", "valueAfterMCql", "valueAfterMD05", "valueAfterMD512", "valueAfterDF5", "valueAfterMT5", "valueAfterMD1", "valueAfterHTMLTE", "valueAfterAST5", "valueAfterGM2"], "md5": ["cmdkey", " md05", "amd25", "mand2", " md65", " md53", "MD512", "cmd1", "amd512", "mand5", "md512", " mdkey", "MD25", "md65", "MD2", "mand512", "cmd2", " md1", "mdkey", "amd5", "cmd05", "md25", " MD5", "md2", " md512", " md25", "mand65", "mandkey", " md2", "md1", "cmd5", "mand1", "cmd512", " MD05", "cmd65", "md53", "amd2", "md05", " MD3", "mand3", "md3", "cmd53", "MD5", " md3", "cmd3", " MD53"], "sbValueBeforeMD5": ["sbValueBetweenmd5", "sbValueBeforeMT005", "sbValueBeforeMD05", "sbValueInsideAMD05", "sbValuebeforeND85", "sbValueWithoutMF25", "sbValuebeforeND5", "sbValueBeforeMR5", "sbValueWithoutMF5", "sbValueAfterMD55", "sbValueBeforeAMD25", "sbValueInsideAMD5", "sbValueWithoutMD5", "sbValueBeforeMD525", "sbValueBetweenmd3", "sbValueBeforemd5", "sbValueAfterMD005", "sbValueBeforeMP525", "sbValueBetweenMD305", "sbValueAfterMP512", "sbValueBeforeMP5", "sbValueAfterMP1", "sbValueBehindMD525", "sbValueBeforeMD35", "sbValuebeforeND2", "sbValueBeforeMT3", "sbValueBeforeMS5", "sbValueBeforeMS85", "sbValueBeforeMP005", "sbValueBehindND5", "sbValueWithoutMD25", "sbValueBeforemd3", "sbValueBeforeND85", "sbValueAfterMP005", "sbValueBeforeMD55", "sbValueBehindND3", "sbValueWithoutMD35", "sbValueBeforeMS1", "sbValueBeforeMG35", "sbValueInsideMD5", "sbValueBeforeMD1", "sbValueBeforeND2", "sbValueWithoutMF35", "sbValueBeforeMR25", "sbValueBeforeMM005", "sbValueAfterMD3", "sbValueBeforeMD3", "sbValuebeforeMD2", "sbValueBeforeMG3", "sbValueBeforemd305", "sbValueBetweenMD2", "sbValueBeforeMC5", "sbValueBeforeMR3", "sbValueBehindND525", "sbValueBeforemd25", "sbValueBeforemd05", "sbValueBeforeMP25", "sbValueBeforemd2", "sbValueBeforeMD25", "sbValueAfterMD512", "sbValueBetweenmd305", "sbValueBeforeMD305", "sbValueBeforeAMD05", "sbValueAfterMP55", "sbValueBeforeMP3", "sbValueAfterMP5", "sbValueBeforeMD85", "sbValueBeforeAMD512", "sbValueBeforeAMD1", "sbValueBetweenMD3", "sbValueBeforeMP85", "sbValueBeforeMM3", "sbValueBehindMD25", "sbValueBeforeMD2", "sbValueBeforeMC3", "sbValueBeforeMD005", "sbValueBeforeAMD305", "sbValueBetweenMD5", "sbValueBehindMD5", "sbValueBehindMD3", "sbValueBeforeND5", "sbValueBeforeMP05", "sbValueAfterMD1", "sbValueBeforeND3", "sbValueInsideMD05", "sbValueBeforeMM5", "sbValueBeforeMP55", "sbValueInsideMD3", "sbValueWithoutMF3", "sbValueBeforeND25", "sbValueWithoutMD3", "sbValueBeforeMC35", "sbValueBeforeMG25", "sbValueBeforeMF25", "sbValuebeforeND3", "sbValueBetweenmd2", "sbValuebeforeMD5", "sbValueBeforeMP512", "sbValueBeforeMF5", "sbValueBeforeND525", "sbValueBeforeMP305", "sbValueBeforeMS3", "sbValueInsideAMD25", "sbValueBeforeMR525", "sbValueBeforeMF3", "sbValueBeforeMS2", "sbValueAfterMP3", "sbValueBeforeMT5", "sbValueBeforeMS512", "sbValueInsideMD25", "sbValueBeforeAMD3", "sbValuebeforeMD85", "sbValueBeforeMD512", "sbValuebeforeMD3", "sbValueBeforeMP1", "sbValueAfterMD5", "sbValueBeforeAMD2", "sbValueBeforeMP2", "sbValueInsideAMD3", "sbValueBehindND25", "sbValueBeforeMG5", "sbValueBeforeMC25", "sbValueBeforeMF35", "sbValueBeforeMM55", "sbValueBeforeMT55", "sbValueBeforeAMD5"], "time": ["race", "error", "ime", "id", "port", "times", "money", "host", "start", "length", "seed", "Time", "name", "month", "tz", "q", "TIME", "year", "rate", "duration", "type", "mode", "count", "counter", "speed", "timeout", "date", "depth", "version", "delay", "age", "cost", "sleep", "work", "clock", "value", "random", "hour", "timer", "size", "etime", "temp"], "rand": ["error", "clean", "ng", "rh", "re", "bit", "right", "id", "reg", "rr", "index", "pattern", "q", "seed", "core", "name", "max", "range", "bug", "winner", "length", "order", "risk", "serial", "year", "rate", "type", "r", "count", "root", "raid", "rage", "rule", "win", "alpha", "depth", "version", "rank", "delay", "nd", "rc", "dr", "round", "ro", "mid", "dist", "random", "rss", "pick", "Rand"], "array": ["air", "pair", "address", "feature", "error", "cache", "sample", "now", "view", "app", "vector", "arr", "function", "row", "index", "string", "range", "archive", "section", "image", "angle", "multi", "bug", "database", "Array", "expression", "ray", "all", "element", "a", "batch", "r", "number", "object", "list", "integer", "table", "our", "arrow", "instance", "value", "area", "collection", "record", "module"], "strTemp": [" strBase", " strTest", "strTemplate", "brTemp", "stringFake", "strTem", "brTem", "stringtemp", "drTemp", "crtemp", "drtemp", "objTemp", "objFake", " strtemp", "arrTem", "StrBase", "arrTemp", "StrTemp", " strTemplate", "strtemp", "brVar", " strVar", "drVar", " strTem", "crTemp", "drTemplate", "brtemp", "objTem", " strFake", "strFake", "strVar", "arrTest", "Strtemp", "drTem", "crTem", "arrBase", "stringTem", "stringTemp", "strBase", "objtemp", "crTemplate", "strTest", "brTest", "arrtemp"], "i": ["v", "z", "k", "ip", "ai", "ti", "I", "e", "id", "io", "xi", "x", "index", "eni", "start", "end", "u", "li", "ui", "hi", "multi", "ci", "c", "si", "phi", "ii", "y", "j", "ie", "info", "b", "n", "o", "slice", "ri", "uri", "p", "ix", "gi", "h", "key", "abi", "in", "l", "di", "d", "field", "yi", "ji", "mu", "f", "pi"]}}
{"id1": "16511008", "id2": "9109613", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createNewProfilingMessageSymbol": ["createNewProfilingMessageYmbol", "createNewProfilingMessageSymmbol", "createNewProfilingMessageYmb", "createNewProfilingMsgSymb", "createNewProfilingMsgSymbol", "createNewProfilingMessageSyletter", "createNewProfilingMessageSymb", "createNewProfilingMsgSymmbol", "createNewProfilingMessageSymletter", "createNewProfilingMessageYletter", "createNewProfilingMsgSymmb", "createNewProfilingMessageCyletter", "createNewProfilingMessageSymmb", "createNewProfilingMsgSymletter", "createNewProfilingMsgSyletter", "createNewProfilingMessageCymb", "createNewProfilingMessageCymbol"], "configID": [" configION", " configId", "ConfigUID", "configION", "configUID", "projectURL", "ConfigURL", " configURL", "ConfigION", "projectION", "ConfigID", "projectUID", "projectId", "configId", "configURL", "ConfigId", " configUID", "projectID"], "programMessageSymbolID": ["programMessageSyklId", "programMessageSyymName", "programMessageSyymIP", "programMessageSyklID", "programMessageSyncmbID", "programMessageSychid", "programMessageSyntaxID", "programMessageSyncmbIP", "programMessageSyncmbolIP", "programMessageSyntaxName", "programMessageSyymId", "programMessageSyncmbid", "programMessageSymbolid", "programMessageSyncmbolId", "programMessageSymbName", "programMessageSymbolName", "programMessageSyncmbId", "programMessageSymbid", "programMessageSymbId", "programMessageSyklName", "programMessageSymbolIP", "programMessageSyncmbolid", "programMessageSychID", "programMessageSyncmbolName", "programMessageSymbID", "programMessageSymbolId", "programMessageSychId", "programMessageSymbIP", "programMessageSyntaxId", "programMessageSyncmbolID", "programMessageSyntaxid", "programMessageSyymID", "programMessageSyncmbName"], "profilingMessageSymbol": ["profilingMessageSymb", "profilingFileSymletter", "profilingMessageSynmbol", "profilingMessageSymPart", "profilingMessageTymbol", "profilingApplicationSymmb", "profilingMessageCyletter", "profilingMessageSyPart", "profilingMessageCymb", "profilingApplicationSymmbol", "profilingMessageCymbol", "profilingFileSymb", "profilingMessageTymb", "profilingFileSymmbol", "profilingFileSymmb", "profilingMessageSynmb", "profilingMessageSynPart", "profilingMessageSymmb", "profilingApplicationSymbol", "profilingApplicationSymb", "profilingMessageSymletter", "profilingMessageSyletter", "profilingFileSyPart", "profilingFileSymPart", "profilingApplicationSyletter", "profilingMessageYletter", "profilingMessageYmbol", "profilingFileSymbol", "profilingMessageSymmbol", "profilingMessageTyPart", "profilingMessageYmb", "profilingApplicationSymletter", "profilingFileSyletter"], "connection": ["bc", "position", "result", "error", "client", "cache", "use", "command", "db", "environment", "ctx", "log", "engine", "index", "connect", "session", "sql", "conn", "context", "state", "response", "machine", "driver", "section", "image", "c", "lock", "database", "si", "communication", "ongo", "Connection", "application", "directory", "config", "socket", " Connection", "cond", "table", "condition", "document", "function", "ion", "pool", "server", "channel", "password", "con", "collection", "unit", "manager", "connected", "relation"], "statement": ["position", "result", "error", "Session", "stat", "Query", "str", "study", "parse", "use", "command", "volume", "db", "function", "session", "sql", "mt", "conn", "string", "state", "out", "connect", "section", "lock", "database", "si", "storage", "expression", "writer", "report", "Connection", "library", "directory", "ment", "table", "message", "ma", "timeout", "parser", "usage", "joined", "agent", "condition", "document", "commit", "se", "execute", "Statement", "summary", "pass", "collection", "unit", "part", "comment", "response", "relation"], "resultSet": ["ResultSet", "ResultSource", "dataGen", " resultS", "dataList", "ResultType", "resultType", "ResultRow", "replySplit", "resultsGen", "ResultLine", "resultRow", "resultList", "responseSet", "rowSource", " resultSource", "resultsSet", "rowSet", "dataSource", "responseRow", "ResultS", "resultSource", "resultGen", "rowType", "replyList", "ResultList", " resultList", "resultSplit", "resultsSource", " resultGen", "replySet", " resultSplit", "replyLine", "responseList", "ResultGen", "resultLine", " resultType", "dataLine", "rowS", "dataSet", "ResultSplit", "dataRow", " resultLine", "resultS"], "query": ["feature", "result", "error", "send", "eries", "description", "Query", "call", "str", "parse", "id", "command", "request", "function", "index", "sql", "q", "string", "name", "lock", "database", "code", "expression", "reason", "type", "sq", "report", "go", "ql", "root", "scan", "join", "rule", "o", "update", "message", "table", "uri", "timeout", "qu", "key", "condition", "search", "filter", "work", "question", "execute", "qs", "style", "script", " Query", "value", "comment", "select", "module"], "msg": ["ger", "map", "md", "cmp", "cap", "cm", "error", "Message", "exc", "ms", "gor", "title", "gen", "status", "str", "mr", "gm", "e", "sim", "id", "db", "rr", "log", "comm", "ge", "mt", "name", "cmd", "err", "doc", "og", "pkg", "agg", "bag", "sg", "m", "format", "reason", "cfg", "html", "g", "desc", "text", "tag", "Msg", "ug", "bg", "loc", "ag", "mg", "lang", "message", "var", "ma", "fg", "mn", "phrase", "dr", "op", "gr", "rag", "nm", "tool", "gs"]}}
{"id1": "2676365", "id2": "7468819", "code1": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"reset": ["save", "delete", "activate", " rebuild", " shutdown", " checkpoint", "start", "clear", "set", "setup", " reconnect", " disconnect", "release", " Reset", "et", "back", "stop", "sync", "update", " migrate", "disable", "close", "flush", "commit", "destroy", "init", "register", " restore"], "currentPilot": ["currentPortector", " currentCPooter", "currentpilot", "currentpiece", "currentPayistor", " currentPooter", "currentPortacket", "currentCPilot", "currentPayacket", "currentpacket", "currentpooter", "activePistor", " currentCPilot", "currentCPacket", " currentPector", "activePilot", "currentPistor", "currentPointilot", "activepistor", "currentPointiece", "activepiece", "currentPooter", "currentPortooter", "activePacket", "currentPointistor", "currentpector", "activePiece", "currentCPector", "currentPayilot", " currentPacket", "currentPointacket", "currentPector", " currentCPector", "currentPayiece", "currentPortilot", "currentCPooter", "currentPiece", "currentPacket", "activepacket", "currentpistor", " currentCPacket", "activepilot"], "psta": ["jste", "pesa", "jda", " pste", "pasi", " psa", "pppa", "parsta", "Pla", "Psa", "jsa", "Pda", "psa", "pesta", " pppa", "parasi", "peppa", "Psta", "pda", " pda", "Pasi", "paresta", "Pste", "Pesta", " pesta", "pela", "parsa", "pla", "pste", "jsta", " pla", "Pppa", " pasi"]}}
{"id1": "9275622", "id2": "22264586", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferfile", "copyFolder", "movefile", " copyFolder", "moveFolder", "transferFolder", "transferFiles", "moveFiles", " copyfile", "moveFile", "transferFile", "copyfile", " copyFiles"], "_file1": ["_fileone", "_files01", "_files2", "_zipOne", "_zipFirst", "_File0", "_mail1", "_mail01", "_fileFirst", "_resourceOne", "_resourceone", "_fFirst", "_files0", "_fOne", "_fone", "_files1", "_File2", "_zipone", "_f1", "_mail2", "_File1", "_file01", "_mail0", "_resource1", "_File01", "_file0", "_resourceFirst", "_fileOne", "_zip1"], "_file2": [" _files4", "_play4", "_Filesecond", " _fileTwo", "_files2", "_playsecond", "_files4", "_file3", "_files3", "jmodel2", "_modelsecond", "_file5", "_play3", " _file4", "_play5", " _file3", " _filesTwo", "jfile5", "_File5", "jfile1", "jmodelsecond", " _files3", "_play1", " _files2", "_model2", "_File2", "_play2", "_fileTwo", "_File1", "_filesTwo", "_file4", "jfilesecond", "_model1", "_filesecond", "jmodel1", "jmodel5", "_playTwo", "_model5", "jfile2"], "fis": [" fiss", "fais", "cfis", "fris", "cfas", " fais", "lfais", "infis", "lfi", " fi", "Fris", "infiss", " fas", "Fos", "infils", "fils", "Fis", "fas", " fils", "afis", "cfiss", "afi", "lfis", "Fiss", "Fils", "lfiss", "Fas", "fiss", "afiss", "fi", "cfos", "cfris", "afais", "infos", " fris"], "fos": ["foes", "Fo", "feus", "infus", "gus", "fus", "gos", "infios", "Fros", "flis", "poes", "fOS", "feis", "Foos", "feos", " foos", "Fus", "Foses", " faos", "feoses", "Fos", "Fis", "fros", " fo", "infoos", "fios", "pis", "lOS", "info", "Fios", "infaos", "flOS", "floes", "lis", " fus", " fios", "infos", "goses", "los", "loes", "fo", "pOS", "infros", "gis", "flos", "foses", "pos", " fros", "faos", "Faos", "foos"], "canalFuente": ["canalFUente", "canaledFuze", "canalFuento", "canallBuence", "canallFuencia", "canalsBuencia", "canalFuze", "canaledBuze", "canaledBuente", "canallFuze", "canalSuestro", "canalFuence", "canalBuence", "canalFUze", "canalKuente", "canalKuento", "canalsBuence", "canalFUencia", "canalFuestro", "canallBuencia", "canalsBuento", "canalKuence", "canaledFuje", "canalFUestro", "canalCraencia", "canalBuze", "canaledFuestro", "canallFuence", "canalSuze", "canalsFuence", "canalFUje", "canaledFuente", "canalsFuencia", "canalBuje", "canalCraente", "canalBuento", "canalSuje", "canalsFuente", "canalBuente", "canalsFuento", "canaledBuje", "canalFuencia", "canalCraence", "canalKuencia", "canalCraento", "canallBuze", "canalKuze", "canallBuente", "canalBuestro", "canaledBuestro", "canalBuencia", "canallFuente", "canalFUence", "canalFuje", "canalSuente", "canalsBuente"]}}
{"id1": "19147279", "id2": "2198730", "code1": "    public boolean actualizarDatosFinal(int idJugadorDiv, int idRonda, jugadorxDivxRonda unjxdxr) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET resultado = ?, puntajeRonda = ? \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatementActFinal(unjxdxr);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public void importCSV(InputStream csvfile) throws Exception {\n        try {\n            String[] qmarks = new String[columns.length];\n            for (int i = 0; i < qmarks.length; i++) {\n                qmarks[i] = \"?\";\n            }\n            if (cleartable) {\n                String delsql = \"delete from \" + table;\n                Statement delstm = conn.createStatement();\n                delstm.executeUpdate(delsql);\n            }\n            String sql = \"insert into \" + table + \" (\" + StringUtils.join(columns, \", \") + \") values (\" + StringUtils.join(qmarks, \", \") + \")\";\n            log.debug(\"SQL: \" + sql);\n            PreparedStatement stm = conn.prepareStatement(sql);\n            int datatypes[] = new int[columns.length];\n            for (int i = 0; i < columns.length; i++) {\n                Table tbl = project.getTableByName(table);\n                if (tbl == null) throw new OntopiaRuntimeException(\"Unknown table: \" + table);\n                Column col = tbl.getColumnByName(columns[i]);\n                if (col == null) throw new OntopiaRuntimeException(\"Unknown table column: \" + columns[i]);\n                if (col.getType() == null) throw new OntopiaRuntimeException(\"Column type is null: \" + col.getType());\n                DataType datatype = project.getDataTypeByName(col.getType(), \"generic\");\n                if (datatype == null) throw new OntopiaRuntimeException(\"Unknown column type: \" + col.getType());\n                String dtype = datatype.getType();\n                if (\"varchar\".equals(dtype)) datatypes[i] = Types.VARCHAR; else if (\"integer\".equals(dtype)) datatypes[i] = Types.INTEGER; else throw new OntopiaRuntimeException(\"Unknown datatype: \" + dtype);\n            }\n            LineNumberReader reader = new LineNumberReader(new InputStreamReader(csvfile));\n            for (int i = 0; i < ignorelines; i++) {\n                String line = reader.readLine();\n                if (line == null) break;\n            }\n            log.debug(\"[\" + StringUtils.join(columns, \", \") + \"]\");\n            int lineno = 0;\n            while (true) {\n                lineno++;\n                String line = reader.readLine();\n                if (line == null) break;\n                try {\n                    String[] cols = StringUtils.split(line, separator);\n                    if (cols.length > columns.length && !ignorecolumns) log.debug(\"Ignoring columns: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    log.debug(\"CVALUES: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    String dmesg = \"(\";\n                    for (int i = 0; i < columns.length; i++) {\n                        String col = cols[i];\n                        if (stripquotes) {\n                            int len = col.length();\n                            if (len > 1 && ((col.charAt(0) == '\"' && col.charAt(len - 1) == '\"') || (col.charAt(0) == '\\'' && col.charAt(len - 1) == '\\''))) col = col.substring(1, len - 1);\n                        }\n                        if (col != null && col.equals(\"\")) col = null;\n                        dmesg = dmesg + col;\n                        if (i < columns.length - 1) dmesg = dmesg + \", \";\n                        stm.setObject(i + 1, col, datatypes[i]);\n                    }\n                    dmesg = dmesg + \")\";\n                    log.debug(dmesg);\n                    stm.execute();\n                } catch (Exception e) {\n                    conn.rollback();\n                    throw new OntopiaRuntimeException(\"Cannot read line \" + lineno + \": '\" + line + \"'\", e);\n                }\n            }\n            conn.commit();\n        } finally {\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 1, "substitutes": {"actualizarDatosFinal": [" actualizarDataoFinal", " actualizarDataoComplete", " actualizarDatOSResult", " actualizarDataoResult", " actualizarDatOSComplete", " actualizarBatocFinal", " actualizarDatocComplete", " actualizarDatosTotal", " actualizarDatocFinal", " actualizarBatosResult", " actualizarDatosComplete", " actualizarBatocTotal", " actualizarDatOSTotal", " actualizarBatosFinal", " actualizarDatocTotal", " actualizarDatOSFinal", " actualizarBatocResult", " actualizarDatosResult", " actualizarDatocResult", " actualizarBatocComplete", " actualizarBatosTotal", " actualizarDataoTotal", " actualizarBatosComplete"], "idJugadorDiv": ["idJubadorDoc", "idJudadorDec", "idJudadorDiv", "idJugaderOrd", "idJudadeDec", "idJudadeDIV", "idJugadorDoc", "idJugadorDIV", "idJudadeDiv", "idJugordOrd", "idJugaderDoc", "idJugordDIV", "idJugordDiv", "idJugrarDiv", "idJugaderDiv", "idJubadorDiv", "idJugadorOrd", "idJugadeDec", "idJubordDoc", "idJugordDec", "idJubordOrd", "idJugrarDoc", "idJugaderDIV", "idJugaderDec", "idJugadeDiv", "idJubordDiv", "idJudadorDIV", "idJugadeDIV", "idJugrarDec", "idJubordDec", "idJugordDoc", "idJugadorDec", "idJubadorOrd", "idJubadorDec", "idJugrarOrd"], "idRonda": ["idrona", "idranna", "idRhado", " idrona", "pidRona", "idRhonda", "pidRora", "idronda", "pidRhona", "pidRhonda", "idRora", "idRona", "pidRado", " idronda", "pidRonda", "pidRhora", " idranna", "idRhora", "idRhona", " idRona", "idrora", "pidRhado", "idGronda", " idrora", "idrado", "idRanna", " idRanna", "idGrora", "idRhanna", "idGrona", "idGrado", " idRora", "idRado"], "unjxdxr": ["unjddxl", "unjddxr", "unjxfxR", "unjxdxxR", "unjxfexr", "unjxfexR", "unjddxxR", "unjxdexl", "unjxfxr", "unjxdxR", "unjddxer", "unjxdxtl", "unjxdxter", "unjxdddr", "unjxfxrs", "unjxdddR", "unjxdxtrs", "unjddxxr", "unjxdxrs", "unjxdexer", "unjxdxxer", "unjxdexr", "unjxdxxr", "unjxdxxl", "unjxdddrs", "unjxdxtR", "unjxfexrs", "unjddxR", "unjddxxer", "unjxdxtr", "unjxdxer", "unjxdexR", "unjxdxl", "unjxdexrs", "unjddxxl"], "intResult": ["intReturn", "INTRes", "ntResponse", "mintOrder", "IntCode", "IntResponse", "intResponse", "INTResult", "IntRest", "intCode", "IntResult", "IntRate", " intOrder", "IntReturn", "ntRes", "longResult", "intRate", "mintResult", "ntResult", "intOrder", "longCode", " intRate", "longRes", "intRest", "IntRes", " intRest", "mintReturn", "mintRate", "intRes", " intRes", "INTRest", "longResponse", "IntOrder", " intReturn", "ntCode", "INTReturn"], "sql": ["url", "params", "job", "eps", "str", "dl", "QL", "db", "log", "nl", "SQL", "sl", "mt", "conn", "string", "msg", "cmd", " SQL", "section", "database", "plan", "dd", "ssl", "sq", "sb", "ql", "printf", "join", "query", "socket", "sync", "joined", "pg", "search", "l", "fn", "limit", "statement", "comment", "select", "pr"], "connection": ["position", "bc", "client", "reader", "proxy", "container", "db", "environment", "ctx", "function", "index", "engine", "connect", "BC", "session", "conn", "context", "cp", "driver", "section", "c", "cc", "database", "character", "communication", "writer", "Connection", "application", "handler", "config", "loc", "socket", "query", "table", "condition", "document", "pg", "ion", "server", "con", "collection", "statement", "log", "manager", "connected", "relation"], "ps": ["posts", "syn", "ping", "ins", "pa", "relations", "ms", "params", "eps", "pse", "PS", "ts", "proxy", "rs", "ns", "conn", "ks", "ls", "cp", "Ps", "changes", "os", "pers", "pps", "hs", "pe", "ppa", "cs", "ops", "ups", "ds", "p", "pg", "ips", "ports", "qs", "pc", "pp", "details", "sp", "bs", "mp", "gs", "pr", "po"]}}
{"id1": "9796161", "id2": "4798332", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 1, "substitutes": {"getMD5": ["getSHA4", " getSHA4", "getMD4", "getmdHash", " getSHAHash", "getmd5", "getSHA5", "getSHA512", "getmd512", "getMDHash", "getmd4", " getMDHash", " getSHA5", "getSHAHash", " getMD4", "getHTML5", "getMD512", " getSHA512", "getHTML4", " getMD512", "getHTML512", "getHTMLHash"], "s": ["v", " ads", "services", "ms", "str", "scripts", "e", "sets", "ts", "rs", "ws", "ates", "es", "input", "ns", "abs", "string", "ls", "styles", "lines", "c", "si", "als", "ses", "self", "comments", "strings", "os", "ssl", "sb", "i", "a", "g", "b", "js", "n", "cs", " fails", "ps", "sym", "S", "sync", "ends", "ows", "ds", "parts", "p", "bytes", "its", "ips", "is", "l", "in", "data", "source", "f", "ss", "bs", "tests", "gs", "ings"], "m": ["cm", "md", "v", "im", "mc", "ms", "mr", "gm", "e", "rm", "pm", "am", "bm", "um", "manager", "machine", "fm", "mut", "man", "M", "c", "sm", "mi", "ym", "mand", "t", "i", "om", "arm", "mm", "tm", "em", "p", "h", "mac", "hm", "wm", "me", "l", "vm", "d", "nm", "dm", "mu", "f", "module"]}}
{"id1": "12236729", "id2": "11562173", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "label": 1, "substitutes": {"copy": [" copying", "transfer", "php", "zip", "io", "Copy", " copied", "replace", "py", "cp", "upload", "clone", "cop", "sync", "diff", "clip", "p", "get", " transfer", "download", " dup", "dump", "split", "cat", " Copy", "paste", "cmp"], "inputFile": ["outputDir", "sourceFiles", "currentDir", "inputDir", " inputFiles", " inputPath", "sourcePath", "inputPath", "sourcefile", " inputfile", "sourceFile", "inputFiles", "outputFiles", "outputfile", " inputDir", "currentFiles", "currentFile", "currentfile", "inputfile", "outputPath"], "outputFile": [" outputFilename", "OutputFile", " outputDir", "outputDir", "referencefile", "inputDir", " outputDirectory", " outputfile", "outputFilename", "OutputDirectory", "tempDir", "referenceDir", "OutputDir", "tempFile", "tempDirectory", "outputfile", "referenceFile", "inputFilename", "tempfile", "outputDirectory", "Outputfile", "referenceFilename", "inputfile"], "in": ["gin", "ins", "reader", "din", "IN", "login", "bin", "e", "id", "inc", "ini", "input", "In", "s", "conn", "inner", "ln", "image", "err", "lock", "read", "a", "i", "r", "connection", "n", "again", "sin", "pull", "socket", "nin", "win", "inn", "min", "pin", "get", "is", "into", "l", "lin", "source", "up", "file", "init", "inside", "kin", "cin", "con", "as", "f"], "out": ["net", "exec", "v", "error", "OUT", "outs", "cache", "w", "output", "bin", "io", "inc", "one", "log", "outside", "conn", "obj", "write", "err", "off", "Out", "plain", "extra", "at", "writer", "i", "b", "ex", "n", "again", "parent", "o", "over", "null", "sync", "socket", "post", "outer", "plus", "line", "file", "up", "temp"], "c": ["cm", "v", "k", "cl", "lc", "cf", "cy", "uc", "e", "id", "C", "x", "pointer", "u", "cr", "ci", "cc", "character", "code", "m", "ct", "ec", "a", "i", "count", "r", "cu", "b", "n", "ce", "esc", "o", "fc", "cd", "p", "rc", "col", "line", "l", "char", "sc", "ch", "d", "pc", "xc", "f"]}}
{"id1": "14783950", "id2": "22046596", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"compressWithZip": ["compressWithJar", "compressedWithJar", "compresswithSax", "compressedUsingJar", "compressInSax", "compressUsingJar", "compressedUsingSax", "compresswithJar", "compressInZip", "compressedUsingZip", "compressUsingZip", "compresswithZip", "compressUsingSax", "compressedWithZip", "compressedWithSax", "compressWithSax", "compressInJar"], "fileList": ["FileChain", "ziplist", "wordString", "fileStream", "modelList", " fileChain", "Filelist", "stringList", "modelStream", "stringChain", "zipSet", "modelEx", "FileName", "FileSet", "stringName", " fileCollection", "inputEx", "inputStream", " fileSet", "modelCollection", "fileChain", "fileEx", "inputList", " fileStream", "stringlist", "FileString", " fileString", "zipList", "fileCollection", "wordName", "fileString", " fileEx", "FileStream", "zipName", "inputCollection", " filelist", "FileList", "wordList", "fileSet", "wordStream", "filelist"], "zipFileName": ["archiveFileDir", "zipFileNames", "folderGlobalPath", "zipFullNames", "zipFilePath", "archiveDirName", "folderGlobalName", "zipPackageDir", "archiveFilePath", "zipFullname", "zipGlobalPath", "zipDirName", "folderGlobalname", "zipGlobalNames", "zipPackageName", "zipGlobalname", "folderFilePath", "zipFullPath", "folderFileName", "zipDirNames", "archiveDirPath", "archiveFileName", "zipFilename", "archiveDirDir", "zipFullName", "folderGlobalNames", "zipGlobalName", "zipPackagePath", "zipFullDir", "folderFileNames", "folderFilename", "zipFileDir", "zipDirDir", "zipDirname", "zipDirPath"], "fos": ["afaos", " fosh", "flis", "afos", "infis", "Fosh", "Fos", "foS", "Fis", "flosh", "afis", "fosh", "infaos", "afoS", "infoS", "infos", "FoS", "flos", "faos", "Faos"], "zos": ["z", "osi", "outs", "zzy", "onz", "ZA", "zar", "kos", "zip", "seconds", "bis", "zers", "spin", "chini", "es", "zon", "budget", "tz", "uz", "jobs", "zen", "zes", "os", "ses", "bag", "zl", "phi", "webkit", "bos", "zan", "dos", "zer", "iframe", "zo", "ozo", "zi", "LOS", "fits", "lins", "oses", "css", "zx", "nz", "zz", "fi", "zag", "rez", "abi", "cos", "inos", "jas", "zb", "ZI", "gz", "loop", "packs", "bes", "zik", "closure", "obb", "ros", "lol", "zy"], "iter": ["ser", "oper", "test", "ip", "chain", "ter", "upper", "itter", "enter", "parse", "finder", "el", "e", "ator", "inc", "sort", "cher", "index", "er", "former", "keep", "iz", "ir", "end", "inner", "liter", "set", "err", "next", "order", "iner", "Iterator", "ie", "i", "ite", "fer", "loc", "list", "walker", "gener", "ner", "inse", "outer", "slice", "fr", "it", "iterator", "is", "http", "file", "izer", "Iter", "coll", "inter", "f", "ener"], "fileName": ["FileType", " filePart", "FileLine", "fPart", "currentname", "localname", "localPart", "FileUrl", " filePath", "currentData", "localPath", "pageName", "filenameInfo", " fileUrl", "filename", "FileName", "currentUrl", "currentName", "fileOpen", "pagename", "fileLine", "filenamename", " fileFull", "fileData", " fileOpen", "simpleOpen", "filenameName", "fName", " fileData", " fileInfo", "fullPath", "fullOpen", "FileString", "filePart", "fileType", " fileString", "FilePath", "filenameFull", "FilePart", "fileInfo", "fLine", "fileFull", "fullName", "fileString", " filename", "FileFull", " fileLine", " fileType", "fname", "simplePath", "simpleName", "filePath", "FileInfo", "localName", "pageString", "FileData", "fileUrl", "pageType", "Filename"], "ind": ["bind", "mind", "z", "id", "inc", "Ind", "x", "index", "div", "val", "pt", "start", "length", "ded", "pend", "end", "rib", "ci", "len", "ii", "j", "i", "count", "eff", "pull", "loc", "ord", "cond", "fr", "ad", "inn", "wind", "ix", "nd", "in", "vert", "ld", "dir", "mid", "pos", "IND", "d"], "shortName": ["ShortPath", "smallName", "longName", "ShortPart", "fullLine", "smallname", "shortPart", "longPart", "smallPart", "longname", "smallPath", "shortname", "fullString", "fullname", "longPath", " shortString", "fullPath", " shortname", " shortLine", "ShortString", "fullName", "shortString", "Shortname", "shortPath", " shortPath", "longLine", "shortLine", "ShortName"], "fis": [" fiss", "fris", "cfis", "gisa", "afos", "Fos", " fisa", "Fis", "fios", "afis", "cfiss", "pis", "Fiss", "gios", "pris", "Fs", " fios", "fs", "gris", "fiss", " fs", "afiss", "cfos", "gis", "afris", "cfris", "cfs", "pisa", " fris", "pios", "fisa"], "buf": ["vec", "uf", "bc", "v", "uc", "bb", "bin", "tmp", "br", "bd", "cv", "bp", "cur", "fb", "ba", "seq", "queue", "bl", "bag", "box", "batch", "Buff", "lb", "b", "grab", "ff", "loc", "wb", "buffer", "done", "la", "bytes", "rb", "fd", "feat", "rc", "data", "pb", "bh", "bf", "lim", "cb", "buff", "bu"], "bytesRead": [" bytesSkip", "flowsLength", "bitsSkip", "secondsRead", "tesSkip", "secondsNeed", "secondsWrite", "wordsRead", "bitsRead", "secondsLength", "flowsRead", "flowsNeed", "tesWrite", "wordsWrite", "bytesSkip", " bytesUse", " bytesWrite", "bytesWrite", "bytesLength", " bytesLength", "flowsWrite", "bitsLoad", "bitsWrite", "tesLoad", "wordsUse", " bytesNeed", "bytesUse", "tesRead", " bytesLoad", "wordsLength", "bytesNeed", "bitsUse", "bytesLoad", "bitsLength"]}}
{"id1": "12066447", "id2": "8150996", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"truncate": ["autuncate", "trunator", "tratenate", "truncational", "trunational", "trrenational", "trunation", "truncation", "trrenator", "autuncator", "trunate", "autatenational", "tratenational", "autatenate", "trrenate", "autuncational", "truncator", "tratenation", "trrenation", "tratenator", "autatenator", "autuncation", "autatenation"], "file": ["fp", "url", "address", "FILE", "base", "cache", " File", "local", "e", "zip", "io", "current", "model", "db", "path", "folder", "log", "function", "one", "filename", "out", "name", "string", "binary", "stream", "archive", "time", "queue", "image", "ile", "this", "files", "or", "format", "File", "type", "info", "connection", "class", "object", "directory", "body", "parent", "handler", "per", "future", "uri", "resource", "it", "plus", "document", "get", "single", "page", "l", "data", "source", "http", "line", "full", "f"], "backupRoot": ["BackbackFile", "BackupDirectory", "backupsDir", "backdownroot", "backbackFile", "backUpRoot", "frontupRoot", "backbackRoot", "backbackHome", "BackupDir", "backureHome", "backureRoot", "backflowroot", "backupDir", "backbaseDirectory", "BackupFile", "BackdownPath", "BackbackRoot", "backdownRoot", "BackdownDirectory", "backbackroot", "Backbackroot", "backUpDir", "backflowFile", "Backdownroot", "backflowDir", "backbackDir", "backupsroot", "backdownDirectory", "backbaseRoot", "backbasePath", "backuproot", "backbackDirectory", "BackureDirectory", "backdownFile", "backupsRoot", "backupsFolder", "frontuproot", "BackureHome", "backUproot", "backdownFolder", "frontupDir", "BackupPath", "Backuproot", "backdownHome", "backdownDir", "backflowRoot", "frontdownroot", "backupHome", "frontdownDir", "BackureRoot", "BackupRoot", "backureDir", "frontdownFolder", "backupFolder", "BackupHome", "backupFile", "frontupFolder", "frontdownRoot", "BackdownRoot", "backbaseroot", "backureDirectory", "backUpFolder", "backupDirectory", "BackbackDir", "backdownPath", "backupsDirectory", "backupPath", "backupsPath", "BackureDir"], "df": ["flow", "fp", "md", "de", "cf", "xf", "da", "dl", "dp", "io", " def", "dict", "func", "db", "tf", "fb", "pdf", "CF", "raf", "fe", "format", "dd", "dq", "deb", "def", "fc", "fr", "ds", "fs", "dc", "pd", "af", "fd", "dt", "dn", "di", "data", "fn", "d", "bf", "dm", "sf", "f", "DF"], "date": ["complete", "url", " Date", "re", "updated", "str", "output", "use", "pre", "valid", "Date", "db", "created", "x", "log", "ge", "input", "out", "name", "string", "time", "bug", "day", "code", "year", "m", "format", "custom", "type", "j", "pe", "dat", "tag", "rule", "back", "D", "ale", "diff", "sync", "update", "message", "version", "dates", "min", "form", "fee", "dt", "age", "ate", "data", "work", "dose", "style", "stage", "d", "create", "modified", "value", "atom", "open", "days", "module"], "zipFile": ["sqlFile", "zipModel", "zipfile", "ZipFiles", "zipFiles", "sqlfile", " zipEntry", "ressfile", "ressFile", "Zipfile", "zEntry", "zFile", "zipEntry", "ressSection", "zipSection", " zipfile", "zModel", "ZipFile", "ZipEntry", "sqlSection", "zSection", "zFiles", "ressModel", "sqlModel", " zipFiles", "zfile"], "zos": ["dylib", "z", "address", "las", "osi", "outs", "zzy", "bitcoin", "zh", "ZA", "zar", "kos", "zip", "proxy", "chini", "ls", "liquid", "zon", "tz", "budget", "uz", "zen", "zes", "os", "ses", "zona", "zl", "webkit", "bos", "ssl", "hess", "zan", "dos", "iffs", "zn", "js", "ops", "asio", "zer", "zo", "ozo", "zi", "fits", "lins", "css", "her", "los", "zx", "nz", "zag", "rez", "cos", "inos", "forge", "jas", "zb", "gz", " sands", "cash", "robe", "zik", "bes", "eros", "han", "closure", "obb", "ros", "nox", "exit", "zero", "ils", "zy", "settings"], "fis": ["lias", "Fias", " fiss", "flris", "rafiss", "flids", "fris", "flis", "Fisp", "liss", " fias", "flias", "fliss", "bis", "infis", "Fris", "rafias", "infiss", " fisl", "fiz", "infils", "fisp", "fils", "biss", "Fis", "infits", "Fisl", "Fos", " fils", "fias", "fisl", "vils", " fits", "bos", "rafis", "Fiss", "fids", "bisl", "lis", "viz", "flisp", "fits", " fiz", "infiz", "infias", "vis", "fiss", "vits", "fos", " fos", "infids", " fris", " fisp", "lids", "rafris"], "entry": ["address", "z", "de", "lc", "reader", "e", "zip", "feed", "exp", "ace", "term", "cel", "row", "index", "ge", "auto", "obj", "offset", "ui", "archive", "image", "next", "si", "card", "extra", "or", "event", "element", "ie", "info", "r", " Entry", "so", "Entry", "zo", "per", "the", "her", "uri", "array", "add", "it", "key", "ion", "ry", "data", "style", "letter", "se", "record", "server", "and", "ries", "comment", "cell"], "buffer": ["Buffer", "address", "position", "result", "header", "uffer", "reader", "cache", "bb", "beta", "transfer", "feed", "FFER", "vector", "available", "row", "border", "length", "sequence", "binary", "seed", "memory", "queue", "layer", "writer", "reference", "batch", "b", "shape", "buf", "number", "null", "slice", "pad", "padding", "iter", "wave", "bytes", "flush", "page", "data", "channel", "server", "device", "comment", "buff"], "readed": ["inputED", "inputled", "readized", "textized", "texted", "textED", " Readed", " readered", "readned", "textended", "readable", "bootED", " ReadED", "booted", " readned", "inputed", "intended", "bootered", " readended", " Readered", "readED", " Readled", " Readable", " readED", "inputned", "readled", "readended", " Readned", "bootable", "intED", " readized", "readered", " readable", " readled", "intized", "inted"]}}
{"id1": "18891988", "id2": "7425022", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"getFile": ["GetString", "GetFilename", "downloadFile", "loadFile", "loadfile", "downloadfile", "getfile", "getFilename", "Getfile", "getString", "loadString", "downloadFilename", "GetFile", "downloadString", "loadFilename"], "serviceName": ["ServiceName", "projectType", " servicePath", "ServicePath", "Servicename", " serviceType", " servicename", "packagename", "servicePath", "ServiceType", "projectUrl", " serviceUrl", "servicename", "projectPath", "ServiceUrl", "packagePath", "serviceType", "packageName", "serviceUrl", "packageUrl", "projectName"], "wsdlLocation": ["wllFolder", "wssdFolder", "awsdlLocation", "wddlLocation", "awslDirectory", "wsllFolder", "wssdAddress", "wsDLUrl", "wslLocation", "wslpDirectory", "wslUrl", "wsllAddress", "wdlAddress", "wslFile", "awslFile", "wsslFolder", "wdlFile", "wddlFile", "wdlFolder", "wllFile", "wslpLocation", "awsdlDirectory", "awslUrl", "wslDirectory", "awsdlFile", "wslFolder", "wsdlDirectory", "wddlFolder", "wsllLocation", "wsDLFile", "wsslLocation", "wsdlFolder", "wsDLLocation", "awsdlUrl", "wsllUrl", "wsslFile", "wllLocation", "wssdLocation", "wddlDirectory", "wsdlFile", "wsdlUrl", "wsslAddress", "wsdlAddress", "wsllFile", "wdlDirectory", "wslpFolder", "wdlLocation", "wssdFile", "wslpFile", "wllAddress", "awslLocation", "wsDLDirectory", "wsllDirectory"], "endpoint": ["endPoint", "endination", "enPoint", " endaddress", "Endword", "endpointer", " endocol", " endPoint", " endpo", "EndPoint", "Endination", "Endpoint", "ENDpoint", "enpointer", "endsword", "startaddress", "endpo", "startpointer", "Endpoints", "startPoint", " endword", "ENDpoints", "endword", "enaddress", "enination", "endsocol", "startpoint", "enpoint", "ENDPoint", " endpointer", "endspo", "endaddress", "Endocol", "endspoint", "endocol", "enpoints", "endpoints", "ENDination", "Endpo"], "fileLocation": ["FILEUrl", " fileURI", "FileURI", " fileUrl", "fileURI", " fileDirectory", "FILEDirectory", "fileUrl", "fileDirectory", "FileDirectory", "FILELocation", "FileLocation", "FileUrl", "FILEURI"], "tempDir": [" temporaryPath", "TempDirectory", " tempVer", "tmpDir", " tempDirectory", "tmpPath", "TempPath", " tempdir", " tempPath", "TempDir", "tmpDirectory", "tempdir", "Tempdir", "tempDirectory", "tmpVer", " temporaryVer", " temporaryDir", "tempVer", "tempPath", "tmpdir", " temporaryDirectory"], "url": ["address", "base", "client", "el", "io", "URL", "path", "log", "fl", "sl", "Url", "host", "string", "conn", "ls", "contact", "stream", "image", "ssl", "connection", "ll", "www", "config", "pull", "socket", "ur", "ul", "uri", "service", "http", "l", "source", "file", "server", "channel", "download", "coll", "open", "web", "f"], "WSDLFile": ["WDDlBase", "WSDLLFile", "WINDELPath", "WDDLFolder", "WDDLFile", "WDDlFile", "WDDLBase", "WSDDLFile", "WSDlPath", "WSDLfile", "WSDlBase", "WSDLLFiles", "WDDlFolder", "WDDLfile", "WSDLSourceFile", "WSDDLFolder", "WDDlPath", "WSDLFiles", "WSDLLFolder", "WSDLLSourceFile", "WDDlfile", "WSDELFolder", "WINDLFile", "WSDlFolder", "WSDLPath", "WINDELFiles", "WSDlfile", "WDDLPath", "WSDDLBase", "WSDELFile", "WSDLLBase", "WINDELFolder", "WSDDLfile", "WSDDLFiles", "WSDDLPath", "WINDELFile", "WSDLLfile", "WSDlFile", "WSDELFiles", "WSDlSourceFile", "WSDDLSourceFile", "WINDLFolder", "WSDLLPath", "WSDLBase", "WDDlSourceFile", "WDDLSourceFile", "WSDLFolder", "WSDELPath", "WINDLFiles", "WINDLPath"], "tmpWSDLFile": ["tmpWDDELUrl", "tmpWSDDLLocation", "tmpWSDELFile", "tmpWSDDLFiles", "tmpWSDLLocation", "tmpWDDELFile", "tmpWDDlFile", "tmpWSDLFiles", "tmpWSDlFolder", "tmpWSDLLFolder", "tmpWDDLFile", "tmpWSDELFiles", "tmpWSDlLocation", "tmpWDDLLocation", "tmpWSDlFiles", "tmpWSDlFile", "tmpWDDlFolder", "tmpWDDLUrl", "tmpWSDlUrl", "tmpWSDLLFile", "tmpWSDLFolder", "tmpWDDELLocation", "tmpWSDELFolder", "tmpWSDELUrl", "tmpWDDlFiles", "tmpWSDLLUrl", "tmpWSDLUrl", "tmpWDDlUrl", "tmpWDDELFiles", "tmpWSDDLFile", "tmpWDDLFiles", "tmpWSDLLFiles", "tmpWDDLFolder", "tmpWSDDLUrl", "tmpWSDELLocation"], "inputFile": ["outputDir", " inputFactory", "InputFactory", "inputDir", " inputStream", "Inputfile", " inputFiles", " inputBuffer", "tempBuffer", " inputPage", "tempPlace", "requestfile", "InputDir", "inFile", " inputBase", "inputPage", "InputFile", "inputFactory", "tempUrl", "infile", "inputStream", "tempFactory", "tempPage", "tempFile", "tempBase", "InputUrl", "InputFiles", " inputfile", " inputUrl", "InputPlace", "inputFiles", " inputPlace", "outputFiles", "outputfile", "requestStream", "InputBuffer", "requestFiles", "inputPlace", "inputUrl", "inputBase", " inputDir", "requestFile", "inDir", "tempfile", "InputBase", "inputBuffer", "InputPage", "inPage", "InputStream", "outputFile", "inputfile"], "tmpFile": ["TempFiles", " tmpFiles", "TempDirectory", " tmpDirectory", "uploadStream", "tempDocument", "uploadFile", "TempFile", "inputDocument", "tmpStream", "inputStream", "tempPage", "tempFile", "tmpDirectory", "tmpPage", "tempDirectory", "inputFiles", "tempStream", "TempPage", "tempFiles", "tmpFiles", "uploadDocument", " tmpPage", "uploadFiles"], "in": ["gin", "ins", "din", "reader", "IN", "client", "login", "bin", "id", "inc", "input", "In", "conn", "on", "inner", "image", "c", "lock", "m", "ssl", "connection", "r", "again", "socket", "win", "inn", "p", "pin", "is", "l", "data", "source", "file", "up", "lin", "init", "impl", "f"], "out": ["net", "error", "OUT", "client", "outs", "IN", "cache", "output", "bin", "io", "inc", "log", "input", "conn", "conv", "on", "inner", "In", "name", "to", "image", "err", "c", "Out", "writer", "connection", "again", "parent", "o", "co", "socket", "sync", "outer", "timeout", "copy", "line", "source", "channel", "file", "up", "ch", "server", "group", "part", "conf", "can"], "con": ["bc", "cm", "gin", "ins", "thin", "uc", "client", "IN", "un", "ran", "com", "inc", "connect", "conn", "conv", "inner", "c", "plain", "en", "ssl", "connection", "rec", "co", "fc", "socket", "sync", "Con", "win", "close", "CON", "rc", "channel", "ch", "cn", "kin", "nc", "Conn", "open", "ctrl", "conf", "can"], "fileLength": ["Filelength", " fileSize", "FileWidth", "channelWidth", "contentLen", " fileLen", "channelLen", "fileWidth", "FileLength", "filelength", "fileLen", " filelength", "contentlength", " fileWidth", "FileSize", "channelSize", "fileSize", "contentLength", "channelLength", "contentSize", "FileLen"], "channelIn": ["ChannelOut", "characterIN", "connectionOut", "Channelin", "characterin", "resourceIN", "connectionIn", "ChannelIN", " channelIN", "channelConn", "connectionConn", "resourcein", " channelConn", "characterOut", "resourceIn", "ChannelConn", "resourceOut", "ChannelIn", "connectionin", "channelIN", " channelin", "channelin", "characterIn"], "channelOut": ["chanOUT", "ChannelOut", "connectionOutput", "connectionOut", "ChannelOutput", "ChannelOutside", " channelOutput", "connectionIn", "channelOutside", "channelout", "connectionOutside", "connectionout", "channelOutput", "channelOUT", "ChannelOUT", "canIn", "canOUT", "ChannelIn", " channelout", "canOut", "chanOut", "canOutside", "chanOutside", "chanIn", "chanout", "Channelout"], "tmpDocument": ["tmpDoc", "tmFile", "tmNode", "newContent", " tmpDoc", "mpDoc", "tmpNode", "newFile", "tempDoc", " tmpContent", "tempdocument", "tempDocument", " tmpNode", "mpDocument", "tmpContent", "tempFile", "newDocument", "tmpdocument", "tempContent", "mpFile", "tmDocument", " tmpdocument", "newdocument", "mpNode", "tempNode", "tmdocument"], "nl1": ["dl1", "arlone", "dl0", "NL11", "kl1", "ln1", "klFirst", "nl5", "ln6", "arlFirst", "ln2", "klone", "arl5", "nl6", "nn11", "NL6", "NL0", "nn6", "nl11", "jl1", "nl0", "jlone", "jl5", "dl2", "kl5", "nn2", "nn0", "nl2", "nlFirst", "NL2", "nlone", "nn1", "ln11", "jlFirst", "NL1", "arl1"], "i": ["qi", "v", "z", "ip", "ai", "ti", "I", "uli", "e", "id", "io", "iu", "xi", "ini", "index", "eni", "ui", "li", "u", "hi", "multi", "ci", "si", "mi", "phi", "ii", "m", "y", "j", "ie", "info", "b", "n", "o", "slice", "ri", "uri", "p", "ix", "gi", "fi", "it", "abi", "di", "oi", "l", "ni", "d", "chi", "yi", "ji", "f", "part", "mu", "bi", "pi"], "node1": ["package91", "Node91", "packageOne", "NodeOne", "packageone", "Node0", "shape1", " node91", "node2", "layer91", "layer1", "n0", "layerOne", "n1", "n2", "node0", "nOne", "Node1", "package1", "layer2", "shapeone", "nodeOne", " nodeone", " node0", "nodeone", "shapeOne", "node91", "shape91", " nodeOne", " node2", "Node2"], "tmpOut": [" tmpOUT", "txtOut", "vmOUT", "ptyOut", " tmpWriter", "tempOUT", "tempWriter", "txtOutput", "tempIn", "ptyIn", "tempOut", "tmpWriter", "vmOut", "tempFile", "ptyOutput", "cacheFile", "tempout", "tmpOUT", "tempOutput", "txtout", "cacheOut", "txtWriter", "cacheOUT", "vmIn", "ptyout", "tmpout", " tmpIn", "cacheIn", "tmpIn", " tmpout", "tmpOutput", " tmpOutput", "vmout"], "retVal": ["valRet", "valval", "retObj", "retval", " retval", "retRet", "RETval", "RETObj", " retObj", " retRet", "valObj", "valVal", "RETVal", "RETRet"]}}
{"id1": "21488518", "id2": "9846843", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"createNew": ["createOpen", "resourceResource", "createResource", "resourceOpen", "openNew", "openCopy", "createCopy", "openResource", "openOpen", "resourceNew", "newResource", "newCopy", "resourceCopy", "newNew", "newOpen"], "name": ["address", "url", "on", "base", "client", "alias", "title", "e", "comment", "id", "current", "ame", "none", "model", "ename", "path", "Name", "folder", "one", "x", "old", "label", "default", "filename", "string", "time", "end", "word", "named", "ext", "size", "prefix", "image", "ui", "missing", "no", "self", "large", "code", "username", "type", "connection", "class", "number", "n", "parent", "directory", "anc", "office", "resource", "common", "key", "content", "search", "non", "ix", "data", "file", "style", "member", "value", "full", "names", "part", "NAME"], "in": ["exec", "ins", "thin", "reader", "din", "IN", "login", "bin", "id", "inc", "raw", "ini", "input", "In", "inner", "size", "image", "len", "read", "i", "connection", "slice", "diff", "win", "buffer", "resource", "plus", "source", "data", "up", "file", "work", "init", "src", "pass", "con", "record"], "length": ["url", "level", "id", "load", "path", "filename", "sequence", "offset", "time", "len", "duration", "Length", "type", "count", "ength", "number", "body", "padding", "buffer", "timeout", "bytes", "content", "line", "width", "password", "limit", "size"], "contentType": ["resourcePath", "ContentType", "resourcetype", " contentPath", "contentLength", " contentLength", "ContentLength", "resourceType", "contenttype", "resourceLength", " contenttype", "contentPath", "Contenttype", "ContentPath"], "dest": ["de", "result", "cont", "thin", "img", "sup", "prop", "output", "tmp", "comb", "zip", "tx", "folder", "target", "flat", "upload", "Dest", "transform", "route", "orig", "desc", "parent", "cdn", "config", "wb", "dc", "done", "store", "source", "destroy", "tif", "dir", "dist", "gz", "d", " destination", "src", "trip", "later", "home", "opt", "trans", "txt", "conf", "temp"], "out": ["exec", "url", "result", "img", "client", "OUT", "outs", "cache", "output", "bin", "view", "exp", "io", "zip", "path", "log", "conn", "obj", "ext", "cmd", "image", "lock", "err", "this", "Out", "writer", "connection", "null", "object", "ex", "again", "o", "parent", "sync", "socket", "buffer", "resource", "flush", "copy", "line", "data", "source", "file", "pool", "channel", "password", "server", "page", "up", "gz", "f", "temp"], "request": ["complete", "external", "url", "base", "client", "job", "project", "re", "call", "QUEST", "transfer", "use", "child", "path", "xml", "rer", "respect", "remote", "input", "ext", "friend", "upload", "rate", "type", "reference", "forward", "report", "pe", "user", "route", "directory", "object", "config", "query", "wheel", "buffer", "resource", "get", "Request", "access", "store", "claim", "req", "instance", "quest", "open", "response"]}}
{"id1": "13233761", "id2": "23531898", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 1, "substitutes": {"executeUpdateTransaction": [" executeUpdateTx", "executeUpdateStatement", " executeDatabaseTx", "executeUpdateTx", "executeDatabaseTransaction", "executeDatabaseTx", " executeDatabaseSession", "executeDatabaseStatement", "executeQuerySession", " executeDatabaseTransaction", "executeQueryStatement", "executeInsertSession", "executeUpdateSession", " executeUpdateSession", "executeInsertTx", "executeInsertTransaction", "executeDatabaseSession", " executeDatabaseStatement", "executeInsertStatement", " executeUpdateStatement", "executeQueryTx", "executeQueryTransaction"], "queries": ["questands", "blests", "commips", "bleries", "compests", "questires", "squeries", "commires", "squests", "squands", "quands", "questeries", "squires", "squips", "compands", "commands", "commeries", "questips", "blands", "comperies", "quips", "blips", "quests", "compips", "quires"], "autoCommit": ["AutoCommits", "AutoDebit", " autoCommitted", " autoComitted", "autocommit", "autocommmit", "autoCompits", "autoommit", "autoCommits", "autoommmit", "autoommitted", "autoDebmit", "autoDebit", "autoCommitted", "AutoDebrit", " autoComits", "AutoCommit", "autoommits", "autoComit", "autocommrit", "autoComits", " autoCommits", "autoCompmit", "AutoDebmit", " autoCommmit", "autocommits", "autoDebrit", "autoCompitted", "AutoCommmit", "AutoDebits", "autoDebits", "autoCommrit", "autoComitted", "autoCompit", "autoCommmit", "autoComrit", "AutoCommrit", " autoComit"], "iterator": ["started", "reader", "ter", "finder", "metadata", "runners", "ator", "interstitial", "vector", "series", "cher", "index", "creator", "former", "pointer", "start", "sequence", "string", "context", "end", "stream", "inner", "section", "set", "next", "database", "starter", "Iterator", "population", "step", "ie", "i", "info", "connection", "encer", "handler", "internet", "slice", "list", "walker", "gener", "inst", "loader", "division", "ski", "iter", "outer", "adder", "done", "consider", "parser", "entry", "data", "filter", "init", "loop", "instance", "later", "collection", "runner", "size", "inter"], "query": ["result", "Query", "call", "str", "command", "row", "sql", "q", "string", "sequence", "name", "action", "next", "expression", "sq", "connection", "ql", "join", "rule", "press", "update", "message", "uri", "table", "qu", "key", "condition", "search", "commit", "data", "entry", "question", "filter", "style", "record", "value", "script", "comment", "select"], "statement": ["result", "stat", "use", "command", "function", "session", "sql", "mt", "string", "start", "state", "s", "conn", "sequence", "action", "section", "next", "database", "si", "storage", "expression", "element", "connection", "join", "ment", "inst", "table", "parser", "usage", "flush", "document", "condition", "commit", "data", "execute", "style", "Statement", "script", "unit", "comment", "response"]}}
{"id1": "12146394", "id2": "8164056", "code1": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "code2": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "label": 1, "substitutes": {"md5Crypt": ["md5crypt", "md6crypt", "md2Key", "MD5Hash", "MD5Key", "md4Crypt", "md5Hash", "MD2crypt", "md6Hash", "md2Crypt", "md4Key", "MD2Hash", "md4Hash", "md2Hash", "MD5Crypt", "md4crypt", "md6Crypt", "MD5crypt", "md6Key", "md2crypt", "MD2Crypt", "md5Key", "MD2Key"], "key": ["air", "hash", "pair", "cy", "cache", "blow", "id", "row", "core", "seed", "name", "length", "ssl", "empty", "message", "date", "fee", "cookie", "data", "server", "value", "full", "size", "token", "magic", "my", "transfer", "use", "x", "KEY", "input", "string", "state", "word", "lock", "cer", "user", "number", "rule", "char", "password", "proof", "carry", "kid", "k", "base", "call", "scope", "zip", "ace", "cert", "money", "kh", "no", "code", "y", "m", "go", "parent", "list", "copy", "source", "shift", "ke", "secret", "ask", "temp", "here", "wire", "ip", "sign", "none", "kw", "time", "ee", "image", "order", "this", "self", "year", "type", "element", "connection", "root", "text", "any", "trust", "sync", "service", "version", "point", "Key", "phrase", "other", "power", "ch", "req", "ce", "material"], "salt": ["seskey", "southart", "sol", "SALT", "Sodium", "skey", "sesort", "svalt", "sesul", "sval", "asalt", "southodium", "southift", "sesart", " sol", " sALT", "ssol", "svALT", "sort", "sodium", "osift", " sart", "ssalt", "ssALT", "sesol", "ssass", "sul", "southalt", "svort", "sass", "ssecret", "osALT", "Ssecret", "assecret", "southALT", "sesal", "asALT", " skey", "osul", "asal", "Sal", "sesass", " sass", "osalt", "sALT", "sart", "sift", "Salt", "sesift", "southsecret", " sift", " ssecret", " sodium", "sal", "sesalt", "sesALT", "sessecret"], "_md": ["_mand", " _amd", "_mg", "\u00a0dm", "copykey", "_m", " _m", "\u00a0mode", " _cmd", "localcmd", " _key", "_dm", "__cmd", "Newdm", "copycmd", " _db", "copymd", "_MD", "\u00a0md", "\u00a0mand", " _dm", "localmg", "\u00a0nm", "Newcmd", "Newamd", "\u00a0m", "__md", "_amd", "copydm", " _nm", "__amd", "localmd", "_db", "__dm", "\u00a0cmd", "_nm", " _MD", "_mode", "_mb", "_key", "_cmd", "Newmd", "localmb"], "md2": ["md5", "md02", "hdTwo", " md62", "MD3", " md5", " mdTwo", " md32", "amd02", "amd4", "md32", "amd32", "cmd1", "cmd4", "MD62", "MD4", "MD2", "md62", "amd62", "cmd2", " md1", "amdTwo", "hd62", "cmd62", "MD1", "mdTwo", "cmd5", "hd2", "md1", "amd2", " md02", "hd32", " md4", "md4", "MD5", "cmd3", "cmd02"], "abyFinal": ["babyfinal", "BabyFinish", "aberFinal", "butFinal", "abyLast", "babyLast", "BabyFull", "abyfinal", "babyResult", "babyTotal", "BabyLast", "amySpecial", "sayFinal", "amySuccess", "abySpecial", "abiesResult", "abyInitial", "rayFinal", "babyFinal", "aberInitial", "abeFinal", "andyfinal", "andyLast", "abiesSuccess", "abyTotal", "butLast", "aberTotal", "abeFull", "sayInitial", "amyFinal", "andyFinal", "abeFinish", "abyFull", "babyInitial", "abySuccess", "abiesFinal", "andyInitial", "abiesFinish", "abeLast", "babySuccess", "babySpecial", "rayInitial", "abyResult", "abyFinish", "rayLast", "BabyFinal", "amyResult", "amyInitial", "abiesFull", "butInitial", "aberfinal", "abiesLast", "Babyfinal", "saySpecial", "andyTotal"], "n": ["net", "v", "z", "k", "syn", "yn", "ng", "N", "br", "un", "nan", "nb", "not", "none", "x", "node", "ns", "conn", "name", "nor", "on", "byn", "c", "no", "len", "nn", "pn", "adj", "np", "y", "m", "all", "t", "en", "a", "r", "g", "b", "nu", "span", "number", "o", "nt", "nw", "ner", "sn", "gn", "inn", "p", "min", "dn", "mn", "non", "l", "na", "cn", "fn", "don", "ni", "num", "d", "ne", "ny", "nc", "network", "f"], "j": ["qi", "jp", "J", "z", "k", "bj", "v", "uj", "ja", "I", "io", "jc", "xi", "x", "index", "q", "ind", "u", "li", "section", "c", "ci", "si", "ij", "adj", "aj", "y", "ii", "ie", "b", "js", "o", "dj", "fr", "p", "l", "jl", "di", "ni", "d", "num", "yi", "ne", "ji", "jj"], "i": ["qi", "ai", "ani", "ti", "mini", "I", "e", "io", "iu", "xi", "ini", "index", "eni", "ui", "li", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "ie", "ali", "o", "ki", "zi", "ri", "p", "gi", "fi", "di", "oi", "ni", "yi", "chi", "ji", "gu", "mu", "bi", "pi"], "sbPasswd": ["sbSecretwd", "cbParw", "sbFailwd", "sfPasswd", "sbCrw", "sbPassWD", "bbParwd", "cbParwd", "sfSecretword", "sfPassword", "sbParword", "sbSecretword", "sbFailw", "sfSecretwd", "bbParw", "cbPassphrase", "sbParw", "sbPassw", "sbCrwords", "bbPassw", "cbParword", "sbFailword", "rbCrword", "rbPasswd", "sbCrWD", "rbPassword", "rbPassWD", "rbCrw", "bbParword", "rbCrwd", "sbPassword", "rbCrWD", "bbPasswd", "sbCrrc", "sbSecretw", "sbPassphrase", "sfSecretwords", "sbParwd", "sbCrwd", "sbPassrc", "cbPassword", "bbParrc", "bbPassword", "rbPassw", "cbParphrase", "sbParrc", "sbFailphrase", "sfPasswords", "sbParWD", "bbPassrc", "sfSecretw", "sfPassw", "sbParwords", "sbCrword", "sbSecretwords", "cbPassw", "sbParphrase", "sbPasswords", "cbPasswd"], "md3": ["amd15", "ms03", "mag23", "amd23", "mag512", "MD3", " md53", "mag15", "amd512", "cmd1", " md23", "amdthird", " md03", "md512", "mdthree", "ms3", "mand23", "MD53", "MD2", "mand512", "cmd2", " md1", "md23", "mand15", "msthree", "MD1", "md1", "cmd23", "md03", "amd03", "md15", "md53", "MD23", "mag3", "mand3", "msthird", " mdthree", "amdthree", "mdthird", "amd3", "cmd53", "cmd3", " mdthird"]}}
{"id1": "18504192", "id2": "15797402", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "in": ["url", "base", "ins", "reader", "IN", "login", "bin", "id", "io", "inc", "old", "ini", "index", "input", "In", "name", "inner", "image", "c", "m", "or", "at", "i", "info", "b", "again", "parent", "diff", "buffer", "inn", "min", "copy", "data", "file", "d", "src", "ac", "part"], "out": ["exec", "external", "base", "OUT", "client", "outs", "cache", "w", "call", "output", "io", "inc", "target", "name", "conn", "obj", "string", "c", "err", "prefix", "Out", "writer", "connection", "b", "ex", "n", "object", "again", "o", "dest", "p", "copy", "point", "line", "data", "file", "password", "part", "temp"], "source": ["ource", "slave", "reader", "client", "project", "scope", "view", "use", "proxy", "sl", "input", "target", "start", "core", "secure", "stream", "Source", "settings", "self", "storage", "clone", "ssl", "ie", "i", "connection", "component", "writer", "null", "parent", "sin", "dest", "slice", "sync", "ources", "iter", "service", "get", "copy", "from", "channel", "se", "server", "src", "origin", "unit", "size", "SOURCE"], "destination": ["destinator", "testinations", "Destinated", "Destification", "Destining", " destining", "Destination", "testinated", "dependification", " destinations", "destinations", "declification", "declinated", " destinator", "declinator", "contining", "dependinated", "testination", " destinated", "declination", "dependination", "destinated", "testinator", "destining", "contination", "dependinator", "destification", "Destinations", "continated", "Destinator", "continator"]}}
{"id1": "7351534", "id2": "8770016", "code1": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "code2": "    public InputStream loadResource(String location) throws GenericConfigException {\n        URL url = getURL(location);\n        try {\n            return url.openStream();\n        } catch (java.io.IOException e) {\n            throw new GenericConfigException(\"Error opening URL resource at location [\" + url.toExternalForm() + \"]\", e);\n        }\n    }\n", "label": 0, "substitutes": {"getStreamFromSystemIdentifier": ["getStreamFromSystemIdifier", "getStreamFromsystemidentifier", "getStreamFromsystemIdentifier", "getStreamFromSystemidentification", "getStreamFromSystemIdentifer", "getStreamFromSystemIdifer", "getStreamFromsystemidentifiers", "getStreamFromSystemidentifer", "getStreamFromsystemIdentifer", "getStreamFromsystemidentifer", "getStreamFromsystemIdentifiers", "getStreamFromSystemIdification", "getStreamFromSystemIdifiers", "getStreamFromSystemidentifier", "getStreamFromSystemIdentifiers", "getStreamFromsystemIdentification", "getStreamFromSystemidentifiers", "getStreamFromsystemidentification", "getStreamFromSystemIdentification"], "systemId": ["ystemName", "systemPath", "machineid", "customId", " systemID", "customid", "serverid", "machineID", "customID", "SystemID", "systemName", "ystemid", "securityID", " systemName", " systemPath", "sysid", "SystemId", "systemID", "servicePath", "Systemid", "sysPath", "SystemName", "securityId", " systemid", "serverID", "serviceId", "securityid", "systemid", "serviceid", "customName", "ystemID", "ystemId", "machineId", "serverId", "sysId", "securityName"], "resolver": ["resolution", "presolve", "resol", "Resolver", "Resolution", "resolving", "presolver", "reolver", "reolve", " resolution", "Resol", "resolve", "Resolving", "Resolve", " resol", "presolving", " resolving", " resolve", "reol", "reolving", "presolution", "reolution"], "source": ["ource", "slave", "position", "result", "reader", "client", "scope", "parse", "e", "id", "proxy", "model", "container", "path", "sl", "remote", "target", "session", "creator", "string", "seed", "name", "secure", "context", "Source", "resources", "spec", "storage", "large", "entity", "type", "element", "info", "component", "connection", "class", "i", "null", "object", "parent", "text", "o", "handler", "slice", "sync", "ources", "uri", "service", "resource", "iter", "document", "from", "channel", "data", "server", "src", "instance", "unit", "size", "ce", "response", "SOURCE"], "stream": ["result", "cont", "client", "reader", "clean", "flash", "allow", "view", "output", "port", "feed", "zip", "load", "child", "model", "proxy", "valid", "path", "log", "sl", "row", "input", "session", "host", "string", "length", "context", "image", "Stream", "read", "or", "event", "live", "connection", "report", "object", "body", "parent", "dest", "handler", "speed", "message", "buffer", "service", "resource", "steam", "wrapper", "wh", "form", "document", "content", "channel", "pool", "data", "file", "server", "src", "instance", "trans", "sw", "response", "temp"], "url": ["ource", "address", "base", "client", "id", "feed", "zip", "URL", "proxy", "path", "sl", "Url", "host", "location", "string", "gl", "image", "link", "large", "ssl", "connection", "object", "loc", "loader", "uri", "service", "resource", "http", "l", "page", "file", "server", "channel", "data", "src", "web", "control"]}}
{"id1": "350482", "id2": "742465", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doReleasecheck", " doBuildcheck", " doVersionWork", "doReleaseTest", "doVERSIONcheck", "doversionCheck", " doReleasecheck", "doBuildCheck", "doVersionTest", " doBuildWork", " doVersionTest", "doversioncheck", "doVersioncheck", "doversionTest", "doVERSIONCheck", "doVersionWork", " doReleaseCheck", "doReleaseCheck", " doBuildCheck", "doVERSIONWork", "doBuildWork", "doVERSIONTest", "doBuildTest", " doBuildTest", "doBuildcheck", " doReleaseTest", "doReleaseWork", " doVersioncheck"], "view": ["v", "reader", "client", "cache", "change", "window", "e", "port", "comment", "use", "app", "el", "model", "VIEW", "request", "div", "input", "row", "session", "q", "out", "screen", "ui", "View", "image", "lock", "this", "widget", "self", "sel", "event", "box", "show", "html", "object", "body", "gui", "see", "config", "edit", "layout", "block", "update", "buffer", "display", "views", "vis", "form", "http", "page", "l", "accept", "server", "style", "full", "gu", "can", "cell"], "url": ["address", "base", "client", "bb", "ob", "zip", "URL", "path", "log", "sl", "input", "Url", "host", "string", "stream", "image", "hub", "build", "lib", "ssl", "connection", "user", "browser", "ll", "socket", "loader", "buffer", "uri", "service", "resource", "bel", "http", "l", "source", "channel", "file", "server", "open", "web", "blog", "f"], "in": ["gin", "ins", "reader", "din", "IN", "login", "isin", "inc", "bis", "ini", "input", "out", "In", "binary", "s", "stream", "inner", "i", "b", "n", "sin", "socket", "nin", "win", "buffer", "resource", "inn", "is", "cin", "lin", "data", "file", "source", "init", "rin", "con", "ac", "as"], "bin": ["bn", "gin", "reader", "din", "IN", "bb", "nb", "spin", "log", "input", "border", "out", "binary", "fin", "inner", "ln", "lock", "bot", "ruby", "lib", "oin", "b", "browser", "body", "sin", "socket", "loader", "win", "buffer", "inn", "pin", "abi", "cin", "lin", "data", "file", "inline", "init", "kin", "con", "part", "record", "bi", "run"], "line": ["lc", "cl", "base", "ip", "job", "str", "parse", "el", "e", "site", "lo", "id", "valid", "load", "model", "log", "le", "row", "ge", "nl", "string", "name", "end", "Line", "lines", "word", "no", "link", "code", "LINE", "look", "day", "layer", "band", "i", "pe", "definition", "b", "text", "object", "rule", "block", "message", "key", "non", "lf", "l", "lin", "data", "file", "source", "page", "style", "inline", "entry", "up", "pass", "letter", "split", "home", "part", "ine", "unit", "comment", "cell"], "develBuild": ["deVELRun", "deVELBuild", "deelRun", "dellRun", "devenRelease", "desvelbuild", "deelBuilder", "DEVELBuilder", "desvelRun", "DEvelbuild", "DEVELBuild", "DEVELbuild", "deployBuilder", "develBuilt", "deployRun", "dewardBuild", "DEvelBuild", "deVELBuilt", "deVELbuild", "desvenBuilder", "deelBuild", "devenBuilder", "dewardbuild", "dellRelease", "deelRelease", "desvenbuild", "desvenBuilt", "develBuilder", "deployBuild", "dewardBuilder", "devenBuild", "develRun", "desvelBuild", "deploybuild", "dewardBuilt", "desvenBuild", "dellBuild", "devenbuild", "desvelBuilt", "desvenRun", "desvelBuilder", "develbuild", "develRelease", "dellBuilder", "DEVELBuilt", "deviousBuild", "devenRun", "deployBuilt", "DEvelBuilder", "desvelRelease", "devenBuilt", "desvenRelease", "deviousbuild", "deviousBuilt", "DEvelBuilt", "deVELBuilder"], "stableBuild": ["validBuilder", "prettybuild", "prettyBuild", "secureBuilder", "latestbuild", "validBuild", "baseBuild", "baseBuilder", "compatibleBuilder", "stableVersion", " stableBuilder", "secureBuild", "staticBuild", "staticBuilder", "compatibleBuild", "prettyVersion", "validbuild", "securebuild", " stablebuild", "latestBuild", "compatiblebuild", " stableVersion", "basebuild", "baseVersion", "latestBuilder", "stablebuild", "stableBuilder", "staticbuild", "prettyBuilder"]}}
{"id1": "6271502", "id2": "18613870", "code1": "    @Override\n    public InputStream getResourceByClassName(String className) {\n        URL url = resourceFetcher.getResource(\"/fisce_scripts/\" + className + \".class\");\n        if (url == null) {\n            return null;\n        } else {\n            try {\n                return url.openStream();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"getResourceByClassName": ["getResourceForclassname", "getResourceByFileName", "getResourceForclassString", "getResourceByclassString", "getResourceByFilename", "getResourceByFileString", "getResourceByclassname", "getResourceForClassString", "getResourceByClassname", "getResourceByClassString", "getResourceForClassname", "getResourceByclassName", "getResourceForClassName", "getResourceForclassName"], "className": ["ClassType", "ClassPath", "scriptName", "classname", "scriptPath", "scriptType", "shortname", " classType", " classname", "classPath", "shortName", "scriptname", "shortTitle", "classTitle", " classTitle", "ClassName", "classType", " classPath", "Classname", "shortPath", "ClassTitle"], "url": ["address", "base", "job", "rel", "str", "ob", "window", "e", "el", "zip", "feed", "URL", "path", "xml", "log", "sl", "Url", "location", "string", "name", "ls", "image", "orb", "resources", "org", "event", "ssl", "element", "class", "b", "object", "www", "loader", "buffer", "lr", "service", "resource", "api", "bel", "uri", "http", "plug", "l", "page", "source", "file", "server", "data", "ref", "instance", "coll", "impl", "web", "rl", "f"]}}
{"id1": "9826240", "id2": "14691829", "code1": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 1, "substitutes": {"checkHashBack": [" checkHashBACK", "checkHashback", "checkKeyFront", "checkSumBACK", " checkhashBACK", "checkhashBack", " checkhashBack", " checkhashFront", "checkKeyBack", "checkKeyback", "checkHashFront", " checkhashback", "checkhashback", " checkHashback", " checkHashFront", "checkSumFront", "checkHashBACK", "checkhashFront", "checkSumBack", "checkKeyBACK", "checkhashBACK", "checkSumback"], "facade": [" facace", "Facace", "Facce", " facide", "factade", "facase", "factoke", "humade", "humede", "facades", "factse", "facoke", "factce", "face", "factase", "Facoke", "humce", " facede", "humase", " facase", "Facse", "Facide", " facades", "fades", "Facade", "fase", "factide", "Facede", "fse", "facede", " facoke", "facace", " facale", "facse", "Facase", "Facale", "facce", " facce", "facale", "fale", "fade", "foke", "facide", "Facades"], "req": ["exec", "jp", "fp", "url", "base", "pro", "required", "cache", "util", "w", "view", "app", "sem", "cb", "requ", "proc", "rr", "cur", "request", "xml", "rf", "q", "res", "obj", "prof", "wx", "err", "pkg", "rt", "require", "sq", "info", "r", "crit", "def", "rec", "pull", "query", "qq", "fr", "ru", "resource", "rb", "form", "Request", "http", "resp", "pb", "gr", "ref", "ctx", "f", "response", "cmp", "pr", "temp"], "txtTransactionID": ["txtTaskType", "txtOrderId", "txtOperationType", "txtTaskInfo", "textTransactionIP", "textTaskName", "txtJobId", "txtOrderName", "textTransactionId", "txtTransactionInfo", "txtTransactionType", "txtJobID", "textTaskID", "txtOperationInfo", "textTransactionName", "textTaskIP", "txtOrderType", "txtTransactionId", "txtOperationIP", "textTaskId", "txtTransactionName", "textTransactionInfo", "txtJobInfo", "textTransactionID", "txtTaskId", "txtOrderID", "textTaskInfo", "txtTaskID", "txtTaskIP", "textTaskType", "txtTaskName", "txtOperationName", "txtOperationId", "txtOperationID", "textTransactionType", "txtTransactionIP", "txtJobIP"], "txtOrderTotal": ["xtOrderLast", "xtOrderToken", "txtRequestInfo", "xtOrdertotal", "txtOrderToken", "txtAddressInfo", "txtRequestLast", "txtOrderInfo", "xtBlockNum", "txtJobToken", "txtJobTotal", "xtOrderNum", "xtRequesttotal", "txtBlockToken", "xtBlockToken", "txtOrderNum", "txtJobtotal", "txtEventInfo", "xtRequestLast", "xtRequestInfo", "txtBlockNum", "xtOrderInfo", "txtRequesttotal", "txtAddressTotal", "txtBlockTotal", "txtJobInfo", "xtOrderTotal", "txtBlockInfo", "txtJobNum", "txtAddressLast", "txtOrdertotal", "txtEventTotal", "xtBlockInfo", "txtEventNum", "txtEventToken", "txtJobLast", "txtOrderLast", "txtAddresstotal", "txtRequestTotal", "xtBlockTotal", "xtRequestTotal"], "txtShopId": ["txtOrderId", "txtFactoryName", "textShopName", "txtShopName", "txtJobId", "txtOrderInfo", "textJobName", "txtOrderName", "txtJobID", "textShopID", "textJobID", "textJobId", "txtFactoryID", "txtJobName", "txtSessionId", "textJobInfo", "txtSessionName", "txtJobInfo", "txtShopInfo", "txtOrderID", "textShopId", "txtShopID", "txtSessionInfo", "txtFactoryId", "txtFactoryInfo", "textShopInfo", "txtSessionID"], "txtArtCurrency": ["txtArtcurrency", "txtartCulture", "txtartCerc", "txtARTCulture", "txtArtAculture", "txtArtCulture", "txtartcurrency", "txtARTSculture", "txtartCcurrency", "txtArtCurrencies", "txtArtAcerc", "txtArtculture", "txtArtCustomcurrency", "txtARTSccurrency", "txtArtCustomerc", "txtARTCurrencies", "txtArtLCcurrency", "txtArtLCurrency", "txtArtccurrency", "txtArtcurrencies", "txtArtcerc", "txtArtLCurrencies", "txtartccurrency", "txtArtScurrency", "txtArtScurrencies", "txtArtSculture", "txtartculture", "txtArtSccurrency", "txtARTScurrency", "txtArtCerc", "txtArtCcurrency", "txtArtAccurrency", "txtArtAcurrency", "txtARTCcurrency", "txtARTScurrencies", "txtartcerc", "txtArtLCulture", "txtARTCurrency", "txtArtCustomurrency", "txtArtCustomulture", "txtartCurrency"], "txtHashBack": ["txtHandleBack", "xtMessageRest", "txtHandleback", "xtHashBack", "txtSHABack", "txtHashSave", "txtStyleBACK", "xtHashBACK", "txtCheckBACK", "txtMessageReturn", "xtMessageReturn", "txtStyleback", "txtSumSave", "xtHashRest", "txtBlockBack", "textHashBack", "xtHashReturn", "txtSumBACK", "txtHashBACK", "textSumback", "txtBlockback", "txtBlockRest", "txtMessageback", "txtSumFront", "xtSumBack", "txtSHAReturn", "txtSumback", "textHashback", "xtMessageBack", "textSumFront", "txtCheckback", "textHashFront", "txtSumBack", "xtSumBACK", "txtHandleRest", "txtSHAback", "txtHashFront", "txtHashback", "txtBlockFront", "xtHashSave", "xtHashback", "textSumReturn", "txtStyleSave", "txtHandleReturn", "txtMessageBack", "txtMessageRest", "txtHashReturn", "xtSumSave", "txtCheckBack", "textHashReturn", "txtSHAFront", "textSumBack", "txtCheckSave", "xtMessageback", "txtHashRest", "txtBlockReturn", "txtStyleBack", "txtSumReturn", "xtSumback"], "hashSeed": ["hashPreseeds", " hashRee", " hashSee", "hashSerieseeds", "hashSeeds", "hashSlead", "hashSlql", "HashSleeds", "HashSlql", "hashSee", "HashSeed", "hashRead", " hashReed", "hashReed", "HashSeeds", " hashReeds", "hashReeds", "HashSlees", "hashSerieseed", "hashSlee", " hashSead", " hashRead", "HashSees", "hashPreseed", "hashRee", "HashSleed", "HashSql", " hashSeeds", "hashSleed", "hashSead", "hashSql", "hashPresees", "hashSeriesql", "hashSeriesees", "hashSlees", "hashPresql", "hashSees", "hashSleeds"], "securityValue": [" securityFile", " securityValues", "securityValues", "secureKey", " securityKey", "secureValue", " securityString", "SecurityString", "SecurityKey", "SecurityValues", "SecurityValue", "securityKey", "SecurityFile", "securityString", "securityFile", "secureValues", "secureFile", "secureString"], "digest": [" digested", "digestro", "hashest", "signEST", " digusher", " digence", "signest", " Digester", "Digence", " Digge", "hashHash", "Digge", " Digestro", "defge", "defester", "logester", "digEST", " digester", "digester", "logence", "digge", " digEST", "Diged", "hashEST", "digusher", "diged", "Digusher", "DigHash", "hashed", "digested", "DigEST", " Digested", "Digester", "Digestro", "digence", "logusher", "defest", " digestro", "digHash", "signester", "sendEST", "Digest", "Digested", "logest", " DigEST", "sendHash", "defested", "sended", "signested", "sendest", " Digest"], "array": ["pair", "address", "feature", "error", "audio", "cache", "sample", "allow", "arr", "environment", "function", "row", "string", "binary", "range", "archive", "section", "image", "angle", "order", "database", "Array", "storage", "ray", "element", "batch", "number", "object", "list", "integer", "buffer", "message", "data", "our", "arrow", "record", "instance", "value", "area", "collection"], "sb": ["su", "bc", "bj", "sv", "xb", "sup", "ib", "bb", "gb", "ob", "nb", "db", "bm", "fb", "sl", "mb", "string", "s", "bsp", "orb", "nn", "si", "sa", "sg", "ssl", "BB", "SB", "lb", "sq", "buf", "bg", "bt", "abb", "wb", "osc", "kb", "buffer", "sn", "eb", "rb", "usb", "pb", "bh", "zb", "src", "bf", "obb", "sf", "cb", "bs"], "j": ["jp", "J", "z", "bj", "k", "v", "uj", "ja", "br", "e", "jc", "x", "index", "length", "ind", "u", "li", "obj", "section", "c", "ij", "oj", "ii", "y", "aj", "m", "i", "g", "js", "n", "o", "dj", "p", "key", "ix", "jo", "dy", "l", "jl", "ch", "d", "ji", "part", "jj", "f", "pr"], "b": ["bc", "k", "job", "ib", "bb", "ob", "e", "bin", "bp", "nb", "br", "bd", "db", "x", "ba", "fb", "mb", "string", "binary", "bug", "c", "orb", "code", "a", "i", "lb", "bar", "body", "bi", "wb", "ab", "eb", "p", "rb", "l", "d", "B", "bf", "f", "cb", "bs", "be"], "hash": ["address", "url", "result", "header", "sha", "error", "ash", "cache", "rh", "flash", "handle", "cover", "db", "Hash", "gh", "kh", "memory", "image", "lock", "hex", "hh", "ruby", "build", "auth", "confirmed", "report", "html", "history", "ph", "number", "hed", "block", "message", "height", "key", "h", "search", "math", "mac", "sh", "dash", "match", "dh", "password", "oh", "value", "json", "ssh", "sum", "ha"]}}
{"id1": "10385815", "id2": "6403868", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"copy": ["exec", "send", "change", "delete", "paste", "transfer", "zip", "Copy", "put", "replace", "Transfer", "write", "upload", "Cop", "sync", "update", "get", "process", "move", "file", "download", "create", "split", "open", " Copy", "clone", "cmp"], "fileFrom": ["ioFrom", "FileStart", "fileAs", "FileTo", "FileIn", " fileStart", "FileSource", "fileSource", "fileIn", "ioTo", "ioSource", "mailFrom", "fileStart", "FileFrom", "ioStart", " fileIn", " fileSource", "mailAs", "mailTo", " fileAs", "FileAs", "mailIn"], "fileTo": ["resourceTarget", "resourceTo", "FileTO", "resourceFile", "fpFrom", " fileFile", "FileTo", "fileto", "fpto", "fileTarget", "FileFrom", " fileTO", "FileTarget", "fpTO", "resourceFrom", " fileto", " fileTarget", "FileFile", "fileTO", "fileFile", "Fileto", "fpTo"], "inputStream": [" inputFile", "outputContext", " inputSync", "inputSteam", " inputstream", "inputFile", "InputChannel", " inputSteam", "InputSync", "InputFile", " inputContext", "outputSteam", "inputContext", "inputSync", "Inputstream", "outputstream", "outputSync", "InputSteam", "inputstream", "InputContext", "InputStream", "outputFile"], "outputStream": ["inputSocket", "OutputChan", "OutputPath", " outputSteam", "writeStream", "outputChan", "inputChan", "inputSteam", "writeSteam", "outputStreamer", "OutputChannel", "OutputSteam", "writeSocket", " outputChan", "fourStreamer", "OutputStream", "outputSocket", "referenceSocket", "outputSteam", "referenceStream", "OutputStreamer", "inputPath", "writeChannel", "fourChannel", " outputPath", "referenceSteam", " outputStreamer", "fourSteam", "referenceChannel", "fourStream", "outputPath"], "inputChannel": ["outputContext", "inputSocket", "inputCam", "outputChan", "inputChan", "parentChannel", "outputPassword", "audioStream", "outputClient", "butCommand", "butContext", "parentChan", "InputChannel", " inputChan", "outputSocket", "butChan", "audioCam", " inputPassword", " inputContext", "butChannel", "inputContext", "audioChannel", "InputSocket", "InputChan", "outputCam", "parentPassword", " inputCommand", "outputCommand", "inputCommand", " inputCam", "audioClient", "inputPassword", " inputClient", "parentStream", "inputClient", "InputContext", " inputSocket", "InputStream"], "outputChannel": ["outputContext", "OutputChan", "OutputQueue", "outputChan", "inputChan", "outContext", " outputContext", "OutputChannel", "outputchannel", "outChan", " outputChan", "outStream", "OutputStream", "inputchannel", "inputContext", " outputQueue", " outputchannel", "inputQueue", "outputQueue", "OutputContext", "Outputchannel", "outChannel"]}}
{"id1": "2642914", "id2": "8490297", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarGszip", "addFileToTargz", "addFileToTargzi", "addFileToZipGarzip", "addFileToTarGsz", "addFileToZipGarz", "addFileToTarGsgz", "addFileToZipGzi", "addFileToTargx", "addFileToZipGarzi", "addFileToTarGux", "addFileToZipGszi", "addFileToTarGszi", "addFileToTarGzi", "addFileToZipGsgz", "addFileToTargzip", "addFileToZipGz", "addFileToTarGgz", "addFileToZipGzip", "addFileToTarGargz", "addFileToTarGarz", "addFileToTarGuzi", "addFileToZipGsz", "addFileToTarGuzip", "addFileToTarggz", "addFileToTarGx", "addFileToTarGuz", "addFileToZipGarx", "addFileToZipGx", "addFileToZipGgz", "addFileToZipGszip", "addFileToTarGarzip", "addFileToTarGarx", "addFileToTarGarzi", "addFileToTarGzip"], "taro": ["ptaron", "Toro", "toro", " tabo", "staco", "Taron", "tabo", " tero", "targo", "stro", "ptaco", "tamar", " taron", " tro", "ptargo", "stoo", "Tara", "tharo", "thaco", "Tamar", "stero", "atro", "Toran", "faco", "largo", "ptabo", "ptaro", "Too", "Tero", "fara", "storo", "Taro", "faro", "atargo", "lro", " taco", "laro", "tero", "atoran", "Tro", "fargo", "taco", " tara", "too", "stamar", "taron", "Tabo", "staro", "loran", "thamar", " too", "Taco", "thoro", "Targo", " targo", "tro", "tara", "toran", "ataro"], "path": ["url", "PATH", "cache", "str", "id", "folder", "log", "filename", "location", "string", "name", "pointer", "pattern", "Path", "image", "c", "type", "root", "route", "text", "directory", "object", "parent", "loc", "uri", "ath", "resource", "p", "key", "from", "data", "fn", "file", "source", "dir", "ref"], "base": ["address", "url", "cache", "absolute", "site", "id", "pre", "relative", "default", "index", "start", "string", "name", "core", "prefix", "bas", "extra", "ase", "type", "root", "b", "parent", "Base", "back", "buffer", "uri", "api", "resource", "p", "key", "from", "store", "http", "file", "server", "dir", "bf", "area", "home", "part"], "f": ["fp", "v", "cf", "url", "w", "e", "found", "feed", "tf", "of", "df", "fb", "rf", "flat", "s", "aff", "c", "this", "raf", "fe", "fa", "self", "m", "fold", "t", "j", "fx", "i", "r", "g", "b", "n", "F", "fc", "fr", "fs", "inf", "p", "fo", "form", "h", "af", "fd", "lf", "l", "fn", "file", "ref", "d", "bf", "framework", "fen", "sf", "fac"], "entryName": [" entryTime", "EntryTime", " entryType", " entryPath", "EntryType", "elementType", "fileTime", "entryPath", " entrySize", " entryname", "archiveSize", "resourceSize", "fileType", "entrySize", "archivename", "resourcename", "entryTime", "resourcePath", "entryname", "archiveName", "elementTime", "EntryPath", "filePath", "archivePath", "elementPath", "resourceName", "EntryName", "fileName", "elementName", "entryType"], "goIn": ["gaIN", "Goin", "poOut", "goIns", "poIN", "GoIns", "poIn", "GOIN", "GOOut", "coin", "loIN", "coIns", "gaIn", "GOIn", "coIn", "GOIns", "GOin", "goOut", "gaIns", "gain", "poIns", "GoIN", "GoIn", "loin", "loIn", "poin", "coOut", "goIN", "goin", "loIns"], "tarEntry": ["TarElement", "TarEntry", "tarFile", "rarEnt", " tarInfo", " tarentry", " TarEntry", "rarFile", "zipInfo", "tarElement", " tarEnt", "rarEntry", "zipEntry", "zipFile", "tarentry", " Tarentry", " TarElement", "zipEnt", "tarInfo", "rarInfo", " tarElement", " tarFile", "Tarentry", "tarEnt"], "children": ["ins", "iblings", "packages", "many", "roots", "output", "feed", "current", "ren", "which", "sub", "members", "when", "father", "kids", "parents", "name", "bars", "values", "jobs", "files", "far", "words", "all", "ools", "rows", "parent", "loc", "each", "plugins", "ul", "blocks", "well", "opens", "content", "h", "other", "pages", "data", "ports", "pool", "web", "Children", "scenes", "ales", "open", "balls", "pes"], "child": ["slave", "kid", "client", "job", "leaf", "hel", "id", "feed", "shell", "cel", "row", "name", "c", "Child", "code", "lib", "build", "or", "layer", "i", "count", "root", "connection", "parent", "cloud", "pull", "per", "draft", "key", "l", "page", "entry", "data", "file", "in", "pool", "ch", "server", "and", "channel", "comment"]}}
{"id1": "22603577", "id2": "18989018", "code1": "    public static String getFileContentFromPlugin(String path) {\n        URL url = getURLFromPlugin(path);\n        StringBuffer sb = new StringBuffer();\n        try {\n            Scanner scanner = new Scanner(url.openStream());\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                sb.append(line + \"\\n\");\n            }\n            scanner.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n        return sb.toString();\n    }\n", "code2": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "label": 0, "substitutes": {"getFileContentFromPlugin": ["getFileContentOfPlugin", "getFileContentfromFile", "getFileContentFormModule", "getFileContentfromplugin", "getFileContentFromModule", "getFileDataOfFile", "getFileDataFromModule", "getFileContentFromplugin", "getFileDataFromPlugin", "getFileContentFormFile", "getFileDataFromplugin", "getFileContentOfFile", "getFileDataOfplugin", "getFileContentOfModule", "getFileContentfromPlugin", "getFileContentFormPlugin", "getFileContentFromFile", "getFileContentfromModule", "getFileContentFormplugin", "getFileDataOfPlugin", "getFileDataFromFile", "getFileDataOfModule", "getFileContentOfplugin"], "path": ["PATH", "system", "job", "str", "id", "platform", "port", "child", "plugin", "input", "filename", "location", "name", "string", "pointer", "pattern", "Path", "stream", "image", "prefix", "code", "type", "class", "text", "object", "config", "install", "loader", "plugins", "uri", "ath", "resource", "p", "key", "content", "data", "work", "file", "entry", "dir", "src", "full", "part"], "url": ["base", "client", "job", "bb", "feed", "io", "URL", "jar", "log", "plugin", "sl", "er", "Url", "string", "ls", "stream", "image", "hub", "this", "org", "ssl", "connection", "r", "user", "b", "browser", "ll", "socket", "loader", "ur", "lr", "uri", "resource", "service", "bel", "http", "plug", "l", "page", "source", "file", "server", "download", "impl", "blog", "f"], "sb": ["bc", "fp", "sv", "job", "ib", "bb", "ob", "gb", "bp", " SB", "nb", "db", "ws", "bm", "fb", "ls", "binary", "bsp", "ruby", "sa", "bag", "sg", "storage", "ssl", "BB", "SB", "lb", "b", "buf", "bg", "bt", "wb", "buffer", "ab", "eb", "rb", "pb", "bh", "vm", "src", "bf", "erb", "sf", "comment", "cb", "gs"], "scanner": ["aninner", "Scanaster", "nerner", "caninner", "Scaner", "canner", "canning", "Scanener", " scaninner", "nerener", " scaner", "scaner", "Scanter", "scanter", "Scaninner", "caner", "scanning", "anner", "scanners", "anninner", "Scanner", "nerners", "anning", "canners", "canter", "scaninner", "annning", "Scanning", "Scanners", "scanaster", " scanaster", "scanener", "canener", "canaster", "aner", "nerter", "annner"], "line": ["cl", "lc", "base", "header", "job", "str", "e", "id", "feed", " inline", "model", " Line", "sl", "lined", "row", "string", "Line", "lines", "section", "next", "link", "character", "code", " lines", "LINE", "layer", "connection", "text", "object", "rule", "block", "sync", "message", "l", "lin", "source", "entry", "data", "page", "col", "file", "style", "inline", "pass", "comment", "cell"]}}
{"id1": "7122523", "id2": "8778962", "code1": "    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request);\n        if (delegate == null) {\n            ActionErrors errors = new ActionErrors();\n            errors.add(null, new ActionError(\"errors.session\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"fail\");\n        }\n        AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla();\n        TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion();\n        String urlSonido = traAyudaPantalla.getUrlSonido();\n        if (urlSonido == null) {\n            return null;\n        }\n        URL url = new URL(urlSonido);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.connect();\n        String tipoMime = urlConnection.getContentType();\n        log.debug(\"Tipo Mime: \" + tipoMime);\n        Map audioOptions = new HashMap();\n        if (tipoMime.indexOf(\"audio\") != -1 || tipoMime.indexOf(\"asf\") != -1 || tipoMime.equals(\"unknown/unknown\")) {\n            audioOptions.put(\"id\", \"MediaPlayer\");\n            audioOptions.put(\"codeBase\", \"http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,7,1112\");\n            audioOptions.put(\"classId\", \"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\");\n            audioOptions.put(\"mimeType\", \"application/x-mplayer2\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/\");\n        } else if (tipoMime.indexOf(\"real\") != -1) {\n            audioOptions.put(\"id\", \"RVOCX\");\n            audioOptions.put(\"codeBase\", \"\");\n            audioOptions.put(\"classId\", \"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\");\n            audioOptions.put(\"mimeType\", \"audio/x-pn-realaudio-plugin\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"\");\n        }\n        request.setAttribute(\"audioOptions\", audioOptions);\n        log.debug(\"entra success\");\n        return mapping.findForward(\"success\");\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"execute": ["exec", "result", "send", "apply", "call", "handle", "transfer", "invoke", "func", "default", "start", "action", "next", "this", "forward", "info", "method", "report", "transform", "route", "post", "message", "submit", "data", "process", "create", "instance", "run"], "mapping": ["rmapper", "pailing", " matching", "mording", "rmapped", "mappings", "mailing", " mapper", "matching", " mailing", "mmailing", " mapped", "pording", "mmapping", "rmappings", "mmatching", "Mapper", "mmording", " mappings", "papping", " mording", "mapper", "Mappings", "Mapping", "rmapping", "Mapped", "patching", "mapped"], "form": ["flow", "template", "builder", "view", "app", "model", "command", "path", "forms", " forms", "input", "former", "session", "Form", "upload", "format", "transform", "route", "object", "FORM", "query", "config", "post", "submit", "page", "entry", "field", "control"], "request": ["result", "client", "enter", "view", "QUEST", "use", "current", "model", "path", "xml", "input", "session", "q", "context", "state", "queue", "image", "event", "type", "method", "report", "user", "application", "route", "object", "parent", "handler", "query", "message", "resource", "ware", "Request", "submit", "server", "subject", "req", "instance", "frame", "create", "web"], "response": ["result", "error", " responses", "client", "status", "output", "view", "model", "Response", "session", "res", "results", "report", "application", "object", " Response", "message", "resource", "http", "page", "data", "resp", "server", "req", "reply", "manager"], "delegate": ["DEploy", "releg", "rolelic", "deplementation", " delegates", " delic", "DElegates", "Deplementation", " deleg", "decleg", "deleg", "Deleg", "Delegates", "Deploy", "DElegate", "rolelegate", "Delic", "declegates", " deplementation", "reploy", "delegates", "relegate", "declegate", " deider", "roleplementation", "delic", "decider", "deider", "Deider", "relegates", "Delegate", "DEleg", "rolelegates", "deploy"], "errors": ["rules", "objects", "error", " messages", "relations", "ages", "params", "ins", "uments", "ays", "eps", "ceptions", "e", " problems", "reports", "rs", "ations", "members", "xml", "rors", "es", "maps", "s", "values", "err", "results", "failed", " exceptions", "comments", "all", "management", "items", "rows", "null", "ops", "runs", "plugins", "issues", "parser", "array", "ae", "orders", "blocks", "events", "asts", "les", "links", "data", "effects", "instance", "rss", "details", "ros", " responses", " Errors", "settings"], "ayudaPantalla": ["ayudaPantla", "ayudaPatarala", "ayudaParaala", "ayudaPataraala", "ayudaPandala", "ayudaPantilla", "ayudaPataraalla", "ayudaPentalla", "ayudaPantsala", "ayudaPatarailla", "ayudaParala", "ayudaPandilla", "ayudaTantala", "ayudaPantsla", "ayudaPantsalla", "ayudaParaalla", "ayudaTantella", "ayudaTentalla", "ayudaTentala", "ayudaPantala", "ayudaTantilla", "ayudaPatantala", "ayudaPandalla", "ayudaPandella", "ayudaPandla", "ayudaPantsella", "ayudaPantella", "ayudaTentilla", "ayudaPatantilla", "ayudaTentella", "ayudaPentilla", "ayudaPentella", "ayudaPentala", "ayudaPatantla", "ayudaPatantalla", "ayudaPantsilla", "ayudaParailla", "ayudaTantalla"], "traAyudaPantalla": ["traAyudaParaala", "traAyudaPandella", "traAyudaParalla", "traAyudaVantala", "traAyudaPartlla", "traAyudaPlantingala", "traAyudaPlantingalla", "traAyudaParaaya", "traAyudaPantaya", "traAyudaPandaya", "traAyudaParaalla", "traAyudaPentala", "traAyudaPantingilla", "traAyudaVandala", "traAyudaPantella", "traAyudaPandilla", "traAyudaVantlla", "traAyudaVantaya", "traAyudaPantingella", "traAyudaPentella", "traAyudaPlantingilla", "traAyudaVantalla", "traAyudaPartalla", "traAyudaPantala", "traAyudaPlantilla", "traAyudaPlantingella", "traAyudaPartaya", "traAyudaPantlla", "traAyudaPlantella", "traAyudaPlantala", "traAyudaVandalla", "traAyudaPandlla", "traAyudaPantilla", "traAyudaPandala", "traAyudaVandlla", "traAyudaPantingalla", "traAyudaPartala", "traAyudaVandaya", "traAyudaPentalla", "traAyudaPlantalla", "traAyudaPentilla", "traAyudaPandalla", "traAyudaPantingala"], "urlSonido": ["urlSonigma", "urlSonigo", "urlSenido", "uriSONini", "UrlSonini", "urlSONuli", "urlTonid", "urlsonini", "urlBonida", "urlSONid", "urlsonado", "urlSenri", "urlTonri", "urlsonigo", "urlTonigo", "urlSONido", "uriSonini", "UrlSonido", "uriSONido", "urlsonido", "UrlSonida", "urlSonini", "urlSONida", " urlTonini", "urlSonida", "UrlSonigo", "UrlSenigo", "UrlSenido", "urlBonido", "UrlSonuli", "urlsonigma", "urlSenigo", "urlMonida", "uriSonido", "urlTonado", " urlTonigo", "UrlBonuli", "urlSONini", "UrlBonido", "urlSonuli", " urlSonigo", "urlTonigma", "uriSONigma", "urlSonri", "urlMonido", "uriSONid", "urlMonuli", " urlSonini", "UrlSenini", "urlSenini", "urlSonid", "urlTonido", " urlSonado", "urlsonri", "UrlBonidi", "UrlSonri", "urlSONidi", "uriSonigma", "urlBonuli", "urlBonidi", "urlSONigma", "UrlSonidi", "urlTonini", "urlBonado", "urlMonidi", "urlSonado", " urlTonido", "UrlSenri", "uriSonid", "UrlBonida", "urlBonigo", " urlTonado", "urlSonidi", "urlBonini", "urlsonid"], "url": ["base", "client", "system", "str", "URL", "path", "log", "sl", "fl", "Url", "location", "string", "ls", "gl", "image", "ssl", "connection", "user", "b", "ll", "www", "config", "uri", "service", "resource", "http", "l", "page", "source", "server", "download", "full", "json", "impl", "web", "control", "f"], "urlConnection": ["UrlInfo", "UrlConnector", "urlConnect", "UrlConnection", "webConnection", "eventConnection", "webFactory", "userconnection", "eventconnection", "eventConnect", "URLConnection", "webconnection", "eventConnector", "urlconnection", "webClient", "httpConnection", "httpClient", "urlClient", "urlConn", "URLConn", "urlFactory", "httpFactory", "webConnect", "URLFactory", "urlInfo", "UrlConnect", " urlInfo", "urlConnector", "URLClient", "Urlconnection", " urlconnection", "webConn", "webConnector", "httpConn", "userInfo", "userConnection"], "tipoMime": ["tiposMext", "tiposMIME", " tipoMpe", " tipoSmime", "tipoTIME", " tipoMIME", "tipoMale", " tiposMime", "tipoKnime", " tipoSmpe", " tipoTime", "tipoTime", "tiposTanche", "tiposText", " tiposTIME", " tiposTpe", "tipoMize", "tipoCorph", "tiposMime", "tipoKnike", "tipoDemale", "tipoKnIME", " tipoSmile", "tipoMorph", "tiposTale", " tiposTime", " tipoTIME", "tipoDemIME", "tipoTize", "tiposMorph", " tipoMile", "tiposTorph", "tipoCext", " tipoMetime", " tiposMpe", "tipoCIME", "tipoPike", "tipoPanche", "tipoTale", "tipoManche", "tipoImize", "tipoTike", "tipoPIME", "tipoCime", "tipoMIME", "tipoNext", " tipoMetIME", "tiposTIME", "tiposMile", "tipoKnanche", "tipoDemize", " tipoSmIME", "tipoMike", "tiposMike", "tiposTile", " tipoTile", "tipoMile", "tiposTize", "tipoNile", "tipoDemime", "tipoCile", "tipoNime", "tiposTike", "tipoTanche", "tipoTile", "tipoMext", " tipoTpe", " tipoMetpe", "tipoTorph", " tiposMIME", "tipoPime", "tiposMize", " tiposTile", "tiposMale", "tipoText", "tiposTime", "tiposManche", "tipoImIME", " tipoMetile", "tipoImale", "tipoNIME", " tiposMile", "tipoImime"], "audioOptions": ["mediaParts", "soundoptions", "AudioOptions", " audioParts", "oggOptions", "videoParts", "videooptions", "archiveStyle", "musicStream", "soundContents", " audioRules", "soundOptions", "audioStream", "AudioGames", "mediaGames", "mediaOptions", "soundOption", "archiveStream", "oggOption", " audioContents", "archiveOptions", " audioOption", "mediaStyle", "videoSettings", "audioRules", "archiveColor", "soundSettings", "audioColor", "audioContents", "audioParts", "AudioStyle", "musicSettings", "mediaVideo", "AudioSettings", "audioGames", "videoOptions", "audioSettings", " audioStyle", "soundRules", " audiooptions", " audioSettings", "videoVideo", "AudioStream", " audioGames", "oggContents", "videoGames", "musicParts", "audioOption", " audioVideo", " audioColor", "audioVideo", "AudioColor", "audiooptions", " audioStream", "mediaSettings", "oggRules", "audioStyle", "videoStream", "musicOptions"]}}
{"id1": "14820302", "id2": "11968328", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"innerProcess": [" innerWrite", "subprocess", "binaryConnect", "innerprocess", "binaryWrite", "binaryprocess", " innerConnect", "subProcess", "innerWrite", "subConnect", "binaryProcess", " innerprocess", "innerConnect", "subWrite"], "curi": ["furi", "lcURI", "cri", "lURI", " cURI", "lcunit", "cgui", "Cui", "CURI", "lcuri", "pri", "fri", "firi", "Curi", "fui", " cui", " cgui", "luri", "Cunit", "lcui", "capi", "Cgui", "Cri", "cURI", "pURI", "Capi", " cri", "lri", "lcri", "cui", "Curl", " capi", "Ciri", "lcgui", "papi", "curl", " cunit", " curl", "ciri", "cunit", "lciri", "fURI", "lurl", "puri"], "regexpr": ["pregexer", "renexpr", "pregexpl", "reggexr", "Regexpre", "reggexper", "Renexpre", "renexper", "reggexpl", "recer", "relexPR", "recrepl", "recreer", "reggexpr", "relexpre", "regnexpr", "regexer", "pregexpr", "rerer", "rerepl", "rereper", "RenexPR", "regexPR", "Regexpr", "regnexr", "renexer", "prenexer", "recrepr", "prenexpl", "recrepre", "Renexp", "renexpl", "pregexp", "recrep", "renexr", "regexp", "recrePR", "renexPR", "reruer", "renexp", "Renexpr", "regexr", "prenexp", "receper", "relexpr", "rerupl", "rerupr", "regexpl", "regnexper", "relexp", "regexpre", "renexpre", "regexper", "recepr", "regnexpl", "Regexp", "RegexPR", "prenexpr", "rerepr", "recepl", "rerup"], "cs": ["Cs", "bc", "lc", "cm", "cf", "ins", "ms", "ca", "cache", "cers", "CS", "cb", "rs", "vs", "tc", "es", "ns", "ks", "conn", "cms", "cr", "ls", "cells", "cing", "cp", "cks", "c", "cc", "ci", "spec", "ios", "os", "ec", "acts", "codes", "cer", "acs", "acks", "js", "ps", "ars", "sync", "ced", "cus", "css", "ces", "ds", "ics", "fs", "cas", "wcs", "rc", "cos", "sc", "cn", "ches", "qs", "icks", "coll", "pc", "ac", "cases", "details", "ss", "bs", "cons", "ctx", "ce", "gs"], "digest": [" digested", "bigEST", " digity", "digit", "hashest", "signEST", "igity", "signest", "Digity", "bigest", " digests", "hashcher", "digcher", "logester", "Digger", " digcher", "digEST", "igest", "signger", "diggest", "biggest", " digester", "digester", " diggest", "Digcher", " digEST", "digests", "igester", "logger", "signests", "signgest", " digit", "digity", "hashger", "digested", "Diger", "Digester", "logit", "hashester", "signester", "diger", "igested", "Digest", " diger", "signer", "digger", "Digested", "logest", "Digit", "bigests", " digger", "signested"], "s": ["su", "v", "address", "services", "ms", "groups", "str", "e", "sets", "rs", "ws", "sl", "ns", "abs", "string", "u", "ls", "binary", "c", "states", "si", "ses", "os", "strings", "t", "sum", "sb", "r", "g", "b", "js", "n", "o", "ans", "ps", "sym", "S", "sync", "ds", "p", "bytes", "h", "obs", "is", "l", "data", "ss", "bs", "f", "gs", "settings"], "m": ["map", "cm", "v", "mc", "imm", "ms", "mr", "gm", "e", "rm", "pm", "am", "bm", "mo", "machine", "string", "fm", "man", "M", "c", "sm", "mi", "ym", "om", "r", "mm", "tm", "p", "hm", "wm", "me", "match", "vm", "nm", "dm"], "newDigestValue": ["newDigesterKey", "newDigestValues", "newDigestedValues", "newSignestValue", "newDigestVal", "newDigESTKey", "newDigestKey", "newSignestedValues", "newDigeterString", "newSignestValues", "newSignestedValue", "newSignestString", "newDigestedKey", "newSignestKey", "newSignestedString", "newDigESTValue", "newDigeterValue", "newDigestedValue", "newDigESTValues", "newDigesterVal", "newSignestedKey", "newDigestedVal", "newDigeterKey", "newDigesterString", "newDigeterVal", "newDigesterValues", "newDigesterValue", "newDigestedString", "newDigESTString", "newDigestString"]}}
{"id1": "13657103", "id2": "5951961", "code1": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"forBundle": ["forMuddy", "forFuddy", "forLale", "forBixture", "getBixture", "forBuddy", "getFixture", "forFixture", "forBale", "forMale", "getBundle", "forMundle", "forLixture", "forLuddy", "getBale", "forFale", "forMixture", "forLundle", "forFundle", "getFundle", "getFuddy", "getBuddy", "getFale"], "manip": ["manic", "multip", "Mani", "multIP", "damip", "manageri", "emanIP", "manageric", "ManIP", " manIP", "Manipp", "managerIP", "Manim", "mani", "multi", "Manic", "damim", "dami", "damIP", "manIP", "manipp", "emanim", "emanip", " manipp", "Manip", "emani", "managerip", "multic", "emanipp", "manim", " mani"], "bout": ["bbOUT", "basedump", "sbagain", "baseash", "sbout", "bin", " bin", "Bout", "BOut", "zin", "ferr", "Bdump", "sbin", "Berr", "sberr", "bdump", "bOut", "Bagain", "sbouts", "sbOUT", "nout", "Bin", "Bash", "fout", "bash", "bouts", "zOUT", "Bouts", "bbouts", "ndump", "baseout", "BOUT", "bOUT", "berr", "fagain", " bouts", "bagain", "zouts", "nOut", " bOUT", "baseOut", "fOUT", "nash", "bbout", "bbin"], "zout": ["zyout", "zipcontainer", "wOut", "azout", " zbox", "ezOut", "zhstore", "wio", "zhquery", "zipstore", "zraw", "wout", " zOut", "zenout", "zipout", "ezconn", "zipbox", "zin", "azouts", " zconn", "azin", "zOut", "zio", " zouts", "zbox", " zin", "zyOut", "azconn", "zherr", "azerr", "ezOUT", "zOUT", " zOUT", "ZOut", "zquery", "Zio", "zipio", "zhraw", "zagain", "zencontainer", "Zin", " zstore", "win", "ezquery", "zipagain", "azbox", "ezout", "zipquery", "zenin", "zyin", "zenagain", "zhOut", "zconn", "ezouts", "Zout", "zerr", "zouts", "zipOut", "zipraw", "zhout", "zstore", "ezraw", "azOUT", "zcontainer", " zerr", "azOut", "azstore", "zystore", " zagain", "zipin", " zcontainer"], "bundle": ["abundle", " borer", "eixture", "nunch", "euni", "abuddy", " bund", "buddy", "buration", "fuddy", "liler", "fixture", "buni", "bixture", "fulp", " biler", "borer", "sbuddy", "sbiler", "sborer", "bider", "abund", "aburation", "bulp", "fider", " buration", " buddy", "funi", "luddy", "fundle", "sbundle", "biler", "lorer", "nuni", "bunch", "nixture", " bulp", "eunch", "nundle", "abulp", " bider", "funch", "foodle", "abider", "fund", " boodle", "furation", "eundle", "lundle", "boodle", "aboodle", "bund"], "files": ["workers", "rules", "objects", "fires", "classes", "groups", "ids", "feed", "flows", "reports", "members", "iles", "children", "xml", "fl", "users", "ls", "lines", "resources", "results", "items", "errors", "models", "images", "plugins", "boxes", "issues", "apps", "events", "fs", "blocks", "books", "bytes", "links", "Files", "bugs", "http", "pages", "ips", "data", "fields", "file", "obs", "thumbnails", "download", "qs", "keys", "leases", "names", "web", "f", "features"], "url": ["address", "job", "rel", "ob", "el", "id", "feed", "URL", "ball", "not", "path", "sl", "fl", "Url", "filename", "location", "string", "out", "host", "pattern", "image", "link", "layer", "element", "html", "user", "b", "browser", "config", "loc", "pull", "fr", "uri", "resource", "http", "l", "page", "entry", "file", "source", "data", "download", "server", "channel", "coll", "dir", "web", "f"], "name": ["address", "base", "error", "alias", "job", "str", "el", "e", "comment", "ame", "id", "child", "model", "old", "path", "Name", "x", "default", "one", "label", "host", "filename", "string", "end", "time", "named", "word", "action", "size", "no", "image", "large", "type", "info", "connection", "definition", "b", "orig", "object", "n", "parent", "number", "block", "wheel", "uri", "resource", "common", "api", "key", "search", "data", "source", "file", "up", "work", "member", "pass", "value", "full", "home", "names", "part", "NAME"], "mf": ["mc", " mc", "ldf", "fmc", "fmcf", "Mf", "fmtf", "Mtf", "smfs", "Mcf", "mfc", "lfs", " mtf", "gfs", "smf", "gdf", "mdf", "mcf", "fmf", "mtf", "smfc", "lf", "gf", "smdf", "gfc", "Mc", " mcf", "mfs", "lfc"], "tmpFile": ["poraryFiles", "TempFiles", " tmpFiles", "poraryChannel", "tmpEntry", "tempEntry", "tmpDir", " tmpUrl", "tmpFunction", "tmpPath", "tmpGlobal", "TempPath", "TempFile", "TempFunction", " tmpDir", "tempChannel", " tmpFunction", "tmpChannel", "tempDir", "TempUrl", "tempFile", " temporaryFile", "poraryPath", "poraryEntry", "tempGlobal", "poraryFile", "poraryFunction", "TempEntry", "poraryUrl", " temporaryDir", " tmpGlobal", "tempFiles", "tmpUrl", "tempPath", "TempChannel", "tmpFiles", " temporaryGlobal", " temporaryFiles"], "ref": [" nav", "cache", "rel", " reference", "re", "ob", "id", "reg", "old", " comp", "val", "obj", " Ref", "aff", " resp", " binding", "eval", "comp", "fe", "ef", "lib", " cache", "type", "Ref", "reference", "def", " index", "Reference", "REF", "config", "loc", " remote", " req", "service", "lf", "col", "resp", "req", "instance", "bf", "part", "conf", "ctx", "f", "cmp"]}}
{"id1": "18504192", "id2": "9033639", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "in": ["url", "base", "ins", "reader", "IN", "login", "bin", "id", "io", "inc", "old", "ini", "index", "input", "In", "name", "inner", "image", "c", "m", "or", "at", "i", "info", "b", "again", "parent", "diff", "buffer", "inn", "min", "copy", "data", "file", "d", "src", "ac", "part"], "out": ["exec", "external", "base", "OUT", "client", "outs", "cache", "w", "call", "output", "io", "inc", "target", "name", "conn", "obj", "string", "c", "err", "prefix", "Out", "writer", "connection", "b", "ex", "n", "object", "again", "o", "dest", "p", "copy", "point", "line", "data", "file", "password", "part", "temp"], "source": ["ource", "slave", "reader", "client", "project", "scope", "view", "use", "proxy", "sl", "input", "target", "start", "core", "secure", "stream", "Source", "settings", "self", "storage", "clone", "ssl", "ie", "i", "connection", "component", "writer", "null", "parent", "sin", "dest", "slice", "sync", "ources", "iter", "service", "get", "copy", "from", "channel", "se", "server", "src", "origin", "unit", "size", "SOURCE"], "destination": ["destinator", "testinations", "Destinated", "Destification", "Destining", " destining", "Destination", "testinated", "dependification", " destinations", "destinations", "declification", "declinated", " destinator", "declinator", "contining", "dependinated", "testination", " destinated", "declination", "dependination", "destinated", "testinator", "destining", "contination", "dependinator", "destification", "Destinations", "continated", "Destinator", "continator"]}}
{"id1": "364438", "id2": "536614", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"convert": ["CONception", " deconversion", "Converted", "oconversion", "subversion", "CONverted", "unception", "subverting", "CONvert", "subverted", "unvert", "unverted", "Conception", "CONverting", " deconverting", "oconverted", "Conversion", "Converting", "CONversion", "oconvert", " deconverted", "conception", "converting", "subvert", "oconverting", "Convert", "conversion", "converted", "unversion", " deconvert"], "src": ["sys", "ource", "fp", "url", "sit", "prot", "st", "img", "reader", "gb", "tmp", "load", "cb", "proc", "scene", "path", "input", "filename", "string", "name", "obj", "s", "stream", "secure", "sth", "Source", "spec", "upload", "storage", "sel", "code", "username", "SourceFile", "ssl", "sb", "component", "Dest", "supp", "buf", "video", "sin", "attr", "back", "config", "loc", "slice", "inst", "sn", "uri", "resource", "rb", "feat", "rc", "href", "source", "fn", "sc", "file", "download", "ref", "RC", "gz", "dist", "req", "stage", "impl", "cpp", "rl", "ctx", "cmp"], "dest": ["disk", "test", "cont", "img", "bin", "tmp", "path", "target", "obj", "lib", "std", " dst", "Dest", "class", "dat", "orig", "null", "dc", "di", "source", "fn", "dir", "dist", " destination", "home", "txt", "temp"], "in": ["ins", "din", "reader", "IN", "login", "bin", "isin", "inc", "io", "ini", "val", "input", "In", "stream", "err", "doc", "inas", "t", "a", "i", "r", "ex", "n", "ps", "win", "inn", "inf", "pin", "is", "data", "source", "up", "file", "d", "pass", "as", "f"], "p": ["fp", "jp", "v", "pa", "tp", "bp", "e", "lp", "pre", "pm", "P", "py", "pr", "s", "cp", "c", "np", "m", "t", "j", "i", "r", "pe", "g", "b", "cop", "o", "ps", "per", "parser", "pd", "pg", "h", "wp", "l", "op", "pb", "d", "pc", "pp", "sp", "part", "f", "pi", "po"], "ds": ["posts", " DS", "eps", "dp", "ths", "vs", "els", "os", " ps", "dat", "ps", " sd", "pd", "uds", "data", "qs", "utils", "points", "rs", "services", "da", "groups", "db", "docs", "s", "ls", "hs", "words", "ys", "models", "cs", "ans", "di", "ld", "cons", "gs", "ins", "xs", "ges", "ts", "nas", "ks", "sts", "ded", "lines", "vals", "js", "ups", "plugins", "dates", "ants", "dds", "ss", "scripts", "tests", "ils", "ads", "sys", "Ds", "ays", "dl", "lp", "tools", "df", "ns", "styles", "dd", "gd", "des", "dos", "sync", " props", "dc", "parts", "dt", "obs", "dist", "amps", "d", "DS", "icks", "dm", "ipes", "bs"], "format": ["template", "atter", "url", "fp", "magic", "model", "path", "function", "plugin", "host", "pattern", "filename", "string", "nat", "language", "struct", "name", "prefix", "spec", "t", "type", "at", "Format", "class", "tag", "handler", "config", "layout", "sche", "table", "parser", "api", "version", "scale", "form", "feat", "fd", "data", "source", "file", "filter", "letter", "ant", "fn", "style", "act", "frame", "unit", "part", "record", "f"], "hasPixelData": ["hasByteData", "showsPixelDATA", "hasPictureSize", "haspixelSize", " hasPixelSize", " hasPixeldata", "showsByteData", "showsByteStyle", "showsBytedata", "showsPixeldata", "hasPixelSize", "hasPicturedata", "showsPixelStyle", "hasByteSize", "hasPixelDATA", "hasPictureData", "hasPixeldata", "hasByteStyle", "haspixelData", "showsByteDATA", "haspixeldata", "hasPixelStyle", "hasBytedata", "showsPixelData", "hasByteDATA"], "inflate": ["inflace", "invenATE", "Inflation", "inFlate", "inflating", "infolode", "insvenate", "inFlation", "insvenATE", "invenode", "insvenating", "inflated", "Inflated", "inadequode", "inadequate", "inffation", "invenate", "insflate", "inflATE", "Inflate", "infloated", "inFlated", "infface", "InFlate", "insflATE", "Inflace", "InFlace", "inadequATE", "insflating", "inFlace", "infloate", "InFlation", "infloation", "insvenode", "inflode", "infolATE", "infloace", "inffate", "infolate", "inflation", "invenating", "inadequating", "InFlated", "insflode", "infolating", "inffated"], "pxlen": ["mxlen", "pxsize", "mxdata", "fxlen", "pgLen", "mxcount", "pgl", "fxden", "pxdata", "fxl", "axlon", "pxl", "pxlength", "pxlon", "pnglength", "xpsize", "pplen", "mxsize", "txlon", "axln", "pclin", "camlen", "pxLen", "camdata", "fxLen", "pxden", "pglen", "pxcount", "pxpos", "fxpos", "pclen", "txlen", "pxln", "pxlin", "campos", "txln", "fxdata", "pclon", "camln", "txlin", "xplen", "xplength", "fxln", "axlin", "ppden", "mxlength", "ppl", "pgden", "pnglen", "ppLen", "pngsize", "mxpos", "pngcount", "axlen", "xpcount", "mxln", "pcln"], "out": ["sys", "v", "error", "OUT", "outs", "cache", "gen", "re", "output", "io", "log", "session", "conn", "obj", "state", "lock", "err", "Out", "step", "lib", "user", "again", "parent", "co", "query", "list", "pad", "post", "copy", "point", "store", "cli", "line", "work", "up", "server", "page", "dump", "group", "inter"]}}
{"id1": "7044153", "id2": "19006212", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    public void Load(String fname) throws Exception {\n        File f = null;\n        try {\n            if (\"\".equals(fname) || fname == null) throw new Exception();\n            System.out.println(\"Loading mapfile \" + fname);\n        } catch (Exception e) {\n            throw new Exception(\"File not found\");\n        }\n        aType = null;\n        fieldtype.clear();\n        creatures.clear();\n        aElement = new String(\"\");\n        content = null;\n        Ax = -1;\n        Ay = -1;\n        aTemplate = -1;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        data_read = 0;\n        URL url = this.game.mainClass.getClassLoader().getResource(fname);\n        if (url == null) {\n            throw new Exception(\"Can't load map from : \" + fname);\n        }\n        try {\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(url.openStream(), this);\n        } catch (Exception e) {\n            System.out.println(\"Can't open XML : \" + e);\n        }\n        for (int i = 0; i < fieldtype.size(); i++) {\n            System.out.println((MapField) fieldtype.get(i));\n        }\n        game.player.setpos(start_x, start_y);\n        System.out.println(\"Player starting position set\");\n        start_x = -1;\n        start_y = -1;\n        System.out.println(\"Map \\\"\" + fname + \"\\\" loaded\");\n    }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendExceptionAsHost", "sendExceptionWithService", "sendExceptiontoserver", "sendExceptiontoService", "sendExceptionWithServer", "sendErrortoHost", "sendExceptionAsServer", "sendErrorToserver", "sendExceptionWithHost", "sendExceptionToserver", "sendErrortoServer", "sendExceptionToHost", "sendExceptiontoServer", "sendErrorToServer", "sendErrortoserver", "sendErrorToService", "sendErrortoService", "sendExceptionAsserver", "sendExceptiontoHost", "sendExceptionWithserver", "sendExceptionToService", "sendErrorToHost", "sendExceptionAsService"], "server": ["ser", "test", "address", "base", "ip", "header", "client", "port", "proxy", "Server", "db", " host", "host", "domain", "prefix", "ssl", "root", "null", "service", "erver", "http", "addr", "email", "json", "serv", "conf"], "ex": ["exec", "su", "rex", "cl", "base", "error", "exc", "pex", "status", "re", "str", "lex", "aux", "throw", "e", "exp", "ace", "none", "Exception", "EX", "tx", "x", "log", "nex", "export", "res", "Ex", "ext", "obj", "Exc", "err", "hex", "ax", "event", "def", "class", "ception", "example", "except", "acer", " exc", "sex", "fail", "con", "full", "rupt", "exit", "temp"], "config": ["address", "base", "client", "console", "app", "Configuration", "proc", "log", "Config", "ext", "cmd", "bug", "cfg", "connection", "options", "text", "Conf", "etc", "service", "rc", "file", "json", "conf", "cb", "settings"], "prob": ["proj", "probs", " probs", "peb", "Proj", "Probs", "Prob", "Probe", " proj", "pebe", "probe", " probe", "pebs", "pej"], "dataSB": ["codeRB", "codeEB", "workPB", "errorSB", "eventSB", "DataHL", "controlSB", "DataLB", "workBB", "uiEl", " dataEl", "execLB", "fileLB", "cacheBL", "eventLB", "fileSB", "loadSB", " dataHL", "pBs", "dataSL", "codeLB", "fullLB", "offSB", " dataMB", "errorPB", "cacheSB", "ifSL", "execBL", "defaultLB", "pSB", " dataRB", "cachesb", "strSB", "postLB", "postSB", " dataBB", "dataHL", "defaultBB", "fullBB", "offSL", "contentOB", "nosb", "datasb", "errorOB", "cacheLB", "codeMB", "codeFB", "controlBL", "ifsb", "innersb", " dataLB", "ifLB", "fullBL", "responseBB", "codeHL", "errorEB", "defaultSB", "responseSB", "datLB", "offBB", "execsb", "dataMB", "psb", "postSL", "DataSB", "dataBL", "Datasb", "datOB", "dataEB", " dataBL", " dataSL", "DataBL", "ifSB", "offsb", " dataFB", "dataRB", "defaultsb", "DataMB", "contentLB", " datasb", "innerSL", "execBB", "dataLB", "filesb", "contentsb", "noLB", "errorBB", "uiSB", "innerSB", "fullSB", "dataPB", "strSL", "workSB", "noSB", "responseLB", "innerLB", " dataEB", "codeBs", "workSL", "dataFB", "fileSL", "dataOB", "DataRB", "loadLB", "strsb", "codeBB", "errorSL", "loadsb", "dataEl", "errorsb", "postsb", "uiLB", "offLB", "dataBB", " dataOB", "eventSL", " dataPB", "controlsb", "DataOB", "datSB", "codesb", "controlBB", "datBB", "contentSB", "noSL", "DataSL", "DataBB", "dataBs", "execSB", "loadBB", "pLB", "codeEl", "controlLB", "errorLB", " dataBs", "codeSB", "DataFB", "strLB", "eventBB", "responseBL"], "trace": ["race", "shadow", " debug", "test", "atter", "result", "flow", "address", "error", " traced", "cache", "bean", "e", " traces", "ace", "cover", "xml", "log", "tx", "string", "out", "profile", "bug", "err", "ray", "t", "ptr", "type", "info", "report", "r", "ctr", "span", " tracing", "tr", "strip", "message", "debug", "buffer", "array", "scale", "track", "stack", "data", "tri", "trip", "details", "runner", "trans", "fake", "temp"]}}
{"id1": "20375440", "id2": "411595", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "srcFile": ["destFiles", "sourceFiles", " srcfile", "destDir", "srcDir", "srcfile", " srcFiles", "srcPath", "destfile", "sourcePath", "sourcefile", "sourceFile", "rcfile", "rcPath", " srcPath", "rcFile", "rcFiles", " srcDir", "srcFiles", "sourceDir"], "destFile": ["destFiles", "destPlace", "targetFiles", "DestFiles", " destfile", "DestPlace", "Destfile", "targetFile", "DestFile", "destPath", "targetfile", "targetPlace", "restfile", "restFiles", "destfile", " destFiles", "tempFile", " destPath", "tempFiles", "tempfile", "tempPath", "DestPath", "restPlace", "restFile"], "src": ["sys", "ser", "url", "img", "stat", "reader", "client", "sup", "sr", "gb", "sec", "sub", "proc", "func", "cur", "ws", "ctx", "sl", "input", "start", "conn", "secure", "conv", "stream", "upload", "self", "sel", "construct", "ssl", "sb", "sq", "config", "slice", "loc", "sync", "ources", "inst", "loader", "rb", "rc", "in", "source", "sc", "dist", "RC", "req", "impl", "bs", "cb", "rs", "cmp"], "dest": ["rest", "slave", "test", "de", "result", "thin", "img", "sup", "output", "tmp", "comb", "proc", "path", "ws", "div", "target", "out", "end", "ui", "cp", "stream", "obj", "this", "std", "ssl", "writer", "Dest", "des", "transform", "class", "desc", "dat", "null", "cdn", "wb", "ds", "wh", "dc", "source", "destroy", "usr", "dir", "dist", "d", "dev", "home", "trans", "opt", " Dest", "temp"], "buffer": ["Buffer", "position", "address", "result", "header", "base", "uffer", "reader", "cache", "bin", "transfer", "feed", "raw", "request", "row", "input", "length", "string", "offset", "memory", "queue", "write", "layer", "reference", "info", "writer", "batch", "b", "number", "buf", "null", "slice", "block", "message", "iter", "bytes", "wave", "key", "copy", "flush", "data", "source", "channel", "limit", "capacity", "value", "size", "buff"], "read": ["exec", "k", "ip", "reader", "level", "send", "parse", "allow", "use", "id", "feed", "load", "not", "raw", "check", "skip", "x", "default", "index", "input", "connect", "start", "length", "play", "ind", "end", "seek", "write", "next", "no", "build", "i", "count", "ride", "wait", "b", "number", "fill", "n", "text", "show", "shape", "find", "Read", "slice", "block", "sync", "READ", "ok", "iter", "close", "add", "key", "get", "copy", "data", "sleep", "work", "se", "d", "limit", "create", "reads", "pass", "pick", "open", "reading", "size", "select", "run"]}}
{"id1": "14794404", "id2": "9081749", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["encryptpassword", "encressSecret", "encressPassword", "EncipherString", "encipherPassword", "encipherString", "encresspassword", "encryptedSecret", "EncryptSecret", "encipherSecret", "encryptedString", "EncryptString", "encressString", "EncipherSecret", "encipherpassword", "EncipherPassword", "encryptString", "Encryptpassword", "encryptSecret", "encryptedpassword", "Encipherpassword", "EncryptPassword"], "password": ["address", "params", "token", "Password", "cache", "description", "sword", "path", "input", "pattern", "string", "name", "word", "prefix", "database", "words", "username", "crypt", "connection", "definition", "text", "object", "enc", "padding", "message", "buffer", "resource", "array", "p", "attribute", "wd", "content", " passwords", "phrase", "data", "PASS", "channel", "secret", "email", "device", "pass"], "encryptedPassword": [" encryptedpassword", "protectedCode", "lockedString", "ryptedPass", "lockedpassword", "lockedPass", "ryptedCode", "ryptedpassword", "protectedPass", "protectedPassword", "encryptedPass", "encryptedCode", "protectedpassword", "encryptedString", " encryptedCode", " encryptedPass", "lockedPassword", " encryptedString", "ryptedString", "encryptedpassword", "protectedString", "ryptedPassword"], "md5": ["MD3", "MD512", "MD45", "amd4", " mddown", "mddown", "dig45", "md512", "dig3", " md3", "MD4", "dig4", " MD512", " md45", "MD2", "dig5", " md6", "amd5", " md512", "digdown", "md2", "MDdown", " MD5", "md6", " md2", "amd6", "amd2", " MD3", "dig2", " MD2", " md4", "md45", "md3", "md4", "MD5", "MD6"], "digest": ["encest", "signest", "mdment", "digace", "mdher", " digests", " digment", "Digenge", " digher", "encment", "digenge", "mdest", "encester", "mdests", " digester", "digester", "digests", "digment", "Digests", "digher", "signests", "Digher", "digested", "mdested", "mdace", "mdash", "Digester", " digenge", "signester", "Digest", "encash", "Digested", " digace", " digash", "mdenge", "Digace", "signested", "digash", "mdester"], "i": ["qi", "v", "k", "ip", "ai", "ti", "I", "e", "id", "io", "xi", "x", "index", "length", "li", "u", "ui", "s", "hi", "multi", "ci", "c", "si", "phi", "ii", "t", "j", "ie", "r", "b", "o", "zi", "ri", "uri", "p", "gi", "ix", "h", "it", "l", "oi", "di", "d", "f", "bi", "pi"], "hex": ["hash", "lit", "digit", "rex", "ip", "pex", "bit", "rh", "str", "pixel", "bin", "id", "exp", "zip", "sign", "none", "check", "utf", "stick", "pattern", "string", "length", "ext", "binary", "prefix", "comp", "serial", "ex", "text", "null", "enc", "oct", "bits", "slice", "pack", "alpha", "mix", "ix", "nexus", "di", "data", "char", "shift", "letter", "sex", "num", "coord", "closure", "ctr", "buff", "temp"]}}
{"id1": "3558512", "id2": "17996547", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"serialize": ["Serialze", "finalze", "Serialize", " serialze", "erialize", "Serialized", "erialze", "Serialization", "Serialify", "serialze", " serialization", "serializable", "erialization", "normalify", "normalized", "finalize", "normalze", "serialify", "finalized", "finalify", "erializable", "Serializable", "serialized", "serialization", "normalize", " serializable"], "out": ["exec", "OUT", "png", "outs", "cache", "client", "w", "gen", "output", "bin", "io", "raw", "filename", "name", "string", "obj", "conn", "archive", "image", "err", "Out", "writer", "i", "report", "a", "ex", "parent", "o", "loader", "buffer", "content", "copy", "page", "data", "pool", "file", "up", "source", "server", "dump", "temp"], "parser": ["test", "processor", "base", "master", "reader", "system", "cache", "builder", "parse", "php", "lp", "tt", "worker", "xml", "plugin", "arser", "er", "seed", "cp", "pkg", "upload", "writer", "pe", "Parser", "class", "parent", "handler", "pillar", "per", "loader", "p", "wrapper", "copy", "file", "up", "server", "instance", "rar", "pp", "ss", "as", "txt", "manager"], "on_disk": ["onJdemand", "onnetfile", "onnetspace", "off_space", "off_delete", "onbootlock", "on_lock", "onbookdelete", "off_lock", "on_file", "off_drive", "onjspace", "off_storage", "onbootdrive", "onJdrive", "onbootdisk", "on_drive", "onJlock", "onjdrive", "onJdisk", "onbootstorage", "off_demand", "onbookdrive", "off_disk", "onjfile", "onbookdisk", "on_storage", "onnetdemand", "onjdisk", "on_demand", "onnetdisk", "on_delete", "onnetdrive", "on_space", "off_file"], "in": ["ins", "thin", "din", "reader", "IN", "login", "bin", "inc", "ini", "input", "In", "conn", "inner", "stream", "c", "inas", "ax", "i", "connection", "info", "r", "again", "o", "socket", "win", "inn", "min", "pin", "copy", "data", "lin", "file", "source", "kin", "rin", "pass", "con", "ac", "as", "f"]}}
{"id1": "15797402", "id2": "822452", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"parse": ["wrap", "save", "apply", "handle", " serve", "php", "view", "load", "cover", "raw", "replace", "worker", "request", "xml", "patch", " convert", " analyse", " parsing", "set", " rewrite", " process", "rate", "read", "fork", "print", "report", "Parser", "transform", "scan", "arse", "pack", "parser", "service", " parser", "http", "process", "se", "processing", "pc", " split", "split", " transform", " dispatch"], "stream": ["url", "reader", "client", "sample", "handle", "view", "feed", "load", "raw", "remote", "input", "inner", "image", "upload", "down", "Stream", "read", "writer", "video", "through", "loader", "message", "resource", "content", "stack", "document", "iterator", "form", "http", "in", "source", "channel", "server", "data", "file", "download", "src", "draw", "response", "temp"], "handler": ["monitor", "processor", "base", "reader", "client", "handle", "controller", "default", "function", "manager", "host", "pointer", "driver", "layer", "format", "event", "handled", "writer", "info", "connection", "application", "Handler", "parent", "hand", "loader", "parser", "service", "wrapper", "phase", "h", "di", "data", "channel", "server", "collection", "ctx", "response"], "metadata": ["map", "template", "md", "monitor", "processor", "header", "params", "met", "runtime", "xml", "metry", "manager", "plugin", "meta", "mt", "state", "material", "database", "mi", "storage", "mon", "m", "properties", "management", "component", "info", "connection", "directory", "config", "parser", "message", "uri", "attribute", "property", "resource", "adata", "managed", "document", "content", "di", "data", "source", "subject", "mx", "json", "collection", "ctx", "module"], "context": [" Context", "processor", "mc", "reader", "system", "scope", " contexts", "proxy", "command", "tx", "request", "xml", "manager", "environment", "event", "component", "element", "connection", "method", "object", "kernel", "text", "parent", "config", "concept", "message", "resource", "Context", "document", "content", "translation", "data", "entry", "subject", "instance", "collection", "txt", "ctx", "cmp"], "name": ["address", "url", "base", "alias", "job", "call", "comment", "ame", "id", "child", "none", "model", "old", "path", "Name", "default", "label", "filename", "string", "on", "time", "named", "action", "word", "size", "no", "prefix", "image", "missing", "large", "code", "m", "type", "connection", "active", "class", "route", "null", "n", "object", "sync", "message", "resource", "common", "api", "version", "key", "search", "in", "source", "data", "work", "file", "full", "names", "part", "NAME"], "out": ["url", "result", "OUT", "client", "outs", "builder", "output", "bin", "window", "exp", "io", "child", "path", "obj", "conn", "ext", "image", "err", "Out", "plain", "lib", "ray", "extra", "writer", "connection", "user", "null", "object", "again", "ex", "o", "socket", "sync", "resource", "flush", "copy", "in", "line", "data", "source", "file", "server", "page", "pool", "channel", "cos", "instance", "manager", "temp"]}}
{"id1": "13563706", "id2": "17557289", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", "handleGET", "didget", " doPut", "didGET", "handlePut", "doGET", "didGet", "handleget", " doget", "didPut", "doget", "doPut", "handleGet"], "request": ["complete", "url", "result", "client", "view", "QUEST", "current", "model", "Response", "xml", "remote", "input", "string", "queue", "image", "event", "type", "info", "report", "method", "user", "application", "connection", "object", "query", "config", "message", "buffer", "attribute", "resource", "p", "Request", "document", "data", "server", "req", "create", "instance", "frame"], "response": ["wa", "result", "header", "error", "client", "description", "status", "re", "output", "view", "site", "feed", "model", "Response", "index", "res", "location", "image", "results", "respond", "reason", "writer", "connection", "report", "application", "object", "body", "query", " Response", "message", "service", "resource", "api", "document", "http", "resp", "server", "pool", "subject", "reply", "onse", "json", "collection"], "selectedPage": [" selectedButton", "namedSite", "namedpage", "electedButton", "selectedpage", "electedLine", " selectedpage", "namedFile", "selectedLine", "selectionFile", "lectedItem", "selectionLine", "selectedHour", "namedPage", "selectionButton", "lectedpage", "selectionHour", "selectionPage", "selectedAction", " selectedHour", "electedPage", "selectionItem", "lectedSite", "lectedFile", "selectionpage", "selectionAction", "selectedButton", "selectedItem", "lectedLine", " selectedItem", "lectedHour", " selectedLine", "namedLine", "lectedPage", "electedpage", " selectedSite", "lectedButton", " selectedFile", "selectedFile", "lectedAction", "selectedSite", " selectedAction"], "page": ["address", "cache", "port", "model", "row", "location", "queue", "section", "route", "message", "display", "p", "document", "age", "peer", "article", "server", "sp", "f", "client", "child", "je", "pl", "fe", "user", "number", "rule", "block", "pg", "pool", "pp", "item", "position", "result", "account", "change", "project", " Page", "language", "menu", "parent", "ice", "per", "office", "resource", "me", "channel", "unit", "module", "url", "ip", "phone", "site", "view", "proxy", "plugin", "ge", "node", "profile", "image", "Page", "type", "connection", "html", "handler", "layout", "point", "instance", "photo", "record", "po"], "portalRequest": ["portpalRequest", "portelRequest", "portallServer", "PortortalUser", "PortalAccess", "portugalOrder", "portallingAccess", "portbalResponse", "portelQuery", " portalPage", "PortortalCommand", "PortalOrder", "portailResponse", "portalCommand", "portelCommand", "portortalAccess", "portalUser", "portpalResponse", " portalQuery", "portortalRequest", "portialQuery", " portialResponse", "portallingRequest", "portALUser", "portailUser", "PortalPage", "PortalUser", "portugalResponse", "portalResponse", "portalServer", "PortalResponse", "PortalRequest", "portbalRequest", "PortalEvent", "PortortalEvent", "portugalUser", "portallRequest", "portailOrder", "portalOrder", "portpalAccess", "portalAccess", "portelResponse", "PortortalAccess", "portortalOrder", "portALRequest", "PortortalResponse", " portialPage", "PortalServer", "portortalEvent", "portortalUser", "portailRequest", "portalPage", "portugalEvent", "portialRequest", "portialResponse", "portbalPage", "portortalServer", "PortortalServer", "portortalPage", "PortortalPage", "portpalPage", "portalEvent", " portalResponse", "portALEvent", "portortalResponse", "portallingCommand", "portallResponse", "portelPage", " portialQuery", "portialPage", "portalQuery", "portallingResponse", "portallUser", "PortortalRequest", "portortalCommand", "portugalServer", "portallingPage", "PortortalOrder", "portugalRequest", "portbalQuery", " portialRequest", "portALResponse", "PortalCommand"], "pageProp": ["PagePro", "parentProperty", "projectProperty", "resourceprop", " pageProperty", "pluginProperty", "pageProperty", "peerProp", "parentObj", "pluginProp", " pageStr", "parentProp", "Pageprop", "pageStr", "agePro", "PageStr", "resourceProperty", "resourcePro", "pluginprop", "projectPro", "ageProp", "peerStr", "pluginPro", "PageProp", "PageObj", "projectprop", "projectProp", " pagePro", "peerProperty", "pagePro", "resourceProp", "peerPro", "parentPro", "PageProperty", "ageProperty", "pageObj", " pageObj", "ageprop", "pageprop"], "possiblePage": ["possiblyLine", "possiblyPages", "puredItem", "patchingpage", "possibilityPage", "permanentPage", "pablePage", "patchedOrder", "possibilitypage", "PossibleItem", "PossiblyPage", "possiblyGroup", "possibilityPages", "possiblypage", "PossibleGroup", "possibleItem", "PossiblyLine", "PossibilityPages", "PossibleLine", "PossiblyOrder", "PossiblePage", "possiblePages", "PossiblyItem", "Possiblepage", "PossibilityLine", "patchingPage", "possiblyOrder", "patchedLine", "PossiblePages", "patchingGroup", "permanentpage", "patchingItem", "permanentOrder", "possiblepage", "possibleOrder", "possibleLine", "PossibleOrder", "possiblyItem", "Possibilitypage", "Possiblypage", "possiblyPage", "pableLine", "possibilityLine", "possibleGroup", "PossiblyGroup", "patchedPage", "permanentLine", "puredPage", "pablepage", "puredpage", "pablePages", "PossibilityPage", "puredGroup", "patchedpage"], "property": ["address", "feature", "result", "header", "prop", "project", "term", "operator", "function", "uration", "name", "string", "profile", "binary", "language", "section", "set", "prefix", "binding", "character", "expression", "entity", "properties", "layer", "t", " Property", "type", "duration", "class", "number", "object", "Property", "config", "future", "integer", "table", "attribute", "resource", "p", "key", "perties", "data", "notation", "maximum", "variable", "value", "label", "f"], "referer": [" refrer", " refeline", "affrer", "defrer", "redeline", "rederer", "Referers", "diffender", "refber", "refender", "deferer", "ferers", "redrer", " refere", "Refre", "afferen", "rerer", "reere", "refrer", " referers", " refiner", "differer", "refre", "reerer", "Referen", "afferer", "defber", "redber", " refber", "Refender", "defere", "Refiner", "reiner", "fere", "referen", "refeline", "Refber", "refiner", "diffiner", "rere", " refre", "frer", "Referer", "referers", "Refere", "ferer", "Refeline", " referen", "diffrer", "affere", "Refrer", "refere", "defender", " refender"], "e": ["de", "esi", "error", "exc", "ele", "one", "ea", "es", "er", "ee", "err", "this", "E", "fe", "eme", "or", "event", "element", "ie", "i", "type", "a", "null", "ception", "see", "o", "message", "ae", "p", "me", "se", "d", "ed", "f"]}}
{"id1": "9371421", "id2": "22752444", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 1, "substitutes": {"eventHash": ["byteDig", "bytehash", "messageHash", "messagehash", "eventhash", " eventDig", "eventKey", " eventKey", " eventhash", "byteKey", "messageKey", "eventDig", "byteHash", "messageDig"], "eventstr": [" eventstring", "Eventsource", "eventStr", "eventsource", "Eventstr", " eventStr", "exstring", "errorstr", "EventStr", "eventdict", "errorstring", "eventstring", "errorStr", "exStr", " eventdict", "Eventstring", "exstr", " eventsource", "Eventdict", "exdict", "errorsource"], "md": ["MD", "hash", "map", "cm", "mc", "dig", "ms", "sha", "ng", "metadata", "id", "pm", "bd", "amd", "mo", "meta", "mb", "mt", "cmd", "hd", "doc", "sm", "rpm", "mand", "m", "dd", "od", "mg", "mm", "ma", "ad", "em", "key", "wd", "mac", "mn", "mod", "hm", "dr", "di", "data", "ke", "dh", "ld", "d", "mag", "vd", "dm", "mem", "mu", " MD", "mp"], "theDigest": ["thedigest", "theSignEST", " theDigEST", "Thedigest", "theDigEST", "ThedigEST", "Thedigester", "TheDigEST", " theSignEST", "thedigester", "theDigester", "TheDigest", "theSignester", "theHashEST", " theDighest", "thedigEST", "theHashester", "theSignhest", "theSignest", "theDighest", "TheDigester", " theSignest", " theSignester", " theDigester", " theSignhest", "theHashest", "thedighest"]}}
{"id1": "18114701", "id2": "5744992", "code1": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "code2": "    public void dorequest(Map<String, String> ps, String method) throws IOException {\n        StringBuffer httpResponse = new StringBuffer();\n        URL ourl = new URL(url);\n        HttpURLConnection httpConnection = (HttpURLConnection) ourl.openConnection();\n        httpConnection.setRequestMethod(method);\n        httpConnection.setDoOutput(true);\n        this.setCookie(httpConnection);\n        OutputStream httpOutputStream = httpConnection.getOutputStream();\n        StringBuffer postParams = new StringBuffer(\"\");\n        for (Entry<String, String> entry : ps.entrySet()) {\n            postParams.append(entry.getKey());\n            postParams.append(\"=\");\n            postParams.append(entry.getValue());\n            postParams.append(\"&\");\n        }\n        httpOutputStream.write(postParams.toString().getBytes());\n        BufferedReader httpBufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n        httpResponse.append(this.readBufferedContent(httpBufferedReader));\n        text = httpResponse.toString();\n        this.readCookie(httpConnection);\n    }\n", "label": 0, "substitutes": {"resolveEntity": ["resolvingEnt", "resolvedEntity", "reolveEntity", "reserveEntity", "resolveentity", "reserveEnt", "resolvedEnt", "resolvedentity", "reserveentity", "resolvingEntity", "reolveentity", "resolveEnt", "reolvedentity", "reolveEnt", "reolvedEntity", "reolvedEnt", "resolvingentity"], "publicId": ["publicID", "productionid", "openid", "externalId", "ublicId", "publicData", "publicUrl", "openId", "ublicEntity", "productionId", "productionID", " publicKey", "systemEntity", "externalEntity", " publicid", "systemID", " publicID", "publicid", "openID", "projectData", "externalID", "publicMid", "projectKey", " publicUrl", " publicData", "systemData", "projectID", "publicKey", "openUrl", "projectId", "ublicID", "externalMid", "systemMid", "systemKey", "ublicMid", "publicEntity", "productionUrl"], "systemId": ["systemPath", " systemUrl", " systemID", "serverid", "SystemID", "systemName", "SystemUrl", "ystemid", "SystemPath", " systemPath", " systemName", "systemUrl", "SystemId", "systemID", "serverName", "Systemid", "serverUrl", "SystemName", " systemid", "systemid", "ystemID", "ystemId", "serverId", "ystemPath"], "resolved": ["revolution", "rejected", "revolve", "resolution", "presolve", "revolving", "Resolver", "Resolution", " resolver", "resjected", "resolving", "presolver", "reolver", "reolve", "revolved", " resjected", " resolution", "presolved", "revolver", "resolve", "presjected", "reolved", "Resolve", "resolver", "presolving", " resolving", " resolve", "presolution", "reolving", "Resolved", "reolution"], "iSource": [" iFactory", "ISource", "iuClient", "piPoint", "ISOURCE", "piSession", "iuSOURCE", "iFactory", " iPoint", "iuStream", "iSession", "apiStream", "diStream", "uriStream", "uiSOURCE", "diPoint", "iClient", "uriSourceFile", "piUrl", "iSOURCE", "piFactory", "piSourceFile", "IClient", " iSession", "apiUrl", "iPoint", "IStream", "iuSource", "apiFactory", "piSource", "uiSource", "piStream", "diSource", "uriSource", "diSourceFile", " iUrl", "iUrl", "uiStream", "apiSource", "uiClient", "iSourceFile", " iSourceFile", "uriSession"], "url": ["address", "client", "rel", "id", "feed", "URL", "jar", "path", "sl", "fl", "Url", "location", "string", "secure", "stream", "image", "org", "ssl", "connection", "user", "b", "browser", "www", "config", "fr", "uri", "resource", "api", "http", "l", "page", "source", "file", "channel", "data", "server", "web", "rl", "f"], "iStream": ["iPath", "uStream", "uriSteam", "uSteam", "uSource", "iiPath", "iiStreamer", "uriStream", "lStream", "uStreamer", "uFrame", "uriStreamer", "iSteam", "iiSource", "iFrame", "iiStream", "lSource", "uriSource", "iiFrame", "iStreamer", "uPath", "iiSteam", "lPath", "lFrame"]}}
{"id1": "20073619", "id2": "7499186", "code1": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 0, "substitutes": {"getPagina": ["getPaguira", "getPagine", "getChangine", "getChaginate", "getChagina", "getChanginate", "getPagira", "getPamina", "getPangira", "getPangine", "getPaminate", "getPaguinate", "getPamine", "getPangina", "getChangira", "getPaginate", "getChagira", "getPamira", "getChagine", "getPaguina", "getPanginate", "getPaguine", "getChangina"], "strurl": ["strstring", "sthttp", "arrurl", "striURL", "arrUrl", "ststr", "STRstring", "strhttp", "sturl", "stristring", "striurl", "wrURL", "wrurl", "arrstr", "wrstring", "strUrl", "Strhttp", "StrUrl", "stUrl", "strURL", "strstr", "wrstr", "stristr", "arrhttp", "Strstr", "STRstr", "STRurl", "STRURL", "Strurl"], "resp": ["rest", "serv", "result", "esi", "Resp", "rh", "rel", "bb", "lp", "zip", "exp", "model", "Response", "default", "remote", "host", "res", "conn", "msg", "obj", "ret", "rep", "err", "success", "comp", "fe", "respond", "news", "reason", "report", "html", "dest", "www", "rec", "pretty", "fr", "api", "p", "content", "respons", "wp", "page", "ref", "req", "coll", "pp", "reply", "json", "rss", "sp", "esp", "part", "response", "cmp", "rev"], "url": ["base", "job", "e", "io", "URL", "ball", "path", "log", "sl", "Url", "ls", "gl", "stream", "image", "org", "ssl", "i", "r", "connection", "user", "b", "ll", "socket", "ur", "buffer", "uri", "service", "resource", "inf", "bel", "http", "l", "page", "source", "file", "server", "entry", "open", "web", "rl", "f"], "in": ["gin", "cf", "ins", "reader", "din", "IN", "login", "el", "bin", "e", "ar", "id", "inc", "ini", "input", "out", "In", "s", "stream", "inner", "image", "c", "err", "doc", "i", "r", "b", "again", "rec", "nin", "fr", "inn", "it", "is", "into", "l", "lin", "source", "file", "init", "inside", "d", "con", "ac", "impl", "as", "f"], "str": ["cl", "lc", "st", "reader", "sr", "e", "br", "arr", "rs", "raw", "cur", "rr", "sl", "div", "string", "s", "obj", "cr", "err", "doc", "c", "code", "Str", "wr", "read", "i", "r", "text", "tr", "rec", "STR", "enc", "fr", "iter", "p", "dr", "line", "stri", "data", "l", "char", "coll", "sp", "f", "pr"]}}
{"id1": "8788371", "id2": "19134229", "code1": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"tail": ["exec", "test", " ignore", "thin", " customize", " download", " shutdown", "shell", " Tail", "ctl", " tee", "start", " terminate", " format", "stop", "sync", " quit", "copy", " trim", "cli", "file", "download", " exit", "split", "exit", "f", "run"], "cmd": ["bind", "csv", "md", "cl", "img", "job", "prop", "own", "cycle", "dict", "cb", "command", "proc", "boot", "comm", "host", "cp", "seq", "pkg", "cfg", "mode", "Cmd", "method", "buf", "config", "grad", "qq", "ok", "cd", "wd", "nd", "ck", "cli", "req", "frame", "cat", "ctr", "ctx", "cmp", "msg"], "pos": ["position", "address", "prop", "pri", "port", "x", "index", "pt", "val", "pointer", "patch", "length", "start", "s", "param", "seq", "len", "os", "Pos", "type", "neg", "i", "ps", "loc", "padding", " position", "POS", "p", "point", "line", "num", "limit", "pc", "part", "Position", "po"], "c": ["exec", "cm", "lc", "v", "cf", "mc", "uc", "ca", "client", "parse", "unc", "e", "C", "tc", "cr", "cp", "u", "cc", "ci", "t", "ec", "arc", "g", "cu", "ce", "cs", "b", "enc", "fc", "cd", "dc", "p", "h", "l", "sc", "cn", "init", "d", "coll", "pc", "con", "ac", "ctrl", "conf", "xc", "f"], "src": ["ource", "rest", "prot", "url", "result", "lit", "fp", "img", "stat", "uc", "rect", "sup", "project", "str", "gb", "proc", "shell", "cur", "sl", "target", "filename", "location", "string", "name", "host", "secure", "stream", "prefix", "username", "ssl", "sb", "root", "route", "text", "dest", "attr", "config", "loc", "sync", "inst", "sn", "uri", "resource", "rb", "feat", "http", "rc", "href", "source", "fn", "sc", "dist", "RC", "cmp"], "path": ["app", "port", "id", "log", "pattern", "location", "conn", "context", "name", "cp", "core", "length", "link", "method", "route", "fs", "api", "p", "sc", "file", "full", "cat", "stat", "client", "prop", "child", "proc", "folder", "pointer", "Path", "spec", "prefix", "or", "object", "loader", "key", "open", "base", "cont", "uc", "system", "rh", "obj", "stream", "info", "parent", "config", "loc", "near", "uri", "resource", "content", "rc", "source", "work", "dir", "home", "txt", "temp", "url", "PATH", "chain", "host", "time", "image", "type", "connection", "root", "text", "handler", "sync", "ath", "version", "wd", "plus", "point", "ref", "ctx", "po"], "parameters": ["prometers", " paramentials", " paramets", "paramsentials", " paramers", "paramets", "prometer", "promerences", "paramentials", "paramerences", "paramseter", "promentials", "paramsets", "promets", "refeter", "parameter", "paramers", "refers", "references", " parameter", " paramerences", "refeters", "paramseters", "promers"], "foption": ["noption", "rfOption", "nOption", "fopt", "Foption", " fopt", "fargument", "rfargument", " fOption", "nopt", "fOption", "rfopt", " fargument", "Fargument", "rfoption", "Fopt", "FOption"], "srcFs": ["rbFS", "configOs", "rcfs", "rbfs", " srcOs", " srcFS", "srcWF", "sbFs", " srcFD", "srcFD", "sbFS", " srcWF", "rcFD", "rcOps", "configFD", "srcOs", "sourceFs", "sourceOs", "sourcefs", "rcFs", "srcfs", "rcFS", "sourceFS", "rbFD", "rcWF", "sourceOps", "srcFS", "sbOs", "configFs", "rbFs", " srcOps", "srcOps", " srcfs", "configFS", "rcOs", "sbWF"], "fileSize": ["loadSize", "loadLength", "pagesize", "pageLength", "byteSize", "worksize", "byteLength", " fileLength", "resourceLength", " fileLen", "bytesize", "pageLen", "lineSize", "FileName", "workSize", " filesize", "lineLength", "loadLen", "pageSIZE", "FileLength", " fileName", "messagesize", "messageLen", " fileInfo", "resourceSize", "workName", "fileLen", "messageSize", "resourceSIZE", "Filesize", "pageSize", "lineLen", "FileSize", "resourceLen", "fileInfo", "FileStorage", " fileStorage", "filesize", "messageLength", "messageSIZE", "FileInfo", "fileLength", "messageInfo", "workLength", "lineStorage", "fileStorage", "fileName", "fileSIZE"], "offset": ["address", "error", "enabled", "meta", "location", "length", "start", "off", "operation", "ptr", "align", "interrupted", "option", "attribute", "data", "limit", "part", "size", "absolute", "left", "pointer", "action", "prefix", "object", "attr", "o", "pad", "timeout", "page", "item", "position", "exclusive", "base", "adjusted", "alias", "ace", "skip", "auto", "extra", "parent", "online", "loc", "slice", "padding", "iterator", "shift", "Offset", "reset", "offer", "index", "out", "end", "next", "set", "order", "array", "optional", "point", "line", "entry", "addr", "style", "area"], "in": ["serv", "gin", "ins", "din", "reader", "IN", "token", "login", "re", "bin", "id", "isin", "inc", "raw", "vin", "ini", "input", "out", "In", "s", "conn", "inner", "stream", "binary", "inas", "read", "m", "or", "ssl", "a", "i", "r", "b", "ex", "n", "again", "rec", "socket", "nin", "win", "resource", "inn", "min", "pin", "is", "into", "data", "lin", "file", "init", "rin", "ac", "as", "f"]}}
{"id1": "22046596", "id2": "21348951", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "label": 1, "substitutes": {"copy": ["exec", " copying", "transfer", "zip", "io", "Copy", "put", " copied", "Transfer", "cp", "to", "write", "upload", " cp", "all", "sync", "clip", "p", "get", " transfer", " copies", "file", "download", " dup", " Copy", "paste"], "s": ["v", "less", "services", "sv", "ins", "outs", "w", "xs", "e", "south", "ts", "x", "es", "sl", "input", "ns", "ls", "u", "c", "si", "files", "os", "ses", "storage", "m", "ssl", "sb", "a", "i", "g", "b", "sin", "o", "ps", "S", "ds", "fs", "p", "is", "l", "source", "sh", "se", "src", "ss", "as", "sf", "f", "gs"], "t": ["template", "v", "z", "tp", "e", "ot", "ts", "tf", "x", "T", "pt", "target", "tc", "to", "c", "down", "y", "m", "at", "i", "r", "ty", "b", "g", "n", " T", "object", "o", "tr", "p", "it", "l", "tty", "file", "ta", "tor", "f", "temp"], "in": ["url", "ins", "din", "reader", "IN", "login", "bin", "e", "id", "io", "inc", "input", "In", "conn", "inner", "c", "m", "ssl", "i", "r", "g", "b", "n", "again", "sin", "pull", "socket", "sync", "nin", "win", "inn", "p", "min", "pin", "h", "is", "l", "source", "file", "up", "init", "d", "rin", "as", "f"], "out": ["net", "v", "OUT", "client", "outs", "w", "call", "output", "bin", "io", "inc", "not", "x", "conn", "ext", "obj", "image", "c", "err", "off", "Out", "plain", "at", "writer", "connection", "g", "b", "ex", "n", "again", "parent", "o", "user", "null", "sync", "p", "l", "channel", "file", "d", "f", "temp"]}}
{"id1": "14001795", "id2": "8047989", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"copyOverWarFile": ["copyoverwarFiles", "copyOverWebfile", "copyoverWarPath", "copyoverwarPath", "copyOverWebFiles", "copyOverWarFiles", "copyOverWARFiles", "copyOverWebPath", "copyOverWARFile", "copyOverwarFile", "copyOverWarfile", "copyOverWarPath", "copyOverWARPath", "copyoverwarfile", "copyoverWarfile", "copyoverWarFile", "copyoverwarFile", "copyoverWarFiles", "copyOverWARfile", "copyOverWebFile", "copyOverwarFiles", "copyOverwarfile", "copyOverwarPath"], "dir": ["md", "url", " directory", "cache", "clean", "local", "direct", "window", "handle", "Dir", "zip", "feed", "cur", "db", "folder", "log", "df", "plugin", "keep", "ir", "lock", "pkg", "doc", "build", "lib", "r", "def", "class", "desc", "directory", "parent", "DIR", "handler", "config", "direction", "loc", "draft", "dc", "wd", "fd", "store", "http", "dr", "dn", "data", "work", "up", "file", "dist", "download", "d", "director", "coll", "group", "part", "manager", "di"], "ff": ["flow", "uf", "fp", "iff", "cf", "cl", "xff", "upp", "now", "bb", "bd", "feed", "ffe", "df", "rf", "fb", "fl", "fff", "aff", "ft", "fe", "ef", "eph", " buff", "dd", "fold", "TF", "fx", "fox", "ph", "buf", "eff", "fam", "uff", "FF", "fed", "fd", "lf", "fw", "ffff", "bf", "pp", "cpp", "sf", "cb", "buff"], "files": ["objects", "classes", "groups", "flows", "iles", "fl", "users", "locks", "ls", "s", "sections", "lines", "jobs", "results", "fa", "fe", "items", "models", "rows", "images", "ps", "plugins", "events", "apps", "fs", "blocks", "Files", "pages", "data", "ums", "file", "keys", "split", "names", "bs", "balls", "features"], "f": ["fp", "v", "cf", "e", "feed", "x", "tf", "rf", "fl", "fb", "flat", "filename", "of", "name", "aff", "c", "fe", "fa", "fold", "t", "info", "i", "n", "F", "handler", "fc", " fa", "fr", "fs", "inf", "p", "fd", "lf", "l", "fn", "file", "d", "bf", " file", "fen", "sf", "part"], "newFile": ["newDir", "updateF", "NewFiles", "oldFiles", " newF", "NewFolder", "andFile", " newFolder", "newLine", "updateLine", " newDir", "NewF", "nextFiles", "NewDir", "newF", "updatefile", "smallfile", "smallFile", "NewFile", "updateFile", "nextFolder", " newfile", "smallDir", "oldDir", " newFiles", "existingFile", "oldFile", "newfile", "newFolder", "andDir", "oldF", "nextDir", "existingfile", "nextFile", "newFiles", "andfile", "existingLine", " newLine", "existingF"], "fi": ["qi", "fp", "cf", "fy", "ico", "ife", "uci", "xi", "ffe", "ini", "py", "fb", "cci", "fin", "Fi", "si", "fe", "fa", "ifi", "ii", "sci", "afi", "i", "info", "fine", "FI", "afe", "zi", "fc", "bi", "flo", "isi", "fr", "fs", "abi", "lf", "shi", "fw", "wi", "sf", "pi", "ifa"], "fo": ["uf", "FO", "cf", "xf", "ico", "osa", "lo", "io", "olo", "mo", "oo", "obi", "si", "fe", "os", "fa", "bo", "ho", "ofi", "afi", "info", "obo", "so", "o", "ki", "zo", "co", "afe", "flo", "inf", "wo", "di", "shi", "fw", "ni", "tto", "sf", "ko", "ato", "po"]}}
{"id1": "11475527", "id2": "13981689", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"addDataFromURL": ["addDataFromUrl", "addDatafromurl", "addDataFromurl", "addDataWithURL", "addTextfromurl", "addDatafromURL", "addDataForURL", "addDataFromFile", "addTextFromFile", "addDataWithurl", "addDataForUrl", "addDataForurl", "addDataForFile", "addTextFromURL", "addDataWithFile", "addTextfromURL", "addTextfromFile", "addTextfromUrl", "addTextFromUrl", "addDatafromUrl", "addDataWithUrl", "addTextFromurl", "addDatafromFile"], "theurl": [" theURL", " Theurl", "testUrl", " thelog", "youurl", " Thepublic", "theuri", " theUrl", "pythonuri", "youURL", "theUrl", "youlog", "testURL", "testurl", "myurl", "myURL", " thepublic", "theURL", "pythonURL", "mypublic", "thereURL", "thepublic", "testlog", " theuri", "thereuri", "myUrl", "youUrl", "pythonurl", "thelog", "thereurl", " TheUrl", " TheURL"], "line": ["url", "cl", "base", "reader", "str", "el", "id", "feed", "model", "log", "nl", "row", "string", "out", "name", "Line", "li", "lines", "write", "link", "len", "no", "character", "code", "LINE", "i", "connection", "pe", "number", "text", "object", "block", "sync", "buffer", "cell", "key", "l", "lin", "file", "style", "entry", "source", "letter", "char", "pass", "part", "ine", "unit", "comment", "f", "le"], "in": ["url", "ins", "reader", "din", "IN", "client", "login", "bin", "io", "inc", "isin", "ini", "input", "out", "In", "s", "conn", "inner", "stream", "fin", "image", "err", "fa", "oin", "read", "m", "or", "a", "i", "r", "info", "b", "again", "socket", "nin", "win", "inn", "it", "pin", "is", "arin", "l", "lin", "file", "source", "cin", "init", "inside", "rin", "pass", "serv", "record"], "data": ["url", "result", "da", "ata", "reader", "output", "DATA", "one", "default", "input", "er", "start", "out", "conn", "end", "stream", "lines", "inner", "next", "this", "like", "writer", "i", "r", "info", "connection", "dat", "body", "o", "handler", "buffer", "iter", "la", "plus", "l", "di", "file", "entry", "up", "source", "d", "open", "f"], "e": ["oe", "de", "error", "exc", "ue", "ele", "edge", "ace", "ise", "one", "ede", "ea", "ge", "er", "je", "es", "ee", "err", "E", "fe", "eme", "ef", "or", "ec", "en", "ie", "element", "event", "pe", "et", "ception", "eu", "o", "ale", "ae", "me", "ev", "se", "ke", "ne", "ade", "f", "ep", "ze", "ce", "be"]}}
{"id1": "10936821", "id2": "8417584", "code1": "    @Override\n    public void doIt() {\n        try {\n            Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\");\n            if (mode.equals(\"FTP\")) {\n                FTPClient client = new FTPClient();\n                client.connect(Constants.ftpHost);\n                client.login(Constants.ftpUser, Constants.ftpPass);\n                client.changeDirectory(Constants.ftpDir);\n                File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName);\n                client.download(\"GT99_A09.rar\", ff);\n                client.disconnect(false);\n                Shared.prepareMovements(ff);\n            } else if (mode.equals(\"File\")) {\n                JFileChooser jfc = new JFileChooser();\n                FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\");\n                jfc.setFileFilter(f);\n                int selection = jfc.showOpenDialog(Shared.getMyMainWindows());\n                if (selection == JFileChooser.APPROVE_OPTION) {\n                    Shared.prepareMovements(jfc.getSelectedFile());\n                } else {\n                    return;\n                }\n            }\n            Shared.updateMovements();\n            if (Shared.isHadMovements()) {\n                MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\");\n                msg.show(Shared.getMyMainWindows());\n            } else {\n                MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\");\n                msg.show(Shared.getMyMainWindows());\n            }\n        } catch (Exception ex) {\n            MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex);\n            msg.show(Shared.getMyMainWindows());\n        }\n    }\n", "code2": "    private String getResultFromHttpUrl(String href) {\n        String result = null;\n        try {\n            URL url = new URL(href);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Object o = conn.getContent();\n            log.debug(\"Opened \" + href + \" and got class \" + o.getClass().getName());\n            StringBuffer version = new StringBuffer();\n            String inputLine;\n            DataInputStream dis = new DataInputStream(conn.getInputStream());\n            while ((inputLine = dis.readLine()) != null) {\n                version.append(inputLine + \"\\n\");\n            }\n            result = version.toString();\n            log.debug(\"Read from URL:\\n\" + result);\n            dis.close();\n        } catch (Exception e) {\n            log.debug(\"Caught exception \" + e + \" whilst attempting to query URL \" + href);\n            e.printStackTrace();\n        } finally {\n            return result;\n        }\n    }\n", "label": 0, "substitutes": {"doIt": ["runInit", " doSomething", "runSomething", " doInit", "runit", "doit", "DoSomething", " doit", "DoInit", "Doit", "doInit", "DoIt", "doSomething", "runIt"], "client": ["cl", "cache", "local", "app", "force", "port", "session", "conn", "secure", "cp", "ssl", "i", "api", "p", "file", "server", "help", "https", "cm", "console", "remote", "conv", "class", "user", "Client", "close", "get", "pg", "http", "grid", "cli", "pool", "open", "cell", "net", "util", "project", "call", "API", "connect", "bird", "parent", "config", "per", "socket", "clip", "resource", "con", "url", "ip", "clean", "request", "default", "plugin", "host", "end", "contact", "ci", "connection", "cloud", "co", "simple", "act", "and", "web", "ce"], "ff": ["flow", "uf", "fp", "url", "cf", "iff", "cl", "upp", "bb", "ob", "feed", "bd", "df", "fb", "fl", "mb", "fff", "cp", "aff", "kk", "ft", "fe", "eph", "ef", "buff", "fx", "ph", "buf", "front", "eff", "back", "abb", "FF", "uff", "eb", "cd", "nd", "fi", "fd", "af", "lf", "bf", "pp", "cpp", "sf", "cb"], "jfc": ["jsfe", "fcf", "lFC", "lpc", "jsfc", "Jcf", "JFC", "jetFC", " jpc", "jcf", "jxf", "fFC", "dfc", "Jbc", "jspc", "jbc", "jFC", " jFC", " jbc", "Jfe", " jxf", "ffc", "Jxf", "dcf", "jetfc", "fbc", "dpc", "lcf", "jetxf", "jfe", "jscf", "jetpc", "Jpc", "jpc", "Jfc", "dfe", "lfc", " jcf"], "f": ["fp", "v", "xf", "cf", "w", "orf", "e", "io", "rf", "df", "fb", "s", "c", "raf", "fe", "self", "m", "t", "j", "i", "r", "info", "g", "b", "n", "F", "handler", "fc", "fs", "p", "fo", "h", "fd", "lf", "l", "filter", "file", "d", "sf", "fac"], "selection": ["position", "url", "cl", "lection", "election", "delete", "SELECT", "selected", "which", "shell", " selected", "slot", "index", "qua", "sl", "location", "Se", "language", "edition", " selections", "si", "choice", " selecting", "sel", "ses", "expression", "management", "ssl", "sb", "info", "connection", "desc", "directory", "loc", "slice", " Selection", "option", "ling", "entry", "match", "sc", "random", "select"], "msg": ["arg", "md", "cm", "Message", "img", "mess", "exc", "error", "send", "ng", "gen", "console", "ms", "gm", "view", "e", "dict", "db", "log", "comm", "plugin", "gl", "s", "cmd", "bug", "mit", "err", "pkg", "og", "doc", "bot", "link", "sg", "generic", "m", "global", "live", "html", "g", "body", "Msg", "bg", "mg", "list", "game", "message", "lang", "kg", "get", "ck", "file", "help", "dm", "cat", "conf", "mu", "mail", "gs", "module"]}}
{"id1": "8747840", "id2": "5977352", "code1": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["rm", "transfer", "zip", "Copy", "load", "put", "cp", "write", "Cop", " cp", "clone", "all", "cop", "sync", "diff", "clip", "p", "get", " transfer", "file", "download", "dump", "mop", "split", " Copy", "paste", "cmp"], "src": ["ource", "url", "sit", "ins", "img", "reader", "gb", "path", "sl", "input", "filename", "obj", "s", "stream", "archive", "files", "sel", "sb", "b", "sin", "back", "config", "loc", "inst", "uri", "resource", "inf", "rb", "rc", "source", "file", "dist", "ref", "rin", "cb"], "dest": ["test", "de", "result", "thin", "sup", "save", "delete", "output", "tmp", "comb", "exit", "folder", "target", "flat", "name", "obj", "down", "Dest", "class", "b", "orig", "desc", "wb", "done", "source", "destroy", "file", "tif", "usr", "dist", "die", "later", "home", "opt", "txt", " Dest", "temp"], "in": ["url", "gin", "ins", "thin", "din", "reader", "IN", "login", "bin", "id", "isin", "inc", "sub", "ini", "input", "In", "conn", "inner", "ln", "stream", "image", "m", "a", "i", "r", "n", "again", "rec", "pull", "socket", "nin", "win", "inn", "h", "is", "l", "source", "lin", "file", "inside", "rin", "con", "impl", "as", "f"], "out": ["exec", "v", "img", "OUT", "client", "outs", "cache", "w", "output", "app", "exp", "io", "inc", "ou", "one", "log", "conn", "ext", "obj", "err", "off", "this", "Out", "self", "writer", "i", "b", "ex", "n", "again", "o", "over", "socket", "post", "outer", "line", "source", "pool", "file", "up", "home", "part", "exit", "temp"], "buf": ["uf", "v", "cap", "bc", "cf", "base", "fp", "uc", "bb", "bp", "tmp", "br", "bd", "cv", "raw", "cur", "ctx", "fb", "length", "cr", "seq", "cp", "cmd", "queue", "len", "bl", "bag", "buff", "batch", "count", "b", "orig", "ff", "wb", "buffer", "ab", "p", "bytes", "rb", "fd", "rc", "data", "bh", "bf", "cb", "f"], "c": ["v", "lc", "cm", " i", "cf", "cl", "cy", "uc", "z", "k", "unc", "e", "C", "cur", "pointer", "cr", "u", "cp", "ci", "cc", "code", "m", "ct", "ec", "a", "i", "count", "r", "b", "ce", "n", "cu", "xc", "o", "enc", "fc", "loc", " b", "dc", "cd", "p", "rc", "col", "l", " n", "ch", "d", "pc", " rc", "nc", "ac", "cb", "f"]}}
{"id1": "16931472", "id2": "12172485", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"handler": [" handling", " response", "handle", " serve", " handle", " success", " init", " next", "callback", " load", " rewrite", " setup", "Handler", " callback", " complete", " redirect", " on", " notify", " processing", "process", " fire", " done", " f", " transfer", " fn", " dispatch", " finish"], "result": ["complete", "map", "feature", "cache", "status", "re", "output", "view", "dict", "Result", "row", "session", "res", "order", "results", "event", "report", "list", "table", "message", "array", "buffer", "resource", "document", "page", "data", "source", "match", "json", "group", "record", "manager", "response"], "target": ["external", "template", "base", "master", "client", "token", "arget", "project", "output", "site", "current", "proxy", "request", "goal", " Target", "environment", "owner", "session", "location", "host", "tail", "image", "next", "link", "this", "database", "Target", "type", "reference", "connection", "event", "html", "class", "route", "object", "parent", "favorite", "task", "config", "layout", "the", "resource", "version", "it", "content", "http", "page", "source", "data", "server", "style", "download", "about", "theme", "that", "unit", "manager", "response"], "url": ["address", "base", "str", "view", "feed", "io", "URL", "path", "sl", "Url", "string", "stream", "build", "org", "ssl", "connection", "user", "browser", "socket", "loader", "buffer", "uri", "service", "resource", "http", "page", "l", "file", "server", "source", "channel", "blog"], "reader": ["builder", "e", "feed", "io", "rr", "worker", "rer", "ler", "row", "er", "input", "stream", "driver", "err", "editor", "read", "Reader", "bird", "layer", "writer", "i", "report", "rx", "over", "loader", "ner", "ri", "buffer", "iter", "parser", "iterator", "http", "rc", "in", "ry", "file", "server", "reading", "f"], "line": ["cl", "error", "e", "id", "log", "nl", "row", "name", "li", "link", "strip", "message", "data", "file", "limit", "header", "status", "lo", "lined", "string", "lock", "LINE", "or", "pe", "user", "definition", "rule", "o", "block", "buffer", "key", "l", "page", "liner", "comment", "rl", "cell", "lc", "base", "str", "parse", "el", "zip", "sl", "range", "lines", "err", "no", "code", "info", "body", "non", "lf", "lin", "source", "inline", "email", "home", "ine", "side", "view", "site", "plugin", "end", "profile", "Line", "look", "live", "text", "sync", "iter", "point", "style", "frame", "response", "le"], "entry": ["builder", "enter", "e", "feed", "term", "owner", "row", "ge", "string", "inner", "archive", "section", "link", "entity", "editor", "layer", "extra", "or", "element", "writer", "ie", "counter", "ent", "connection", "Entry", "per", "ner", "her", "uri", "service", "resource", "key", "rc", "page", "ry", "data", "se", "source", "match", "member", "value", "part", "exit", "ener", "cell"], "fromIndex": ["sourceSection", "startIndex", "fromPoint", "FromLength", "fromLength", "FromOffset", "FromIndex", "toIndex", "fromSection", "startLength", " fromLength", "fromPosition", " fromPosition", " fromSection", "FromPoint", "startPosition", " fromOffset", "toPoint", "FromSection", "toPosition", "fromOffset", " fromPoint", "FromPosition", "startOffset", "sourcePoint", "toOffset", "sourceIndex", "sourcePosition"], "r": ["v", "vr", "w", "re", "sr", "mr", "e", "ar", "rr", "nr", "er", "res", "q", "u", "cr", "range", "c", "m", "rg", "b", "attr", "ner", "ri", "fr", "ru", "lr", "array", "p", "rb", "rc", "l", "R", "d", "f", "rl", "rs", "pr"]}}
{"id1": "838844", "id2": "18211588", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"convert": ["CONception", " deconversion", "Converted", "oconversion", "subversion", "CONverted", "unception", "subverting", "CONvert", "subverted", "unvert", "unverted", "Conception", "CONverting", " deconverting", "oconverted", "Conversion", "Converting", "CONversion", "oconvert", " deconverted", "conception", "converting", "subvert", "oconverting", "Convert", "conversion", "converted", "unversion", " deconvert"], "src": ["sys", "ource", "fp", "url", "sit", "prot", "st", "img", "reader", "gb", "tmp", "load", "cb", "proc", "scene", "path", "input", "filename", "string", "name", "obj", "s", "stream", "secure", "sth", "Source", "spec", "upload", "storage", "sel", "code", "username", "SourceFile", "ssl", "sb", "component", "Dest", "supp", "buf", "video", "sin", "attr", "back", "config", "loc", "slice", "inst", "sn", "uri", "resource", "rb", "feat", "rc", "href", "source", "fn", "sc", "file", "download", "ref", "RC", "gz", "dist", "req", "stage", "impl", "cpp", "rl", "ctx", "cmp"], "dest": ["disk", "test", "cont", "img", "bin", "tmp", "path", "target", "obj", "lib", "std", " dst", "Dest", "class", "dat", "orig", "null", "dc", "di", "source", "fn", "dir", "dist", " destination", "home", "txt", "temp"], "in": ["ins", "din", "reader", "IN", "login", "bin", "isin", "inc", "io", "ini", "val", "input", "In", "stream", "err", "doc", "inas", "t", "a", "i", "r", "ex", "n", "ps", "win", "inn", "inf", "pin", "is", "data", "source", "up", "file", "d", "pass", "as", "f"], "p": ["fp", "jp", "v", "pa", "tp", "bp", "e", "lp", "pre", "pm", "P", "py", "pr", "s", "cp", "c", "np", "m", "t", "j", "i", "r", "pe", "g", "b", "cop", "o", "ps", "per", "parser", "pd", "pg", "h", "wp", "l", "op", "pb", "d", "pc", "pp", "sp", "part", "f", "pi", "po"], "ds": ["posts", " DS", "eps", "dp", "ths", "vs", "els", "os", " ps", "dat", "ps", " sd", "pd", "uds", "data", "qs", "utils", "points", "rs", "services", "da", "groups", "db", "docs", "s", "ls", "hs", "words", "ys", "models", "cs", "ans", "di", "ld", "cons", "gs", "ins", "xs", "ges", "ts", "nas", "ks", "sts", "ded", "lines", "vals", "js", "ups", "plugins", "dates", "ants", "dds", "ss", "scripts", "tests", "ils", "ads", "sys", "Ds", "ays", "dl", "lp", "tools", "df", "ns", "styles", "dd", "gd", "des", "dos", "sync", " props", "dc", "parts", "dt", "obs", "dist", "amps", "d", "DS", "icks", "dm", "ipes", "bs"], "format": ["template", "atter", "url", "fp", "magic", "model", "path", "function", "plugin", "host", "pattern", "filename", "string", "nat", "language", "struct", "name", "prefix", "spec", "t", "type", "at", "Format", "class", "tag", "handler", "config", "layout", "sche", "table", "parser", "api", "version", "scale", "form", "feat", "fd", "data", "source", "file", "filter", "letter", "ant", "fn", "style", "act", "frame", "unit", "part", "record", "f"], "hasPixelData": ["hasByteData", "showsPixelDATA", "hasPictureSize", "haspixelSize", " hasPixelSize", " hasPixeldata", "showsByteData", "showsByteStyle", "showsBytedata", "showsPixeldata", "hasPixelSize", "hasPicturedata", "showsPixelStyle", "hasByteSize", "hasPixelDATA", "hasPictureData", "hasPixeldata", "hasByteStyle", "haspixelData", "showsByteDATA", "haspixeldata", "hasPixelStyle", "hasBytedata", "showsPixelData", "hasByteDATA"], "inflate": ["inflace", "invenATE", "Inflation", "inFlate", "inflating", "infolode", "insvenate", "inFlation", "insvenATE", "invenode", "insvenating", "inflated", "Inflated", "inadequode", "inadequate", "inffation", "invenate", "insflate", "inflATE", "Inflate", "infloated", "inFlated", "infface", "InFlate", "insflATE", "Inflace", "InFlace", "inadequATE", "insflating", "inFlace", "infloate", "InFlation", "infloation", "insvenode", "inflode", "infolATE", "infloace", "inffate", "infolate", "inflation", "invenating", "inadequating", "InFlated", "insflode", "infolating", "inffated"], "pxlen": ["mxlen", "pxsize", "mxdata", "fxlen", "pgLen", "mxcount", "pgl", "fxden", "pxdata", "fxl", "axlon", "pxl", "pxlength", "pxlon", "pnglength", "xpsize", "pplen", "mxsize", "txlon", "axln", "pclin", "camlen", "pxLen", "camdata", "fxLen", "pxden", "pglen", "pxcount", "pxpos", "fxpos", "pclen", "txlen", "pxln", "pxlin", "campos", "txln", "fxdata", "pclon", "camln", "txlin", "xplen", "xplength", "fxln", "axlin", "ppden", "mxlength", "ppl", "pgden", "pnglen", "ppLen", "pngsize", "mxpos", "pngcount", "axlen", "xpcount", "mxln", "pcln"], "out": ["sys", "v", "error", "OUT", "outs", "cache", "gen", "re", "output", "io", "log", "session", "conn", "obj", "state", "lock", "err", "Out", "step", "lib", "user", "again", "parent", "co", "query", "list", "pad", "post", "copy", "point", "store", "cli", "line", "work", "up", "server", "page", "dump", "group", "inter"]}}
{"id1": "11475527", "id2": "9327525", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    @Test\n    public void test02_ok() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(chartURL);\n            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);\n            nameValuePairs.add(new BasicNameValuePair(\"ws\", \"getDomainEvolution\"));\n            nameValuePairs.add(new BasicNameValuePair(\"chartTitle\", \"test\"));\n            nameValuePairs.add(new BasicNameValuePair(\"type\", \"chart\"));\n            nameValuePairs.add(new BasicNameValuePair(\"firstDate\", \"20111124\"));\n            nameValuePairs.add(new BasicNameValuePair(\"lastDate\", \"20111125\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParams\", \"type,counting,protocol,unit,proxy,domain,timeScale,period\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParamsValues\", \"chart,volume,all,hits,all,google.com,day,360\"));\n            nameValuePairs.add(new BasicNameValuePair(\"serieTitle\", \"serie\"));\n            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            assertNotNull(entity);\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));\n            System.out.println(reader.readLine());\n            instream.close();\n            assertEquals(\"error :\" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"addDataFromURL": ["addDataFromUrl", "addDatafromurl", "addDataFromurl", "addDataWithURL", "addTextfromurl", "addDatafromURL", "addDataForURL", "addDataFromFile", "addTextFromFile", "addDataWithurl", "addDataForUrl", "addDataForurl", "addDataForFile", "addTextFromURL", "addDataWithFile", "addTextfromURL", "addTextfromFile", "addTextfromUrl", "addTextFromUrl", "addDatafromUrl", "addDataWithUrl", "addTextFromurl", "addDatafromFile"], "theurl": [" theURL", " Theurl", "testUrl", " thelog", "youurl", " Thepublic", "theuri", " theUrl", "pythonuri", "youURL", "theUrl", "youlog", "testURL", "testurl", "myurl", "myURL", " thepublic", "theURL", "pythonURL", "mypublic", "thereURL", "thepublic", "testlog", " theuri", "thereuri", "myUrl", "youUrl", "pythonurl", "thelog", "thereurl", " TheUrl", " TheURL"], "line": ["url", "cl", "base", "reader", "str", "el", "id", "feed", "model", "log", "nl", "row", "string", "out", "name", "Line", "li", "lines", "write", "link", "len", "no", "character", "code", "LINE", "i", "connection", "pe", "number", "text", "object", "block", "sync", "buffer", "cell", "key", "l", "lin", "file", "style", "entry", "source", "letter", "char", "pass", "part", "ine", "unit", "comment", "f", "le"], "in": ["url", "ins", "reader", "din", "IN", "client", "login", "bin", "io", "inc", "isin", "ini", "input", "out", "In", "s", "conn", "inner", "stream", "fin", "image", "err", "fa", "oin", "read", "m", "or", "a", "i", "r", "info", "b", "again", "socket", "nin", "win", "inn", "it", "pin", "is", "arin", "l", "lin", "file", "source", "cin", "init", "inside", "rin", "pass", "serv", "record"], "data": ["url", "result", "da", "ata", "reader", "output", "DATA", "one", "default", "input", "er", "start", "out", "conn", "end", "stream", "lines", "inner", "next", "this", "like", "writer", "i", "r", "info", "connection", "dat", "body", "o", "handler", "buffer", "iter", "la", "plus", "l", "di", "file", "entry", "up", "source", "d", "open", "f"], "e": ["oe", "de", "error", "exc", "ue", "ele", "edge", "ace", "ise", "one", "ede", "ea", "ge", "er", "je", "es", "ee", "err", "E", "fe", "eme", "ef", "or", "ec", "en", "ie", "element", "event", "pe", "et", "ception", "eu", "o", "ale", "ae", "me", "ev", "se", "ke", "ne", "ade", "f", "ep", "ze", "ce", "be"]}}
{"id1": "17791385", "id2": "5125848", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "src": ["url", "sit", "ipl", "st", "img", "ins", "sup", "sl", "input", "filename", "s", "ls", "stream", "obj", "image", "upload", "files", "sel", "sb", "b", "sin", "dest", "back", "config", "loc", "inst", "uri", "resource", "inf", "rb", "http", "rc", "source", "file", "sc", "dist", "txt"], "dst": ["fdst", "ddst", "Dlt", "ddest", "ddfd", "pdsp", "Dsts", "ddsp", "pdft", "ststs", "dft", "fdsp", "dlt", " dlt", "stdest", "Dst", "fdfd", "dsp", "ddft", "pdfd", "dfd", " ddest", "stst", "Ddest", "stlt", "dsts", "pdst", "fdft", " dsts"], "in": ["url", "gin", "ins", "din", "reader", "IN", "login", "bin", "id", "inc", "ini", "input", "In", "conn", "inner", "ln", "err", "oin", "m", "i", "r", "n", "again", "sin", "pull", "socket", "nin", "win", "inn", "pin", "h", "is", "cin", "lin", "data", "file", "init", "inside", "kin", "rin", "con", "impl", "as", "f"], "out": ["net", "exec", "OUT", "client", "outs", "cache", "w", "output", "bin", "exp", "io", "inc", "raw", "x", "conn", "s", "ext", "obj", "err", "off", "Out", "plain", "self", "at", "writer", "i", "ex", "n", "again", "parent", "o", "null", "sync", "post", "outer", "copy", "other", "line", "file", "up", "server", "part", "f", "temp"], "buf": ["vec", "uf", "v", "cap", "bc", "base", "uc", "bb", "bin", "br", "bd", "raw", "cur", "ctx", "val", "fb", "fl", "length", "seq", "cmd", "queue", "c", "off", "bl", "bag", "batch", "count", "b", "ff", "loc", "pad", "wb", "buffer", "bytes", "rb", "fd", "rc", "data", "bh", "bf", "lim", "cat", "cb", "buff"], "len": ["cap", "lc", "cl", "base", "bin", "el", "Len", "val", "sl", "fl", "length", "ind", "li", "fin", "name", "ln", "end", "no", "c", "err", "all", "en", "i", "count", "n", "ll", "nt", "ix", "fd", "lf", "line", "data", "l", "lin", "pos", "lt", "lim", "split", "part", "size", "f", "le", "rev"]}}
{"id1": "16550855", "id2": "3197876", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "label": 0, "substitutes": {"readPage": ["getFile", "openFile", "findPages", "getPages", "openPage", "openPages", "findpage", "readPages", "readFile", "findFile", "readpage", "getpage", "findPage", "openpage", "getPage"], "ignoreComments": ["includeComments", "ignoreTags", " ignorecomments", "usecomments", "oreComment", "includeTags", "oreQuotes", "ignoreQuotes", "includeComment", "ignoreComment", "useTags", "orecomments", "oreTags", " ignoreComment", "useComments", " ignoreTags", "includecomments", "useQuotes", "oreComments", " ignoreQuotes", "ignorecomments"], "in": ["url", "gin", "ins", "reader", "din", "IN", "token", "client", "re", "login", "bin", "e", "id", "isin", "inc", "ini", "index", "input", "out", "In", "s", "on", "inner", "stream", "image", "c", "err", "m", "t", "ssl", "i", "r", "connection", "user", "b", "again", "rec", "socket", "loader", "nin", "win", "buffer", "inn", "version", "min", "it", "h", "http", "into", "is", "data", "source", "lin", "file", "init", "kin", "inside", "con", "as", "f"], "inputLine": [" inputText", "ifline", "requestLine", " inputCo", " inputRow", "requestline", "pullLine", "requestCo", "InputLook", "ifLook", " inputName", "InputText", "InputL", "rawLine", "installline", "incL", "ifCo", "InputCell", " inputPage", "commentCell", "inputRow", "incline", "imageline", "requestRow", "inputPage", " inputCell", "inputL", "commentLine", "inputLink", "commentPage", "pullLink", "imageLook", "rawline", "inputName", " inputLink", "Inputline", "inputCell", "commentline", "InputName", "rawL", "installLine", "inputline", "rawText", "requestLook", "installL", "imageLine", "ifLine", "requestLink", " inputL", "InputLine", "rawLink", "InputLink", " inputline", "incLook", "inputText", "incLine", "inputLook", "inputCo", "pullline", "InputPage", "pullRow", "installLook", " inputLook", "imageL", "rawName"], "html": ["template", "strong", "url", "result", "base", "header", "img", "wrap", "amp", "title", "flash", "str", "output", "war", "view", "tt", "high", "htm", "xml", "tml", "tf", "gh", "flat", "ui", "bsp", "hard", "doc", "link", "plain", "format", "live", "show", "js", "text", "body", "attr", "www", "css", "embed", "message", "api", "detail", "content", "h", "links", "http", "page", "data", "article", "source", "inline", "hot", "HTML", "summary", "bf", "dump", "ht", "json", "details", "home", "part", "atom", "web", "rss", "blog", "f", "msg", "temp"]}}
{"id1": "5399593", "id2": "13414771", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["encipher", "escrypt", "encress", "decryption", "escryption", " encryption", "decipher", " encress", "decrypt", "encryption", " encipher", "escipher", "escress", "decress"], "plaintext": ["forecontent", " plainText", " plaincontent", "plainTEXT", "rainText", "plainform", "singleform", "ainform", "singletext", "foreText", "plainText", " plainform", "singleText", "ainText", "raincontent", "raintext", "singleTEXT", "foretext", "rainTEXT", "aintext", "plaincontent", " plainTEXT", "foreTEXT", "ainTEXT"], "UnsupportedEncodingException": ["UnsupportedEncodingError", "UnsupportedEncryptionException", "UnsupportedCodedException", "UnsupportedEncodingEx", "UnsupportedCodingEx", "UnsupportedCodedEx", "UnsupportedEncgorithmError", "UnsupportedEncodedError", "UnsupportedEncgorithmEx", "UnsupportedEncryptionError", "UnsupportedEncryptionEx", "UnsupportedCodingException", "UnsupportedCodedError", "UnsupportedEncodedException", "UnsupportedEncodedEx", "UnsupportedEncgorithmException", "UnsupportedCodingError"], "md": ["mad", "MD", "map", "sha", "mc", "dig", "ms", "metadata", "rm", "pm", "bd", "amd", "db", "am", "mo", "meta", "mb", "mt", "mage", "cmd", "material", "hd", "code", "mand", "m", "dd", "Cmd", "hed", "od", "mg", "mm", "ma", "message", "dc", "cd", "wd", "mac", "mn", "hm", "mod", "me", "d", "mag", "bf", "nm", "dm", "mem", "sum", "mu", " MD", "mp", "po"], "raw": ["ghost", "sha", "dec", "wrap", "unsigned", "clean", "ng", "flash", "RAW", "sign", "load", "row", "input", "aws", "rew", "original", "missing", "hex", "serial", "Raw", "null", "micro", "unknown", "empty", "buf", "enc", "block", "message", "alpha", "array", "blocks", "buffer", "shared", "instance", "full", "initial", "ack"], "hash": ["url", "base", "sha", "header", "ash", "cache", "rh", "flash", "id", "Hash", "log", "string", "kh", "image", "hex", "hh", "ruby", "ashes", "code", "auth", "build", "html", "text", "hed", "block", "message", "array", "version", "alpha", "key", "mac", "h", "math", "abi", "sh", "data", "password", "secret", "shared", "sum", "ha"]}}
{"id1": "18504192", "id2": "9550506", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "in": ["url", "base", "ins", "reader", "IN", "login", "bin", "id", "io", "inc", "old", "ini", "index", "input", "In", "name", "inner", "image", "c", "m", "or", "at", "i", "info", "b", "again", "parent", "diff", "buffer", "inn", "min", "copy", "data", "file", "d", "src", "ac", "part"], "out": ["exec", "external", "base", "OUT", "client", "outs", "cache", "w", "call", "output", "io", "inc", "target", "name", "conn", "obj", "string", "c", "err", "prefix", "Out", "writer", "connection", "b", "ex", "n", "object", "again", "o", "dest", "p", "copy", "point", "line", "data", "file", "password", "part", "temp"], "source": ["ource", "slave", "reader", "client", "project", "scope", "view", "use", "proxy", "sl", "input", "target", "start", "core", "secure", "stream", "Source", "settings", "self", "storage", "clone", "ssl", "ie", "i", "connection", "component", "writer", "null", "parent", "sin", "dest", "slice", "sync", "ources", "iter", "service", "get", "copy", "from", "channel", "se", "server", "src", "origin", "unit", "size", "SOURCE"], "destination": ["destinator", "testinations", "Destinated", "Destification", "Destining", " destining", "Destination", "testinated", "dependification", " destinations", "destinations", "declification", "declinated", " destinator", "declinator", "contining", "dependinated", "testination", " destinated", "declination", "dependination", "destinated", "testinator", "destining", "contination", "dependinator", "destification", "Destinations", "continated", "Destinator", "continator"]}}
{"id1": "22135199", "id2": "16215393", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"testCodingEmptyFile": ["testCodingZeroFile", "testCachingEmptyStream", "testCachingEmptyFiles", "testCodingNoFile", "testCachingOfFile", "testCachingEmptySourceFile", "testCodingOfFile", "testCodingZeroFiles", "testCodingOfSourceFile", "testCodingZeroSourceFile", "testCachingOfSourceFile", "testCodingEmptyFiles", "testCodingNoSourceFile", "testCachingOfStream", "testCodingOfStream", "testCachingEmptyFile", "testCachingOfFiles", "testCodingNoFiles", "testCodingNoStream", "testCodingEmptyStream", "testCodingZeroStream", "testCodingEmptySourceFile", "testCodingOfFiles"], "baos": ["Baoes", "baoS", "waOs", "buo", "baoa", "aaaaOs", "paoa", "BaOS", "pao", "kao", "baOs", "bioS", "bioes", "biotes", "waos", "aaaaos", " baotes", "aaaaoS", "bao", "waoS", " baoS", "BaoS", " baoes", "baotes", "buos", "waOS", "baOS", "kaos", "kaOS", "kaoa", "baoes", "BaOs", "bios", "Baos", "paos", "aaaaOS", "buOS", "buoa", "Baotes", "paOS"], "channel": ["an", "camera", "flow", "url", "cam", "reader", "console", "system", "client", "bean", "feed", "io", "container", "chan", "log", "out", "conn", "context", "stream", "sea", "queue", "c", "self", "connection", "cho", "video", "parent", "handler", "config", "socket", "service", "Channel", "data", "ch", "sc", "server", "source", "group", "can", "annels"], "params": ["processor", "Param", "proc", "Parameters", "tx", "stats", "conn", "cms", "param", " parameters", "Par", "options", "cpu", "null", "par", "ops", "ps", "config", "mm", "css", "parser", " param", "api", "http", "ams", "size", "ctx", "cmp", "settings"], "outbuf": ["Outbuffer", "Outbuff", "inputbuf", " outbuffer", "outputcb", "Outbuf", "outputbuf", "Outcb", "inputqueue", "outputbag", "outputqueue", " outcb", "outqueue", " outbuff", "inputbuff", "outcb", "outbuffer", "inputbag", "outputbuff", "outputbuffer", " outbag", "outbuff", " outqueue", "outbag"], "metrics": ["metals", "matals", "Metals", " metics", "metics", " metals", "metras", " metrix", " metras", "Metric", "monrics", "matric", "metric", "matrix", "Metras", "monics", "Metrix", "monric", "Metrics", "monras", " metric", "Metics", "matrics", "metrix"], "encoder": ["Encoser", "Encoded", "ecode", " encipher", "encoser", " encressor", "enressor", "encoded", "enccode", "ecoding", "Encler", " encoded", "ecipher", "ecler", " encoding", "ecressor", "eccode", "Encoder", "ecoder", "enoded", "encressor", "Encipher", "ecoser", "encler", " encler", "enode", "ecoded", " encode", "encipher", "Encoding", "enoser", "encoding", "Encode", "encode", " enccode", " encoser", "enoder"], "tmpFile": ["poraryfile", "mpFiles", "txtFunction", " tmpFiles", " tmpfile", "vtFile", "poraryPage", "vtfile", "tmpDir", "tmpFunction", "tmpPath", "mpPage", "mpFilename", " tmpDir", "txtFile", "tmpFolder", "mpFunction", "tempFolder", " tmpFilename", "tmpFilename", "tempFile", "testFiles", "txtfile", "mpDir", "tmpPage", "mpFile", "vtDir", " tmpFolder", "poraryFile", "poraryFunction", "testFile", "testFolder", "tempFiles", "tempfile", "mpfile", "vtFilename", "txtPage", "testfile", "tmpfile", "mpPath", "tempPath", "tmpFiles", " tmpPath"], "fout": ["fdurl", " fio", "flwrite", "flurl", "sffile", "frwrite", "ffile", "sfchannel", "Fchannel", "flagain", "frurl", " ffile", "sfio", "frout", "fio", "furl", "sfout", "Fio", "fagain", "fdagain", "Ffile", "fragain", "fwrite", "flout", "fdwrite", "Fout", "fdout"], "wrtout": ["wRTin", "wadrout", "wRTOut", "wRTn", "wrdwriter", "wrdout", "wrin", " wrcouter", "wrcouter", "wrtouter", "wRTouter", "wrout", " wrcin", "wadrwriter", "Wrtouter", "WRTin", " wrcout", "wrcOut", "Wrtn", "wrcout", "wrOut", "wrtOut", " wrtouter", "wrdouter", "wrcn", "Wrtout", "wadragain", "WRTOut", "Wrtin", "wRTagain", " wrtagain", "wadrouter", "wrtn", "wadrin", "WRTwriter", "WRTn", "WrtOut", "wrdin", "wrcagain", " wrcagain", "wrcin", "WRTouter", "wrtin", "Wrtwriter", "wrn", "wrtagain", "wRTwriter", "wrtwriter", " wrtin", "WRTout", "wRTout"], "fchannel": [" fchan", "pqueue", "bcontainer", "fqueue", "fenresource", " fcontainer", "hstream", "pcontainer", "pchan", "hresource", " fconn", "fcontainer", "fconn", "bchan", "fresource", "fstream", "pstream", "fchan", "bconn", "fenchannel", "fenstream", "pchannel", "bchannel", "fenqueue", "hchannel", "pconn", "hqueue", "presource"], "s": ["su", "v", "services", "ins", "ms", "e", "ts", "es", "ns", "abs", "string", "ls", "u", "c", "states", "os", "ses", "strings", "m", "t", "i", "r", "g", "b", "js", "n", "o", "ps", "S", "p", "l", "qs", "ss", "f", "gs", "ings", "settings"]}}
{"id1": "14001795", "id2": "15799935", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyoverwarFiles", "copyOverWebfile", "copyoverWarPath", "copyoverwarPath", "copyOverWebFiles", "copyOverWarFiles", "copyOverWARFiles", "copyOverWebPath", "copyOverWARFile", "copyOverwarFile", "copyOverWarfile", "copyOverWarPath", "copyOverWARPath", "copyoverwarfile", "copyoverWarfile", "copyoverWarFile", "copyoverwarFile", "copyoverWarFiles", "copyOverWARfile", "copyOverWebFile", "copyOverwarFiles", "copyOverwarfile", "copyOverwarPath"], "dir": ["md", "url", " directory", "cache", "clean", "local", "direct", "window", "handle", "Dir", "zip", "feed", "cur", "db", "folder", "log", "df", "plugin", "keep", "ir", "lock", "pkg", "doc", "build", "lib", "r", "def", "class", "desc", "directory", "parent", "DIR", "handler", "config", "direction", "loc", "draft", "dc", "wd", "fd", "store", "http", "dr", "dn", "data", "work", "up", "file", "dist", "download", "d", "director", "coll", "group", "part", "manager", "di"], "ff": ["flow", "uf", "fp", "iff", "cf", "cl", "xff", "upp", "now", "bb", "bd", "feed", "ffe", "df", "rf", "fb", "fl", "fff", "aff", "ft", "fe", "ef", "eph", " buff", "dd", "fold", "TF", "fx", "fox", "ph", "buf", "eff", "fam", "uff", "FF", "fed", "fd", "lf", "fw", "ffff", "bf", "pp", "cpp", "sf", "cb", "buff"], "files": ["objects", "classes", "groups", "flows", "iles", "fl", "users", "locks", "ls", "s", "sections", "lines", "jobs", "results", "fa", "fe", "items", "models", "rows", "images", "ps", "plugins", "events", "apps", "fs", "blocks", "Files", "pages", "data", "ums", "file", "keys", "split", "names", "bs", "balls", "features"], "f": ["fp", "v", "cf", "e", "feed", "x", "tf", "rf", "fl", "fb", "flat", "filename", "of", "name", "aff", "c", "fe", "fa", "fold", "t", "info", "i", "n", "F", "handler", "fc", " fa", "fr", "fs", "inf", "p", "fd", "lf", "l", "fn", "file", "d", "bf", " file", "fen", "sf", "part"], "newFile": ["newDir", "updateF", "NewFiles", "oldFiles", " newF", "NewFolder", "andFile", " newFolder", "newLine", "updateLine", " newDir", "NewF", "nextFiles", "NewDir", "newF", "updatefile", "smallfile", "smallFile", "NewFile", "updateFile", "nextFolder", " newfile", "smallDir", "oldDir", " newFiles", "existingFile", "oldFile", "newfile", "newFolder", "andDir", "oldF", "nextDir", "existingfile", "nextFile", "newFiles", "andfile", "existingLine", " newLine", "existingF"], "fi": ["qi", "fp", "cf", "fy", "ico", "ife", "uci", "xi", "ffe", "ini", "py", "fb", "cci", "fin", "Fi", "si", "fe", "fa", "ifi", "ii", "sci", "afi", "i", "info", "fine", "FI", "afe", "zi", "fc", "bi", "flo", "isi", "fr", "fs", "abi", "lf", "shi", "fw", "wi", "sf", "pi", "ifa"], "fo": ["uf", "FO", "cf", "xf", "ico", "osa", "lo", "io", "olo", "mo", "oo", "obi", "si", "fe", "os", "fa", "bo", "ho", "ofi", "afi", "info", "obo", "so", "o", "ki", "zo", "co", "afe", "flo", "inf", "wo", "di", "shi", "fw", "ni", "tto", "sf", "ko", "ato", "po"]}}
{"id1": "3187685", "id2": "4750967", "code1": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"copyJar": ["copySocket", "CopySocket", " copyingSocket", " copyingJam", "CopyJam", "zipJam", " copyingZip", "zipZip", "CopyJar", "copyJam", "CopyZip", "copyZip", " copyingJar", "zipSocket", "zipJar"], "src": ["url", "sit", "st", "img", "uc", "sub", "path", "sl", "input", "host", "filename", "core", "ls", "s", "stream", "obj", "archive", "image", "upload", "files", "storage", "sel", "ssl", "sb", "sq", "b", "buf", "dest", "config", "loc", "inst", "uri", "resource", "rb", "rc", "l", "source", "file", "sc", "dist", "download", "rs"], "dst": ["eddr", "odset", "edsts", "ddr", "fput", "edst", "edput", "dset", " ddr", " dset", "odsts", "odst", "dput", "odput", "fsts", "fst", "ldput", "lddr", " dput", "dsts", "ldsts", "fset", "ldst", " dsts"], "srcChannel": ["srcConnection", "rcClient", "srcClient", " srcConnection", "srcPage", "srcContext", "destClient", "rcConnection", " srcchannel", " srcPage", "sourceContext", "instPage", "sourcePage", "sourceChan", "srcSocket", "srcchannel", "instConnection", "sourceChannel", "rcSocket", "destChannel", " srcContext", "instChan", "rcChannel", "sslContext", "srcChan", "destConnection", " srcClient", "sslChannel", " srcSocket", "instChannel", "rcContext", "rcchannel", "sslSocket", "sourcechannel", " srcChan", "destChan", "sslChan", "sourceConnection", "rcChan"], "dstChannel": ["drdStream", "DdestChan", "DstChan", "dstConnection", "DestConnection", "drestchannel", " dstChan", "dspConnection", " drdChannel", "dstsChan", "dstStream", "ddestConnection", "drdchannel", "ddestChannel", "DestChannel", "dstsStream", "DstChannel", "Ddestchannel", "destChannel", "dostchannel", "DestChan", " drdchannel", "dstsConnection", "destchannel", " dstStream", "dstschannel", "ddestchannel", "DstConnection", "dstchannel", "dostChan", "drdChan", " drdChan", "DdestChannel", "Destchannel", "destConnection", "drestChannel", "ddestChan", "drdChannel", "drestChan", "Dstchannel", "dspChannel", "DdestConnection", "dspchannel", "dspChan", "dstChan", "dostChannel", "drestStream", "destChan", " dstchannel", " drdStream", "dstsChannel"]}}
{"id1": "17683082", "id2": "22338097", "code1": "    HttpRepository(Path path) throws IOException {\n        super(path);\n        this.url = new URL(path.toURLString());\n        HttpURLConnection.setFollowRedirects(true);\n        this.connection = (HttpURLConnection) url.openConnection();\n        this.ns = Names.getNamespace(path);\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 0, "substitutes": {"IOException": [" URIception", "IPError", "IOError", " URIError", " URIException", "IPException", "IPception", " IOception", " IOError", "IOception"], "url": ["address", "base", "client", "cache", "job", "feed", "URL", "path", "log", "sl", "host", "Url", "location", "conn", "bug", "image", "link", "this", "build", "ssl", "user", "config", "loc", "socket", "uri", "service", "resource", "access", "http", "page", "l", "source", "file", "server", "channel", "ref", "impl", "web", "manager"], "connection": ["position", "client", "reader", "function", "index", "location", "context", "link", "database", "Connection", "application", "directory", "handler", "config", "socket", "loader", "uri", "service", "resource", "version", "wrapper", "channel", "server", "file", "collection", "manager", "response", "relation"], "ns": ["net", "params", "ms", "NS", "scope", "str", "db", "space", "ws", "conn", "ls", "obj", "lines", "domain", "prefix", " namespace", "os", "cs", "n", "object", "ps", "ds", "fs", "cn", "pos", "nc", "names", "ss"]}}
{"id1": "4686922", "id2": "20619879", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourcesAsfile", "extractResourceInResource", "extractResourceInFile", "extractResourceToResource", "extractResourceInfile", "extractResourceToFiles", "extractResourceInFiles", "extractResourcesToFiles", "extractResourceAsResource", "extractResourcesToResource", "extractResourcesAsFile", "extractResourceAndResource", "extractResourceAsFiles", "extractResourceAsFile", "extractResourcesAsResource", "extractResourcesAsFiles", "extractResourceAndfile", "extractResourceAndFiles", "extractResourceAsfile", "extractResourcesToFile", "extractResourcesTofile", "extractResourceTofile", "extractResourceAndFile"], "resourcePath": ["servicepath", "sourceUrl", "ResourceId", " resourceId", "serviceFolder", "resourceFolder", "resourcepath", " resourcepath", "sourceId", " resourceUrl", "sourcePath", "stringpath", "servicePath", "ResourcePath", "resourceUrl", "stringPath", "sourcepath", "stringFolder", "Resourcepath", " resourceFolder", "resourceId", "ResourceUrl"], "dest": ["sac", "result", "de", "img", "prop", "sup", "project", "output", "tmp", "comb", "transfer", "path", "folder", "default", "target", "filename", "flat", "resources", "Dest", "class", "route", "desc", "const", "config", "wb", "done", "resource", "content", "store", "data", "destroy", "file", "source", "dist", " destination", "src", "contract", "die", "later", "home", "trans", "txt", " Dest", "temp"], "in": ["url", "gin", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "ini", "input", "In", "conn", "inner", "image", "c", "this", "like", "i", "r", "connection", "b", "n", "again", "sin", "rec", "socket", "nin", "win", "resource", "inn", "plus", "is", "arin", "cin", "source", "lin", "up", "file", "init", "inside", "kin", "rin", "pass", "con", "as", "f"], "out": ["net", "exec", "ins", "OUT", "client", "outs", "cache", "w", "output", "bin", "app", "io", "inc", "one", "boot", "outside", "auto", "conn", "s", "In", "ext", "obj", "image", "err", "this", "off", "Out", "ax", "lib", "norm", "all", "at", "writer", "i", "a", "user", "b", "ex", "n", "null", "again", "o", "co", "parent", "sync", "socket", "outer", "copy", "cookie", "cos", "source", "file", "up", "server", "f", "temp"]}}
{"id1": "15051083", "id2": "23118425", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"getMessageDigest": ["getMessageDesignester", "getMessageHashester", "getmessagedigest", "getmessageDigature", "getmessagedigester", "getMessagedigature", "getMessageHashature", "getmessagedigests", "getMessageDesignests", "getMessageDigests", "getMessagedigester", "getmessageDigest", "getMessageDigature", "getmessageDigests", "getmessagedigature", "getMessageDesignature", "getMessageDigester", "getMessageHashest", "getmessageDigester", "getMessageDesignest", "getMessageHashests", "getMessagedigests", "getMessagedigest"], "digest": [" digested", "hexex", " digex", " Diger", "signest", " Digester", "digeter", "greatester", " Dighed", "greatest", " digests", " Digeter", "greatiter", " Digger", "greatested", "feedester", "digex", "sandester", "Digger", "digEST", " digester", "digesting", "digester", " digEST", "signiter", "Dighed", "digests", "Digests", "Digex", "dighed", "Digesting", "feedest", "signesting", "digested", "feedested", "hexest", "DigEST", "Diger", "Digester", "hexests", "sandesting", "signester", "diger", " digeter", "sandest", "Digest", " diger", " dighed", "digger", "Digested", "Digiter", "sandested", " digger", "digiter", "hexEST", "signested", "Digeter", " Digest"], "node": ["address", "local", "child", "one", "internal", "path", "remote", "index", "odes", "location", "name", " namespace", "self", "entity", "event", "element", "global", "connection", "component", "root", "route", "n", "object", "parent", "Node", "config", " annotation", "uri", "resource", " Node", " nodes", " source", " child", "document", "point", " parent", "source", "server", "instance", "network", "ode", "module"], "external": ["https", "ternal", "client", "account", "local", "e", "multiple", " External", "internal", "environment", "outside", "remote", "export", "target", "External", "name", "Intern", "out", "binary", "secondary", "element", "global", "reference", "ex", "object", "n", "tern", " global", " remote", "outer", " foreign", "resource", "intern", "foreign", "source", "international", "instance", "network"], "messageDigest": [" messageDigger", "messageHashester", "messagedigest", "messageDenge", "messageDest", "messageHashest", " messageHashested", " messageDigester", "messageDester", "messagedigester", "messageDesignested", "messageSignested", "messageDigesting", " messageDesignest", "messageHashested", "messageDesignester", "messageSignester", "MessageSignenge", "messageSignenge", "messagedigger", "MessageDigest", "MessageSignest", "messageDigested", " messageDesignger", " messageDigested", "messageDigenge", "messageDesignest", "messageDesignger", " messageDesignested", "messageModested", "messageModester", "messageHashesting", " messageHashester", " messageDesignester", "MessageSignester", "messageMarkester", "MessageDigenge", " messageHashest", "messageModesting", "messageDested", "messageModest", "messageMarkested", "messageDesignesting", " messageDigesting", "messageMarkest", "MessageDigester", "MessageSignested", "MessageDigested", "messageSignest", "messagedigested", "messageDigger", "messageMarkenge", "messageDigester", " messageHashesting"]}}
{"id1": "20091126", "id2": "6403868", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"copy": ["exec", "call", "output", "transfer", "zip", "io", "Copy", "proxy", "put", "cp", "archive", "write", "upload", "Cop", "type", "cop", "join", "over", "p", "source", "process", "up", "file", "download", "cat", "open", "paste", "cmp"], "in": ["url", "base", "ins", "reader", "IN", "login", "bin", "id", "inc", "old", "index", "input", "ic", "In", "name", "inner", "image", "m", "or", "a", "i", "connection", "b", "again", "config", "query", "diff", "buffer", "min", "l", "data", "work", "file", "source", "lin", "ac", "part", "f"], "out": ["exec", "external", "v", "url", "result", "base", "OUT", "outs", "cache", "call", "output", "exp", "io", "x", "default", "target", "dot", "ext", "string", "name", "image", "write", "prefix", "off", "err", "c", "Out", "plain", "a", "i", "ex", "again", "parent", "object", "o", "buffer", "array", "p", "content", "point", "page", "data", "source", "file", "server", "channel", "value", "comment", "temp"], "inChannel": ["inClient", " inButton", "inputChan", " inchannel", "insChannel", "inChan", " inClient", "iniStream", "inputGate", "outChan", "winStream", "INClient", "inchannel", "outchannel", "outStream", "iniChan", "outButton", "inputStream", "inputchannel", "winchannel", " inStream", "INChan", "inGate", "INchannel", "winChannel", "inStream", "INChannel", " inChan", "INGate", "winChan", "iniChannel", "INStream", "insStream", "iniGate", "insClient", "inputButton", "inButton", "inputChannel", "INButton", "insChan"], "outChannel": ["inClient", "outClient", "outsChan", "outputStream", "Outchannel", "outputChan", "outContext", " outConnection", "outsChannel", "inChan", " outChan", "OutStream", "outputClient", "outputchannel", " outContext", "outChan", "inchannel", "outchannel", "outputChannel", "outStream", "OutClient", "outConnection", "outsConnection", "inStream", "outsStream", " outStream", "OutContext", "inConnection", " outchannel", "OutChan", "OutChannel", "inContext"]}}
{"id1": "7761195", "id2": "12744653", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["encipher", "ecryption", "Encrypt", "encress", "ecress", "Encipher", "Encress", " encryption", "Encryption", "ecipher", " encress", "encryption", " encipher", "ecrypt"], "plaintext": ["plainsource", "batletter", " plainText", " plainstruct", " plainsource", " plainletter", "plainletter", "pretext", "protectedText", "foreText", "plainText", "foreletter", "plainstruct", "prestruct", "batsource", "foretext", "battext", "predata", "foresource", "protecteddata", "plaindata", "batText", " plaindata", "protectedtext", "protectedstruct", "preText"], "sb": ["sv", "bb", "gb", "bp", " SB", "nb", "sam", "db", "bm", "BG", "gc", "mb", "si", "sg", "sq", "SB", "BB", "bg", "kB", "abb", "rb", "pb", "bh", "bf", "ss", "erb", "sf", "cb", "bs"], "md": ["mad", "MD", "cm", "de", "mc", "sha", "ms", "metadata", "rm", "pm", "bd", "amd", "cb", "df", "mo", "meta", "mb", "mt", "cmd", "M", "hd", "sm", "mand", "m", "dd", "gd", "Cmd", "od", "mg", "mm", "ma", "ad", "dc", "cd", "pd", "wd", "mac", "mp", "hm", "mod", "dr", "dh", "ld", "d", "mag", "nm", "vd", "dm", "mu", " MD", "dig"], "raw": ["dec", "unsigned", "clean", "ng", "output", "RAW", "feed", "load", "valid", "row", "input", "stream", "original", "image", "missing", "hex", "serial", "words", "Raw", "null", "text", "buf", "empty", "unknown", "enc", "block", "buffer", "array", "message", "pack", "bytes", "wave", "rc", "data", "shared", "instance", "full", "initial", "json", "ack", "response"], "hash": ["url", "base", "sha", "header", "ash", "cache", "rh", "flash", "id", "Hash", "log", "alt", "kh", "image", "hex", "ashes", "code", "html", "text", "block", "her", "message", "array", "version", "buffer", "pack", "key", "mac", "h", "abi", "sh", "data", "secret", "ref", "num", "sum", "ha", "dig"]}}
{"id1": "14783950", "id2": "9096314", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"compressWithZip": ["compressWithJar", "compressedWithJar", "compresswithSax", "compressedUsingJar", "compressInSax", "compressUsingJar", "compressedUsingSax", "compresswithJar", "compressInZip", "compressedUsingZip", "compressUsingZip", "compresswithZip", "compressUsingSax", "compressedWithZip", "compressedWithSax", "compressWithSax", "compressInJar"], "fileList": ["FileChain", "ziplist", "wordString", "fileStream", "modelList", " fileChain", "Filelist", "stringList", "modelStream", "stringChain", "zipSet", "modelEx", "FileName", "FileSet", "stringName", " fileCollection", "inputEx", "inputStream", " fileSet", "modelCollection", "fileChain", "fileEx", "inputList", " fileStream", "stringlist", "FileString", " fileString", "zipList", "fileCollection", "wordName", "fileString", " fileEx", "FileStream", "zipName", "inputCollection", " filelist", "FileList", "wordList", "fileSet", "wordStream", "filelist"], "zipFileName": ["archiveFileDir", "zipFileNames", "folderGlobalPath", "zipFullNames", "zipFilePath", "archiveDirName", "folderGlobalName", "zipPackageDir", "archiveFilePath", "zipFullname", "zipGlobalPath", "zipDirName", "folderGlobalname", "zipGlobalNames", "zipPackageName", "zipGlobalname", "folderFilePath", "zipFullPath", "folderFileName", "zipDirNames", "archiveDirPath", "archiveFileName", "zipFilename", "archiveDirDir", "zipFullName", "folderGlobalNames", "zipGlobalName", "zipPackagePath", "zipFullDir", "folderFileNames", "folderFilename", "zipFileDir", "zipDirDir", "zipDirname", "zipDirPath"], "fos": ["afaos", " fosh", "flis", "afos", "infis", "Fosh", "Fos", "foS", "Fis", "flosh", "afis", "fosh", "infaos", "afoS", "infoS", "infos", "FoS", "flos", "faos", "Faos"], "zos": ["z", "osi", "outs", "zzy", "onz", "ZA", "zar", "kos", "zip", "seconds", "bis", "zers", "spin", "chini", "es", "zon", "budget", "tz", "uz", "jobs", "zen", "zes", "os", "ses", "bag", "zl", "phi", "webkit", "bos", "zan", "dos", "zer", "iframe", "zo", "ozo", "zi", "LOS", "fits", "lins", "oses", "css", "zx", "nz", "zz", "fi", "zag", "rez", "abi", "cos", "inos", "jas", "zb", "ZI", "gz", "loop", "packs", "bes", "zik", "closure", "obb", "ros", "lol", "zy"], "iter": ["ser", "oper", "test", "ip", "chain", "ter", "upper", "itter", "enter", "parse", "finder", "el", "e", "ator", "inc", "sort", "cher", "index", "er", "former", "keep", "iz", "ir", "end", "inner", "liter", "set", "err", "next", "order", "iner", "Iterator", "ie", "i", "ite", "fer", "loc", "list", "walker", "gener", "ner", "inse", "outer", "slice", "fr", "it", "iterator", "is", "http", "file", "izer", "Iter", "coll", "inter", "f", "ener"], "fileName": ["FileType", " filePart", "FileLine", "fPart", "currentname", "localname", "localPart", "FileUrl", " filePath", "currentData", "localPath", "pageName", "filenameInfo", " fileUrl", "filename", "FileName", "currentUrl", "currentName", "fileOpen", "pagename", "fileLine", "filenamename", " fileFull", "fileData", " fileOpen", "simpleOpen", "filenameName", "fName", " fileData", " fileInfo", "fullPath", "fullOpen", "FileString", "filePart", "fileType", " fileString", "FilePath", "filenameFull", "FilePart", "fileInfo", "fLine", "fileFull", "fullName", "fileString", " filename", "FileFull", " fileLine", " fileType", "fname", "simplePath", "simpleName", "filePath", "FileInfo", "localName", "pageString", "FileData", "fileUrl", "pageType", "Filename"], "ind": ["bind", "mind", "z", "id", "inc", "Ind", "x", "index", "div", "val", "pt", "start", "length", "ded", "pend", "end", "rib", "ci", "len", "ii", "j", "i", "count", "eff", "pull", "loc", "ord", "cond", "fr", "ad", "inn", "wind", "ix", "nd", "in", "vert", "ld", "dir", "mid", "pos", "IND", "d"], "shortName": ["ShortPath", "smallName", "longName", "ShortPart", "fullLine", "smallname", "shortPart", "longPart", "smallPart", "longname", "smallPath", "shortname", "fullString", "fullname", "longPath", " shortString", "fullPath", " shortname", " shortLine", "ShortString", "fullName", "shortString", "Shortname", "shortPath", " shortPath", "longLine", "shortLine", "ShortName"], "fis": [" fiss", "fris", "cfis", "gisa", "afos", "Fos", " fisa", "Fis", "fios", "afis", "cfiss", "pis", "Fiss", "gios", "pris", "Fs", " fios", "fs", "gris", "fiss", " fs", "afiss", "cfos", "gis", "afris", "cfris", "cfs", "pisa", " fris", "pios", "fisa"], "buf": ["vec", "uf", "bc", "v", "uc", "bb", "bin", "tmp", "br", "bd", "cv", "bp", "cur", "fb", "ba", "seq", "queue", "bl", "bag", "box", "batch", "Buff", "lb", "b", "grab", "ff", "loc", "wb", "buffer", "done", "la", "bytes", "rb", "fd", "feat", "rc", "data", "pb", "bh", "bf", "lim", "cb", "buff", "bu"], "bytesRead": [" bytesSkip", "flowsLength", "bitsSkip", "secondsRead", "tesSkip", "secondsNeed", "secondsWrite", "wordsRead", "bitsRead", "secondsLength", "flowsRead", "flowsNeed", "tesWrite", "wordsWrite", "bytesSkip", " bytesUse", " bytesWrite", "bytesWrite", "bytesLength", " bytesLength", "flowsWrite", "bitsLoad", "bitsWrite", "tesLoad", "wordsUse", " bytesNeed", "bytesUse", "tesRead", " bytesLoad", "wordsLength", "bytesNeed", "bitsUse", "bytesLoad", "bitsLength"]}}
{"id1": "3558512", "id2": "6988216", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "label": 1, "substitutes": {"serialize": ["Serialze", "finalze", "Serialize", " serialze", "erialize", "Serialized", "erialze", "Serialization", "Serialify", "serialze", " serialization", "serializable", "erialization", "normalify", "normalized", "finalize", "normalze", "serialify", "finalized", "finalify", "erializable", "Serializable", "serialized", "serialization", "normalize", " serializable"], "out": ["exec", "OUT", "png", "outs", "cache", "client", "w", "gen", "output", "bin", "io", "raw", "filename", "name", "string", "obj", "conn", "archive", "image", "err", "Out", "writer", "i", "report", "a", "ex", "parent", "o", "loader", "buffer", "content", "copy", "page", "data", "pool", "file", "up", "source", "server", "dump", "temp"], "parser": ["test", "processor", "base", "master", "reader", "system", "cache", "builder", "parse", "php", "lp", "tt", "worker", "xml", "plugin", "arser", "er", "seed", "cp", "pkg", "upload", "writer", "pe", "Parser", "class", "parent", "handler", "pillar", "per", "loader", "p", "wrapper", "copy", "file", "up", "server", "instance", "rar", "pp", "ss", "as", "txt", "manager"], "on_disk": ["onJdemand", "onnetfile", "onnetspace", "off_space", "off_delete", "onbootlock", "on_lock", "onbookdelete", "off_lock", "on_file", "off_drive", "onjspace", "off_storage", "onbootdrive", "onJdrive", "onbootdisk", "on_drive", "onJlock", "onjdrive", "onJdisk", "onbootstorage", "off_demand", "onbookdrive", "off_disk", "onjfile", "onbookdisk", "on_storage", "onnetdemand", "onjdisk", "on_demand", "onnetdisk", "on_delete", "onnetdrive", "on_space", "off_file"], "in": ["ins", "thin", "din", "reader", "IN", "login", "bin", "inc", "ini", "input", "In", "conn", "inner", "stream", "c", "inas", "ax", "i", "connection", "info", "r", "again", "o", "socket", "win", "inn", "min", "pin", "copy", "data", "lin", "file", "source", "kin", "rin", "pass", "con", "ac", "as", "f"]}}
{"id1": "21182766", "id2": "3024992", "code1": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 0, "substitutes": {"load": ["Load", "loading", "save", "call", "parse", "delete", "use", "proc", "check", "path", "include", "start", "set", "resources", "setup", "write", "build", "loads", "read", "construct", "info", "LOAD", "class", "find", "config", "install", "loader", "update", "pack", "resource", "loaded", "add", "get", "copy", "store", "process", "init", "download", "create", "dump"], "propsName": ["pepsName", "pepsname", "propsDesc", "comppertiesname", "pepsNames", "profsName", "profsPath", "profsname", "pepertiesNames", "propertiesPath", "proPSDesc", "comppsDesc", "pepertiesName", "comppertiesPath", "pepertiesPath", "propsNames", "comppertiesName", "proPSname", "pepsPath", "propertiesName", "comppsPath", "comppsName", "propertiesname", "comppertiesDesc", "propsPath", "proPSNames", "pepertiesname", "proPSName", "propertiesNames", "profsDesc", "profsNames", "comppsname", "propertiesDesc", "propsname", "proPSPath"], "props": ["probs", "compps", "protpr", "perps", "precs", "pets", "pebs", "peps", "pripos", "pecs", "protperties", "pribs", "prebs", "propps", "crops", "compds", "Procs", "Props", "prpr", "properties", "cropr", "prpps", "prots", "cropps", "Probs", "prids", "procs", "propos", "comppos", "compbs", "prperties", "preps", "prips", "perpos", "croperties", "protps", "prets", "propr", "perds", "Prots", "protpps", "prods", "perbs", "prps"], "url": ["cl", "base", "ob", "e", "id", "feed", "URL", "jar", "not", "path", "xml", "sl", "fl", "Url", "location", "name", "gl", "stream", "event", "ssl", "i", "r", "user", "b", "browser", "config", "loader", "buffer", "uri", "service", "resource", "api", "bel", "http", "l", "page", "source", "file", "server", "data", "channel", "ref", "src", "f"]}}
{"id1": "5551393", "id2": "1862616", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public static String fetch(String reference) throws IOException {\n        URL url = new URL(reference);\n        HttpURLConnection c = (HttpURLConnection) url.openConnection();\n        c.setRequestMethod(\"GET\");\n        c.setDoOutput(true);\n        c.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n        return parseISToString(c.getInputStream());\n    }\n", "label": 0, "substitutes": {"getMD5": ["getSHA4", " getM512", " getM4", "getMD4", "getSHA256", "getmd5", "getSHA5", "getM256", "getSHA512", "getM5", "getM4", "getmd512", " getMD512", "getmd4", "getMD256", "getM512", " getMD4", " getMD256", "getMD512", " getM5", " getM256", "getmd256"], "source": ["ource", "template", "address", "url", "result", "base", "output", "security", "proxy", "SOURCE", "input", "target", "start", "string", "seed", "name", "length", "secure", "Source", "sm", "code", "info", "text", "object", "dest", "config", "slice", "message", "buffer", "service", "resource", "bytes", "content", "data", "file", "style", "src", "unit", "size", "expected", "temp"], "tmp": ["foo", "emp", "test", "result", "stuff", "fp", "params", "cache", "output", "metadata", "zip", "current", "tt", "vt", "default", "py", "meta", "obj", "binary", "storage", "code", "sb", "html", "b", "buf", "body", "ignore", "dest", "buffer", "var", "array", "rb", "copy", "data", "vm", "src", "nm", "Temp", "bf", "part", "cpp", "txt", "cb", "mp", "cmp", "temp"], "md": ["mad", "MD", "cm", "mc", "ms", "rm", "pm", "bd", "zip", "amd", "mo", "meta", "mb", "mt", "ind", "oda", "cmd", "hd", "mi", "rpm", "mand", "editor", "m", "dd", "gd", "sd", "od", "mg", "mm", "ma", "ad", "pd", "cd", "mmm", "wd", "nd", "mac", "mn", "mod", "di", "ld", "d", "mag", "nm", "vd", "dm", "bf", "mu", " MD", "mp"]}}
{"id1": "20091126", "id2": "5237257", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["exec", "call", "output", "transfer", "zip", "io", "Copy", "proxy", "put", "cp", "archive", "write", "upload", "Cop", "type", "cop", "join", "over", "p", "source", "process", "up", "file", "download", "cat", "open", "paste", "cmp"], "in": ["url", "base", "ins", "reader", "IN", "login", "bin", "id", "inc", "old", "index", "input", "ic", "In", "name", "inner", "image", "m", "or", "a", "i", "connection", "b", "again", "config", "query", "diff", "buffer", "min", "l", "data", "work", "file", "source", "lin", "ac", "part", "f"], "out": ["exec", "external", "v", "url", "result", "base", "OUT", "outs", "cache", "call", "output", "exp", "io", "x", "default", "target", "dot", "ext", "string", "name", "image", "write", "prefix", "off", "err", "c", "Out", "plain", "a", "i", "ex", "again", "parent", "object", "o", "buffer", "array", "p", "content", "point", "page", "data", "source", "file", "server", "channel", "value", "comment", "temp"], "inChannel": ["inClient", " inButton", "inputChan", " inchannel", "insChannel", "inChan", " inClient", "iniStream", "inputGate", "outChan", "winStream", "INClient", "inchannel", "outchannel", "outStream", "iniChan", "outButton", "inputStream", "inputchannel", "winchannel", " inStream", "INChan", "inGate", "INchannel", "winChannel", "inStream", "INChannel", " inChan", "INGate", "winChan", "iniChannel", "INStream", "insStream", "iniGate", "insClient", "inputButton", "inButton", "inputChannel", "INButton", "insChan"], "outChannel": ["inClient", "outClient", "outsChan", "outputStream", "Outchannel", "outputChan", "outContext", " outConnection", "outsChannel", "inChan", " outChan", "OutStream", "outputClient", "outputchannel", " outContext", "outChan", "inchannel", "outchannel", "outputChannel", "outStream", "OutClient", "outConnection", "outsConnection", "inStream", "outsStream", " outStream", "OutContext", "inConnection", " outchannel", "OutChan", "OutChannel", "inContext"]}}
{"id1": "15797402", "id2": "11933797", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"parse": ["wrap", "save", "apply", "handle", " serve", "php", "view", "load", "cover", "raw", "replace", "worker", "request", "xml", "patch", " convert", " analyse", " parsing", "set", " rewrite", " process", "rate", "read", "fork", "print", "report", "Parser", "transform", "scan", "arse", "pack", "parser", "service", " parser", "http", "process", "se", "processing", "pc", " split", "split", " transform", " dispatch"], "stream": ["url", "reader", "client", "sample", "handle", "view", "feed", "load", "raw", "remote", "input", "inner", "image", "upload", "down", "Stream", "read", "writer", "video", "through", "loader", "message", "resource", "content", "stack", "document", "iterator", "form", "http", "in", "source", "channel", "server", "data", "file", "download", "src", "draw", "response", "temp"], "handler": ["monitor", "processor", "base", "reader", "client", "handle", "controller", "default", "function", "manager", "host", "pointer", "driver", "layer", "format", "event", "handled", "writer", "info", "connection", "application", "Handler", "parent", "hand", "loader", "parser", "service", "wrapper", "phase", "h", "di", "data", "channel", "server", "collection", "ctx", "response"], "metadata": ["map", "template", "md", "monitor", "processor", "header", "params", "met", "runtime", "xml", "metry", "manager", "plugin", "meta", "mt", "state", "material", "database", "mi", "storage", "mon", "m", "properties", "management", "component", "info", "connection", "directory", "config", "parser", "message", "uri", "attribute", "property", "resource", "adata", "managed", "document", "content", "di", "data", "source", "subject", "mx", "json", "collection", "ctx", "module"], "context": [" Context", "processor", "mc", "reader", "system", "scope", " contexts", "proxy", "command", "tx", "request", "xml", "manager", "environment", "event", "component", "element", "connection", "method", "object", "kernel", "text", "parent", "config", "concept", "message", "resource", "Context", "document", "content", "translation", "data", "entry", "subject", "instance", "collection", "txt", "ctx", "cmp"], "name": ["address", "url", "base", "alias", "job", "call", "comment", "ame", "id", "child", "none", "model", "old", "path", "Name", "default", "label", "filename", "string", "on", "time", "named", "action", "word", "size", "no", "prefix", "image", "missing", "large", "code", "m", "type", "connection", "active", "class", "route", "null", "n", "object", "sync", "message", "resource", "common", "api", "version", "key", "search", "in", "source", "data", "work", "file", "full", "names", "part", "NAME"], "out": ["url", "result", "OUT", "client", "outs", "builder", "output", "bin", "window", "exp", "io", "child", "path", "obj", "conn", "ext", "image", "err", "Out", "plain", "lib", "ray", "extra", "writer", "connection", "user", "null", "object", "again", "ex", "o", "socket", "sync", "resource", "flush", "copy", "in", "line", "data", "source", "file", "server", "page", "pool", "channel", "cos", "instance", "manager", "temp"]}}
{"id1": "18374478", "id2": "5836744", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"updateUser": ["updateRole", "addWord", " updateMember", "deleteuser", " updateRole", " updateuser", "editUser", "editUsers", "deleteMember", "updatedUser", "updatedWord", "updateduser", "UpdatePassword", "updatePassword", "createUser", "updateWord", "UpdateMember", "editRole", "updateuser", " updateAccount", " updateWord", "UpdateRole", "deletePassword", "createRole", "adduser", "updateAccount", "UpdateUsers", "editAccount", "deleteRole", "updateMember", "addUsers", "deleteWord", "UpdateUser", "updatedUsers", "updateUsers", " updatePassword", "addUser", "Updateuser", "UpdateWord", "createAccount", "deleteUser", "createUsers", " updateUsers", "deleteUsers"], "user": ["result", "ver", "client", "account", "job", "system", "project", "str", "view", "site", "use", "app", "current", "model", "log", "User", "row", "users", "session", "plugin", "name", "creator", "profile", "string", "contact", "bug", "this", "character", "self", "auth", "username", "you", "custom", "connection", "used", "null", "object", "parent", "rule", "config", "author", "per", "update", "message", "post", "resource", "person", "p", "version", "content", "page", "me", "data", "pool", "match", "ro", "USER", "server", "member", "instance", "full", "group", "record", "manager", "response", "module"], "conn": ["exec", "cm", "url", "mc", "client", "ca", "ann", "cache", "util", "uc", "ob", "el", "ou", "reg", "cb", "db", "log", "pt", "connect", "sql", "host", "core", "cr", "cp", "oss", "sth", "lock", "c", "cc", "ci", "org", "ct", "ec", "connection", "Connection", "n", "config", "enc", "loc", "nt", "co", "pub", "sync", "cond", "socket", "dc", "api", "close", "pg", "h", "rc", "col", "cli", "pool", "cn", "ch", "act", "server", "coll", "pc", "con", "nc", "ac", "cat", "Conn", "serv", "part", "conf", "ctx", "ha", "pr"], "autoCommit": ["automaticCommend", "autoCitting", "autoDebite", " autoCommite", "autoCited", "automaticDebIT", "autoRebits", "autoCommits", "autoCommited", "autoDebit", "autoDebmit", " autoComits", " autoCommited", "automaticDebend", "autoCommIT", "autoBlend", "autoComit", "autoComits", " autoDebit", "autoDebitting", "automaticDebmit", "autoBlmit", " autoCommits", " autoDebmit", "autoCmit", "autoRebit", " autoDebited", " autoDebitting", "autoComIT", "automaticCommIT", "automaticDebit", "autoAbitting", "autoBlit", "autoRebite", "autoCommend", "autoCit", " autoCommmit", "autoComite", "autoDebited", "autoAbmit", "autoDebend", "autoCommitting", "autoAbit", "autoAbited", "autoDebits", "automaticCommit", "automaticCommmit", " autoComite", "autoBlIT", "autoCommmit", "autoCommite", "autoDebIT", "autoComend", " autoCommitting", " autoComit"], "deleteRoles": ["deleteRsoles", "destroyRols", "deleteSlole", "deleteLoles", "deleteDoots", "destroyNoots", "deleteGrils", "insertRoases", "deleteLodes", "destroyNols", "deleteDules", "deleteDils", "delLoles", "delLole", "deleteRules", "deleteDases", "deleteRooles", "deleteDole", "deleteNoots", "deleteCases", "deleteSlases", "insertRooles", "deleteDols", "destroyRoots", "insertRoules", "insertRole", "delRoles", "deleteGroles", "deleteRils", "deleteRodes", "deleteRsules", "delLases", "destroyNils", "destroyRils", "insertRases", "deleteRoole", "deleteRoules", "delRole", "deleteRoots", "delRodes", "deleteRsases", "delRases", "deleteLole", "deleteNils", "deleteGrols", "destroyNoles", "deleteRsole", "deleteRole", "deleteRases", "deleteSloles", "deleteNols", "deleteRoases", "deleteRols", "insertRoole", "deleteCodes", "destroyRoles", "deleteCole", "deleteSlodes", "deleteDoles", "deleteGroots", "insertRules", "deleteNoles", "deleteLases", "delLodes", "deleteColes"], "insertRoles": ["updateLols", "insertLoots", "copyRules", "insertGoots", "updateRoles", "insertRsles", "insertRows", "insertLles", "insertLules", "copyRoles", "insertRsules", "insertRodes", " insertShole", "updateLoles", "insertSules", "copyGows", "copyGules", "insertRsoles", "updateRules", " insertRules", " insertSholes", " insertRodes", "insertSodes", "deleteRanges", "insertSloots", "copyRows", " insertRole", "insertRsanges", "insertRsodes", "insertLoles", "insertRoots", "copyGoots", "insertRols", "updateRols", "insertSlanges", "insertSole", "copyGoles", "insertSoles", " insertShules", "copyRoots", "insertRles", "updateLules", "insertSholes", "insertRanges", "insertLols", "insertShole", "insertRules", "insertGules", "insertShules", "insertLows", "deleteSlanges", "deleteSloots", "insertRsoots", "updateRles", "insertRsows", " insertShodes", "insertRole", "deleteRodes", "insertSloles", "insertGoles", "insertSlodes", "deleteRoots", "updateLles", "deleteSloles", "insertRsols", "deleteSlodes", "insertGows", "insertShodes"], "role": ["shadow", "slave", "de", "base", "error", "alias", "force", "Role", "relation", "one", "rol", "function", "row", "val", "label", "string", "profile", "range", "to", "link", "or", "username", "zone", "type", "repl", "route", "tag", "rule", "guard", "service", "resource", "key", "l", "entry", "roller", "ro", "member", "ole", "group", "rl", "tool", "le", "module"]}}
{"id1": "21092340", "id2": "9109613", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addToAsive", "addToSlIVE", "addtoAsives", "addToArchively", "addToAsively", "addToAsives", "addtoArchive", "addToAdaptively", "addToSlive", "addToAsIVE", "addToAdaptives", "addtoAsIVE", "addToArchIVE", "addToArchives", "addToAdaptive", "addtoArchIVE", "addToAdaptIVE", "addtoArchively", "addToSlively", "addToSlives", "addtoAsive", "addtoArchives", "addtoAsively"], "pod": ["ods", "cache", "project", "bean", "tmp", "module", "zip", "child", "po", "proc", "pot", "plugin", "node", "host", "pkg", "pl", "component", "cer", "pid", "pe", "ce", "object", "od", "per", "pad", "loader", "post", "table", "ad", "p", "peer", "pc", "part", "product", "plug", "pi", "Pod"], "podArchiveOutputStream": ["podArchIVEInputFile", "podArchivesFileResource", "podArchiveByteSteam", "podArchivingOutputStream", "podArchiveInputSteam", "podArchivingOutputFile", "podArchIVEOutputStream", "podArchiveByteFile", "podArchiveInputStream", "podArchivingWriteStream", "podArchivesOutputFile", "podArchiveOutputSteam", "podArchiveWriteFile", "podArchiveOutputResource", "podArchiveFileResource", "podArchIVEInputSteam", "podArchiveIOResource", "podArchIVEOutputSteam", "podArchiveOutputDirectory", "podArchivesOutputSteam", "podArchiveByteDirectory", "podArchIVEOutputFile", "podArchivesFileStream", "podArchivesFileSteam", "podArchivesFileFile", "podArchivesOutputStream", "podArchivingOutputPath", "podArchiveFilePath", "podArchiveWriteStream", "podArchiveIOSteam", "podArchiveInputPath", "podArchiveFileFile", "podArchiveIODirectory", "podArchivingWriteSteam", "podArchiveIOFile", "podArchIVEOutputDirectory", "podArchiveOperationSteam", "podArchIVEInputDirectory", "podArchiveFileSteam", "podArchiveWritePath", "podArchiveInputDirectory", "podArchiveFileStream", "podArchiveOperationResource", "podArchivingWriteFile", "podArchiveWriteSteam", "podArchIVEInputStream", "podArchivingWritePath", "podArchiveOperationStream", "podArchiveInputFile", "podArchiveIOStream", "podArchivesOutputResource", "podArchiveByteStream", "podArchiveOperationFile", "podArchiveFileDirectory", "podArchiveOutputPath", "podArchiveOutputFile", "podArchivingOutputSteam"], "filename": ["fp", "url", "FILE", "alias", "title", "dll", "fil", "which", "kl", "platform", "ename", "path", "folder", "nil", "label", "location", "string", "sequence", "name", "binary", "archive", "word", "named", "prefix", "database", "files", "username", "SourceFile", "route", "ppa", "directory", "application", "loader", "uri", "property", "kn", "l", "fn", "file", "subject", "download", "sf", "Filename", "f", "il", "module"], "source": ["ource", "slave", "url", "result", "reader", "output", "use", "zip", "proxy", "path", "sl", "input", "target", "string", "seed", "stream", "archive", "driver", "image", "Source", "connection", "text", "parent", "config", "slice", "loader", "uri", "service", "resource", "copy", "document", "stack", "file", "src", "unit", "SOURCE"], "entry": ["address", "result", "reader", "e", "zip", "feed", "child", "path", "row", "ge", "index", "pointer", "auto", "string", "obj", "stream", "archive", "image", "this", "or", "event", "element", "ie", "connection", "r", "object", "parent", "Entry", "post", "resource", "add", "it", "iterator", "line", "file", "data", "se", "article", "letter", "record"]}}
{"id1": "11616716", "id2": "12783713", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResultInReader", "getCMSResponseasSteam", "getCMSResultWithSteam", "getCMSResultInStream", "getCMSResponseAsStream", "getCMSResultasFile", "getCMSResponseasReader", "getCMSResultWithFile", "getCMSResultWithReader", "getCMSResultAsFile", "getCMSResponseAsSteam", "getCMSResponseasFile", "getCMSResultasStream", "getCMSResultAsReader", "getCMSResultasSteam", "getCMSResultasReader", "getCMSResponseAsFile", "getCMSResultWithStream", "getCMSResponseasStream", "getCMSResultInFile", "getCMSResultAsSteam", "getCMSResultInSteam", "getCMSResponseAsReader"], "rqlQuery": ["srqlquery", "rQLquery", " rqlquery", "rsqlMethod", "srqlQu", "rsqlquery", "srQLQuery", "rsqlQuery", "rQLQu", "rSQLQuery", " rsqlQu", "rqlquery", "rSQLMethod", "rqlQ", " rsqlMethod", "rQLQuery", "srqlQuery", "rsqlQ", "riliQuery", "riliquery", "riliQu", "srqlQ", " rqlQu", "srQLQu", "srQLquery", "srQLQ", "rSQLquery", "rQLMethod", "riliQ", "rsqlQu", "rQLQ", "rqlMethod", " rqlMethod", "rSQLQu", " rsqlQuery", " rsqlquery", "rqlQu"], "osr": ["otsrm", "ossrr", "boswer", "ysrar", "OSrt", "osrm", "opsr", "osR", "ospr", "opswer", "iospr", "losfr", "ossrs", "osssr", "ysrt", "otspr", "losrr", "ossrw", "osrw", " ospr", "cosrr", "usrs", "oscr", " oscr", "iosrw", "osrr", " osfr", "obsrar", "osrar", "osrt", "iosrs", " osrr", "losrt", "bosrar", "cosfr", "ossrar", "userr", "OSrr", "obsr", "ossrt", " osrm", "osfr", "usrw", "OSr", "iosr", "OSerr", "obswer", "osrs", "cosr", "ysr", "bosR", "ossrm", "obsR", " osrar", "oserr", "otssr", "uspr", "osscr", "usr", "ossr", "osspr", "bosr", " osrt", "opsR", "otsr", "opsrar", " ossr", "losr", "cosrt", "oswer", "osserr", "usrt", "yscr", "usrr"], "url": ["lc", "base", "client", "ob", "URL", "path", "nl", "sl", "fl", "Url", "host", "fb", "string", "ls", "org", "ssl", "connection", "r", "b", "ll", "www", "config", "socket", "uri", "resource", "http", "l", "page", "source", "file", "server", "channel", "open", "web", "rl", "blog", "f"], "conn": ["exec", "net", "lc", "rn", "client", "ca", "ann", "reg", "cb", "cur", "db", "connect", "oss", "conv", "cp", "cr", "c", "ci", "err", "rt", "org", "ec", "ssl", "ct", "connection", "en", "Connection", "n", "attr", "enc", "loc", "sync", "nt", "dc", "p", "wrapper", "h", "http", "rc", "l", "col", "fn", "server", "ch", "cn", "act", "coll", "pc", "con", "nc", "Conn", "open", "ctx", "f", "pr"]}}
{"id1": "18891988", "id2": "12055086", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["GetString", "GetFilename", "downloadFile", "loadFile", "loadfile", "downloadfile", "getfile", "getFilename", "Getfile", "getString", "loadString", "downloadFilename", "GetFile", "downloadString", "loadFilename"], "serviceName": ["ServiceName", "projectType", " servicePath", "ServicePath", "Servicename", " serviceType", " servicename", "packagename", "servicePath", "ServiceType", "projectUrl", " serviceUrl", "servicename", "projectPath", "ServiceUrl", "packagePath", "serviceType", "packageName", "serviceUrl", "packageUrl", "projectName"], "wsdlLocation": ["wllFolder", "wssdFolder", "awsdlLocation", "wddlLocation", "awslDirectory", "wsllFolder", "wssdAddress", "wsDLUrl", "wslLocation", "wslpDirectory", "wslUrl", "wsllAddress", "wdlAddress", "wslFile", "awslFile", "wsslFolder", "wdlFile", "wddlFile", "wdlFolder", "wllFile", "wslpLocation", "awsdlDirectory", "awslUrl", "wslDirectory", "awsdlFile", "wslFolder", "wsdlDirectory", "wddlFolder", "wsllLocation", "wsDLFile", "wsslLocation", "wsdlFolder", "wsDLLocation", "awsdlUrl", "wsllUrl", "wsslFile", "wllLocation", "wssdLocation", "wddlDirectory", "wsdlFile", "wsdlUrl", "wsslAddress", "wsdlAddress", "wsllFile", "wdlDirectory", "wslpFolder", "wdlLocation", "wssdFile", "wslpFile", "wllAddress", "awslLocation", "wsDLDirectory", "wsllDirectory"], "endpoint": ["endPoint", "endination", "enPoint", " endaddress", "Endword", "endpointer", " endocol", " endPoint", " endpo", "EndPoint", "Endination", "Endpoint", "ENDpoint", "enpointer", "endsword", "startaddress", "endpo", "startpointer", "Endpoints", "startPoint", " endword", "ENDpoints", "endword", "enaddress", "enination", "endsocol", "startpoint", "enpoint", "ENDPoint", " endpointer", "endspo", "endaddress", "Endocol", "endspoint", "endocol", "enpoints", "endpoints", "ENDination", "Endpo"], "fileLocation": ["FILEUrl", " fileURI", "FileURI", " fileUrl", "fileURI", " fileDirectory", "FILEDirectory", "fileUrl", "fileDirectory", "FileDirectory", "FILELocation", "FileLocation", "FileUrl", "FILEURI"], "tempDir": [" temporaryPath", "TempDirectory", " tempVer", "tmpDir", " tempDirectory", "tmpPath", "TempPath", " tempdir", " tempPath", "TempDir", "tmpDirectory", "tempdir", "Tempdir", "tempDirectory", "tmpVer", " temporaryVer", " temporaryDir", "tempVer", "tempPath", "tmpdir", " temporaryDirectory"], "url": ["address", "base", "client", "el", "io", "URL", "path", "log", "fl", "sl", "Url", "host", "string", "conn", "ls", "contact", "stream", "image", "ssl", "connection", "ll", "www", "config", "pull", "socket", "ur", "ul", "uri", "service", "http", "l", "source", "file", "server", "channel", "download", "coll", "open", "web", "f"], "WSDLFile": ["WDDlBase", "WSDLLFile", "WINDELPath", "WDDLFolder", "WDDLFile", "WDDlFile", "WDDLBase", "WSDDLFile", "WSDlPath", "WSDLfile", "WSDlBase", "WSDLLFiles", "WDDlFolder", "WDDLfile", "WSDLSourceFile", "WSDDLFolder", "WDDlPath", "WSDLFiles", "WSDLLFolder", "WSDLLSourceFile", "WDDlfile", "WSDELFolder", "WINDLFile", "WSDlFolder", "WSDLPath", "WINDELFiles", "WSDlfile", "WDDLPath", "WSDDLBase", "WSDELFile", "WSDLLBase", "WINDELFolder", "WSDDLfile", "WSDDLFiles", "WSDDLPath", "WINDELFile", "WSDLLfile", "WSDlFile", "WSDELFiles", "WSDlSourceFile", "WSDDLSourceFile", "WINDLFolder", "WSDLLPath", "WSDLBase", "WDDlSourceFile", "WDDLSourceFile", "WSDLFolder", "WSDELPath", "WINDLFiles", "WINDLPath"], "tmpWSDLFile": ["tmpWDDELUrl", "tmpWSDDLLocation", "tmpWSDELFile", "tmpWSDDLFiles", "tmpWSDLLocation", "tmpWDDELFile", "tmpWDDlFile", "tmpWSDLFiles", "tmpWSDlFolder", "tmpWSDLLFolder", "tmpWDDLFile", "tmpWSDELFiles", "tmpWSDlLocation", "tmpWDDLLocation", "tmpWSDlFiles", "tmpWSDlFile", "tmpWDDlFolder", "tmpWDDLUrl", "tmpWSDlUrl", "tmpWSDLLFile", "tmpWSDLFolder", "tmpWDDELLocation", "tmpWSDELFolder", "tmpWSDELUrl", "tmpWDDlFiles", "tmpWSDLLUrl", "tmpWSDLUrl", "tmpWDDlUrl", "tmpWDDELFiles", "tmpWSDDLFile", "tmpWDDLFiles", "tmpWSDLLFiles", "tmpWDDLFolder", "tmpWSDDLUrl", "tmpWSDELLocation"], "inputFile": ["outputDir", " inputFactory", "InputFactory", "inputDir", " inputStream", "Inputfile", " inputFiles", " inputBuffer", "tempBuffer", " inputPage", "tempPlace", "requestfile", "InputDir", "inFile", " inputBase", "inputPage", "InputFile", "inputFactory", "tempUrl", "infile", "inputStream", "tempFactory", "tempPage", "tempFile", "tempBase", "InputUrl", "InputFiles", " inputfile", " inputUrl", "InputPlace", "inputFiles", " inputPlace", "outputFiles", "outputfile", "requestStream", "InputBuffer", "requestFiles", "inputPlace", "inputUrl", "inputBase", " inputDir", "requestFile", "inDir", "tempfile", "InputBase", "inputBuffer", "InputPage", "inPage", "InputStream", "outputFile", "inputfile"], "tmpFile": ["TempFiles", " tmpFiles", "TempDirectory", " tmpDirectory", "uploadStream", "tempDocument", "uploadFile", "TempFile", "inputDocument", "tmpStream", "inputStream", "tempPage", "tempFile", "tmpDirectory", "tmpPage", "tempDirectory", "inputFiles", "tempStream", "TempPage", "tempFiles", "tmpFiles", "uploadDocument", " tmpPage", "uploadFiles"], "in": ["gin", "ins", "din", "reader", "IN", "client", "login", "bin", "id", "inc", "input", "In", "conn", "on", "inner", "image", "c", "lock", "m", "ssl", "connection", "r", "again", "socket", "win", "inn", "p", "pin", "is", "l", "data", "source", "file", "up", "lin", "init", "impl", "f"], "out": ["net", "error", "OUT", "client", "outs", "IN", "cache", "output", "bin", "io", "inc", "log", "input", "conn", "conv", "on", "inner", "In", "name", "to", "image", "err", "c", "Out", "writer", "connection", "again", "parent", "o", "co", "socket", "sync", "outer", "timeout", "copy", "line", "source", "channel", "file", "up", "ch", "server", "group", "part", "conf", "can"], "con": ["bc", "cm", "gin", "ins", "thin", "uc", "client", "IN", "un", "ran", "com", "inc", "connect", "conn", "conv", "inner", "c", "plain", "en", "ssl", "connection", "rec", "co", "fc", "socket", "sync", "Con", "win", "close", "CON", "rc", "channel", "ch", "cn", "kin", "nc", "Conn", "open", "ctrl", "conf", "can"], "fileLength": ["Filelength", " fileSize", "FileWidth", "channelWidth", "contentLen", " fileLen", "channelLen", "fileWidth", "FileLength", "filelength", "fileLen", " filelength", "contentlength", " fileWidth", "FileSize", "channelSize", "fileSize", "contentLength", "channelLength", "contentSize", "FileLen"], "channelIn": ["ChannelOut", "characterIN", "connectionOut", "Channelin", "characterin", "resourceIN", "connectionIn", "ChannelIN", " channelIN", "channelConn", "connectionConn", "resourcein", " channelConn", "characterOut", "resourceIn", "ChannelConn", "resourceOut", "ChannelIn", "connectionin", "channelIN", " channelin", "channelin", "characterIn"], "channelOut": ["chanOUT", "ChannelOut", "connectionOutput", "connectionOut", "ChannelOutput", "ChannelOutside", " channelOutput", "connectionIn", "channelOutside", "channelout", "connectionOutside", "connectionout", "channelOutput", "channelOUT", "ChannelOUT", "canIn", "canOUT", "ChannelIn", " channelout", "canOut", "chanOut", "canOutside", "chanOutside", "chanIn", "chanout", "Channelout"], "tmpDocument": ["tmpDoc", "tmFile", "tmNode", "newContent", " tmpDoc", "mpDoc", "tmpNode", "newFile", "tempDoc", " tmpContent", "tempdocument", "tempDocument", " tmpNode", "mpDocument", "tmpContent", "tempFile", "newDocument", "tmpdocument", "tempContent", "mpFile", "tmDocument", " tmpdocument", "newdocument", "mpNode", "tempNode", "tmdocument"], "nl1": ["dl1", "arlone", "dl0", "NL11", "kl1", "ln1", "klFirst", "nl5", "ln6", "arlFirst", "ln2", "klone", "arl5", "nl6", "nn11", "NL6", "NL0", "nn6", "nl11", "jl1", "nl0", "jlone", "jl5", "dl2", "kl5", "nn2", "nn0", "nl2", "nlFirst", "NL2", "nlone", "nn1", "ln11", "jlFirst", "NL1", "arl1"], "i": ["qi", "v", "z", "ip", "ai", "ti", "I", "uli", "e", "id", "io", "iu", "xi", "ini", "index", "eni", "ui", "li", "u", "hi", "multi", "ci", "si", "mi", "phi", "ii", "m", "y", "j", "ie", "info", "b", "n", "o", "slice", "ri", "uri", "p", "ix", "gi", "fi", "it", "abi", "di", "oi", "l", "ni", "d", "chi", "yi", "ji", "f", "part", "mu", "bi", "pi"], "node1": ["package91", "Node91", "packageOne", "NodeOne", "packageone", "Node0", "shape1", " node91", "node2", "layer91", "layer1", "n0", "layerOne", "n1", "n2", "node0", "nOne", "Node1", "package1", "layer2", "shapeone", "nodeOne", " nodeone", " node0", "nodeone", "shapeOne", "node91", "shape91", " nodeOne", " node2", "Node2"], "tmpOut": [" tmpOUT", "txtOut", "vmOUT", "ptyOut", " tmpWriter", "tempOUT", "tempWriter", "txtOutput", "tempIn", "ptyIn", "tempOut", "tmpWriter", "vmOut", "tempFile", "ptyOutput", "cacheFile", "tempout", "tmpOUT", "tempOutput", "txtout", "cacheOut", "txtWriter", "cacheOUT", "vmIn", "ptyout", "tmpout", " tmpIn", "cacheIn", "tmpIn", " tmpout", "tmpOutput", " tmpOutput", "vmout"], "retVal": ["valRet", "valval", "retObj", "retval", " retval", "retRet", "RETval", "RETObj", " retObj", " retRet", "valObj", "valVal", "RETVal", "RETRet"]}}
{"id1": "8119563", "id2": "21531069", "code1": "    protected boolean checkLink(URL url) {\n        try {\n            URLConnection connection = url.openConnection();\n            connection.connect();\n            return true;\n        } catch (IOException e) {\n            MsgLog.error(\"DapParser.checkLink(): IOException: \" + e.toString());\n            return false;\n        }\n    }\n", "code2": "    public int updateuser(User u) {\n        int i = 0;\n        Connection conn = null;\n        PreparedStatement pm = null;\n        try {\n            conn = Pool.getConnection();\n            conn.setAutoCommit(false);\n            pm = conn.prepareStatement(\"update user set username=?,passwd=?,existstate=?,management=? where userid=?\");\n            pm.setString(1, u.getUsername());\n            pm.setString(2, u.getPasswd());\n            pm.setInt(3, u.getExiststate());\n            pm.setInt(4, u.getManagement());\n            pm.setString(5, u.getUserid());\n            i = pm.executeUpdate();\n            conn.commit();\n            Pool.close(pm);\n            Pool.close(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            Pool.close(pm);\n            Pool.close(conn);\n        } finally {\n            Pool.close(pm);\n            Pool.close(conn);\n        }\n        return i;\n    }\n", "label": 0, "substitutes": {"checkLink": [" checkConnect", " checkLine", "loadLine", "CheckLine", "CheckConnect", "loadLink", "checkLine", "Checklink", " checklink", "loadlink", "loadConnect", "CheckLink", "checkConnect", "checklink"], "url": ["address", "base", "client", "str", "proxy", "URL", "sl", "Url", "host", "location", "name", "string", "conn", "image", "link", "or", "ssl", "element", "class", "route", "null", "object", "config", "loc", "socket", "uri", "service", "resource", "http", "l", " URL", "source", "file", "server", "entry", "page", "instance", "open"], "connection": ["position", "client", "builder", "io", "function", "connect", "conn", "response", "image", "c", "link", "database", "character", "communication", "writer", "i", "Connection", "b", "application", "object", "handler", "config", "loc", "socket", " Connection", "uri", "timeout", "resource", "http", "ion", "l", "data", "channel", "server", "network", "unit", "open", "connected", "relation"]}}
{"id1": "19206412", "id2": "11005804", "code1": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"md5String": ["md512String", " md5Bytes", "md4string", "md5string", "md512string", "md4String", " md5Str", "md6Bytes", "md6Str", " md512string", "md6String", "md6string", " md5string", "md512Bytes", " md512Str", "md5Bytes", "md512Str", " md512Bytes", "md4Str", " md512String", "md4Bytes", "md5Str"], "str": ["url", "result", "st", "re", "sr", "e", "br", "exp", "dict", "arr", "er", "string", "out", "s", "obj", "hr", "name", "err", "doc", "this", "self", "Str", "strings", "r", "kr", "text", "tr", "STR", "enc", "star", "fr", "bytes", "dr", "stri", "data", "char", "pass", "sp", "txt", "f", "msg"], "md": ["MD", "map", " Md", "mc", "dig", "ms", "metadata", "pm", "bd", "amd", "db", "am", "df", "mo", "um", "mk", "mb", "mt", "cmd", "hd", "sm", "rpm", "code", "mand", "m", "dd", "Cmd", "od", "mg", "mm", "ma", "ad", "pd", "mail", "cd", "wd", "mac", "hm", "mod", "me", "data", "ld", "dh", "d", "mag", "vd", "dm", "sum", "mu", " MD", "mp", "cmp"], "hash": ["address", "url", "header", "sha", "base", "error", "ver", "ash", "cache", "rh", "chip", "bin", "id", "arr", "check", "Hash", "index", "host", "dot", "kh", "range", "memory", "image", "hex", "code", "count", "html", "print", "number", "body", "ha", "tr", "diff", "block", "her", "array", "key", "h", "search", "sh", "filter", "char", "value", "part", "sum", "f"], "hexChars": ["hexCHats", "hexchats", "hexchars", "hexCHacters", "hexKhars", "hashchARS", "hexCHARS", "hashchacters", "hashChash", " hexchashes", "hexCARS", "hexKhash", "hexKhARS", "hexChash", "hexCharashes", "hexCHashes", "hexCHases", "hashCHars", "hexChARS", "hashCHashes", " hexchats", "hexChats", " hexChARS", "hashChashes", "hashchases", "hexCashes", "hexChashes", "hexchashes", "hashChases", "hexCharARS", "hexCash", "hexCharases", "hexchacters", "hexchases", "hashChars", " hexChats", "hashChacters", " hexChashes", "hashChARS", "hashchars", "hashCHARS", "hexCharacters", "hexCHars", "hashCHash", "hexCars", "hexchARS", "hexChases", "hexCharars", "hexCharats", "hexChacters", "hexKhashes", "hexCHash", " hexchars", " hexchARS"], "res": ["Results", "us", "rules", "rex", "result", "cache", "re", "resolution", "reg", "arr", "ress", "Result", "vs", "es", "Res", "out", "string", "s", "vers", "ris", "abs", "ret", "err", "RS", "results", "pers", "bs", "ras", "r", "des", "vals", "rus", "rows", "cs", "ps", "css", "Rs", "RES", "bytes", "rez", "data", "resp", "pres", "req", "rss", "details", "ss", "ros", "cons", "rs", "response", "rev"], "i": ["qi", "v", "k", "base", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "index", "length", "u", "li", "ui", "hi", "multi", "c", "ci", "si", "phi", "code", "ii", "y", "m", "j", "a", "info", "ie", "b", "o", "bi", "diff", "ri", "uri", "p", "it", "gi", "h", "ix", "abi", "in", "oi", "di", "l", "d", "field", "ji", "part", "mu", "f", "pi", "temp"]}}
{"id1": "4629990", "id2": "21555906", "code1": "    private String logonToServer(FTPClient ftpClient, String ftpAddress, int noRetries) {\n        String remoteHomeDir = null;\n        noRetriesSoFar = 0;\n        while (true) {\n            try {\n                ftpClient.connect(ftpAddress, ftpPort);\n                int reply = ftpClient.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftpClient.disconnect();\n                    throw new IOException();\n                }\n                if (!ftpClient.login(user, password)) {\n                    throw new IOException();\n                }\n                remoteHomeDir = ftpClient.printWorkingDirectory();\n                msgEntry.setAppContext(\"logonToServer()\");\n                msgEntry.setMessageText(\"Logged into FTP server \" + ftpAddress + \":\" + ftpPort + \" as user \" + user);\n                logger.logProcess(msgEntry);\n                break;\n            } catch (IOException e) {\n                logoutAndDisconnect(ftpClient);\n                if (noRetriesSoFar++ < noRetries) {\n                    waitBetweenRetry();\n                    notifyAndStartWaitingFlag = false;\n                } else {\n                    notifyAndStartWaitingFlag = true;\n                    errEntry.setThrowable(e);\n                    errEntry.setAppContext(\"logonToServer()\");\n                    errEntry.setAppMessage(\"Unable to login after \" + (noRetriesSoFar - 1) + \" retries. Max Retries.\\n\" + \"Address:\" + ftpAddress + \"\\n\" + \"User:\" + user);\n                    errEntry.setSubjectSendEmail(\"Unable to login to \" + ftpAddress + \" after \" + (noRetriesSoFar - 1) + \" retries.\");\n                    logger.logError(errEntry);\n                    break;\n                }\n            }\n        }\n        return remoteHomeDir;\n    }\n", "code2": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"logonToServer": ["logonToGuest", "logOnFromRemote", "logOnFromClient", "logOnToRemote", "logOnToServer", "logOnFromServer", "logonTOClient", "logonFromServer", "logonTOGuest", "logOnToClient", "logonFromGuest", "logOnToGuest", "logonFromClient", "logonFromRemote", "logontoRemote", "logonTOServer", "logonTORemote", "logontoClient", "logOnFromGuest", "logonToRemote", "logontoServer", "logonToClient", "logontoGuest"], "ftpClient": ["ftcpAPI", "ftpaClient", "ctpPort", "ftbclient", "ftbConn", "ftcpPort", "ctcpConn", "ctcpConnect", "ctcpServer", "ftapclient", " ftpCloud", "ftpConnect", "ftpaCloud", "ftpaConn", "ftpcClient", "ftcpCenter", "ftprClient", " ftpclient", "ftpaServer", "ftpclient", " ftpaServer", " ftpaClient", "ftcpContext", "ftpiServer", "ftpcConnect", "ftpConn", "ftprPort", "ftpiClient", "ftpcServer", "ftpcPort", "ftcServer", " ftbCloud", "ftpcContext", " ftpPort", " ftpcServer", " ftpcClient", "ftpiAddress", "ftsPort", "ftcpClient", "ftcConnection", "ctpAPI", "ctpServer", "ftcClient", "ftcpConn", " ftpcContext", "ftpcAddress", "ftpaPort", "ftsClient", " ftpConn", "ftcpConnection", "ftpaCenter", "ftcpServer", "ctpConnect", "ftbPort", " ftpaclient", " ftpServer", "ftsServer", "ctcpAddress", "ctcpAPI", " ftpConnection", "ctpAddress", "ftpConnection", "ftpcclient", "ftpcConn", "ftbCloud", "ftnAddress", " ftpcConnection", "ctcpClient", "ftapCenter", "ftcContext", " ftpCenter", " ftpaCenter", "ftnServer", "ctcpPort", "ftpCloud", "ftbClient", "ftpContext", "ftpAPI", "ftcpConnect", "ftnClient", "ftapClient", "ftpcCloud", "ftsConnect", "ftnAPI", " ftpaPort", "ftapServer", "ctpConn", "ctpClient", "ftpServer", "ftpiAPI", "ftcpAddress", "ftcpclient", "ftprclient", "ftpcConnection", "ftpaAddress", " ftpContext", "ftpaclient", "ftpPort", " ftbConn", "ftpCenter", " ftbClient", " ftbclient"], "ftpAddress": ["ctpPort", "ftcpURL", "ftcpPort", " ftpaddress", "ftfAdd", "ftoAddress", "ftapPort", "ctoPort", "ftfEntry", " ftcpaddress", "ctpAdd", "ftoaddress", "ftfPort", "ftapAlias", "ctcpURL", "ftlAddress", "ftcpInterface", " ftcpAddress", "ftrInterface", "ftwpAddress", " ftcpPort", "ftportaddress", "ftnpAddress", " ftpPort", "ctcpaddress", "ctcpInterface", "ftlPort", "ctpaddress", "ftnpPort", "ftwpaddress", " ftcpAlias", "ctoAddress", "ftportPort", "ftfInterface", "ftportAlias", "fttpPort", "ctcpAdd", "ctcpAddress", "ctpInterface", "ftapaddress", "ftnpURL", "ctpAddress", "ctoaddress", "ftcpaddress", "ftpInterface", "ctpEntry", "ftpURL", "ftrPort", "ftrAdd", "ftpAdd", "ftladdress", "ctcpEntry", "ctcpPort", "ftcpAlias", "fttpURL", "ftfAddress", "ftpAlias", "ftwpPort", "ftpEntry", "ftapAddress", "ctpURL", "ftcpAddress", "ftnpaddress", "fttpEntry", "fttpaddress", "ftrAddress", "ftfaddress", "ftcpEntry", "ftcpAdd", "ftportAddress", "ftpPort", "ftpaddress", "fttpAddress", "ftoPort", " ftpAlias"], "noRetries": ["noretrying", "noEntrying", " noPatriers", " noRetrys", " noPatries", "noPatrys", "noTry", "noTrying", "noPatry", "noPatriers", "noTrys", "noExtrys", "noExtrying", "noretries", "noExtries", " noPatry", "noRetrying", "noEntries", "noTries", " noPatrying", " noRetriers", "noRetriers", "noPatries", " noPatrys", " noRetry", "noretrys", "noRetrys", "noRetry", "noretriers", "noEntrys", "noEntriers", " noRetrying", "noExtry", "noPatrying"], "remoteHomeDir": ["remoteHomePath", "RemoteRootPath", " remoteHomeFolder", "remoteHostPath", "RemoteHomeFile", "remoteWorkingPath", "remoteRootDir", " remotehomeFolder", "remoteHomeFolder", " remotehomeFile", "remotehomePath", "remoteHostDirectory", "remoteRootPath", "remotehomeFolder", "remoteRootDirectory", "remoteHostDir", "RemoteRootFile", "remoteHostFolder", " remoteHomeDirectory", "RemoteRootDirectory", "remoteRootFile", "remoteWorkingDir", " remotehomeDir", "RemoteHomeDirectory", "remoteHomeDirectory", "remotehomeFile", "remoteRootFolder", "RemoteRootDir", "RemoteHomeDir", "remotehomeDirectory", "remoteWorkingDirectory", "remoteHostFile", "RemoteHomePath", " remoteHomeFile", "remotehomeDir", " remotehomeDirectory", "remoteHomeFile", "remoteWorkingFile"], "noRetriesSoFar": ["noRetryingsoMuch", "noRetriesSOFurther", "noRetriesStillFurther", "noRetriesSofar", "noRetriessoFar", "noRetrySoFar", "noRetriesTooMuch", "noRetriesSoFurther", "noRetrySOfar", "noRetrysSOFar", "noRetrysSoFar", "noRetriesStillFar", "noRetrysSOfar", "noRetryingSoMuch", "noRetriessoMuch", "noRetriessofar", "noRetriessoFurther", "noRetryingsofar", "noRetrysSofar", "noRetrySOFar", "noRetriesSoMuch", "noRetrysSoFurther", "noRetriesSOMuch", "noRetriesSincefar", "noRetrySofar", "noRetriesTooFar", "noRetriesSOfar", "noRetrysSOFurther", "noRetryingSoFar", "noRetryingsoFar", "noRetryingSofar", "noRetriesSOFar", "noRetriesSinceFar", "noRetriesToofar", "noRetriesStillfar"], "reply": ["address", "result", "base", "error", "lie", "ping", "send", "status", "call", "answer", "comment", "feed", "request", "py", "state", "ret", "queue", "prefix", "link", "len", "bot", "next", "write", "code", "respond", "reason", "repl", "connection", "count", "info", "user", "report", "Reply", "sync", "ply", "message", "post", "service", "ix", "from", "rc", "dy", "resp", "server", " replies", " replied", "response"]}}
{"id1": "8132219", "id2": "13852596", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "inFile": ["InFilename", "Infile", "binfile", "inputFile", "InFile", "INfile", "InSourceFile", "INSourceFile", "infile", "binPlace", "inputFiles", "inPlace", " infile", "binFiles", " inFilename", "inputPlace", "outfile", "outPlace", "inFilename", " inSourceFile", "binFile", "inFiles", "outFiles", "inSourceFile", "INFile", "inputfile", "INFilename"], "outFile": ["againFilename", " outFilename", "againPlace", "outputFilename", " outfile", "infile", " outPlace", "outputPlace", "outputFiles", "outputfile", " outFiles", "outfile", "againfile", "outPlace", "inFilename", "inFiles", "outFiles", "outFilename", "againFile", "outputFile"], "in": ["url", "base", "ins", "reader", "din", "IN", "bin", "id", "io", "inc", "x", "ini", "index", "input", "ic", "In", "name", "inner", "image", "c", "like", "m", "a", "i", "connection", "n", "again", "config", "inn", "pin", "is", "data", "source", "file", "work", "rin", "part", "as", "f"], "out": ["exec", "external", "v", "OUT", "client", "outs", "cache", "w", "call", "output", "bin", "io", "x", "log", "default", "conn", "name", "ext", "string", "dot", "obj", "to", "image", "write", "c", "prefix", "Out", "plain", "writer", "user", "b", "null", "n", "ex", "o", "buffer", "version", "resource", "p", "copy", "line", "data", "file", "part", "Output"], "inChannel": ["inputChan", " inchannel", "sinFlow", "inChan", " inSocket", "iniStream", " inConnection", "sinChan", "outChan", "winStream", "inchannel", "outchannel", "INFlow", "inichannel", "outStream", "inSocket", "inputStream", "inputchannel", "winLanguage", "outConnection", "winchannel", "INChan", "INSocket", "INchannel", "winChannel", "INChannel", "inStream", "sinChannel", "iniLanguage", "outLanguage", " inChan", "iniChannel", "INStream", "sinSocket", " inFlow", "inConnection", "INConnection", "inFlow", "inputChannel", "inLanguage"], "outChannel": ["againChannel", "Outchannel", "outputChan", "outContext", " outConnection", "inChan", "OutStream", " outChan", "outputchannel", "againchannel", "newContext", "outChan", " outContext", "OutConnection", "inchannel", "outchannel", "outputChannel", "outStream", "outConnection", "againChan", " outStream", "newChannel", "againPath", "OutContext", "inConnection", "newStream", " outchannel", "outPath", "OutChan", "newChan", "OutChannel", "inPath", " outPath"]}}
{"id1": "14794404", "id2": "1097147", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["encryptpassword", "encressSecret", "encressPassword", "EncipherString", "encipherPassword", "encipherString", "encresspassword", "encryptedSecret", "EncryptSecret", "encipherSecret", "encryptedString", "EncryptString", "encressString", "EncipherSecret", "encipherpassword", "EncipherPassword", "encryptString", "Encryptpassword", "encryptSecret", "encryptedpassword", "Encipherpassword", "EncryptPassword"], "password": ["address", "params", "token", "Password", "cache", "description", "sword", "path", "input", "pattern", "string", "name", "word", "prefix", "database", "words", "username", "crypt", "connection", "definition", "text", "object", "enc", "padding", "message", "buffer", "resource", "array", "p", "attribute", "wd", "content", " passwords", "phrase", "data", "PASS", "channel", "secret", "email", "device", "pass"], "encryptedPassword": [" encryptedpassword", "protectedCode", "lockedString", "ryptedPass", "lockedpassword", "lockedPass", "ryptedCode", "ryptedpassword", "protectedPass", "protectedPassword", "encryptedPass", "encryptedCode", "protectedpassword", "encryptedString", " encryptedCode", " encryptedPass", "lockedPassword", " encryptedString", "ryptedString", "encryptedpassword", "protectedString", "ryptedPassword"], "md5": ["MD3", "MD512", "MD45", "amd4", " mddown", "mddown", "dig45", "md512", "dig3", " md3", "MD4", "dig4", " MD512", " md45", "MD2", "dig5", " md6", "amd5", " md512", "digdown", "md2", "MDdown", " MD5", "md6", " md2", "amd6", "amd2", " MD3", "dig2", " MD2", " md4", "md45", "md3", "md4", "MD5", "MD6"], "digest": ["encest", "signest", "mdment", "digace", "mdher", " digests", " digment", "Digenge", " digher", "encment", "digenge", "mdest", "encester", "mdests", " digester", "digester", "digests", "digment", "Digests", "digher", "signests", "Digher", "digested", "mdested", "mdace", "mdash", "Digester", " digenge", "signester", "Digest", "encash", "Digested", " digace", " digash", "mdenge", "Digace", "signested", "digash", "mdester"], "i": ["qi", "v", "k", "ip", "ai", "ti", "I", "e", "id", "io", "xi", "x", "index", "length", "li", "u", "ui", "s", "hi", "multi", "ci", "c", "si", "phi", "ii", "t", "j", "ie", "r", "b", "o", "zi", "ri", "uri", "p", "gi", "ix", "h", "it", "l", "oi", "di", "d", "f", "bi", "pi"], "hex": ["hash", "lit", "digit", "rex", "ip", "pex", "bit", "rh", "str", "pixel", "bin", "id", "exp", "zip", "sign", "none", "check", "utf", "stick", "pattern", "string", "length", "ext", "binary", "prefix", "comp", "serial", "ex", "text", "null", "enc", "oct", "bits", "slice", "pack", "alpha", "mix", "ix", "nexus", "di", "data", "char", "shift", "letter", "sex", "num", "coord", "closure", "ctr", "buff", "temp"]}}
{"id1": "3266833", "id2": "13063241", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"is": ["us", "im", "iv", "ais", "ins", "ip", "ib", "iso", "was", "has", "id", "isa", "IS", "bis", "ws", "Is", "es", "abs", "ir", "cms", "ris", "image", "ios", "iss", "os", "or", "i", "info", "lis", "fits", "isc", "isu", "close", "get", "iris", "its", "in", "init", "as", "bs", "mis"], "name": ["address", "url", "base", "description", "alias", "title", "ame", "id", "nice", "term", "Name", "one", "path", "space", "default", "filename", "string", "named", "word", "domain", "image", "no", "size", "prefix", "database", "memory", "this", "large", "code", "vision", "type", "format", "connection", "null", "n", "NAME", "parent", "directory", "office", "version", "min", "key", "search", "data", "source", "file", "pass", "value", "names", "part", "label", "module"], "contentType": ["ContentType", "ContentInfo", "outputType", "sourcetype", "outputName", " contentPoint", "sourceType", "documentType", "contentInfo", "contentName", "ContentPath", "documenttype", "outputTypes", "mediaName", "mediaTypes", " contentInfo", "messageType", " contenttype", "Contenttype", " contentName", "messagetype", "messageName", "ContentTypes", "contenttype", "mediaPath", "documentInfo", "contentPoint", "contentTypes", "documentPoint", "ContentName", "sourceInfo", "mediaType", "messageInfo", "sourcePoint", "contentPath", "outputPath"], "index": ["position", "address", "error", "level", "id", "inc", "none", "x", "default", "include", "input", "pointer", "string", "length", "offset", "end", "image", "write", "multi", "prefix", "axis", "expression", "type", "i", "number", "shape", "body", "pull", "slice", "weight", "list", "Index", "update", "alpha", "depth", "height", "timeout", "key", "content", "search", "page", "in", "data", "append", "width", "fix", "value", "open", "size"], "extension": ["configensions", "variensions", "Extensions", "configuration", "variance", "configension", "variuration", "Extension", "variension", "Extance", "extance", "Exturation", "exturation", "configance", "extensions"], "isImage": [" isFile", "isaFile", " isVideo", "asFile", "isaImage", "isInstance", "IsImage", "areimage", "ISFile", " isimage", " isInstance", "isimage", " isMedia", "ISImage", "isaMedia", "areImage", "asimage", "isVideo", "IsVideo", "ISVideo", " isImages", "areMedia", "isMedia", "areInstance", "isPicture", "asImage", "isFile", "ISPicture", "areFile", "IsFile", " isPicture", "IsPicture", "asInstance", "areImages", "isaImages", "isImages"], "isAux": ["isAAux", "isAcUX", "isUex", "isWaux", " isAxt", " isAx", "isWax", " isAUX", "isArrayru", "isAnux", "isAAru", "isAcxt", "isUlux", "isAsux", "isAAxt", "isAx", "isArrayUX", "isArrayux", "isWaUX", "isAAUX", " isHax", "isAslux", " isArrayux", "isAsex", "isAsUX", "isUUX", "isUux", "isAExcept", " isHaux", "isHaux", "isAnex", "asAsex", "isAex", "asAsUX", "asAsux", "isHax", "isUExcept", "asAux", "isAxt", "isAnlux", "isAnUX", "asAsExcept", "isOAlux", "isOAux", "isAlux", "isWalux", "isAsx", "asAExcept", "isHalux", "isAcux", "isAsExcept", "isOAExcept", "isOAUX", "asAex", "isArrayxt", "isAcru", " isArrayUX", " isHalux", "isHaUX", " isAlux", "asAlux", " isHaUX", " isAru", "isAUX", "isAru", "asAUX", " isArrayxt", "asAslux", " isArrayru"], "out": ["exec", "result", "base", "error", "OUT", "client", "outs", "cache", "project", "output", "exp", "io", "input", "auto", "conn", "ext", "inner", "word", "obj", "image", "next", "prefix", "off", "this", "Out", "plain", "extra", "at", "a", "user", "ex", "object", "again", "null", "o", " in", "over", "parent", "sync", "socket", "post", "outer", "array", "table", "version", "buffer", "copy", "in", "page", "data", "pool", "file", "up", "work", "source", "part", "size", "temp"], "bufferedImage": ["buffledimage", "BufferingImage", "bufferingImage", "buffledImage", "buffendedimage", "BufferedImage", "bufferingimage", "Bufferedimage", "buffendedImage", "bufferedimage", "Bufferingimage"], "inputStream": ["InputSteam", "outputBuffer", "inputstream", "outputStream", " inputSteam", "Inputstream", "inputSteam", "inputBuffer", " inputstream", "outputstream", "InputBuffer", "InputStream", " inputBuffer", "outputSteam"]}}
{"id1": "11082670", "id2": "22442270", "code1": "    @SuppressWarnings(\"unchecked\")\n    public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException {\n        StringBuilder json = new StringBuilder();\n        String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n        try {\n            URL url = new URL(requestUrl.toString());\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                json.append(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            throw new GtugsException(e);\n        }\n        List<Event> events = new ArrayList<Event>();\n        JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString());\n        JSONArray results = (JSONArray) jsonObj.get(\"results\");\n        for (int i = 0; i < results.size(); i++) {\n            JSONObject result = (JSONObject) results.get(i);\n            Event e = new Event();\n            e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\")));\n            e.setCity((String) result.get(\"venue_city\"));\n            e.setDescription((String) result.get(\"description\"));\n            e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\")));\n            e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\")));\n            e.setName((String) result.get(\"name\"));\n            Date myDate = null;\n            String time = (String) result.get(\"time\");\n            try {\n                myDate = meetupDateFormat.parse(time);\n                e.setStartTime(timeDateFormat.format(myDate));\n                e.setEndTime(timeDateFormat.format(myDate));\n                e.setStartDate(myDate);\n                e.setEndDate(myDate);\n                String tz = tzDateFormat.format(myDate);\n                if (tz != null && tz.startsWith(\"+\")) {\n                    tz = tz.substring(1);\n                }\n                e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100));\n            } catch (ParseException ex) {\n                ex.printStackTrace();\n                continue;\n            }\n            e.setState((String) result.get(\"venue_state\"));\n            StringBuilder addressBuilder = new StringBuilder();\n            if (result.get(\"venue_address1\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address1\") + \" \");\n            }\n            if (result.get(\"venue_address2\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address2\") + \" \");\n            }\n            if (result.get(\"venue_address3\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address3\") + \" \");\n            }\n            if (result.get(\"venue_address4\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address4\"));\n            }\n            e.setStreetAddress(addressBuilder.toString().trim());\n            e.setZipCode((String) result.get(\"venue_zip\"));\n            e.setUrl((String) result.get(\"event_url\"));\n            events.add(e);\n        }\n        return events;\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"lookupFutureEvents": ["lookupupEvent", "lookupAllEvent", "lookupRequestEvents", "lookUpFutureItems", "lookupAllEvents", "lookUpupEvents", "lookUpupItems", "lookupAllItems", "lookUpupEvent", "lookupRequestItems", "lookUpFutureEvents", "lookupFutureItems", "lookupRequestEvent", "lookupupItems", "lookupupEvents", "lookupFutureEvent", "lookUpFutureEvent"], "groupIdentifier": ["groupidentifer", "groupIdentizer", "groupidentification", " groupIdentifiers", "groupSequifiers", "groupIdifier", "groupIdifer", " groupIdentification", "groupIdentifer", "groupSequifier", "groupSequification", "groupIdifiers", "groupSequifer", "groupIdizer", " groupIdentifer", "groupidentizer", "groupIdentification", "groupidentifier", "groupIdentifiers", "groupidentifiers", " groupIdentizer"], "json": ["JSON", "token", "description", "status", "son", "output", "id", "zip", "io", "xml", "request", "input", "sql", "string", "obj", "struct", "build", "journal", "j", "ssl", "info", "html", "js", "twitter", "body", "text", "jack", "query", "list", "array", "message", "api", "key", "http", "data", "server", "value", "rss", "photo", "txt", "response", " JSON"], "requestUrl": ["RequestURL", "requestAddress", "downloadUr", "RequestStr", "downloadUrl", "responseStr", "requestUr", "downloadURL", " requestUr", "RequestUr", " requestName", " requestStr", " requestAddress", "requestName", "downloadAddress", "requestStr", "requestURL", " requestURL", "RequestName", "RequestUrl", "responseURL", "RequestAddress", "responseName", "responseUrl"], "url": ["address", "base", "client", "io", "URL", "path", "sl", "input", "Url", "string", "gl", "stream", "image", "hub", "org", "event", "ssl", "connection", "user", "rule", "socket", "buffer", "uri", "service", "resource", "api", "http", "l", "data", "file", "server", "channel", "source", "open", "web", "rl", "f"], "in": ["gin", "ins", "reader", "din", "IN", "re", "login", "bin", "id", "io", "inc", "ini", "input", "er", "out", "In", "s", "stream", "inner", "image", "c", "err", "read", "ssl", "r", "b", "again", "fr", "buffer", "inn", "min", "is", "into", "line", "l", "data", "lin", "source", "init", "impl", "serv", "f"], "inputLine": [" inputText", "eventline", "requestLine", "outputStream", "audioL", " inputStream", "InputL", "requestBlock", "audioLine", "audioUrl", "outputBlock", "inputL", "controlStream", "inputStream", "controlLine", "InputUrl", "eventLine", "eventStream", " inputUrl", "inputline", "requestL", "controlL", " inputL", "requestStream", "controlBlock", "InputLine", "inputUrl", "outputText", "outputline", " inputline", "outputLine", "inputText", "eventText", "outputL", "inputBlock"], "events": ["services", "fires", "groups", "archives", "reports", "members", "times", "Events", "forms", "ents", "es", "lists", "lines", "files", "comments", "items", "errors", "rows", "plugins", "issues", "actions", "views", "dates", "pages", "effects", "tests", "features"], "jsonObj": ["jsonArray", "JSONAct", "xmlExt", "xmlobj", "JSONObj", "JSONObject", "sonobj", "xmlAct", "responseObj", "responseObject", "xmlArray", "xmlObj", "jsonobj", "sonArray", "JSONobj", "jsonExt", "sonObj", "responseAct", "xmlObject", "responseobj", "jsonObject", "sonExt", "JSONExt", "JSONArray", "jsonAct"], "results": ["Results", "rules", "objects", "groups", "output", "reports", "shows", "Result", "times", "Events", "ions", "es", "res", "stats", "RESULTS", "values", "response", "vers", "resources", "changes", "terms", "words", "items", "errors", "r", "vals", "rows", "runs", "dates", " Results", "its", "pages", "data", "qs", "successful", "ries", "ventures", "details", "products", "roads", "tests", "features", "ings"], "i": ["qi", "v", "ip", "ai", "ti", "vi", "I", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "u", "li", "ui", "hi", "inner", "multi", "ci", "c", "uni", "si", "phi", "ii", "j", "ie", "info", "ori", "b", "n", "bi", "slice", "ri", "uri", "p", "ix", "gi", "h", "fi", "oi", "di", "chi", "yi", "ji", "mu", "f", "pi"], "result": ["complete", "feature", "error", "ver", "job", "rh", "status", "sr", "output", "comment", "found", "view", "term", "Result", "request", "particip", "function", "default", "row", "goal", "session", "res", "profile", "section", "err", "success", "order", "event", "element", "info", "report", "r", "user", "role", "rule", "back", "query", "venture", "ner", "game", "message", "date", "resource", "plus", "search", "page", "entry", "data", "match", "style", "successful", "details", "part", "product", "record", "manager", "response"], "e": ["ga", "v", "esi", "error", "ele", "one", "es", "ec", "ie", "g", "ception", "eu", "eb", "p", "ye", "ep", "ze", "f", "complete", "oe", "enter", "je", "ea", "er", "te", "u", "s", "c", "fe", "or", "en", "event", "pe", "b", "o", "ente", "l", "be", "de", "el", "err", "E", "entity", "y", "m", "t", "ae", "office", "it", "me", "ev", "exc", "none", "ffe", "ge", "end", "ee", "j", "element", "ite", "r", "eve", "n", "see", "line", "entry", "se", "d", "ne", "die", "ed", "ce", "le"], "myDate": [" myTime", " myDay", "anyDate", "anyYear", "anydate", "myDay", "MyDat", "MyDate", "yourTime", "yourYear", " myDat", "yourdate", " myYear", "MYDay", "myTime", "yourDate", "yourDay", "MYDate", "MYDat", "myYear", "myDat", "anyDat", "homeDate", "yourDat", "mydate", "homeDat", "homeTime", "MyDay", "MYTime", "homedate", "anyTime", "MyTime"], "time": ["ime", "id", "am", "times", "money", "host", "location", "name", "string", "Time", "length", "start", "tim", "image", "TIME", "price", "week", "year", "code", "rate", "type", "duration", "live", "text", "loc", "message", "date", "timeout", "depth", "data", "work", "clock", "value", "hour", "rice", "home", "timer", "size", "etime"], "tz": ["z", " offset", "UTC", " hour", " zone", " GMT", "tc", "Delta", "offset", "hh", " loc", " interval", "zone", "GMT", " zones", "Z", " locale", "loc", " clock", "Zone", "zz", "Clock", " schedule", "clock", " timestamp", "Timeout", "Offset", "hour", "etime"]}}
{"id1": "20623709", "id2": "4895903", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public List load(String sourceType, Object source, String param) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"load \" + source);\n        }\n        String location = null;\n        String type = null;\n        Object inputsource = null;\n        if (source instanceof DynamicMBean) {\n            sourceType = \"MbeansDescriptorsDynamicMBeanSource\";\n            inputsource = source;\n        } else if (source instanceof URL) {\n            URL url = (URL) source;\n            location = url.toString();\n            type = param;\n            inputsource = url.openStream();\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof File) {\n            location = ((File) source).getAbsolutePath();\n            inputsource = new FileInputStream((File) source);\n            type = param;\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof InputStream) {\n            type = param;\n            inputsource = source;\n        } else if (source instanceof Class) {\n            location = ((Class) source).getName();\n            type = param;\n            inputsource = source;\n            if (sourceType == null) {\n                sourceType = \"MbeansDescriptorsIntrospectionSource\";\n            }\n        }\n        if (sourceType == null) {\n            sourceType = \"MbeansDescriptorsDigesterSource\";\n        }\n        ModelerSource ds = getModelerSource(sourceType);\n        List mbeans = ds.loadDescriptors(this, location, type, inputsource);\n        return mbeans;\n    }\n", "label": 0, "substitutes": {"split": ["exec", "share", "delete", "parse", "Split", "transfer", "sort", "start", "archive", "set", "run", "build", "format", "join", "diff", "sync", "update", "add", "copy", "match", "append", "execute", "process", "init", "part", "open", "cmp"], "targetDirectory": ["destFile", "outputDir", "masterDirectory", "outputFolder", "currentDir", "destFolder", "destDir", "baseFolder", "targetDatabase", "targetFolder", "TargetFolder", "targetDir", " targetRoot", "targetFile", "TargetPath", "TargetDatabase", "baseDir", "masterPath", "TargetFile", " targetDir", "TargetRoot", " targetPath", "currentDirectory", "currentRoot", "basePath", "targetPath", "masterDir", " targetFile", "TargetDirectory", "currentFolder", "baseFile", "masterDatabase", "baseDirectory", "targetRoot", "currentPath", "outputDirectory", "TargetDir", "baseDatabase", "destDirectory", "outputFile", " targetFolder"], "prefix": ["first", "template", "fp", "prot", "base", "cache", "resolution", "pre", "path", "folder", "Pref", "index", "filename", "patch", "name", "string", "sequence", "offset", "pattern", "domain", "queue", "format", "username", "type", "root", "number", " suffix", "directory", "config", "padding", "uri", "timeout", "resource", "ix", "append", "fixed", "FIX", "fix", "unit", "txt", "temp"], "maxUnitBases": ["maxUnitAliasing", "maxUnitEases", "maxUnitEails", "maxUnitAliails", "maxUnitAliaches", "maxunitAliase", "maxUnitQuease", "maxunitAliasing", "maxUnitBase", "maxUnitQueases", "maxUnitEase", "maxUnitBails", "maxUnitBues", "maxUnitQueues", "maxUnitBaches", "maxUnitPlase", "maxunitBases", "maxunitAliails", "maxUnitPlaches", "maxUnitChases", "maxunitBues", "maxUnitChues", "maxUnitEaches", "maxunitBase", "maxUnitPlases", "maxUnitAliues", "maxUnitChasing", "maxunitAliaches", "maxunitBaches", "maxUnitAliase", "maxunitBasing", "maxUnitAliases", "maxunitBails", "maxunitAliases", "maxunitAliues", "maxUnitBasing", "maxUnitChase", "maxUnitPlails", "maxUnitQueasing"], "maxUnitEntries": ["maxUnitEntrys", "maxUnitOrdies", "maxUnitOrdresses", "maxUnitInties", "maxunitEntryresses", "maxUnitErries", "maxUnitErines", "maxLineEntries", "maxUnitOrdines", "maxUnitErry", "maxLineOrdrations", "maxUnitEntures", "maxunitEntryrys", "maxUnitCountines", "maxunitEntryies", "maxUnitOrdrys", "maxUnitEntryries", "maxUnitEntrations", "maxUnitIntries", "maxLineOrdries", "maxunitEntresses", "maxUnitEnties", "maxUnitAddries", "maxLineOrdry", "maxUnitOrdries", "maxUnitEntry", "maxUnitEntryry", "maxUnitAddry", "maxUnitAddresses", "maxUnitEntryures", "maxUnitOrdry", "maxUnitEntryresses", "maxLineEntry", "maxUnitAddures", "maxUnitCountrations", "maxLineEntines", "maxUnitEntryrys", "maxUnitCountry", "maxUnitIntrys", "maxUnitCountries", "maxunitEntries", "maxunitEnties", "maxUnitIntresses", "maxUnitEntines", "maxUnitOrdrations", "maxUnitEntresses", "maxunitEntrys", "maxunitEntryries", "maxUnitErrations", "maxLineEntrations", "maxUnitEntryies", "maxLineOrdines"], "fis": ["forisa", " fiss", "visa", "fris", " fIs", "Fisc", "fisc", "forisc", " fai", "Fris", " fisc", "vIs", "foris", " fisa", "fIs", "Fis", "vai", "forai", "Fiss", "vis", "fiss", "foriss", "forris", "fai", "forIs", " fris", "fisa"], "fci": ["vcos", "hci", "Fco", "Fai", " foci", "bis", " fai", " fii", "hco", "foci", "efcos", "bco", "efco", "Fis", "vai", "efai", "hai", "bci", "vco", "vci", "fii", "Foci", "bai", "efci", "dii", "fai", "dci", "Fci", "Fii", "doci", "hcos", "fcos", "dco"], "fos": ["foes", "tos", "tis", "ifo", "fsos", "toss", "foss", "infis", "Fos", "Fis", "ifios", " fo", "Foss", "fios", "Foes", "fsios", "infoes", "toes", "fscos", " fios", "ifcos", "fo", " fcos", "fso", "ifos", "infos", "infoss", "fcos"], "fco": ["fileco", "filebo", "hci", "dro", "Fco", "fileico", "Fico", "hgo", "lco", "fgo", "hco", "fbo", "lcos", "fro", "fico", "lro", " fbo", "lgo", "Fbo", "dcos", " fcos", "lci", " fro", "fileci", "dci", "Fci", " fico", "hcos", "fcos", "dco", " fgo"], "buffer": ["Buffer", "bc", "position", "result", "base", "header", "uffer", "reader", "cache", "window", "bin", "transfer", "pause", "comment", "view", "feed", "request", "border", "input", "length", "context", "binary", "offset", "memory", "queue", "image", "callback", "expression", "rate", "read", "layer", "writer", "info", "batch", "reference", "counter", "bar", "null", "buf", "block", "pad", "loader", "message", "iter", "resource", "timeout", "scale", "flush", "copy", "document", "translation", "data", "channel", "entry", "server", "source", "device", "capacity", "size", "zero", "buff", "response", "texture"], "currentBasesCount": ["currentBasingNum", "currentBaseCounter", "currentBatchescount", "currentChasescount", "currentChasesCount", "currentChasesCounter", "currentBasingCount", "currentBatchesCounter", "currentBasesCounter", "currentBatchesCount", "currentBatchesNum", "currentChasesNum", "currentChasecount", "currentBasingcount", "currentChaseCount", "currentBasescount", "currentBasingCounter", "currentBaseNum", "currentChaseNum", "currentBaseCount", "currentBasecount", "currentBasesNum", "currentChaseCounter"], "currentEntriesCount": ["currentAddriesSize", "currentEntursSize", "currentAddriesOffset", "currentEntursOffset", "currentEntursCount", "currentEntriesOffset", "currentEntriesLimit", "currentEnturesLimit", "currentAdduresSize", "currentEntrasSize", "currentEnturesSize", "currentEntriesSize", "currentEnturesCount", "currentEnturesOffset", "currentAddriesCount", "currentAdduresCount", "currentEntrasOffset", "currentAdduresOffset", "currentAdduresLimit", "currentEntrasCount", "currentEntrasLimit", "currentEntursLimit", "currentAddriesLimit"], "targetCount": ["argetCount", "targetSize", "TargetSize", "patternSize", "targetSum", "argetSum", "argetSize", "patterncount", "targetcount", "TargetSum", "TargetCount", "argetcount", "patternCount", "Targetcount", "patternSum"], "fastaChannel": [" fastABuffer", " fastaConnection", " fastAConnection", "fastanBuffer", "fastAContainer", "fastasChannel", "fastAColumn", "fastasColumn", "fastasContext", "fastasConnection", "fastanContainer", " fastaContainer", "fastaqColumn", "fastasBuffer", "fastanContext", "fastAChannel", "fastaqChannel", " fastaColumn", " fastAChannel", "fastAContext", "fastanChannel", "fastaqConnection", " fastaContext", "fastasContainer", "fastaConnection", " fastAContainer", "fastABuffer", "fastaqBuffer", " fastAColumn", "fastaContainer", " fastAContext", "fastaContext", "fastaColumn", "fastAConnection"], "totalSeqCount": ["totalQueqCount", "totalSeQCounter", "totalSeQNum", "totalSeQCount", "totalSeqsNum", "totalQueQCounter", "totalSeqcount", "totalSeuxCounter", "totalQueQcount", "totalSeuxCount", "totalSeqsCount", "totalSeqsCounter", "totalSeqscount", "totalQueQNum", "totalQueqCounter", "totalSeqNum", "totalSeQcount", "totalQueqcount", "totalQueqNum", "totalQueQCount", "totalSeuxNum", "totalSeuxcount", "totalSeqCounter"], "totalResiduesCount": ["totalResiduingCount", "totalResiduationNum", "totalResiduescount", "totalResqueuresSize", "totalResqueuesNum", "totalResiduingcount", "totalResiduationcount", "totalResqueuresCount", "totalResqueuesCount", "totalResiduationSize", "totalResiduationCount", "totalResiduresNum", "totalResiduingNum", "totalResiduesNum", "totalResiduingSize", "totalResidurescount", "totalResiduesSize", "totalResqueuesSize", "totalResqueuresNum", "totalResqueuescount", "totalResiduresCount", "totalResqueurescount", "totalResiduresSize"], "prevTime": ["commitFile", " prevFile", "PrevSize", "PrevValue", " prevSize", "commitTime", "PrevTime", "PrevFile", "prevSize", "commitValue", " prevValue", "commitSize", "prevFile", "prevValue"], "fastaFileSize": ["fastaFileAddress", "fastaLineAddress", "fastaFilesSize", "fastABufferCount", "fastasFileAddress", "fastaFilesLength", "fastaPageName", "fastaBufferLength", "fastaFilesAddress", "fastaBlockSize", "fastasFileLength", "fastAFileSize", "fastaLineLength", "fastaFilesName", "fastaFileCount", "fastaBufferAddress", "fastaPageLength", "fastABufferLength", "fastaBlockLength", "fastaLineCount", "fastaFileLength", "fastasHeaderLength", "fastaBlockAddress", "fastABufferAddress", "fastasFileSize", "fastaFileName", "fastAFileLength", "fastaBlockCount", "fastasHeaderAddress", "fastaBufferCount", "fastasHeaderName", "fastaPageAddress", "fastaHeaderAddress", "fastasFileName", "fastaHeaderName", "fastaLineSize", "fastAFileCount", "fastaHeaderSize", "fastaBufferSize", "fastAFileAddress", "fastABufferSize", "fastaHeaderLength", "fastaPageSize", "fastasHeaderSize"], "fastaFileReadOffset": ["fastaFilesWriteoffset", "fastaFileWriteEntry", "fastaDirectoryWriteEntry", "fastaFileLengthOffset", "fastaFileLengthOff", "fastaFileRunoffset", "fastaFileRunOff", "fastaFileReadoffset", "fastaBufferWriteoffset", "fastaFileWriteoffset", "fastaFileRunEntry", "fastaDirectoryReadOff", "fastaFileLoadLength", "fastaDirectoryWriteoffset", "fastaBufferReadoffset", "fastaFilereadOff", "fastaBufferReadAmount", "fastaFileReadAmount", "fastaFilesWriteOffset", "fastaFileLoadoffset", "fastaFilesReadOff", "fastaBufferWriteAmount", "fastaBufferWriteOffset", "fastaDirectoryWriteOff", "fastaBufferWriteLength", "fastaFilesReadLength", "fastaFileStartoffset", "fastaFileLengthoffset", "fastaFileWriteOffset", "fastaFileReadOff", "fastaDirectoryWriteOffset", "fastaDirectoryReadOffset", "fastaBufferReadOffset", "fastaFileWriteOff", "fastaFileReadEntry", "fastaFileLengthLength", "fastaFilesWriteOff", "fastaFilesWriteLength", "fastaFileStartEntry", "fastaDirectoryReadoffset", "fastaFileWriteAmount", "fastaFileWriteLength", "fastaFilesReadoffset", "fastaFilereadoffset", "fastaFileStartOffset", "fastaFileReadLength", "fastaFileRunOffset", "fastaDirectoryReadEntry", "fastaFilereadLength", "fastaFileLengthAmount", "fastaFileLoadAmount", "fastaFileLoadOffset", "fastaBufferReadLength", "fastaFilereadOffset", "fastaFileStartOff", "fastaFilesReadOffset"], "partitionStartOffset": ["partitionStartOrder", "partitionsEndOrder", "partitionStopOff", "partitionsStartOff", "partitionBufferOrder", "partitionBufferOffset", "partitionStartRange", "partitionStopOffset", "partitionEndOff", "partitionsEndOffset", "partitionsEndOff", "partitionsStartOrder", "partitionStopRange", "partitionStopOrder", "partitionStartOff", "partitionBufferOff", "partitionsStartOffset", "partitionsEndRange", "partitionEndOrder", "partitionEndRange", "partitionsStartRange", "partitionBufferRange"], "bufferSize": ["BufferC", "BufferSIZE", " bufferType", "BufferType", "bufferC", "queueSize", "processType", "bufferCount", " bufferSIZE", " bufferCount", "BufferCount", "bufferSIZE", "processC", "BufferSize", "processSIZE", "processSize", "queueCount", "bufferType", " bufferC"], "fastaBuffer": [" fastABuffer", "fastanFile", "fastasBuff", "fastanPtr", "fastanBuffer", "fastAContainer", "fastasChannel", " fastasContainer", "fastaQueue", "fastasQueue", " fastasFile", "fastasPtr", "fastanBuff", "fastaceBuffer", "FastasChannel", "fastaStream", "fastaaPtr", "FastaStream", "fastaFile", "fastanContainer", "FastaBuffer", "FastaBuff", "FastaChannel", "FastasStream", " fastaContainer", "fastasStream", "fastaaBuff", " fastABuff", "FastasBuffer", "fastasBuffer", "fastanStream", "fastAChannel", "FastasPtr", " fastaBuff", "fastanQueue", "fastaaStream", " fastAChannel", "fastanChannel", "fastaPtr", "fastaaBuffer", "fastasContainer", "fastAQueue", " fastasChannel", "fastAFile", " fastAFile", " fastAQueue", "fastABuff", "fastABuffer", " fastasBuffer", "fastaBuff", "fastacePtr", "FastasBuff", "fastaceChannel", " fastaQueue", "fastasFile", "fastaContainer", "FastaPtr", "fastAPtr", "fastaceBuff", " fastaFile"], "fastaReadState": ["fastasReaderState", "fastasReaderType", "fastaReadingState", "fastaReaderstate", "fastaReadstate", "fastaFileMode", "fastaReadType", "fastaReaderType", "fastaFileType", "fastaReadingType", "fastasReadType", "fastasReaderstate", "fastaReadingstate", "fastasReadstate", "fastasReadMode", "fastaReaderMode", "fastaFilestate", "fastaReadingMode", "fastaReadMode", "fastasReadState", "fastaFileState", "fastasReaderMode", "fastaReaderState"], "nBytes": ["pBytes", "nFrames", "lenbytes", "nbytes", "numFrames", "NBytes", "oFiles", "lenBytes", "oBytes", "nFiles", "NFiles", " nbytes", "NParts", "NByte", " nParts", "pParts", "pByte", "nByte", "pbytes", " nByte", "lenFrames", " nFrames", "lenFiles", "nParts", "numFiles", " nFiles", "oParts", "Nbytes", "numbytes", "numBytes", "obytes"]}}
{"id1": "13152325", "id2": "293167", "code1": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"loadExistingAntlibs": ["loadExistingAntLibes", "loadExistingAntLIBb", "loadExistingantlibb", "loadExistingantlibz", "loadExistingAntlibz", "loadExistingAntLibs", "loadExistingAntilibs", "loadExistingAntLIBs", "loadExistingAntilibes", "loadExistingAntLIBz", "loadExistingAntLIBes", "loadExistingantLibs", "loadExistingAntlibb", "loadExistingantLibes", "loadExistingantLibz", "loadExistingAntilibz", "loadExistingAntLibb", "loadExistingantLibb", "loadExistingAntlibes", "loadExistingAntLibz", "loadExistingantlibes", "loadExistingAntilibb", "loadExistingantlibs"], "classLoader": ["sourceLoader", " classContainer", "CLASSLoading", "sourceLine", "constLoading", "CLASSContainer", " classloader", " classUrl", "classLoading", "sourceLoading", "constLoader", "classUrl", "ClassLine", "constUrl", "ClassLoading", "constloader", "Classloader", " classLine", "ClassUrl", "ClassContainer", "ClassLoader", "classloader", "CLASSLoader", "sourceloader", " classLoading", "classLine", "CLASSloader", "classContainer"], "antlibUrl": ["ntLibJar", "artlibraryAddress", "antLibJar", "antlrUrl", "antlibLocation", "ntlibLocation", "ntlibURL", "antLibURL", "ntLibUr", "antlibraryURL", "antibJar", "antibURI", "antslUrl", "antLibUr", "antlabServer", "antlibURI", "antibUr", "artlibraryJar", "ntlibURI", "artlibServer", "antLibURI", "antliServer", "antlabUrl", "antlibAddress", "antlibraryUrl", "antlibServer", "antlibraryAddress", "artlibAddress", "antlabJar", "artlibUrl", "antlabAddress", "antslURI", "ntLibUrl", "ntlibJar", "artlibraryServer", "antLibLocation", "antLibUrl", "antlrJar", "antslUr", "antlibUr", "antliJar", "ntLibLocation", "antlibJar", "antlrLocation", "ntLibURI", "antlrURL", "antlibURL", "artlibJar", "antliUrl", "antlibraryJar", "ntlibUrl", "ntLibURL", "antlibraryServer", "ntlibUr", "artlibraryUrl", "antliAddress", "antslJar", "antlibraryLocation", "antibUrl"], "antlibUri": ["antlabUrrio", "antlibUsRI", "antlabUio", "antlibURI", "antlibraryUri", "antlibEri", "antlibraryAro", "antlibraryUric", "antlibUsrio", "antlabUris", "antlibOris", "antlibUsro", "antlibFileris", "antlibUtri", "antliUris", "antlibraryUro", "antlibFli", "antlibraryFileris", "antliOli", "antlibUrris", "antlibFileri", "antlibOpi", "antlibOri", "antlabUrri", "antlibAris", "antlibAio", "antlibEric", "antlibraryUsric", "antlibraryArio", "antlabUrris", "antlibAro", "antlibraryFileri", "antlibIro", "antlibUtRI", "antlibUsio", "antlibIri", "antlibraryUrio", "antlibCro", "antlibArio", "antlibUsris", "antlibUli", "antlibCri", "antlibraryFilero", "antlibCric", "antlibUpi", "antlibEro", "antlibraryUsro", "antlibraryUsRI", "antlibFileRI", "antlibIris", "antliOri", "antlibraryFileRI", "antlibraryUsri", "antlibraryURI", "antlibUtro", "antlibFris", "antliUri", "antlibUrri", "antlabUrio", "antlibUris", "antlibFpi", "antlibUrio", "antliUli", "antliUpi", "antlibUro", "antlibFri", "antliOris", "antlibERI", "antlibraryARI", "antlibARI", "antlibUsric", "antlibUtrio", "antlibUspi", "antlabUri", "antlibFilero", "antlibIRI", "antlibOli", "antlibUric", "antlibUrrio", "antlibraryAri", "antliOpi", "antlibUsli", "antlibAri", "antlibCRI", "antlibUio", "antlibUsri", "antlibraryUris"], "resources": ["objects", "relations", "classes", "types", "groups", "packages", "roots", "archives", "ids", "multiple", "reports", "rs", "times", "users", "res", "parents", "maps", "lines", "results", "ruby", "files", "rt", "strings", "errors", "items", "rows", "plugins", "ources", "loader", "events", "apps", "media", "resource", "bytes", "http", "pages", "source", "Resources", "thumbnails", "ries", "details", "collection", "rules", "features"], "url": ["ource", "address", "base", "str", "id", "feed", "io", "URL", "zip", "jar", "path", "xml", "plugin", "sl", "Url", "host", "location", "string", "name", "li", "image", "link", "layer", "ssl", "element", "connection", "r", "user", "route", "root", "ll", "config", "loc", "loader", "ri", "ur", "buffer", "lr", "resource", "service", "key", "http", "l", "page", "source", "file", "server", "data", "download", "addr", "coll", "f"], "stream": ["v", "client", "system", "clean", "view", "e", "port", "feed", "io", "zip", "model", "path", "sl", "input", "er", "host", "out", "string", "context", "driver", "serial", "Stream", "read", "or", "ssl", "writer", "r", "user", "transform", "video", "body", "handler", "per", "slice", "socket", "loader", "buffer", "parser", "resource", "form", "document", "http", "in", "source", "data", "file", "channel", "server", "pool", "filter", "coll", "f", "response"], "reader": ["result", "parse", "e", "feed", "io", "rr", "worker", "xml", "rer", "ler", "row", "er", "input", "driver", "err", "editor", "read", "Reader", "or", "bird", "layer", "writer", "i", "r", "connection", "rx", "library", "handler", "oder", "per", "loader", "ner", "ri", "parser", "iter", "buffer", "resource", "iterator", "http", "in", "ry", "entry", "server", "file", "source", "rar", "reading", "f"], "line": ["lc", "base", "header", "ip", "job", "str", "parse", "el", "e", "raw", "log", "le", "val", "sl", "row", "nl", "plugin", "string", "name", "li", "Line", "end", "lines", "word", "range", "write", "err", "code", "LINE", "read", "element", "info", "r", "pe", "user", "text", "rule", "o", "sync", "block", "resource", "key", "non", "lf", "page", "lin", "source", "file", "data", "l", "entry", "letter", "inline", "pass", "liner", "part", "cell"], "pkg": ["fp", "lc", "prot", "base", "ip", "alias", "packages", "dep", "parse", "dp", "zip", "jar", "po", "git", "path", "plugin", "filename", "patch", "string", "cp", "cmd", "spec", "prefix", "comp", "rpm", "lib", "type", "info", "ph", "class", "gp", "ppa", "root", "loc", "install", "loader", "lang", "pack", "kg", "resource", "p", "wd", "qa", "file", "dir", "password", "req", "src", "pp", "Package", "plug", "cmp", "module"], "uri": ["address", "base", "util", "io", "URL", "iri", "proxy", "path", "plugin", "string", "li", "ui", " URI", "uni", "anti", "ci", "database", "lib", "i", "root", "ri", "service", "api", "resource", "URI", "http", "cli", "source", "entry", "file", "server", "uid", "collection", "pi"], "resource2antlib": ["resource2ntibl", "resource5antLib", "resource2ntlib", "resource2ctlib", "resource2antslib", "resourceSecondatibl", "resource2ctlab", "resource2rtLib", "resource4ntlibrary", "resource4antlab", "resource2ntlibrary", "resource2antLib", "resource2antlibrary", "resource2rtrib", "resource2ntl", "resource4ntlab", "resource2antlab", "resource2ntLib", "resource5antlibrary", "resourceSecondantibl", "resource4antlibrary", "resource4antLib", "resource4antlib", "resourceSecondantrib", "resourceSecondantLib", "resource2aptlibrary", "resourceSecondatrib", "resource2ctlibrary", "resource5antslib", "resourceSecondatLib", "resource2artlib", "resource2artLib", "resource2antrib", "resource2ctLib", "resource2atLib", "resource5antslibrary", "resource2antsLib", "resource2atlib", "resource2atrib", "resource2aptlib", "resource2artlab", "resource2aptLib", "resource2artlibrary", "resource2rtlib", "resource2ntrib", "resource2antibl", "resourceSecondatlib", "resource5antlib", "resource2antl", "resource4ntlib", "resource4ntLib", "resource2ntlab", "resource2antsl", "resource5antsLib", "resource5antsl", "resource2antslibrary", "resource2atibl", "resource5antl", "resourceSecondantlib", "resource2aptl", "resource2rtibl"]}}
{"id1": "8452134", "id2": "310182", "code1": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"exists": ["xist", "resist", "exist", "esist", "actisting", "Existing", "resisting", "resists", "actistent", "esisting", "Existent", "xits", "Exist", "existing", "existent", "esists", "xists", "exits", "xisting", "Exists", "Exits", "actists", "resits", "esistent", "actist"], "fileToCheck": ["filetocheck", "entryTocheck", "stringToTest", "entryToChe", "entryTOChe", "fileTOChe", "entryTOcheck", "fileToChe", "fileToTest", "fileTOCheck", "filetoTest", "filetoChe", "fileTocheck", "entryToCheck", "entryTOCheck", "entryTOTest", "stringToCheck", "fileTOcheck", "filetoCheck", "stringTocheck", "entryToTest", "fileTOTest"], "ftp": ["fftp", "mailpc", "lfps", "oftp", "uft", "ntp", " fta", "ftip", "uffp", "ftfp", " ftpb", "lfp", "FTap", "alttp", "aftpc", " ftpa", " ftb", "FTps", "lftp", " ftt", "ctp", "rtp", "tta", "ftpc", "mailp", "ftap", "rta", "afttp", "fp", "ftw", "nta", "ufp", "ftpb", " ftcp", "ftb", "ftpo", "ft", "ttcp", "fta", "ftbr", "uttp", "ftsp", "cfps", "ffpo", "fcp", "ctpo", "altpc", "ufcp", "ttp", "ktpc", "oftip", "aftp", " ftw", " ftip", "aftcp", " ftpo", "utpc", "rtpc", "cftp", "htip", "cttp", "ntcp", "ftcp", "ctcp", "ffp", "mailtp", "ktp", "ftsps", "kta", "fpc", " ftap", "ffcp", "fttp", " fttp", " ftpc", "altw", "utp", "htpa", " ftfp", "utw", "htp", "htbr", "ftps", "ftpa", "ttps", "ntps", "altp", "ftsb", "rtpb", " ftps", "oftbr", "mailcp", "ktpb", "FTb", "oftpa", "FTp", "cfpo", "ftsap", "ftt", "cfp", " ftbr", "lfpo"], "found": ["first", "defined", "result", "error", "received", "local", "updated", "finder", "left", "connected", "valid", "old", "default", "index", "fl", "flat", "val", "length", "locked", "Found", "bug", "given", "ret", "err", "success", "len", "failed", "read", "checked", "all", "confirmed", "count", "used", "active", "find", "built", "nt", "good", "iter", "loaded", "broken", "search", "fd", "finding", "l", "fixed", "pos", "successful", "full", "f", "sent", "expected", "response"], "reply": ["address", "result", "base", "error", "send", "received", " response", "status", "call", "answer", "comment", "force", "rr", "request", "index", "length", "next", "err", "len", "write", "link", "bot", "prefix", "code", "respond", "read", "reason", "repl", "info", "connection", "report", "Reply", "text", "echo", "query", "sync", "post", "message", "ply", "buffer", "service", "dy", "lying", "match", "resp", "continue", "server", "cause", "data", " replies", " replied", "part", "sent", "zero", "response"]}}
{"id1": "8588992", "id2": "823074", "code1": "    public ActionForward perform(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String status = null;\n        HttpSession session = request.getSession();\n        ReportingBean reportingBean = null;\n        NewConceptBean conceptBean = null;\n        String conceptName = null;\n        String primitive = null;\n        MessageResources errorMessages = MessageResources.getMessageResources(\"com.apelon.apps.dts.treebrowser.resources.error_messages\");\n        LogonUtilities logonUtilities = new LogonUtilities();\n        if (logonUtilities.checkSession(session, status, reportingBean, errorMessages)) {\n            reportingBean = (ReportingBean) session.getAttribute(\"reportingBean\");\n            if ((reportingBean.getMessageHtml().indexOf(\"Classify\")) == -1) {\n                reportingBean.setReportingHtml(\"\");\n            }\n            conceptBean = (NewConceptBean) session.getAttribute(\"newConceptEntity\");\n            conceptName = request.getParameter(\"conceptName\");\n            primitive = request.getParameter(\"primitive\");\n            if (primitive == null) {\n                primitive = \"false\";\n            }\n            conceptBean.setConceptName(conceptName);\n            conceptBean.setPrimitive(primitive);\n            String namespace = conceptBean.getConceptNamespace();\n            if (namespace == null) {\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_3\"));\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n                return (mapping.findForward(status));\n            }\n            String[] roleMods = request.getParameterValues(\"some_or_all\");\n            String[] roleGrps = request.getParameterValues(\"role_group\");\n            Vector roles = conceptBean.getRoles();\n            RoleBean[] roleCons = new RoleBean[roles.size()];\n            roles.copyInto(roleCons);\n            if (roleMods != null && roleGrps != null && roleCons != null) {\n                if (roleCons.length == roleMods.length && roleCons.length == roleGrps.length) {\n                    for (int i = 0; i < roleCons.length; i++) {\n                        roleCons[i].setSomeOrAll(roleMods[i]);\n                        roleCons[i].setRoleGroup(roleGrps[i]);\n                    }\n                }\n            }\n            session.setAttribute(\"newConceptEntity\", conceptBean);\n            NewConceptXMLDisplayBean xmlBean = new NewConceptXMLDisplayBean();\n            xmlBean.setNewConceptXml(conceptBean);\n            String data = BrowserUtilities.encodeUrl(\"conceptXml\") + \"=\" + BrowserUtilities.encodeUrl(xmlBean.getNewConceptXml()) + \"&\" + BrowserUtilities.encodeUrl(\"nameSpace\") + \"=\" + BrowserUtilities.encodeUrl(namespace);\n            XMLPropertyHandler configPh = new XMLPropertyHandler(\"dtsbrowserclassify.xml\");\n            Properties configProps = configPh.getProps();\n            String urlString = configProps.getProperty(\"url\");\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuffer buf = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                buf.append(line);\n            }\n            String resultXml = buf.toString();\n            wr.close();\n            rd.close();\n            ClassifiedConceptBean ccBean = new ClassifiedConceptBean();\n            ClassifyResultParser parser = new ClassifyResultParser(resultXml);\n            ResultBuilder rbuilder = new ResultBuilder();\n            rbuilder.setConceptBean(ccBean);\n            rbuilder.setParser(parser);\n            rbuilder.setNamespace(namespace);\n            try {\n                rbuilder.buildResult();\n                ccBean = rbuilder.getConceptBean();\n                ClassifiedConceptDisplayBean displayBean = new ClassifiedConceptDisplayBean();\n                displayBean.setNewConceptHtml(ccBean);\n                session.setAttribute(\"classifyResult\", ccBean);\n                session.setAttribute(\"classifyDisplayResult\", displayBean);\n                status = \"success\";\n            } catch (Exception e) {\n                Categories.dataServer().error(StackTracePrinter.getStackTrace(e));\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_1\") + e.getMessage());\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n            }\n        }\n        return (mapping.findForward(status));\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"perform": ["consubmit", "persubmit", "conroute", "tosubmit", "perroute", "overform", "oversubmit", "conflow", "toflow", "perflow", "toform", "overroute", "overflow", "toroute", "conform"], "mapping": ["tmapping", "rmapper", "smappings", " matching", "tmapper", "mappings", "smapper", " migration", "mailing", "tmatching", " mapper", "matching", "ormigration", "smailing", "ormatching", "rmappings", "Mapper", "Mailing", "ormapping", "migration", "Mappings", "mapper", "smapping", "Mapping", "tmigration", "ormapper", "rmapping", "rmailing"], "form": ["flow", "template", "change", "view", "app", "controller", "model", "command", "path", "forms", " forms", "stream", "Form", "format", "method", "report", "transform", "route", "object", "config", "update", "submit", " submission", "page", "process", " transform", "control", "f"], "request": ["complete", "position", "result", "client", "project", "enter", "re", "view", "QUEST", "use", "current", "child", "model", "path", "xml", "remote", "input", "q", "name", "context", "queue", "image", "event", "report", "method", "user", "application", "route", "object", "join", "query", "press", "post", "message", "resource", "version", "condition", "Request", "document", "submit", "page", "server", "subject", "req", "instance", "create", "frame", "initial", "record"], "response": ["result", "client", "re", "view", "output", "model", "Response", "xml", "res", "report", "method", "application", "object", " Response", "message", "resource", "api", "page", "resp", "server", "reply", "json", "manager"], "status": ["complete", "score", "result", "error", "stat", "Status", "description", "login", "str", "output", "site", "exit", "id", "security", "current", "model", "sort", "xml", "uses", "index", "host", "string", "stats", "state", "name", "action", "prefix", "success", "spec", "step", "code", "reason", "type", "ssl", "notice", "method", "html", "wait", "speed", "sync", "edit", "update", "message", "service", "version", "icon", "date", "source", "server", "subject", " Status", "stage", "warning", "STAT", "json", "msg", "settings"], "session": ["su", "result", "Session", "client", "account", "token", "cache", "local", "scope", "view", "site", "use", "port", "ESSION", "security", "child", "container", "shell", "ess", "input", "temp", "connect", "context", "state", "s", "host", "language", "thread", "image", "lock", "set", "sa", "entity", "sb", "connection", "batch", "user", "application", "gui", "task", "query", "socket", "message", "service", "resource", "api", "mission", "condition", "document", "search", "http", "cookie", "source", "process", "se", "server", "subject", " Session", "ession", "group", "sp", "statement", "manager", "settings"], "reportingBean": ["reportingGuane", "sharingBeean", " reportingBea", "gettingBeoin", "trainingBEbean", "reportingBebean", "reportingBroada", " reportingBoane", " reportingBebean", "reportingBoann", "trainingBeam", "reportingTean", "reportingRoam", "reportingBeam", "trainingBeean", "ReportingBeanned", "reportingCodebean", "gettingBEa", "gettingBEoin", "reportingBoan", "reportingBeean", "sharingBEbean", "ReportingBeean", "gettingBeane", "trainingBEam", "reportingBoa", "ReportingBane", "ReportingBanned", "reportingCodeean", "reportingBEa", "sharingBEean", " reportingBoan", " reportingRobean", "reportingBEan", "ReportingBean", "sharingBebean", "reportingMeean", "reportingBeanc", "ReportingBan", "reportingBleam", " reportingRoan", "reportingBleanan", "sharingBEan", "reportingBea", "sharingBEanc", "reportingBroadan", " reportingBeane", " reportingRoean", "reportingBEanc", "reportingTebean", "trainingBEan", "reportingBbean", "reportingBEoin", "reportingRoanan", "reportingBoean", "trainingBeanc", "reportingTeanc", "reportingGuean", "reportingMean", "reportingBeanned", "reportingGuan", "reportingGuanned", "reportingBoane", "ReportingBeane", "sharingBeanc", "reportingBan", "reportingBroadane", "reportingBooin", " reportingBoann", "reportingBanned", "reportingBlean", "trainingBEann", "reportingBeoin", "trainingBeann", "reportingBEanan", "reportingBEbean", "reportingBanc", "gettingBea", "reportingBeanan", "reportingBEane", " reportingBeann", " reportingRoa", "reportingMea", "reportingBroadoin", "reportingBane", "reportingBEann", "reportingRoean", "reportingBleann", " reportingBeean", "trainingBEean", "reportingRoann", "reportingBoanned", "reportingBeane", "trainingBEanan", "gettingBEane", "reportingRobean", "reportingRoanc", "reportingBEean", "gettingBean", "reportingBEam", "trainingBEanc", "trainingBeanan", "sharingBean", "trainingBean", "reportingRoa", "reportingMebean", "reportingCodeanc", " reportingBoean", "reportingRoan", "reportingBeann", "gettingBEan", "trainingBebean", "reportingCodean", "reportingBann", "reportingTeean"], "conceptBean": [" conceptBan", "conceptClanc", "conceptTeean", "conceptBebean", "conceptModelans", "conceptTean", "projectBeane", "contactBEanc", "conceptFeann", "contractBean", "conceptBoaning", "conceptBa", "contractBeean", "conceptPegan", "conceptTeane", "conceptBegan", "projectBean", "conceptBein", "contractBEean", "conceptEla", "conceptBeann", "reportTeean", "conceptBlen", "conceptBEans", "conceptBane", " conceptBebean", "conceptClan", "reportBean", "conceptBea", "conceptPea", "conceptBlann", "reportTean", "reportBeean", "conceptElean", "conceptClean", "conceptEans", "conceptTeaning", "conceptPean", "conceptBeaning", " conceptFebean", "conceptBEgan", "conceptFeen", "projectBEn", "conceptBbean", " conceptFeen", "contractBEan", "reportBeaning", "conceptEan", "conceptEn", "projectBEans", "conceptEean", "conceptBan", "contractBegan", "conceptElgan", "conceptBeean", "conceptBen", " conceptBane", "contactBein", "conceptModelan", "conceptBlbean", "conceptBeans", "contractBEgan", "contactBEan", "conceptPlean", "conceptElan", " conceptBeann", "conceptBlan", "conceptPlanc", "projectBEane", "projectBeans", " conceptBeen", " conceptBeane", "contactBean", "conceptPeean", "conceptPlin", "contactBEin", "projectBen", " conceptBea", "conceptEane", "contactBeean", "conceptBeen", "conceptBEn", "conceptEa", "conceptPlan", "conceptModelane", "conceptBEean", " conceptBeean", "conceptBEanc", "conceptBEin", "reportTeane", "contactBEean", "conceptBeanc", " conceptFeann", " conceptBa", "contactBeanc", "conceptFean", "projectBEan", "conceptBeane", "conceptFebean", " conceptFean", "conceptBoan", "reportBeane", "conceptBEane", "conceptBEaning", "conceptBoane", "conceptBoean", "conceptBEa", "conceptClin", "conceptBEan", "conceptBann", "conceptModeln", "reportTeaning", "contractBEa", "contractBea"], "conceptName": ["conceptname", " conceptname", " conceptNames", "clientname", " conceptType", "ceptType", "contextType", "ceptname", "conceptType", "conceptNames", "contextname", "contextName", "ceptName", " conceptUnit", "conceptUnit", "contextNAME", " conceptNAME", "ceptUnit", "clientNAME", "clientName", "contextNames", "contextUnit", "ceptNames", "conceptNAME"], "primitive": ["Primitives", "necessitive", "perity", "primical", "Primue", "peritives", "primifier", "primitiveness", "primity", " primifier", "transifier", "quantitive", "Primifier", "quantue", "peritive", "Primitivity", "Primient", "Primitive", "quantitiveness", "transitive", "necessitives", "perical", "penitives", "primitives", "necessity", "penity", "penitive", " primitivity", "penical", "quantity", "Primical", " primity", "primitivity", "quantitives", "transitivity", "perient", "necessitiveness", "Primity", "penient", "transue", "Primitiveness", " primitiveness", "primue", " primue", "primient"], "errorMessages": [" errorMessags", "errormessrors", "errorMessains", "errorMags", "errorMains", "errorScags", " errorMessrors", " errorBodes", " errormessags", " errorBagers", " errorChrors", "errorMagers", " errorMessings", "errorChages", "errorScains", "errorMessrors", " errorMessodes", " errorMessagers", " errormessains", "errorChings", "errorMessags", "errorBages", "errormessings", "errorBodes", "errorScages", "errorBags", "errormessages", "errorMessagers", "errorErags", " errorChages", "errorErings", "errormessagers", "errormessags", "errorMessings", " errorChags", "errorMessodes", "errorBagers", " errorMessains", " errorChings", " errorBags", "errorChags", "errorMages", "errormessains", "errorScagers", "errorChrors", "errorErrors", "errorErages", "errorChodes", " errorBages", "errorChagers", " errormessages", "errormessodes", " errormessagers"], "logonUtilities": [" logonutils", "logonutiles", "logonFacility", " logonutility", "logonUtiles", "logonFacilities", "logronUtilities", " logonMutility", " logonMutils", " logonUtil", "logronutiles", "logonIntilities", "logonUtility", " logonsUtil", " logonsutilities", "logonutility", " logonTil", " logonsutils", " logonMutil", "logonIntiles", "logronutilities", "logonutilities", " logonsUtils", " logonTils", " logonutilities", "logronutils", "logonIntility", "logronutility", "logonUtils", " logonTilities", " logonTility", " logonMutilities", "logronUtiles", "logonFacils", "logronUtils", " logonutil", " logonsUtilities", " logonUtils", " logonsutility", " logonUtility", "logonutils", "logonFaciles", " logonsutil", "logronUtility", "logonIntils", " logonsUtility"], "namespace": ["insename", "Namesig", "inspaced", "nameships", "nspaces", "namespaced", "ships", "nspace", "nsename", "space", "inspace", "namespaces", "Namespaces", "relationspace", "namesename", "relationspaced", "Nameships", "relationspaces", "conspace", "Namespace", "consig", "relationsename", "spaces", "namesig", "inspaces", "conspaces", "nspaced", "conships", "sig"], "roleMods": ["RoleOps", "roleMod", "oleMods", "oleComm", " roleMod", "relationComm", "roleMOD", "RoleMods", " roleOps", "relationMOD", " roleMOD", "relationMods", "RoleMod", "oleMOD", " roleComm", "roleOps", "relationMod", "oleOps", "oleMod", "roleComm"], "roleGrps": ["roleArPs", "roleGps", "roleGrples", " roleChpes", " roleChps", " roleGrp", "rolegrPS", " roleGples", "roleGrp", " roleGps", "roleGrPS", " roleChPS", "roleGrpes", "rolegrps", "roleChps", "roleChPS", "roleArples", "rolegrpes", " roleGrpes", "roleCorPs", "roleCorples", " roleGPs", "roleGPs", "roleGples", "roleGrPs", " roleGrPS", " roleGrples", "roleArp", "roleDroPS", "roleArps", "roleCorps", "rolegrPs", "roleDroPs", " roleChPs", " roleGrPs", "roleDropes", " roleGp", "roleDrops", "roleChPs", "roleGp", "roleCorp", "roleChpes"], "roles": ["proels", "rolls", "rooles", "rolele", "coels", "rolels", "rolules", "rololes", "roleels", "rolle", "rels", "roleoles", "rles", "role", "prols", "rols", "rle", "roules", "prooles", "coles", "roleles", "roels", "rolles", "roleules", "proles", "cooles", "coules"], "roleCons": ["rolCont", " rolecons", "rolCons", "rulecons", "roleMembers", "oleMembers", " roleIns", "rolcons", " roleCont", "ruleContin", "ruleIns", "ruleMembers", "ruleCons", "rolMods", "roleContin", "rolecons", "olecons", " roleContin", "rolMembers", "roleIns", "ruleMods", "oleCons", "ruleCont", "oleContin", " roleMembers", "rolIns", "roleCont"]}}
{"id1": "16466743", "id2": "9826240", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"getmd5": ["getmd6", "getmn5", " getMD12", "getmd12", " getmd6", "getmetadata6", "getmd512", " getMD5", "getmn512", "getmetadata5", "getmetadata512", "getMD5", "getmn6", "getMD12", "getmetadata12", " getMD6", " getmd12", "getMD512", " getmd512", " getMD512", "getmn12", "getMD6"], "password": ["hash", "address", "encrypted", "account", "token", "Password", "login", "sword", "path", "input", "pattern", "string", "name", "word", "prefix", "auth", " Password", "words", "username", "crypt", "number", "text", "config", "pad", "padding", "message", "buffer", "attribute", "array", "p", " passwords", "key", "wd", "phrase", "data", "PASS", "secret", "email", "pass", "f"], "pwHash": ["PWSum", "pwhMac", "pwhash", "PwSum", "pxMac", "qxSum", "pwaHash", "pwMac", "pwdDig", "PWHash", "qwSum", " pwSum", "pwdSum", "PWMac", "pweHash", "pwehash", "pwdMac", "pwaSum", "pwaMac", "pwdHash", "pWMac", "pwBlock", "pwtMac", "pwhBlock", "pwSum", "pWSum", " pwaSum", "qxDig", "qxHash", "pxDig", "qxMac", "pWHash", "qwMac", "pwaDig", "pxHash", "PwHash", "pwdhash", "pwahash", " pwDig", "pwtBlock", " pwaHash", "pxSum", "PwMac", "pWBlock", "pwDig", " pwahash", "PWBlock", "pwhHash", "pwtSum", " pwaDig", " pwhash", "pwhSum", "qwHash", "pweSum", "pwtHash", "PwBlock", "qwDig", "pweDig"], "md": ["MD", "hash", "cm", "mc", "dig", "ms", "sha", "metadata", "rm", "pm", "bd", "amd", "db", "am", "bm", "um", "mo", "meta", "mb", "mt", "mage", "cmd", "M", "sm", "mi", "mand", "m", "dd", "Cmd", "od", "mg", "mm", "ma", "ad", "pd", "cd", "dc", "kg", "mac", "hm", "mod", "me", "ld", "d", "mag", "nm", "dm", "mu", " MD", "mp"], "b": ["base", "ib", "bb", "gb", "ob", "bin", "br", "e", "bd", "nb", "emb", "db", "bis", "fb", "ba", "mb", "binary", "u", "orb", "buff", "sb", "a", "batch", "r", "lb", "buf", "bi", "wb", "buffer", "ab", "eb", "p", "bytes", "rb", "reb", "l", "B", "d", "bf", "bs", "cb", "f", "be"], "i": ["qi", "v", "z", "base", "ip", "ai", "ti", "vi", "I", "e", "id", "io", "xi", "x", "index", "start", "u", "li", "s", "ui", "multi", "c", "ci", "si", "phi", "ii", "j", "a", "r", "info", "n", "o", "bi", "zi", "block", "slice", "ri", "uri", "p", "it", "gi", "h", "abi", "l", "oi", "data", "di", "ni", "d", "chi", "ji", "mu", "f", "pi"]}}
{"id1": "14001795", "id2": "4618237", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyoverwarFiles", "copyOverWebfile", "copyoverWarPath", "copyoverwarPath", "copyOverWebFiles", "copyOverWarFiles", "copyOverWARFiles", "copyOverWebPath", "copyOverWARFile", "copyOverwarFile", "copyOverWarfile", "copyOverWarPath", "copyOverWARPath", "copyoverwarfile", "copyoverWarfile", "copyoverWarFile", "copyoverwarFile", "copyoverWarFiles", "copyOverWARfile", "copyOverWebFile", "copyOverwarFiles", "copyOverwarfile", "copyOverwarPath"], "dir": ["md", "url", " directory", "cache", "clean", "local", "direct", "window", "handle", "Dir", "zip", "feed", "cur", "db", "folder", "log", "df", "plugin", "keep", "ir", "lock", "pkg", "doc", "build", "lib", "r", "def", "class", "desc", "directory", "parent", "DIR", "handler", "config", "direction", "loc", "draft", "dc", "wd", "fd", "store", "http", "dr", "dn", "data", "work", "up", "file", "dist", "download", "d", "director", "coll", "group", "part", "manager", "di"], "ff": ["flow", "uf", "fp", "iff", "cf", "cl", "xff", "upp", "now", "bb", "bd", "feed", "ffe", "df", "rf", "fb", "fl", "fff", "aff", "ft", "fe", "ef", "eph", " buff", "dd", "fold", "TF", "fx", "fox", "ph", "buf", "eff", "fam", "uff", "FF", "fed", "fd", "lf", "fw", "ffff", "bf", "pp", "cpp", "sf", "cb", "buff"], "files": ["objects", "classes", "groups", "flows", "iles", "fl", "users", "locks", "ls", "s", "sections", "lines", "jobs", "results", "fa", "fe", "items", "models", "rows", "images", "ps", "plugins", "events", "apps", "fs", "blocks", "Files", "pages", "data", "ums", "file", "keys", "split", "names", "bs", "balls", "features"], "f": ["fp", "v", "cf", "e", "feed", "x", "tf", "rf", "fl", "fb", "flat", "filename", "of", "name", "aff", "c", "fe", "fa", "fold", "t", "info", "i", "n", "F", "handler", "fc", " fa", "fr", "fs", "inf", "p", "fd", "lf", "l", "fn", "file", "d", "bf", " file", "fen", "sf", "part"], "newFile": ["newDir", "updateF", "NewFiles", "oldFiles", " newF", "NewFolder", "andFile", " newFolder", "newLine", "updateLine", " newDir", "NewF", "nextFiles", "NewDir", "newF", "updatefile", "smallfile", "smallFile", "NewFile", "updateFile", "nextFolder", " newfile", "smallDir", "oldDir", " newFiles", "existingFile", "oldFile", "newfile", "newFolder", "andDir", "oldF", "nextDir", "existingfile", "nextFile", "newFiles", "andfile", "existingLine", " newLine", "existingF"], "fi": ["qi", "fp", "cf", "fy", "ico", "ife", "uci", "xi", "ffe", "ini", "py", "fb", "cci", "fin", "Fi", "si", "fe", "fa", "ifi", "ii", "sci", "afi", "i", "info", "fine", "FI", "afe", "zi", "fc", "bi", "flo", "isi", "fr", "fs", "abi", "lf", "shi", "fw", "wi", "sf", "pi", "ifa"], "fo": ["uf", "FO", "cf", "xf", "ico", "osa", "lo", "io", "olo", "mo", "oo", "obi", "si", "fe", "os", "fa", "bo", "ho", "ofi", "afi", "info", "obo", "so", "o", "ki", "zo", "co", "afe", "flo", "inf", "wo", "di", "shi", "fw", "ni", "tto", "sf", "ko", "ato", "po"]}}
{"id1": "5414088", "id2": "9846843", "code1": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"saveFileData": ["saveFileText", "loadFileText", "loadLocalData", "loadFileContent", "saveStreamText", "loadLocalBody", "saveLocalContent", "loadFileBody", "saveLocalText", "loadLocalText", "saveStreamContent", "savefileBody", "saveFileContent", "saveStreamData", "saveStreamBody", "savefileData", "savefileText", "loadFileData", "saveLocalData", "loadLocalContent", "savefileContent", "saveLocalBody", "saveFileBody"], "file": ["picture", "fp", "FILE", "base", "cache", "local", "parse", "use", "force", "current", "load", "model", "db", "path", "folder", "log", "function", "space", "input", "filename", "auto", "name", "profile", "binary", "to", "image", "queue", "database", "fe", "large", "lib", "code", "File", "type", "global", "connection", "info", "show", "class", "null", "parent", "object", "handler", "config", "per", "future", "service", "resource", "it", "content", "document", "get", "single", "http", "page", "data", "source", "work", "letter", "pic", "line", "create", "style", "figure", "full", "part", "f", "module"], "destination": ["boundribution", "destinator", "Destinated", "constinator", "distined", "distination", "Destination", "restination", "targetination", "Destribution", " destinations", "boundination", "Destined", "restinator", "destinations", "destribution", " destinator", "constation", "configinator", "destation", "Destation", "restinate", "constinations", "boundinated", "destinate", "boundinator", "configined", "targetinator", "destinated", "scheation", " destinate", "scheinations", "distinated", "destined", "distinator", "configination", "scheination", "restinations", "Destinate", "Destinations", "constination", "targetribution", "configinated", "scheinator", "Destinator", "targetinated"], "newDataFile": ["newAssetFile", " newDataTable", "newAssetDirectory", " newAssetTable", "newDataFiles", " newAssetFiles", "newVersionTable", "newNewLine", "newDataLine", "newStorageFile", "newContentModule", "largeDataChannel", "largeDatModule", "newDataChannel", "largeDatFile", "largeDataBase", "newInfoFile", "newAssetFiles", "newInfoFiles", "newVersionDir", "newStorageBase", "newDatBase", "newNewTable", "NewVersionDir", "newVersionFiles", "newDataTable", "newStorageChannel", "NewVersionLine", "newDataDir", "newDatModule", " newDataFiles", "NewDataLine", "newDataDirectory", "newNewDir", "newDataModule", "newContentFile", "newStorageModule", "newContentBase", "newVersionLine", "newInfoLine", "largeDatBase", "NewVersionFile", "newContentChannel", "NewVersionFiles", " newAssetDirectory", "newDatChannel", "newNewFiles", "newVersionDirectory", "largeDataFile", " newDataDirectory", "newInfoDir", "NewDataFiles", "newDatFile", "newNewDirectory", "newNewFile", "NewDataDir", "largeDatChannel", "largeDataModule", "NewDataFile", "newAssetTable", "newDataBase", " newAssetFile"], "fileName": ["FileType", " filePath", " fileNAME", "FileName", "filename", "fileNAME", "resourceType", "servicePath", "fileType", "FilePath", "serviceNAME", "resourcename", "serviceName", "resourcePath", " filename", " fileType", "filePath", "resourceName", "Filename", "FileNAME"], "assetsPath": [" assetspath", " assetsFile", "toolsDir", "absoluteDir", "antsCase", "assetsTree", " assetsCase", "absolutepath", "antsTree", " assetsTree", "assetspath", "toolsPath", "imagesPath", "imagesDir", "imagesFile", "absolutePath", "assetsCase", "assetsDir", "imagespath", "toolsTree", "toolsCase", "antsDir", "assetsFile", " assetsDir", "antsPath", "absoluteFile"], "workingFile": ["trainingFile", "pingFILE", "WorkingFilename", "lockingFilename", "workingfile", "workFile", "writingFILE", " workingfile", "WorkingFile", "workFiles", "WorkingFILE", "writingFilename", "writingSourceFile", "startingStream", " workingFiles", "pingStream", "movingFile", "workingStream", "pingFile", "gradingFILE", "WorkingFiles", "learningSourceFile", "startingSourceFile", "workingFILE", "WorkingDirectory", "learningFilename", "processingfile", "movingFILE", "learningFILE", "lockingFILE", "processingFilename", "workingSourceFile", " workingFILE", " workingFilename", " workingDirectory", "lockingSourceFile", "writingFile", "trainingStream", "movingfile", "workSourceFile", "processingFILE", "gradingfile", " workingSourceFile", "startingFile", "gradingFile", "WorkingSourceFile", "learningFile", "movingSourceFile", "workingFiles", "pingSourceFile", "trainingFILE", "workingDirectory", "lockingFile", "movingFilename", "processingSourceFile", "gradingFilename", "workingFilename", "trainingSourceFile", "startingFILE", "workDirectory", "processingFile", "writingfile"], "vc": ["lc", "cf", "DC", "mc", "cy", " util", "cache", "util", " cf", " c", "cv", "C", "Controller", "vt", "db", " cd", " cs", "ic", "vg", "hw", "CV", "c", "cc", "ci", "GC", " cache", "cu", " dc", "cs", " VC", "fc", " db", "dc", "rc", "ant", "VC", "RC", "fw", "pc", " rc", "vd", "ac", "cow", "coll", "CC", " cc", "ctrl", "xc", " vm", "acl"], "is": ["us", "address", "iv", "ais", "ip", "ins", "does", "ois", "isol", "app", "isa", "iso", "are", "id", "has", "IS", "bis", "vs", "Is", "sis", "abs", "ir", "ui", "ls", "ris", "ci", "isl", "ios", "iss", "os", "or", "i", "info", "js", "lis", "isi", "ri", "api", "its", "iris", "in", "init", "as"], "channelFrom": ["imageOrigin", "imageFrom", " channelfrom", "ChannelOf", "channelOf", "channelfrom", "pageTo", " channelOf", "imageTo", "pageFrom", "queueOf", "ChannelOrigin", "queuefrom", "channelOrigin", "pagefrom", "ChannelTo", "Channelfrom", "pageOf", "ChannelFrom", "queueFrom", "queueTo", "imageOf", " channelOrigin"], "newVersionFile": ["newDataFiles", "NEWVersionFile", "newversionFiles", "newTargetDir", "NewVersionFormat", "newDataFormat", "newTargetFunction", "newVersionFunction", "newChannelFile", "NewVersionFunction", "NEWversionDir", "newVersionDir", "NewVersionDir", "newVersionFiles", "newDataDir", "NewDataFormat", "newNewDir", "NEWversionFiles", "newChannelFormat", "NEWversioned", "newChannelDir", "newDataFunction", "newversioned", "NewVersionFile", "newTargetFile", "NEWVersioned", "newChannelFunction", "NewDataFunction", "NEWversionFile", "newNewFiles", "newVersionFormat", "NEWVersionDir", "newversionFile", "newversionDir", "newNewed", "newVersioned", "newNewFile", "NEWVersionFiles", "NewDataDir", "newDataed", "NewDataFile", "newTargetFormat"], "channelTo": ["Channelto", "userTO", "queueto", "userTo", "Channel2", "flowTo", " channelto", "routeTo", "routeFor", "channelFlo", "channelto", "flowOf", "queueTO", "ChannelOf", "channelOf", "channel2", " channel2", "flowFrom", "userto", "routeFrom", "routeFlo", " channelOf", "ChannelFor", "ChannelFlo", "ChannelTO", "channelTO", "flow2", "ChannelTo", " channelTO", "ChannelFrom", " channelFlo", "queueFrom", " channelFor", "flowTO", "channelFor", "userFrom", "queueTo", "flowto"], "writeCurrentChannel": [" writeCurrentSquare", " writeCurrentQueue", "writeCenterChannel", " writeThisChannel", "writePreviousChan", " writeThisConnection", "valuecurrentChan", "writeNewchannel", "writeCurrentUser", "changeNewchannel", " writeStreamChannel", "writeCompleteChan", "writeCurChannel", "writeStreamChan", "writeRightchannel", "writeNewChan", "writeThisStream", "writeThisChannel", "writeStreamUser", "writeRightMessage", "writeStreamStream", "writeCorrectChannel", "valueCurrentPlayer", "writeActiveStream", "valuecurrentChannel", "writeRightChannel", "writecurrentChan", "writeCurChan", "writeOriginalMessage", "writePreviousChannel", "writeCurrentMessage", "writeCurPlayer", " writeNewSquare", "writeCurrentStream", "changeCurrentUser", "writeCorrectQueue", "writeCompleteSquare", "writeNewUser", "writeCurConnection", "writeCurrentchannel", "writeActiveChannel", " writeNewChan", "writeNewMessage", "writeCorrectStream", "writeCorrectConnection", "valueCurrentChannel", "writeCompleteChannel", " writeCurrentUser", "writecurrentChannel", "writeStreamChannel", "changeCurrentMessage", "valueCurrentChan", " writeCurrentConnection", "writeRightUser", " writeCurrentStream", "changeCurrentchannel", "writeCurrentPlayer", "writeNewSquare", "writePreviousStream", " writeThisQueue", "writecurrentConnection", " writeStreamStream", "writeOriginalChannel", "valuecurrentPlayer", "writeActiveUser", "writeCurrentQueue", "writecurrentSquare", "writeCompleteConnection", " writeThisStream", "writeActiveChan", " writeStreamUser", "writeThisConnection", "changeCurrentChannel", " writeNewConnection", "changeNewMessage", "writeNewConnection", "writeNewChannel", " writeNewChannel", "writecurrentPlayer", "writeCenterPlayer", "writePreviousUser", "writeCurrentSquare", "writeCenterChan", "writeOriginalUser", "writeThisQueue", "writeCurrentChan", "writeCurrentConnection", "changeNewUser", "writeCurQueue", " writeStreamChan", " writeCurrentChan", "writeCurStream", "writeOriginalchannel", "changeNewChannel"], "fromChannel": ["toFile", "FromChan", "Fromchannel", "formConnection", "fromchannel", "FromFile", "FromButton", "toSocket", "formStream", " fromConnection", "fromStream", "fromClient", "fromConnection", "fromPage", "FromStream", " fromPage", "fromSocket", " fromSocket", "FromClient", "FromSocket", "fromPlayer", "formChannel", " fromButton", "fromServer", "FromServer", " fromServer", " fromPlayer", " fromChan", "toChan", " fromStream", "toChannel", "newServer", "fromFile", "toClient", " fromchannel", " fromClient", "newChannel", "FromChannel", "FromPage", "newButton", "newStream", "FromPlayer", "toPage", " fromFile", "formPlayer", "tochannel", "fromChan", "fromButton", "FromConnection"], "img": ["map", "picture", "im", "v", "url", "iv", "Image", "ani", "png", "cache", " images", "ng", "jpg", "gb", "br", "tmp", "app", "io", "Images", "fb", "input", "div", "auto", "hr", "obj", " image", "aff", "gif", "image", "imp", "lib", "ii", "m", "au", "ie", "i", "gd", "info", "g", "images", "buf", "bg", "attr", "icon", "api", "p", "imag", "pic", "data", "dir", "NG", "src", "coll", "f", "agi"], "height": ["flow", "header", "ip", "png", "upper", "view", "resolution", "window", "ensions", "id", "crop", "volume", "gh", "row", "input", "length", "hi", "hd", "image", "def", "rows", "images", "Height", "ops", "head", "shape", "padding", "alpha", "depth", "h", "age", "pages", "data", "thumbnails", "style", "d", "capacity", "area", "inches", "size"], "width": ["flow", "wa", "Width", "left", "output", "window", "port", "platform", "crop", "path", "sl", "border", "length", "core", "image", "write", "down", "widget", "fe", "large", "lon", "duration", "writer", "number", "weight", "layout", "depth", "amount", "age", "page", "data", "style", "capacity", "value", "full", "area", "sw", "size", "settings"], "folderPath": ["directoryHalf", "folderPoint", " folderHalf", "folderName", "FolderPoint", "directoryPath", "fileDir", "dirLocation", "directoryPoint", "FolderName", "directoryName", "dirHalf", "FolderDir", "dirPath", "directoryDir", "dirName", "filePoint", " folderName", "directoryLocation", "folderLocation", "filePath", "FolderPath", " folderLocation", "folderDir", "folderHalf"], "directory": ["system", "Manager", "cache", "project", "direct", "Dir", " manager", "volume", "container", "relative", "folder", "filename", "location", "machine", " directories", "archive", "database", "widget", "storage", "connection", "root", "parent", "object", "handler", " Directory", " dir", "direction", "list", "tree", "Folder", "l", " repository", "dir", "server", "d", "director", "area", "collection", "Directory", "home", "manager", "f"], "files": ["objects", "classes", "fil", "places", "iles", "children", "users", "parents", "s", "sections", "lines", "jobs", "results", "projects", "items", "images", "apps", "blocks", "fs", "Files", "pages", "data", "packs", "split", "names", "f", "writers"]}}
{"id1": "812803", "id2": "8490297", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["CONception", " deconversion", "Converted", "oconversion", "subversion", "CONverted", "unception", "subverting", "CONvert", "subverted", "unvert", "unverted", "Conception", "CONverting", " deconverting", "oconverted", "Conversion", "Converting", "CONversion", "oconvert", " deconverted", "conception", "converting", "subvert", "oconverting", "Convert", "conversion", "converted", "unversion", " deconvert"], "src": ["sys", "ource", "fp", "url", "sit", "prot", "st", "img", "reader", "gb", "tmp", "load", "cb", "proc", "scene", "path", "input", "filename", "string", "name", "obj", "s", "stream", "secure", "sth", "Source", "spec", "upload", "storage", "sel", "code", "username", "SourceFile", "ssl", "sb", "component", "Dest", "supp", "buf", "video", "sin", "attr", "back", "config", "loc", "slice", "inst", "sn", "uri", "resource", "rb", "feat", "rc", "href", "source", "fn", "sc", "file", "download", "ref", "RC", "gz", "dist", "req", "stage", "impl", "cpp", "rl", "ctx", "cmp"], "dest": ["disk", "test", "cont", "img", "bin", "tmp", "path", "target", "obj", "lib", "std", " dst", "Dest", "class", "dat", "orig", "null", "dc", "di", "source", "fn", "dir", "dist", " destination", "home", "txt", "temp"], "in": ["ins", "din", "reader", "IN", "login", "bin", "isin", "inc", "io", "ini", "val", "input", "In", "stream", "err", "doc", "inas", "t", "a", "i", "r", "ex", "n", "ps", "win", "inn", "inf", "pin", "is", "data", "source", "up", "file", "d", "pass", "as", "f"], "p": ["fp", "jp", "v", "pa", "tp", "bp", "e", "lp", "pre", "pm", "P", "py", "pr", "s", "cp", "c", "np", "m", "t", "j", "i", "r", "pe", "g", "b", "cop", "o", "ps", "per", "parser", "pd", "pg", "h", "wp", "l", "op", "pb", "d", "pc", "pp", "sp", "part", "f", "pi", "po"], "ds": ["posts", " DS", "eps", "dp", "ths", "vs", "els", "os", " ps", "dat", "ps", " sd", "pd", "uds", "data", "qs", "utils", "points", "rs", "services", "da", "groups", "db", "docs", "s", "ls", "hs", "words", "ys", "models", "cs", "ans", "di", "ld", "cons", "gs", "ins", "xs", "ges", "ts", "nas", "ks", "sts", "ded", "lines", "vals", "js", "ups", "plugins", "dates", "ants", "dds", "ss", "scripts", "tests", "ils", "ads", "sys", "Ds", "ays", "dl", "lp", "tools", "df", "ns", "styles", "dd", "gd", "des", "dos", "sync", " props", "dc", "parts", "dt", "obs", "dist", "amps", "d", "DS", "icks", "dm", "ipes", "bs"], "format": ["template", "atter", "url", "fp", "magic", "model", "path", "function", "plugin", "host", "pattern", "filename", "string", "nat", "language", "struct", "name", "prefix", "spec", "t", "type", "at", "Format", "class", "tag", "handler", "config", "layout", "sche", "table", "parser", "api", "version", "scale", "form", "feat", "fd", "data", "source", "file", "filter", "letter", "ant", "fn", "style", "act", "frame", "unit", "part", "record", "f"], "hasPixelData": ["hasByteData", "showsPixelDATA", "hasPictureSize", "haspixelSize", " hasPixelSize", " hasPixeldata", "showsByteData", "showsByteStyle", "showsBytedata", "showsPixeldata", "hasPixelSize", "hasPicturedata", "showsPixelStyle", "hasByteSize", "hasPixelDATA", "hasPictureData", "hasPixeldata", "hasByteStyle", "haspixelData", "showsByteDATA", "haspixeldata", "hasPixelStyle", "hasBytedata", "showsPixelData", "hasByteDATA"], "inflate": ["inflace", "invenATE", "Inflation", "inFlate", "inflating", "infolode", "insvenate", "inFlation", "insvenATE", "invenode", "insvenating", "inflated", "Inflated", "inadequode", "inadequate", "inffation", "invenate", "insflate", "inflATE", "Inflate", "infloated", "inFlated", "infface", "InFlate", "insflATE", "Inflace", "InFlace", "inadequATE", "insflating", "inFlace", "infloate", "InFlation", "infloation", "insvenode", "inflode", "infolATE", "infloace", "inffate", "infolate", "inflation", "invenating", "inadequating", "InFlated", "insflode", "infolating", "inffated"], "pxlen": ["mxlen", "pxsize", "mxdata", "fxlen", "pgLen", "mxcount", "pgl", "fxden", "pxdata", "fxl", "axlon", "pxl", "pxlength", "pxlon", "pnglength", "xpsize", "pplen", "mxsize", "txlon", "axln", "pclin", "camlen", "pxLen", "camdata", "fxLen", "pxden", "pglen", "pxcount", "pxpos", "fxpos", "pclen", "txlen", "pxln", "pxlin", "campos", "txln", "fxdata", "pclon", "camln", "txlin", "xplen", "xplength", "fxln", "axlin", "ppden", "mxlength", "ppl", "pgden", "pnglen", "ppLen", "pngsize", "mxpos", "pngcount", "axlen", "xpcount", "mxln", "pcln"], "out": ["sys", "v", "error", "OUT", "outs", "cache", "gen", "re", "output", "io", "log", "session", "conn", "obj", "state", "lock", "err", "Out", "step", "lib", "user", "again", "parent", "co", "query", "list", "pad", "post", "copy", "point", "store", "cli", "line", "work", "up", "server", "page", "dump", "group", "inter"]}}
{"id1": "9371421", "id2": "9081749", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 1, "substitutes": {"eventHash": ["byteDig", "bytehash", "messageHash", "messagehash", "eventhash", " eventDig", "eventKey", " eventKey", " eventhash", "byteKey", "messageKey", "eventDig", "byteHash", "messageDig"], "eventstr": [" eventstring", "Eventsource", "eventStr", "eventsource", "Eventstr", " eventStr", "exstring", "errorstr", "EventStr", "eventdict", "errorstring", "eventstring", "errorStr", "exStr", " eventdict", "Eventstring", "exstr", " eventsource", "Eventdict", "exdict", "errorsource"], "md": ["MD", "hash", "map", "cm", "mc", "dig", "ms", "sha", "ng", "metadata", "id", "pm", "bd", "amd", "mo", "meta", "mb", "mt", "cmd", "hd", "doc", "sm", "rpm", "mand", "m", "dd", "od", "mg", "mm", "ma", "ad", "em", "key", "wd", "mac", "mn", "mod", "hm", "dr", "di", "data", "ke", "dh", "ld", "d", "mag", "vd", "dm", "mem", "mu", " MD", "mp"], "theDigest": ["thedigest", "theSignEST", " theDigEST", "Thedigest", "theDigEST", "ThedigEST", "Thedigester", "TheDigEST", " theSignEST", "thedigester", "theDigester", "TheDigest", "theSignester", "theHashEST", " theDighest", "thedigEST", "theHashester", "theSignhest", "theSignest", "theDighest", "TheDigester", " theSignest", " theSignester", " theDigester", " theSignhest", "theHashest", "thedighest"]}}
{"id1": "4168534", "id2": "7425022", "code1": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 0, "substitutes": {"insertSmsInf": ["insertJsMSConf", "insertSmesinf", "insertSmbConf", "insertSmsInfo", "insertJsmsConf", "insertSmsConf", "insertSMSInfo", "insertSMSConf", "insertSmbInfo", "insertSmbInf", "insertSmesInfo", "insertSmsinf", "insertSMSinf", "insertSmesInf", "insertSmbinf", "insertSMSInf", "insertJsMSInfo", "insertJsMSInf", "insertJsmsInfo", "insertJsmsinf", "insertJsMSinf", "insertJsmsInf", "insertSmesConf"], "sms": ["isfs", "schems", "smos", "esbm", "inms", "scheMs", "esMs", "smn", " sessions", "scheessions", "isms", "sbm", " sMs", "installmes", "esmes", "ismos", "pails", "installms", "installbm", " smn", "jsls", "dsmb", "scheails", " sfs", "esmb", " smos", "esms", "dsls", " smes", "inmos", "esls", "infs", "jsmes", "jsms", " sails", "jsmb", "dsmes", "smb", "sls", "sails", "sMs", "pms", "pessions", "smes", "installMs", " sbm", "sfs", "ismn", "dsms", "pMs", "sessions", "inmn"], "smsId": ["smsUrl", "smsName", " smsInfo", "sMSKey", "smesInfo", "slsid", "SmsUrl", "snsId", "spsInfo", "smsInfo", "Smeid", "snsID", "SmeId", "smeid", "slsID", "snsUrl", "smesid", "snsKey", "snsid", "esmsID", "esnsKey", "sssID", " smsName", "SmsID", "SmeUrl", "sMSid", "esnsID", "gmsId", "snsName", "smesName", "smesID", " snsId", "gnsid", " snsid", "smsID", "esnsid", " smsid", "spsid", "sssId", " snsInfo", "scsKey", "Smsid", "sMSId", "gnsId", "gnsID", "gmsID", "smeId", "SmsId", "spsName", "slsId", " snsName", "smeID", "smsid", "scsId", "smeUrl", "sMSID", "esmsKey", "SmeID", "smesUrl", "smsKey", "scsid", "esnsId", "sssid", "esmsId", "scsID", "spsId", "gmsid", "snsInfo", "smesId", "esmsid"], "conn": ["exec", "cm", "lc", "cf", "mc", "error", "client", "ca", "ann", "cache", "uc", "ou", "reg", "db", "log", "ctx", "oci", "connect", "session", "sql", "core", "cr", "cp", "conv", "cms", "obj", "lock", "c", "ci", "cc", "org", "ct", "connection", "Connection", "n", "config", "loc", "co", "nt", "enc", "sync", "pub", "dc", "close", "pg", "rc", "cli", "col", "pool", "ch", "cn", "act", "server", "coll", "pc", "con", "nc", "cat", "Conn", "conf", "cb", "pr", "po"], "pstmt": ["pctnm", "pstmb", "prestatt", " pestdb", "pctm", "pStmt", "pstrdb", "pfnt", "Pstmr", "pstrmt", "pfbt", "pfnm", "pctmt", "pcttt", "pthdt", "pmtmt", "pktmd", " pktmt", " pstmb", "pngmt", "Psttt", "pstdb", "pthmd", "Pstmn", "pstdt", "pestmr", " pestmr", " pstmn", "Pctmb", "psthmd", "Pstmd", " pstmd", "pfmb", "pfmn", " pktmn", " pstm", "pStmb", " pestorp", "Pctmn", " pktmd", "Pstmb", "postmt", "psthmr", "pktmt", "psthdt", "pctbt", "pthmt", "Pctmt", " pstnt", "pctmb", "psthmb", " pfm", " pstnm", "pSttt", "pStmr", "pmtm", "Pctm", " pestmt", " pstmr", "pfmt", "pngbt", "psthtt", "pctmd", "pktmn", "pctmr", "pctdb", "pestdb", " postatt", "Pctmd", "pstrm", "Pctdb", "pstmd", " pstorp", " pfnt", " postm", "pktdt", "Pstbt", "psthmn", "pstnt", "pstmn", "pstm", "pfdb", "pstmr", " pstdt", "pngmd", " postmd", "pstrmn", "Pctmr", " pfmt", "pmtdb", "pstbt", " pstdb", "psttt", "pestorp", "pctnt", "psthmt", "prestmd", "pstnm", "pfm", "pngmb", "Pcttt", "pctatt", " pktdt", " pstatt", "Pstdb", "postm", "pmtnm", "prestmt", "pmtorp", "Pctbt", " pestmb", "Pstm", "psthdb", "pctorp", "pstatt", "pfmd", "pmtmb", "pctmn", " postmt", "prestm", "pstorp", "pthmn", "postmd", "pestmt", "postatt", "Pstmt", " pfnm", "pmtnt", "pestmb"], "buffer": ["Buffer", "template", "bc", "url", "result", "uf", "base", "header", "uffer", "cache", "builder", "re", "flash", "window", "bin", "view", "FFER", "comment", "raw", "shell", "request", "log", "function", "fb", "string", "binary", "memory", "queue", "database", "build", "code", "layer", "writer", "sb", "print", "info", "batch", "b", "null", "buf", "bar", "program", "object", "text", "block", "message", "BU", "array", "resource", "iter", "key", "document", "copy", "http", "page", "pb", "append", "file", "server", "IO", "book", "buff"], "index": ["position", "address", "digit", "base", "error", "column", "level", "cache", "change", "id", "inc", "path", "default", "x", "include", "input", "connect", "val", "length", "ind", "end", "offset", "section", "step", "connection", "i", "batch", "info", "number", "join", "find", "config", "loc", "block", "diff", "slice", "weight", "Index", "update", "list", "alpha", "array", "version", "add", "key", "condition", "search", "point", "match", "append", "style", "width", "pos", "num", "instance", "field", "value", "open", "size"], "ex": ["exec", "su", "external", "rex", "de", "error", "exc", "pex", "re", "aux", "lex", "com", "app", "exp", "expl", "EX", "tx", "x", "es", "nex", "ic", "name", "Ex", "obj", "ext", "Exc", "six", "err", "ax", "rap", "event", "class", "rx", "ignore", "js", "ception", "example", "except", "sex", "con", "exit", "temp"]}}
{"id1": "12380475", "id2": "18974466", "code1": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"transport": ["ransprocess", " transports", "protmission", "transmission", "ransport", " transprocess", "transpoint", "protprocess", "protports", "ransporter", " transmission", "ranspoint", "protpoint", " transporter", "transports", "transporter", "protport", "ransmission", " transpoint", "protporter", "transprocess", "ransports"], "file": ["fp", "url", "FILE", "base", "reader", "cache", "change", "project", "local", "handle", "e", "use", "io", "model", "db", "path", "folder", "log", "filename", "auto", "name", "out", "string", "stream", "queue", "image", "ile", "File", "type", "connection", "info", "class", "user", "route", "directory", "object", "parent", "handler", "socket", "service", "resource", "content", "document", "http", "single", "page", "data", "source", "channel", "dir", "server", "entry", "line", "full", "comment", "f"], "files": ["objects", "ins", "classes", "flows", "iles", "ions", "users", "ls", "s", "cells", "lines", "results", "sites", "items", "models", "images", "facts", "ups", "issues", "headers", "boxes", "events", "blocks", "fs", "views", "books", "Files", "pages", "ums", "phones", "dir", "thumbnails", "keys", "names", "bs", "balls", "pes", "f", "features"], "i": ["v", "k", "ip", "ai", "ti", "vi", "I", "e", "id", "io", "xi", "x", "ini", "index", "end", "u", "li", "ui", "hi", "multi", "c", "ci", "si", "mi", "ii", "m", "j", "info", "b", "n", "o", "slice", "ri", "uri", "p", "it", "key", "h", "abi", "col", "oi", "di", "ni", "d", "chi", "f", "pi"], "inChannel": ["InMessage", "inputChan", " inchannel", "inChan", "InStream", "InFile", " inFile", "InChannel", " inCh", "inFile", "inchannel", "outchannel", "outMessage", "outStream", "outFile", "inputStream", " inStream", "inCh", "inStream", " inMessage", "inMessage", " inChan", "InChan", "inputCh", "Inchannel", "InCh", "inputChannel"], "outChannel": ["Outchannel", " outConnection", "inChan", " outChan", "OutStream", "ioHandler", "outChan", "ioConnection", "inchannel", "outchannel", "outStream", "outConnection", "inHandler", "ioChan", "inStream", " outStream", "ioChannel", "inConnection", " outchannel", "OutChan", " outHandler", "OutChannel", "outHandler"]}}
{"id1": "7044685", "id2": "2910383", "code1": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "code2": "    public String downloadAndOpen(JProgressBar bar) {\n        long size = 0;\n        try {\n            size = photo.getSize();\n        } catch (ServiceException ex) {\n            ex.printStackTrace();\n        }\n        try {\n            bar.setMaximum((int) size);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        bar.setValue(0);\n        image = new File(\"TMP/\" + photo.getTitle().getPlainText());\n        try {\n            if (!image.exists()) {\n                image.createNewFile();\n                image.deleteOnExit();\n                URL url = null;\n                BufferedOutputStream fOut = null;\n                try {\n                    url = new URL(photo.getMediaContents().get(0).getUrl());\n                    InputStream html = null;\n                    html = url.openStream();\n                    fOut = new BufferedOutputStream(new FileOutputStream(image));\n                    byte[] buffer = new byte[32 * 1024];\n                    int bytesRead = 0;\n                    int in = 0;\n                    while ((bytesRead = html.read(buffer)) != -1) {\n                        in += bytesRead;\n                        bar.setValue(in);\n                        fOut.write(buffer, 0, bytesRead);\n                    }\n                    html.close();\n                    fOut.close();\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return image.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"encrypt": ["enccrypt", "encipher", "encress", "deccrypt", "decipher", " enccrypt", "enrypt", "enress", "decrypt", " encress", " encipher", "decress", "enipher"], "plaintext": ["plainsource", "flatsource", " plainText", " plaincontent", " PlainText", "plainTEXT", "fcbinary", " plainbinary", " plainsource", "flattext", " Plaintext", " Plaincontent", "plainText", " Plainbinary", "flatTEXT", "plainbinary", "broadTEXT", "fcText", "broadsource", "fccontent", "broadText", "flatText", "plaincontent", "broadtext", " plainTEXT", "fctext"], "d": ["mad", "md", "de", "da", "dl", "e", "id", "bd", "dict", "db", "ded", "c", "mand", "m", "dd", "t", "gd", "r", "g", " dd", "b", "n", "dat", "o", "sd", "D", "did", "od", "dad", "ds", "ad", "dc", "pd", "cd", "p", "nd", "h", "fd", "dn", "dt", "di", "l", "data", "dr", "mod", "dh", "ld", "ed", "f", "dig", "rd"]}}
{"id1": "23510383", "id2": "8788371", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"saveProject": ["insertproject", "insertModel", "deleteProject", "deleteModel", " saveApplication", "saveproject", " saveproject", "deleteApplication", "insertProject", "deleteproject", "insertApplication", "saveApplication", "saveModel", " saveModel"], "file": ["complete", "picture", "fp", "base", "FILE", "project", "local", "found", "use", "zip", "model", "db", "path", "folder", "log", "filename", "out", "image", "lock", "ile", "files", "File", "connection", "directory", "parent", "object", "handler", "table", "resource", "plus", "document", "single", "line", "data", "work", "dir", "full", "part"], "types": ["photos", "Types", "services", "params", "relations", "classes", "objects", "groups", "packages", "eps", "archives", "ids", "ts", "tags", "reports", "shows", "ames", "tools", "times", "Images", "ypes", "forms", "ions", "users", "locks", "lists", "styles", "jobs", "resources", "projects", "files", "strings", "words", "uploads", "properties", "models", "options", "plugins", "boxes", "blocks", "parts", "opens", "links", "its", "pages", "versions", "thumbnails", "ports", "fields", "keys", "stores", "packs", "products", "cats", "names", "pes", "tests", "features", "settings"], "images": ["photos", "services", "png", "assets", "rooms", "tags", "reports", "videos", "Images", "users", "styles", "image", "files", "modules", "uploads", "plugins", "boxes", "events", "actions", "media", "views", "blocks", "ips", "versions", "thumbnails", "scripts", "features"], "trajectories": ["transjectors", "trajections", "traveyory", "traventory", "tracessions", "transjections", "tracessories", "traveyions", "traveyories", "traveyors", "transcessory", "trajectors", "transcessories", "transjectories", "traventors", "traventories", "traventions", "tracessory", "transjectory", "trajectory", "tracessors", "transcessions", "transcessors"], "databasesIncluded": ["daturesIncluded", "databasesInsclusion", "databasesInclusive", "databytesInsclusion", "databasesinhibited", "databasesINcluding", "databasesInhibited", "daturesInhibited", "databasesOutcluding", "databasesOutcluded", "databasesinclusion", "databasesOutclusive", "daturesInsclusion", "daturesInsclusive", "databytesInclusion", "databasesINclusion", "databytesInscluding", "databytesInscluded", "databasesIncluding", "daturesInshibited", "databytesInshibited", "databytesInhibited", "databasesInshibited", "databasesincluded", "databasesINhibited", "daturesInclusive", "databytesIncluded", "databasesInscluded", "databytesIncluding", "databasesINcluded", "daturesInscluded", "databasesInscluding", "daturesInclusion", "databasesOutclusion", "databasesinclusive", "databasesOuthibited", "databasesInclusion", "databasesInsclusive"], "onlyLinks": ["OnlyLinks", "withLinks", "withLink", "OnlyLink", "justLinks", "allLink", "justLink", "onlylinks", " onlyLink", "alllinks", "justFiles", "withlinks", "OnlyFiles", "onlyLink", " onlylinks", " onlyFiles", "onlyFiles", "allLinks"], "index": ["position", "address", "xxx", "level", "found", "id", "inc", "old", "x", "default", "ini", "input", "pattern", "ind", "length", "offset", "end", "string", "tail", "i", "number", "head", "slice", "weight", "Index", "key", "search", "point", "page", "match", "width", "num", "value", "initial", "part", "size"], "name": ["url", "base", "title", "id", "none", "path", "Name", "default", "filename", "string", "ext", "named", "memory", "domain", "image", "large", "vision", "connection", "number", "NAME", "message", "resource", "key", "unique", "data", "up", "stage", "full", "home", "names", "part", "size", "temp"], "format": ["external", "template", "position", "header", "base", "status", "feed", "current", "term", "function", "export", "filename", "pattern", "string", "language", "struct", "offset", "prefix", "at", "Format", "transform", "text", "handler", "config", "layout", "pretty", "parser", "date", "scale", "form", "data", "letter", "style", "init", "value", "unit", "temp"], "count": ["base", "error", "level", "cache", "call", "found", "force", "child", "path", "Count", "length", "code", "build", "counter", "parent", "weight", "list", "depth", "content", "age", "page", "match", "process", "num", "limit", "sum"], "version": ["v", "feature", "master", "header", "ver", "description", "project", "output", "platform", "cover", "xml", "environment", "default", "target", "python", "string", "section", "image", "database", "journal", "vision", "release", "application", "Version", "latest", "video", "directory", "config", "update", "draft", "content", "versions", "channel", "data", "vert", "VERSION", "download", "server", "dir", "manager"], "writer": ["written", "wire", "writ", "reader", "builder", "w", "output", "war", "worker", "xml", "engine", "creator", "er", "export", "former", "out", "driver", "word", "writing", "write", "widget", "wr", "editor", "journal", "Writer", "riter", "player", "handler", "walker", "buffer", "parser", "wrapper", "wave", "document", "page", "data", "letter", "W", "director", "later", "book", "manager", "author", "writers", "temp"], "xmlDir": ["databaseArea", "xmlPath", "xmlFolder", " xmlDirectory", "databaseDirectory", " xmlFolder", "externalFolder", "databaseDir", "jsonPath", "imageFile", " xmlArea", "jsonArea", "jsonDir", "imageFolder", "imageDirectory", "xmlArea", "databasePath", "xmlDirectory", " xmlFile", "jsonDirectory", "externalDir", " xmlPath", "xmlFile", "imageDir", "externalFile", "externalDirectory"], "databases": ["variations", "notabases", "datations", "variabases", "arrabytes", "notrooms", "drogs", "diogs", "Databases", " datrooms", "datogs", "structables", "datases", "arrases", "structabases", "drabases", "Databytes", "databytes", "datables", "notases", "Datases", "datrooms", "variogs", "diabases", "variabytes", "diabytes", "arrables", "notations", "structabytes", "Datations", " datations", "structases", " datases", "drabytes", "Datrooms", "drations", "diations", "Datables", "arrabases"], "t": ["template", "v", "test", "token", "title", "w", "e", "ts", "none", "T", "target", "te", "string", "q", "c", "y", "m", "j", "i", " T", "ty", "class", "n", "o", "task", "att", "tm", "Type", "p", "h", "ant", "d"], "type": ["template", "test", "result", "TYPE", "base", "error", "token", "e", "right", "id", "model", "function", "target", "string", "state", "language", "action", "to", "set", "link", "database", "ype", "like", "y", "info", "role", "pe", "class", "ty", "null", "definition", "parent", "rule", "o", "slice", "block", "option", "attribute", "Type", "p", "key", "single", "other", "data", "match", "op", "style", "field", "value", "group", "collection", "part", "comment"], "currentName": ["thisMember", "reportedNames", " currentStyle", "CurrentKey", "reportedKey", "thisStyle", "CurrentPath", "currentAddress", "thisName", "CurrentFile", "recentName", "CurrentName", "currentNames", "CurrentType", "currentStyle", "reportedType", "reportedName", "currentMember", "currentTime", "futurePath", "futureNames", "thisAddress", "recentTime", "thisPath", "reportedPath", " currentPath", " currentType", "currentKey", "thisTime", "thisType", " currentMember", "futureFile", "reportedAddress", " currentKey", "recentStyle", "currentType", " currentFile", " currentTime", "currentPath", "CurrentAddress", "CurrentNames", "recentMember", "currentFile", " currentNames", "futureName"], "baseCopy": ["aseCopy", "basicCopy", "basicSource", " baseCop", " basecopy", "BaseCreate", " baseSource", " baseShare", " baseCreate", "baseCreate", "basiccopy", "baseCop", "baseShare", "BaseCopy", " baseName", "Basecopy", "BaseShare", "baseName", "basicCreate", "BaseName", "binaryCopy", "basecopy", "BaseSource", "baseSource", "BaseCop", "asecopy", "binaryCop", "aseShare", "aseName", "binarycopy"], "source": ["ource", "slave", "result", "base", "reader", "client", "cache", "scope", "view", "site", "use", "current", "proxy", "scene", "remote", "input", "target", "core", "inner", "stream", "section", "image", "Source", "storage", "rate", "clone", "reference", "connection", "component", "ie", "object", "parent", "text", "dest", "config", "slice", "ources", "option", "service", "resource", "from", "channel", "server", "src", "unit", "size", "manager", "SOURCE"], "destination": ["destinator", "Destinated", "constinator", "distignment", "transination", "distination", "Destination", " destment", "transignment", "Destribution", "externalinated", "combination", "destinations", "constation", "destribution", " destinator", "Destment", "distribution", "destment", "destation", "Destation", "constinations", "combinations", "transinator", " destinated", "Destignment", "destinated", "combation", "externalment", "distinator", "Destinations", "externalination", "constination", "transribution", "combinator", "externalinator", "Destinator", "destignment"], "clefs": ["clebs", "clef", "cleflows", "Clefs", "CLEFS", " cleflows", "CleFS", "CLEbs", "Cleflows", "CLEf", "cleFS", "Clef", " clef", "CLEflows", "Clebs", " cleFS", "CLEfs", " clebs"], "st": ["rest", "str", "ste", "ts", "sta", "tt", "ast", "St", "sl", "sts", "mt", "start", "cr", "struct", "sth", "est", "set", "sm", "bl", "ist", "sa", "std", "ct", "sb", "bt", "ost", "inst", "fr", "sn", "stru", "nd", "sc", "ld", "src", "ust", "ST", "sp", "ss", "statement", "rd"], "rs": [" ans", " src", " ra", " Result", "Res", " success", "res", " matches", " RS", "RS", " sr", " sq", " params", " Rs", "Rs", " hits", " changes", "rc", "R", "RC", " repl", " rc", " obj", " re", "rd", " rm"]}}
{"id1": "11865906", "id2": "7948308", "code1": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"testIdentification": ["testAuthentity", "testidentification", "testAuthentification", "TestIdentity", "testIdentifier", "testPersonity", "testAuthentifier", "TestIdentifier", "testidentify", "testIdentify", "testAuthentify", "testidentity", "Testidentification", "TestIdentify", "testPersonifier", "testIdentity", "Testidentity", "testPersonify", "testPersonification", "Testidentifier", "testidentifier", "TestIdentification", "Testidentify"], "username": ["address", "url", "sudo", "account", "token", "job", "whatever", "login", "uno", "uin", "ame", "sword", "verb", "utf", "nil", "your", "plugin", "users", "host", "filename", "creator", "string", "name", "ui", "profile", "month", "driver", "word", "prefix", "database", "character", "company", "purpose", "nick", "ug", "mobile", "hello", "uri", "property", "person", "rue", "staff", "consumer", "usr", "subject", "USER", "email", "ername", "uid", "home", "uu"], "password": ["picture", "hash", "address", "sudo", "params", "account", "token", "Password", "cache", "description", "login", "w", "sword", "security", "wallet", "session", "filename", "patch", "string", "name", "profile", "seed", "word", "driver", "prefix", "database", "auth", "words", "crypt", "null", "text", "diff", "pad", "padding", "attribute", "p", "wd", "key", " passwords", "mac", "phrase", "PASS", "fax", "email", "secret", "pass", "value", "Pass"], "md5": ["dd5", " mdob", "MD512", "MD3", "dd2", "ddob", " md75", "sha1", "MDob", "md512", "MD75", "MD4", "sha5", "sha512", "MD2", "mdob", " md1", " md512", "md2", "md75", "MD1", " md2", "md1", "sha3", "sha4", "sha75", " md4", "md3", "md4", "MD5", " md3", "dd512"], "logServiceMock": ["logServiceAMock", "logServiceMocked", "logServiceManagerock", "logServiceMOCK", "logServiceManock", "logServiceBOCK", "logServiceManocker", "logModuleMock", "logServiceAMocker", "logServiceFocker", "logServicePocks", "logClientBock", "logServiceAMocked", "logServicemOCK", "logServicePick", "logServiceMocker", "logServiceFocks", "logServiceManocks", "logServiceVocker", "logClientMocker", "logServiceBock", "logServiceVck", "logServiceFOCK", "logModuleMocker", "logClientBck", "logServiceVock", "logServiceAMOCK", "logModuleMOCK", "logServiceBck", "logServiceFck", "logServiceManagerOCK", "logClientBocker", "logServiceMick", "logServiceManagerocker", "logModulePocks", "logServiceFock", "logModuleMocks", "logServiceManocked", "logClientMOCK", "logServiceMck", "logModuleManock", "logServiceMocks", "logModulePOCK", "logServiceBick", "logClientBOCK", "logServicePock", "logModuleManocker", "logModuleMick", "logServicemick", "logServicemock", "logClientMck", "logServiceBocker", "logModulePock", "logServiceVocks", "logModuleManOCK", "logModulePick", "logServiceVOCK", "logClientMock", "logServiceBocks", "logServiceFocked", "logModuleManocks", "logServicemocks", "logServiceManagerocks", "logServicePOCK", "logServiceManOCK"], "dbServiceMock": ["dbServiceCMocker", "dbServiceFox", "dbServiceManick", "dbServicemock", "dbServicesManock", "dbClientFOCK", "dbservicemox", "dbserviceMOCK", "dbClientFock", "dbServicesMox", "dbServiceMocker", "dbServiceCMock", "dbServicesMocker", "dbServiceDocker", "dbClientMocked", "dbServiceManagerOCK", "dbServicemocker", "dbServicemox", "dbserviceMox", "dbServiceBox", "dbServicesMick", "dbClientMick", "dbServiceDock", "dbServiceMick", "dbServiceCMocked", "dbServiceBocker", "dbServiceManagerocker", "dbServiceDick", "dbServiceManagerock", "dbServiceMocked", "dbClientMOCK", "dbServiceVocker", "dbServiceFOCK", "dbServiceVox", "dbServiceManock", "dbServiceMOCK", "dbServiceFocked", "dbservicemock", "dbServicesManick", "dbServiceVock", "dbServiceVOCK", "dbServicesMock", "dbClientMock", "dbServiceManox", "dbServicesManox", "dbClientFick", "dbServicemOCK", "dbservicemocker", "dbserviceMock", "dbServiceDOCK", "dbServiceFock", "dbServiceVick", "dbServiceFick", "dbServiceFocker", "dbServiceCMick", "dbserviceMocker", "dbServiceBock", "dbServicemick", "dbClientMocker", "dbServicemocked", "dbServiceManagerick", "dbClientFocked", "dbServiceManocker", "dbServiceBOCK", "dbServiceMox", "dbServicesManocker", "dbservicemOCK", "dbClientFocker"], "user": ["result", "client", "account", "token", "job", "follow", "login", "project", "use", "current", "proxy", "model", "db", "log", "User", "creator", "row", "plugin", "name", "profile", "ee", "bug", "lock", "auth", "or", "you", "type", "info", "connection", "real", "class", "role", "object", "rule", "config", "per", "usa", "api", "person", "resource", "key", "by", "other", "page", "me", "usr", "data", "server", "up", "USER", "match", "member", "instance", "pass", "record", "blog", "author"]}}
{"id1": "6009527", "id2": "11546108", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadInstachment", "doFinishloadAttachment", "doFinishLoadInstortion", "doFinishLoadInstment", "doFinishloadAttment", "doFinishloadAttachments", "doFinishLoadInstments", "doFinishloadAttments", "doFinishloadAttortion", "doFinishLoadAttachortion", "doFinishLoadAssment", "doFinishLoadAttment", "doFinishloadAttachortion", "doFinishLoadAssments", "doFinishLoadAttachments", "doFinishLoadAttachachment", "doFinishLoadAssachment", "doFinishLoadAssortion", "doFinishLoadAttortion", "doFinishloadAttachachment", "doFinishLoadAttments"], "attachmentId": ["attentionType", "adociationId", "attlementType", "attentionid", "attentionID", "adachmentId", "adachmentPath", "attimagePath", "ttachmentId", "attachmentid", "ttachmentid", "AttachmentID", "attociationID", "attimageInfo", "attociationPath", "attachmentPath", "attentionPath", "attociationInfo", "adociationPath", "ttociationID", "adociationInfo", "adachmentID", "attentionInfo", "attimageID", "ttachmentID", "Attachmentid", "attlementId", "ttociationid", "attachmentType", "adociationID", "attplementationID", "attentionId", "attachmentID", "AttachmentId", "attachmentInfo", "AttachmentType", "attplementationId", "adachmentInfo", "attplementationid", "attimageId", "attociationid", "attociationId", "attlementID", "ttociationId", "attlementid"], "attachment": ["adment", "attached", "assention", "instachment", "instruction", "attachention", "adached", "attment", "assment", " adaptention", "appachment", "attachruction", " attment", "instment", "assached", "adachment", "appention", "adention", "appruction", "attociation", "attruction", " attociation", "attachachment", " attention", "attachached", "appment", "attention", " adaptociation", " adaptment", "instention", "assachment", "association", " adaptachment"], "attachmentUri": ["attachmentAri", "attachmentAti", "attachmentSuris", "attachmentSuURI", "attachmentURI", "attachmentCuuri", "attachmentSuti", "attmentUuri", "attachmentEri", "attachmentEti", "attachedARI", "attachedUri", "attachmentEuri", "attachedUuri", "attachmentERI", "attmentIURI", "attachmentCuri", "attachmentIri", "attachmentUris", "attmentUris", "attachmentSuRI", "attachmentUti", "attachedAuri", "attachmentUURI", "attmentIri", "attachedURI", "attachmentIris", "attachmentIuri", "attachedUti", "attachmentSuuri", "attmentUURI", "attachedAri", "attachmentARI", "attachmentUuri", "attachmentSuri", "attachmentAuri", "attmentIris", "attmentIuri", "attachmentCuURI", "attachmentCuris", "attmentUri", "attachedAti", "attachmentIURI"], "contentUri": ["contentIuri", "resourceUri", "contentFileuri", "resourceUi", "contentCuri", "contentIri", "contentURi", "contentIi", "contentURI", "contentSuris", "contentCri", "resourceURI", "contentUuri", "contentSuri", "resourceIi", "resourceIri", "contentUdi", "contentSudi", "resourceUris", "contentURuri", " contentSuri", "resourceIRI", "resourceUuri", " contentSuris", "contentUi", "contentUsri", " contentSudi", "contentUsris", " contentSuRI", "contentCRI", " contentURI", "contentUsRI", "contentCi", "contentFileRI", "contentFileri", "contentIris", "contentFileris", "contentIRI", "resourceIuri", "contentCdi", "contentURris", "resourceIris", "contentURri", " contentUdi", "contentUsdi", "contentSuRI", "contentUsuri", "contentUris", " contentUris", "contentCris"], "file": ["ger", "picture", "fp", "url", "base", "FILE", "reader", "cache", "local", "output", "view", "use", "zip", "io", "load", "child", "model", "path", "folder", "log", "input", "filename", "auto", "name", "binary", "able", "stream", "to", "image", "this", "upload", "files", "entity", "via", "File", "connection", "pe", "b", "object", "handler", "socket", "buffer", "uri", "resource", "get", "copy", "content", "single", "line", "data", "source", "up", "letter", "work", "create", "unit", "book", "f", "le"], "in": ["url", "gin", "ins", "din", "reader", "IN", "login", "e", "bin", "id", "io", "inc", "ini", "input", "In", "s", "conn", "inner", "binary", "image", "c", "err", "this", "m", "or", "a", "i", "r", "connection", "b", "again", "o", "pull", "socket", "sync", "nin", "win", "inn", "pin", "copy", "cli", "data", "source", "up", "init", "ac", "con", "as", "f"], "out": ["net", "exec", "base", "OUT", "client", "outs", "IN", "cache", "output", "bin", "view", "io", "inc", "one", "log", "conn", "s", "on", "inner", "In", "ext", "to", "lock", "err", "image", "this", "Out", "writer", "connection", "i", "b", "null", "again", "ex", "o", "socket", "sync", "nin", "outer", "resource", "by", "copy", "line", "data", "page", "up", "source", "cli", "init"], "intent": ["activation", "feature", "ani", "Activity", "activate", "animate", " Intent", "term", "xml", "request", "ents", "context", "language", "contact", "effect", "action", "spirit", "this", "anim", "acc", "entity", "event", "element", "ent", "text", "object", "impact", "category", "enc", "anc", "eng", "concept", "vent", "inst", "advert", "android", "agent", "it", "content", "document", "feat", "entry", "focus", "act", "ant", "init", "ink", "intention", "activity", "ctx", "response"]}}
{"id1": "2521141", "id2": "18489832", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "label": 1, "substitutes": {"copy": ["share", "change", "delete", "paste", "rm", "transfer", "ame", "zip", "Copy", "load", "ge", "cp", "archive", "image", "write", "link", "upload", " cp", "type", "pe", "cop", "directory", "ignore", "config", "sync", "diff", "update", "clip", "ize", "open", "get", "source", "move", "file", "download", "create", "dump", "cat", "attach", "clone", "opy"], "from_name": ["fromMnames", "from__memory", " from_key", "from_Name", "to_path", "source_memory", "source_name", "from__name", "from_path", " from_Name", "from_filename", "to_filename", "from_key", "source_filename", "fromFname", "fromFmemory", "fromFpath", "from_memory", "fromFfilename", " from_names", "fromMname", "fromMfile", "from__filename", "from__path", "from_names", "source_path"], "to_name": ["to_filename", "toamfile", "toampath", " to_home", "to_path", "to_Name", " to_path", "to_home", "from_path", "from_filename", "toamname", " to_Name", "toamhome"], "from_file": ["remote_lane", "from_folder", " from_directory", "source_brain", "fromappfunction", " from_auto", "from_auto", " from__file", "from_files", "remote_log", "fromapplane", "remote_function", "source_file", "from_directory", "from_function", "from__files", "fromCfile", "source_name", "fromCfilename", " from_source", "fromCname", "from__name", "fromappfile", "from_filename", "fromCbrain", "from___name", "from__directory", "from__resource", "source_files", " from__auto", "source_filename", " from__name", "source_directory", "from_brain", " from_folder", "from___filename", "from_log", "fromapplog", "from_source", "source_resource", " from__filename", " from_filename", "remote_file", "from__auto", "from__filename", " from_files", "from___file", "from_resource", "from___auto", "from_lane", "from__file"], "to_file": ["to__load", " to_files", "intojfile", "to64function", "toJbar", "eto_name", "from_stream", " to_class", "to67dir", "to_server", "to_files", "source_server", "toJfile", "from_files", "to___file", "intojuse", "from_dir", "into_file", "tojuse", "intojfunction", "source_file", "into_name", "to___name", "tojfunction", "to_load", "to67file", "eto___file", "to_bar", "to_dir", "into_function", "from_model", "to67name", "to__file", "eto_file", "to_class", "to_stream", "to_filename", "to_remote", "from_binary", "tojfile", "to_queue", " to_model", "into_use", "source_files", "to_use", "source_filename", " to_filename", "to_model", "eto___name", "tojname", "to64use", "toJname", "eto_remote", "to__dir", "from_bar", "to___remote", "to64name", "eto___remote", "to_function", " to_queue", "to67load", "to__name", "intojname", "from_load", "to64file", "toJstream", "to_binary"], "parent": ["test", "address", "pa", "cache", "port", "id", "inc", "path", "am", "div", "session", "location", "name", "global", "null", "directory", "api", "p", "file", "server", "full", "Parent", "mother", "part", "size", "author", "complete", "client", "child", "term", "old", "folder", "function", "remote", "target", "patch", "string", "memory", "or", "user", "rule", "tree", "page", "pool", "ac", "current", "container", "parents", "ppa", "per", "loc", "uri", "resource", "content", "search", "source", "home", "unit", "temp", "url", "ip", "owner", "host", "out", "type", "connection", "root", "par", "any", "handler", "point", "manager", "fat", "po"], "dir": ["md", "url", " directory", "dec", "ver", "cache", "rel", "dep", "Dir", "id", "exp", "io", "dict", "container", "cur", "db", "path", "folder", "div", "keep", "name", "out", "ir", "lock", "doc", "build", "or", "global", "r", "def", "root", "class", "user", "directory", "object", "tr", "per", "loc", "block", "iter", "dc", "dis", "wd", "dr", "di", "in", "data", "entry", "file", "nav", "d", "director", "coll", "die", "dev", "group", "home", "part", "cat", "manager", "f", "module"], "from": ["two", "address", "url", "cm", "cf", "base", "ra", "client", "cache", "bean", "vol", "parse", "left", "e", "view", "feed", "io", "cor", "ou", "when", "one", "auto", "name", "conn", "cr", "start", "stream", "range", "context", "link", "this", "fe", "self", "normal", "or", "component", "connection", "pe", "so", "empty", "with", "find", "per", "flo", "without", "fr", "api", "add", "by", "form", "get", "http", "who", "source", "entry", "file", "se", "ch", "low", "From", "server", "con", "part", "can", "ce"], "to": ["su", "two", "base", "client", "ver", "token", "output", "io", "proxy", "not", "db", "one", "fb", "TO", "target", "session", "auto", "out", "conn", "on", "top", "write", "storage", "or", "via", "t", "type", "connection", "To", "so", "o", "dest", "co", "thro", "socket", "per", "flo", "see", "sync", "office", "will", "api", "by", "with", "store", "http", "too", "op", "file", "server", "tto", "value", "until", "that", "about", "as", "size", "fat", "pi", "po"], "buffer": ["Buffer", "address", "position", "url", "header", "uffer", "reader", "bb", "window", "transfer", "feed", "total", "default", "row", "border", "length", "seed", "binary", "memory", "queue", "character", "read", "layer", "duration", "reference", "writer", "batch", "b", "shape", "buf", "number", "null", "slice", "block", "padding", "message", "iter", "resource", "wave", "flush", "document", "page", "data", "channel", "source", "server", "variable", "comment", "buff", "texture"], "bytes_read": ["bytes___pass", "bytesXload", "bytes___reads", "bytes_reads", "byte_load", "byte_before", "gets___pass", "gets_read", "gets___reads", "bytes_en", "gets_reads", "byteslexread", "bytesXcurrent", "bytes_load", "byteslexcurrent", "bytesXread", " bytes_write", "bytes_pass", "bytes_write", "bytes_allow", "gets_allow", "byte_current", "gets___read", "bytes_before", "bytes_current", " bytes_en", "byteslexload", "bytes_found", "byte_read", " bytes_found", "gets___allow", "byteslexbefore", "bytes___read", "gets_pass", "bytesXbefore", "bytes___allow"]}}
{"id1": "13362846", "id2": "19549577", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 0, "substitutes": {"setContenu": ["setTonenues", "setContineu", "setTonenuit", "setContennuer", "setContonenues", "setContineuit", "setContenuer", "setTonenu", "setContonenuit", "setContonenu", "setContineuer", "setContennues", "setTenu", "setTenuer", "setContennuit", "setContineues", "setTonenuer", "setTenues", "setContonenuer", "setTenuit", "setContenuit", "setContenues", "setContennu"], "contenuFichier": ["contenuFicie", "contenuFicher", "contenuFichieri", "contenuPhichiere", "contenuFchier", "contenuFicheier", "contenuFaffier", "contenuFrenchoyer", "contenuMichiers", "contenuTicheier", "contenuFiciere", "contenuPhactoryiere", "contenuFrenchie", "contenuPhactoryier", "contenuFicheerer", "contenuFrenchery", "contenuFactoryier", "contenuFcherer", "contenuMichie", "contenuMichier", "contenuMichieri", "contenuFicheieri", "contenuFicheiere", "contenuFichoyer", "contenuPFochiere", "contenuMrenchiere", "contenuFochiere", "contenuMrenchique", "contenuPhactoryoyer", "contenuFocher", "contenuFactoryie", "contenuPhichier", "contenuFrenchiere", "contenuPrefaffier", "contenuFicheery", "contenuTicherer", "contenuPrefaffiere", "contenuFaffiers", "contenuFrenchique", "contenuFrenchier", "contenuPFocher", "contenuPFichier", "contenuPrefaffie", "contenuFicoyer", "contenuPrefichie", "contenuMichiere", "contenuFaffer", "contenuPrefichier", "contenuFichtie", "contenuPrefichiere", "contenuFicheique", "contenuFichiere", "contenuTicheiere", "contenuPFichique", "contenuFichie", "contenuPFicher", "contenuFrenchiers", "contenuPFochique", "contenuFrencherer", "contenuFichery", "contenuMrenchie", "contenuPrefichiers", "contenuFochier", "contenuFicheer", "contenuFochiers", "contenuTicheery", "contenuTicheerer", "contenuFaffique", "contenuMrenchier", "contenuFicherer", "contenuMichique", "contenuMaffiere", "contenuTichery", "contenuPFochier", "contenuFactoryiere", "contenuFichtieri", "contenuFicheie", "contenuMaffie", "contenuTichiere", "contenuFochique", "contenuFchiere", "contenuFactoryoyer", "contenuFaffieri", "contenuFchery", "contenuMaffier", "contenuFaffie", "contenuPrefaffiers", "contenuFichtiere", "contenuTichier", "contenuMaffiers", "contenuPFichiere", "contenuFichtier", "contenuPhichoyer", "contenuFichtique", "contenuFichique", "contenuFaffiere", "contenuFochie", "contenuFichiers", "contenuPhichie", "contenuPhactoryie", "contenuFicier", "contenuMaffieri"], "fichierElectronique": ["fichierElectonier", "fichierAdministronistic", "fichierElectroneiques", "fichierElectronsique", "fichierAdministronsie", "fichierElectoloniere", "fichierCentronlique", "fichierAdministronsical", "fichierAdministronique", "fichierElectron\u00e9e", "fichierElectrons\u00e9e", "fichierElectproniques", "fichierElectonie", "fichierElectronslique", "fichierAdministrons\u00e9e", "fichierElectromical", "fichierElectolonique", "fichierElectronica", "fichierElectolonica", "fichierElectromique", "fichierElectroneique", "fichierAustroniques", "fichierElectornlique", "fichierElectromiques", "fichierElectrolica", "fichierAdministronical", "fichierCentronique", "fichierElectroliere", "fichierElectronsiques", "fichierElectornier", "fichierElectronsiere", "fichierCentroniques", "fichierCentronier", "fichierElectrolique", "fichierElectronsie", "fichierElectronsier", "fichierAustroliques", "fichierElectaronie", "fichierAustroniere", "fichierElectorniques", "fichierElectronlique", "fichierAdministronie", "fichierElectaron\u00e9e", "fichierCentorniques", "fichierElectronier", "fichierElectpronical", "fichierElectpronique", "fichierAdministronslique", "fichierAdministronsier", "fichierAustrolier", "fichierCentornier", "fichierElectronistic", "fichierAdministronsiques", "fichierElectronical", "fichierAustroliere", "fichierCentornique", "fichierAustrolique", "fichierElectronsica", "fichierAdministronlique", "fichierElectoloniques", "fichierElectronie", "fichierAustronier", "fichierElectroneiere", "fichierAdministroniques", "fichierElectpronistic", "fichierElectroneie", "fichierElectronelique", "fichierElectaronique", "fichierAustronique", "fichierElectrolie", "fichierElectaronier", "fichierCentornlique", "fichierAdministron\u00e9e", "fichierElectromistic", "fichierElectronsistic", "fichierElectrolier", "fichierElectonique", "fichierElectrol\u00e9e", "fichierAdministronsique", "fichierElectroniere", "fichierElectornique", "fichierElectroliques", "fichierAdministronier", "fichierElectroneier", "fichierAdministronsistic", "fichierElectroniques", "fichierElectonlique", "fichierElectronsical"], "utilisateurCourant": ["utilisateurApplicants", "utilisationApplicante", "utilisateurGovernants", "utilisateurGovernateur", "utilisationApplicateur", "utilisateurParticipante", "utilisationApplicant", "utilisateurApplicateur", "utilisationCourateur", "utilisateurParticipateur", "utilisateurCourateur", "utilisateurGovernant", "utilisateurApplicante", "utilisationCourante", "utilisationCourants", "utilisationApplicants", "utilisateurParticipants", "utilisateurGovernante", "utilisateurParticipant", "utilisationCourant", "utilisateurApplicant", "utilisateurCourante", "utilisateurCourants"], "support": ["feature", "knowledge", "services", "share", "client", "system", "util", "ann", "allow", "force", "proxy", "cover", "respect", "know", "plugin", "contact", "supported", "friend", "bank", "facebook", "storage", "Library", "format", "supp", "info", "library", "evidence", "best", "Support", "config", "protection", "concept", "pull", "service", "media", "document", "review", "compatible", "accept", "push", "help", "summary", "utils", " Support", "control", "pport", "settings"], "ficheDocument": ["infraudNumber", "ficheFeature", "FicheContent", "fchaDoc", "affineDocument", "fcheDocuments", "fcheDoc", "enficheCatalog", " fcheDocument", " ficheDocuments", "FcheDoc", "foineFeature", "fruitDocument", "afficheFeature", "fielDocument", "affineDoc", "enfoiceDirectory", "fcheDocument", "enficheDocument", " fcheDirectory", "enfoiceDocument", "foiceCatalog", "financedocument", " ficheMatrix", " ficheDirectory", "fruitdocument", "facheMatrix", "affineFeature", "inficheDoc", "fraudDoc", "fetchDoc", "fichedocument", "ficheDoc", "fruitNumber", "fetchFeature", "inficheDocument", "fraudCatalog", "fcheDirectory", "fcheContent", "enfoiceCompany", "foinedocument", "affichedocument", "fcheMatrix", "FcheContent", "Fichedocument", "FcheDocument", "frauddocument", "infraudDocument", "affinedocument", "friqueDoc", "fraudDirectory", "enficheCompany", "ficheContent", "infrauddocument", "friquedocument", " fcheDocuments", "finedocument", "fraudDocument", "financeDoc", "FicheDocument", "ficheCompany", "financeNumber", "ficheMatrix", " fcheMatrix", "fchaContent", "enfoiceCatalog", "foiceDirectory", "fagueDocument", "FicheDoc", "fielDirectory", "infichedocument", "friqueDocument", "fielCatalog", "facheDocuments", "foineDoc", "afficheDoc", "Fchedocument", "ficheDirectory", "fchadocument", "financeDocument", "afficheDocument", "infraudDoc", "fielCompany", "foiceDocument", "foiceCompany", "inficheNumber", "ficheDocuments", "friqueContent", "fruitDoc", "fineFeature", "fetchdocument", "foineDocument", "fetchDocument", "ficheCatalog", "fineDocument", "enficheDirectory", "fineDoc", "fchedocument", "fraudCompany", "fagueMatrix", "fagueDirectory", "facheDirectory", "ficheNumber", "fagueDocuments", "fchaDocument", "fraudNumber", "facheDocument"], "nomFichier": ["nomFitherer", "nomFichtiller", "nomPrefichieri", "nomWchire", "nomWchiere", "nomPchy", "nomVichieri", "nomPrefchire", "nomFichiner", "nomVch\u00e8re", "nomFiquier", "nomPchien", "nomFiscier", "nomFachire", "nomNichtiner", "nomFichtire", "nomPrefichier", "nomPhachier", "nomFichtieri", "nomFichire", "nomVich\u00e8re", "nomNichier", "nomPhicherer", "nomPrefichire", "nomFachieri", "nomWichire", "nomPhacherer", "nomFiscery", "nomFichery", "nomPrefchieri", "nomPchier", "nomFichien", "nomPichery", "nomFochiere", "nomPhachieri", "nomVcher", "nomFichtery", "nomNichiner", "nomFachiller", "nomFchiere", "nomFchrier", "nomFiscy", "nomFchy", "nomPchery", "nomFchien", "nomFich\u00e8re", "nomFithier", "nomFrenchieri", "nomPichien", "nomFichiere", "nomVchieri", "nomFach\u00e8re", "nomWchier", "nomPhichieri", "nomFisciner", "nomFachrier", "nomFacher", "nomF\u00e9tien", "nomFiscien", "nomPhachiere", "nomNicher", "nomWichier", "nomPhichier", "nomFachiere", "nomPhichiere", "nomNichtier", "nomFiqurier", "nomFithiere", "nomFicherer", "nomFochier", "nomFachiner", "nomNichter", "nomFisciller", "nomWichery", "nomFchire", "nomVicher", "nomF\u00e9ty", "nomPichy", "nomFrencher", "nomFichter", "nomFiquieri", "nomFichy", "nomFithieri", "nomFcher", "nomFrench\u00e8re", "nomPrefchrier", "nomWichiere", "nomVchier", "nomFchieri", "nomFichtiere", "nomPrefchier", "nomVichier", "nomFch\u00e8re", "nomPrefichrier", "nomFachier", "nomFchery", "nomFichtier", "nomPichier", "nomFichrier", "nomFacherer", "nomNichtiller", "nomWchery", "nomFochery", "nomFicher", "nomFichterer", "nomFichieri", "nomFchier", "nomF\u00e9tery", "nomFiquire", "nomF\u00e9tier", "nomFrenchier", "nomNichiller", "nomFichtiner", "nomFichiller", "nomFochire", "nomFiscer"], "extension": ["anchension", "encension", "EXTime", "EXTension", "Extension", "extensions", "anchime", "encression", "Extime", "exception", "Extion", "exension", "extression", "anchensions", "exression", "Extensions", "extion", "exion", "extime", "Extception", "EXTensions", "encception", "Extression", "extception", "encion"], "fichierElectroniqueExistant": ["fichierElectroniqueXivist", "fichierElectroniqueExplists", "fichierElectroniqueExplclusive", "fichierElectroniquesExistance", "fichierElectroniqueexilingual", "fichierElectroniquesExists", "fichierElectroniqueExclusive", "fichierElectroniqueXistance", "fichierElectroniqueExplistance", "fichierElectroniquesXclusive", "fichierElectroniqueSistance", "fichierElectroniqueexists", "fichierElectroniqueExivist", "fichierElectroniqueExilingual", "fichierElectroniquesExist", "fichierElectroniqueexist", "fichierElectroniqueExplivist", "fichierElectroniqueExists", "fichierElectroniqueExist", "fichierElectroniqueXclusive", "fichierElectroniqueExplistant", "fichierElectroniqueXistent", "fichierElectroniqueSistent", "fichierElectroniqueSilingual", "fichierElectroniqueExistance", "fichierElectroniquesXist", "fichierElectroniqueExistent", "fichierElectroniqueXistant", "fichierElectroniquesXists", "fichierElectroniqueXists", "fichierElectroniqueexistance", "fichierElectroniquesXistance", "fichierElectroniqueXilingual", "fichierElectroniqueXist", "fichierElectroniquesExilingual", "fichierElectroniqueSistant", "fichierElectroniqueexclusive", "fichierElectroniquesExclusive", "fichierElectroniquesXilingual", "fichierElectroniqueexivist", "fichierElectroniquesExistent", "fichierElectroniqueexistent", "fichierElectroniquesXistent", "fichierElectroniqueexistant", "fichierElectroniquesXivist", "fichierElectroniquesExivist", "fichierElectroniquesXistant", "fichierElectroniquesExistant", "fichierElectroniqueExplist"], "idIgid": ["idEGdid", "idIgenID", "idIGid", "idIgID", "idUguid", "idIgname", "idIgdid", "idEGids", "idUguids", "idUguname", "idUgname", "idIgnod", "idIogbit", "idIggod", "idUgID", "idIgids", "idIgmid", "idIGbit", "idIogids", "idIguid", "idEgid", "idIgnid", "idIguname", "idIgenids", "idEGid", "idIogid", "idEgbit", "idUguID", "idIGdid", "idIggid", "idIgubit", "idIgmname", "idIgmID", "idIggID", "idUgid", "idEgids", "idIgbit", "idIgenid", "idIogdid", "idIgmids", "idIgnID", "idIGids", "idIgnids", "idIggids", "idIgudid", "idEgdid", "idIguID", "idIguids", "idIgod", "idEGbit", "idIgenname", "idUgids", "idIguod"], "inputStream": ["InputLength", "inputThread", "outputThread", "inputSteam", "eventSteam", "eventStreamer", " inputstream", "outputStreamer", "InputThread", " inputSteam", " inputThread", "outputSteam", "eventStream", "outputLength", "InputStreamer", "Inputstream", "outputstream", "eventstream", " inputLength", "inputLength", "InputSteam", "inputstream", "inputStreamer", "InputStream"], "outputStream": ["outputContext", " outputstream", " outputSteam", "inputSteam", " outputContext", "officeSteam", "outputStreamer", "OutputSteam", "officestream", "OutputStream", "officeStream", "outputSteam", "OutputStreamer", "inputContext", "officeStreamer", "entitystream", "entityStreamer", "entitySteam", "outputstream", "Outputstream", "inputstream", "entityStream", "OutputContext", "inputStreamer"], "typeMime": ["typeMetide", "typeMatangle", "TypeSmimes", "typeSmangle", "typeMetimes", "typeMetime", "TypeMimes", "typeSmime", "typeMangle", "TypeSmangle", "typeSmimes", "typeMatimes", "typeMatime", "typeMimes", "TypeMide", "typeMatide", "typeSmide", "TypeMangle", "TypeMime", "TypeSmime", "typeMetangle", "TypeSmide", "typeMide"], "tailleFichier": [" tailleFichiers", " tailleFignier", " tailleFichie", " tailleFicheie", " tailleFigner", " tailleFicheier", " taillefochier", " taillefichiers", " tailleFocher", " taillefochie", " taillefichie", " tailleFochie", " tailleFicheer", " tailleFicher", " tailleFochier", " tailleficher", " tailleFignie", " taillefocher", " tailleFochiers", " tailleFicheiers", " tailleFigniers", " taillefichier", " taillefochiers"]}}
{"id1": "17791385", "id2": "3187685", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "src": ["url", "sit", "ipl", "st", "img", "ins", "sup", "sl", "input", "filename", "s", "ls", "stream", "obj", "image", "upload", "files", "sel", "sb", "b", "sin", "dest", "back", "config", "loc", "inst", "uri", "resource", "inf", "rb", "http", "rc", "source", "file", "sc", "dist", "txt"], "dst": ["fdst", "ddst", "Dlt", "ddest", "ddfd", "pdsp", "Dsts", "ddsp", "pdft", "ststs", "dft", "fdsp", "dlt", " dlt", "stdest", "Dst", "fdfd", "dsp", "ddft", "pdfd", "dfd", " ddest", "stst", "Ddest", "stlt", "dsts", "pdst", "fdft", " dsts"], "in": ["url", "gin", "ins", "din", "reader", "IN", "login", "bin", "id", "inc", "ini", "input", "In", "conn", "inner", "ln", "err", "oin", "m", "i", "r", "n", "again", "sin", "pull", "socket", "nin", "win", "inn", "pin", "h", "is", "cin", "lin", "data", "file", "init", "inside", "kin", "rin", "con", "impl", "as", "f"], "out": ["net", "exec", "OUT", "client", "outs", "cache", "w", "output", "bin", "exp", "io", "inc", "raw", "x", "conn", "s", "ext", "obj", "err", "off", "Out", "plain", "self", "at", "writer", "i", "ex", "n", "again", "parent", "o", "null", "sync", "post", "outer", "copy", "other", "line", "file", "up", "server", "part", "f", "temp"], "buf": ["vec", "uf", "v", "cap", "bc", "base", "uc", "bb", "bin", "br", "bd", "raw", "cur", "ctx", "val", "fb", "fl", "length", "seq", "cmd", "queue", "c", "off", "bl", "bag", "batch", "count", "b", "ff", "loc", "pad", "wb", "buffer", "bytes", "rb", "fd", "rc", "data", "bh", "bf", "lim", "cat", "cb", "buff"], "len": ["cap", "lc", "cl", "base", "bin", "el", "Len", "val", "sl", "fl", "length", "ind", "li", "fin", "name", "ln", "end", "no", "c", "err", "all", "en", "i", "count", "n", "ll", "nt", "ix", "fd", "lf", "line", "data", "l", "lin", "pos", "lt", "lim", "split", "part", "size", "f", "le", "rev"]}}
{"id1": "18046717", "id2": "20210699", "code1": "    private String getFullClassName(URL url, String className) throws Exception {\n        JarInputStream jis = new JarInputStream(url.openStream());\n        ZipEntry zentry = null;\n        while ((zentry = jis.getNextEntry()) != null) {\n            String name = zentry.getName();\n            int lastPos = name.lastIndexOf(\".class\");\n            if (lastPos < 0) {\n                continue;\n            }\n            name = name.replace('/', '.');\n            int pos = -1;\n            if (className != null) {\n                pos = name.indexOf(className);\n                if (pos >= 0 && name.length() == pos + className.length() + 6) {\n                    jis.close();\n                    return (name.substring(0, lastPos));\n                }\n            }\n        }\n        jis.close();\n        return (null);\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"getFullClassName": ["getFullFilePath", "getShortClassname", "getFullClassNames", "getFullclassNames", "getShortclassname", "getFullFileNames", "getFullclassName", "getShortClassNames", "getShortclassPath", "getFullFullPath", "getFullClassPath", "getFullFullNames", "getFullFilename", "getFullFullname", "getFullclassPath", "getFullClassname", "getFullFullName", "getShortclassNames", "getShortClassName", "getFullclassname", "getShortClassPath", "getFullFileName", "getShortclassName"], "url": ["address", "base", "job", "feed", "io", "URL", "jar", "path", "sl", "Url", "host", "location", "string", "gl", "bug", "image", "org", "or", "ssl", "connection", "html", "user", "loc", "loader", "ur", "uri", "service", "lr", "date", "resource", "http", "l", "page", "source", "server", "file", "entry", "src"], "className": ["ClassType", "classCode", "classNumber", "ClassPath", "objectNames", "sourcename", "typeLine", "typeNumber", "sectionType", "classname", " classNumber", "shortNumber", "shortname", "sourceName", " classType", "sectionname", "fullname", "typename", " classCode", " classname", "classPath", "shortName", "classNAME", "classNames", "fullCode", "fullPath", "sourceNAME", "sectionName", "ClassName", "typeName", "objectname", "classType", " classLine", " classPath", "Classname", "fullName", " classNAME", " classNames", "objectNAME", "classLine", "ClassCode", "sectionPath", "objectName", "shortLine", "sourceNames"], "jis": ["jois", "ajis", "ajiss", "zris", " jas", "zas", "zists", " ji", "jetais", "ajris", "ajais", "jris", "zais", "joais", "joiss", "Jiss", "jists", "zi", "joris", "jetis", " jais", "zis", "jetas", "jetris", "ajists", " jists", " jiss", "jas", "jais", "Jis", "jiss", "ji", "Ji", "Jais", " jris", "ziss"], "zentry": ["zerentry", " zconnection", "zoEntry", "gzenter", "lenter", "zpie", "zester", "zenter", "zoconnection", " zpart", "zoenter", "zerenter", "zpart", "jpie", "jEntry", "zconnection", "zEntry", "gzEntry", "lester", "gzconnection", "zerester", "jentry", "ezentry", "lfile", "ezpie", "ezpart", " zEntry", "gzentry", "ezEntry", " zester", "lentry", "zoentry", " zfile", " zpie", "zfile", " zenter", "zerfile", "jpart"], "name": ["address", "base", "error", "alias", "clean", "now", "str", "e", "comment", "ame", "id", "none", "old", "Name", "path", "x", "one", "space", "default", "filename", "start", "string", "s", "end", "inner", "named", "word", "size", "prefix", "no", "image", "code", "type", "info", "i", "connection", "class", "number", "n", "object", "date", "api", "common", "key", "ix", "search", "l", "in", "entry", "data", "file", "work", "style", "up", "pass", "value", "home", "names", "part", "NAME", "f"], "lastPos": [" lastRes", "finalIndex", "nextPos", "fullPos", "lastpos", "fullPosition", " lastPart", "nextIndex", "lastLen", "firstPosition", "fullpos", "finalRes", "firstpos", "nextPart", "firstPart", "lastRes", "nextRes", "lastPart", "lastIndex", " lastPosition", "nextLen", " lastLen", "firstPos", "lastPosition", " lastpos", "nextpos", "finalPos", "finalLen", "firstLen", " lastIndex", "fullLen"], "pos": ["position", "nos", "pro", "fun", "pose", "none", "x", "pt", "index", "val", "pointer", "start", "length", "end", "offset", "seq", "no", "len", "spec", "doc", "off", "os", "Pos", "j", "neg", "i", "count", "eff", "ps", "loc", "diff", "cond", " position", "post", "POS", "p", "ix", "is", "cos", "line", "col", "push", "act", "style", "limit", "pass", "part", "unit", "size", "rev", "po"]}}
{"id1": "1188100", "id2": "16092702", "code1": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"test": [" testing", "error", "call", "check", " Test", "start", "out", "write", "Test", "testing", "build", "print", "report", "method", "show", "example", "debug", " example", " evaluate", "server", "execute", "create", "fail", "tests", "run"], "s": ["us", "less", "services", "sv", "ms", "outs", "w", "e", "sets", "south", "ts", "rs", "bis", "ws", "es", "sl", "session", "ns", "ks", "out", "abs", "ls", "stats", "state", "stream", "lines", "states", "si", "os", "ses", "storage", "bs", "ssl", "sb", "i", "g", "b", "js", "n", "cs", "ops", "o", "ans", "ps", "sym", "S", "sync", "ds", "fs", "gs", "p", "opens", "service", "h", "its", "is", "l", "in", "source", "server", "d", "ss", "as", "f", "ils", "settings"], "input": ["flow", "reader", "audio", "w", "output", "php", "feed", "io", "raw", "Input", "request", "xml", "out", "stream", "driver", "image", "storage", "read", "ssl", "i", "a", "r", "null", "o", "buffer", "copy", "in", "data", "qa", "source", "up", "instance", "rss", "reading", "response", "temp"], "writer": ["written", "wa", "writ", "reader", "builder", "w", "str", "output", "io", "raw", "wan", "worker", "xml", "ler", "er", "pointer", "string", "out", "word", "writing", "write", "rw", "storage", "wr", "editor", "keeper", "layer", "Writer", "riter", "r", "null", "o", "per", "walker", "wb", "outer", "buffer", "office", "wrapper", "key", "data", "work", "source", "letter", "book", "writers", "WR", "temp"]}}
{"id1": "23672408", "id2": "8135072", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 1, "substitutes": {"copyIconFiles": ["copyFileImages", " copyiconFiles", "copyIconTypes", " copyiconTypes", "copyFileFile", "copyFileTypes", "copyIconFile", "copyIconImages", "copyImageTypes", " copyIconTypes", "copyiconFiles", "copyImageImages", "copyFileFiles", " copyiconFile", " copyiconImages", "copyImageFile", " copyIconFile", " copyIconImages", "copyiconFile", "copyiconTypes", "copyImageFiles", "copyiconImages"], "clazz": ["llasse", "Closs", "helllass", " closed", "clobe", "hellasso", "Cllass", "llaz", "glaz", "slosed", "sluster", "hellobe", "Clazz", "glazz", "cluster", "Claz", "slod", "llobe", " clab", " classo", "Closer", "Clab", " clunk", "clclass", " clclass", "slazz", "CLod", " clobe", " cllass", "clance", "Cluster", "clab", "llclass", "Clclass", "clunk", " clance", "slaz", " classe", " closer", "fluster", "hellazz", "flazz", "sllass", "classe", "classo", "CLazz", "hellasse", "CLance", "plazz", "flunk", "hellance", "CLaz", " closs", "cllass", "closs", "glod", "ploser", "claz", "Clunk", "flaz", " cluster", "clod", "llab", " claz", "closed", "plclass", "hellosed", "glance", "pllass", "llasso", "sloss", "closer", "slance", "llazz"], "i16": ["i24", "I15", "io2016", "ai14", "si2016", "ii24", "l15", "ai15", "ini17", "si15", "l64", "si64", "io15", "io16", "io24", "ini15", "i15", "si14", "ini2016", "i17", "I16", "ini16", "l24", "si16", "ai2016", "ini14", "l16", "int24", "I17", "ai16", "pi24", "ii15", "int15", "ii2016", "i2016", "int16", "i14", "ii14", "i64", "si24", "ii16", "pi16", "I14", "ii17", "int2016", "pi15", "pi64"], "fileType": ["letterState", "iconLength", "fileStyle", "transferFamily", "singleTime", "playTy", " filetype", "fileSpread", " fileTime", "imageFile", "imageKey", "fileTime", "messageType", "FileLocation", "imageStyle", "fileAuth", "fileTy", "fileBlock", "imageType", "imageTime", "wordAuth", "letterTy", "filePath", "filetype", "wordType", " fileTy", "FileType", " fileLength", "feedType", "playType", "messagetype", "FileLike", " fileBlock", "fileInfo", "lettertype", "feedInfo", " fileAuth", "FileFamily", " fileFile", "documentType", "messagePath", "fileLocation", "documenttype", " fileUnit", "wordLength", "singleStyle", "imageUnit", "fileLike", "iconType", "iconKey", "documentBlock", "feedPatch", " fileInfo", "messagePatch", "iconPath", "fileFamily", "letterBlock", "iconStyle", "singleFile", "iconAuth", "fileLength", " fileKey", "feedLocation", "fileFile", "wordTy", " fileLike", "letterFamily", " fileState", " filePatch", "playFamily", " filePath", "FileStyle", "documentState", "imageFamily", "filePatch", " fileStyle", "playSpread", "transferSpread", "transferType", " fileFamily", "transferTy", "feedLike", "fileKey", "letterType", "iconTy", "feedtype", "imagePath", "feedPath", "fileState", "letterSpread", "FileInfo", "FileUnit", "singleType", " fileLocation", "fileUnit"], "desti16": ["destsi64", "destabi15", "combini15", "destf16", "targeti2016", "destI15", "combi15", "destsi32", "desti016", "destf2016", "destI2016", "destini16", "destabi016", "targetI2016", "targetI16", "desti64", "destini64", "combi16", "combini32", "combini16", "desturi64", "destini32", "destI016", "desturi16", "desti2016", "destI16", "combini64", "targeti16", "destsi16", "targetI15", "destsi15", "destf15", "targeti15", "targetI016", "destf016", "desturi15", "targeti016", "destabi2016", "combi64", "desturi32", "desti15", "destini15", "combi32", "destabi16"], "src": ["iv", "st", "tmp", "cur", "filename", "secure", "hub", "sel", "ssl", "desc", "front", "null", "pull", "usr", "thumbnails", "sc", "file", "data", "scenes", "coll", "ctrl", "https", "console", "gb", "cv", "proc", "func", "input", "target", "conv", "s", "pkg", "uv", "b", "video", "ug", "dest", "attr", "back", "grad", "rb", "http", "in", "rl", "cb", "ser", "uc", "sr", "crop", "sl", "stream", "upload", "lib", "sq", "buf", "config", "loc", "socket", "inst", "uri", "resource", "rc", "source", "bh", "download", "gz", "rss", "ource", "sys", "url", "img", "output", "view", "load", "scene", "default", "gl", "image", "r", "root", "cdn", "sync", "support", "rob", "dist", "req", "ctx", "bs", "cmp"], "dst": ["dsdr", "dsost", "idbl", "Dost", "ddest", "Dsts", " dste", "idsc", "dste", "dost", "rdput", "rdst", "idrd", "dsput", "dedst", "dbl", " dput", "dsts", "dsst", "adost", "dput", " dest", "drest", "dct", "dsl", "nste", "ddr", "adct", "adbl", " dbl", "iddest", "ldost", "ldbl", "idest", "dest", "dedput", "Dbl", "ldst", " dST", "idst", "idsl", "nst", "sdsc", "rdST", " drest", " dsc", "nrest", "Dst", "Ddr", "rdsc", "drd", " ddest", "adst", "sdbl", "deddr", "sdst", "sdsl", "dedost", "nsts", "dST", "drsc", "Dct", "sddest", "Dste", "Drest", "Dput", "drst", "dsc", "sdrd", "drST", "drput", " dsl", "sdest", " drd", "ldct", " dsts"], "i32": ["I42", "si32", "in32", "I32", "si33", "si22", "ini32", "ui31", " i34", "i35", "in33", " i33", "ini33", "ui30", "iu15", "in15", "i33", "i15", "si35", "ri32", "ui34", "in34", "ri42", "qi32", "i31", "qi33", "qi34", " i35", "ri35", "I30", "i42", " i31", "ini22", " i22", "I35", "qi15", "ui32", "I34", "I31", " i30", "i22", "ini35", " i42", "I33", "ri33", "iu32", "iu34", "i30", "iu33", "i34"], "desti32": ["destabi15", "destiu28", "destabi16", "destiu33", "destsi32", "destii33", " desti22", "destic32", " destsi22", "targeti32", "desti28", "destic15", "destsi22", " desti15", "destabi22", "desti33", " destsi15", "targetiu33", "destiu34", "destii28", "destin32", "desti22", "targetiu28", "destsi16", "destiu32", "targeti28", "destsi15", "destin28", "destabi32", "desti34", "destic16", "targetiu34", "destii34", " destsi32", "targeti34", "destin34", "targetiu32", "destin33", "desti15", "targeti33", " destsi16", "destic22", "destii32"]}}
{"id1": "11716816", "id2": "1097147", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"updateFile": ["upFolder", "updateDirectory", "copyFolder", "copyBody", "importFile", "importFolder", "importBody", "upFile", "updateBody", "copyDirectory", "copyFile", "updateFolder", "importDirectory", "upBody", "upDirectory"], "file": ["fp", "url", "FILE", "base", "cache", "local", "e", "zip", "current", "load", "io", "model", "db", "path", "log", "input", "filename", "name", "queue", "lock", "image", "this", "files", "File", "type", "info", "connection", "pe", "class", "b", "object", "parent", "handler", "socket", "future", "resource", "content", "get", "http", "single", "l", "data", "source", "up", "dir", "line", "full", "part", "f"], "IOException": ["DownloadException", "TimeoutException", "IOProblem", "DownloadProblem", "TimeoutProblem", "Downloadception", " IOProblem", " IOception", "Timeoutception", "IOception"], "destFile": ["destFiles", "flatFile", "sourceFiles", "DestFiles", "destFolder", " destfile", "destDir", "Destfile", "srcFile", "origDir", "destFull", "sourceFolder", " destinationFile", "destTable", " destFolder", " destinationDir", "origTable", "DestFile", "destPath", " destFull", "destfile", "srcPath", " destFiles", " destTable", "sourceDir", " destinationFiles", "flatFiles", "sourceFile", "destroyfile", "DestDir", "destroyDir", " destPath", " destDir", "origFile", "srcFolder", "DestFolder", " destinationFull", "flatfile", "DestPath", "destroyTable", "destroyFile", "flatDir", "srcFiles", "DestFull", "origfile"], "in": ["cl", "gin", "cf", "ins", "din", "reader", "IN", "client", "login", "re", "el", "bin", "id", "io", "inc", "isin", "ini", "input", "In", "s", "conn", "inner", "on", "image", "c", "err", "this", "lock", "ax", "a", "i", "r", "connection", "b", "again", "with", "pull", "socket", "sync", "nin", "win", "inn", "p", "min", "pin", "l", "cin", "source", "up", "inside", "init", "work", "pass", "con", "ac", "as", "f"], "out": ["net", "exec", "url", "OUT", "client", "outs", "w", "call", "login", "output", "bin", "ou", "io", "inc", "exp", "of", "outside", "conn", "ext", "obj", "In", "name", "to", "no", "err", "off", "this", "c", "Out", "lib", "extra", "at", "writer", "i", "connection", "user", "b", "ex", "n", "again", "o", "co", "sync", "socket", "nin", "outer", "option", "timeout", "resource", "point", "cookie", "channel", "up", "password", "pass"]}}
{"id1": "8093133", "id2": "4016687", "code1": "    public static Object loadXmlFromUrl(URL url, int timeout, XML_TYPE xmlType) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        BufferedInputStream buffInputStream = new BufferedInputStream(connection.getInputStream());\n        return loadXml(buffInputStream, xmlType);\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        String sFTP = \"ftp.miservidor.com\";\n        String sUser = \"usuario\";\n        String sPassword = \"password\";\n        try {\n            System.out.println(\"Conectandose a \" + sFTP);\n            client.connect(sFTP);\n            boolean login = client.login(sUser, sPassword);\n            if (login) {\n                System.out.println(\"Login correcto\");\n                boolean logout = client.logout();\n                if (logout) {\n                    System.out.println(\"Logout del servidor FTP\");\n                }\n            } else {\n                System.out.println(\"Error en el login.\");\n            }\n            System.out.println(\"Desconectando.\");\n            client.disconnect();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"loadXmlFromUrl": ["loadXMLFromFile", "loadXmlFromurl", "loadXmlWithUrl", "loadXMLfromurl", "loadXMLFromurl", "loadXmlfromurl", "loadXmlfromURL", "loadXmlWithURL", "loadXMLfromFile", "loadXmlWithurl", "loadXmlAsUrl", "loadXmlfromFile", "loadXMLFromUrl", "loadXmlWithFile", "loadXmlAsURL", "loadXmlAsFile", "loadXMLFromURL", "loadXmlAsurl", "loadXmlFromURL", "loadXmlFromFile", "loadXMLfromURL", "loadXmlfromUrl", "loadXMLfromUrl"], "url": ["address", "base", "client", "str", "id", "feed", "io", "URL", "path", "sl", "Url", "host", "location", "string", "conn", "obj", "image", "link", "org", "ssl", "user", "object", "config", "loc", "loader", "buffer", "uri", "resource", "service", "http", "l", "page", "source", "file", "server", "open"], "timeout": ["client", "token", "cache", "resolution", "window", "port", "seconds", "io", "length", "out", "offset", "time", "scroll", "lock", "duration", "type", "wait", "ssl", "config", "socket", "sync", "period", "buffer", "resource", "delay", "key", "sleep", "data", "server", "limit", "capacity", "Timeout", "network", "until", "unit", "size"], "xmlType": ["elementModel", "xmlTypes", "xmlStyle", "elementtype", "writerModel", "phpClass", "mlFile", "elementType", " xmlTypes", "writerStyle", " xmlStyle", "phpTypes", " xmlClass", "writerType", " xmlModel", "phpType", "mlClass", " xmlFile", "xmlFile", "xmlModel", "xmltype", "mlType", "phpFile", "writertype", "elementStyle", "xmlClass", "mlTypes", " xmltype"], "connection": ["position", "lc", "bc", "client", "reader", "builder", "connected", "union", "use", "which", "io", "proxy", "container", "function", "index", "connect", "conn", "context", "section", "c", "database", "character", "event", "communication", "writer", "Connection", "b", "application", "directory", "handler", "config", "loc", "socket", " Connection", "uri", "resource", "version", "wrapper", "condition", "http", "ion", "l", "entry", "channel", "server", "closed", "con", "network", "collection", "unit", "open", "response", "relation"], "buffInputStream": ["BuffOutputstream", "BuffReadStream", "buffReadStream", "buffReadstream", "buffInputSteam", "BuffReadstream", "BuffReadSteam", "BuffOutputSteam", "buffReadSteam", "BuffInputSteam", "buffOutputstream", "buffinputSteam", "buffInstream", "BuffOutputStream", "buffinputstream", "buffInSteam", "BuffInputStream", "BuffInputstream", "buffInStream", "buffOutputSteam", "buffOutputStream", "buffinputStream", "buffInputstream"]}}
{"id1": "7891509", "id2": "10547671", "code1": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 1, "substitutes": {"pageAddress": ["siteUrl", "urlUrl", "urladdress", "PageAddress", "urlLocation", "pageLocation", "pageName", "siteName", "urlAddress", "resourceaddress", "siteAddress", " pageName", "PageLocation", "PageUrl", "resourceUrl", "siteLocation", "Pageaddress", "pageaddress", " pageUrl", " pageLocation", "pageUrl", "resourceLocation", "PageName", "resourceAddress"], "url": ["address", "base", "reader", "client", "bb", "feed", "URL", "plugin", "sl", "Url", "host", "string", "out", "ls", "stream", "image", "this", "ssl", "element", "i", "r", "connection", "user", "b", "browser", "object", "socket", "loader", "uri", "service", "resource", "http", "page", "l", "file", "data", "server", "source", "channel", "open", "web", "f"], "in": ["gin", "ins", "reader", "din", "IN", "client", "token", "login", "bin", "id", "isin", "inc", "ini", "input", "out", "In", "s", "conn", "stream", "inner", "c", "err", "read", "ssl", "i", "r", "b", "again", "rec", "socket", "nin", "win", "buffer", "resource", "inn", "min", "into", "line", "l", "data", "file", "source", "inside", "init", "kin", "impl", "as", "f"], "inputLine": [" inputFile", "pageLine", "selectFile", "inputString", "InputL", "rawLine", "inputFile", "InputCell", "selectLine", " inputPage", "rawFile", " inputString", "imageFile", " inputCell", "inputL", "rawPage", "inputPage", "selectContent", "rawString", "InputFile", "selectPage", "rawline", "inputContent", "imageCell", "inputCell", " inputUrl", "rawContent", "inputline", "rawUrl", "imageLine", " inputL", "pageline", "InputLine", "inputUrl", " inputContent", " inputline", "pageUrl", "pageString", "imageL"]}}
{"id1": "2465747", "id2": "4798332", "code1": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"postRequest": ["POSTResponse", "POSTQuery", " PostRequest", " postResponse", "postResponse", " PostMethod", "POSTRequest", " postMethod", " postQuery", "postQuery", " PostResponse", "postMethod", " PostQuery", "POSTMethod"], "urlString": [" urlFile", "urlText", "httpStr", "urlStr", " urlName", "httpName", " urlStr", "httpstring", "uriStream", " urlstring", "URLstring", "urlFile", "uriStr", "urlStream", "URLString", "URLText", "URLName", "urlName", "httpStream", " urlStream", "uriString", "urlstring", "httpText", "httpString", "httpFile", " urlText", "uriFile"], "data": ["map", "address", "result", "parse", "output", "metadata", "module", "dict", "DATA", "request", "function", "input", "session", "state", "to", "multi", "next", "results", "database", "this", "operation", "info", "batch", "dat", "object", "body", "query", "config", "message", "array", "media", "uri", "parts", "resource", "key", "api", "done", "server", "keys", "value", "json", "part", "as", "manager", "response", "settings"], "returnData": ["returnInfo", "outputString", "returnCode", "returnDat", "resultValue", "replyValue", " returnText", "inputString", "resultDat", "ReturnString", "replyString", "returnLine", " returnString", "ReturnLine", "inputData", "replyData", "runString", "ReturnData", "inputCode", " returnInfo", "resultData", "runValue", " returnLine", "getDat", "ReturnText", "getData", "getValue", " returnValue", "outputCode", "runLine", "resultInfo", "resultString", " returnDat", "runData", " returnCode", "inputValue", "returnString", "outputData", "returnValue", "outputLine", "replyLine", "resultText", "resultLine", "returnText", "getInfo", "outputValue"], "url": ["address", "position", "base", "client", "use", "zip", "URL", "proxy", "Url", "session", "connect", "string", "conn", "image", "link", "database", "org", "ssl", "user", "b", "object", "www", "config", "loc", "uri", "service", "resource", "http", "l", "page", "file", "server", "channel", "open", "web", "f", "relation"], "connection": ["position", "client", "connected", "output", "union", "use", "io", "URL", "proxy", "db", "log", "function", "index", "connect", "session", "conn", "context", "section", "image", "c", "link", "database", "character", "communication", "user", "Connection", "application", "object", "directory", "body", "handler", "config", "loc", "socket", "uri", "service", "resource", "timeout", "version", "close", "condition", "document", "http", "l", "channel", "server", "password", "con", "later", "open", "response", "relation"], "out": ["net", "exec", "error", "OUT", "client", "outs", "cache", "builder", "w", "login", "output", "io", "inc", "log", "conn", "string", "ext", "inner", "name", "err", "prefix", "no", "Out", "plain", "extra", "writer", "report", "print", "object", "again", "o", "co", "query", "list", "socket", "outer", "key", "copy", "cli", "line", "page", "up", "file", "server", "init", "dump", "con", "group", "later", "part", "comment", "temp"], "keySet": ["keyMap", "characterSet", "versionSet", " keyLine", "versionStream", " keyType", "KeySize", "typeSet", "objectString", "KeyType", "keyCode", "objectKey", "keyType", "dataString", "KeyString", "keyString", "keyStream", "KeyKey", "valueSize", "rowSet", " keySize", "rowString", " keyString", "rowKey", "typeType", "characterString", "characterKey", "objectSize", "typeMap", "typeString", " keyKey", "rowType", "keyLine", "dataStream", "versionString", "versionCode", "KeyMap", "keyKey", " keyCode", " keyStream", "valueString", " keyMap", "dataCode", "KeyLine", "valueLine", "objectSet", "keySize", "characterType", "KeySet", "dataSet", "valueSet"], "values": ["services", "objects", "ins", "params", "types", "groups", "marks", "ints", "vi", "roots", "uments", "vs", "docs", " Values", "maps", "lists", "ues", "vers", "lines", "results", "changes", "als", "ones", "words", "properties", "items", "errors", "vals", "options", "measures", "UES", "events", "frames", "views", "parts", "ves", "tests", "fields", "versions", "ports", "Values", "keys", "stores", "value", "details", "points", "limits", "names", "verts", "pes", "rules", "settings"], "count": ["first", "test", "position", "base", "ver", "level", "call", "now", "handle", "e", "use", "id", "current", "found", "child", "cycle", "old", "check", "Count", "default", "path", "index", "label", "repeat", "start", "length", "ind", "name", "core", "multi", "c", "order", "len", "next", "code", "all", "type", "i", "counter", "class", "number", "n", "parent", "batch", "list", "weight", "depth", "key", "other", "col", "pool", "num", "field", "coll", "limit", "loop", "group", "collection", "part", "sum", "size", "f"], "in": ["cm", "gin", "ins", "reader", "din", "IN", "login", "bin", "e", "id", "isin", "inc", "ini", "input", "ic", "In", "conn", "fin", "inner", "c", "err", "i", "r", "ex", "again", "body", "rec", "socket", "nin", "fr", "inn", "pin", "is", "into", "l", "lin", "cin", "init", "kin", "rin", "con", "ac", "as"], "inputLine": [" inputFile", "inputToken", "stringLine", "outBlock", "returnSection", "returnLine", "inputFile", "inputSection", "stringline", " inputToken", "stringToken", "outputBlock", "returnFile", "InputFile", " inputSection", "outFile", "inputline", "outChar", "InputSection", "InputLine", "inputChar", "stringFile", "outputline", "outputToken", " inputline", "outputChar", " inputChar", "outputLine", "outLine", "outputFile", " inputBlock", "inputBlock"]}}
{"id1": "17786231", "id2": "12783713", "code1": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"downloadFile": ["copyFiles", "transferfile", " downloadStream", " downloadFiles", "transferFiles", "copyFile", "downloadfile", "downloadStream", "transferStream", "copyStream", "transferFile", " downloadfile", "copyfile", "downloadFiles"], "downloadUrl": ["updateUrl", "transferUrl", "updateURL", "transferURL", " downloadURL", " downloadLine", "downloadURL", "updateLine", "outputUrl", "updateFile", "outputURL", "transferurl", " downloadurl", "outputurl", "downloadurl", "updateurl", "downloadLine", "outputLine", "transferFile"], "destinationFile": ["destporaryString", "DestinatingImage", "destinatedFILE", "destinationImage", "destoutputString", "destinatedFiles", "destporaryFile", "destinatingFile", "DestinationFiles", "destinationFiles", "destoutputImage", "destinatedFile", "DestinationFile", "destinationString", "destinationFILE", "destigrationFilename", "DestinationImage", "destinatingFilename", "destporaryFiles", "DestinatingFILE", "destoutputFile", "destoutputFiles", "DestinationString", "DestinatingFilename", "destinatingImage", "destporaryImage", "DestinatingString", "DestinatingFile", "DestinatingFiles", "DestinationFILE", "destinatingString", "destinatingFILE", "destigrationFile", "DestinationFilename", "destinatedFilename", "destigrationFILE", "destinationFilename", "destigrationFiles", "destinatingFiles"], "client": ["https", "url", "cl", "cache", "project", "call", "app", "force", "proxy", "request", "cher", "plugin", "remote", "session", "connect", "conn", "contact", "queue", "c", "self", "bird", "connection", "method", "application", "parent", "handler", "Client", "per", "config", "query", "uri", "service", "api", "resource", "get", "http", "cli", "channel", "server", "con", "ce"], "httpGet": [" httpCreate", "ttpSend", "ttpGet", "ttpCreate", "HttpCall", " httpCall", "httpget", "httpSend", "httpCreate", "resourceCall", "HttpPut", "resourceGet", "resourcePut", "HttpGet", "resourceget", "Httpget", " httpget", "HttpSend", "httpCall", "HttpCreate", " httpPut", "ttpCall", " httpSend", "httpPut"], "outputFile": [" outputDir", "referencePath", "targetFiles", "outputDir", "writeStream", "referencefile", "inputDir", "targetDir", "targetFile", "inputFile", "writefile", " outputDirectory", " outputFiles", " outputfile", "outStream", "outFile", "referenceStream", "inputFiles", " outputPath", "outputFiles", "outputfile", "writeFile", "referenceFile", "targetDirectory", "outfile", "inputDirectory", "outPath", "outputDirectory", "writePath", "outputPath"], "outputStream": ["OutputFile", " outputSteam", "logSteam", "inputSteam", " outputForm", "outputStreamer", "OutputSteam", "inputFile", "logWriter", "OutputStream", " outputWriter", "responseSteam", "outputSteam", "outputForm", "logStream", "responseStream", "inputWriter", "inputForm", "responseFile", "logStreamer", "responseWriter", " outputStreamer", "outputWriter", "OutputForm", "inputStreamer", "OutputWriter"], "response": ["result", "error", "received", "status", "output", "feed", "Response", "request", "session", "generation", "queue", "image", "success", "respond", "event", "connection", "report", "application", "object", "body", "ception", "handler", "query", "message", "resource", "api", "version", "document", "http", "data", "resp", "server", "reply", "json", "collection", "relation"], "entity": ["url", "result", "item", "cache", "status", "ity", "output", "e", "metadata", "id", "el", "model", "volume", "xml", "environment", "issue", "node", "machine", "state", "image", "event", "element", "component", "connection", "ie", "pe", "ent", "application", "object", "body", "message", "media", "resource", "service", "attribute", "api", "agent", "content", "document", "translation", "Entity", "data", "entry", "file", "server", "source", "email", "channel", "instance", "coll", "json", "collection", "unit", " identity", "comment", "ce"], "inputStream": [" inputFile", "InputLength", "downloadstream", "selectFile", "outputBuffer", "selectStream", "inputSteam", "audioStream", "downloadStream", " inputstream", "outputStreamer", "audioStreamer", "inputFile", "InputChannel", " inputSteam", "outputChannel", "selectSteam", "InputFile", " inputStreamer", "childStreamer", "outputSteam", "InputStreamer", "Inputstream", "childStream", "outputstream", "InputBuffer", " inputLength", "downloadLength", "inputLength", "selectStreamer", "audiostream", "InputSteam", "inputstream", "childSteam", "downloadSteam", "childChannel", "inputBuffer", "inputChannel", " inputChannel", "inputStreamer", "InputStream", " inputBuffer", "audioSteam"], "callback": ["backs", "url", "result", "processor", "cache", "Callback", "call", "proxy", "func", "function", "plugin", "fb", "CB", "state", "behavior", "cc", "code", "event", "band", "connection", "batch", "ff", "handler", "back", "config", "future", "sync", "loader", "message", "buffer", "resource", "wrapper", "consumer", "data", "closure", "collection", "clone", "cb", "cell"], "copiedLength": ["copiedBytes", "copyingBytes", "copyiedCount", "copyedBytes", "copiedSize", "copyiedLength", "copyiedlength", "copippedWidth", "copippedSize", "copyingCount", "copyedSize", "copyedLength", "copippedlength", "copyippedWidth", "copixedCount", "copiedCount", "copixedSize", "copodedWidth", "copedBytes", "copippedLength", "copiedWidth", "copedLength", "copedSize", "copyippedSize", "copyiedWidth", "copyinglength", "copyingWidth", "copyiedSize", "copedCount", "copiedlength", "copyippedLength", "copyiedBytes", "copyingSize", "copyippedlength", "copodedSize", "copodedlength", "copixedBytes", "copyingLength", "copixedLength", "copyedCount", "copodedLength"], "percentage": ["milaged", "milance", "Percentile", "Percentaged", "percentance", "percentade", " Percentile", " percentages", " percentade", "percentages", "milade", "percentaged", " Percentages", "milage", " percentile", "Percentages", "Percentade", " percentaged", " Percentance", " percentance", "Percentance", " Percentage", "Percentage", "percentile"]}}
{"id1": "1371265", "id2": "20210699", "code1": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"update": ["Update", "save", "delete", "updated", "apply", "replace", "request", "index", "set", "write", "info", "report", "query", "edit", "post", "table", "resource", "add", "UPDATE", "insert", "data", "append", "create", "json", "select", "run"], "channelPath": ["resourcePath", "resourceMap", "downloadObject", "resourcepath", " channelMap", "filePath", " channelObject", "downloadPath", "fileMap", "fileObject", "resourceObject", " channelpath", "downloadpath", "downloadMap", "filepath"], "dataField": ["alphaTerm", "responseField", "DataTerm", "dataTable", "dataTerm", " dataTable", " dataArea", "resourceFIELD", "dataFIELD", "responseTerm", "datafield", " datafield", "resourceTerm", "resourceField", "dataArea", "resourcefield", "alphaField", "responsefield", "DataArea", " dataTerm", "responseFIELD", "DataTable", "DataField", "alphaTable", " dataFIELD", "alphaArea"], "fatherDocId": ["fatherWriterName", "fatherPoID", "fatherDocumentid", "fatherFileId", "fatherDocPath", "motherDocid", "fatherDocid", "fatherdocName", "fatherFilePath", "motherDocId", "motherDocumentPath", "fatherdocInfo", "fatherWriterid", "fatherFileid", "motherDocID", "fatherPoName", "motherDocumentId", "motherDocumentid", "fatherdocId", "fatherWriterId", "motherDocumentInfo", "fatherDocName", "fatherFileInfo", "fatherDocumentPath", "fatherWriterID", "fatherFileName", "motherDocPath", "fatherDocumentInfo", "motherDocumentName", "motherDocInfo", "fatherDocumentID", "fatherFileID", "motherDocName", "fatherDocInfo", "fatherPoId", "motherDocumentID", "fatherWriterInfo", "fatherDocumentName", "fatherdocPath", "fatherDocID", "fatherDocumentId", "fatherPoid"], "sqlInitial": ["SQLInitial", "qlInitialized", " sqlinitial", "qlinitial", "sqlinitial", "qlFinal", "qlInitial", " sqlInitialized", "SQLinitial", "queryInit", "qlInit", "queryInitial", "sqlFinal", "sqlInitialized", "SQLFinal", "queryinitial", "sqlInit", "SQLInit", " sqlInit", "queryFinal", "SQLInitialized"], "sqlsortURL": ["sqLSORTURL", "sqlsourceURI", "sqLSORTUrl", "sqllaltSSL", "sqlssortURI", "sqLSorturl", "sqlsortSSL", "sqlsaltURL", "sqlsORTurl", "sqlssortUrl", "sqLSortUrl", "sqlsourceUrl", "sqlsendURI", "sqlsortURI", "sqllortURL", "sqlsaltURI", "sqllaltUrl", "sqlssorturl", "sqllortUrl", "sqLSortURL", "sqLSORTURI", "sqLSortURI", "sqlsendUrl", "sqlsourceURL", "sqlsORTUrl", "sqlssortURL", "sqlsourceurl", "sqlsendURL", "sqllortSSL", "sqllortURI", "sqlsaltSSL", "sqlsortUrl", "sqlsORTURI", "sqlsourceSSL", "sqllaltURL", "sqllaltURI", "sqlsORTURL", "sqLSORTurl", "sqlsaltUrl", "sqlsorturl", "sqlsendSSL"], "conn": ["net", "syn", "mc", "client", "ca", "ann", "Connect", "reg", "db", "oci", "pt", "connect", "session", "res", "sql", "cr", "cp", "oss", "core", "lock", "ci", "c", "cc", "rt", "en", "ct", "connection", " con", "Connection", "apt", "cs", "n", "enc", "co", "sync", "nt", "pub", "ds", "dc", "orp", "p", "pg", "dn", "rc", "col", "cn", "ch", "ens", "act", "coll", "pc", "con", "nc", "ht", "cat", "Conn", "conf", "ctx", "pr"], "rs": ["ra", "ms", "ins", "mr", "sr", "xs", "PS", "ges", "ts", "sels", "rr", "vs", "arch", "rors", "ks", "res", "pr", "s", "cr", "ris", "ns", "vers", "maps", "hr", "lines", "RS", "results", "rep", "ues", "rt", "pers", "hs", "repl", "ys", "r", "ras", "rg", "rows", "acks", "cs", "rx", "runs", "ans", "ats", "ars", "ows", "ds", "Rs", "asts", "rb", "its", "obs", "rc", "sc", "rys", "qs", "DS", "icks", "src", "rss", "ros", "bs", "rl", "rd", "ocr"], "ps": ["jp", "posts", "syn", "pa", "ms", "ins", "pex", "eps", "pse", "PS", "pm", "pre", "ts", "vs", "ws", "pt", "ns", "res", "ks", "s", "RS", "Ps", "pl", "os", "pers", "pps", "bs", "ras", "ys", "pe", "cs", "ans", "ups", "ars", "co", "ples", "ds", "Rs", "aps", "fs", "p", "LS", "pg", "ips", "ons", "pres", "ports", "ens", "pos", "amps", "DS", "pc", "pass", "con", "pp", "sp", "ss", "ros", "gs", "pr", "po"], "dbo": ["dbi", "bBo", "dbc", "dBo", "mdba", "dpo", "bbi", "ldba", "ldBo", "DBo", "Dbi", "Dbo", " dbc", "bbo", "mdbc", "ldbo", "bpo", "mdbo", " dBo", "mdBo", " dbi", "ldbc", " dpo", "Dpo", " dba", "dba"], "url": ["address", "rel", "str", "view", "id", "force", "hl", "URL", "feed", "path", "request", "nl", "sl", "fl", "Url", "filename", "location", "string", "name", "language", "host", "q", "image", "layer", "username", "ssl", "r", "html", "route", "text", "rule", "ll", "www", "loc", "ur", "fr", "uri", "date", "resource", "http", "href", "l", "page", "data", "file", "source", "server", "download", "email", "src", "rl", "blog", "f", "response"], "st": ["rest", "rd", "cl", "str", "ste", "sta", "x", "ast", "St", "sl", "pt", "sts", "string", "start", "cr", "s", "sth", "est", "ft", "bl", "rt", "ist", "Str", "std", "t", "sb", "r", "pe", "ut", "const", "th", "stop", "ost", "inst", "sn", "fr", "la", "p", "stress", "nd", "stack", "l", "stri", "sh", "sc", "ld", "src", "ust", "ST", "sp", "sw", "ss", "pr"], "sortDocId": ["sortDepID", " sortFilePath", "sortdocID", "sortDocumentid", "sortDepInfo", "sortDocumentId", "sortDocumentPath", "sortFileID", "sortPageId", "sortDOCId", " sortDocumentid", "sortdocName", " sortFileID", "sortFileId", "sortDepName", " sortDocumentID", "updateDocumentInfo", "sortDocid", "sortWriterID", "sortDocName", "sortDocumentInfo", "sortDOCID", "updateDocid", " sortDocInfo", "updateDocumentID", " sortFileInfo", "sortPageName", "sortFilePath", "sortdocId", "sortDocumentName", "updateDocID", "sortdocid", "sortdocPath", "sortdocInfo", "sortDocInfo", "updateDocId", "sortFileInfo", "sortDocPath", "sortWriterName", "sortDepId", " sortFileId", " sortDocumentId", "sortWriterId", "updateDocumentid", "sortFileid", "sortDOCid", "sortDOCName", " sortDocumentName", "updateDocInfo", " sortDocName", " sortDocid", " sortDocPath", "sortPageid", "sortWriterid", "sortDepid", " sortDocID", "sortDocumentID", "updateDocumentId", "sortDocID", "sortPageID"], "flag": ["arg", "kind", "prop", "bit", "status", "fun", "leaf", "str", "use", "id", "force", "child", "func", "fl", "bool", "start", "string", "ind", "ext", "binary", "offset", "bug", "ret", "agg", "format", "flags", "wait", "count", "tag", "Flag", "star", " Flag", "sync", "ag", "standard", "debug", "key", "store", "data", "match", "file", "lag", "char", "inline", "field", "only", "cat", "part", "blog", "FLAG"], "sqlsort": ["sqlsORT", " sqlesORT", " sqlssort", "sqlsorted", "sqLSorts", " sqlsORT", "sqsort", "sqlesORT", "sqllORT", "sqLSsort", " sqLSORT", "sqlessort", " sqLSsort", " sqlsorts", "sqsorts", "sqllorter", "sqlsorts", "sqlesort", "sqlssort", "sqllort", "sqLSorter", " sqlesorted", "sqLSorted", "sqlesorter", "sqllorted", "sqlesorts", "sqlsorter", "sqLSORT", "sqlesorted", "sqLSort", " sqlesorter", " sqlsorter", " sqLSorts", "sqssort", " sqlsorted", "sqsORT", " sqLSort", " sqlesort"], "sortURL": ["ortUrl", "ortURL", "sortURI", "updateURL", "altURL", "altUrl", " sortSSL", "SortURL", "ortUR", "editurl", "sortUR", "Sorturl", " sortID", "searchURI", "ortSSL", "updateSSL", "searchUR", "SortUR", "editUR", "searchID", "searchURL", "sortUrl", " sortUR", "updateURI", "ortID", "editUrl", "searchUrl", "sorturl", " sorturl", "sortID", "ortURI", "editURL", "altSSL", "sortSSL", " sortURI", "SortUrl", "altUR", " sortUrl", "updateUR"], "sortflag": ["SortFLAG", "filterflag", "ortFLAG", "sorttype", "considerlike", "addresslike", "filterFLAG", "ortfeed", "sortflags", "addressflag", " sortFLAG", "addressfeed", "considerfeed", " sortFlag", "sortlike", "sortFLAG", "ortlike", "considerflag", "Sortflag", "ortflags", "sortfeed", "ortflag", "orttype", "addressflags", " sorttype", "sortFlag", "ortFlag", "considerflags", "filtertype", "SortFlag"]}}
{"id1": "21363911", "id2": "9996334", "code1": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "code2": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "label": 0, "substitutes": {"testTransactions": ["testTacts", " testTransact", "testtransact", "testTransactionacts", "testTransact", " testtransacts", "testTransactionaction", "testtransactions", " testtransactions", " testtransaction", " testtransact", "testTactions", "testTaction", "testTransacts", "testTransactionact", "testTransactionactions", " testTransaction", "testTransaction", "testtransacts", "testtransaction", " testTransacts", "testTact"], "con": ["an", "exec", "cm", "cl", "ocon", "cf", "bc", "can", "ca", "client", "cache", "ver", "uc", "mc", "un", "ran", "com", "ain", "db", "log", "ctx", "x", "connect", "sql", "conn", "core", "conv", "cr", "c", "cc", "pl", "fac", "en", "custom", "ec", "connection", "crit", "ct", "const", "pen", "co", "fc", "sync", "enc", "Con", "pub", "win", "cond", "common", "close", "min", "condition", "CON", "rc", "col", "don", "act", "cn", "create", "contract", "pc", "coll", "ac", "cons", "ctrl", "conf", "xc", "run", "pr", "po"], "st": ["rest", "rd", "cl", "sw", "str", "ste", "sta", "put", "db", "tx", "St", "sl", "pt", "ks", "sts", "mt", "s", "cr", "est", "sth", "c", "set", "bl", "pl", "fe", "ist", "sa", "std", "t", "en", "ct", "sb", "r", "pe", "ut", "const", "co", "td", "ost", "sync", "inst", "fr", "sy", "sn", "la", "ck", "rc", "sh", "l", "sc", "se", "ld", "act", "d", "src", "pc", "ust", "ST", "sp", "ss", "pr"], "rs": ["maps", "sw", "ins", "ra", "mr", "sr", "str", "xs", "ges", "ts", "rr", "vs", "tx", "ws", "rors", "row", "yrs", "ns", "res", "ks", "pr", "s", "cr", "ls", "ris", "vers", "hr", "lines", " RS", "RS", "results", "changes", "rt", "hs", "pers", "errors", "ras", "r", "repl", "ys", "rows", "acks", "cs", "rx", "arms", "runs", "kr", "ans", "ps", "co", "ars", "ows", "ds", "Rs", "dr", "rc", "ums", "rys", "qs", "src", "rss", "details", "ros", "bs", "ss", "rl", "rd"]}}
{"id1": "10361370", "id2": "2668853", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"hash": ["shadow", "header", "sha", "ash", "cache", "ashing", "sign", "check", "Hash", "index", "hex", "build", "render", "crypt", "html", "fill", "block", "update", "version", "key", "h", "match", "dh", "password", "dump", "sum", "comment"], "saltBefore": ["sertBefore", "singALTAbove", "sintHead", "sALTStart", "isaltFrom", "sALTAbove", "isaltHead", "isaultStart", "singaltBefore", "seedAfter", "sALTBefore", "singALTBefore", "seedAbove", "singaltAbove", "isaultFrom", "sintFrom", "saltAbove", "singaltStart", "saultFrom", "sertAbove", "isaltBefore", "sultBefore", "singALTStart", "saultStart", "sALTAfter", "singaltAfter", "isaultBefore", "sultHead", "sertStart", "saltFrom", "isaltStart", "seedBefore", "sultFrom", "isaultHead", "sintBefore", "seedStart", "saultHead", "singALTAfter", "saltStart", "saultBefore", "sertAfter", "sultStart", "sintStart", "saltHead"], "content": ["address", "url", "header", "cont", "cache", "str", "output", "raw", "model", "xml", "music", "creator", "input", "filename", "pattern", "string", "sequence", "length", "stream", "word", "section", "image", "size", "character", "expression", "entity", "code", "format", "method", "text", "body", "object", "parent", "message", "buffer", "media", "resource", "version", "Content", "document", "data", "source", "password", "script", "value", "json", "comment", "temp"], "saltAfter": ["saltedAround", "sertBefore", "saltedEnd", "singaltBefore", "saltafter", "sALTBefore", "sintExtra", "sintAfter", "saltAround", "singALTAround", "sertAround", "singALTBefore", "saultAfter", "saltEnd", "saultExtra", " saltafter", "singaltEnd", " sALTAfter", "sALTEnd", " sALTExtra", "saltedAfter", "sALTAfter", " sALTBefore", "singaltAfter", "sertEnd", "sintafter", "sALTAround", "sALTExtra", "singALTEnd", "sintBefore", "saltExtra", "singALTAfter", "saltedBefore", "saultBefore", "saultafter", " saltExtra", " sALTafter", "sertAfter", "singaltAround", "sALTafter"], "repeatedHashingCount": ["repeatedHashCounter", "repeatedHumpingType", "repeatedHatingLength", "repeatedHashesNumber", "repeatedHumpingcount", "repeatedHashesCount", "repeatedHashingLength", "repeatedChashesNumber", "repeatedHashesCode", "repeatedShashingCounter", "repeatedChashesType", "repeatedChashingcount", "repeatedHashingType", "repeatedShashingCode", "repeatedHashedCount", "repeatedChashingCount", "repeatedHashCount", "repeatedChashescount", "repeatedHashingcount", "repeatedShashingLength", "repeatedHashingCode", "repeatedHashCode", "repeatedShashCode", "repeatedHashesType", "repeatedHashesCounter", "repeatedHashescount", "repeatedShashCounter", "repeatedHashedType", "repeatedHashingNumber", "repeatedChashingType", "repeatedHatingCount", "repeatedShashingCount", "repeatedShashLength", "repeatedHashingCounter", "repeatedHumpingNumber", "repeatedHatingCode", "repeatedHatingCounter", "repeatedChashingNumber", "repeatedHashedcount", "repeatedHashLength", "repeatedShashCount", "repeatedChashesCount", "repeatedHashedNumber", "repeatedHumpingCount", "repeatedHashesLength"], "digest": ["digator", " digested", " Digator", "hashest", "signEST", " Diger", " digusher", "loger", "signest", "hexString", " Digester", " digests", "DigString", "mixest", "validester", "logester", "Digger", "ngest", "Digator", "finest", "digEST", "validest", "mixested", "signger", "diggest", "digString", " digester", "Diggest", "digester", " diggest", "ngested", " digEST", "hexested", "generests", " digator", "ngester", "mixester", "digusher", "digests", "Digests", "finested", "validested", "loggest", "Digusher", "nger", "digested", "DigEST", "mixusher", "hexest", "Diger", "Digester", "hexests", "hashested", "finester", "signester", "diger", "hashString", "Digest", " diger", "digger", "Digested", "finests", "logest", "generester", " digger", "generested", "signested", "generest", "hashests", "valider", " Digest"], "digestLength": ["digestsType", " digesterType", "digesterType", "digestsLen", " digesterlength", "digestType", "digestingLength", "DigesterLen", "DigestLen", "digestingLen", "digestsLength", "digestedLen", "digestinglength", "DigestLength", "digesterLen", " digestlength", " digesterLength", "digestingType", "digesterLength", "digestedLength", "digestedlength", " digestType", "Digesterlength", "DigesterLength", "Digestlength", "digestlength", "digestslength", " digestLen", "digesterlength", " digesterLen", "digestLen"], "i": ["qi", "v", "lc", "k", "ai", "ti", "I", "e", "ami", "id", "io", "iu", "xi", "x", "ini", "index", "start", "length", "u", "li", "s", "ui", "multi", "ci", "c", "anti", "si", "phi", "ii", "t", "j", "count", "info", "b", "n", "o", "bi", "slice", "zi", "ri", "uri", "api", "p", "gi", "h", "fi", "di", "oi", "l", "d", "wei", "chi", "mu", "f", "pi"]}}
{"id1": "18370075", "id2": "22338097", "code1": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 1, "substitutes": {"createPasswordDigest": ["createpassworddigest", "createPasswordModenge", "createPassworddigest", "createPasswordSignest", "createPasswordSignifier", "createPasswordSignenge", "createPassworddigenge", "createpassworddigenge", "createPasswordDigenge", "createpasswordDigester", "createPasswordModest", "createpasswordDigest", "createPasswordDigester", "createPasswordDigifier", "createPasswordSignester", "createpassworddigester", "createPasswordModifier", "createpasswordDigifier", "createPassworddigifier", "createpassworddigifier", "createpasswordDigenge", "createPassworddigester", "createPasswordModester"], "password": ["hash", "address", "account", "token", "Password", "login", "sword", "security", "command", "wallet", "path", "filename", "pattern", "seed", "name", "string", "word", "database", "auth", "words", "username", "crypt", "user", "text", "config", "pad", "padding", "message", "p", "key", "wd", "phrase", "data", "PASS", "source", "secret", "email", "pass", "Pass"], "salt": ["SALT", " sALT", "ssalt", "ssALT", "ssass", "sass", "ssecret", "Ssecret", "pALT", "sesass", "psecret", " sass", "sALT", "Salt", "pass", "sesALT", "Sass", "sssecret", "sesalt", " ssecret", "palt", "sessecret"], "md": ["mad", "MD", "mc", "sha", "ms", "clean", "metadata", "pm", "bd", "zip", "amd", "mo", "meta", "mb", "mt", "ind", "cmd", "code", "mand", "m", "dd", "ph", "gd", "od", "mm", "ma", "ad", "pd", "message", "cd", "kg", "nd", "mac", "mn", "mod", "me", "di", "ld", "d", "mag", "bf", "nm", "dm", " MD", "mail", "po"], "digest": [" digested", "hashest", "generress", "signest", "decests", " digests", " digcode", "dEST", " digress", "digEST", " digester", "generests", "digester", " digEST", "decest", "decester", "digests", "DigEST", "dest", "digested", "digress", "Digester", "hashested", "hashcode", "hashester", "dested", "dester", "signester", "Digest", "Digested", "digcode", "signcode", "generester", "signested", "generest", "decress"]}}
{"id1": "8815137", "id2": "19322941", "code1": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "code2": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"copyToDir": ["copy2Folder", "copyNewDir", "copyFromFile", " copyToFolder", " copyFromFolder", "copyToDist", "copyNewDist", "copyToFolder", "copy2Dir", "copyToFile", " copyFromDist", "copy2File", "copyNewFile", "copyFromFolder", " copyFromFile", "copyNewFolder", " copyToDist", " copyFromDir", " copyToFile", "copyFromDir", "copy2Dist", "copyFromDist"], "dir": ["url", " directory", "base", "cache", "project", "local", "output", "Dir", "id", "zip", "module", "model", "container", "db", "path", "folder", "log", "plugin", "div", "target", "keep", "name", "out", "ir", "domain", "lock", "doc", "this", "files", "lib", "editor", "build", "type", "report", "class", "root", "directory", "parent", "object", "DIR", "dest", "direction", "loc", "diff", "tree", "uri", "dc", "wd", "store", "http", "data", "entry", "source", "dist", "d", "director", "coll", "home", "manager", "f", "temp"], "file": [" module", "FILE", "cache", "local", "e", "force", "id", "model", "path", "log", "filename", "name", "queue", "format", "File", "directory", "message", "p", "data", "letter", "full", "part", "f", "fp", "use", "db", "folder", "function", "string", "write", "fe", "class", "object", "block", "key", "http", "single", "l", "page", "create", "comment", "lane", " directory", "base", "zip", "current", "io", "binary", "stream", "files", "lib", "code", "info", "parent", "body", "media", "resource", "content", " filename", "source", "home", "unit", "module", "url", "view", "found", "default", "out", "image", "this", "ile", "self", "type", "live", "connection", " name", "handler", "table", " source", "line", "up", " base"], "fileOutputStream": ["FileInputSteam", "FileOutputFile", "fileOutputSem", "fileIOStream", "fileConfigStream", "fileInputChannel", "filesInputSteam", "fileConfigstream", "FileInputStream", "fileIOFile", "fileOperLength", "fileBytestream", "fileInputFile", "fileInputSteam", "FileOutputSteam", "fileOutputFile", "FileInputFile", "filesOutputChannel", "fileOperSteam", "fileConfigSteam", "fileResponseStream", "fileInputLength", "fileByteStream", "fileOutputLength", "filesOutputSteam", "filesInputLength", "fileResponseSem", "filesInputStream", "FileInputSem", "fileByteLength", "filesOutputstream", "fileWriteChannel", "fileOutputSteam", "fileOutputstream", "fileIOSem", "fileResponseSteam", "fileByteSteam", "filesInputstream", "fileWriteSteam", "fileConfigChannel", "fileWriteStream", "fileResponseFile", "FileOutputSem", "fileIOSteam", "filesOutputStream", "fileInputstream", "fileInputSem", "fileOperStream", "fileOperstream", "filesOutputLength", "filesInputChannel", "fileWritestream", "FileOutputStream", "fileOutputChannel"], "fileInputStream": ["fileOutputThread", "fileStoragePass", "fileAsyncStream", "filesInputPass", "fileInPass", "fileInstallStream", "fileSourceStream", " fileInputstream", "filesInputSteam", " fileOutputSteam", " fileInputThread", "fileInternalStream", "fileInputPass", "fileInputSteam", " fileInputSteam", "fileInSteam", "fileInStream", "filesOutputThread", "fileOutputPass", "fileStorageStream", "fileAsyncstream", "fileSourcestream", "fileInternalSteam", "filesOutputSteam", " fileOutputThread", "filesInputStream", "filesOutputPass", "filesOutputstream", "fileOutputstream", "fileOutputSteam", "fileSourceThread", "fileStorageSteam", "filesInputThread", "filesInputstream", "fileAsyncSteam", "fileInternalstream", "fileSourceSteam", "fileInstallstream", "fileInternalThread", "filesOutputStream", "fileInputstream", " fileOutputstream", "fileStorageThread", "fileInputThread", "fileInstallSteam", "fileInThread"], "read": ["exec", " Read", "ip", "reader", "send", "level", "allow", "parse", "lex", "view", "e", "use", "id", "feed", "io", "load", "current", "raw", "old", "readable", "check", "default", "total", "index", "input", "seek", "length", "play", "end", "start", "write", "next", "build", "i", "count", "ride", "wait", "b", "fill", "r", "find", "Read", "sync", "READ", "ok", " write", "iter", "resource", "close", "add", "get", "work", "se", "sleep", "last", "loop", "create", "reads", "pass", "open", "reading", "size", "select", "ask", "run"], "buffer": ["Buffer", "result", "base", "uffer", "reader", "cache", "transfer", "comment", "feed", "load", "request", "row", "border", "length", "seed", "binary", "offset", "queue", "write", "layer", "batch", "b", "shape", "buf", "null", "slice", "iter", "message", "wave", "bytes", "flush", "data", "channel", "limit", "split", "size", "zero", "buff"]}}
{"id1": "22993368", "id2": "22135199", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2String", "decodeStringToFile", "decodeFile2Stream", "decodeFile2Files", "decodeFileFromFiles", "decodeStringToStream", "decodeFileAsFiles", "decodeFileAsString", "decodeStringToFiles", "decodeFileFromFile", "decodeFileToStream", "decodeString2File", "decodeFileToString", "decodeFileFromString", "decodeFileFromStream", "decodeFile2String", "decodeFileAsFile", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeFile2File", "decodeString2Files", "decodeFileAsStream"], "infile": ["Inbase", "Infile", "infiles", "InFile", " inFile", " instream", "inFile", "Instream", "minstream", "inputfiles", "infilename", "inbase", "outfilename", "minfile", " infilename", "outfiles", "minbase", "inputfp", "infp", " infiles", "inputfilename", " infp", "outfp", "instream", " inbase", "inputfile", "minFile"], "outfile": ["outputfilename", "outputpath", "outpath", "inputdatabase", "infolder", "inputFile", " outpath", "outdatabase", "inFile", "outFile", "outputdatabase", "outfolder", " outfolder", "infilename", "outfilename", " outFile", "outputfile", "inputpath", " outfilename", "outputfolder", " outdatabase", "outputFile", "inputfile"], "in": ["gin", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "ini", "input", "ic", "In", "s", "conn", "inner", "err", "inas", "m", "a", "i", "r", "b", "again", "sin", "socket", "nin", "win", "inn", "min", "pin", "is", "into", "cin", "data", "source", "lin", "init", "inside", "rin", "pass", "ac", "con", "as"], "out": ["net", "exec", "base", "error", "OUT", "client", "outs", "cache", "job", "output", "bin", "ou", "io", "inc", "one", "log", "session", "conn", "obj", "In", "inner", "name", "to", "image", "write", "err", "off", "no", "Out", "lib", "or", "writer", "ex", "parent", "again", "o", "co", "socket", "sync", "post", "outer", "timeout", "point", "copy", "line", "channel", "file", "up", "work", "pass", "home", "exit"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bb", "bin", "transfer", "feed", "raw", "input", "border", "length", "seed", "binary", "offset", "queue", "write", "layer", "type", "reference", "batch", "count", "b", "null", "buf", "slice", "padding", "iter", "bytes", "wave", "flush", "data", "channel", "server", "source", "limit", "value", "split", "size", "buff"], "read": ["exec", " skip", " Read", "ip", "reader", "send", " copy", "parse", "lex", "allow", "use", "id", "feed", "io", "load", "inc", "raw", "current", "_", "check", "x", " count", "connect", "seek", "length", "ind", "play", "start", "end", "write", "next", "len", "i", "count", "ride", "wait", "r", "n", "fill", "find", "Read", "slice", "sync", "READ", "tell", " write", "ad", "iter", "add", "get", "copy", "work", "sleep", "se", "limit", "reads", "pass", "reading", "size", "select", "f", "run"], "success": ["complete", "first", "result", "positive", "error", "cess", " succ", "primary", "status", "follow", "ccess", "growth", "flash", "fast", "right", "Success", "valid", "model", "func", "path", "default", " succeed", " Success", "true", "winner", "rolled", "results", "xx", "failed", "danger", "construct", " successful", "method", "null", "again", "ceed", "good", "message", "done", "rolling", "successfully", "content", "continue", "data", "warning", "successful", "pass", "roll", "initial", "better", "fail", "value", "open", "comment", "response"]}}
{"id1": "17716716", "id2": "19147281", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"plainToMD": [" stringToHash", " string2DER", " string2MD", " stringTOString", " input2Hash", " stringtoMD", " inputToDER", " stringToDER", " inputToMD", " stringToString", " input2MD", " stringtoString", " stringtoHash", " stringtoDER", " string2String", " stringTOMD", " input2String", " stringTOHash", " input2DER", " stringToMD", " stringTODER", " inputToString", " inputToHash", " string2Hash"], "loggerCol": ["progingColumn", "loggercol", "pluggingcol", "loggeCol", "loggingDr", "pluggercol", "pluggingDr", "loggecol", "loggeeDr", "loggeeCor", "progingCol", "pluggingCor", "logorerCollection", "pluggingCol", "pluggerCor", "progercol", "loggingCollection", "loggerColumn", "loggeCor", "loggingcol", "logorercol", "loggerDr", "pluggerDr", "loggerCor", "loglercol", "loglerCol", "loggingColumn", "loggeecol", "progerCol", "loglerCollection", "progerCollection", "progerColumn", "loggingCol", "loggeDr", "loggeeCol", "logorerColumn", "progingcol", "loggingCor", "loglerColumn", "loggerCollection", "logorerCol", "pluggerCol", "progingCollection"], "input": ["url", "base", "reader", "audio", "IN", "str", "output", "dict", "model", "raw", "container", "Input", "path", "request", "xml", "string", "context", "state", "cmd", "image", "format", "ssl", "connection", "null", "text", "empty", "config", "list", "buffer", "alpha", "inf", "plus", "form", "in", "data", "source", "file", "password", "instance", "temp"], "byteHash": ["stringArray", "blockSum", "byteBlock", "Bytehash", "bitBlock", "byteshash", "bytesHash", " bytehash", "wordArray", "ByteBlock", "bytehash", "ByteHash", "blockBlock", "stringhash", "byteSum", "stringHash", " byteSalt", "bithash", "wordSum", "bitHash", "bitArray", "stringSalt", " byteArray", " byteBlock", "wordhash", "blockHash", "byteSalt", "bytesSalt", "wordHash", "bytesArray", "bitSum", "byteArray", " byteSum", "ByteSum", "blockhash"], "md": ["MD", "hash", "cm", "mc", "dig", "ms", "metadata", "rm", "pm", "bd", "amd", "am", "df", "mo", "um", "meta", "mb", "mt", "cmd", "doc", "cc", "sm", "pkg", "rpm", "mand", "m", "dd", "ph", "Cmd", "Msg", "mg", "mm", "ma", "ad", "cd", "pd", "mac", "mn", "hm", "dr", "di", "mod", "dh", "d", "mag", "nm", "dm", "f", "mu", " MD", "mp", "msg"], "md5result": [" md5Result", "md5Result", " md25result", "md7result", " md25data", "md53results", "md7report", "md5results", "md6result", "md6package", "md305runner", " md5results", " md5report", "mddownresult", " md5package", " md7Result", "md25Result", "md512report", "md6report", "md4response", "mddownResult", " md5runner", "md512results", "md53runner", "md512Result", " md5data", "md4result", "md5report", " md305result", " md7result", " md25Result", "md5runner", "md25package", "md5data", "md7Result", "md305response", "md25result", " md305results", "md25data", " md305runner", "md305results", "md305result", "md6Result", "md4results", "md53response", " md7results", " md305response", " md5response", "md6results", "md512result", "md5response", "md53result", "mddowndata", " md25package", "md5package", "md6data", " md7report", "md7results", "md4runner", "mddownpackage"], "i": ["qi", "v", "z", "ai", "ti", "I", "e", "id", "io", "xi", "x", "index", "length", "u", "s", "li", "hi", "ui", "multi", "c", "ci", "si", "ii", "j", "r", "b", "n", "o", "bi", "zi", "ri", "uri", "p", "key", "gi", "h", "fi", "l", "oi", "di", "d", "ji", "mu", "f", "pi"]}}
{"id1": "6988216", "id2": "10266116", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public InputStream retrieveStream(String url) {\n        HttpGet getRequest = new HttpGet(url);\n        try {\n            HttpResponse getResponse = getClient().execute(getRequest);\n            final int statusCode = getResponse.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n                Log.w(getClass().getSimpleName(), \"Error \" + statusCode + \" for URL \" + url);\n                return null;\n            }\n            HttpEntity getResponseEntity = getResponse.getEntity();\n            return getResponseEntity.getContent();\n        } catch (Exception e) {\n            getRequest.abort();\n            Log.w(getClass().getSimpleName(), \"Error for URL \" + url, e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"testSimpleQuery": [" runClientSearch", " runSimpleFilter", "runSimpleSearch", " runSimpleSearch", " runRawConnect", " runClientFilter", "runSimpleQuery", "runRawConnect", " runSimpleQuery", "runRawFilter", " runClientQuery", "runSimpleConnect", " runBasicQuery", " runClientConnect", " runBasicConnect", " runBasicFilter", " runRawQuery", " runSimpleConnect", " runRawFilter", "runRawQuery", " runRawSearch", "runRawSearch", " runBasicSearch", "runSimpleFilter"], "dummySource": ["duddyClient", "dundleContent", " dummyOrigin", "dellyContent", "duddyContent", " dumbConfig", "dummyService", "duddyOrigin", "puddySourceFile", "daddyType", "dumbOrigin", "puddyType", "dumbContent", "pummySource", " dumbOrigin", "pummyType", "dandySourceFile", "puddyContent", "dumbConfig", "dummyOrigin", "puddyService", "duddySourceFile", "pummyService", "pummyContent", "dundleOrigin", "dundleSource", "duddyService", "dummySourceFile", "puddyClient", "pummySite", "dandySource", "dummyConfig", "duddyType", "dumbSource", "pummyClient", "daddyService", " dumbContent", "dandyClient", "daddySourceFile", "dellySource", "dummyType", "daddySite", "dummyClient", "daddyClient", "dellyService", "puddySite", "duddySource", " dummyConfig", "pummySourceFile", "dummySite", "daddySource", " dumbSource", "puddySource", "dandySite", "daddyContent", "duddyConfig", "duddySite", "dundleConfig", "dellyType"], "os": ["sys", "mos", "us", "OS", "osi", "Os", "nos", "ms", "iso", "ou", "aos", "io", "vs", "es", "oss", "ns", "ks", "out", "conn", "ls", "s", "oc", "ios", "or", "bos", "ori", "i", "acs", "dos", "oos", "uns", "om", "object", "ops", "ose", "o", "ps", "ows", "oses", "css", "ds", "los", "fs", "ok", "ols", "is", "obs", "cos", "op", "ens", "pos", "as", "ros", "oa", "ss", "ol", "bs", "ox", "oS"], "dummyContent": ["dumpercontent", "dummyBody", " dellycontent", "dumperOutput", "dellyContent", "duddyContent", "dumperSource", " dummyContents", "dumperContent", "duckyReader", " dellyOutput", "dumperContents", "dellyOutput", "dellycontent", " dellyContents", "duckyContent", " dellyContent", "DuckyContent", "dumpingContent", "dellyContents", "duddyReader", "DuckyBody", "DummyContent", "dumperReader", "dummyContents", " dummyOutput", "dummycontent", "DuckySource", "dummyOutput", "duckyBody", "dumpingContents", "dummyReader", "duddySource", "dumpingOutput", "DummyBody", "DummyReader", "DuckyReader", "dumperBody", " dummycontent", "duddyBody", "duckySource", "DummySource", "dumpingcontent"], "source": ["ource", " Source", "slave", "ser", "url", "result", "reader", "client", "cache", "scope", "site", "e", "use", "proxy", " sources", "sl", "target", "host", "node", "core", "secure", "s", "string", "stream", "seed", "Source", "resources", "storage", "element", "i", "info", "connection", "class", "text", "parent", "object", "sin", "config", "sync", "ources", "sn", "uri", "service", "resource", "search", "cos", "channel", "sc", "src", "unit", "size", "SOURCE"], "content": ["address", "url", "sol", "result", "cont", "header", "description", "clean", "title", "output", "feed", "current", "load", "child", "cover", "model", "xml", "children", "music", "input", "target", "host", "cms", "image", "size", "expression", "code", "news", "comments", "report", "html", "transform", "text", "body", "config", "css", "update", "message", "media", "resource", "version", "Content", "service", "document", "cos", "data", "match", "server", "value", "activity", "comment", "response"], "qResult": ["kResult", "qSource", "iqResult", "kSource", "qresult", "kresult", "queryResponse", "queryResults", " qResults", "QResults", "qReturn", "kFilter", "kReturn", "rRes", "queryFilter", "rSource", "kRes", "qResults", "queryResult", "queryRes", "qFilter", " qresult", "rresult", "QFilter", "queryresult", "QReturn", "queryReturn", " qResponse", "kResults", "iqResults", "qResponse", "rResult", "querySource", "iqResponse", "QResult", "qRes", "iqresult"], "results": ["Results", "result", "objects", "ins", "groups", "ids", "reports", "shows", "members", "docs", "children", "ions", "users", "res", "RESULTS", "values", "s", "vers", "lines", "resources", "files", "items", "errors", "models", "rows", "runs", "features", "events", "blocks", "its", "pages", "data", "versions", "qs", "successful", "ries", "details", "collection", "tests", "response"], "it": ["v", "lit", "sit", "ip", "ins", "itted", "stat", "ITS", "id", "which", "not", "iti", "ort", "ic", "rit", "ati", "mit", "ci", "It", "si", "pit", "or", "you", "t", "ite", "i", "info", "r", "edit", "list", "ited", "slice", "the", "iter", " It", "p", "its", "in", "l", "entry", "op", "init", "and", "IT", "split", "ait"], "rSrc": ["RSrec", " rEsource", "rAssrc", " rSsrc", " rDssrc", "RIsrc", "rDssrc", "rSsrc", "RSource", "rAsource", "rEsRC", "RIsrec", "rDsrc", "rSource", "rPsrc", "RIsRC", " rDsrc", " rEssrc", "rAsrec", " rDsRC", "rPsource", "rEsource", "RIsource", "rDsource", " rDsource", "rIsrec", " rEsRC", "rEsrc", "rIsource", " rSource", "rEssrc", "rSrec", "rAsRC", " rSRC", "rPssrc", "rDsRC", "rIsrc", "rSRC", " rEsrc", "RSRC", "RSrc", "rAsrc", "rIsRC", "rPsRC"], "rSrcIn": ["rCRCIn", "rAsrcin", "rCrcIns", "rSRCin", "rSsrcIn", "rSourceIns", "rAsrcIn", "rSRCOut", "rSvcIN", "rCRCIns", "rSvcIns", "rSrcIns", "rCsrcIn", "rAsrcOut", "rSsrcOut", "rSvcin", "rCsrcin", "rCsrcIN", "rSvcIn", "rSrcOut", "rCRCOut", "rCsrcOut", "rSourceOut", "rSvcOut", "rAsRCin", "rSRCIns", "rCrcIn", "rAsRCIn", "rSourcein", "rSRCIN", "rCrcOut", "rSRCIn", "rSsrcin", "rAsRCOut", "rCrcIN", "rCrcin", "rSrcIN", "rSourceIn", "rSrcin", "rSsrcIN"], "actualOut": ["operatorOut", "realout", "eventOUT", "assertOut", "realWin", "assertBridge", "eventOut", "illegalOUT", "illegalOut", "assertOUT", "publicOUT", " actualOUT", "operatorIn", " ActualOUT", "nexpectedIn", "publicIn", "actualout", " actualout", " actualIn", "assertIn", " ActualIn", "actualOUT", "operatorout", "nexpectedOut", "actualOutput", "nexpectedWin", "realOut", "illegalIn", " actualOutput", "actualBridge", " actualWin", " actualBridge", "eventIn", "actualWin", "realIn", "actualIn", " ActualBridge", "eventout", "publicOut", "illegalOutput", "nexpectedout", "publicOutput", "operatorOUT", " ActualOut"]}}
{"id1": "10451698", "id2": "18433984", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"copy": ["drop", "share", "change", "delete", "paste", "rm", "transfer", "zip", "Copy", "load", "replace", "remote", "py", "cp", "archive", "lock", "write", " cp", "type", "cop", "ignore", "parent", "sync", "list", "update", "clip", "get", "process", "move", "file", "download", "create", "dump", "split", "cat", "ssh", "part", "clone", "run"], "source": ["ource", "slave", "url", "result", "reader", "client", "cache", "project", "scope", "view", "site", "use", "current", "proxy", "model", "path", "folder", "remote", "target", "filename", "start", "name", "seed", "string", "secure", "stream", "flat", "archive", "section", "image", "Source", "storage", "ie", "info", "connection", "class", "root", "null", "directory", "object", "parent", "config", "slice", "iter", "service", "resource", "plus", "from", "document", "data", "file", "server", "src", "unit", "sf", "ce", "SOURCE"], "destinationDirectory": ["destributionDirectory", "destructionFolder", "DestributionHome", "destributionPath", "DestinationFolder", "DestinationDir", "destributionHome", "destructionDir", " destinationFolder", " destinationFile", " destinationsFolder", "destarationPoint", " destinationDir", "DestinationHome", "DestributionFolder", "destificationDirectory", "destinationFile", "DestinationDirectory", "destippingDirectory", "destinatorPoint", "destinationsDirectory", "destinationPath", "destinationDir", "DestributionDirectory", " destinationsFile", "destinationHome", "destippingFolder", "destinatorPath", "destificationFolder", "destippingHome", "destinationsDir", "destinationsFolder", "DestributionPath", "destippingDir", "DestributionDir", " destinationsDir", "destinatorDirectory", "destarationDirectory", "destinationsFile", "destructionDirectory", "destributionFolder", "DestributionPoint", "destructionFile", "destinationFolder", "destarationPath", " destinationsDirectory", "destinationPoint", "destributionPoint", "destificationHome", "destributionDir", "destributionFile", "destificationDir", "DestinationPoint", "DestinationPath"], "newDir": ["NewFolder", " newDirectory", " newFolder", "NewDir", "NewDirectory", "newDirectory", " newdir", "nextdir", "NewFile", "Newdir", "nextFolder", "nextDirectory", "newFolder", "nextDir", "newdir", "nextFile"], "children": ["rules", "iv", "url", "ins", "uc", "packages", "iblings", "roots", "which", "when", "ren", "child", "current", "sub", "members", "sort", "father", "kids", "filename", "parents", "values", "projects", "files", "words", "items", "ools", "rows", "parent", "loc", "each", "list", "begin", "ul", "events", "blocks", "mount", "opens", "content", "other", "pages", " Children", "data", "ums", "Children", "scenes", "balls", "collection", "names", "web", "pes", "tests"], "i": ["qi", "v", "lc", "k", "iv", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "q", "start", "end", "li", "ui", "u", "hi", "inner", "multi", "ci", "si", "mi", "ii", "m", "y", "j", "type", "ie", "info", "ori", "b", "n", "o", "slice", "ri", "uri", "p", "gi", "key", "h", "ix", "fi", "it", "di", "in", "oi", "d", "ji", "part", "mu", "f", "pi"], "newFile": ["createDir", "Newfile", "NewFiles", "oldFiles", " newDirectory", "nextfile", "createfile", "nextFiles", "NewDir", "NewDirectory", "newDirectory", "createSource", " newSourceFile", "NewFile", " newfile", "NewSource", "oldDir", " newFiles", "oldFile", "nextSource", "newfile", "newSource", "NewSourceFile", "nextSourceFile", "nextDir", "oldDirectory", "nextFile", "createFile", "newFiles", "newSourceFile"], "output": ["complete", "external", "flow", "address", "result", "oper", "error", "console", "change", "after", "current", "ou", "put", "Output", "target", "out", "core", "binary", "generation", "four", "ilo", "generated", "image", "write", "operation", "writer", "connection", "application", "object", "parent", "kernel", "o", "again", "config", "socket", "outer", "update", "display", "service", "resource", "option", "other", "page", "file", "unit", "web", "control", "response", "temp"], "input": ["exec", "flow", "error", "client", "reader", "audio", "feed", "current", "inc", "child", "raw", "Input", "operator", "request", "index", "keep", "out", "context", "stream", "inner", "image", "this", "self", "storage", "connection", "print", "text", "parent", "config", "pull", "socket", "buffer", "resource", "inf", "plus", "form", "http", "in", "data", "work", "before", "instance", "ink", "ack", "temp"], "buff": ["bind", "uf", "cf", "cod", "bb", "gb", "ob", "bin", "comb", "feed", "load", "cur", "boot", "fb", "length", "cp", "bug", "cmd", "bound", "fe", "info", "ph", "batch", "count", "b", "shape", "buf", "text", "cast", "Buff", "ff", "back", "oct", "slice", "pad", "hello", "buffer", "pack", "uff", "rb", "flush", "data", "char", "gz", "txt", "comment", "cb", "f"], "read": ["exec", "k", "ip", "send", "reader", "allow", "parse", "lex", "use", "id", "feed", "io", "load", "transfer", "check", "skip", "x", "readable", "ask", "index", "reading", "start", "length", "ind", "end", "seek", "play", "write", "next", "len", " load", "rate", "en", "type", "wait", "count", "b", "fill", "text", "n", "find", "Read", "config", "sync", "slice", "READ", "ok", "buffer", " write", "iter", "close", "add", "get", "se", "loop", "and", "reads", "pass", "ink", "open", " count", "size", "select", "f", "run"]}}
{"id1": "5061606", "id2": "23246123", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "label": 0, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNecccessnecessary", "createSettingsIfNecesseless", "createSettingsIfNecesnecessary", "createSettingsIfNecesary", "createSettingsIfNececnecessary", "createSettingsIfNequccesseless", "createSettingsIfNecccessarily", "createSettingsIfNequesseless", "createSettingsIfNequccessarily", "createSettingsIfNequessnecessary", "createSettingsIfNequccessnecessary", "createSettingsIfNequessary", "createSettingsIfNequessarily", "createSettingsIfNecccessary", "createSettingsIfNequccessary", "createSettingsIfNececarily", "createSettingsIfNecccesseless", "createSettingsIfNececeless", "createSettingsIfNecessnecessary", "createSettingsIfNececary", "createSettingsIfNecesarily", "createSettingsIfNeceseless", "createSettingsIfNecessarily"], "out": ["net", "exec", "url", "result", "error", "OUT", "client", "outs", "cache", "output", "bin", "app", "window", "io", "model", "path", "log", "plugin", "index", "conn", "obj", "name", "image", "write", "err", "this", "off", "prefix", "Out", "plain", "lock", "editor", "at", "writer", "connection", "a", "i", "user", "null", "again", "object", "ex", "o", "parent", "config", "sync", "socket", "array", "timeout", "by", "flush", "copy", "cookie", "page", "data", "source", "file", "up", "server", "pool", "init", "password", "channel", "group", "exit"], "fSettings": ["fileSettings", "fJs", "rfSetting", "fsSetting", "fettings", "fSetup", " fsettings", "rfConfig", "fmSettings", "fileettings", "sfettings", "fmSetup", "sfJs", "sfsettings", "fmConfig", "FConfig", "sfSetting", "fSetting", " fJs", "Fsettings", "fileSetting", " fettings", "FSettings", "FJs", " fSetting", "fsConfig", "filesettings", "fsSettings", "rfSettings", "rfFs", "fConfig", "fmSetting", " fConfig", "fsettings", "sfSettings", "FSetup", "FSetting", "fsSetup", " fFs", "fFs", "fsFs"], "src": ["ource", "fp", "url", "prot", "base", "ins", "img", "st", "uc", "sr", "str", "gb", "tmp", "sub", "cur", "path", "sl", "filename", "string", "stream", "lower", "storage", "sel", "ssl", "sb", "b", "route", "text", "dest", "attr", "config", "loc", "uri", "rb", "rc", "source", "sc", "file", "dist", "ref", "req", "ctr", "cb", "settings"], "in": ["url", "gin", "ins", "thin", "din", "reader", "IN", "login", "bin", "id", "inc", "path", "ini", "index", "input", "In", "s", "inner", "stream", "image", "c", "err", "i", "r", "connection", "b", "n", "again", "sin", "win", "inn", "copy", "l", "data", "source", "file", "init", "kin", "rin", "con", "f"]}}
{"id1": "12389873", "id2": "13644375", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"load": ["test", " reload", "Load", "loading", "save", "transfer", "ready", "write", "link", "build", "read", "construct", " Load", " loaded", "config", "sync", "add", "get", " loading", "process", "init", "download", " loads", "dump", "clone", "select", "Loading"], "conn": ["exec", "mc", "client", "ca", "ann", "cache", "util", "reg", "db", "oci", "pt", "connect", "session", "ns", "sql", "state", "ls", "cp", "cr", "c", "ci", "cc", "rt", "ct", "ec", "sb", "connection", "Exec", "Connection", "n", "config", "co", "enc", "nt", "loc", "pub", "dc", "p", "h", "pg", "dn", "col", "cn", "ch", "act", "dh", "coll", "pc", "con", "nc", "cat", "Conn", "conf", "ctx", "pr"], "stmt": ["playtr", " sttr", " stmn", "esttr", "stager", " stmr", "astmn", "atmt", "astk", "fldo", "osttr", "estmd", "strs", "Stdb", "putur", "STml", "stb", " str", "playml", "stMT", "slager", "STbl", "stmr", "Stts", "Stpl", "stbt", "atmn", " strs", "stts", "actbl", "plb", "STdb", " stor", "Stur", "ostpr", "elmt", "stmb", "STnt", " sttor", "strdo", "stm", "playmt", "tct", "estct", "slk", "StMT", "putmb", "putts", "playor", "estMT", "stql", " stmb", "acttor", "dmd", "dmt", "Sttor", "dnt", "astmt", "astql", "playmn", "themn", "Stmn", "plr", "Stpr", "slr", "slmn", "flmt", "tm", "ostmt", "STpl", "Stmr", "ostct", "flk", "stct", "Stmt", " stk", "elrs", "Stnt", "actmt", " stager", "slnt", "STMT", "Stmd", "sttor", "stnt", "str", "Sttr", "elml", "puttr", "Stth", "estmt", "STmn", " stbt", "stk", "clur", "slmt", "plnt", "Stbt", "cltr", "flmd", " stb", "stmd", " stmi", "atMT", "STct", " stdb", "plmt", "stth", "stor", "themt", "stpr", "strmt", "strmd", "atb", " stct", "stdo", " stpl", "acttr", "STmt", "Stager", "Stmc", " stth", "clmn", "stbl", "estmr", "Stor", "STmd", " stts", "STk", "estk", "Stb", "stdb", "stmc", " stql", " stm", "putmn", "putmi", "stur", "Stm", "putbt", " stMT", "strk", "elmi", "tmt", " stbl", "STager", "stpl", "putml", "clmt", "plMT", "estth", "Stbl", "ostmn", " stmc", "putrs", "Stmb", "estdo", "STql", " stnt", "ostpl", "stml", "stmn", "theb", "estql", "plmn", "dMT", "sttr", " stml", "stmi", " stpr", "themc", "playpl", "tpl", "putmt", "ostager", "Stql", "Stml", "Stct"]}}
{"id1": "12171364", "id2": "8150996", "code1": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 0, "substitutes": {"getFrameworkFactory": ["getFramernelFactory", "getFlowwareInstance", "getFrameworkService", "getFlowwareService", "getFramwareInstance", "getFramwareFactory", "getFramernelService", "getFramernelInterface", "getFramorkInterface", "getFramwareInterface", "getFrameworkInterface", "getFramorkInstance", "getFramorkService", "getFramernelInstance", "getFloweworkInstance", "getFloweworkInterface", "getFramwareService", "getFrameworkInstance", "getFloweworkFactory", "getFramorkFactory", "getFlowwareInterface", "getFlowwareFactory", "getFloweworkService"], "url": ["address", "base", "rel", "re", "ob", "el", "feed", "zip", "URL", "jar", "path", "sl", "Url", "location", "string", "gl", "stream", "image", "err", "orb", "this", "org", "ssl", "r", "class", "b", "browser", "config", "loc", "socket", "loader", "ur", "fr", "lr", "service", "resource", "api", "uri", "bel", "http", "plug", "l", "href", "source", "file", "server", "data", "github", "coll", "blog", "f"], "br": ["yr", "result", "obl", "vr", "img", "reader", "ver", "mr", "sr", "bb", "ob", "handle", "str", "flash", "ber", "HR", "io", "arr", "jar", "brush", "db", "ler", "fb", "er", "sl", "abs", "cr", "hr", "stream", "bridge", "bro", "err", "orb", "bl", "rt", "Br", "org", "r", "b", "browser", "buf", "bar", "tr", "ner", "fr", "ur", "ab", "lr", "resource", "rb", "http", "dr", "href", "BR", "ch", "bh", "src", "bf", "sp", "cb", "pr"], "s": ["su", "signed", "v", "sv", "e", "es", "session", "name", "si", "os", "ssl", "a", "i", "g", "ps", "sym", "S", "ds", "message", "fs", "p", "is", "data", "as", "rs", "f", "sets", "input", "res", "string", "u", "ls", "c", "spec", "hs", "comments", "words", "strings", "b", "o", "enc", "single", "l", "in", "sf", "w", "str", "your", "sl", "sid", "t", "sb", "js", "search", "source", "ss", "sum", "side", "an", "site", "shell", "ws", "ns", "abs", "r", "text", "n", "ops", "sync", "h", "its", "line", "d", "pass", "second"]}}
{"id1": "20929570", "id2": "9738825", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    public void load(URL url) throws IOException {\n        ResourceLocator locator = null;\n        try {\n            locator = new RelativeResourceLocator(url);\n        } catch (URISyntaxException use) {\n            throw new IllegalArgumentException(\"Bad URL: \" + use);\n        }\n        ResourceLocatorTool.addResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n        InputStream stream = null;\n        try {\n            stream = url.openStream();\n            if (stream == null) {\n                throw new IOException(\"Failed to load materials file '\" + url + \"'\");\n            }\n            logger.fine(\"Loading materials from '\" + url + \"'...\");\n            load(stream);\n        } finally {\n            if (stream != null) stream.close();\n            ResourceLocatorTool.removeResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n            locator = null;\n        }\n    }\n", "label": 0, "substitutes": {"toMd5": ["toMcd5", "toBd15", "toBmd15", "toMm5", "toMmd7", "toMcd512", "toMm512", "toMm15", "toMd512", "toMd7", "toBmd5", "toMcd15", "toBmd7", "toMmd5", "toBmd512", "toMmd512", "toMmd15", "toMm7", "toMcd7", "toBd7", "toBd512", "toBd5", "toMd15"], "str": ["url", "result", "st", "sr", "e", "br", "exp", "arr", "sec", "input", "string", "out", "s", "obj", "conn", "name", "err", "Str", "r", "b", "kr", "text", "tr", "STR", "enc", "fr", "buffer", "bytes", "dr", "in", "stri", "data", "char", "source", "pass", "sp", "txt", "f", "msg", "temp"], "messageDigest": ["Messagedigester", "moreDigester", "messageHashester", "MessageMarkester", "moredigeter", "messageHashest", "MessageDefester", " messageDigEST", "messagedigester", "Messagedigested", "MessageMarkest", "MessagedigEST", "moredigested", "messageUploadested", " messageDiguster", "messageGest", "messageMarketter", "MessageDefested", "messageUploadest", "messageDse", "messageDigested", "messageDigeter", "messageDuster", "messageMarkester", "messagedigetter", "MessageDigester", "MessageDigested", "messageDigester", "messageDigher", "messageDher", " messageDest", "messageDiguster", "messageGuster", "moreDigest", "MessageDigEST", "MessageMarkher", " messageDEST", "messageMarkher", "moreDigested", "MessageDefest", "messageDigse", "messageGester", "Messagedigest", "MessageDigher", "MessageMarketter", "messageDest", "MessageDefse", " messageDuster", " messageDigester", "MessageDigse", "moreDigeter", "messageGEST", "messageDEST", "messagediguster", "MessageDigest", "messageMixse", "messagedigeter", "messagedigEST", "messageDested", "messageDeter", "messageMarkest", "messageDigEST", "messagedigested", "messageDefested", "messageHasheter", "messagedigest", "messageDester", "messageDigetter", "messageMixested", "messageMixester", "messageDefest", "messageDefester", "messageHashested", " messageDester", "moredigester", "messageDefse", "messageUploadEST", "messageMixest", "messageUploadester", "messagedigher", "messageDetter", "MessageDigetter", "moredigest"], "byteArray": ["ByteOrder", "wordBuffer", "wordString", "pixelArray", "bitBuffer", "byteIndex", "byteAmount", " byteAddress", "byteLength", "charObject", "resourcearray", "charAddress", "resourceLength", "bitIndex", "wordArray", "byteBuffer", "charLength", "bitLength", "charBuffer", "ByteAddress", "pixelObject", "wordarray", "charArray", " byteNumber", "ByteNumber", " byteString", "doublearray", "byteNumber", "byteString", " byteIndex", "charNumber", "doubleArray", "bitObject", "ByteAmount", "pixelLength", "ByteBuffer", "byteAddress", "doubleString", "bitArray", "doubleBuffer", " byteOrder", "bytearray", "charOrder", "resourceArray", "resourceIndex", "charAmount", "ByteLength", "ByteArray", "byteOrder", "byteObject", " byteAmount", "pixelBuffer", " byteBuffer", "bitarray", " byteLength", " bytearray"], "md5StrBuff": ["md5StRef", "md5STRBuff", "md6strBuffer", "md2StringComp", "md2StrBuffer", "md2StringRest", "md5TrDb", "md2StringText", "md5StringRest", "md2StringDb", "md6strBuff", "md6StrBuffer", "md2StringRef", "md5StrApp", "md5StrRest", "md5StringComp", "md5STRRest", "md5TrBuff", "md5StringText", "md5STRComp", "md5StText", "md2StrBuff", "md6StrBuff", "md2StringBuffer", "md5StrDb", "md5strText", "md6strText", "md5TrRef", "md2StrDb", "md6Strbuff", "md5StringApp", "md5strApp", "md5StComp", "md5StDb", "md5strbuff", "md5Stringbuff", "md2StrText", "md5StringDb", "md5TrText", "md5StringBuffer", "md2StrComp", "md2StrRest", "md5StrRef", "md5StApp", "md5TrBuffer", "md5StRest", "md5Strbuff", "md5StringBuff", "md6StrText", "md5StrComp", "md2StringApp", "md5StrBuffer", "md5STRBuffer", "md5strBuffer", "md2StrRef", "md5Trbuff", "md2StrApp", "md5StringRef", "md5StrText", "md6strbuff", "md2StringBuff", "md5StBuff", "md5StBuffer", "md5strBuff"], "i": ["qi", "v", "lc", "k", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "index", "length", "name", "li", "u", "ui", "inner", "multi", "ci", "c", "si", "phi", "ii", "y", "j", "ie", "info", "b", "n", "o", "bi", "slice", "ri", "uri", "p", "gi", "it", "h", "fi", "abi", "ix", "in", "di", "oi", "l", "d", "field", "ji", "part", "mu", "f", "pi"]}}
{"id1": "2676365", "id2": "17111859", "code1": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 0, "substitutes": {"reset": ["save", "delete", "activate", " rebuild", " shutdown", " checkpoint", "start", "clear", "set", "setup", " reconnect", " disconnect", "release", " Reset", "et", "back", "stop", "sync", "update", " migrate", "disable", "close", "flush", "commit", "destroy", "init", "register", " restore"], "currentPilot": ["currentPortector", " currentCPooter", "currentpilot", "currentpiece", "currentPayistor", " currentPooter", "currentPortacket", "currentCPilot", "currentPayacket", "currentpacket", "currentpooter", "activePistor", " currentCPilot", "currentCPacket", " currentPector", "activePilot", "currentPistor", "currentPointilot", "activepistor", "currentPointiece", "activepiece", "currentPooter", "currentPortooter", "activePacket", "currentPointistor", "currentpector", "activePiece", "currentCPector", "currentPayilot", " currentPacket", "currentPointacket", "currentPector", " currentCPector", "currentPayiece", "currentPortilot", "currentCPooter", "currentPiece", "currentPacket", "activepacket", "currentpistor", " currentCPacket", "activepilot"], "psta": ["jste", "pesa", "jda", " pste", "pasi", " psa", "pppa", "parsta", "Pla", "Psa", "jsa", "Pda", "psa", "pesta", " pppa", "parasi", "peppa", "Psta", "pda", " pda", "Pasi", "paresta", "Pste", "Pesta", " pesta", "pela", "parsa", "pla", "pste", "jsta", " pla", "Pppa", " pasi"]}}
{"id1": "18793482", "id2": "4798332", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"modifyApplicationMessage": ["modifyAppmessage", "modifyAppMessage", "modifiedApplicationMessage", "modifyAppMsg", "modifyApplicationContent", "modifiedApplicationContent", "modifiedapplicationContent", "modifiedapplicationmessage", "modifyExternalMsg", "modifyapplicationMsg", "modifyapplicationmessage", "modifyApplicationmessage", "modifyapplicationMessage", "modifyapplicationContent", "modifiedapplicationMsg", "modifiedapplicationMessage", "modifiedApplicationmessage", "modifiedApplicationMsg", "modifyAppContent", "modifyExternalContent", "modifyExternalmessage", "modifyExternalMessage", "modifyApplicationMsg"], "locale": ["localator", "locator", "placeALE", "locationALE", "placeale", "localue", "localale", "localame", "Locator", "locationales", "Locales", " locator", "locales", "Locame", "locue", " locame", "LocALE", " locales", "locationale", "Locale", "placeales", "locALE", "placeame", "localales", "localALE", "locationue", "locame", "Locue"], "messageName": ["MessageKey", "MessageValue", " messagename", "messageKey", " messageKey", "msgName", "MessageName", "messageType", "phraseName", "reasonname", "msgValue", "phraseKey", "msgType", "Messagename", "MessageType", " messageType", "msgKey", "phraseType", "reasonName", "reasonValue", "messagename", "phraseValue", "reasonType"], "messageValue": ["responseType", "MessageValue", "msgName", "MessageName", "MessageVal", "messageType", "msgValue", "msgType", "responseValue", " messageType", "MessageType", "responseVal", " messageVal", "responseName", "messageVal", "msgVal"], "properties": ["params", "pro", "prop", "metadata", "tmp", "xml", "py", "stats", "obj", "resources", "options", "ops", "Pro", "ps", "config", "Property", " props", "property", "api", "perties", "ips", " Properties", "data", "pb", "json", "txt", "conf", "settings"], "i18nPath": ["i18nPart", "i18bStr", "i18nsUrl", "i18nCorp", "i18bPath", "i18fCorp", "i18naPart", "i18fPath", "i18ninFile", "i16nPart", "i18naStr", "i18fpath", "i18bPart", "i11fPath", "i18nLocation", "i18nUrl", "i18nsFile", "i16npath", "i18onPath", "i11nCorp", "i16nStr", "i18onLocation", "i18nsPart", "i18nepath", "i11fUrl", "i18onFile", "i18nspath", "i18naPath", "i32nUrl", "i18ninUrl", "i18nsLocation", "i11nUrl", "i18bpath", "i32ninPath", "i16nsStr", "i18nsPath", "i32ninFile", "i18neUrl", "i18ninLocation", "i32nPath", "i18ninPath", "i32nLocation", "i32ninUrl", "i18onUrl", "i18npath", "i11fCorp", "i18neCorp", "i18nePath", "i32nFile", "i16nsPath", "i16nspath", "i18nStr", "i18nsCorp", "i11fpath", "i18nFile", "i32ninLocation", "i18nsStr", "i16nPath", "i16nsPart", "i18napath", "i11npath", "i18fUrl", "i11nPath"], "englishFile": ["languagefile", "languageFiles", "EnglishPath", "exampleFile", " englishDir", "examplePath", "examplefile", "propertiesPath", "propertiesFolder", "ianaPath", "ianaJar", "languageJar", "EnglishFile", "englishJar", "propertiesfile", " englishJar", "ianaDir", "languageFile", "ianaFile", "exampleFolder", "englishDir", " englishFiles", "EnglishFiles", "englishFolder", "languagePath", "propertiesFile", "EnglishFolder", "languageDir", " englishPath", "Englishfile", "englishFiles", "englishPath", " englishfile", "englishfile"], "propertiesFilePath": ["propertiesSourceFileName", "pertiesfilepath", "propertiesFileName", "propertiesFilesUrl", "pertiesfilePath", "propertiesSourceFilepath", "propertiesFileURL", "pertiesDirUrl", "pertiesfileName", "pertiesFileUrl", "propertiesfilepath", "propertiesFilesURL", "propertiesfileUrl", "pertiesFileName", "propertiesFileUrl", "propertiesDirpath", "propertiesFilesName", "pertiesFilepath", "pertiesFilePath", "propertiesfileURL", "propertiesFilespath", "propertiesDirName", "propertiesfileName", "propertiesSourceFilePath", "propertiesFilesPath", "pertiesFileURL", "pertiesDirName", "propertiesDirUrl", "propertiesDirPath", "pertiesDirpath", "pertiesDirPath", "propertiesfilePath", "propertiesFilepath", "propertiesSourceFileURL", "pertiesfileURL"], "file": ["FILE", "force", "model", "path", "one", "log", "filename", "name", "format", "File", "show", "directory", "message", "p", "data", "letter", "full", "part", "f", "fp", "use", "child", "folder", "function", "string", "word", "lock", "fe", "or", "pe", "class", "b", "object", "buffer", "property", "http", "single", "l", "page", "base", "reader", "php", "zip", "language", "binary", "stream", "files", "entity", "parent", "socket", "media", "resource", "it", "content", "source", "field", "unit", "book", "module", "url", "play", "ile", "connection", "application", "text", "handler", "future", "h", "up", "die", "le"], "in": ["gin", "ins", "reader", "din", "IN", "login", "bin", "io", "inc", "isin", "ini", "input", "er", "ic", "In", "s", "inner", "image", "err", "or", "i", "r", "b", "n", "again", "sin", "nin", "ri", "win", "inn", "p", "pin", "plus", "it", "into", "l", "lin", "cin", "inside", "kin", "init", "d", "rin", "con", "f"], "out": ["net", "exec", "v", "error", "OUT", "outs", "builder", "w", "output", "bin", "ou", "io", "inc", "exp", "one", "string", "s", "end", "inner", "word", "ext", "to", "image", "err", "write", "Out", "plain", "lib", "i", "r", "b", "ex", "n", "again", "o", "co", "sync", "socket", "outer", "p", "by", "cli", "work", "up", "and", "full", "home", "part", "f"], "c": ["v", "bc", "k", "cl", "cf", "lc", "cy", "uc", "dec", "cont", "w", "C", "cur", "x", "pointer", "cr", "ci", "cc", "character", "code", "ct", "ec", "a", "i", "t", "r", "arc", "b", "cu", "n", "ice", "esc", "o", "enc", "dc", "p", "h", "rc", "col", "l", "char", "ch", "sc", "d", "pc", "ac", "con", "abc", "f", "size", "xc", "ce"], "is": ["us", "ais", "ins", "ib", "re", "str", "does", "iso", "are", "has", "id", "isa", "IS", "bis", "Is", "es", "res", "ir", "ui", "s", "stream", "ris", "si", "ios", "iss", "os", "i", "info", "ps", "ri", "isu", "iter", "api", "it", "get", "its", "as", "serv"], "breader": [" cakeER", "breaditer", "brewiter", " cakeler", " Breader", "breaders", " breaders", " cakeer", " cakeers", "feediter", "webiter", "breadamer", "feedamer", " BreadER", "breadler", " breadler", "brewer", "webr", " Breaders", "weber", "feeder", "breadER", " Breadler", "brewamer", "breadr", "feedr", " breadER", "webamer", "brewr"], "line": ["url", "lc", "header", "ip", "error", "base", "status", "phrase", "str", "parse", "el", "lo", "feed", "model", "one", "log", "le", "row", "nl", "lined", "sl", "plugin", "string", "name", "Line", "response", "lines", "word", "section", "end", "li", "no", "link", "write", "next", "character", "code", "look", "LINE", "day", "band", "definition", "text", "body", "rule", "block", "sync", "strip", "message", "key", "lf", "page", "lin", "data", "l", "letter", "style", "inline", "entry", "frame", "pass", "value", "split", "liner", "part", "comment", "side", "item", "cell"], "strBuilder": ["stringbuilder", " strBuilding", "StrBuffer", "stringBuilding", "stringBuild", "stringBuilder", "brbuilder", "brBuild", "StrBuild", "brBlock", "strBuild", "strBuffer", "Strbuilder", " strBuild", "StrBlock", "StrBuilding", " strBlock", "strbuilder", "brBuffer", "brBuilder", "StrBuilder", " strbuilder", "strBlock", "stringBuffer", " strBuffer", "brBuilding", "strBuilding"], "pieces": ["services", "objects", "tops", "groups", "marks", "steps", "seconds", "letters", "places", "flows", "forms", "lists", "values", "sections", "cells", "lines", "styles", "files", "rings", "words", "strings", "circle", "items", "vals", "ops", "tips", "bits", "pots", "pins", "nets", "boxes", "apps", "parts", "blocks", "cards", "bytes", "ips", "pages", "planes", "phones", "piece", "keys", "packs", "cuts", "bones", "split", "names", "features"], "found": ["first", "defined", "result", "required", "updated", "left", "filled", "valid", "not", "old", "got", "created", "based", "val", "fl", "true", "identified", "Found", "made", "given", "err", "missing", "failed", "normal", "all", "lost", "confirmed", "used", "count", "null", "changed", "find", "built", "still", "matched", "fall", " Found", "broken", "loaded", "successfully", "search", "l", "letter", "fixed", "printed", "successful", "full", "f", "sent", "expected", "finding", "temp"]}}
{"id1": "14783950", "id2": "2461169", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressWithJar", "compressedWithJar", "compresswithSax", "compressedUsingJar", "compressInSax", "compressUsingJar", "compressedUsingSax", "compresswithJar", "compressInZip", "compressedUsingZip", "compressUsingZip", "compresswithZip", "compressUsingSax", "compressedWithZip", "compressedWithSax", "compressWithSax", "compressInJar"], "fileList": ["FileChain", "ziplist", "wordString", "fileStream", "modelList", " fileChain", "Filelist", "stringList", "modelStream", "stringChain", "zipSet", "modelEx", "FileName", "FileSet", "stringName", " fileCollection", "inputEx", "inputStream", " fileSet", "modelCollection", "fileChain", "fileEx", "inputList", " fileStream", "stringlist", "FileString", " fileString", "zipList", "fileCollection", "wordName", "fileString", " fileEx", "FileStream", "zipName", "inputCollection", " filelist", "FileList", "wordList", "fileSet", "wordStream", "filelist"], "zipFileName": ["archiveFileDir", "zipFileNames", "folderGlobalPath", "zipFullNames", "zipFilePath", "archiveDirName", "folderGlobalName", "zipPackageDir", "archiveFilePath", "zipFullname", "zipGlobalPath", "zipDirName", "folderGlobalname", "zipGlobalNames", "zipPackageName", "zipGlobalname", "folderFilePath", "zipFullPath", "folderFileName", "zipDirNames", "archiveDirPath", "archiveFileName", "zipFilename", "archiveDirDir", "zipFullName", "folderGlobalNames", "zipGlobalName", "zipPackagePath", "zipFullDir", "folderFileNames", "folderFilename", "zipFileDir", "zipDirDir", "zipDirname", "zipDirPath"], "fos": ["afaos", " fosh", "flis", "afos", "infis", "Fosh", "Fos", "foS", "Fis", "flosh", "afis", "fosh", "infaos", "afoS", "infoS", "infos", "FoS", "flos", "faos", "Faos"], "zos": ["z", "osi", "outs", "zzy", "onz", "ZA", "zar", "kos", "zip", "seconds", "bis", "zers", "spin", "chini", "es", "zon", "budget", "tz", "uz", "jobs", "zen", "zes", "os", "ses", "bag", "zl", "phi", "webkit", "bos", "zan", "dos", "zer", "iframe", "zo", "ozo", "zi", "LOS", "fits", "lins", "oses", "css", "zx", "nz", "zz", "fi", "zag", "rez", "abi", "cos", "inos", "jas", "zb", "ZI", "gz", "loop", "packs", "bes", "zik", "closure", "obb", "ros", "lol", "zy"], "iter": ["ser", "oper", "test", "ip", "chain", "ter", "upper", "itter", "enter", "parse", "finder", "el", "e", "ator", "inc", "sort", "cher", "index", "er", "former", "keep", "iz", "ir", "end", "inner", "liter", "set", "err", "next", "order", "iner", "Iterator", "ie", "i", "ite", "fer", "loc", "list", "walker", "gener", "ner", "inse", "outer", "slice", "fr", "it", "iterator", "is", "http", "file", "izer", "Iter", "coll", "inter", "f", "ener"], "fileName": ["FileType", " filePart", "FileLine", "fPart", "currentname", "localname", "localPart", "FileUrl", " filePath", "currentData", "localPath", "pageName", "filenameInfo", " fileUrl", "filename", "FileName", "currentUrl", "currentName", "fileOpen", "pagename", "fileLine", "filenamename", " fileFull", "fileData", " fileOpen", "simpleOpen", "filenameName", "fName", " fileData", " fileInfo", "fullPath", "fullOpen", "FileString", "filePart", "fileType", " fileString", "FilePath", "filenameFull", "FilePart", "fileInfo", "fLine", "fileFull", "fullName", "fileString", " filename", "FileFull", " fileLine", " fileType", "fname", "simplePath", "simpleName", "filePath", "FileInfo", "localName", "pageString", "FileData", "fileUrl", "pageType", "Filename"], "ind": ["bind", "mind", "z", "id", "inc", "Ind", "x", "index", "div", "val", "pt", "start", "length", "ded", "pend", "end", "rib", "ci", "len", "ii", "j", "i", "count", "eff", "pull", "loc", "ord", "cond", "fr", "ad", "inn", "wind", "ix", "nd", "in", "vert", "ld", "dir", "mid", "pos", "IND", "d"], "shortName": ["ShortPath", "smallName", "longName", "ShortPart", "fullLine", "smallname", "shortPart", "longPart", "smallPart", "longname", "smallPath", "shortname", "fullString", "fullname", "longPath", " shortString", "fullPath", " shortname", " shortLine", "ShortString", "fullName", "shortString", "Shortname", "shortPath", " shortPath", "longLine", "shortLine", "ShortName"], "fis": [" fiss", "fris", "cfis", "gisa", "afos", "Fos", " fisa", "Fis", "fios", "afis", "cfiss", "pis", "Fiss", "gios", "pris", "Fs", " fios", "fs", "gris", "fiss", " fs", "afiss", "cfos", "gis", "afris", "cfris", "cfs", "pisa", " fris", "pios", "fisa"], "buf": ["vec", "uf", "bc", "v", "uc", "bb", "bin", "tmp", "br", "bd", "cv", "bp", "cur", "fb", "ba", "seq", "queue", "bl", "bag", "box", "batch", "Buff", "lb", "b", "grab", "ff", "loc", "wb", "buffer", "done", "la", "bytes", "rb", "fd", "feat", "rc", "data", "pb", "bh", "bf", "lim", "cb", "buff", "bu"], "bytesRead": [" bytesSkip", "flowsLength", "bitsSkip", "secondsRead", "tesSkip", "secondsNeed", "secondsWrite", "wordsRead", "bitsRead", "secondsLength", "flowsRead", "flowsNeed", "tesWrite", "wordsWrite", "bytesSkip", " bytesUse", " bytesWrite", "bytesWrite", "bytesLength", " bytesLength", "flowsWrite", "bitsLoad", "bitsWrite", "tesLoad", "wordsUse", " bytesNeed", "bytesUse", "tesRead", " bytesLoad", "wordsLength", "bytesNeed", "bitsUse", "bytesLoad", "bitsLength"]}}
{"id1": "23273706", "id2": "14598566", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectTreeMeta", "getProjectDocumentData", "getProjecttreeInfo", "getprojecttreeInfo", "getProjectPageDATA", "getProjectTreeInfo", "getProjectPageMeta", "getprojecttreeDATA", "getProjectDocumentInfo", "getprojectTreeInfo", "getprojectTreeData", "getProjectTreeDATA", "getprojecttreeData", "getprojectTreeDATA", "getprojecttreeMeta", "getProjectPageData", "getProjectDocumentDATA", "getProjecttreeDATA", "getprojectTreeMeta", "getProjecttreeMeta", "getProjecttreeData", "getProjectPageInfo", "getProjectDocumentMeta"], "treeData": ["monkeyArray", "storyDec", "bodyData", "contentData", "reeData", "contentInfo", "reeArray", "monkeyDat", "treeArray", "bodyString", "monkeyData", "treeDec", "TreeArray", "reeInfo", "reeList", "contentDat", " treeDec", " treeList", "bodyDat", "TreeList", " treeString", "reeString", "treeList", " treeArray", "treeString", "contentText", "treeText", "storyDat", "bodyList", " treeText", "storyData", " treeInfo", "monkeyDec", "TreeInfo", "TreeString", "storyArray", "reeDat", "treeInfo", "treeDat", " treeDat", "TreeData", "reeText"], "filename": ["fp", "url", "dylib", "FILE", "title", "whatever", "jpg", "dll", "metadata", "tmp", "fil", "kl", "kj", "path", "folder", "xml", "nil", "location", "name", "string", "prefix", "upload", "database", "files", "journal", "username", "SourceFile", "ppa", "directory", "wav", "uri", "kn", "fd", "data", "fn", "file", "sheet", "password", "figure", "framework", "ername", "txt", "Filename"], "urlString": ["URLStr", "urlUrl", "locationStr", "urlStr", "URLURL", " urlStr", "addressURL", " urlURL", "URLstring", "addressStr", "URLUrl", " urlUrl", "URLString", "locationString", "urlstring", "urlURL", "addressstring", "locationstring", "locationUrl", "addressString", " urlstring"], "urldata": [" urlddata", "urlfdata", "urlldata", "URldata", "URlddata", "urlfat", "URlfat", "urldat", "urllat", "urledta", "urlddata", "URldat", "urlledATA", " urldATA", "urllata", "urLDta", "URlfdata", "urldta", "urLDATA", "urlledata", "urlfATA", "URlfATA", "urlfata", " urLDta", " urLDATA", "URldATA", " urLData", " urLDdata", "urleddata", "urledATA", " urldta", "urLData", "urlledta", "urLDat", "urLDdata", "urledata", "urllATA", "urlleddata", "urldATA", "URlfata"], "factory": ["ufiller", "pault", "luild", "confFactory", " fictionary", "filler", "piller", "cFactory", "ufictionary", "cault", "flier", "cactory", " fFactory", "confactory", " fuild", "liller", "pFactory", "cfFactory", "ufuild", "fuild", "fault", "ufactory", "conflier", "fFactory", "ciller", "pactory", "cfiller", "cflier", " flier", "fictionary", " fault", "cfactory", "confiller", "lactory", "lictionary", " filler"], "parser": ["ger", "reader", "util", "builder", "parse", "monkey", "lp", "xml", "fruit", "plugin", "arser", "er", "auto", "string", "s", "driver", "pdf", "raf", "t", "writer", "r", "ph", "Parser", "b", "library", "root", "parent", "jack", "handler", "loader", "uri", "api", "p", "http", "l", "se", "up", "instance", "json", "utils", "manager"], "u": ["yu", "us", "su", "uf", "url", "hu", "tu", "util", "U", "io", "ou", "iu", "ui", "s", "uni", " ur", "uv", "c", "lu", "cu", "b", "nu", "eu", "o", "ur", "ul", "uri", "ru", "p", "uu", "http", "plug", "l", "d", "universal"], "is": ["us", "serv", "ais", "ip", "ai", "ib", "ob", "iso", "isa", "has", "io", "ar", "are", "IS", "bis", "Is", "es", "abs", "ir", "s", "ui", "ris", "isl", "iss", "ios", "or", "ie", "info", "ori", "ops", "lis", "ri", "isu", "uri", "fs", "api", "p", "it", "iris", "gets", "http", "in", "its", "obs", "init", "as", "mis", "pi"], "os": ["sys", "us", "OS", "osi", "Os", "ms", "ob", "iso", "io", "aos", "bis", "es", "oss", "s", "oes", "ios", "bs", "or", "bos", "oos", "dos", "ops", "so", "ose", "o", "ps", "fits", "oses", "los", "fs", "opens", "gets", "obs", "http", "cos", "oa", "ens", "pos", "as", "ol", "ros", "ils"], "iBufSize": ["iBbufLen", "iLlfsize", "iBufLen", "iBlfsize", "iBufsize", "iByteufLength", "iLufSt", "iBuffersize", "iBuffSize", "iBufLength", "iByteufLen", "iLufLength", "iBuffLen", "iByteufsize", "iBufferLength", "iBbufsize", "iLlfSt", "iBuffSt", "iBufSt", "iBbufLength", "iBytebufLength", "iBytebufLen", "iBytebufsize", "iBufferSt", "iBuffLength", "iBufferSize", "iBuffsize", "iBlfLength", "iBytebufSize", "iLlfSize", "iByteufSize", "iLlfLength", "iBlfSize", "iBlfSt", "iBlfLen", "iLufsize", "iLufSize", "iBbufSize"], "inBuf": ["inBuffub", "inBunk", "inBuff", "inFuff", "inBbuf", "inPluf", "outBub", "inBub", " inFbuf", "inBuffuf", "inDaf", "inCump", "inCuff", "inCuf", "inFuf", "inBlump", "inCaf", "inbub", " inBaf", "inbuf", "inbump", "inBaf", "inFbuf", " inBuff", "inPlunk", " inCunk", " inBump", " inFuf", "inBuffbuf", " inBbuf", "inBluf", "inFaf", "inDbuf", "inBlunk", " inBunk", "outBuf", " inFuff", " inCuf", "inBuffump", "inCunk", "inbbuf", "outBuffump", " inCbuf", "outBbuf", "inPlbuf", "outBuffuf", "inDuff", "inBump", "inBlbuf", "inDuf", "inBlub", "outBump", "outBuffub", " inCump", "outBuffbuf", "inCbuf", " inFaf", "inPlump"], "iNumRead": ["inumWrite", "iLenWritten", "qiValREAD", "inumread", " iNumWrite", "iNumberRead", "iChanread", "pNumRead", " iNumWritten", "pNumread", "qiValRead", "iNumWritten", " iFatWritten", "pNumberWritten", "pNumberRead", "iValread", "pNumWritten", "iFatRead", "iNumberWrite", "pNumWrite", "pNumberWrite", "iNumberread", "iNumWrite", "iChanREAD", "iNumBuild", "qiNumBuild", "iNumberWritten", " iFatRead", "iValBuild", "iValREAD", "qiValread", "inumRead", "iFatWrite", "iNumREAD", "iLenWrite", "iLenRead", "iValRead", "qiValBuild", "iNumberBuild", "iNumberREAD", "qiNumREAD", "qiNumread", "pNumberread", "iNumread", "inumWritten", "iChanRead", "iFatWritten", " iFatWrite", "qiNumRead", "iChanBuild"], "f": ["uf", "v", "fp", "e", "feed", "io", "rf", "df", "s", "c", "fe", "fa", "m", "t", "j", "r", "g", "b", "n", "o", "F", "ff", "handler", "fc", "fr", "fs", "p", "h", "fd", "fi", "l", "fn", "file", "d", "full", "sf"], "inputstream": ["Inputchannel", "outputStream", " inputStream", "outputchannel", " inputsw", "contentsystem", "Inputsw", " inputchannel", "contentsw", "inputStream", "inputchannel", "Inputstream", "contentStream", "outputstream", " inputsystem", "inputsystem", "contentstream", "Inputsystem", "InputStream", "inputsw"], "document": ["project", "output", "e", "window", "container", "xml", "docs", "node", "context", "language", "doc", "m", "t", "info", "html", " documents", "null", "object", "n", "directory", " documentation", "parent", "list", "Document", "tree", "media", "ocument", "office", "p", "DOM", "content", "dom", "page", "l", "data", "source", "file", "d", "director", "collection", "record", "Documents", "response"], "nodelist": [" nodette", "anodata", "anodedata", "nonedels", "nodedeme", "nodedemark", "nodeline", " nodesette", "nodeselist", "nonedette", "nodedestate", " nodesels", "nodsette", "Nodemark", "nodselist", "nODette", "nodestate", "snodelist", "nodslist", "nozels", "nondelist", "nodedestyle", "nodesels", "nodesh", "nodesette", "NODemark", "nodeelist", "nodeata", " nodesename", "snodeline", "nodata", "snodselist", "Nodestyle", "nodlist", "nonedelist", "nondata", " nodename", "nODelist", "nodedata", "snodsette", "anodelist", "nozename", "nozestyle", "NODestyle", "nondeme", "nodette", "nODeline", "nondestate", "nonedename", " nodeselist", "nODesh", "snodslist", "nodeme", "Nodelist", "nodestyle", "nodseline", "nODlist", "nodedesh", "nozette", "nodedeline", "nodedette", "anodedelist", "anodedeme", "nozelist", "nodemark", "nodesename", "nODestyle", "Nodesh", "snodseline", "nodedlist", "NODesh", "nodeeme", "snodette", "nodedelist", "nodels", "anodestate", "nodename", "nodeestate", "nODemark", "NODelist", "snodlist", "nozemark", "anodedestate", "anodeme", " nodels", "nozesh"], "num": ["net", "comb", "nb", "inc", "Num", "total", "um", "nr", "index", "div", "node", "nom", "nam", "max", "uni", "multi", "umi", "len", "dim", "np", "zero", "mon", "m", "norm", "en", "count", "om", "NUM", "number", "n", "nu", "span", "mult", "loc", "ul", "uri", "dom", "col", "init", "pos", "tri", "con", "lim", "unit", "sum", "part", "mu", "temp"], "i": ["qi", "v", "iv", "ip", "ai", "ti", "I", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "start", "li", "ui", "hi", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "m", "j", "ie", "info", "ori", "g", "b", "a", "o", "bi", "slice", "isi", "ri", "uri", "p", "gi", "it", "fi", "ix", "di", "oi", "in", "cli", "l", "col", "ik", "d", "yi", "chi", "ji", "part", "mu", "pi"]}}
{"id1": "9954926", "id2": "4562786", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "label": 0, "substitutes": {"simulate": ["simure", "Simulate", "animure", "simulator", "imulation", "imulate", "Simulator", "simulation", "animulator", "animulate", "imulator", "Simure", "Simulation", "animulation", "imure"], "out": ["external", "error", "outs", "cache", "gen", "window", "tmp", "raw", "log", "session", "name", "conn", "plain", "writer", "report", "null", "post", "flush", "data", "server", "full", "group", "part", "client", "db", "string", "state", "word", "lock", "write", "prefix", "down", "Out", "user", "object", "o", "buffer", "key", "store", "in", "page", "cli", "pool", "dump", "comment", "exit", "net", "result", "base", "OUT", "w", "now", "io", "obj", "err", "lib", "info", "again", "parent", "list", "outer", "resource", "copy", "con", "temp", "sys", "flow", "output", "bin", "view", "exp", "pre", "ex", "co", "table", "point", "line", "up"], "file": ["fp", "url", "address", "FILE", "base", "cache", "output", "port", "feed", "path", "log", "filename", "name", "stream", "queue", "ile", "files", "fe", "File", "connection", "report", "pe", "b", "rule", "handler", "socket", "loader", "buffer", "message", "resource", "l", "line", "data", "in", "source", "page", "full", "collection", "unit", "book", "f", "le"], "obtainUserReputationRequest": ["obtainUserRepentionResponse", "obtainUserRepulationEntry", "obtainUserRepentionrequest", "obtainUserReputeResponse", "obtainUserComputeEntry", "obtainUserReputerequest", "obtainUserReputionGrant", "obtainUserRepigrationResponse", "obtainUserReputedResponse", "obtainUserRelutationGrant", "obtainUserRepigrationQuery", "obtainUserReputationEntry", "obtainUserAnnutationResponse", "obtainUserAnnutationQuery", "obtainUserReputationInfo", "obtainUserComputerequest", "obtainUserRepigrationrequest", "obtainUserReputionResponse", "obtainUserReputeRequest", "obtainUserRepentionGrant", "obtainUserRepigrationRequest", "obtainUserReputationrequest", "obtainUserAnnigrationQuery", "obtainUserRepositoryInfo", "obtainUserRelutationRequest", "obtainUserAnnigrationGrant", "obtainUserRelentionrequest", "obtainUserAnnutationRequest", "obtainUserRelutationResponse", "obtainUserReputeInfo", "obtainUserRepurationResponse", "obtainUserRelentionGrant", "obtainUserRepositoryRequest", "obtainUserAnnigrationRequest", "obtainUserRelentionResponse", "obtainUserComputationEntry", "obtainUserRelentionRequest", "obtainUserRepentionRequest", "obtainUserComputationInput", "obtainUserComputationRequest", "obtainUserComputeRequest", "obtainUserRepositoryrequest", "obtainUserRepurityInput", "obtainUserRepulationResponse", "obtainUserReputableResponse", "obtainUserReputeQuery", "obtainUserRepurationGrant", "obtainUserRepurationQuery", "obtainUserComputationInfo", "obtainUserComputationrequest", "obtainUserComputationResponse", "obtainUserReputablerequest", "obtainUserReputeEntry", "obtainUserAnnutationGrant", "obtainUserReputeGrant", "obtainUserRepurationRequest", "obtainUserComputeInfo", "obtainUserReputedrequest", "obtainUserReputedGrant", "obtainUserReputableRequest", "obtainUserReputionRequest", "obtainUserRepurityEntry", "obtainUserRepositoryResponse", "obtainUserRepurityRequest", "obtainUserRepigrationGrant", "obtainUserReputationInput", "obtainUserRelutationrequest", "obtainUserReputeInput", "obtainUserRepigrationInfo", "obtainUserReputationGrant", "obtainUserRepulationRequest", "obtainUserComputeInput", "obtainUserReputedRequest", "obtainUserRepurityResponse", "obtainUserRepulationInput", "obtainUserReputationQuery", "obtainUserReputionrequest", "obtainUserComputeResponse", "obtainUserAnnigrationResponse"], "obtainUserReputationResponse": ["obtainUserExputationRequest", "obtainUserRepurationResponse", "obtainUserRepurationRequest", "obtainUserReputationResp", "obtainUserRepositoryRequest", "obtainUserExpositoryRequest", "obtainUserReputeRequest", "obtainUserReputeResponse", "obtainUserRepositoryResponse", "obtainUserExputationResponse", "obtainUserExpositoryResponse", "obtainUserRepositoryResp", "obtainUserReputeResp", "obtainUserExputationResp", "obtainUserExpositoryResp", "obtainUserRepurationResp"], "rateUserRequest": ["issueCustomerForce", "rateUResponse", "rateMachineRequest", "ratedUserRequest", "ratedUserFunction", "issueCustomerQUEST", "RateFileResponse", "rateFileResult", "rateUCustomer", "gradeLineRequest", "ratedFileRequest", "rateUsageForce", "rateUsRequest", "gradeLineCustomer", "rateUsageResponse", "ratePostrequest", "ratedFileFunction", "rateFileQuery", "RateUserQUEST", "gradeUserRequest", "rateuserRequest", "rateCustomerRequest", "rateClientRequest", "rateUsageReturn", "rateLineQUEST", "rateUserQUEST", "rateLineQuery", "rateUsageQUEST", "rateHumanVersion", " rateuserQUEST", "rateUSERForce", "ratePostQUEST", "rateFileCommand", "rateUsForce", "ratePostRequest", "rateUsageGrant", "RateFileQUEST", "ratedUsageRequest", " rateuserRequest", "featureUserRequest", "rateUCommand", "rateUSERQUEST", " rateClientrequest", "rateUserVersion", " rateUserrequest", "rateLinerequest", "issueUserForce", "rateWordRequest", "rateServiceRequest", "rateUQuery", "rateFileFunction", " rateuserResponse", "rateUserReturn", "rateUError", "issueCustomerReturn", "rateUserCustomer", "rateApplicationUser", "rateClientGrant", "rateFilerequest", "rateUSERRequest", "rateLineResponse", "rateWordrequest", "rateUsageQuery", " rateApplicationRequest", "rateUsQUEST", "RateFilerequest", "ratedUsageForce", "ratedUsagerequest", "ratedUserForce", "featureMachineResult", "rateLineError", "rateMachineResult", " rateuserrequest", "rateApplicationQuery", "rateMachinerequest", " rateUserGrant", "rateUsageUser", "ratedFileQuery", "rateURequest", "rateuserQUEST", "rateUserGrant", "rateFileResponse", "ratedUsageQUEST", "ratePostResponse", "featureMachineRequest", "rateUFunction", "rateMachineVersion", "rateHumanrequest", "rateServiceQuery", " rateUserQuery", "RateUserrequest", "rateUserrequest", "rateFileVersion", "issueUserQUEST", "rateUserError", "rateUserUser", "rateUserQuery", "rateApplicationRequest", "featureUserResult", "rateUserCommand", "rateUsagerequest", "rateWordCustomer", "rateUsageRequest", "rateuserResponse", "ratedFileCommand", " rateApplicationResponse", "gradeLinerequest", "ratedUserQuery", "rateUserResult", "featureUserVersion", " rateClientGrant", " rateUserQUEST", "rateWordQuery", "RateUserRequest", "rateHumanResult", "rateCustomerQUEST", "rateHumanRequest", " rateClientRequest", "rateCustomerForce", "rateUsReturn", "rateWordError", "featureMachineVersion", "rateFileUser", "gradeUserCustomer", "rateUrequest", "ratedUserCommand", "featureMachinerequest", "rateServiceFunction", "issueUserRequest", "RateUserResponse", "ratedUserrequest", "ratedUsageQuery", "rateClientrequest", "rateUQUEST", "rateFileRequest", "rateUserFunction", "rateUSERrequest", "rateUserForce", "issueUserReturn", "featureUserrequest", "ratedUserQUEST", " rateApplicationQuery", "rateCustomerReturn", "rateServiceCommand", " rateUserUser", "rateLineRequest", "gradeUserError", "issueCustomerRequest", "gradeLineError", "RateFileRequest", "gradeUserrequest", " rateApplicationUser", "rateLineGrant", "rateUForce", "rateuserrequest", "rateLineCustomer", "rateApplicationResponse", "rateFileQUEST"], "rateUserResponse": ["rateUsersStatus", "rateUResponse", "rateTimeStatus", "rateUserReply", "rateFileResult", "RateTimeResp", "rateCustomStatus", " rateFileResult", " rateApplicationResp", " rateUReply", "RateUserStatus", "rateUResp", "rateTimeResponse", "rateCustomerRequest", " rateUResponse", " rateUserReply", "rateUresponse", "rateClientResp", "rateCustomResponse", "rateClientStatus", "rateUserResp", " rateFileResponse", "rateApplicationResp", "rateFileResp", " rateUserResp", "rateUsersResp", "rateUsersRequest", " rateApplicationData", "rateuserResult", "rateFileReply", "rateUserData", "RateUserResp", "rateUserCustomer", "rateUserReference", " rateUserresponse", "rateuserReference", "rateTimeCustomer", "rateUserStatus", "rateClientCustomer", "rateUserResource", "rateApplicationData", "rateuserReply", "rateUReply", "rateFileResponse", " rateUserResult", "rateCustomResp", " rateUResp", "rateuserStatus", "rateCustomerResponse", "rateCustomerData", "rateUserresponse", "rateuserResponse", " rateApplicationResponse", "rateUserResult", "rateFileStatus", "RateUserRequest", " rateUserData", " rateUserReference", "RateTimeResponse", "rateFileresponse", "rateuserResp", "rateuserresponse", "rateUsersResource", "RateTimeStatus", "rateApplicationReference", "rateuserData", "rateTimeResp", "rateCustomerResource", "RateUserResponse", "RateUserCustomer", " rateFileResp", "rateUsersResult", " rateUserStatus", " rateFileStatus", "rateUsersResponse", "RateTimeCustomer", " rateApplicationReference", "RateUserResource", "rateClientResponse", "rateCustomerReference", "rateCustomCustomer", "rateCustomerResp", "rateApplicationResponse", " rateUresponse"], "fis": [" fiss", "fris", " fIs", "bis", "sfris", "sfIs", "bIs", "FIs", "Fris", "bris", "biss", "fIs", "Fis", "Fiss", "sfiss", "fiss", " fris", "sfis"], "br": ["bc", "result", "reader", "str", "ob", "bp", "ber", "io", "arr", "brush", "ler", " tr", "res", "hr", "bridge", "fin", "cr", "err", "bro", "bl", "wr", "Br", "Reader", "bed", "r", "b", "browser", "buf", "body", "tr", "fr", "buffer", "lr", "rb", " fr", "dr", "BR", "ch", "gr", "ref", " bio", "sp", "sw", "bs", "pr"], "call": ["flow", "address", "url", "result", "cl", "voice", "cod", "str", "output", "e", "comment", "phone", "ell", "use", "load", "invoke", "throw", "check", "request", "xml", "input", "string", "name", "play", "Line", "contact", "c", "doc", "callback", "code", "type", "charge", "info", "Call", "cu", "user", "text", "body", "query", "co", "loc", "buffer", "message", "calling", "ck", "line", "data", "work", "sc", "push", "claim", "fax", "create", "roll", "cat", "called", "ack", "f", "response", "cell", "msg"]}}
{"id1": "21425787", "id2": "18974466", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "in": ["exec", "url", "base", "ins", "reader", "IN", "login", "bin", "id", "io", "inc", "ini", "index", "input", "In", "name", "inner", "image", "c", "m", "or", "at", "a", "i", "connection", "b", "ex", "again", "inn", "min", "source", "work", "file", "up", "data", "ac"], "out": ["exec", "v", "result", "base", "OUT", "client", "outs", "cache", "w", "call", "output", "io", "inc", "x", "target", "name", "conn", "to", "c", "prefix", "off", "Out", "at", "writer", "connection", "user", "b", "ex", "n", "object", "again", "o", "dest", "p", "point", "data", "source", "file", "server", "up", "part", "temp"], "sourceChannel": ["srcConnection", "SourceStream", "sourceSocket", " sourcechannel", "targetchannel", "sourceStream", "ourcechannel", "resourceConnection", "ourceSocket", " sourceStream", "sourceChan", "srcSocket", "ourceChan", "Sourcechannel", "resourceChan", "resourceChannel", "resourcechannel", " sourceSocket", "srcChan", "targetStream", "targetChannel", " sourceChan", "SourceChannel", " sourceConnection", "SourceConnection", "ourceChannel", "srcChannel", "SourceChan", "sourcechannel", "targetChan", "ourceConnection", "sourceConnection"], "destinationChannel": ["destationchannel", "destinationStream", "destinatorChan", "destinatedChan", "DestinatorConnection", "destationChannel", "destinatedFile", "DestinatingStream", "destructionChannel", "destinatorchannel", "DestinationFile", "destructionChan", "Destinationchannel", "DestinationStream", "destinationChan", "destinatedChannel", "DestinatorChan", "Destinatorchannel", "DestinatingChannel", "destationConnection", "DestinatingManager", "destinatorFile", "destinationFile", "destinatedConnection", "destinatorChannel", "destinatingChan", "destinateChan", "destinatorManager", "destinatingStream", "destinatedchannel", "destinationchannel", "DestinationChan", "DestinationConnection", "destinatorStream", "destinatingManager", "destinateConnection", "destationFile", "destinationManager", "DestinatingChan", "destinatedManager", "destinatorConnection", "destinatedStream", "DestinationManager", "destructionConnection", "DestinatorFile", "destinationConnection", "DestinationChannel", "DestinatorChannel", "destinatingChannel", "destinateChannel"]}}
{"id1": "841724", "id2": "732800", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewwrite", "readandRewrite", "readandrewrites", "readAndSwrites", "readAndrewrite", "readAndRebrite", "readandRewwrite", "readAndrewwrite", "readAndRebrites", "readandrewwrite", "readandrewrap", "readAndSwwrite", "readandRewrap", "readandRewrites", "readAndrewrap", "readAndRewrites", "readAndrewrites", "readAndRebrap", "readAndRewrap", "readAndSwrap", "readandrewrite", "readAndSwrite", "readAndRebwrite"], "inFile": ["oldFilename", "InFiles", "Infile", "oldFiles", "loginFilename", "inputFile", "InFile", "InSourceFile", "loginFile", "infile", "oldfile", "inputFiles", "oldFile", " infile", "inputFilename", " inFilename", "loginfile", "outfile", "loginFiles", "inFilename", " inSourceFile", "outSourceFile", "inFiles", "outFiles", "outFilename", "inSourceFile", " inFiles", "inputfile"], "outFile": ["newDir", "thisfile", "outDir", "processPlace", "OutStream", "thisFILE", "OutDir", "outFILE", "newFile", "offFile", "offFILE", "thisFilename", "outputFILE", "outStream", "outputFilename", "offFilename", " outfile", "exfile", "offPlace", "processFILE", "outputPlace", "thisFile", "processFilename", " outStream", " outDir", "outputfile", "newfile", "newStream", "exFilename", "outfile", "exFILE", "outPlace", "OutFile", "processFile", "exFile", "Outfile", "outFilename", "outputFile"], "iis": ["Iis", "iiris", " iiss", "iiIs", "ciIs", "ciIS", "ciis", "Iiss", "Iais", "iniiss", "iniIs", "iiss", "iniris", "ciais", "iiiss", " iIS", "iniIS", " iais", "iIS", " iIs", "iiIS", "iIs", " iris", "iris", "ciiss", "iniis", "iiis", "IIS", "ciris", "iais"], "dcmParser": [" dcrPlugin", "dmParser", " dcmHelper", " dcmarser", "fcmHandler", "dpmPlugin", "dcrPar", "fpmParser", "dCMReader", "dcmLoader", " dcmPlugin", "dpmLanguage", "dkmParser", "fpmparser", "dcmHelper", " dpmLanguage", "dmcParser", "dbmPolicy", "dcrReader", "dmcPar", " dpmParser", "dmissionReader", "dCMHandler", " dcmparser", "dmissionPlugin", "dmPlugin", "dmmparser", "dCMParser", "dpmHandler", "dbmHelper", "dpmReader", "dpmInstallation", " dcrLoader", "dbmPlugin", " dpmarser", "dmmLoader", "dhemJar", "dmoduleparser", "DcmReader", " dcrParser", " dpmJar", "dcmPolicy", "DcmInstallation", "dhemInstallation", "dmcJar", " dpmPolicy", "dpmparser", " dpmHelper", "dmissionLanguage", "dcmPar", " dpmparser", "dcmReader", "dpmPar", "fpmHandler", "dmodulePlugin", "dkmPlugin", "dbmParser", "dcmparser", " dcmPar", "dkmPolicy", "dmoduleParser", "dcrPlugin", "fcmParser", "dCMPlugin", "dmoduleJar", "dmcarser", "dcmPlugin", "dmoduleReader", " dcmPolicy", "DcmJar", "dcrParser", " dpmPlugin", "dCMLoader", " dcrReader", "DcmParser", " dcmLanguage", "dpmJar", "dmissionParser", "dhemParser", "dcmarser", " dcmJar", "dcmInstallation", "dpmParser", "dCMparser", "dmmPlugin", "dcrLoader", "dcrarser", "fpmReader", " dpmPar", "dcrJar", "dpmLoader", " dpmLoader", "dmLoader", "dmmParser", " dpmReader", "dcmJar", "fcmReader", "dhemReader", "dkmHelper", "fcmparser", "dpmarser", "dpmHelper", "dpmPolicy", " dcmLoader", "dcmHandler", "dcmLanguage", "dmReader", " dcmReader"], "ds": ["sys", "services", "da", "Os", "ins", "Ds", "ays", "eps", "xs", "ts", "ils", "db", "vs", "tx", "ws", "nas", "ads", "df", "session", "ns", "ks", "asi", "ls", "s", "conn", "iss", "os", "dd", "Db", "gd", "des", "ys", "dat", "js", "cs", "vals", "drivers", "cdn", "ps", "sync", "pd", "dc", "parts", "uds", "ants", "dt", "dr", "di", "dds", "data", "is", "ld", "qs", "amps", "DS", "d", "src", "icks", "details", "utils", "points", "ss", "bs", "ros", "tes", "rs", "gs", "ras"], "pdReader": ["pcRead", "pcLoader", "dsreader", "hdWriter", "xdReader", "xdRead", "hdRunner", "hdStream", "pcWriter", "hdRead", "ddStream", "dsLoader", "pbRunner", "pcReader", "dsReader", "dsRead", "hdreader", "pbLoader", "hdLoader", "ddRunner", "pdLoader", "pbStream", "pdStream", "pdreader", "pdRunner", "dsWriter", "pbReader", "hdReader", "xdreader", "pdRead", "xdWriter", "ddReader", "ddLoader"], "out": ["external", "outs", "cache", "gen", "inc", "model", "session", "conn", "name", "doc", "ssl", "writer", "at", "null", "with", "data", "file", "full", "group", "part", "as", "client", "child", "term", "db", "dot", "s", "ext", "word", "to", "lock", "write", "down", "Out", "user", "object", "o", "her", "key", "store", "page", "in", "cli", "password", "device", "later", "net", "result", "base", "OUT", "w", "login", "io", "auto", "obj", "inner", "err", "lib", "code", "layer", "again", "parent", "over", "oder", "list", "outer", "copy", "director", "temp", "exec", "flow", "sys", "url", "img", "builder", "output", "exp", "default", "image", "order", "connection", "ex", " in", "co", "sync", "diff", "array", "point", "line", "up", "pass", "dev", "manager"], "dcmEncParam": ["dcmElType", "dcmEnParam", "dcmEstType", "dcmEstPar", "dcmDecPart", "dcmDecParameter", "dcmArchParameter", "dcmEnArg", "dcmEncArg", "dcmElPar", "dcmEncParameter", "dcmDecType", "dcmSecType", "dcmEncPart", "dcmDecParam", "dcmEnType", "dcmSecPart", "dcmEncType", "dcmArchParam", "dcmSecPar", "dcmEnPart", "dcmSecParam", "dcmDecArg", "dcmEnPar", "dcmEstParam", "dcmElParameter", "dcmElParam", "dcmEstParameter", "dcmDecPar", "dcmEnParameter", "dcmArchArg", "dcmEncPar"], "pdWriter": ["PDWrite", "dpWrite", "hdWriter", "htReader", "ddWrite", "dpReader", "pdWriting", "dsOutput", "dsReader", "dpWriter", "hdWrite", "PDWriter", "dpWriting", "PDReader", "htWriting", "dsWriter", "hdReader", "htWrite", "htWriter", "PDWriting", "ddWriter", "ddOutput", "hdOutput", "pdOutput", "dsWrite", "ddReader", "pdWrite"]}}
{"id1": "19944975", "id2": "2461169", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["saveReport", " writeSection", " writeReport", "WriteConfiguration", "saveConfiguration", "WriteSection", "writeConfig", "writeReport", "saveConfig", "WriteReport", "saveSection", "WriteConfig", "writeSection", " writeConfig"], "out": ["exec", "external", "base", "OUT", "reader", "outs", "client", "IN", "w", "project", "scope", "output", "window", "exp", "io", "path", "xml", "filename", "res", "name", "string", "obj", "conn", "ext", "inner", "write", "prefix", "c", "this", "inas", "Out", "plain", "err", "lib", "m", "at", "writer", "connection", "report", "user", "ex", "object", "again", "parent", "o", "config", "list", "sync", "resource", "key", "flush", "line", "pool", "file", "server", "init", "password", "dump", "temp"], "url": ["address", "base", "rel", "ob", "feed", "io", "URL", "path", "xml", "sl", "Url", "location", "string", "conn", "stream", "image", "org", "ssl", "connection", "r", "b", "object", "ll", "config", "uri", "service", "resource", "api", "http", "l", "page", "source", "file", "server", "data", "channel", "open", "web", "f"], "in": ["serv", "gin", "ins", "din", "reader", "IN", "login", "bin", "id", "isin", "inc", "xml", "ini", "input", "In", "s", "conn", "stream", "inner", "cms", "c", "err", "inas", "ssl", "a", "i", "r", "b", "n", "again", "socket", "nin", "win", "resource", "inn", "min", "pin", "copy", "is", "cin", "data", "source", "file", "lin", "inside", "kin", "rin", "ac", "as", "f"]}}
{"id1": "19335986", "id2": "9236363", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["uncachedEvent", "unchandledexc", "uncatchedexc", "CatchedEvent", "unchandledEvent", "uncachedexc", "uncaughtexc", "CaughtException", "uncatchedEvent", "unchandledException", "Catchedexc", "CaughtEvent", "uncachedException", "uncaughtEvent", "CatchedException", "uncatchedException", "Caughtexc"], "t": ["title", "w", "ts", "tx", "T", "te", "out", "s", "c", "m", "type", " td", "r", "ty", " T", "g", "n", "tr", "ing", "tree", "p", "it", "l", "let", "d", "ed", "f"], "e": ["oe", "de", "esi", "error", "exc", "ele", "enter", "el", "ace", "Exception", "environment", "es", "er", "ge", "s", "ee", "err", "c", "E", "fe", "code", "m", "event", "ie", "en", "i", "element", "pe", "ec", "r", "j", "ception", "eu", "o", "example", "diff", "ae", "eb", "p", "me", "data", "ev", "se", "d", "ne", "f", "ep", "ed", "ce", "be"], "display": ["position", "de", "monitor", "console", "description", "panel", "status", "Display", "view", "app", "window", "platform", "container", "default", "design", "host", "screen", "play", "profile", "scroll", "image", "this", "fe", "report", "show", "object", "body", "hide", "config", "layout", "p", "dis", "content", "page", "me", "process", "style", "d", "summary"], "shell": ["exec", "cl", " Shell", "Shell", "console", "system", "status", "el", "app", "child", "container", "sound", "tools", "xml", "log", "environment", "host", "machine", "image", "lock", "m", "launch", "sb", "live", "bash", "b", "body", "kernel", "gui", "echo", "sym", "buffer", "mail", "copy", "h", "poll", "math", "sh", "l", "cli", "process", "server", "help", "loop", "ml", "clone", "hell", "tool"], "message": ["address", "monitor", "result", "header", "Message", "error", "mess", "console", "description", "status", "flash", "view", "output", "model", "xml", "log", "request", " messenger", " exception", "essage", "queue", "image", "m", "management", "event", "report", "application", "object", "body", "update", "mail", "buffer", "media", "content", "copy", "document", "translation", "meter", "page", "data", "server", "email", "member", "summary", "value", "response", "msg"], "e1": [" e2", "exc1", "exc8", "e2", " e8", "E3", "exc3", "exc2", "E8", " e3", "E2", "e3", "E1", "e8"]}}
{"id1": "12066447", "id2": "8932510", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"truncate": ["autuncate", "trunator", "tratenate", "truncational", "trunational", "trrenational", "trunation", "truncation", "trrenator", "autuncator", "trunate", "autatenational", "tratenational", "autatenate", "trrenate", "autuncational", "truncator", "tratenation", "trrenation", "tratenator", "autatenator", "autuncation", "autatenation"], "file": ["fp", "url", "address", "FILE", "base", "cache", " File", "local", "e", "zip", "io", "current", "model", "db", "path", "folder", "log", "function", "one", "filename", "out", "name", "string", "binary", "stream", "archive", "time", "queue", "image", "ile", "this", "files", "or", "format", "File", "type", "info", "connection", "class", "object", "directory", "body", "parent", "handler", "per", "future", "uri", "resource", "it", "plus", "document", "get", "single", "page", "l", "data", "source", "http", "line", "full", "f"], "backupRoot": ["BackbackFile", "BackupDirectory", "backupsDir", "backdownroot", "backbackFile", "backUpRoot", "frontupRoot", "backbackRoot", "backbackHome", "BackupDir", "backureHome", "backureRoot", "backflowroot", "backupDir", "backbaseDirectory", "BackupFile", "BackdownPath", "BackbackRoot", "backdownRoot", "BackdownDirectory", "backbackroot", "Backbackroot", "backUpDir", "backflowFile", "Backdownroot", "backflowDir", "backbackDir", "backupsroot", "backdownDirectory", "backbaseRoot", "backbasePath", "backuproot", "backbackDirectory", "BackureDirectory", "backdownFile", "backupsRoot", "backupsFolder", "frontuproot", "BackureHome", "backUproot", "backdownFolder", "frontupDir", "BackupPath", "Backuproot", "backdownHome", "backdownDir", "backflowRoot", "frontdownroot", "backupHome", "frontdownDir", "BackureRoot", "BackupRoot", "backureDir", "frontdownFolder", "backupFolder", "BackupHome", "backupFile", "frontupFolder", "frontdownRoot", "BackdownRoot", "backbaseroot", "backureDirectory", "backUpFolder", "backupDirectory", "BackbackDir", "backdownPath", "backupsDirectory", "backupPath", "backupsPath", "BackureDir"], "df": ["flow", "fp", "md", "de", "cf", "xf", "da", "dl", "dp", "io", " def", "dict", "func", "db", "tf", "fb", "pdf", "CF", "raf", "fe", "format", "dd", "dq", "deb", "def", "fc", "fr", "ds", "fs", "dc", "pd", "af", "fd", "dt", "dn", "di", "data", "fn", "d", "bf", "dm", "sf", "f", "DF"], "date": ["complete", "url", " Date", "re", "updated", "str", "output", "use", "pre", "valid", "Date", "db", "created", "x", "log", "ge", "input", "out", "name", "string", "time", "bug", "day", "code", "year", "m", "format", "custom", "type", "j", "pe", "dat", "tag", "rule", "back", "D", "ale", "diff", "sync", "update", "message", "version", "dates", "min", "form", "fee", "dt", "age", "ate", "data", "work", "dose", "style", "stage", "d", "create", "modified", "value", "atom", "open", "days", "module"], "zipFile": ["sqlFile", "zipModel", "zipfile", "ZipFiles", "zipFiles", "sqlfile", " zipEntry", "ressfile", "ressFile", "Zipfile", "zEntry", "zFile", "zipEntry", "ressSection", "zipSection", " zipfile", "zModel", "ZipFile", "ZipEntry", "sqlSection", "zSection", "zFiles", "ressModel", "sqlModel", " zipFiles", "zfile"], "zos": ["dylib", "z", "address", "las", "osi", "outs", "zzy", "bitcoin", "zh", "ZA", "zar", "kos", "zip", "proxy", "chini", "ls", "liquid", "zon", "tz", "budget", "uz", "zen", "zes", "os", "ses", "zona", "zl", "webkit", "bos", "ssl", "hess", "zan", "dos", "iffs", "zn", "js", "ops", "asio", "zer", "zo", "ozo", "zi", "fits", "lins", "css", "her", "los", "zx", "nz", "zag", "rez", "cos", "inos", "forge", "jas", "zb", "gz", " sands", "cash", "robe", "zik", "bes", "eros", "han", "closure", "obb", "ros", "nox", "exit", "zero", "ils", "zy", "settings"], "fis": ["lias", "Fias", " fiss", "flris", "rafiss", "flids", "fris", "flis", "Fisp", "liss", " fias", "flias", "fliss", "bis", "infis", "Fris", "rafias", "infiss", " fisl", "fiz", "infils", "fisp", "fils", "biss", "Fis", "infits", "Fisl", "Fos", " fils", "fias", "fisl", "vils", " fits", "bos", "rafis", "Fiss", "fids", "bisl", "lis", "viz", "flisp", "fits", " fiz", "infiz", "infias", "vis", "fiss", "vits", "fos", " fos", "infids", " fris", " fisp", "lids", "rafris"], "entry": ["address", "z", "de", "lc", "reader", "e", "zip", "feed", "exp", "ace", "term", "cel", "row", "index", "ge", "auto", "obj", "offset", "ui", "archive", "image", "next", "si", "card", "extra", "or", "event", "element", "ie", "info", "r", " Entry", "so", "Entry", "zo", "per", "the", "her", "uri", "array", "add", "it", "key", "ion", "ry", "data", "style", "letter", "se", "record", "server", "and", "ries", "comment", "cell"], "buffer": ["Buffer", "address", "position", "result", "header", "uffer", "reader", "cache", "bb", "beta", "transfer", "feed", "FFER", "vector", "available", "row", "border", "length", "sequence", "binary", "seed", "memory", "queue", "layer", "writer", "reference", "batch", "b", "shape", "buf", "number", "null", "slice", "pad", "padding", "iter", "wave", "bytes", "flush", "page", "data", "channel", "server", "device", "comment", "buff"], "readed": ["inputED", "inputled", "readized", "textized", "texted", "textED", " Readed", " readered", "readned", "textended", "readable", "bootED", " ReadED", "booted", " readned", "inputed", "intended", "bootered", " readended", " Readered", "readED", " Readled", " Readable", " readED", "inputned", "readled", "readended", " Readned", "bootable", "intED", " readized", "readered", " readable", " readled", "intized", "inted"]}}
{"id1": "9796161", "id2": "11049257", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": ["getSHA4", " getSHA4", "getMD4", "getmdHash", " getSHAHash", "getmd5", "getSHA5", "getSHA512", "getmd512", "getMDHash", "getmd4", " getMDHash", " getSHA5", "getSHAHash", " getMD4", "getHTML5", "getMD512", " getSHA512", "getHTML4", " getMD512", "getHTML512", "getHTMLHash"], "s": ["v", " ads", "services", "ms", "str", "scripts", "e", "sets", "ts", "rs", "ws", "ates", "es", "input", "ns", "abs", "string", "ls", "styles", "lines", "c", "si", "als", "ses", "self", "comments", "strings", "os", "ssl", "sb", "i", "a", "g", "b", "js", "n", "cs", " fails", "ps", "sym", "S", "sync", "ends", "ows", "ds", "parts", "p", "bytes", "its", "ips", "is", "l", "in", "data", "source", "f", "ss", "bs", "tests", "gs", "ings"], "m": ["cm", "md", "v", "im", "mc", "ms", "mr", "gm", "e", "rm", "pm", "am", "bm", "um", "manager", "machine", "fm", "mut", "man", "M", "c", "sm", "mi", "ym", "mand", "t", "i", "om", "arm", "mm", "tm", "em", "p", "h", "mac", "hm", "wm", "me", "l", "vm", "d", "nm", "dm", "mu", "f", "module"]}}
{"id1": "1586662", "id2": "20414923", "code1": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "code2": "    protected int deleteBitstreamInfo(int id, Connection conn) {\n        PreparedStatement stmt = null;\n        int numDeleted = 0;\n        try {\n            stmt = conn.prepareStatement(DELETE_BITSTREAM_INFO);\n            stmt.setInt(1, id);\n            numDeleted = stmt.executeUpdate();\n            if (numDeleted > 1) {\n                conn.rollback();\n                throw new IllegalStateException(\"Too many rows deleted! Number of rows deleted: \" + numDeleted + \" only one row should be deleted for bitstream id \" + id);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"Problem deleting bitstream. \" + e.getMessage(), e);\n            throw new RuntimeException(\"Problem deleting bitstream. \" + e.getMessage(), e);\n        } finally {\n            cleanup(stmt);\n        }\n        return numDeleted;\n    }\n", "label": 1, "substitutes": {"doOne": ["Do1", "do1", "go1", "doSync", "loone", "DoOne", "DoSync", "lo1", "loOne", "goSync", "doone", "loSync", "goone", "goOne", "Doone"], "bid": ["mad", "bc", "bn", "base", "sha", "wid", "received", "bit", "bb", "id", "aba", "bm", "ast", "paid", "seed", "sid", "oid", "bas", "bon", "year", "auth", "hid", "bed", "pid", "batch", "ban", "b", "vid", "bt", "ad", "ud", "la", "du", "rb", "abi", "lay", "bh", "ld", "mid", "ref", "bf", "chid", "aud", "uid", "ed", "cb", "bi", "rid"], "tid": [" tids", "trids", " tiden", "ptid", "tinfo", "timid", "pbase", "timbid", "ptiden", "tide", "Tide", "tbase", "tids", "trid", "paid", "piden", "Tbid", "tiden", "timID", "pide", " tide", "taid", "ptinfo", "Tbase", "Tid", "pid", " taid", "trbid", "tID", "Tids", "pinfo", " tinfo", " tbase", "TID", "pids", "tbid", "trID", "timids", "ptaid"], "aid": ["mad", "ga", "aned", "da", "sha", "pa", "ai", "ca", "Aid", "alias", "acid", "said", "ays", "ada", "id", "aida", "ia", "ding", "ay", "ast", "lan", "paid", "aed", "ased", "man", "ady", "order", "sid", "sat", "oid", "bas", "auth", "dd", "ase", "a", "added", "az", "sd", "anc", "aa", "ad", "ab", "du", "delay", "cas", "af", "na", "lay", "lied", "idd", "d", "aim", "aud", "ac", "ed", "au", "ara"], "delta": ["ndota", "lota", " delt", "ldelt", "edelta", " d_", "adada", "ldota", "Delt", "ddota", " dada", "adelta", "edDelta", "ndta", "detime", "lada", "Delta", "DDelta", " d\n", "sdelta", "ldelta", "adDelta", "D_", "sdata", "ldDelta", "lelt", "ddelt", "ddDelta", "lelta", "edetime", "adelt", "delt", "sdetime", "d\n", "sdota", "ndata", " dota", "dada", "sdta", "d_", "sdelt", "Dota", "edta", "dota", "dta", "ddelta", "ndetime", " dDelta", "ndelt", "data", "D\n", "sdDelta", "ndDelta", "dDelta", "Dada", "ndelta", "adota"], "aBalance": ["aBal", "saBal", " aWeight", " aCost", " aCredit", "aabalance", "eaCost", " aBal", "saBalance", "pbalance", "eaBalance", "aaBalance", "aaCredit", "sabalance", "aaAmount", "aHalf", "pBalance", "bBalance", "aaWeight", "bHalf", "abalance", "aAmount", " abalance", "pWeight", "bAmount", "aCredit", "aWeight", " aHalf", "eaBal", "eabalance", "saCost", "pCredit", "bCredit", "aCost", " aAmount", "aaHalf"], "RS": ["SH", "RB", "OS", "BS", "RO", "MS", "PS", "RI", "TR", "OSS", "CS", "IS", "Res", "MC", "RR", "FS", "VS", "KS", "GR", "CL", "SS", "RT", "RL", "TS", "SR", "Vs", "JR", "RP", "SW", "RD", "LL", "NRS", "HS", "Rs", "JS", "US", "LS", "RE", "Ms", "RW", "RM", "RC", "DS", "AR", "KR", "IR", "RN", "POST", "MR", "DR", "rs", "CD", "VR"], "Stmt": ["Cmn", "STMT", "Stmp", "Stut", "Stgr", "Lgr", "StMT", " stgr", "Lmp", " stmt", " Stut", "stp", " stMT", "Strmt", "STmn", "Lmt", " Stp", "Stau", "Cmt", "Stp", "Firstmb", "StTr", "Cau", "Stbl", "Firsttm", "Firstpr", "Stmb", "StrMT", "stMT", "LMT", " stmp", "stpr", "Stpr", "STut", "Sttm", "Stmn", "Strmp", "STbl", "stmt", " Sttm", "Strau", "STTr", "CMT", "sttm", "stmp", "stTr", " StTr", " Stau", "stgr", "STmt", " Stmn", "STp", "Cut", " Stmb", "Cmp", "stmb", "Firstmt", " Stmp", "stbl", " StMT", " Stbl", " Stpr"], "Query": ["Option", "Force", "Update", "Factory", "Display", "ERY", "Body", "QL", "Cache", "Server", "Join", "Code", "Table", "Method", "Qu", "Scan", "Filter", "Flow", "SQL", " query", "Url", "Script", "Info", "Database", "Time", "Line", "Check", "Source", "Q", "Form", "Module", "Route", "Array", "Do", "Test", "Raw", "Str", "Common", "File", "Style", "Range", "Db", "Init", "Exp", "Format", "Connection", "Rule", "Model", "Row", "Report", "Msg", "Previous", "query", "Condition", "Stage", "Service", "Document", "Comment", "URI", "This", "Request", "Fixed", "Key", "Function", "Statement", "Error", "Driver", "Conn", "Command"], "res": ["rest", "Results", "Resp", "re", "PS", "reg", "Response", "Res", "Ret", "obj", "results", "resh", "vals", "js", "rows", "ES", "runs", "rem", "RES", "RE", "Gr", "lets", "resp", "Resources", "gr", "ches", "Cons", "ras"]}}
{"id1": "6271502", "id2": "18570190", "code1": "    @Override\n    public InputStream getResourceByClassName(String className) {\n        URL url = resourceFetcher.getResource(\"/fisce_scripts/\" + className + \".class\");\n        if (url == null) {\n            return null;\n        } else {\n            try {\n                return url.openStream();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"getResourceByClassName": ["getResourceForclassname", "getResourceByFileName", "getResourceForclassString", "getResourceByclassString", "getResourceByFilename", "getResourceByFileString", "getResourceByclassname", "getResourceForClassString", "getResourceByClassname", "getResourceByClassString", "getResourceForClassname", "getResourceByclassName", "getResourceForClassName", "getResourceForclassName"], "className": ["ClassType", "ClassPath", "scriptName", "classname", "scriptPath", "scriptType", "shortname", " classType", " classname", "classPath", "shortName", "scriptname", "shortTitle", "classTitle", " classTitle", "ClassName", "classType", " classPath", "Classname", "shortPath", "ClassTitle"], "url": ["address", "base", "job", "rel", "str", "ob", "window", "e", "el", "zip", "feed", "URL", "path", "xml", "log", "sl", "Url", "location", "string", "name", "ls", "image", "orb", "resources", "org", "event", "ssl", "element", "class", "b", "object", "www", "loader", "buffer", "lr", "service", "resource", "api", "bel", "uri", "http", "plug", "l", "page", "source", "file", "server", "data", "ref", "instance", "coll", "impl", "web", "rl", "f"]}}
{"id1": "62362", "id2": "3767903", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["CONception", " deconversion", "Converted", "oconversion", "subversion", "CONverted", "unception", "subverting", "CONvert", "subverted", "unvert", "unverted", "Conception", "CONverting", " deconverting", "oconverted", "Conversion", "Converting", "CONversion", "oconvert", " deconverted", "conception", "converting", "subvert", "oconverting", "Convert", "conversion", "converted", "unversion", " deconvert"], "src": ["sys", "ource", "fp", "url", "sit", "prot", "st", "img", "reader", "gb", "tmp", "load", "cb", "proc", "scene", "path", "input", "filename", "string", "name", "obj", "s", "stream", "secure", "sth", "Source", "spec", "upload", "storage", "sel", "code", "username", "SourceFile", "ssl", "sb", "component", "Dest", "supp", "buf", "video", "sin", "attr", "back", "config", "loc", "slice", "inst", "sn", "uri", "resource", "rb", "feat", "rc", "href", "source", "fn", "sc", "file", "download", "ref", "RC", "gz", "dist", "req", "stage", "impl", "cpp", "rl", "ctx", "cmp"], "dest": ["disk", "test", "cont", "img", "bin", "tmp", "path", "target", "obj", "lib", "std", " dst", "Dest", "class", "dat", "orig", "null", "dc", "di", "source", "fn", "dir", "dist", " destination", "home", "txt", "temp"], "in": ["ins", "din", "reader", "IN", "login", "bin", "isin", "inc", "io", "ini", "val", "input", "In", "stream", "err", "doc", "inas", "t", "a", "i", "r", "ex", "n", "ps", "win", "inn", "inf", "pin", "is", "data", "source", "up", "file", "d", "pass", "as", "f"], "p": ["fp", "jp", "v", "pa", "tp", "bp", "e", "lp", "pre", "pm", "P", "py", "pr", "s", "cp", "c", "np", "m", "t", "j", "i", "r", "pe", "g", "b", "cop", "o", "ps", "per", "parser", "pd", "pg", "h", "wp", "l", "op", "pb", "d", "pc", "pp", "sp", "part", "f", "pi", "po"], "ds": ["posts", " DS", "eps", "dp", "ths", "vs", "els", "os", " ps", "dat", "ps", " sd", "pd", "uds", "data", "qs", "utils", "points", "rs", "services", "da", "groups", "db", "docs", "s", "ls", "hs", "words", "ys", "models", "cs", "ans", "di", "ld", "cons", "gs", "ins", "xs", "ges", "ts", "nas", "ks", "sts", "ded", "lines", "vals", "js", "ups", "plugins", "dates", "ants", "dds", "ss", "scripts", "tests", "ils", "ads", "sys", "Ds", "ays", "dl", "lp", "tools", "df", "ns", "styles", "dd", "gd", "des", "dos", "sync", " props", "dc", "parts", "dt", "obs", "dist", "amps", "d", "DS", "icks", "dm", "ipes", "bs"], "format": ["template", "atter", "url", "fp", "magic", "model", "path", "function", "plugin", "host", "pattern", "filename", "string", "nat", "language", "struct", "name", "prefix", "spec", "t", "type", "at", "Format", "class", "tag", "handler", "config", "layout", "sche", "table", "parser", "api", "version", "scale", "form", "feat", "fd", "data", "source", "file", "filter", "letter", "ant", "fn", "style", "act", "frame", "unit", "part", "record", "f"], "hasPixelData": ["hasByteData", "showsPixelDATA", "hasPictureSize", "haspixelSize", " hasPixelSize", " hasPixeldata", "showsByteData", "showsByteStyle", "showsBytedata", "showsPixeldata", "hasPixelSize", "hasPicturedata", "showsPixelStyle", "hasByteSize", "hasPixelDATA", "hasPictureData", "hasPixeldata", "hasByteStyle", "haspixelData", "showsByteDATA", "haspixeldata", "hasPixelStyle", "hasBytedata", "showsPixelData", "hasByteDATA"], "inflate": ["inflace", "invenATE", "Inflation", "inFlate", "inflating", "infolode", "insvenate", "inFlation", "insvenATE", "invenode", "insvenating", "inflated", "Inflated", "inadequode", "inadequate", "inffation", "invenate", "insflate", "inflATE", "Inflate", "infloated", "inFlated", "infface", "InFlate", "insflATE", "Inflace", "InFlace", "inadequATE", "insflating", "inFlace", "infloate", "InFlation", "infloation", "insvenode", "inflode", "infolATE", "infloace", "inffate", "infolate", "inflation", "invenating", "inadequating", "InFlated", "insflode", "infolating", "inffated"], "pxlen": ["mxlen", "pxsize", "mxdata", "fxlen", "pgLen", "mxcount", "pgl", "fxden", "pxdata", "fxl", "axlon", "pxl", "pxlength", "pxlon", "pnglength", "xpsize", "pplen", "mxsize", "txlon", "axln", "pclin", "camlen", "pxLen", "camdata", "fxLen", "pxden", "pglen", "pxcount", "pxpos", "fxpos", "pclen", "txlen", "pxln", "pxlin", "campos", "txln", "fxdata", "pclon", "camln", "txlin", "xplen", "xplength", "fxln", "axlin", "ppden", "mxlength", "ppl", "pgden", "pnglen", "ppLen", "pngsize", "mxpos", "pngcount", "axlen", "xpcount", "mxln", "pcln"], "out": ["sys", "v", "error", "OUT", "outs", "cache", "gen", "re", "output", "io", "log", "session", "conn", "obj", "state", "lock", "err", "Out", "step", "lib", "user", "again", "parent", "co", "query", "list", "pad", "post", "copy", "point", "store", "cli", "line", "work", "up", "server", "page", "dump", "group", "inter"]}}
{"id1": "293167", "id2": "8166767", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public Object invoke(MethodInvocation invocation, int retryTimes) throws Throwable {\n        retryTimes--;\n        try {\n            String url = getServiceUrl() + \"/\" + invocation.getMethod().getName();\n            HttpPost postMethod = new HttpPost(url);\n            if (invocation.getMethod().getParameterTypes().length > 0) postMethod.setEntity(new StringEntity(JsonUtils.toJson(invocation.getArguments())));\n            HttpResponse rsp = HttpClientUtils.getDefaultInstance().execute(postMethod);\n            StatusLine sl = rsp.getStatusLine();\n            if (sl.getStatusCode() >= 300) {\n                throw new RuntimeException(\"Did not receive successful HTTP response: status code = \" + sl.getStatusCode() + \", status message = [\" + sl.getReasonPhrase() + \"]\");\n            }\n            HttpEntity entity = rsp.getEntity();\n            StringBuilder sb = new StringBuilder();\n            InputStream is = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n            String line;\n            while ((line = reader.readLine()) != null) sb.append(line).append(\"\\n\");\n            reader.close();\n            is.close();\n            String responseBody = null;\n            if (sb.length() > 0) {\n                sb.deleteCharAt(sb.length() - 1);\n                responseBody = sb.toString();\n            }\n            Type t = invocation.getMethod().getGenericReturnType();\n            if (t.equals(Void.class) || responseBody == null) return null;\n            return JsonUtils.fromJson(responseBody, t);\n        } catch (ConnectTimeoutException e) {\n            if (retryTimes < 0) throw e;\n            if (urlFromDiscovery) {\n                String serviceUrl = discoverServiceUrl(getServiceInterface().getName());\n                if (!serviceUrl.equals(getServiceUrl())) {\n                    setServiceUrl(serviceUrl);\n                    log.info(\"relocate service url:\" + serviceUrl);\n                }\n            }\n            return invoke(invocation, retryTimes);\n        }\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doVersionUpdate", " doVersionUpdate", " doversionCheck", "doversionScan", "doversionCheck", "doChangeCheck", "doChangecheck", " doversioncheck", "doChangeUpdate", "doversioncheck", "doVersioncheck", "doFeaturecheck", " doVersionScan", " doversionUpdate", "doversionUpdate", "doFeatureScan", "doVersionScan", "doFeatureCheck", " doversionScan", "doChangeScan", "doFeatureUpdate", " doVersioncheck"], "view": ["v", "cache", "vol", "window", "e", "port", "model", "div", "row", "session", "link", "sel", "box", "show", "query", "display", "form", "server", "fail", "value", "full", "group", "gu", "client", "use", "VIEW", "check", "input", "View", "lock", "event", "user", "object", "video", "block", "views", "vis", "by", "http", "page", "review", "pool", "comment", "can", "cell", "im", "base", "change", "el", "ou", "container", "screen", "body", "head", "config", "list", "index", "out", "ui", "image", "this", "widget", "self", "html", "see", "edit", "layout", "update", "ve", "up", "style", "manager"], "url": ["address", "base", "builder", "rel", "bb", "ob", "id", "zip", "URL", "path", "log", "sl", "Url", "host", "location", "string", "name", "ls", "gl", "stream", "bug", "length", "image", "hub", "link", "ssl", "b", "browser", "null", "ll", "www", "loc", "socket", "loader", "fr", "buffer", "uri", "ul", "resource", "http", "l", "source", "file", "server", "download", "email", "impl", "open", "web", "blog", "f"], "in": ["ins", "reader", "din", "IN", "login", "isin", "inc", "bis", "ini", "input", "out", "In", "binary", "s", "inner", "stream", "err", "doc", "m", "b", "again", "sin", "socket", "nin", "win", "buffer", "resource", "inn", "pin", "is", "cin", "lin", "data", "file", "source", "init", "rin", "con", "ac", "as"], "bin": ["bn", "gin", "reader", "din", "IN", "login", "bb", "nb", "vin", "spin", "ini", "input", "border", "out", "binary", "fin", "inner", "lock", "bot", "ruby", "lib", "oin", "ban", "b", "browser", "body", "sin", "socket", "loader", "win", "buffer", "inn", "pin", "abi", "arin", "cin", "lin", "is", "file", "init", "con", "record", "bi", "run"], "line": ["lc", "cl", "base", "ip", "job", "str", "parse", "el", "e", "id", "zip", "one", "log", "le", "val", "ge", "row", "nl", "sl", "string", "name", "end", "Line", "out", "lines", "range", "word", "write", "link", "code", "LINE", "look", "type", "pe", "definition", "b", "user", "text", "object", "block", "pin", "key", "jo", "lf", "lin", "data", "file", "page", "l", "entry", "inline", "up", "letter", "unit", "ine", "part", "comment", "cell"], "version": ["feature", "position", "v", "ver", "project", "beta", "id", "cover", "model", "plugin", "python", "patch", "host", "string", "name", "bug", "driver", "section", "image", "code", "format", "vision", "type", "release", "user", "Version", "null", "video", "latest", "pull", "install", "update", "support", "license", "date", "option", "vert", "versions", "server", "download", "VERSION", "secret", "device", "value", "dev", "unit", "author"], "build": ["uild", "ver", "job", "builder", "rel", "follow", "clean", "use", "feed", "load", "valid", "log", "boot", "make", "row", "patch", "hold", "Build", "bug", "lock", "image", "link", "lease", "info", "print", "release", "show", "tag", "built", "pull", "block", "install", "building", "update", "post", "mount", "how", "add", "get", "http", "work", "style", "help", "home", "unit", "run"]}}
{"id1": "9109613", "id2": "4164833", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"fileCopy": ["fileUpload", "folderTransfer", "foldercopy", "Filecopy", "fileTransfer", "folderUpload", "FileTransfer", " fileTransfer", " fileUpload", "folderCopy", "filecopy", "FileUpload", "FileCopy", " filecopy"], "from_name": ["fromTheword", " from_no", " from_space", "fromametime", "from_size", "from__Name", " from_key", "from_Name", "from_no", "fromTheName", "from_time", "fromFullname", "fromqName", "fromFullName", "from__name", " from_alias", "fromqname", "from_path", " from_Name", "from_address", "from_image", "from_alias", "from_filename", " from__alias", "fromFulladdress", " from_time", "from_key", " from__Name", " from_size", "fromThename", " from_image", " from__name", "from_word", " from__address", "fromameno", "from__alias", " from_path", "fromamename", "fromThespace", " from_filename", "fromqpath", " from_address", "fromameName", " from_resource", "from__address", "from_resource", "fromqfilename", "from_space", "fromFullalias", " from_word"], "to_name": ["To_common", "tokname", "to_path", "to_Name", "to_file", "to_names", "To_Name", "from_path", "to_common", "tokcommon", "from_names", "to_key", " to_file", "To_name", "tokName", "from_Name", " to_key"], "fromFile": ["asFile", "FromFile", "oneFile", "fromFolder", "oneDir", "FromLine", "onePage", " fromDirectory", " fromFunction", "sourcePage", "fromPage", "fromFiles", "onefile", "ofFolder", "fromPackage", "oneFunction", "FromFolder", "connectionFile", "autoPage", " fromPage", "toLine", "fromLine", "fromfile", "FromDir", "tofile", "oneModel", " fromFactory", "asFiles", "fromDir", " fromPackage", "oneFolder", "ofFile", " fromFolder", "fromLibrary", " fromFiles", "asfile", "fromModel", "sourceFile", "sourceLibrary", "autoFile", "asFactory", "Fromfile", "FromPage", "FromModel", "connectionPackage", "FromLibrary", " fromfile", " fromModel", "FromDirectory", "connectionfile", "sourceDirectory", "toFactory", "fromFactory", " fromLine", " fromDir", "autoFolder", "FromFiles", "ofPackage", "FromFunction", "connectionFolder", "fromDirectory", "toFiles", "fromFunction", "offile", "autofile", " fromLibrary", "toFunction"], "toFile": [" toFolder", "soPage", "fromFiles", "toLine", "ofTable", "targetfile", "tempFile", " toSourceFile", "toLibrary", "ToPlace", " toPage", "targetSourceFile", " toFunction", "ToDirectory", "toFiles", "nofile", "toPlace", "toFunction", "ofDir", "baseTable", " toFactory", "targetFolder", "noFile", "toTable", "TOPage", "coFile", "baseDir", "TOFile", "aDir", "targetPage", " toFiles", "sofile", "targetFactory", "soLibrary", "TOPlace", " toLine", " toTable", " toDirectory", "targetDir", "basefile", "targetFile", "noLibrary", "tempFolder", "fromDir", "afile", "Tofile", "ToLibrary", "toDir", "cofile", "toPage", "ToPage", "fromDirectory", "offile", "coFunction", "tempFactory", "toFolder", "toDirectory", "ToDir", "aFile", "targetPlace", "ToLine", " tofile", "fromPage", "fromLine", "noPage", "ToFiles", "fromfile", "tofile", "soFile", "ofFile", "ToFactory", "ToFile", "toSourceFile", "ToSourceFile", "aFiles", "ToFunction", "baseFile", "toFactory", " toDir", "tempfile", "coDirectory", "TODir"], "parent": ["address", "test", "pa", "port", "id", "inc", "path", "div", "session", "location", "name", "section", "g", "null", "directory", "option", "api", "p", "col", "data", "file", "server", "full", "Parent", "part", "pr", "complete", "client", "child", "term", "remote", "patch", "string", "or", "pe", "class", "user", "shape", "rule", "guard", "key", "page", "pool", "ac", "lc", "paren", "current", "valid", "pt", "parents", "large", "loc", "resource", "content", "search", "source", "home", "url", "master", "ip", "region", "exp", "owner", "out", "type", "connection", "root", "par", "any", "point", "line", "and", "manager"], "dir": ["url", "dec", "ver", "rel", "dep", "Dir", "exp", "dict", "inc", "container", "cur", "db", "path", "folder", "div", "keep", "name", "out", "ir", "lock", "doc", "lib", "build", "or", "r", "def", "root", "class", "directory", "attr", "rec", "DIR", "per", "loc", "block", "iter", "dc", "dis", "wd", "fd", "mod", "dr", "di", "col", "file", "dist", "d", "director", "coll", "die", "dev", "group", "cat", "home", "manager", "f"], "from": ["cm", "url", "de", "base", "ra", "client", "clean", "bean", "vol", "parse", "left", "e", "view", "ou", "io", "module", "when", "old", "one", "auto", "name", "conn", "out", "cr", "stream", "range", "start", "c", "link", "this", "self", "normal", "or", "component", "connection", "user", "so", "empty", "o", "with", "query", "per", "hand", "without", "flo", "fr", "wh", "api", "add", "by", "form", "get", "in", "who", "source", "channel", "file", "se", "ch", "low", "From", "con", "part", "can", "ce", "po"], "to": ["su", "two", "be", "eto", "base", "ver", "token", "cache", "output", "port", "io", "proxy", "not", "db", "one", "fb", "TO", "target", "auto", "out", "name", "on", "top", "no", "again", "tom", "or", "via", "type", "connection", "go", "b", "object", "To", "so", "o", "see", "co", "with", "sync", "flo", "office", "will", "api", "by", "plus", "copy", "store", "page", "http", "source", "op", "file", "too", "tto", "about", "until", "size", "fat", "pi", "po"], "buffer": ["Buffer", "address", "position", "result", "header", "uffer", "reader", "cache", "transfer", "feed", "vector", "available", "total", "default", "row", "border", "length", "string", "binary", "seed", "memory", "queue", "character", "read", "layer", "duration", "reference", "batch", "shape", "buf", "number", "null", "block", "padding", "table", "message", "iter", "resource", "bytes", "flush", "document", "page", "data", "channel", "server", "variable", "device", "value", "comment", "buff", "texture"], "bytes_read": ["classesavavailable", "bytesESSreceived", " bytes_load", "bytesavavailable", "classes_READ", "bytes___READ", "bytes_READ", "classes_available", "classesavview", " bytes_written", "lines_received", "classes_read", "lines_read", "bytesavview", "bytesavread", "classes_view", "bytesESSput", "bytes_available", "bytesESSread", "bytes_load", "lines_written", "bytes_received", " bytes_write", "bytes_put", "bytes_write", "bytes___view", "bytesavREAD", "bytesESSwritten", "bytes_written", "bytesayput", "lines_put", "bytes___read", "classesavREAD", "classesavread", "bytesayreceived", "bytesayread", "bytes_view", "bytesaywritten", "bytes___available"]}}
{"id1": "20623709", "id2": "2324868", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 1, "substitutes": {"split": ["exec", "share", "delete", "parse", "Split", "transfer", "sort", "start", "archive", "set", "run", "build", "format", "join", "diff", "sync", "update", "add", "copy", "match", "append", "execute", "process", "init", "part", "open", "cmp"], "targetDirectory": ["destFile", "outputDir", "masterDirectory", "outputFolder", "currentDir", "destFolder", "destDir", "baseFolder", "targetDatabase", "targetFolder", "TargetFolder", "targetDir", " targetRoot", "targetFile", "TargetPath", "TargetDatabase", "baseDir", "masterPath", "TargetFile", " targetDir", "TargetRoot", " targetPath", "currentDirectory", "currentRoot", "basePath", "targetPath", "masterDir", " targetFile", "TargetDirectory", "currentFolder", "baseFile", "masterDatabase", "baseDirectory", "targetRoot", "currentPath", "outputDirectory", "TargetDir", "baseDatabase", "destDirectory", "outputFile", " targetFolder"], "prefix": ["first", "template", "fp", "prot", "base", "cache", "resolution", "pre", "path", "folder", "Pref", "index", "filename", "patch", "name", "string", "sequence", "offset", "pattern", "domain", "queue", "format", "username", "type", "root", "number", " suffix", "directory", "config", "padding", "uri", "timeout", "resource", "ix", "append", "fixed", "FIX", "fix", "unit", "txt", "temp"], "maxUnitBases": ["maxUnitAliasing", "maxUnitEases", "maxUnitEails", "maxUnitAliails", "maxUnitAliaches", "maxunitAliase", "maxUnitQuease", "maxunitAliasing", "maxUnitBase", "maxUnitQueases", "maxUnitEase", "maxUnitBails", "maxUnitBues", "maxUnitQueues", "maxUnitBaches", "maxUnitPlase", "maxunitBases", "maxunitAliails", "maxUnitPlaches", "maxUnitChases", "maxunitBues", "maxUnitChues", "maxUnitEaches", "maxunitBase", "maxUnitPlases", "maxUnitAliues", "maxUnitChasing", "maxunitAliaches", "maxunitBaches", "maxUnitAliase", "maxunitBasing", "maxUnitAliases", "maxunitBails", "maxunitAliases", "maxunitAliues", "maxUnitBasing", "maxUnitChase", "maxUnitPlails", "maxUnitQueasing"], "maxUnitEntries": ["maxUnitEntrys", "maxUnitOrdies", "maxUnitOrdresses", "maxUnitInties", "maxunitEntryresses", "maxUnitErries", "maxUnitErines", "maxLineEntries", "maxUnitOrdines", "maxUnitErry", "maxLineOrdrations", "maxUnitEntures", "maxunitEntryrys", "maxUnitCountines", "maxunitEntryies", "maxUnitOrdrys", "maxUnitEntryries", "maxUnitEntrations", "maxUnitIntries", "maxLineOrdries", "maxunitEntresses", "maxUnitEnties", "maxUnitAddries", "maxLineOrdry", "maxUnitOrdries", "maxUnitEntry", "maxUnitEntryry", "maxUnitAddry", "maxUnitAddresses", "maxUnitEntryures", "maxUnitOrdry", "maxUnitEntryresses", "maxLineEntry", "maxUnitAddures", "maxUnitCountrations", "maxLineEntines", "maxUnitEntryrys", "maxUnitCountry", "maxUnitIntrys", "maxUnitCountries", "maxunitEntries", "maxunitEnties", "maxUnitIntresses", "maxUnitEntines", "maxUnitOrdrations", "maxUnitEntresses", "maxunitEntrys", "maxunitEntryries", "maxUnitErrations", "maxLineEntrations", "maxUnitEntryies", "maxLineOrdines"], "fis": ["forisa", " fiss", "visa", "fris", " fIs", "Fisc", "fisc", "forisc", " fai", "Fris", " fisc", "vIs", "foris", " fisa", "fIs", "Fis", "vai", "forai", "Fiss", "vis", "fiss", "foriss", "forris", "fai", "forIs", " fris", "fisa"], "fci": ["vcos", "hci", "Fco", "Fai", " foci", "bis", " fai", " fii", "hco", "foci", "efcos", "bco", "efco", "Fis", "vai", "efai", "hai", "bci", "vco", "vci", "fii", "Foci", "bai", "efci", "dii", "fai", "dci", "Fci", "Fii", "doci", "hcos", "fcos", "dco"], "fos": ["foes", "tos", "tis", "ifo", "fsos", "toss", "foss", "infis", "Fos", "Fis", "ifios", " fo", "Foss", "fios", "Foes", "fsios", "infoes", "toes", "fscos", " fios", "ifcos", "fo", " fcos", "fso", "ifos", "infos", "infoss", "fcos"], "fco": ["fileco", "filebo", "hci", "dro", "Fco", "fileico", "Fico", "hgo", "lco", "fgo", "hco", "fbo", "lcos", "fro", "fico", "lro", " fbo", "lgo", "Fbo", "dcos", " fcos", "lci", " fro", "fileci", "dci", "Fci", " fico", "hcos", "fcos", "dco", " fgo"], "buffer": ["Buffer", "bc", "position", "result", "base", "header", "uffer", "reader", "cache", "window", "bin", "transfer", "pause", "comment", "view", "feed", "request", "border", "input", "length", "context", "binary", "offset", "memory", "queue", "image", "callback", "expression", "rate", "read", "layer", "writer", "info", "batch", "reference", "counter", "bar", "null", "buf", "block", "pad", "loader", "message", "iter", "resource", "timeout", "scale", "flush", "copy", "document", "translation", "data", "channel", "entry", "server", "source", "device", "capacity", "size", "zero", "buff", "response", "texture"], "currentBasesCount": ["currentBasingNum", "currentBaseCounter", "currentBatchescount", "currentChasescount", "currentChasesCount", "currentChasesCounter", "currentBasingCount", "currentBatchesCounter", "currentBasesCounter", "currentBatchesCount", "currentBatchesNum", "currentChasesNum", "currentChasecount", "currentBasingcount", "currentChaseCount", "currentBasescount", "currentBasingCounter", "currentBaseNum", "currentChaseNum", "currentBaseCount", "currentBasecount", "currentBasesNum", "currentChaseCounter"], "currentEntriesCount": ["currentAddriesSize", "currentEntursSize", "currentAddriesOffset", "currentEntursOffset", "currentEntursCount", "currentEntriesOffset", "currentEntriesLimit", "currentEnturesLimit", "currentAdduresSize", "currentEntrasSize", "currentEnturesSize", "currentEntriesSize", "currentEnturesCount", "currentEnturesOffset", "currentAddriesCount", "currentAdduresCount", "currentEntrasOffset", "currentAdduresOffset", "currentAdduresLimit", "currentEntrasCount", "currentEntrasLimit", "currentEntursLimit", "currentAddriesLimit"], "targetCount": ["argetCount", "targetSize", "TargetSize", "patternSize", "targetSum", "argetSum", "argetSize", "patterncount", "targetcount", "TargetSum", "TargetCount", "argetcount", "patternCount", "Targetcount", "patternSum"], "fastaChannel": [" fastABuffer", " fastaConnection", " fastAConnection", "fastanBuffer", "fastAContainer", "fastasChannel", "fastAColumn", "fastasColumn", "fastasContext", "fastasConnection", "fastanContainer", " fastaContainer", "fastaqColumn", "fastasBuffer", "fastanContext", "fastAChannel", "fastaqChannel", " fastaColumn", " fastAChannel", "fastAContext", "fastanChannel", "fastaqConnection", " fastaContext", "fastasContainer", "fastaConnection", " fastAContainer", "fastABuffer", "fastaqBuffer", " fastAColumn", "fastaContainer", " fastAContext", "fastaContext", "fastaColumn", "fastAConnection"], "totalSeqCount": ["totalQueqCount", "totalSeQCounter", "totalSeQNum", "totalSeQCount", "totalSeqsNum", "totalQueQCounter", "totalSeqcount", "totalSeuxCounter", "totalQueQcount", "totalSeuxCount", "totalSeqsCount", "totalSeqsCounter", "totalSeqscount", "totalQueQNum", "totalQueqCounter", "totalSeqNum", "totalSeQcount", "totalQueqcount", "totalQueqNum", "totalQueQCount", "totalSeuxNum", "totalSeuxcount", "totalSeqCounter"], "totalResiduesCount": ["totalResiduingCount", "totalResiduationNum", "totalResiduescount", "totalResqueuresSize", "totalResqueuesNum", "totalResiduingcount", "totalResiduationcount", "totalResqueuresCount", "totalResqueuesCount", "totalResiduationSize", "totalResiduationCount", "totalResiduresNum", "totalResiduingNum", "totalResiduesNum", "totalResiduingSize", "totalResidurescount", "totalResiduesSize", "totalResqueuesSize", "totalResqueuresNum", "totalResqueuescount", "totalResiduresCount", "totalResqueurescount", "totalResiduresSize"], "prevTime": ["commitFile", " prevFile", "PrevSize", "PrevValue", " prevSize", "commitTime", "PrevTime", "PrevFile", "prevSize", "commitValue", " prevValue", "commitSize", "prevFile", "prevValue"], "fastaFileSize": ["fastaFileAddress", "fastaLineAddress", "fastaFilesSize", "fastABufferCount", "fastasFileAddress", "fastaFilesLength", "fastaPageName", "fastaBufferLength", "fastaFilesAddress", "fastaBlockSize", "fastasFileLength", "fastAFileSize", "fastaLineLength", "fastaFilesName", "fastaFileCount", "fastaBufferAddress", "fastaPageLength", "fastABufferLength", "fastaBlockLength", "fastaLineCount", "fastaFileLength", "fastasHeaderLength", "fastaBlockAddress", "fastABufferAddress", "fastasFileSize", "fastaFileName", "fastAFileLength", "fastaBlockCount", "fastasHeaderAddress", "fastaBufferCount", "fastasHeaderName", "fastaPageAddress", "fastaHeaderAddress", "fastasFileName", "fastaHeaderName", "fastaLineSize", "fastAFileCount", "fastaHeaderSize", "fastaBufferSize", "fastAFileAddress", "fastABufferSize", "fastaHeaderLength", "fastaPageSize", "fastasHeaderSize"], "fastaFileReadOffset": ["fastaFilesWriteoffset", "fastaFileWriteEntry", "fastaDirectoryWriteEntry", "fastaFileLengthOffset", "fastaFileLengthOff", "fastaFileRunoffset", "fastaFileRunOff", "fastaFileReadoffset", "fastaBufferWriteoffset", "fastaFileWriteoffset", "fastaFileRunEntry", "fastaDirectoryReadOff", "fastaFileLoadLength", "fastaDirectoryWriteoffset", "fastaBufferReadoffset", "fastaFilereadOff", "fastaBufferReadAmount", "fastaFileReadAmount", "fastaFilesWriteOffset", "fastaFileLoadoffset", "fastaFilesReadOff", "fastaBufferWriteAmount", "fastaBufferWriteOffset", "fastaDirectoryWriteOff", "fastaBufferWriteLength", "fastaFilesReadLength", "fastaFileStartoffset", "fastaFileLengthoffset", "fastaFileWriteOffset", "fastaFileReadOff", "fastaDirectoryWriteOffset", "fastaDirectoryReadOffset", "fastaBufferReadOffset", "fastaFileWriteOff", "fastaFileReadEntry", "fastaFileLengthLength", "fastaFilesWriteOff", "fastaFilesWriteLength", "fastaFileStartEntry", "fastaDirectoryReadoffset", "fastaFileWriteAmount", "fastaFileWriteLength", "fastaFilesReadoffset", "fastaFilereadoffset", "fastaFileStartOffset", "fastaFileReadLength", "fastaFileRunOffset", "fastaDirectoryReadEntry", "fastaFilereadLength", "fastaFileLengthAmount", "fastaFileLoadAmount", "fastaFileLoadOffset", "fastaBufferReadLength", "fastaFilereadOffset", "fastaFileStartOff", "fastaFilesReadOffset"], "partitionStartOffset": ["partitionStartOrder", "partitionsEndOrder", "partitionStopOff", "partitionsStartOff", "partitionBufferOrder", "partitionBufferOffset", "partitionStartRange", "partitionStopOffset", "partitionEndOff", "partitionsEndOffset", "partitionsEndOff", "partitionsStartOrder", "partitionStopRange", "partitionStopOrder", "partitionStartOff", "partitionBufferOff", "partitionsStartOffset", "partitionsEndRange", "partitionEndOrder", "partitionEndRange", "partitionsStartRange", "partitionBufferRange"], "bufferSize": ["BufferC", "BufferSIZE", " bufferType", "BufferType", "bufferC", "queueSize", "processType", "bufferCount", " bufferSIZE", " bufferCount", "BufferCount", "bufferSIZE", "processC", "BufferSize", "processSIZE", "processSize", "queueCount", "bufferType", " bufferC"], "fastaBuffer": [" fastABuffer", "fastanFile", "fastasBuff", "fastanPtr", "fastanBuffer", "fastAContainer", "fastasChannel", " fastasContainer", "fastaQueue", "fastasQueue", " fastasFile", "fastasPtr", "fastanBuff", "fastaceBuffer", "FastasChannel", "fastaStream", "fastaaPtr", "FastaStream", "fastaFile", "fastanContainer", "FastaBuffer", "FastaBuff", "FastaChannel", "FastasStream", " fastaContainer", "fastasStream", "fastaaBuff", " fastABuff", "FastasBuffer", "fastasBuffer", "fastanStream", "fastAChannel", "FastasPtr", " fastaBuff", "fastanQueue", "fastaaStream", " fastAChannel", "fastanChannel", "fastaPtr", "fastaaBuffer", "fastasContainer", "fastAQueue", " fastasChannel", "fastAFile", " fastAFile", " fastAQueue", "fastABuff", "fastABuffer", " fastasBuffer", "fastaBuff", "fastacePtr", "FastasBuff", "fastaceChannel", " fastaQueue", "fastasFile", "fastaContainer", "FastaPtr", "fastAPtr", "fastaceBuff", " fastaFile"], "fastaReadState": ["fastasReaderState", "fastasReaderType", "fastaReadingState", "fastaReaderstate", "fastaReadstate", "fastaFileMode", "fastaReadType", "fastaReaderType", "fastaFileType", "fastaReadingType", "fastasReadType", "fastasReaderstate", "fastaReadingstate", "fastasReadstate", "fastasReadMode", "fastaReaderMode", "fastaFilestate", "fastaReadingMode", "fastaReadMode", "fastasReadState", "fastaFileState", "fastasReaderMode", "fastaReaderState"], "nBytes": ["pBytes", "nFrames", "lenbytes", "nbytes", "numFrames", "NBytes", "oFiles", "lenBytes", "oBytes", "nFiles", "NFiles", " nbytes", "NParts", "NByte", " nParts", "pParts", "pByte", "nByte", "pbytes", " nByte", "lenFrames", " nFrames", "lenFiles", "nParts", "numFiles", " nFiles", "oParts", "Nbytes", "numbytes", "numBytes", "obytes"]}}
{"id1": "18891988", "id2": "15445861", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["GetString", "GetFilename", "downloadFile", "loadFile", "loadfile", "downloadfile", "getfile", "getFilename", "Getfile", "getString", "loadString", "downloadFilename", "GetFile", "downloadString", "loadFilename"], "serviceName": ["ServiceName", "projectType", " servicePath", "ServicePath", "Servicename", " serviceType", " servicename", "packagename", "servicePath", "ServiceType", "projectUrl", " serviceUrl", "servicename", "projectPath", "ServiceUrl", "packagePath", "serviceType", "packageName", "serviceUrl", "packageUrl", "projectName"], "wsdlLocation": ["wllFolder", "wssdFolder", "awsdlLocation", "wddlLocation", "awslDirectory", "wsllFolder", "wssdAddress", "wsDLUrl", "wslLocation", "wslpDirectory", "wslUrl", "wsllAddress", "wdlAddress", "wslFile", "awslFile", "wsslFolder", "wdlFile", "wddlFile", "wdlFolder", "wllFile", "wslpLocation", "awsdlDirectory", "awslUrl", "wslDirectory", "awsdlFile", "wslFolder", "wsdlDirectory", "wddlFolder", "wsllLocation", "wsDLFile", "wsslLocation", "wsdlFolder", "wsDLLocation", "awsdlUrl", "wsllUrl", "wsslFile", "wllLocation", "wssdLocation", "wddlDirectory", "wsdlFile", "wsdlUrl", "wsslAddress", "wsdlAddress", "wsllFile", "wdlDirectory", "wslpFolder", "wdlLocation", "wssdFile", "wslpFile", "wllAddress", "awslLocation", "wsDLDirectory", "wsllDirectory"], "endpoint": ["endPoint", "endination", "enPoint", " endaddress", "Endword", "endpointer", " endocol", " endPoint", " endpo", "EndPoint", "Endination", "Endpoint", "ENDpoint", "enpointer", "endsword", "startaddress", "endpo", "startpointer", "Endpoints", "startPoint", " endword", "ENDpoints", "endword", "enaddress", "enination", "endsocol", "startpoint", "enpoint", "ENDPoint", " endpointer", "endspo", "endaddress", "Endocol", "endspoint", "endocol", "enpoints", "endpoints", "ENDination", "Endpo"], "fileLocation": ["FILEUrl", " fileURI", "FileURI", " fileUrl", "fileURI", " fileDirectory", "FILEDirectory", "fileUrl", "fileDirectory", "FileDirectory", "FILELocation", "FileLocation", "FileUrl", "FILEURI"], "tempDir": [" temporaryPath", "TempDirectory", " tempVer", "tmpDir", " tempDirectory", "tmpPath", "TempPath", " tempdir", " tempPath", "TempDir", "tmpDirectory", "tempdir", "Tempdir", "tempDirectory", "tmpVer", " temporaryVer", " temporaryDir", "tempVer", "tempPath", "tmpdir", " temporaryDirectory"], "url": ["address", "base", "client", "el", "io", "URL", "path", "log", "fl", "sl", "Url", "host", "string", "conn", "ls", "contact", "stream", "image", "ssl", "connection", "ll", "www", "config", "pull", "socket", "ur", "ul", "uri", "service", "http", "l", "source", "file", "server", "channel", "download", "coll", "open", "web", "f"], "WSDLFile": ["WDDlBase", "WSDLLFile", "WINDELPath", "WDDLFolder", "WDDLFile", "WDDlFile", "WDDLBase", "WSDDLFile", "WSDlPath", "WSDLfile", "WSDlBase", "WSDLLFiles", "WDDlFolder", "WDDLfile", "WSDLSourceFile", "WSDDLFolder", "WDDlPath", "WSDLFiles", "WSDLLFolder", "WSDLLSourceFile", "WDDlfile", "WSDELFolder", "WINDLFile", "WSDlFolder", "WSDLPath", "WINDELFiles", "WSDlfile", "WDDLPath", "WSDDLBase", "WSDELFile", "WSDLLBase", "WINDELFolder", "WSDDLfile", "WSDDLFiles", "WSDDLPath", "WINDELFile", "WSDLLfile", "WSDlFile", "WSDELFiles", "WSDlSourceFile", "WSDDLSourceFile", "WINDLFolder", "WSDLLPath", "WSDLBase", "WDDlSourceFile", "WDDLSourceFile", "WSDLFolder", "WSDELPath", "WINDLFiles", "WINDLPath"], "tmpWSDLFile": ["tmpWDDELUrl", "tmpWSDDLLocation", "tmpWSDELFile", "tmpWSDDLFiles", "tmpWSDLLocation", "tmpWDDELFile", "tmpWDDlFile", "tmpWSDLFiles", "tmpWSDlFolder", "tmpWSDLLFolder", "tmpWDDLFile", "tmpWSDELFiles", "tmpWSDlLocation", "tmpWDDLLocation", "tmpWSDlFiles", "tmpWSDlFile", "tmpWDDlFolder", "tmpWDDLUrl", "tmpWSDlUrl", "tmpWSDLLFile", "tmpWSDLFolder", "tmpWDDELLocation", "tmpWSDELFolder", "tmpWSDELUrl", "tmpWDDlFiles", "tmpWSDLLUrl", "tmpWSDLUrl", "tmpWDDlUrl", "tmpWDDELFiles", "tmpWSDDLFile", "tmpWDDLFiles", "tmpWSDLLFiles", "tmpWDDLFolder", "tmpWSDDLUrl", "tmpWSDELLocation"], "inputFile": ["outputDir", " inputFactory", "InputFactory", "inputDir", " inputStream", "Inputfile", " inputFiles", " inputBuffer", "tempBuffer", " inputPage", "tempPlace", "requestfile", "InputDir", "inFile", " inputBase", "inputPage", "InputFile", "inputFactory", "tempUrl", "infile", "inputStream", "tempFactory", "tempPage", "tempFile", "tempBase", "InputUrl", "InputFiles", " inputfile", " inputUrl", "InputPlace", "inputFiles", " inputPlace", "outputFiles", "outputfile", "requestStream", "InputBuffer", "requestFiles", "inputPlace", "inputUrl", "inputBase", " inputDir", "requestFile", "inDir", "tempfile", "InputBase", "inputBuffer", "InputPage", "inPage", "InputStream", "outputFile", "inputfile"], "tmpFile": ["TempFiles", " tmpFiles", "TempDirectory", " tmpDirectory", "uploadStream", "tempDocument", "uploadFile", "TempFile", "inputDocument", "tmpStream", "inputStream", "tempPage", "tempFile", "tmpDirectory", "tmpPage", "tempDirectory", "inputFiles", "tempStream", "TempPage", "tempFiles", "tmpFiles", "uploadDocument", " tmpPage", "uploadFiles"], "in": ["gin", "ins", "din", "reader", "IN", "client", "login", "bin", "id", "inc", "input", "In", "conn", "on", "inner", "image", "c", "lock", "m", "ssl", "connection", "r", "again", "socket", "win", "inn", "p", "pin", "is", "l", "data", "source", "file", "up", "lin", "init", "impl", "f"], "out": ["net", "error", "OUT", "client", "outs", "IN", "cache", "output", "bin", "io", "inc", "log", "input", "conn", "conv", "on", "inner", "In", "name", "to", "image", "err", "c", "Out", "writer", "connection", "again", "parent", "o", "co", "socket", "sync", "outer", "timeout", "copy", "line", "source", "channel", "file", "up", "ch", "server", "group", "part", "conf", "can"], "con": ["bc", "cm", "gin", "ins", "thin", "uc", "client", "IN", "un", "ran", "com", "inc", "connect", "conn", "conv", "inner", "c", "plain", "en", "ssl", "connection", "rec", "co", "fc", "socket", "sync", "Con", "win", "close", "CON", "rc", "channel", "ch", "cn", "kin", "nc", "Conn", "open", "ctrl", "conf", "can"], "fileLength": ["Filelength", " fileSize", "FileWidth", "channelWidth", "contentLen", " fileLen", "channelLen", "fileWidth", "FileLength", "filelength", "fileLen", " filelength", "contentlength", " fileWidth", "FileSize", "channelSize", "fileSize", "contentLength", "channelLength", "contentSize", "FileLen"], "channelIn": ["ChannelOut", "characterIN", "connectionOut", "Channelin", "characterin", "resourceIN", "connectionIn", "ChannelIN", " channelIN", "channelConn", "connectionConn", "resourcein", " channelConn", "characterOut", "resourceIn", "ChannelConn", "resourceOut", "ChannelIn", "connectionin", "channelIN", " channelin", "channelin", "characterIn"], "channelOut": ["chanOUT", "ChannelOut", "connectionOutput", "connectionOut", "ChannelOutput", "ChannelOutside", " channelOutput", "connectionIn", "channelOutside", "channelout", "connectionOutside", "connectionout", "channelOutput", "channelOUT", "ChannelOUT", "canIn", "canOUT", "ChannelIn", " channelout", "canOut", "chanOut", "canOutside", "chanOutside", "chanIn", "chanout", "Channelout"], "tmpDocument": ["tmpDoc", "tmFile", "tmNode", "newContent", " tmpDoc", "mpDoc", "tmpNode", "newFile", "tempDoc", " tmpContent", "tempdocument", "tempDocument", " tmpNode", "mpDocument", "tmpContent", "tempFile", "newDocument", "tmpdocument", "tempContent", "mpFile", "tmDocument", " tmpdocument", "newdocument", "mpNode", "tempNode", "tmdocument"], "nl1": ["dl1", "arlone", "dl0", "NL11", "kl1", "ln1", "klFirst", "nl5", "ln6", "arlFirst", "ln2", "klone", "arl5", "nl6", "nn11", "NL6", "NL0", "nn6", "nl11", "jl1", "nl0", "jlone", "jl5", "dl2", "kl5", "nn2", "nn0", "nl2", "nlFirst", "NL2", "nlone", "nn1", "ln11", "jlFirst", "NL1", "arl1"], "i": ["qi", "v", "z", "ip", "ai", "ti", "I", "uli", "e", "id", "io", "iu", "xi", "ini", "index", "eni", "ui", "li", "u", "hi", "multi", "ci", "si", "mi", "phi", "ii", "m", "y", "j", "ie", "info", "b", "n", "o", "slice", "ri", "uri", "p", "ix", "gi", "fi", "it", "abi", "di", "oi", "l", "ni", "d", "chi", "yi", "ji", "f", "part", "mu", "bi", "pi"], "node1": ["package91", "Node91", "packageOne", "NodeOne", "packageone", "Node0", "shape1", " node91", "node2", "layer91", "layer1", "n0", "layerOne", "n1", "n2", "node0", "nOne", "Node1", "package1", "layer2", "shapeone", "nodeOne", " nodeone", " node0", "nodeone", "shapeOne", "node91", "shape91", " nodeOne", " node2", "Node2"], "tmpOut": [" tmpOUT", "txtOut", "vmOUT", "ptyOut", " tmpWriter", "tempOUT", "tempWriter", "txtOutput", "tempIn", "ptyIn", "tempOut", "tmpWriter", "vmOut", "tempFile", "ptyOutput", "cacheFile", "tempout", "tmpOUT", "tempOutput", "txtout", "cacheOut", "txtWriter", "cacheOUT", "vmIn", "ptyout", "tmpout", " tmpIn", "cacheIn", "tmpIn", " tmpout", "tmpOutput", " tmpOutput", "vmout"], "retVal": ["valRet", "valval", "retObj", "retval", " retval", "retRet", "RETval", "RETObj", " retObj", " retRet", "valObj", "valVal", "RETVal", "RETRet"]}}
{"id1": "18504192", "id2": "411595", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "in": ["url", "base", "ins", "reader", "IN", "login", "bin", "id", "io", "inc", "old", "ini", "index", "input", "In", "name", "inner", "image", "c", "m", "or", "at", "i", "info", "b", "again", "parent", "diff", "buffer", "inn", "min", "copy", "data", "file", "d", "src", "ac", "part"], "out": ["exec", "external", "base", "OUT", "client", "outs", "cache", "w", "call", "output", "io", "inc", "target", "name", "conn", "obj", "string", "c", "err", "prefix", "Out", "writer", "connection", "b", "ex", "n", "object", "again", "o", "dest", "p", "copy", "point", "line", "data", "file", "password", "part", "temp"], "source": ["ource", "slave", "reader", "client", "project", "scope", "view", "use", "proxy", "sl", "input", "target", "start", "core", "secure", "stream", "Source", "settings", "self", "storage", "clone", "ssl", "ie", "i", "connection", "component", "writer", "null", "parent", "sin", "dest", "slice", "sync", "ources", "iter", "service", "get", "copy", "from", "channel", "se", "server", "src", "origin", "unit", "size", "SOURCE"], "destination": ["destinator", "testinations", "Destinated", "Destification", "Destining", " destining", "Destination", "testinated", "dependification", " destinations", "destinations", "declification", "declinated", " destinator", "declinator", "contining", "dependinated", "testination", " destinated", "declination", "dependination", "destinated", "testinator", "destining", "contination", "dependinator", "destification", "Destinations", "continated", "Destinator", "continator"]}}
{"id1": "8973505", "id2": "15810440", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"writeFileType": ["createFiletype", "writeFilestype", "writePageTypes", "writeFiletype", "createFileType", "writePageHeader", "writeFILEType", "createFilesType", "writeFILEHeader", "createFileHeader", "writePagetype", "createFileTypes", "createFilesHeader", "writeFileTypes", "writePageType", "writeFileHeader", "writeFILEtype", "createFilesTypes", "createFilestype", "writeFilesTypes", "writeFilesHeader", "writeFilesType", "writeFILETypes"], "uriFile": ["riFilename", "uriUrl", "uiFile", "riFile", "URIFiles", "riFiles", "URIfile", "uiFiles", "urifile", "uriFilename", "uifile", "uriFiles", "filenameFile", "riUrl", "rifile", "filenamefile", "filenameFilename", "URIFile", "URIUrl", "filenameFiles", "URIFilename", "uiUrl"], "outputfile": [" outputfull", "OutputFile", "resourcefiles", "outputfilename", "outputfiles", "resourcefile", "resourcestring", "outputdir", "inputFile", "unitfile", "Outputdir", "inputfiles", "inputstring", "inputdir", " outputdir", "resourcefilename", "unitstring", " outputFile", "unitfiles", "inputfilename", "unitfilename", "Outputfile", "inputfull", "outputstring", "Outputfull", "outputfull", "outputFile", "inputfile"], "num": ["master", "nb", "inc", "Num", "term", "index", "nam", "name", "length", "offset", "umi", "multi", "no", "len", "dim", "count", "NUM", "batch", "number", "n", "nu", "mult", "span", "amount", "common", "col", "coord", "limit", "loop", "con", "initial", "split", "unit", "sum", "zero"], "writer": ["external", "window", "e", "wl", "xml", "engine", "session", "we", "format", "riter", "method", "report", "null", "message", "document", "data", "server", "part", "author", "written", "wa", "header", "writ", "feed", "wan", "function", "ler", "creator", "er", "lock", "write", "wr", "object", "loader", "wb", "buffer", "wrapper", "key", "page", "later", "wt", "w", "io", "inner", "driver", "editor", "journal", "layer", "per", "walker", "socket", "outer", "office", "wave", "writers", "source", "unit", "book", "temp", "wire", "master", "builder", "output", "worker", "ws", "index", "out", "ee", "rw", "widget", "type", "Writer", "element", "r", "root", "handler", "service", "entry", "style", "width", "manager", "writing"], "uri": ["address", "id", "nil", "filename", "location", "context", "li", "link", "hub", "oid", "mi", "i", "route", "directory", "wiki", "direction", "query", "ri", "message", "attribute", "document", "file", "uid", "course", "token", "term", "folder", "remote", "string", "sequence", "nor", "uni", "prefix", "database", "component", "du", "URI", "http", "cli", "di", "picture", "feature", "base", "eni", "binary", " URI", "range", "winner", "doi", "multi", "username", "resource", "source", "origin", "unit", "pi", "qi", "metadata", "iri", "verb", "plugin", "node", "ui", "ilo", "umi", "element", "reference", "ori", "connection", "handler", "gi", "href", "theme", "collection"], "counter": ["race", "lc", "processor", "result", "master", "ver", "ter", "enter", "comment", "controller", "current", "vector", "worker", "nr", "index", "creator", "repeat", "pointer", "keep", "sequence", "name", "time", "inner", "offset", "book", "step", "expression", "keeper", "trace", "i", "count", "batch", "reference", "number", "info", "parent", "computer", "cpu", "handler", "hello", "loader", "ner", "outer", "parser", "iter", "Counter", "condition", "meter", "page", "continue", "entry", "cookie", "server", "clock", "loop", "instance", "coll", "second", "collection", "timer", "currency", "runner", "record", "inter"], "reader": ["ger", "upper", "finder", "e", "feed", "io", "rr", "worker", "rer", "ler", "row", "er", "ir", "inner", "driver", "stream", "ruby", "editor", "read", "Reader", "bird", "keeper", "layer", "r", "riter", "rx", "handler", "oder", "per", "loader", "ner", "ri", "parser", "iter", "lr", "buffer", "in", "l", "rar", "reading"], "url": ["address", "base", "client", "id", "feed", "io", "URL", "path", "plugin", "sl", "Url", "string", "ls", "li", "stream", "image", "link", "ssl", "connection", "user", "browser", "text", "www", "config", "ri", "resource", "http", "l", "page", "source", "file", "server", "channel", "download", "web", "blog"], "myConnection": ["myconnection", "someConnect", "someConn", "yourConn", "yourconnection", "MyConnection", "someConnection", " myConnect", "yourConnector", " myconnection", "Myconnection", "MyConn", "myConnector", "myConn", "MyConnect", "MyReader", " myConnector", "myConnect", "yourConnection", "MyConnector", " myConn", "someReader"], "myReader": [" myParser", " myWriter", "yourParser", " myRead", "myRead", "myWriter", "MyRead", "MyWriter", "MyReader", "yourReader", "yourRead", "yourWriter", "MyParser", "myParser"], "line": ["lc", "cl", "header", "base", "error", "column", "parse", "el", "use", "id", "feed", "log", "row", "string", "name", "note", "Line", "end", "lines", "range", "word", "no", "link", "code", "LINE", "look", "day", "element", "pe", "user", "text", "rule", "block", "ri", "message", "cell", "du", "key", "point", "non", "lf", "page", "lin", "data", "file", "entry", "source", "letter", "l", "inline", "style", "frame", "pass", "liner", "part", "comment", "response", "le"], "linecount": [" lineindex", "pagecount", "rowsize", " linecache", "linelength", "lettercount", "lineindex", " linesize", "linecache", "lettersize", "linesize", " lineCount", "linenumber", "Lineindex", "pagenumber", "rowcount", "rowlen", " linelen", " linenumber", "Linesize", "letterlen", "Linecount", "pageCount", "rowcache", " linelength", "pageindex", "lineCount", "rowlength", "linelen", "Linecache", "LineCount", "Linenumber", "letterlength"], "hasOWL": ["hasEFLM", " hasEWDL", "hasOWSl", "hasODl", " hasEWLA", "hasBYL", "hasEWl", "hasEWL", "hasOWDL", "hasOWSDL", " hasEWl", "hasEFLA", "hasOULA", "hasOWLM", "hasOWSL", "hasOWl", "hasEWLL", " hasOWLL", " hasOWLM", "HasEWL", "HasOWLA", "hasODLM", " hasOWDL", "hasBYl", "hasEWLM", "hasOUL", " hasEWLL", "hasEWLA", "hasBYLL", "hasODL", "HasOWL", "HasOWLL", " hasOWl", "HasEWLA", "hasEWDL", "hasBYDL", "hasODLA", "HasOWLM", "hasEFL", "hasEFl", "hasOULM", " hasEWL", "hasOULL", "hasOWSLL", "hasOWLL", "HasEWLL", " hasEWLM", " hasOWLA", "hasOWLA", "HasEWLM", "hasODLL"], "hasRDFS": ["hasRFSU", "hasGRUFAST", "hasRDPS", "hasXDFE", "hasGRDFS", "hasRTFs", "hasCDPES", "hasGRDFAST", "hasRDFU", "hasCDFS", "hasRDPES", "hasRDPE", "hasRTFES", "hasXDPs", "hasRDFE", "hasRFES", "hasRdfS", "hasRUFAST", "hasCDPS", "hasRDFSU", "hasRDPSU", "hasXDPE", "hasRTFS", "hasRdfE", "hasRdfs", "hasCDFES", "hasRDFES", "hasRFAST", "hasRFE", "hasRDFAST", "hasGRDFs", "hasRUFSU", "hasRNFE", "hasXDFU", "hasXDPU", "hasRDPAST", "hasCDPE", "hasRDFs", "hasRNFs", "hasRNFS", "hasCDFs", "hasGRUFS", "hasGRUFs", "hasCDFE", "hasRFS", "hasXDPS", "hasCDPs", "hasGRUFSU", "hasXDFS", "hasGRDFSU", "hasRFs", "hasRUFS", "hasRDPs", "hasRdfU", "hasRUFs", "hasRDPU", "hasXDFs", "hasRNFU", "hasRTFE"], "hasRDF": [" hasRFD", "hasSRDP", "hasRRUF", "hasRDEF", "yesDDP", "HasRRDEF", "hasURUF", "hasURMF", " hasRRUF", "hasSRDEF", " hasRRFD", "hasDDF", "hasRRdf", "hasRFD", "yesDDF", "hasUOW", "HasRRDF", "yesDMF", " hasRUF", " hasRMF", "HasRRdf", "hasRRDP", "hasRRMF", "yesROW", "hasUMF", "yesRMF", "hasMRDP", "HasRdf", "hasSRDF", "hasNRDF", "yesRDF", "hasUDF", " hasRRMF", "yesRDP", "hasSRdf", "hasMRDEF", "hasRdf", "hasROW", "hasRRDEF", "hasNRFD", "hasDMF", "hasNRUF", "hasRRFD", "hasURDF", "hasNRMF", "hasDDP", " hasRRDF", "HasRDP", "hasMRDF", "yesDOW", "hasDOW", "HasRDF", "hasRUF", "HasRDEF", "hasUDP", "hasURFD", "hasMRdf", "hasRMF", "hasRDP", "HasRRDP", "hasRRDF"]}}
{"id1": "13783898", "id2": "22536033", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeFileToFiles", "encodeStringToFiles", "encodeFile2Stream", "encodeFiletoStream", "encodeFileFromFile", "encodeFileFromStream", "encodeFiletoFile", "encodeString2File", "encodeFiletoFiles", "encodeString2Files", "encodeFile2File", "encodeString2String", "encodeString2Stream", "encodeFileFromString", "encodeFileToString", "encodeFile2String", "encodeStringToString", "encodeFileToStream", "encodeFiletoString", "encodeStringToStream", "encodeFile2Files", "encodeStringToFile"], "infile": ["Infile", "infiles", "inputFile", "InFile", "inFile", "Infiles", "outFile", "inputfiles", "infilename", "outfilename", " infilename", "outfiles", "inputfp", "infp", " infiles", "inputfilename", " infp", "outfp", "Infilename", "inputfile"], "outfile": ["outputfilename", "newname", "Outname", "newFile", "outname", "infolder", "newfolder", " outname", "Outfolder", "outFile", "outfolder", " outfolder", "infilename", "outfilename", "outputfp", " outFile", "outputfile", " outfilename", " outfp", "newfile", "infp", "OutFile", "outputfolder", "Outfile", "outfp"], "in": ["gin", "base", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "vin", "ini", "input", "ic", "In", "s", "conn", "inner", "image", "err", "inas", "m", "a", "i", "r", "b", "again", "sin", "socket", "nin", "win", "inn", "min", "pin", "is", "into", "cin", "data", "source", "init", "inside", "rin", "pass", "ac", "con", "as"], "out": ["net", "exec", "base", "error", "OUT", "client", "outs", "cache", "job", "output", "bin", "ou", "io", "inc", "one", "session", "conn", "obj", "In", "inner", "on", "name", "to", "image", "err", "write", "off", "no", "Out", "lib", "or", "writer", "ex", "parent", "again", "o", "co", "socket", "sync", "post", "outer", "timeout", "point", "copy", "line", "source", "work", "file", "up", "home", "exit"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bb", "transfer", "feed", "raw", "fb", "input", "border", "length", "seed", "binary", "offset", "queue", "write", "len", "layer", "type", "reference", "batch", "count", "b", "null", "buf", "slice", "padding", "iter", "bytes", "wave", "flush", "data", "source", "server", "limit", "value", "split", "size", "buff"], "read": ["exec", " skip", " Read", "ip", "reader", "send", " copy", "parse", "lex", "allow", "use", "id", "feed", "io", "load", "inc", "raw", "current", "_", "check", "x", " count", "input", "connect", "start", "length", "ind", "play", "seek", "end", "write", "next", "len", "i", "count", "ride", "wait", "fill", "n", "find", "Read", "slice", "sync", "READ", "tell", " write", "ad", "iter", "close", "add", "get", "copy", "work", "sleep", "se", "limit", "reads", "pass", "reading", "size", "select", "f", "run"], "success": ["complete", "first", "result", "error", "cess", " succ", "fast", "status", "ccess", "growth", "follow", "flash", "primary", "right", "Success", "valid", "model", "func", "path", "default", " succeed", " Success", "true", "winner", "rolled", "results", "xx", "failed", "danger", " successful", "construct", "method", "null", "again", "ceed", "good", "message", "done", "rolling", "successfully", "respons", "content", "continue", "data", "warning", "successful", "pass", "roll", "initial", "better", "fail", "value", "open", "modified", "comment", "response"]}}
{"id1": "4531653", "id2": "18046717", "code1": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    private String getFullClassName(URL url, String className) throws Exception {\n        JarInputStream jis = new JarInputStream(url.openStream());\n        ZipEntry zentry = null;\n        while ((zentry = jis.getNextEntry()) != null) {\n            String name = zentry.getName();\n            int lastPos = name.lastIndexOf(\".class\");\n            if (lastPos < 0) {\n                continue;\n            }\n            name = name.replace('/', '.');\n            int pos = -1;\n            if (className != null) {\n                pos = name.indexOf(className);\n                if (pos >= 0 && name.length() == pos + className.length() + 6) {\n                    jis.close();\n                    return (name.substring(0, lastPos));\n                }\n            }\n        }\n        jis.close();\n        return (null);\n    }\n", "label": 0, "substitutes": {"md5": ["mp5", "md512", "mp7", "md7", " md512", "md6", "MD512", "MD7", "MD5", "MD6", " md7", " md6", "mp512", "mp6"], "data": ["template", "address", "base", "sha", "ata", "cache", "str", "output", "DATA", "input", "string", "name", "image", "hex", "this", "database", "code", "format", "a", "method", "dat", "text", "body", "pad", "message", "buffer", "media", "api", "alpha", "bytes", "key", "content", "in", "source", "script"], "md": ["MD", "mc", "dig", "metadata", "pm", "bd", "amd", "db", "mo", "meta", "mb", "mt", "cmd", "material", "hd", "rod", "sm", "code", "mand", "editor", "m", "dd", "gd", "od", "mg", "grad", "mm", "ma", "ad", "pd", "cd", "ds", "wd", "mac", "mod", "di", "d", "mag", "nm", "dm", " MD", "mp", "docker"]}}
{"id1": "9236363", "id2": "23370621", "code1": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"unJarStart": ["copyJarRest", "copyServerEnd", "syncServerPath", "copyjarStart", "copyjarEnd", "copyZipPath", "copyZipEnd", "copyJarStart", "copyZipRest", "copyServerPath", "copyJarPath", "copyjarRest", "syncJarEnd", "copyZipStart", "syncServerEnd", "copyServerRest", "syncJarRest", "syncJarPath", "copyjarPath", "syncServerStart", "copyJarEnd", "syncServerRest", "copyServerStart", "syncJarStart"], "jarPath": [" jarContent", "relEntry", "jarFile", "archiveDir", "relpath", "archivepath", "garContent", "badUrl", " jarName", "javaEntry", "jampath", "garText", "garpath", "badpath", "javaLog", "zippath", "zipPath", "jarpath", " jarText", "badPath", "jarCh", "garUrl", "narCh", "jarDir", "javaUrl", "jamLog", "garFile", "badLog", "zipEntry", "narpath", "garPath", "narName", "JarFile", "archiveLog", "javaName", "zipFile", "javaCh", "jarLog", "jarText", "narPath", "jarName", " jarDir", " jarUrl", "Jarpath", "javaFile", "javaPath", "jarUrl", " jarFile", "JarContent", " jarLog", "javaText", " jarpath", "JarPath", "JarCh", "relFile", "archivePath", "javapath", "jamPath", "jarContent", "JarName", "jamDir"], "jarEntryStart": ["tarentryStart", "jarImportFollow", " jarEntryFinish", "jarFilePart", "tarentryName", "jarAttemptPart", "jarImportEnd", " jarFileStart", "jarFileName", "jarAttemptEnd", "jarFileEnd", "tarEntrySource", " jarImportStart", "tarEntryStart", "jarEntryPart", "jarImportName", " jarFileName", "jarFileFollow", "jarEntryFollow", " jarFilePart", " jarEntryName", "jarPartEnd", "jarEntName", " jarEntrySource", "jarFileStart", " jarImportEnd", "jarentryStart", "jarentrySource", "tarEntryPart", "tarentryPart", "jarEntryEnd", "jarEntryFinish", "jarEntPart", "jarFileFinish", "jarImportFinish", "tarEntryName", "jarEntryName", "jarAttemptStart", " jarFileSource", "jarentryPart", "tarentrySource", "jarPartStart", " jarImportPart", "jarPartFinish", "jarEntSource", " jarFileFinish", " jarEntryFollow", "jarEntrySource", "jarAttemptFollow", " jarEntryEnd", "jarPartPart", "jarImportSource", "jarImportStart", " jarImportFollow", "jarFileSource", "jarImportPart", " jarEntryPart", " jarFileEnd", "jarentryName", "jarEntStart"], "path": ["test", "error", "cache", "right", "id", "log", "session", "pattern", "location", "name", "conn", "context", "method", "ph", "route", "directory", "th", "graph", "api", "mount", "p", "ion", "cookie", "data", "file", "ith", "ha", "prop", "left", "folder", "boot", "pointer", "patch", "string", "Path", "prefix", "object", "dest", "key", "template", "base", "system", "zip", "inner", "then", "code", "mode", "parent", "config", "loc", "uri", "resource", "it", "content", "source", "work", "dir", "home", "temp", "url", "PATH", "clean", "output", "request", "default", "host", "archive", "image", "next", "step", "type", "root", "text", "ath", "wd", "pass", "json", "ctx", "po"], "relPath": ["relpath", "relativepath", " relDir", "relativeDir", "relativePath", " relName", "relName", "Relpath", "relativeName", "RelName", " relPos", "RELName", "relativePos", "RelPath", "RELPath", "RELPos", "RelDir", " relpath", "relPos", "relDir", "RELpath"], "jar": ["ser", " module", "url", "drop", "cache", "magic", "car", "sr", "parse", "war", "com", "ar", "zip", " war", "ball", "xml", "folder", "space", "ler", "sl", " archive", "er", "plugin", "ge", "start", "log", "fire", "tab", "archive", "pkg", "tar", "bag", " tar", "keeper", "zone", "ssl", "java", " manifest", "bar", "browser", "gap", " java", " dir", "pipe", "per", "her", "pack", " capsule", "jo", " parser", "dr", "cookie", "sheet", "server", "dir", "spin", "rar", "mag", "sp", "open", "Jar", "module"], "entries": ["entrys", "Entursions", "enders", "quies", "entensions", "quents", "enties", "quries", "ientries", "endries", "entEntry", "Enties", "counters", "endrys", "entories", "countEntry", "adders", "entryEntry", "qulements", "addries", "entryers", "enters", "ientursions", "endories", "entryensions", "entryries", "entlements", "entursions", "ENTents", "antries", "Entlements", "Entrys", "Entry", "ientry", "ENTlements", "iters", "itrys", "ENTries", "antursions", "addEntry", "Entents", "countries", "itories", "Entories", "countensions", "ENTies", "antlements", "Entries", "entents", "ientlements", "itries", "addensions", "Enters", "antry"], "entry": ["oe", "address", "de", "be", "lie", "reader", "enter", "parse", "e", "zip", "cel", "je", "ler", "ge", "name", "obj", "mer", "or", "element", "ie", "r", "ent", " Entry", "Entry", "pack", "la", "resource", "add", "it", "key", "jo", "ry", "se", "server", "ries", "pie", "cat", "part", "ce", "module"], "jarEntry": ["jarFile", "archiveFile", "javaEntry", "celEntry", " jarElement", "javaImport", "javaRule", "carEntry", "javaElement", "celEnt", " jarentry", "serName", "jarRule", "celFile", "serEntry", "jobEntry", "javaEnt", "carElement", "archiveRule", "serElement", "jarentry", "jobImport", " jarEnt", "javaName", "serFile", "archiveElement", "jarName", " jarImport", "javaFile", "carPath", "javaPath", "jarImport", "javaentry", "carEnt", "jarEnt", "archiveEnt", "archiveName", "celRule", "jobPath", "archiveEntry", "jarElement", "jobentry"], "ze": ["zie", "z", "ja", "ipe", "e", "zip", "cel", "je", "sl", "kee", "ge", "te", "li", "zen", "zes", "fe", " je", "code", "ZE", "ide", "ie", "pe", "zer", "zo", "za", "zi", " ace", "jo", "xe", "se", "ke", "ne", "ine", "ce", "aze", "le", "zy", "be"], "bin": ["bn", "base", "bit", "login", "bb", "zip", "proxy", "isin", "bis", "vin", "spin", "log", "boot", "ini", "plugin", "index", "abin", "binary", "inner", "lock", "len", "bank", "bot", "bas", "lib", "zone", "info", "bar", "body", "sin", "win", "resource", "inn", "gi", "pin", "abi", "arin", "di", "in", "data", "file", "cin", "init", "kin", "bi"]}}
{"id1": "11484416", "id2": "19335986", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "label": 1, "substitutes": {"moveFile": [" movedFiles", " movedPath", " movePath", " moveFiles", "MovePath", " movedFile", " moveDirectory", "moveFiles", "movePath", "MoveDirectory", "moveDirectory", " movedDirectory", "MoveFiles", "MoveFile"], "orig": ["base", "img", "bin", "tmp", "id", "comb", "proxy", "exe", "old", "internal", "folder", "remote", "obj", "ext", "archive", "original", "image", "raf", "bas", "build", "org", "Orig", "ori", "info", "prev", "real", "transform", "buf", "raid", "dest", "loc", "iter", "array", "rb", "copy", "imag", "source", "file", "init", "coord", "src", "frame", "coll", "origin", "impl", "home", "ctr", "f", "temp"], "target": ["external", "template", "prot", "result", "base", "master", "arget", "project", "tmp", "force", "platform", "current", "replace", "path", " Target", "remote", "auto", "archive", "ret", "to", "original", "next", "this", "build", "format", "t", "Target", "reference", "object", "parent", "join", "dest", "nt", "resource", "it", "copy", "source", "compatible", "match", "eth", "origin", "manager", "f", "temp"], "buffer": ["Buffer", "position", "url", "result", "address", "base", "header", "uffer", "cache", "bb", "bin", "transfer", "feed", "raw", "request", "input", "repeat", "length", "sequence", "binary", "queue", "write", "code", "read", "layer", "reference", "batch", "b", "null", "buf", "slice", "block", "padding", "message", "iter", "resource", "bytes", "wave", "content", "copy", "stack", "source", "data", "file", "frame", "buff"], "bread": ["bn", "bc", "food", "brew", "bare", "buck", "str", "bb", "feed", "beat", "zip", "circ", "ble", "cook", "ffe", "div", "design", "cake", "four", "length", "raft", "rib", "wake", "knife", "fe", "choice", "batch", "rows", "fine", "rub", "bat", "hello", "fred", "good", "fall", "inn", "eb", "broken", "key", "fed", "fee", "abi", "bee", "sleep", "grain", "wen", "width", "robe", "fif", "loop", "piece", "fle", "num", "die", "fen", "web", "meal", "zero"], "fis": ["his", "qiss", "ufos", " fiss", " fIs", "afos", "qos", " fisa", "fIs", "fils", "lfos", " fils", "afis", "ufiss", "afIs", "lfis", "fxos", "qis", "lfIs", "lfiss", "ufis", "fiss", "afiss", "ufils", "hisa", "qils", "fxisa", "fxis", "hos", "fxIs", "hIs", "fisa"], "fos": ["flois", " foss", " fens", "Fros", "gos", "infois", "flors", "fens", "Foses", "fors", "foss", "Fors", " foses", "Fos", "floses", "Fis", "goss", "Fens", "fros", "fois", "Foss", "fose", "Faos", "flose", "infaos", "flaos", "Fois", "gros", "infors", " fose", "Fose", "flos", "gis", " fros", "foses", "faos", "infos", "flens"]}}
{"id1": "21821404", "id2": "596993", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    private String makeLoginRequest(URL url) throws IOException {\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setDoInput(true);\n        urlConnection.setDoOutput(true);\n        urlConnection.setUseCaches(false);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"Email=\").append(URLEncoder.encode(EMAIL, \"UTF-8\"));\n        content.append(\"&Passwd=\").append(URLEncoder.encode(PASSWORD, \"UTF-8\"));\n        content.append(\"&service=\").append(URLEncoder.encode(SERVICE, \"UTF-8\"));\n        content.append(\"&source=\").append(URLEncoder.encode(\"Google Base data API\", \"UTF-8\"));\n        OutputStream outputStream = urlConnection.getOutputStream();\n        outputStream.write(content.toString().getBytes(\"UTF-8\"));\n        outputStream.close();\n        int responseCode = urlConnection.getResponseCode();\n        InputStream inputStream;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = urlConnection.getInputStream();\n        } else {\n            inputStream = urlConnection.getErrorStream();\n        }\n        return toString(inputStream);\n    }\n", "label": 0, "substitutes": {"getWebPage": ["getVirtualpage", "getVirtualpages", "parsewebpage", "parsewebPage", "parseWebPage", "parseWebpage", "getWebpages", "getwebpages", "getwebpage", "parsewebpages", "getwebPage", "getVirtualPage", "parseWebpages", "getWebpage"], "urlObj": ["strObject", "urlobj", "urlExt", " urlExt", "URLObj", "httpOb", "UrlObj", "URLExt", "urlOb", "resourceExt", " urlInst", "URLobj", " urlobj", "resourceobj", "httpObj", "UrlOb", "Urlobj", "strobj", "blogObject", "resourceObj", "strInst", "strObj", "URLObject", "urlInst", " urlObject", "blogObj", "httpobj", " urlOb", "resourceObject", "urlObject", "blogobj", "blogInst"], "content": ["address", "url", "result", "cont", "header", "clean", "output", "feed", "load", "model", "raw", "string", "out", "core", "lines", "section", "c", "write", "code", "comments", "java", "report", "html", "text", "body", "object", "empty", "online", "css", "message", "array", "buffer", "resource", "Content", "document", "page", "data", "source", "file", "server", "continue", "work", "coll", "value", "json", "comment", "response"], "is": ["ser", "us", "im", "rest", "ais", "ires", "ip", "ins", "ai", "does", "ois", "site", "iso", "isa", "ar", "io", "was", "id", "IS", "bis", "ise", "x", "Is", "es", "al", "abs", "ir", "cms", "s", "ui", "stream", "ris", "out", "est", "isl", "iss", "ios", "os", "nis", "or", "you", "ie", "i", "r", "info", "irc", "ops", "any", "lis", "problem", "ps", "il", "isc", "isi", "ri", "fs", "it", "isp", "iris", "its", "in", "as", "mis", "be"], "reader": ["ser", "actor", "e", "io", "rr", "worker", "x", "rer", "ler", "row", "er", "stream", "driver", "inner", "editor", "read", "Reader", "or", "bird", "writer", "i", "r", " Reader", "rx", "handler", "oder", "loader", "ner", "ri", "buffer", "iter", "parser", "h", "rc", "in", "l", "server", "ro", "rar", "director", "reading"], "line": ["url", "cl", "lc", "column", "str", " inline", "row", "string", "name", "out", "Line", "response", "word", "lines", "section", "cr", "link", "character", "code", "LINE", "connection", "user", "text", "body", "object", "block", "strip", "cle", "message", "buffer", "key", "lf", "page", "data", "lin", "file", "l", "col", "char", "source", "entry", "server", "inline", "pass", "part", "ine", "comment", "f", "item", "cell"]}}
{"id1": "18370075", "id2": "3375724", "code1": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "code2": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createPasswordDigest": ["createpassworddigest", "createPasswordModenge", "createPassworddigest", "createPasswordSignest", "createPasswordSignifier", "createPasswordSignenge", "createPassworddigenge", "createpassworddigenge", "createPasswordDigenge", "createpasswordDigester", "createPasswordModest", "createpasswordDigest", "createPasswordDigester", "createPasswordDigifier", "createPasswordSignester", "createpassworddigester", "createPasswordModifier", "createpasswordDigifier", "createPassworddigifier", "createpassworddigifier", "createpasswordDigenge", "createPassworddigester", "createPasswordModester"], "password": ["hash", "address", "account", "token", "Password", "login", "sword", "security", "command", "wallet", "path", "filename", "pattern", "seed", "name", "string", "word", "database", "auth", "words", "username", "crypt", "user", "text", "config", "pad", "padding", "message", "p", "key", "wd", "phrase", "data", "PASS", "source", "secret", "email", "pass", "Pass"], "salt": ["SALT", " sALT", "ssalt", "ssALT", "ssass", "sass", "ssecret", "Ssecret", "pALT", "sesass", "psecret", " sass", "sALT", "Salt", "pass", "sesALT", "Sass", "sssecret", "sesalt", " ssecret", "palt", "sessecret"], "md": ["mad", "MD", "mc", "sha", "ms", "clean", "metadata", "pm", "bd", "zip", "amd", "mo", "meta", "mb", "mt", "ind", "cmd", "code", "mand", "m", "dd", "ph", "gd", "od", "mm", "ma", "ad", "pd", "message", "cd", "kg", "nd", "mac", "mn", "mod", "me", "di", "ld", "d", "mag", "bf", "nm", "dm", " MD", "mail", "po"], "digest": [" digested", "hashest", "generress", "signest", "decests", " digests", " digcode", "dEST", " digress", "digEST", " digester", "generests", "digester", " digEST", "decest", "decester", "digests", "DigEST", "dest", "digested", "digress", "Digester", "hashested", "hashcode", "hashester", "dested", "dester", "signester", "Digest", "Digested", "digcode", "signcode", "generester", "signested", "generest", "decress"]}}
{"id1": "6403868", "id2": "9109613", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"extractUninstallFiles": ["extractUninstallfiles", "extractUnzipfiles", "extractUnInstallFiles", "extractUpinstallFiles", "extractUninstallSources", "extractUnpackfiles", "extractUpinstallSources", "extractUnInstallfiles", "extractUnzipSources", "extractUnpackSources", "extractUnzipFiles", "extractUppackFiles", "extractUppackfiles", "extractUppackFile", "extractUpinstallfiles", "extractUppackSources", "extractUnInstallFile", "extractUnpackFile", "extractUpinstallFile", "extractUnInstallSources", "extractUnzipFile", "extractUninstallFile", "extractUnpackFiles"], "_destPath": ["_sourcepath", "_srcFile", "_sourcePath", "_distFile", "_distPath", "_destDir", "_sourceDir", "_downloadPath", "_sourceDirectory", " _destFile", "_tmppath", "_srcPath", "_tmpPath", "_downloadHome", "_tmpDirectory", "_DestDirectory", " _sourceDirectory", "_tmpDir", " _sourceFile", "_DestFile", "_sourceHome", "_srcDir", "_srcDirectory", "_distDirectory", " _destHome", " _destDirectory", "_destHome", "_destDirectory", "_DestDir", "_destFile", " _sourceHome", "_DestPath", "_downloadFile", " _sourcePath", "_DestHome", "_downloadDirectory", "_destpath", "_Destpath", "_sourceFile", "_distDir"], "upgrade": ["ipgrading", "upinstall", "offgrades", "offgrade", " upGrade", "duGrade", "offgrading", "upgrading", " upgrades", "duge", "upge", "UpGrade", "upgrades", "ipgrades", "Upge", "Upgrading", "ipgrade", " upgrading", "dugrade", "Upgrade", " upge", "ipinstall", "offinstall", "upGrade", "dugrading", " upinstall"], "lastVer": ["lastVers", "nextVersion", "firstVER", "prevver", "firstVer", "lastVER", " lastver", "prevVers", " lastVersion", "LastVER", "prevVer", "LastVersion", "firstver", "firstVersion", " lastVers", "lastVersion", "nextVer", "lastver", "Lastver", " lastVER", "nextVers", "LastVer", "nextver", "prevVersion"], "oldlog": ["OldLog", "newLog", " oldtext", "oldbug", "newpath", "oldLOG", "oldtext", "oldertext", "olderLOG", "Oldlog", "olderlog", " oldpath", " oldbug", "oldpath", "OldLOG", "Oldpath", "olderLog", "newtext", " oldLog", "newlog", "newLOG", "OLDLog", "OLDbug", "oldLog", "OLDlog", "newbug", " oldLOG"], "destPath": ["destFile", "DestDirectory", "constPath", " destLog", "DestPATH", "contPath", "flatFolder", "constFile", "sourcePath", " destWin", "descDir", "sourcepath", "postRoot", "exportpath", "homepath", "destath", "constpath", "constHome", "destHome", " destDir", " destName", "usrpath", "destDirectory", "securePath", "doneWin", "destRoot", "destKit", "descFile", "exportDirectory", " destHome", " destFile", " destFolder", "destName", "destLog", "postPATH", "homePath", "secureDir", "usrFile", "targetPATH", " destpath", "DestHome", "flatDir", "doneLog", "postPath", " destCh", "DestDir", "homeDir", "donepath", "contath", "exportPATH", "targetDir", "targetFile", "Destath", "secureWin", "destCh", "donePath", "destWin", " destath", "targetPath", "sourceDirectory", "targetRoot", "DestFolder", " destPATH", "DestPath", " destDirectory", "srcDirectory", "descCh", "descpath", "usrPath", "descName", "postpath", "destFolder", "destDir", "homeName", "doneDir", "flatPath", "homeLog", "exportPath", "targetpath", "DestFile", "homeKit", "destpath", " destRoot", "srcPath", "descPath", "DestRoot", "srcPATH", " destKit", "descKit", "contpath", "Destpath", "srcpath", "secureLog", "destPATH", "contDir", "sourceDir", "DestCh", "flatpath"], "lastVerPath": ["lastModCh", "nextverCh", "lastVerspath", " lastVersionpath", "lastTestpath", " lastVersionCh", "lastVersPath", "lastTestId", " lastVerFile", "prevverName", "lastVersionPath", "nextverpath", " lastVerpath", "lastVERPath", "lastVerEx", "lastVERDir", " lastVersionFile", " lastVersionPath", " lastVerId", "lastModDir", " lastModCh", " lastVersionId", "lastVERCh", "nextverFile", "prevVerFile", "lastVerName", "lastverFile", "prevverpath", "lastverCh", "lastVersionId", "lastModpath", "lastVersionCh", "prevVerName", "lastVersFile", "lastTestFile", "nextVerFile", "lastVersionpath", "nextVerpath", "lastVerCh", "lastverName", "lastVerpath", " lastModPath", "lastModName", " lastVerEx", "lastVEREx", "lastverId", "lastVerFile", " lastVerCh", "lastVersCh", "nextVerPath", "prevverPath", " lastModDir", " lastVerDir", "lastVersionEx", "lastverDir", "nextVerCh", "lastVersionFile", " lastVersionEx", "nextverPath", "prevVerPath", "lastverEx", "lastVerDir", "lastVerId", "lastModPath", "lastverpath", "lastverPath", "lastTestPath", "lastVersionName", "lastModFile", "lastVERpath", "prevverFile", " lastModpath", "prevVerpath"], "bkdir": [" bktloc", "Bckdir", "bKdirectory", "bvpath", " bktdesc", "bktfile", "bkkloc", "bKDir", "bvDir", "bvloc", "bkkfile", "bckdir", " bktdir", "bakDir", " bkloc", "Bkpath", "bktdesc", "bkdirectory", "bkir", " bkdesc", "Bkdir", "bKpath", "Bkdirectory", "bkbloc", "bkkdir", "BkDir", "bkgir", "bkkpath", "bktloc", "bkDir", "bkgDir", "bakloc", "bakdirectory", " bktfile", " bkfile", "BckDir", "bkgdir", "bakir", "Bckdirectory", "bckDir", " bkpath", "Bckpath", "bkbdesc", "bkpath", "bkkDir", " bkDir", " bakloc", "bktdir", " bakpath", "bkkdesc", " bakir", "bakpath", "bckpath", "bvdir", "bkloc", "bkbdir", "bkbfile", "bkfile", "bkkir", " bakdir", " bakDir", " bkir", "bkdesc", "bKdir", "bakdir", "bckdirectory"], "oldClassCopied": ["oldClassCopyies", "oldclassCopies", "oldFileCopying", "oldclassCopied", "oldFilecopies", "oldClassCopying", "oldClasscopored", "oldClassCopyified", "oldFilecopie", "oldFileCopified", "oldClasscopie", "oldFileCopyified", "oldclassCopie", "oldFileCopyying", "oldClassCopies", "oldClassSkied", "oldclassCopored", "oldClassSkies", "oldClassCopyiated", "oldClasscopying", "oldClassCrossied", "oldClassCopie", "oldClasscopied", "oldFileCopies", "oldFileCopiated", "oldClassCopified", "oldClassCrossified", "oldFileCopie", "oldFileCopyiated", "oldClassCrossying", "oldFileCopied", "oldClasscopies", "oldClassCopiated", "oldFilecopying", "oldClassCrossiated", "oldClassCopyied", "oldClassSkored", "oldClassCopyying", "oldClassCopyie", "oldFileCopyied", "oldFilecopied", "oldClassCopored", "oldClassSkie"], "ls": ["lc", "less", "dl", "ails", "lp", "sels", "wl", "vs", "lv", "fl", "locks", "ns", "lists", "ln", "lbs", "lines", "tl", "files", "bps", "als", "fts", "lb", "mails", "iffs", "igs", "cs", "ll", "lis", "list", "los", "la", "fs", "lr", "ols", "LS", "les", "lf", "l", "irs", "qs", "ches", "lt", "rl", "bs", "ils", "acl"], "i": ["qi", "v", "z", "lc", "ip", "ai", "ti", "I", "uli", "e", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "q", "start", "ind", "li", "u", "s", "hi", "ui", "inner", "multi", "ci", "c", "si", "mi", "ij", "phi", "ii", "m", "y", "t", "type", "j", "info", "b", "o", "slice", "end", "ri", "uri", "p", "min", "it", "gi", "fi", "ix", "abi", "oi", "di", "l", "d", "yi", "ji", "part", "mu", "f", "pi"]}}
{"id1": "12428013", "id2": "4118412", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 0, "substitutes": {"polishOff": [" synchronipeOn", " synchroniceOffline", " synchronishingOffline", " polishingOn", " synchronishingOn", " synchroniceDown", " polishingOffline", " synchronishingOff", " synchronipeOff", " synchronishOn", " synchronishOff", " polishOn", " synchronipeDown", " synchronishDown", " polishDown", " synchroniceOn", " polishingDown", " synchronipeOffline", " synchroniceOff", " synchronishOffline", " synchronishingDown", " polishOffline", " polishingOff"], "monitor": ["cm", "oper", "processor", "master", "mc", "stat", "mor", "client", "status", "controller", "pm", "port", "progress", "container", "cher", "log", "function", "conn", "core", "thread", "state", "driver", "umi", "callback", "image", "sm", "widget", "mon", "m", "or", "reason", "component", "duration", "username", "report", "counter", "method", "number", "watch", "object", "program", "directory", "body", "handler", "config", "loader", "period", "update", "message", "timeout", "condition", "meter", "consumer", "don", "match", "clock", "member", "dm", "annot", "timer", "unit", "runner", "control", "manager", "Monitor", "module"], "from": ["actor", "address", "url", "false", "base", "vol", "left", "id", "ou", "path", "owner", "remote", "host", "start", "name", "string", "contact", "range", "action", "prefix", "code", "org", "or", "small", "username", "at", "type", "connection", "component", "user", "route", "front", "with", "back", "loc", "uri", "attribute", "resource", "add", "by", "form", "who", "source", "channel", "server", "since", "email", "From", "about", "origin", "part", "size", "ce"], "to": ["su", "two", "address", "url", "eto", "base", "token", "site", "left", "io", "remote", "TO", "target", "location", "name", "out", "top", "range", "prefix", "database", "toc", "type", "repl", "info", "go", "connection", "user", "To", "so", "o", "with", "dest", "table", "uri", "version", "resource", "by", "key", "into", "source", "server", "file", "pos", "ref", "about", "value", "full", "until", "reply", "size", "po"], "renameTo": ["relameTo", "relenameUrl", "reageTO", "renseTo", "renalto", "renamelTo", "renseFor", "renAMEUrl", "renributeTo", "renAMEToken", "reameTO", "renewTarget", "renAMETo", "renageToken", "renenameUrl", "renamelOf", "renAMETarget", " RenAMEWill", " RenameFor", "renamelFor", "rennameTarget", "reageto", "renseTO", "renokeUrl", "renokeOf", "renameUrl", "renokeTO", "renokeFor", "relenameTo", "renameFor", "rennameTo", "renseOf", "relameto", "relameFrom", "renenameto", " RenameOf", "renameto", "relameTarget", "renamTarget", " RenAMETo", "renameFrom", "renamWill", "renenameTarget", "renameToken", "relalFrom", "reameTo", "renributeWill", "renoketo", " renAMETo", "relalTo", "renageTO", "renenameTo", " renameTarget", "renalTo", "renalFrom", "renalTarget", " RenseOf", "rennameto", " RenseFor", " renAMEFrom", "relameUrl", "renAMETO", "rennameFrom", "renewTo", "renageto", "renAMEFrom", "renalTO", "relalto", "reameToken", "renageTo", "relenameto", "renameWill", "reameto", " RenAMEFor", "renameTarget", "relalTarget", "renamFor", "reageTo", "renameOf", "renokeFrom", "renributeTarget", "renAMEto", "reageToken", " RenAMETarget", " RenameTarget", " RenameWill", "relenameFrom", "renalToken", "renributeFor", "renameTO", "renAMEWill", " RenseTo", "renenameFrom", " RenseTO", " renAMETarget", "renewFrom", "renokeTo", "renamelTO", " RenameTo", " RenameTO", "renamTo", "renAMEFor", " renameFrom"], "ftpClient": ["ftpCommunity", "ftpChannel", "ftcpChannel", " ftapiCloud", " fttpClient", "ctcpServer", " ftlClient", "ftmClient", " ftpoCenter", "ftcpResource", " ftiServer", " ftiClient", " ftpCloud", "ftpsContainer", "aftpStream", "ftbCan", " ftpiChannel", " ftapiClient", "ftfClient", "ftlCommunity", "ftpcClient", "ftcpCenter", "fttpStream", "ctpChannel", " ftpoClient", " ftapiHelper", " ftpContainer", " ftpclient", "ftfCenter", "ftpclient", "ftpcCommunity", " fttpContainer", " ftpiServer", "ftoHost", "ftpiServer", "ftcpCommunity", "ftfCloud", "fticlient", "ftcGuest", "ftlConnection", "ftoCan", "ctcpResource", " ftpChannel", "ftpoCenter", "ftcpCloud", "ftlCenter", "ftpiClient", "ctpResource", "ftpcServer", " ftpHelper", "ftcServer", "ftpGuest", "ftpcHelper", "ftfpCloud", "ftpiHost", "ftpsControl", "ftcpGuest", "ftbHost", "ftfpChannel", "ftpsClient", " ftpGuest", " ftoCan", "ftapiServer", " fttpClass", "ftcpClient", " ftnServer", "ftnHost", "afttClient", " ftpHost", "ftfpResource", "ctpServer", "ftcClient", "ftmResource", " ftnHost", " ftiGuest", "fttpHost", "ftfpServer", "afttStream", "ftiGuest", " ftlCommunity", "ftcpConnection", "ftcpHost", "ftpoCloud", "ftcpServer", "fttpContainer", "ftpoClient", "ftpsClass", " ftoServer", "fttpClass", " ftpServer", "ftfpClient", "fttpControl", " ftpConnection", "ftpResource", "ftpcControl", "ftmChannel", " ftapiServer", "ftpConnection", " ftpClass", "aftpClient", "ftapiHelper", " ftpControl", " ftpiHost", " ftnClient", "ctcpClient", "ftpHost", "ftfpCenter", "ftbServer", "ftpcClass", " ftpCenter", "ftmServer", "ftbrClient", "ftapiClient", "ftnServer", " fticlient", "ftpCloud", "fttClient", "ctcpChannel", "ftcpHelper", "ftoClient", "ftiClient", "ftiServer", "ftbClient", "fttStream", "ftbrStream", "ftoServer", " ftpCommunity", "ftcclient", "ftnClient", "ftpClass", "ftpcContainer", " ftpCan", "ftpcCloud", "fttpCan", "ftpStream", " ftoHost", " ftpiClient", "fttpChannel", "ftpiChannel", "fttpClient", " ftlConnection", "ftpServer", "ctpClient", "ftcpclient", "fttpServer", "ftpcConnection", " fttpControl", "ftpHelper", "ftpContainer", " ftpoCloud", " ftlCenter", "ftpCan", "ftapiCloud", "ftpCenter", "ftlClient", "ftpcCenter", " ftoClient", "ftpControl"], "ftpHolder": ["ftpWather", "fttpChard", "ftpWholder", "ftpcWolder", "ftphander", "fttpChander", "ftphholder", "ftphold", "ftpSholder", "fttpHook", "ftpChard", "ftpWolder", "ftpWorkather", "ftpcHather", "ftpHander", "ftpholder", "ftpShander", "ftpcHold", "ftpShard", "ftpShook", "ftpHook", "ftpWorkholder", "ftpcWather", "ftpHholder", "fttpHolder", "ftpCholder", "ftpcWholder", "ftpHather", "ftphather", "ftpHold", "fttpHander", "ftpChook", "ftpWorkolder", "ftpHard", "ftpChander", "fttpChook", "fttpCholder", "ftpcHolder", "ftpWorkold", "ftpWold", "fttpHard", "ftphard", "ftphook", "ftpcWold", "ftpcHholder"], "iter": ["ser", "oper", "result", "ipper", "iv", "ip", "ver", "collect", "ter", "chain", "reader", "itter", "enter", "finder", "e", "id", "ator", "inc", "skip", "cher", "index", "er", "former", "keep", "ir", "end", "inner", "set", "next", "err", "Iterator", "or", "ite", "i", "info", "over", "loc", "list", "walker", "gener", "ner", "outer", "it", "iterator", "its", "http", "in", "entry", "file", "izer", "init", "Iter", "limit", "coll", "size", "inter", "f", "ener"], "element": ["air", "ele", "e", "section", "empty", "option", "attribute", "document", "data", "article", "letter", "server", "coll", "value", "atom", "part", "header", "token", "child", "Element", "folder", "environment", "er", "input", "action", "or", "event", "component", "et", "definition", "number", "object", "key", "page", "match", "activity", "comment", "item", "cell", "result", "reader", "el", "container", "inner", "entity", "editor", "layer", "parent", "per", "resource", "content", "email", "variable", "member", "module", "output", "owner", "plugin", "node", "ee", "next", "this", "expression", "type", "connection", "text", "service", "optional", "line", "entry", "style", "instance"]}}
{"id1": "4618237", "id2": "11049257", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "label": 0, "substitutes": {"writeFileToFile": ["writeFileAndStream", "writeFile2Channel", "writeFileToChannel", "writeFilesToFiles", "writeFilesToFile", "writeFileAndChannel", "writeFilesToChannel", "writeFileAndFile", "writeFilesAsChannel", "writeFileAndFiles", "writeFileToFiles", "writeFile2File", "writeFile2Files", "writeFilesAsStream", "writeFilesAsFile", "writeFileToStream", "writeFile2Stream", "writeFileAsStream", "writeFileAsFiles", "writeFilesAsFiles", "writeFileAsChannel", "writeFilesToStream", "writeFileAsFile"], "fin": ["fp", "thin", "din", "inv", "rf", "include", "ini", "FIN", "conn", "fm", "ris", "ln", "raf", "rt", "fa", "Fin", "en", "ori", "fine", "pins", "fr", "nir", "inn", "inf", "pin", "fi", "fd", "arin", "lin", "fn", "file", "init", "kin", "rin", "fen", "f", "fat"], "fout": [" fint", "Fint", "rfint", "bin", " foff", "rfin", "rfOut", "bOut", "fint", "Fin", "rfout", "bout", "Foff", " fOut", "boff", "FOut", "fOut", "foff", "Fout"], "append": ["send", "save", "apply", "leaf", "opp", "app", "protect", "flat", "pend", "end", "atten", "ext", "string", "ending", "remove", "batch", "ended", "null", "text", "printf", "enc", "want", "future", "pad", "padding", "except", "update", "pack", "add", "optional", "flush", "adjust", "vert", "push", "password", "spread", "only", "fail", "open"], "inChannel": ["innerConnection", "outQueue", "innStream", "inputChan", " inchannel", " inQueue", "inChan", "inQueue", "InStream", "innerChannel", "outChan", "InChannel", "inchannel", "outchannel", "innerchannel", "loginchannel", "outStream", "inputConnection", "inputStream", "innChannel", "INChan", " inStream", "INchannel", "inStream", "INChannel", "innchannel", "innerStream", "INStream", "inConnection", "INConnection", "InChan", "innerChan", "INQueue", "loginStream", "Inchannel", "loginChannel", "inputChannel"], "outChannel": ["Outchannel", "outputChan", "outContext", "inChan", "OutStream", " outChan", "outputchannel", " outContext", "outChan", "inchannel", "outchannel", "outputChannel", "externalChan", "outStream", "outputSocket", "inSocket", "ioChan", "inStream", "externalChannel", "ioStream", "ioChannel", "externalSocket", "OutContext", " outchannel", "outSocket", "iochannel", "OutChan", "OutChannel", "inContext", "externalchannel"]}}
{"id1": "4593011", "id2": "20275821", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"loadDDL": ["LoadCDE", "loadDDE", "loadODL", "LoadDDLL", "loadSDLL", "loadCDML", "loadSDE", "loadODLL", "loadCDL", "loadODML", "LoadDDML", "loadSDML", "LoadDDE", "loadDDLL", "loadODE", "LoadDDL", "LoadCDL", "LoadCDLL", "LoadCDML", "loadSDL", "loadDDML", "loadCDLL", "loadCDE"], "stmt": ["stm", "constm", "Stmd", " stm", " stmn", "Stmp", " sttr", " stgr", "sttt", "Stm", "STtr", "Sttt", "rm", "estmt", "rdb", "rmt", "rmd", "tmt", "constmt", "esttt", "tmd", "STmp", "estmd", "strgr", "Stdb", "stmd", " stdb", "constmn", "Stmb", " sttt", "estm", "tdb", "Stmn", "estmp", "stmr", "STmb", "strmt", "stpr", "stmn", "STgr", "tm", "STpr", "sttr", "Stmr", " stpr", "STmr", "constdb", "stmp", "Stmt", "STmt", "strpr", "stgr", "strtr", "stmb", "estmr", "estmb", " stmd", "stdb"], "qry": ["quri", "qries", "equry", " qury", "Qries", "quries", "qurys", "qrys", "eqRY", "Qry", "qRY", " qrys", "quury", "qury", "qri", " qri", " qries", "quRY", "eqry", " qRY", "Qri", "Qrys", "eqrys"], "q": ["v", "k", " p", "e", "id", "requ", "request", " query", "queue", "c", "Q", " sq", "t", "sq", "i", "r", "dq", "ql", "b", "iq", "n", "query", "config", "qq", " req", "qu", "p", "key", "qa", "ch", "qs", "eq", "qt", "d", "req", "quant", "quest", "select", "f"]}}
{"id1": "339517", "id2": "4921631", "code1": "    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n        URL url = getClass().getResource(name);\n        InputStream in = url.openStream();\n        try {\n            return ClassFile.read(in);\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 0, "substitutes": {"getClassFile": ["getCacheCode", "getSourceLoader", "createCodeCode", "createClassCode", "getCacheLoader", "getClassFiles", "getClassLoader", "getSourceFile", "getCacheFile", "getCodeCode", "getSourceFiles", "createClassFile", "getSourceCode", "createCodeFiles", "createClassLoader", "getCacheFiles", "getCodeFile", "getCodeLoader", "getClassCode", "createClassFiles", "createCodeFile", "createCodeLoader", "getCodeFiles"], "name": ["address", "base", "str", "ame", "id", "path", "Name", "request", "default", "filename", "string", "named", "size", "prefix", "this", "type", "i", "info", "connection", "class", "definition", "n", "object", "parent", "config", "loader", "uri", "resource", "key", "data", "source", "file", "pass", "names", "part", "NAME"], "url": ["base", "reader", "el", "found", "id", "feed", "io", "URL", "sl", "Url", "host", "string", "ls", "image", "resources", "this", "ssl", "i", "r", "connection", "class", "b", "user", "ll", "rule", "config", "loader", "uri", "service", "resource", "http", "l", "source", "file", "server", "page", "instance", "open", "rl", "f"], "in": ["gin", "ins", "din", "reader", "IN", "token", "login", "bin", "id", "isin", "inc", "ini", "input", "out", "In", "s", "stream", "inner", "image", "err", "inas", "ax", "read", "ssl", "i", "r", "b", "ex", "n", "again", "socket", "nin", "win", "resource", "inn", "is", "data", "lin", "source", "inside", "init", "rin", "con", "ac", "as", "f"]}}
{"id1": "12306305", "id2": "2668634", "code1": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doCopyFile": ["doTransferfile", "doCopyfile", "doCopyFiles", "DoCopfile", "doCopfile", "docopyDirectory", "docopyfile", "DoCopFile", "DoCopDirectory", "docopyFile", "DoCopyDirectory", "doCopFile", "doTransferDirectory", "docopyFiles", "doCopFiles", "DoCopyfile", "doTransferFile", "DoCopyFile", "doCopyDirectory", "DoCopFiles", "DoCopyFiles", "doTransferFiles", "doCopDirectory"], "srcFile": ["destFiles", "instFile", "sourceFiles", " srcfile", "srcPage", "destDir", "srcDir", " srcPage", "destPage", "instPage", "sourcePage", "srcfile", "srcFilename", " srcFiles", "accessPath", "instDir", "destPath", "rcDir", "destfile", "srcPath", "sourcefile", " srcDirectory", "sourceFile", "accessPage", "rcfile", "destFilename", " srcPath", "instfile", "accessFile", "rcFile", "sourceDirectory", " srcFilename", "accessFilename", " srcDir", "rcDirectory", "srcDirectory", "rcPage", "srcFiles", "sourceDir"], "destFile": ["optfile", "destFiles", "optSourceFile", "targetFiles", " DestTime", "flatFile", "flatFilename", " destPage", "DestFiles", "descTitle", " destfile", "destDir", "destFolder", "DestDirectory", "optPath", "descFolder", "Destfile", "srcDir", "descFile", "srcSourceFile", "destSourceFile", "destPage", "targetFile", "sourcePage", "destTitle", "srcfile", " destFolder", "restTime", " DestFile", "DestFile", "destPath", "destTime", "targetfile", " destTitle", "flatFolder", "destfile", " destFiles", " destFilename", " DestDir", " Destfile", "sourceDir", "optFile", "targetPath", " destTime", " destSourceFile", "sourceFile", "descFilename", "targetSourceFile", "DestTime", "destFilename", "flatTitle", "targetDirectory", "DestDir", "sourceDirectory", "homeDir", " destPath", " destDir", "homeFile", "restSourceFile", "restDirectory", "srcDirectory", " destDirectory", "homeFiles", "DestPage", "destDirectory", "srcFiles", "homefile", "srcTime", "restFile"], "preserveFileDate": ["preservedTimeDay", "preserveFilesDay", "preserveFilesTime", "preserveLineDate", "preserveUnitdate", "preserveUnitDate", "preserveDirectoryDay", "preserveFilesSince", "preserveFilesDate", "preservingFileDate", "preserveDirectorydate", "preserveFileSince", "preservedTimedate", "preservingFileSince", "preservingFilesdate", "preservedFileDay", "preservedTimeTime", "preserveDirectoryTime", "preserveLinedate", "preservingFiledate", "preserveTimedate", "preserveFiledate", "preservedFileDate", "preserveTimeDay", "preservingFilesDate", "preserveTimeTime", "preserveFileTime", "preserveFileDay", "preservedFileTime", "preserveFilesdate", "preservingFilesSince", "preservedTimeDate", "preservedFiledate", "preserveTimeDate", "preserveDirectoryDate", "preserveUnitSince", "preserveLineSince"], "input": ["exec", "address", "url", "ip", "error", "reader", "audio", "client", "view", "feed", "io", "current", "child", "Input", "internal", "request", "out", "context", "conn", "stream", "inner", "binary", "image", "upload", "this", "self", "event", "i", "connection", "active", "null", "parent", "config", "socket", "buffer", "api", "form", "copy", "in", "source", "channel", "file", "data", "up", "instance", "open", "temp"], "output": ["external", "flow", "oper", "address", "console", "audio", "ou", "io", "current", "child", "put", "feed", "environment", "Output", "target", "out", "four", "core", "ilo", "queue", "image", "write", "next", "operation", "writer", "connection", "application", "null", "again", "parent", "video", "object", "o", "config", "socket", "outer", "office", "version", "copy", "other", "source", "channel", "file", "download", "unit", "control", "response"]}}
{"id1": "11477906", "id2": "13886238", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["getdefaultParameters", "loadDefaultsettings", "loaddefaultsettings", "loadDefaultParameters", "getDefaultParameters", "loadApplicationsettings", "loadApplicationSettings", "loaddefaultConfiguration", "loadDefaultConfiguration", "loadApplicationParameters", "getdefaultsettings", "loaddefaultParameters", "getDefaultConfiguration", "getDefaultsettings", "loadGlobalParameters", "loadGlobalConfiguration", "loadApplicationConfiguration", "getdefaultConfiguration", "getDefaultSettings", "getdefaultSettings", "loadGlobalSettings", "loaddefaultSettings", "loadGlobalsettings"], "configFileName": ["fileFileTime", "fileFileName", "configFilesTime", "fileFILELocation", "configFullLocation", "configFullName", "configFileUrl", "fileFileLocation", "configModuleUrl", "fileFILEName", "configFilenameName", "ConfigFileUrl", "configFullUrl", "configFILEName", "configFileLocation", "configFilesName", "configPlaceUrl", "ConfigFileName", "configPlaceString", "fileFILETime", "configPlaceLocation", "configFILEType", "ConfigFileLocation", "configModuleName", "configFILETime", "configFilenameType", "configFilenameTime", "configFileTime", "configModuleString", "ConfigModuleString", "configFilesLocation", "configModuleLocation", "configFullString", "ConfigFileString", "ConfigModuleLocation", "configFilenameLocation", "ConfigModuleUrl", "ConfigModuleName", "configFileType", "configFileString", "configFILELocation", "fileFileType", "configFilesType", "fileFILEType", "configPlaceName"], "in": ["url", "base", "ins", "din", "reader", "IN", "login", "bin", "id", "inc", "log", "ini", "input", "In", "conn", "stream", "inner", "err", "this", "read", "m", "ssl", "a", "i", "r", "n", "again", "pull", "config", "socket", "diff", "nin", "resource", "inn", "it", "pin", "plus", "is", "cin", "source", "data", "work", "up", "init", "inside", "pc", "pass", "con", "as", "f"], "out": ["exec", "net", "error", "OUT", "client", "outs", "output", "bin", "view", "ou", "io", "inc", "exp", "one", "log", "default", "name", "conn", "ext", "string", "obj", "able", "to", "image", "err", "prefix", "off", "c", "write", "Out", "set", "lib", "this", " output", "all", "t", "writer", "connection", "user", "ex", "null", "again", "object", "o", "parent", "back", "config", "socket", "sync", " back", "timeout", "version", "it", "point", "copy", "data", "up", "file", "server", "password", "s", "instance", "and", "d", " file", "f"]}}
{"id1": "1508161", "id2": "8047989", "code1": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"conMail": [" sendMail", " submitContact", " submitMail", " submitContent", " submitEmail", " uploadContact", " uploadEmail", " uploadContent", " parseContact", " parseContent", " sendEmail", " uploadMail", " sendContent", " sendContact", " parseMail", " parseEmail"], "mail": ["md", "test", "item", "base", "gmail", "follow", "local", "call", "el", "e", "view", "id", "zip", "load", "proxy", "model", "xml", "request", "log", "mo", "name", "mass", "multi", "pkg", "link", "order", "Mail", "build", "sel", "mand", "m", "event", "element", "ssl", "mails", "class", "html", "user", "object", "body", "del", "update", "message", "post", "service", "key", "content", " email", "l", "data", "match", "file", "letter", "server", "email", "mill", "Email", "ml", "ship", "open", "f", "il"], "client": ["base", "cache", "project", "call", "app", "force", "request", "plugin", "session", "host", "conn", "contact", "driver", "this", "self", "bird", "ssl", "connection", "i", "method", "et", "object", "handler", "Client", "config", "socket", "uri", "service", "api", "resource", "http", "cli", "l", "server", "con", "web", "ce"], "url": ["address", "base", "e", "id", "feed", "URL", "path", "request", "sl", "Url", "host", "string", "name", "ssl", "connection", "method", "route", "www", "config", "ur", "uri", "service", "resource", "key", "http", "href", "l", "data", "file", "server", "channel", "email", "download", "up", "web", "f"], "get": ["exec", "send", "call", "parse", "load", "invoke", "put", "check", "Get", "session", "start", "end", "next", "set", "build", "like", "read", "info", "connection", "show", "g", "body", "find", "query", "pull", "update", "uri", "service", "resource", "GET", "api", "post", "gets", "cli", "server", "req", "create", "json", "open"], "response": ["result", "error", "received", "status", "re", "output", "e", "feed", "Response", "request", "environment", "remote", "res", "success", "respond", "event", "connection", "application", "object", "body", "message", "resource", "api", "wave", "document", "Entity", "page", "data", "resp", "server", "full", "reply", "json", "collection", "onse"], "entity": ["result", "esi", "error", "ity", "el", "e", "output", "model", "xml", "environment", "node", "ee", "image", "event", "element", "connection", "om", "pe", "ent", "et", "application", "object", "body", "message", "resource", "person", "agent", "em", "api", "content", "document", "Entity", "page", "data", "article", "file", "server", "email", "entry", "coll", "instance", "json", "collection", "unit", "comment", "ce"], "doc": ["map", "md", "dec", "exp", "dict", "valid", "db", "xml", "docs", "div", "oc", "struct", "lib", "Doc", "m", "html", "desc", "text", "body", "Document", "message", "uri", "dc", "resource", "content", "document", "dr", "page", "line", "data", "file", "up", "dir", "pos", "d", "coll", "pc", "DOC", "unit", "f", "po"], "msg": ["map", "md", "error", "ms", "mess", "title", "gen", "str", "id", "reg", "db", "xml", "log", "comm", "ge", "urg", "cmd", "pkg", "err", "agg", "code", "m", "reason", "type", "info", "html", "g", "desc", "text", "Msg", "ug", " ms", "loc", "ag", "message", "content", "dr", "data", " desc", "op", "char", "mid", "req", "comment"]}}
{"id1": "16079868", "id2": "5049453", "code1": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private BingResponse queryBing(BingRequest request) throws BingException {\n        try {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Searching through bing...\");\n            }\n            String query = request.getQuery();\n            query = URLEncoder.encode(query, \"UTF-8\");\n            URL url = new URL(\"http://api.bing.net/json.aspx?\" + \"AppId=\" + request.getAppId() + \"&Query=\" + query + \"&Sources=\" + request.getType().toString());\n            URLConnection connection = null;\n            if (useProxy) {\n                if (proxyType == null) {\n                    throw new BingException(\"Please set a proxy first before trying to connect through a proxy\", new Throwable());\n                }\n                connection = ProxyWrapper.getURLConnection(url.toString(), proxyType.toString(), proxyHost, proxyPort);\n            } else {\n                connection = new URL(url.toString()).openConnection();\n            }\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            String response = builder.toString();\n            ResponseParser parser = new ResponseParser();\n            parser.getError(response);\n            return parser.getResults(response);\n        } catch (MalformedURLException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        } catch (IOException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        }\n    }\n", "label": 0, "substitutes": {"readIntoList": ["readIntonMap", "readIntoLog", "readTextoMap", "readInttoList", "readIntoMap", "readTextoList", "readInttoLog", "readTextoLog", "readIntonLog", "readIntonList", "readInttoMap"], "url": ["address", "base", "job", "feed", "io", "URL", "path", "remote", "input", "Url", "host", "location", "string", "name", "sl", "gl", "stream", "image", "link", "org", "ssl", "connection", "user", "object", "rule", "config", "buffer", "uri", "service", "resource", "date", "http", "l", "source", "file", "server", "data", "email", "channel", "rl"], "list": ["map", "test", "result", "client", "cache", "status", "view", "dict", "load", "index", "out", "name", "li", "lists", "obj", "queue", "this", "self", "code", "we", "all", "LIST", "menu", "info", "batch", "show", "user", "object", "parent", "join", "see", "listed", "table", "tree", "array", "detail", "get", "l", "data", "pool", "server", "nav", "member", "coll", "json", "group", "part", "record", "temp"], "in": ["gin", "ins", "reader", "din", "IN", "client", "token", "login", "re", "bin", "io", "inc", "raw", "ini", "input", "er", "out", "In", "inner", "stream", "image", "c", "err", "read", "m", "ssl", "a", "i", "r", "b", "again", "rec", "loader", "nin", "fr", "buffer", "iter", "inn", "min", "h", "is", "l", "data", "lin", "file", "source", "con", "as", "f"], "inputLine": [" inputFile", " inputText", "requestLine", "ifline", "outputString", "requestline", "ifName", "inputString", "InputBlock", "commandFile", "requestText", " inputName", "commandName", "InputText", "InputL", " inputStream", " inputLin", "inputFile", "commandLine", "issueLine", " inputString", "argumentBlock", "inputL", "issueline", "InputString", "InputFile", "commandItem", "issueLin", "outputL", "inputName", "inputStream", "Inputline", "InputName", "inputLin", "commandline", "argumentL", "inputline", "InputItem", "argumentLine", "requestL", "ifLine", " inputL", " inputItem", "ifLin", "InputLine", "inputItem", "outputText", "outputline", " inputline", "outputLine", "inputText", "argumentStream", "commandText", "InputStream", "issueName", "commandBlock", "outputFile", " inputBlock", "inputBlock"], "commandNameBegin": [" commandLineBegin", "commandPathBeginning", "commandLineCreate", " commandNameBeginning", "commandNamebegin", "commandParamBeginning", " commandTimeBegin", "CommandNameEnd", "commandLineBeginning", "commandTimeCreate", " commandLineEnd", "commandTimeBeginning", "commandStringBegin", "commandStringEnd", "CommandNamebegin", "commandLengthCreate", " commandNamebegin", "CommandNameBeginning", "commandNameCreate", "commandPathbegin", "commandLineEnd", "commandLengthBegin", "commandStringbegin", " commandNameCreate", " commandTimeBeginning", "commandParamEnd", " commandLinebegin", "commandTimeEnd", "commandLineBegin", "commandNameBeginning", " commandStringBeginning", "commandTimeBegin", "commandParambegin", "CommandLineBeginning", "commandPathEnd", "commandLengthBeginning", "commandLengthEnd", "commandLinebegin", " commandTimeCreate", "CommandLinebegin", "CommandLineEnd", "commandParamBegin", "CommandNameBegin", " commandStringbegin", "commandTimebegin", " commandStringBegin", "CommandLineBegin", " commandStringEnd", " commandTimeEnd", " commandLineBeginning", "commandPathBegin", "commandStringBeginning"], "commandNameEnd": [" commandLineBegin", "commandLineStart", "commandParamend", "operationParamStart", "commandPathBegin", "commandParamEND", "commandLineend", "commandPathend", " commandNameStart", "commandParamStart", " commandLineEnd", " commandLineStart", " commandNameEND", "commandTimeend", "commandNameend", "operationNameEnd", "commandPathStart", "commandLineEnd", "commandnameend", "commandLineEND", "operationNameend", "commandTimeEND", "operationNameBegin", "commandParamEnd", "commandTimeEnd", "commandLineBegin", "commandTimeBegin", "commandTimeStart", "operationParamBegin", "operationNameStart", " commandTimeEND", "commandPathEnd", "operationParamend", " commandLineend", "commandParamBegin", "commandnameEnd", "commandPathEND", "commandNameEND", "commandnameEND", " commandTimeend", " commandTimeEnd", "commandNameStart", "operationParamEnd", " commandNameend", " commandLineEND"], "item": ["result", "base", "ip", "client", "job", "builder", "el", "site", "app", "or", "xml", "owner", "plugin", "er", "hop", "name", "li", "ui", "response", "obj", "action", "image", "next", "link", "order", "si", "Item", "layer", "extra", "event", "items", "menu", "i", "element", "info", "user", "bar", "object", "parent", "handler", "edit", "update", "iter", "service", "api", "option", "admin", "p", "it", "add", "other", "page", "data", "entry", "up", "server", "article", "channel", "source", "instance", "area", "group", "atom", "part", "json", "manager", "temp"], "e": ["oe", "v", "esi", "error", "exc", " event", "Event", "change", "re", "edge", "force", " pe", "ise", "one", "x", "ea", "es", "er", "te", "u", "ee", "c", "err", "this", "E", "fe", "ze", "or", "event", "t", "a", "ie", "en", "ec", "i", "pe", "ce", "ite", "ception", "o", "handler", "ae", "p", "ve", "l", "me", "ev", "se", "ke", "d", "ne", " ev", "ed", "f", "le"]}}
{"id1": "3046085", "id2": "17974661", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "label": 0, "substitutes": {"s": ["speech", "v", "services", "params", "w", "sample", "str", "e", "south", "sets", "sound", "path", "es", "ns", "string", "name", "ses", "strings", "m", "t", "a", "i", "r", "sb", "g", "b", "n", "text", "S", "parts", "joined", "p", "content", "is", "in", "data", "source", "ss", "f", "gs"], "tokenizer": ["okenator", "widgetiser", "generiser", "tuner", "finizable", "logizable", " tokeniter", "tunner", "statizers", "initialiser", "normalizable", "finer", "loginer", "okeniter", "tooliner", "toolize", "okenzer", "optimizer", "okenization", "tokenization", "Tokenizer", "statiter", "tokenister", "tokenize", "tunizer", "Tokenized", "okenizer", "Tokenener", "tokenizers", " tokenzer", "okeniser", " tokenized", "optimiser", "Tokenizers", "widgetizer", "Tokenister", "okenizable", " tokenener", "tokeniter", "generizer", "okenener", "finize", "tokenener", "okenister", "logize", "normalize", "generized", "tokenator", "Tokenizable", "Tokeniser", " tokenizers", "initialiner", "tokenzer", "normalizer", "statizer", "Tokeniner", "widgetizable", "okeniner", "widgetiner", "Tokener", " tokener", " tokenner", "finizer", "tokenner", "toolizable", "tokeniner", "normaliner", " tokenizable", "optimizable", " tokeniser", "initializable", "okenner", "okenize", "initialize", "logizer", "Tokenize", "initialization", "okenizers", "tokener", "initializer", "tunzer", " tokenization", " tokenator", "okener", "tokenized", "statator", "toolizer", " tokenister", " tokenize", "tokenizable", "tokeniser", "optiminer", "generize"], "title": ["url", "audio", "description", "metadata", "art", "owner", "music", "meta", "filename", "name", "string", "profile", "prefix", "Title", "bot", "company", "editor", "layer", "format", "username", "type", "genre", "text", "tag", "song", "license", "media", "resource", "album", "source", "data", "summary", "theme", "team", "label", "author"], "artist": ["master", "audio", "voice", "alias", "metadata", "art", "episode", "cover", "music", "creator", "target", "patch", "filename", "archive", "winner", "image", "prefix", "chart", "layer", "username", "player", "genre", "video", "tag", "song", "Artist", "media", "album", "track", "source", "piece", " artists", "season", "theme", "photo", "author"], "location": ["address", "position", "url", "level", "audio", "description", "region", "path", "length", "language", "time", "image", "layer", "motion", "tag", "mobile", "loc", "layout", "lang", "message", "media", "album", "content", "Location", "gallery", "area", "photo", "theme"], "rating": ["score", "playing", "audio", "description", "resolution", "fps", "repeat", "ranking", "scoring", "training", "sharing", "rate", "boarding", "live", "genre", "weight", "padding", "game", "breaking", "alpha", "media", "album", "rank", "style", "rising", "random", "season", "tracking"], "overplay": ["offload", "overlay", "offledge", "oplay", "offplay", "reload", "opplay", "overload", "offlay", "replay", "reledge", "opledge", "opload", "relay", "overledge"], "temp": ["template", "test", "emp", " temporary", "base", "cache", " tmp", "str", "tmp", "current", "partial", "path", "font", "music", "tc", "pt", "flat", "string", "name", "sequence", "original", "prefix", "testing", "format", "type", "tag", "body", "empty", "stable", "loc", "list", "layout", "message", "media", "content", "track", "txt", "data", "source", "style", "stage", "Temp", "part", "unit", "fake"], "tags": ["relations", "types", "packages", "assets", "archives", "ids", "authors", "reports", "videos", "users", "stats", "styles", "sections", "resources", "files", "terms", "comments", "strings", "modules", "words", "properties", "stars", "Tags", "images", "plugins", "bots", "events", "dates", "bugs", "fields", "phones", "thumbnails", "tracks", "products", "names", "notes", "tests", "features"], "bytes": ["objects", "params", "outs", "Bytes", "seconds", "letters", "videos", "es", "values", "lines", "tes", "files", "notes", "bps", "comments", "strings", "words", "errors", "body", "bits", "pieces", "parts", "blocks", "articles", "les", "gets", "ips", "fee", "pages", "data", "units", "keys", "balls", "size", "codes"], "hasher": ["hanher", " hashers", "Hashed", "hanest", "hashest", "hadhandler", "hashers", "hahers", "haher", "havehandler", " haser", "haer", "hadher", "Haser", "haser", "Hasher", "hashr", "haveer", "Hasest", "hanhr", " hashed", "hahed", "hashed", "haner", "hasumper", "haest", "hashhandler", "hadest", " hashr", "haveumper", "hashandler", " hasest", "haveher", "hadumper", "hasest", "havehr", "hashher", "hashumper", "Hashers", "haveest"]}}
{"id1": "9275622", "id2": "2642914", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferfile", "copyFolder", "movefile", " copyFolder", "moveFolder", "transferFolder", "transferFiles", "moveFiles", " copyfile", "moveFile", "transferFile", "copyfile", " copyFiles"], "_file1": ["_fileone", "_files01", "_files2", "_zipOne", "_zipFirst", "_File0", "_mail1", "_mail01", "_fileFirst", "_resourceOne", "_resourceone", "_fFirst", "_files0", "_fOne", "_fone", "_files1", "_File2", "_zipone", "_f1", "_mail2", "_File1", "_file01", "_mail0", "_resource1", "_File01", "_file0", "_resourceFirst", "_fileOne", "_zip1"], "_file2": [" _files4", "_play4", "_Filesecond", " _fileTwo", "_files2", "_playsecond", "_files4", "_file3", "_files3", "jmodel2", "_modelsecond", "_file5", "_play3", " _file4", "_play5", " _file3", " _filesTwo", "jfile5", "_File5", "jfile1", "jmodelsecond", " _files3", "_play1", " _files2", "_model2", "_File2", "_play2", "_fileTwo", "_File1", "_filesTwo", "_file4", "jfilesecond", "_model1", "_filesecond", "jmodel1", "jmodel5", "_playTwo", "_model5", "jfile2"], "fis": [" fiss", "fais", "cfis", "fris", "cfas", " fais", "lfais", "infis", "lfi", " fi", "Fris", "infiss", " fas", "Fos", "infils", "fils", "Fis", "fas", " fils", "afis", "cfiss", "afi", "lfis", "Fiss", "Fils", "lfiss", "Fas", "fiss", "afiss", "fi", "cfos", "cfris", "afais", "infos", " fris"], "fos": ["foes", "Fo", "feus", "infus", "gus", "fus", "gos", "infios", "Fros", "flis", "poes", "fOS", "feis", "Foos", "feos", " foos", "Fus", "Foses", " faos", "feoses", "Fos", "Fis", "fros", " fo", "infoos", "fios", "pis", "lOS", "info", "Fios", "infaos", "flOS", "floes", "lis", " fus", " fios", "infos", "goses", "los", "loes", "fo", "pOS", "infros", "gis", "flos", "foses", "pos", " fros", "faos", "Faos", "foos"], "canalFuente": ["canalFUente", "canaledFuze", "canalFuento", "canallBuence", "canallFuencia", "canalsBuencia", "canalFuze", "canaledBuze", "canaledBuente", "canallFuze", "canalSuestro", "canalFuence", "canalBuence", "canalFUze", "canalKuente", "canalKuento", "canalsBuence", "canalFUencia", "canalFuestro", "canallBuencia", "canalsBuento", "canalKuence", "canaledFuje", "canalFUestro", "canalCraencia", "canalBuze", "canaledFuestro", "canallFuence", "canalSuze", "canalsFuence", "canalFUje", "canaledFuente", "canalsFuencia", "canalBuje", "canalCraente", "canalBuento", "canalSuje", "canalsFuente", "canalBuente", "canalsFuento", "canaledBuje", "canalFuencia", "canalCraence", "canalKuencia", "canalCraento", "canallBuze", "canalKuze", "canallBuente", "canalBuestro", "canaledBuestro", "canalBuencia", "canallFuente", "canalFUence", "canalFuje", "canalSuente", "canalsBuente"]}}
{"id1": "10131427", "id2": "8747840", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferfile", " copyChannel", "CopyFile", "CopyChannel", "CopyFiles", "transferFiles", "transferChannel", " copyfile", "Copyfile", "transferFile", "copyfile", "copyChannel", " copyFiles"], "in": ["url", "base", "ins", "reader", "IN", "login", "bin", "id", "io", "inc", "ini", "index", "input", "In", "name", "inner", "image", "c", "m", "or", "at", "a", "i", "b", "ex", "again", "config", "diff", "buffer", "inn", "resource", "min", "copy", "data", "work", "file", "source", "ac"], "out": ["exec", "external", "v", "base", "OUT", "client", "outs", "cache", "w", "output", "io", "x", "target", "name", "conn", "string", "image", "c", "prefix", "off", "Out", "at", "writer", "connection", "ex", "n", "object", "o", "dest", "buffer", "p", "copy", "point", "source", "data", "file", "part", "temp"], "sourceChannel": ["srcConnection", "SourceStream", "sourceSocket", "srcStream", " sourcechannel", "targetchannel", "sourceStream", "ourceStream", "ourcechannel", "sourceManager", " sourceStream", "sourceChan", "srcSocket", "SourceQueue", "SourceSocket", "ourceChan", "Sourcechannel", " sourceQueue", " sourceSocket", "srcChan", "SourceManager", "sourceQueue", "srcManager", "targetStream", "targetChannel", "srcQueue", " sourceChan", "SourceChannel", " sourceConnection", "SourceConnection", "ourceChannel", "srcChannel", "SourceChan", " sourceManager", "sourcechannel", "targetChan", "sourceConnection"], "destinationChannel": ["destationChan", "destationchannel", "destinatedChan", "destinatorChan", "destinationsConnection", "destinationStream", "DestinatorConnection", "destationCh", "destationChannel", "destinationschannel", "destinatorchannel", "destinatedCh", "Destinationchannel", "DestinatorChan", "destinationChan", "destinatedChannel", "Destinatorchannel", "DestinationStream", "DestinationCh", "destationConnection", "destinateStream", "destinatedConnection", "destinatorChannel", "DestinatorStream", "DestinatorCh", "destinatechannel", "destinationchannel", "destinationsStream", "DestinationChan", "DestinationConnection", "destinatorStream", "destinatorCh", "destinationsChannel", "destinateConnection", "destinatorConnection", "DestinatorChannel", "DestinationChannel", "destinationConnection", "destinateChannel", "destinationCh"]}}
{"id1": "21033686", "id2": "1235538", "code1": "    public File read() throws IOException {\n        URLConnection conn = url.openConnection();\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n        conn.connect();\n        int length = conn.getContentLength();\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        if (tempDir == null) {\n            tempDir = \".\";\n        }\n        File tempFile = new File(tempDir + \"/\" + new GUID() + \".dat\");\n        tempFile.deleteOnExit();\n        InputStream in = null;\n        OutputStream out = null;\n        ProgressMonitor monitor = new ProgressMonitor(parentComponent, \"Downloading \" + url, null, 0, length);\n        try {\n            in = conn.getInputStream();\n            out = new BufferedOutputStream(new FileOutputStream(tempFile));\n            int buflen = 1024 * 30;\n            int bytesRead = 0;\n            byte[] buf = new byte[buflen];\n            ;\n            long start = System.currentTimeMillis();\n            for (int nRead = in.read(buf); nRead != -1; nRead = in.read(buf)) {\n                if (monitor.isCanceled()) {\n                    return null;\n                }\n                bytesRead += nRead;\n                out.write(buf, 0, nRead);\n                monitor.setProgress(bytesRead);\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n            monitor.close();\n        }\n        return tempFile;\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 0, "substitutes": {"read": ["exec", "url", "reader", "send", "parse", "transfer", "feed", "load", "put", "check", "request", "readable", "skip", "reading", "input", "connect", "end", "stream", "write", "next", "upload", "wait", "find", "Read", "pull", "READ", "update", "buffer", "iter", "close", "add", "get", "copy", "search", "http", "continue", "data", "process", "init", "download", "create", "reads", "open", "select", "run"], "conn": ["exec", "cm", "url", "cf", "mc", "ai", "ca", "client", "stat", "ann", "login", "cb", "not", "comm", "connect", "sql", "conv", "cp", "cmd", "c", "ci", "err", "rt", "ct", "ssl", "en", "connection", "Connection", "n", "cdn", "config", "enc", "socket", "nt", "sync", "co", "loc", "dc", "open", "p", "http", "cli", "channel", "ch", "cn", "init", "coll", "fail", "con", "nc", "Conn", "oa", "ctx", "connected", "cmp"], "length": ["position", "url", "zip", "load", "path", "total", "distance", "time", "range", "angle", "lock", "len", "duration", "Length", "info", "count", "block", "depth", "delay", "l", "limit", "size"], "tempDir": ["poraryFolder", "tempDist", "TempDirectory", " tempDist", "poraryDir", "tmpDir", "tmpDist", " tempDirectory", "tmpPath", "TempPath", " tempdir", "TempFile", " tempPath", "tmpFolder", "TempDir", "tempFolder", "tmpFile", "tmpDirectory", "tempdir", "Tempdir", " tempFolder", "tempDirectory", "TempFolder", "poraryDist", "poraryDirectory", "tempPath", "tmpdir"], "tempFile": ["poraryfile", " tempSourceFile", "poraryDir", "tmpDir", " tempDirectory", "tmpPath", "tempPlace", "tmpSourceFile", " tempPath", " tempPlace", " temporaryfile", "tempUrl", "tmpFile", "tmpPlace", "tmpDirectory", " temporaryFile", "poraryPath", " tempUrl", "tempDirectory", " temporaryPlace", "poraryFile", "poraryUrl", " temporaryDir", "poraryDirectory", "porarySourceFile", "tempfile", "tmpUrl", "tmpfile", "tempPath", "tempSourceFile", " tempfile"], "in": ["url", "gin", "ins", "reader", "din", "IN", "client", "login", "re", "bin", "id", "inc", "ini", "input", "In", "s", "inner", "on", "image", "c", "err", "this", "oin", "like", "m", "or", "en", "a", "i", "r", "ie", "info", "b", "n", "again", "rec", "pull", "socket", "diff", "nin", "win", "inn", "pin", "l", "data", "source", "lin", "file", "init", "kin", "cin", "cli", "work", "con", "impl", "serv"], "out": ["net", "exec", "external", "url", "error", "OUT", "client", "outs", "cache", "w", "login", "output", "bin", "io", "log", "ext", "name", "inner", "cmd", "image", "write", "err", "off", "prefix", "lock", "Out", "or", "writer", "connection", "i", "ex", "again", "null", "o", "n", "parent", "co", "socket", "sync", "outer", "post", "timeout", "min", "key", "plus", "copy", "line", "data", "source", "file", "up", "unit", "part", "Output", "temp"], "monitor": ["cm", "processor", "master", "client", "mor", "reader", "own", "pm", "pre", "reg", "port", "container", "log", "session", "state", "param", "inner", "lock", "trace", "mon", "m", "reason", "management", "writer", "info", "report", "counter", "duration", "method", "number", "watch", "parent", "program", "connection", "handler", "config", "update", "timeout", "wrapper", "pin", "condition", "meter", "rain", "pool", "clock", "member", "summary", "timer", "unit", "control", "manager", "Monitor"], "buflen": ["BuFLent", " bulleng", "bullent", " buflock", "bullock", "buclan", "buFleng", "BuFLan", "buFLeng", "buFLen", "buFLong", "buclent", "buFLent", "BuFLen", "bullong", "buFLock", "buFLength", "buflent", " bufleng", "buFlong", " bullen", "Buflength", "buflength", " buflong", "buFlock", "buclen", "bullength", "buFLan", "bulleng", "buclength", "bullen", "bufleng", " bullong", "buflock", "Buflent", "Buflan", "buflan", "bullan", "buflong", " bullock", "buFlen", "Buflen", "BuFLength"], "bytesRead": ["tesread", "nsWrite", " bytesread", "nsLength", "Bytesread", "nsread", "BytesFound", "tesWrite", "bytesFound", "tesFound", " bytesWrite", "bytesLength", " bytesLength", "bytesWrite", "BytesWrite", "BytesRead", "tesRead", "nsRead", " bytesFound", "bytesread", "BytesLength"], "buf": ["Buffer", "uf", "bc", "vec", "cap", "v", "header", "base", "result", "uc", "exc", "cf", "cache", "bin", "tmp", "comb", "cv", "br", "cur", "func", "ctx", "fb", "seq", "cmd", "queue", "pkg", "off", "bag", "box", "batch", "auc", "b", "ha", "ff", "loc", "block", "wb", "buffer", "la", "bytes", "rb", "cas", "ucc", "fd", "rc", "data", "bh", "ref", "coord", "src", "home", "cb", "buff", "bu"], "start": ["base", "st", "error", "art", " Start", "progress", "end", "state", "time", "offset", "max", "set", "step", "en", "count", "stop", "Start", "scale", "min", "stack", "from", "data", "last", "source", "since", "init", "pos", "size"], "nRead": [" nReader", "nnWrite", "mWrite", "nBuild", "cRead", "ninReading", " nBuild", "unnWrite", "oRead", "nnReader", "nnRead", "pnWrite", "mReading", "unnReading", "jRead", "unnReader", " nReading", "pnReader", "ninReader", "cWrite", "mRead", "iRead", "nAdd", "nReader", "ninRead", "unnRead", "nReading", "jWrite", "ninWrite", "cBuild", "iBuild", "oReader", "oWrite", "pnRead", "iWrite", "pnReading", "jReader", "cReader", "oAdd", " nWrite", " nAdd", "jReading", "cReading", "mReader", "nWrite", "nnAdd", "iReader"]}}
{"id1": "293167", "id2": "5951961", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersionUpdate", " doVersionUpdate", " doversionCheck", "doversionScan", "doversionCheck", "doChangeCheck", "doChangecheck", " doversioncheck", "doChangeUpdate", "doversioncheck", "doVersioncheck", "doFeaturecheck", " doVersionScan", " doversionUpdate", "doversionUpdate", "doFeatureScan", "doVersionScan", "doFeatureCheck", " doversionScan", "doChangeScan", "doFeatureUpdate", " doVersioncheck"], "view": ["v", "cache", "vol", "window", "e", "port", "model", "div", "row", "session", "link", "sel", "box", "show", "query", "display", "form", "server", "fail", "value", "full", "group", "gu", "client", "use", "VIEW", "check", "input", "View", "lock", "event", "user", "object", "video", "block", "views", "vis", "by", "http", "page", "review", "pool", "comment", "can", "cell", "im", "base", "change", "el", "ou", "container", "screen", "body", "head", "config", "list", "index", "out", "ui", "image", "this", "widget", "self", "html", "see", "edit", "layout", "update", "ve", "up", "style", "manager"], "url": ["address", "base", "builder", "rel", "bb", "ob", "id", "zip", "URL", "path", "log", "sl", "Url", "host", "location", "string", "name", "ls", "gl", "stream", "bug", "length", "image", "hub", "link", "ssl", "b", "browser", "null", "ll", "www", "loc", "socket", "loader", "fr", "buffer", "uri", "ul", "resource", "http", "l", "source", "file", "server", "download", "email", "impl", "open", "web", "blog", "f"], "in": ["ins", "reader", "din", "IN", "login", "isin", "inc", "bis", "ini", "input", "out", "In", "binary", "s", "inner", "stream", "err", "doc", "m", "b", "again", "sin", "socket", "nin", "win", "buffer", "resource", "inn", "pin", "is", "cin", "lin", "data", "file", "source", "init", "rin", "con", "ac", "as"], "bin": ["bn", "gin", "reader", "din", "IN", "login", "bb", "nb", "vin", "spin", "ini", "input", "border", "out", "binary", "fin", "inner", "lock", "bot", "ruby", "lib", "oin", "ban", "b", "browser", "body", "sin", "socket", "loader", "win", "buffer", "inn", "pin", "abi", "arin", "cin", "lin", "is", "file", "init", "con", "record", "bi", "run"], "line": ["lc", "cl", "base", "ip", "job", "str", "parse", "el", "e", "id", "zip", "one", "log", "le", "val", "ge", "row", "nl", "sl", "string", "name", "end", "Line", "out", "lines", "range", "word", "write", "link", "code", "LINE", "look", "type", "pe", "definition", "b", "user", "text", "object", "block", "pin", "key", "jo", "lf", "lin", "data", "file", "page", "l", "entry", "inline", "up", "letter", "unit", "ine", "part", "comment", "cell"], "version": ["feature", "position", "v", "ver", "project", "beta", "id", "cover", "model", "plugin", "python", "patch", "host", "string", "name", "bug", "driver", "section", "image", "code", "format", "vision", "type", "release", "user", "Version", "null", "video", "latest", "pull", "install", "update", "support", "license", "date", "option", "vert", "versions", "server", "download", "VERSION", "secret", "device", "value", "dev", "unit", "author"], "build": ["uild", "ver", "job", "builder", "rel", "follow", "clean", "use", "feed", "load", "valid", "log", "boot", "make", "row", "patch", "hold", "Build", "bug", "lock", "image", "link", "lease", "info", "print", "release", "show", "tag", "built", "pull", "block", "install", "building", "update", "post", "mount", "how", "add", "get", "http", "work", "style", "help", "home", "unit", "run"]}}
{"id1": "21754659", "id2": "16549995", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"getButtonSonido": ["getbuttonSenendo", "getbuttonSonira", "getbuttonSenico", "getButtonJonico", "getButtonSonira", "getbuttonSenira", "getbuttonSonico", "getbuttonSonendo", "getButtonJonira", "getButtonJonido", "getButtonSenido", "getButtonSonendo", "getButtonSonico", "getButtonSenico", "getButtonSenendo", "getbuttonSenido", "getButtonSenira", "getButtonJonendo", "getbuttonSonido"], "buttonSonido": ["buttonSonigo", "buttonSonida", "btnDonido", "buttonHomardo", "btnSonini", "ButtonSonida", "buttonHomado", " buttonSenado", "btnSonardo", "btnDonigo", " buttonSonida", "ButtonSonini", "btnDonardo", "buttonDonado", "buttonDonino", "btnSonado", "buttonDonardo", "buttonsonardo", "buttonSonini", "buttonSenido", "buttonTanido", "buttonsonado", "buttonSenini", "ButtonSonado", "ButtonSonardo", "buttonSenado", "buttonDonido", "buttonSenida", "buttonsonini", "ButtonDonida", "buttonHonido", " buttonSonado", "buttonHonardo", "buttonHonino", " buttonSenida", "buttonHomida", "buttonTanado", "buttonSenino", "buttonDonini", "buttonHomido", "ButtonSonido", "btnSonigo", " buttonSonardo", " buttonSenardo", "buttonSonino", "buttonSonardo", "ButtonDonido", "buttonDonida", "btnSonido", "buttonDonigo", "buttonSenardo", "buttonTanardo", "ButtonDonini", "buttonSonado", "buttonsonido", "buttonsonigo", " buttonSenido", " buttonSonino", "buttonSenigo", " buttonSenino", "buttonHonado", "btnDonado", "ButtonDonado", "buttonTanida", "ButtonDonardo"], "e": ["Event", " ignored", " caught", " invoked", " pe", " ie", " exp", " exception", "ee", "E", " E", " je", " te", " other", "event", "t", " en", " cause", " ate", " ace", " exc", " fe", " events", " Event", " ev", " inst", "ed"], "fc": ["WF", "wt", "bc", "fp", "lc", "cf", "xf", "mc", "wk", "DC", "Factory", "roc", "fb", "fl", "PF", "tc", "FS", "fm", "c", "CF", "FE", "fe", "fa", "wic", "GF", "ec", "ct", "fx", "irc", "F", "enc", "isc", "flo", "fr", "fs", "dc", "fed", "fi", "fd", "af", "lf", "FC", "fn", "fw", " FC", "LC", "bf", "WC", "pc", "nc", "con", "xc", "f", "il"], "returnVal": ["ReturnVAL", "ReturnValue", "returnVAL", " returnNum", "backVal", "continueNum", "backval", " returnVAL", " returnval", "returnval", " returnValue", "continueVal", "backValue", "returnNum", "ReturnVal", "backVAL", "returnValue", "ReturnNum", "continueValue", "continueval", "Returnval"], "file": ["fp", "url", "cf", "FILE", "base", "local", "use", "php", "zip", "io", "feed", "db", "path", "folder", "log", "function", "input", "filename", "name", "out", "binary", "to", "image", "lock", "ile", "files", "fe", "lib", "File", "type", "global", "info", "connection", "user", "b", "class", "directory", "object", "handler", "per", "socket", "message", "uri", "resource", "get", "document", "single", "http", "l", "page", "data", "up", "dir", "source", "full", "part", "sf", "f"], "rutaGlobal": [" rutaGeneral", "srutaGlobal", "rettaReal", " rutoInternational", "rutiLocal", "rutiGlobal", "rutoCore", "srutaCore", "rottaCore", "srutaGeneral", "srottaCore", "rutoGeneral", "rutaCore", "rutoLocal", " rutaInternational", " rutoGlobal", "srettaReal", "srutaLocal", "srottaLocal", "srottaGeneral", "rutaLocal", "rottaGeneral", "srutaReal", "rundaGlobal", " rutoGeneral", "rugaInternational", "rutaGeneral", "rottaGlobal", "rutiGeneral", "rucaGlobal", "rundaGeneral", "rutoInternational", "srutaInternational", "rettaLocal", "rutaInternational", "rundaInternational", "rucaInternational", "rugaLocal", "srettaInternational", "rutiInternational", "rottaLocal", "rutaReal", "rutiCore", "srettaLocal", "rucaGeneral", "rutiReal", "rutoGlobal", "rettaInternational", "rugaReal", "rugaGlobal", "srottaGlobal", "rettaGlobal", "srettaGlobal"], "rutaRelativa": ["rutaRelattivo", "rutaMalarivism", "rutaRelativo", "rutaRelATivas", "rutaRelattivas", "rutaRelarivo", "rutaRelariv", "rutaMalativism", "rutaRelarivas", "rutaRelariva", "rutaMalativo", "rutaRelattivism", "rutaRelativism", "rutaRelattiva", "rutaRelateiva", "rutaRelATiva", "rutaMalariva", "rutaRelateivo", "rutaRelarativo", "rutaRelateivism", "rutaMalativas", "rutaRelarativas", "rutaMalarivo", "rutaRelateiv", "rutaRelativ", "rutaRelarativa", "rutaRelATiv", "rutaRelarivism", "rutaRelativas", "rutaMalarivas", "rutaRelattiv", "rutaRelATivo", "rutaRelarativism", "rutaMalativa", "rutaRelarativ"], "fis": [" fiss", "fris", "xiss", " fys", "frir", " fIs", "viss", "xis", "fys", "FIs", "Fris", "vIs", "Fos", "fir", "fIs", "Fis", "fros", "xris", "Fir", " fir", "Fiss", "friss", "vos", "vis", "fiss", "xys", " fris", "Fys"], "fos": ["fileops", "Fo", "fileos", "FOS", "infios", "fOS", "Fops", "infis", " fOS", "fileocks", "tfo", "Fos", "tfOS", "Fis", " fo", "infOS", "fios", " fops", "tfos", "Fios", " focks", "fileo", " fios", "fo", "focks", "fops", "Focks", "infos", "tfops"], "canalFuente": ["canalFUante", "canalFUente", "canalFient", "canalMuente", "canulFuence", "canulFient", "canallBuence", "canalFUent", "canalsBuante", "canalMuence", "canalKuenza", "canallFuenza", "canalJuento", "canalFuent", "canalsFuante", "canulFuente", "canalFuence", "canalBuence", "canalfuenza", "canalMuencer", "canalKuente", "canulFiencer", "canalFiencer", "canalsBuent", "canallBugent", "canalsBuento", "canulFience", "canalKuence", "canalBuent", "canulFuent", "canalFUento", "canulFuencer", "canalJuente", "canalFuencer", "canalFugent", "canallFuence", "canalBugent", "canalfuence", "canalFuante", "canalsFuent", "canallFugent", "canalBuento", "canalsBuente", "canalsFuente", "canalBuente", "canalsFuento", "canalFience", "canalKugent", "canalfugent", "canallBuenza", "canalFuenza", "canalFiente", "canulFiente", "canalJuence", "canalJuante", "canalBuante", "canallBuente", "canalJuent", "canalMuent", "canallFuente", "canalBuenza", "canalfuente", "canalFuento", "canalJuencer"], "canalDestino": ["canelCampania", "canalDestinos", "canaldestino", "canallDestino", "canelCampination", "canalCampania", "canaldestinos", "canalCampination", "canaldestina", "canelDestania", "canalCampina", "canalNegania", "canallDestina", "canalDestina", "canalldestino", "canalNegino", "canallDestinos", "canelDestino", "canalldestina", "canalCampino", "canalNegination", "canalNegina", "canelDestina", "canalldestinos", "canelCampina", "canaldestania", "canalDestania", "canalCampinos", "canalDestination", "canelCampino", "canelDestination", "canalldestania", "canallDestania", "canaldestination"]}}
{"id1": "11556231", "id2": "12766394", "code1": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 0, "substitutes": {"ByURL": ["CreateURL", "ByURI", "BySSL", "CreateUrl", "CreateSSL", "createURL", "byURL", "createURI", "byUrl", "byURI", "bySSL", "CreateURI", "createSSL", "ByUrl", "createUrl"], "urlstr": ["URLStr", "httpStr", "urlStr", "UrlStr", "URLname", "urlSTR", "httpstring", "Urlstr", "UrlSTR", "URLstring", "urlname", "Urlname", "Urlstring", "URLstr", "httpSTR", "urlstring", " urlname", "httpstr", " urlSTR", "URLSTR", " urlstring"], "uri": ["qi", "address", "base", "description", "absolute", "id", "io", "URL", "iri", "path", "Url", "filename", "location", "string", "ui", "host", " URI", "domain", "image", "prefix", "database", "username", "type", "i", "route", "directory", "text", "direction", "query", "ri", "attribute", "resource", "URI", "http", "href", "server", "file", "collection", "manager", "pi"], "url": ["address", "base", "client", "system", "id", "feed", "URL", "proxy", "path", "sl", "Url", "session", "location", "conn", "string", "li", "host", "stream", "image", "link", "ssl", "user", "loc", "loader", "service", "resource", "http", "l", "page", "channel", "file", "server", "download", "web", "f"], "connection": ["client", "system", "connected", "io", "URL", "connect", "conn", "context", "stream", "c", "database", "or", "writer", "i", "Connection", "application", "directory", "body", "handler", "socket", "resource", "http", "l", "channel", "server", "director", "con", "collection", "open", "control", "response", "relation"], "in": ["ins", "client", "IN", "login", "bin", "inc", "ini", "input", "connect", "out", "In", "s", "conn", "stream", "inner", "cms", "c", "or", "a", "i", "r", "writer", "socket", "inn", "lin", "init", "kin", "and", "con", "ac", "as", "f"], "reader": ["result", "ais", "client", "io", "ini", "row", "input", "er", "ler", "out", "conn", "stream", "inner", "read", "Reader", "or", "writer", "i", "r", "handler", "loader", "buffer", "iter", "resource", "parser", "wrapper", "rc", "server", "channel", "entry", "reading"], "is": ["im", "serv", "ais", "ins", "ai", "sr", "iso", "has", "isa", "io", "was", "iri", "IS", "bis", "Is", "conn", "out", "s", "ui", "ris", "cms", "ci", "err", "isl", "si", "iss", "ios", "os", "nis", "or", "i", "info", "lis", "isi", "ri", "fs", "iris", "src", "rss", "sp", "as", "rs", "mis"], "document": ["result", "output", "xml", "docs", "node", "doc", "database", "m", "element", "writer", "class", "application", " documents", "object", "parent", "root", " documentation", "config", "graph", "Document", "message", "ocument", "resource", "content", "collection", "Documents", "response"], "source": ["container", "input", "node", "context", "string", "language", "stream", "driver", "Source", "element", "info", "class", "object", "text", "parent", "parser", "service", "resource", "content", "file", "src", "instance", "unit", "SOURCE"], "name": ["base", "description", "id", "Name", "node", "filename", "location", "string", "word", "named", "domain", "prefix", "format", "type", "element", "info", "definition", "root", "object", "NAME", "text", "parent", "tag", "attribute", "property", "resource", "URI", "key", "file", "instance", "value", "names", "comment"], "namespaceURI": ["namesferenceuri", "namespaceNS", "NamespaceURI", "namesheetURI", "namesferenceMI", "namespacedGI", "NamespaceMI", "namesistenceFINE", "nameservinguri", "namespacedNS", "namespaceGI", "Namespacesuri", "NamespacesMI", "namesheeturi", "namesistenceuri", "namespacesFINE", "namespacesURI", "namespacesMI", "namespaceFINE", "namesistenceURI", "namespacedURI", "perspacedGI", "Namespaceuri", "namespaceuri", "perspaceuri", "namesferenceURI", "namespaceduri", "NamespacesURI", "namespaceMI", "namesheetGI", "NamespaceNS", "nameservingNS", "NamespacesFINE", "NamespaceFINE", "namespacesuri", "perspacedURI", "perspaceURI", "perspaceGI", "namesferenceFINE", "perspaceduri", "nameservingURI", "namesistenceMI"], "qualifiedName": ["qualifiedURI", " qualifiedPath", "qualifiedType", "localname", "qualname", "localPath", "qualifiedname", "qualURI", "fixedPath", "fixedName", "fixedname", "qualifiedPath", "simplename", "qualName", " qualifiedURI", " qualifiedType", " qualifiedname", "simpleURI", "simplePath", "localType", "simpleName", "qualPath", "fixedType"], "data": ["template", "base", "ata", "description", "str", "output", "id", "child", "model", "DATA", "xml", "default", "input", "node", "string", "context", "language", "stream", "doc", "comments", "format", "element", "type", "info", "def", "class", "definition", "number", "text", "object", "body", "parent", "config", "message", "buffer", "resource", "property", "media", "content", "value", "script", "NAME"], "tagName": [" tagClass", "localClass", "tagClass", "localname", "TagName", "Tagname", "TagClass"], "target": ["template", "address", "base", "prop", "path", "label", "host", "location", "node", "domain", "next", "format", "Target", "component", "info", "method", "root", "class", "object", "parent", "head", "resource", "property", "href", "instance", "uid", "NAME"], "elementId": [" elementID", "nodeId", "nodeid", "elementid", " elementTag", "elementID", " elementid", "objectTag", "elementTag", "objectid", "nodeTag", "objectId", "objectID", "nodeID"], "tagname": ["className", " tagNAME", "classNAME", "tagNAME", "TagName", "Tagname", "classname", "TagNAME"], "localName": ["qualifiedNAME", " localNAME", "qualifiedname", "clientName", "clientname", "localname", "localNAME", " localname", "clientNAME"]}}
{"id1": "21316706", "id2": "19687456", "code1": "    @Override\n    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        if ((url == null) || (proxy == null)) {\n            throw new IllegalArgumentException(Messages.getString(\"luni.1B\"));\n        }\n        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 0, "substitutes": {"openConnection": [" openConnect", "openconnection", " openconnection", "initConnection", "initconnection", "createConnector", "initConnect", "openConnect", "createconnection", "createConnection", "openConnector", "initConnector", "createConnect", " openConnector"], "url": ["address", "base", "client", "str", "ob", "port", "io", "URL", "db", "path", "log", "default", "sl", "Url", "host", "string", "name", "ls", "image", "link", "or", "layer", "ssl", "connection", "user", "library", "null", "object", "socket", "loader", "uri", "service", "lr", "resource", "http", "l", "page", "source", "file", "server", "channel", "email", "ref", "web", "f"], "proxy": ["address", "base", "ip", "pa", "client", "cache", "project", "pse", "port", "zip", "io", "child", "host", "pointer", "roxy", "friend", "Proxy", "lib", "ssl", "connection", "pe", "library", "object", "parent", "config", "socket", "uri", "service", "resource", "p", "http", "page", "source", "pool", "server", "fax", "instance", " proxies", "web", "clone", "manager"]}}
{"id1": "20091126", "id2": "4599372", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"copy": ["exec", "call", "output", "transfer", "zip", "io", "Copy", "proxy", "put", "cp", "archive", "write", "upload", "Cop", "type", "cop", "join", "over", "p", "source", "process", "up", "file", "download", "cat", "open", "paste", "cmp"], "in": ["url", "base", "ins", "reader", "IN", "login", "bin", "id", "inc", "old", "index", "input", "ic", "In", "name", "inner", "image", "m", "or", "a", "i", "connection", "b", "again", "config", "query", "diff", "buffer", "min", "l", "data", "work", "file", "source", "lin", "ac", "part", "f"], "out": ["exec", "external", "v", "url", "result", "base", "OUT", "outs", "cache", "call", "output", "exp", "io", "x", "default", "target", "dot", "ext", "string", "name", "image", "write", "prefix", "off", "err", "c", "Out", "plain", "a", "i", "ex", "again", "parent", "object", "o", "buffer", "array", "p", "content", "point", "page", "data", "source", "file", "server", "channel", "value", "comment", "temp"], "inChannel": ["inClient", " inButton", "inputChan", " inchannel", "insChannel", "inChan", " inClient", "iniStream", "inputGate", "outChan", "winStream", "INClient", "inchannel", "outchannel", "outStream", "iniChan", "outButton", "inputStream", "inputchannel", "winchannel", " inStream", "INChan", "inGate", "INchannel", "winChannel", "inStream", "INChannel", " inChan", "INGate", "winChan", "iniChannel", "INStream", "insStream", "iniGate", "insClient", "inputButton", "inButton", "inputChannel", "INButton", "insChan"], "outChannel": ["inClient", "outClient", "outsChan", "outputStream", "Outchannel", "outputChan", "outContext", " outConnection", "outsChannel", "inChan", " outChan", "OutStream", "outputClient", "outputchannel", " outContext", "outChan", "inchannel", "outchannel", "outputChannel", "outStream", "OutClient", "outConnection", "outsConnection", "inStream", "outsStream", " outStream", "OutContext", "inConnection", " outchannel", "OutChan", "OutChannel", "inContext"]}}
{"id1": "3330944", "id2": "21979717", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"extractImage": ["extressLayer", "extractFile", "compressImage", "extrateLayer", "compressText", "extressFile", "extractText", "compractImage", "extvertLayer", "extvertText", "extressImage", "extvertFile", "extrateText", "extrateImage", "compressLayer", "compractFile", "compressFile", "extractLayer", "compractLayer", "extressText", "extrateFile", "extvertImage", "compractText"], "input": ["picture", "PUT", "url", "address", "base", "img", "OUT", "audio", "IN", "reader", "amp", "bin", "tmp", "RAW", "id", "current", "view", "API", "raw", "command", "DATA", "Input", "path", "request", "xml", "include", "inc", "ini", "temp", "string", "out", "In", "inner", "image", "prefix", "type", "i", "null", "text", "parent", "empty", "sin", "config", "pull", "standard", "media", "dc", "inf", "form", "rc", "source", "work", "file", "data", "qa", "init", "inside", "src", "ink", "SOURCE"], "output": ["external", "address", "result", "current", "path", "Output", "target", "filename", "out", "string", "name", "generated", "image", "write", "prefix", "STDOUT", "format", "text", "parent", "config", "message", "resource", "version", "document", "page", "source", "file", "dir", "password", "secret", "unit", "exit", "response", "temp"], "params": ["mos", "las", "lc", "services", "processor", "photos", "pro", "reader", "base", "pixel", "Param", "lp", "fps", "proc", "Parameters", "vs", "xml", "bis", "ctx", "py", "obj", "styles", "param", "Par", "s", "resources", "results", "spec", "si", "words", "properties", "afi", "i", "models", "ras", "batch", "options", "par", "attr", "lis", "ps", "config", "plugins", "mm", "pins", "phys", "api", "parts", "p", "dis", "http", "phrase", "ams", "data", "server", "details", "json", "theme", "names", "conf", "manager", "rules", "features", "pi", "settings"], "w": ["wt", "wa", "world", "reader", "aw", "war", "wl", "worker", "ws", "xml", "kw", "out", "wx", "hw", "write", "rw", "widget", "wic", "wal", "we", "m", "writer", "pipe", "ow", "wb", "nw", "wh", "p", "wave", "wd", "wcs", "wp", "wm", "work", "W", "fw", "wi", "sw", "web", "f", "temp"], "in": ["gin", "ins", "img", "din", "thin", "IN", "ani", "ai", "mc", "login", "bin", "id", "isin", "inc", "vin", "include", "ini", "index", "out", "In", "conn", "binary", "image", "err", "inas", "fa", "m", "ssl", "i", "r", "connection", "b", "null", "ex", "n", "again", "config", "socket", "nin", "win", "inn", "p", "min", "pin", "arin", "cin", "lin", "data", "file", "source", "qa", "kin", "cgi", "inside", "init", "rin", "src", "con", "ac", "part", "f", "cli", "temp"], "dest": ["rest", "test", "de", "cont", "st", "img", "din", "sup", "prop", "project", "delete", "dep", "beta", "tmp", "comb", "id", " Dest", "path", "folder", "default", "remote", "target", "flat", "nam", "name", "decl", "doc", "Dest", "dat", "desc", "route", "null", "parent", "gui", "config", "loc", "wb", "dc", "done", "resource", "dis", "wd", "dom", "di", "source", "destroy", "style", "dist", "dir", "d", "src", "coord", "die", "home", "txt", "exit", "temp"], "bi": ["ga", "qi", "bc", "ai", "ti", "ib", "vi", "mini", "gb", "bin", "nb", "xi", "bis", "bm", "oci", "ini", "ba", "eni", "li", "obi", "umi", "ci", "bank", "si", "fa", "bas", "phi", "ii", "sb", "i", "ori", "info", "b", "cu", "dat", "ki", "zi", "BI", "isi", "pin", "gi", "Bi", "fi", "abi", "di", "cli", "oi", "bid", "bh", "ni", "chi", "wei", "ji", " bio", "wi", "bs", "mu", "agi", "pi"], "os": ["us", "OS", "osi", "Os", "nos", "outs", "ob", "xs", "ot", "io", "aos", "ou", "vs", "ws", "es", "oss", "ks", "ns", "out", "s", "oes", "ios", " bos", "bos", "i", "oos", "dos", "des", "cs", "ops", "so", "o", "co", "fits", "oses", "ds", "los", "fs", "is", "obs", "cos", "pos", "as", "oa", "bs", "ors", "oS"]}}
{"id1": "8468859", "id2": "3536332", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"connect": ["bind", "exec", "stat", "client", "establish", "Connect", "login", "port", "sign", "log", "boot", "host", "start", "conn", "on", "patch", "write", " reconnect", "build", "read", "en", "nect", "construct", "connection", " disconnect", " connection", "config", "find", "stop", "socket", "close", "add", "init", "download", "create", "con", "open", "select", "connected", "run"], "status": ["complete", "result", "stat", "Status", "login", "str", "output", "site", "use", "id", "current", "progress", "skip", "log", "index", "session", "ui", "state", "success", "si", "step", "code", "type", "wait", "active", "count", "user", "parent", "speed", "sync", "standard", "edit", "update", "version", "min", "content", "continue", "source", "server", "style", "stage", "summary", "fail", "full", "unit", "response", "temp"], "reply": ["address", "result", "base", "error", "ping", "send", " response", "call", "answer", "request", "vote", "py", "state", "action", "ret", "next", "link", "prefix", "bot", "respond", "code", "reason", "repl", "connection", "count", "info", "Reply", "query", "sync", "post", "message", "update", "fee", "dy", "data", "resp", "server", "random", "second", "comment", "response"], "isConnected": ["isAccepted", "isNECTished", "isConnectioning", "isConnectable", "IsConnectp", " isConnectioned", "isaAdapted", "IsConnects", " isConnectaged", " isConnectable", " isAcceptable", "isFinished", "isFinaged", "isAcceptable", "isNECTalled", "isNECTing", "isConnectished", "isFining", "isConnectionp", "isConnectionalled", " isConnectionished", "isaAdapteded", "isConnections", "isConnectioneded", " isConnectioning", "isconnecteded", "isaAdapting", " isConnectished", "IsConnectioned", "isAcceptaged", " isConnecting", " isAcceptted", "isConnecting", "isNECTed", "IsConnecting", "IsConnections", "isAdapted", "isAdapting", "isaConnectified", "isConnectified", "isAdaptified", " isConnectalled", "isConnectionished", "isaAdaptified", "isaConnecting", "isconnecteds", "isFined", "IsConnected", "isFinalled", "isconnectedp", "isConnectalled", "isConnectaged", " isConnectted", "isConnectionified", "isConnectioned", "isaConnecteded", "IsConnectionp", " isAcceptaged", "isAdapteded", "isConnectted", "isFinable", "isAcceptted", " isAccepted", "isConnectp", "isaConnected", "IsConnectioning", " isConnectionalled", "isConnecteded", "isConnects", "isFinted", "isconnecteding"]}}
{"id1": "12869602", "id2": "11154758", "code1": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        FileOutputStream fos = null;\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String filename = \"i.exe\";\n            fos = new FileOutputStream(filename);\n            client.retrieveFile(\"/\" + filename, fos);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fos != null) {\n                    fos.close();\n                }\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"test_validate_tag_getTopAlbums": ["test_validate_tag_getTopArtbums", "test_validate_tag_getTopArtbumls", "test_validate_tag_getTopAlgges", "test_validate_tag_getTopArtalbums", "test_validate_tag_getTopAlangls", "test_validate_tag_getTopAlalbums", "test_validate_tag_getTopAlanges", "test_validate_tag_getTopAlango", "test_validate_tag_getTopArtalbumo", "test_validate_tag_getTopAlangs", "test_validate_tag_getTopArtalbumes", "test_validate_tag_getTopAlbumes", "test_validate_tag_getTopAlalbumo", "test_validate_tag_getTopArtbumes", "test_validate_tag_getTopArtbumo", "test_validate_tag_getTopAlbumls", "test_validate_tag_getTopAlggs", "test_validate_tag_getTopArtalbumls", "test_validate_tag_getTopAlbumo", "test_validate_tag_getTopAlalbumls", "test_validate_tag_getTopAlggls", "test_validate_tag_getTopAlggo", "test_validate_tag_getTopAlalbumes"], "factory": ["pault", "dinder", "ifault", "finder", "dictionary", "facault", "affuild", "newictionary", "dactory", "pictionary", "ifuild", "facactory", "newinder", "ifuture", "affactory", "fuild", "fault", "newactory", "dault", "ifactory", "future", "facuture", "pactory", "pinder", "fictionary", "affuture", "facuild", "affault", "newault"], "schemaLocation": ["specmaPath", "schemeLocation", "symalocation", "specbaseFile", "schemlLocation", "schemaPath", "specbaseLocation", "schemasLocation", "symlFile", "schemaslocation", "schebasePosition", "symllocation", "symaFile", "schebaselocation", "specmaLocation", "schemasPosition", "schebaseLocation", "specmaFile", "symaLocation", "schemllocation", "symlLocation", "schemalocation", "schemeFile", "specbasePath", "specmaPosition", "schemasFile", "schebaseFile", "schebasePath", "schemaPosition", "schemasPath", "schemePath", "schemePosition", "schemaFile", "specbasePosition", "schemlFile"], "schema": ["defml", "verme", "mama", "verml", "mamas", "mage", "scheme", "schege", "cheme", "defma", "masge", "masma", "defme", "verma", "chemas", "schemma", "vermas", "cheml", "mamma", "scheml", "masmas", "schemas", "chemma", "chege", "defmas", "chema", "masmma"], "validator": ["Validater", "validoder", "valation", "validater", " validater", " invalidner", "valater", " invalidater", "Validator", "Validation", "validner", " invalidator", " invalider", " validoder", " validner", "valator", "Validoder", "Validner", "validation", " valider", " validation", "Valider", "valider", "valoder"], "url": ["address", "feed", "URL", "path", "xml", "sl", "Url", "host", "location", "stream", "image", "ssl", "connection", "method", "user", "b", "browser", "text", "www", "config", "loc", "buffer", "uri", "date", "resource", "api", "http", "l", "file", "server", "channel", "download", "email", "coll", "web", "f"], "inputStream": [" inputFile", "downStream", "inputSteam", "downSteam", "InputSource", "inputFile", "downSource", "InputPath", " inputPath", " inputSteam", "inputSource", "InputFile", " inputSource", "inputPath", "downForm", "responsePath", "responseStream", "inputForm", "responseFile", "responseSource", "InputSteam", " inputForm", "InputForm", "InputStream"], "source": ["ource", "slave", "result", "reader", "level", "view", "proxy", "model", "scene", "path", "input", "target", "session", "string", "out", "context", "s", "stream", "image", "Source", "format", "connection", "method", "class", "text", "object", "handler", "slice", "ources", "parser", "uri", "service", "resource", "document", "from", "data", "file", "channel", "src", "instance", "SOURCE"]}}
{"id1": "3558512", "id2": "812803", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"serialize": ["Serialze", "finalze", "Serialize", " serialze", "erialize", "Serialized", "erialze", "Serialization", "Serialify", "serialze", " serialization", "serializable", "erialization", "normalify", "normalized", "finalize", "normalze", "serialify", "finalized", "finalify", "erializable", "Serializable", "serialized", "serialization", "normalize", " serializable"], "out": ["exec", "OUT", "png", "outs", "cache", "client", "w", "gen", "output", "bin", "io", "raw", "filename", "name", "string", "obj", "conn", "archive", "image", "err", "Out", "writer", "i", "report", "a", "ex", "parent", "o", "loader", "buffer", "content", "copy", "page", "data", "pool", "file", "up", "source", "server", "dump", "temp"], "parser": ["test", "processor", "base", "master", "reader", "system", "cache", "builder", "parse", "php", "lp", "tt", "worker", "xml", "plugin", "arser", "er", "seed", "cp", "pkg", "upload", "writer", "pe", "Parser", "class", "parent", "handler", "pillar", "per", "loader", "p", "wrapper", "copy", "file", "up", "server", "instance", "rar", "pp", "ss", "as", "txt", "manager"], "on_disk": ["onJdemand", "onnetfile", "onnetspace", "off_space", "off_delete", "onbootlock", "on_lock", "onbookdelete", "off_lock", "on_file", "off_drive", "onjspace", "off_storage", "onbootdrive", "onJdrive", "onbootdisk", "on_drive", "onJlock", "onjdrive", "onJdisk", "onbootstorage", "off_demand", "onbookdrive", "off_disk", "onjfile", "onbookdisk", "on_storage", "onnetdemand", "onjdisk", "on_demand", "onnetdisk", "on_delete", "onnetdrive", "on_space", "off_file"], "in": ["ins", "thin", "din", "reader", "IN", "login", "bin", "inc", "ini", "input", "In", "conn", "inner", "stream", "c", "inas", "ax", "i", "connection", "info", "r", "again", "o", "socket", "win", "inn", "min", "pin", "copy", "data", "lin", "file", "source", "kin", "rin", "pass", "con", "ac", "as", "f"]}}
{"id1": "3309233", "id2": "23215235", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public void readFile(URL url) throws PedroException, IOException, ParserConfigurationException, SAXException {\n        this.zipFileName = url.toString();\n        URLConnection urlConnection = url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n        unzipNativeFormatFile(inputStream);\n        parseAlertFiles();\n        deleteAlertFiles();\n    }\n", "label": 0, "substitutes": {"doInBackground": ["buildInBackground", " doAsyncBackground", " doUsingBackground", " doAsyncConsole", "buildUsingStudio", " doAsBackground", "buildUsingBackground", " doAsConsole", " doAsyncAsync", " doInConsole", " doUsingAsync", " doUsingStudio", " doAsyncStudio", "buildInAsync", " doAsStudio", " doInAsync", "buildUsingConsole", " doInStudio", "buildUsingAsync", " doUsingConsole", "buildInStudio", "buildInConsole", " doAsAsync"], "params": ["address", "services", "objects", "posts", "types", "eps", "parse", "Param", "pm", "reports", "Parameters", "py", "values", "ls", "Par", "lines", "s", "resources", "results", "files", "comments", "strings", "properties", "type", "i", "arms", "options", "par", "ps", "config", "mes", "pins", "ds", "los", "parts", "p", "phrase", "ams", "page", "source", "data", "keys", "json", "details", "sp", "names", "ctx", "settings"], "param": ["cm", "address", "monitor", "lc", "mor", "amp", "project", "Param", "comment", "pm", "pri", "model", "camp", "proc", "am", "path", "default", "prem", "conn", "name", "string", "prom", "cp", "iam", "Parameter", "mand", "connection", "gram", "null", "object", "par", "parent", "arm", "km", "config", "mm", "rem", "option", "p", " parameter", "meter", "single", "aram", "channel", "pool", "pb", "ams", "vm", "password", "page", "contract", "pc", "ram", "part", "conf", "ctx", "temp"], "client": ["cm", "url", "cl", "base", "project", "app", "force", "proxy", "request", "plugin", "session", "host", "connect", "conn", "secure", "cp", "c", "comp", "self", "bird", "ssl", "connection", "handler", "Client", "config", "apache", "service", "api", "resource", "p", "http", "cli", "channel", "server", "google", "help", "con", "ce", "response"], "post": ["base", "send", "e", "pod", "zip", "pre", "load", "feed", "put", "proc", "request", "patch", "hop", "next", "set", "c", "upload", "dd", "head", "body", "query", "install", "api", "p", "add", "form", "http", "wp", "submit", "entry", "op", "pb", "push", "Post", "server", "pos", "create", "and", "posted", "POST", "pp", "json", "part", "comment", "f", "response"], "resp": ["exec", "error", "Resp", "received", " response", "status", "re", "rh", "rel", "e", "Response", "request", "comm", "res", "conn", "obj", "rep", "success", "err", "respond", "par", "body", "handler", "rec", "enc", "fc", "api", "resource", "content", "http", "page", "server", "download", "ref", "req", "reply", "json", "sp", "serv", "response"], "entity": ["base", "status", "ity", "output", "e", "el", "model", "xml", "node", "string", "conn", "obj", "code", "ec", "event", "element", "connection", "ent", "object", "body", "enc", "attribute", "resource", "person", "agent", "content", "translation", "Entity", "line", "data", "entry", "article", "instance", "coll", "json", "activity", "unit", "response"], "result": ["address", "url", "description", "place", "status", "output", "Result", "default", "row", "res", "string", "location", "name", "ret", "success", "results", "report", "desc", "object", "text", "message", "resource", "property", "content", "translation", "page", "line", "entry", "data", "match", "source", "record", "instance", "value", "json", "details", "response"]}}
{"id1": "17158020", "id2": "4921631", "code1": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encryptpassword", "decryptpassword", "decryptPass", "decryptString", "encressPassword", "encipherPassword", "encipherString", "encresspassword", "decipherPass", "encressString", "encipherPass", "encipherpassword", "encryptString", "decipherpassword", "encressPass", "decipherPassword", "decipherString", "decryptPassword", "encryptPass"], "passwordString": ["PasswordString", " passwordBytes", "passText", " passwordPassword", "PasswordText", "passwordText", "PasswordBytes", " passwordText", "PasswordStr", "passPassword", "passwordStr", "passwordBytes", " passwordStr", "passBytes", "PasswordPassword", "passString", "passwordPassword", "passStr"], "digest": [" digested", "mainit", "Digse", "digit", "signEST", "generer", "signest", "heder", "mainest", " digse", "compested", "hedester", "compest", "signse", "digEST", "mainested", "diggest", " digester", "Diggest", "digester", " diggest", " digEST", " digHash", "mainHash", "digse", " digit", "DigEST", "digested", "Diger", "Digester", "digHash", "signester", "diger", "Digest", " diger", "signer", "compHash", "Digested", "genergest", "compit", "hedest", "hedested", "generester", "generest"], "raw": ["dec", "wrap", "unsigned", "clean", "ng", "local", "RAW", "feed", "load", "none", "row", "input", "out", "aws", "binary", "rew", "original", "image", "missing", "hex", "serial", "pure", "Raw", "null", "unknown", "empty", "enc", "block", "buffer", "array", "alpha", "wrapper", "channel", "secret", "shared", "instance", "random", "full", "initial", "temp"], "hash": ["url", "header", "sha", "base", "ash", "cache", "rh", "id", "Hash", "utf", "index", "row", "input", "response", "kh", "image", "hex", "ashes", "ruby", "auth", "html", "hed", "block", "her", "message", "array", "version", "key", "mac", "h", "sh", "data", "secret", "pass", "sum", "ha", "dig"]}}
{"id1": "8468859", "id2": "9718328", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    public void actionPerformed(ActionEvent e) {\n        if (\"register\".equals(e.getActionCommand())) {\n            buttonClicked = \"register\";\n            try {\n                String data = URLEncoder.encode(\"ver\", \"UTF-8\") + \"=\" + URLEncoder.encode(Double.toString(questVer), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"name\", \"UTF-8\") + \"=\" + URLEncoder.encode(name.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"os\", \"UTF-8\") + \"=\" + URLEncoder.encode(os.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"jre\", \"UTF-8\") + \"=\" + URLEncoder.encode(jre.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(email.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"key\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"Qr7SchF\", \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"answers\", \"UTF-8\") + \"=\" + URLEncoder.encode(Integer.toString(getAnswers()), \"UTF-8\");\n                URL url = new URL(\"http://ubcdcreator.sourceforge.net/register.php\");\n                URLConnection conn = url.openConnection();\n                conn.setDoInput(true);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = rd.readLine()) != null) {\n                }\n                rd.close();\n                wr.close();\n            } catch (Exception ex) {\n            }\n            setVisible(false);\n        } else if (\"cancel\".equals(e.getActionCommand())) {\n            buttonClicked = \"cancel\";\n            setVisible(false);\n        } else if (\"never\".equals(e.getActionCommand())) {\n            buttonClicked = \"never\";\n            setVisible(false);\n        }\n    }\n", "label": 0, "substitutes": {"connect": ["bind", "exec", "stat", "client", "establish", "Connect", "login", "port", "sign", "log", "boot", "host", "start", "conn", "on", "patch", "write", " reconnect", "build", "read", "en", "nect", "construct", "connection", " disconnect", " connection", "config", "find", "stop", "socket", "close", "add", "init", "download", "create", "con", "open", "select", "connected", "run"], "status": ["complete", "result", "stat", "Status", "login", "str", "output", "site", "use", "id", "current", "progress", "skip", "log", "index", "session", "ui", "state", "success", "si", "step", "code", "type", "wait", "active", "count", "user", "parent", "speed", "sync", "standard", "edit", "update", "version", "min", "content", "continue", "source", "server", "style", "stage", "summary", "fail", "full", "unit", "response", "temp"], "reply": ["address", "result", "base", "error", "ping", "send", " response", "call", "answer", "request", "vote", "py", "state", "action", "ret", "next", "link", "prefix", "bot", "respond", "code", "reason", "repl", "connection", "count", "info", "Reply", "query", "sync", "post", "message", "update", "fee", "dy", "data", "resp", "server", "random", "second", "comment", "response"], "isConnected": ["isAccepted", "isNECTished", "isConnectioning", "isConnectable", "IsConnectp", " isConnectioned", "isaAdapted", "IsConnects", " isConnectaged", " isConnectable", " isAcceptable", "isFinished", "isFinaged", "isAcceptable", "isNECTalled", "isNECTing", "isConnectished", "isFining", "isConnectionp", "isConnectionalled", " isConnectionished", "isaAdapteded", "isConnections", "isConnectioneded", " isConnectioning", "isconnecteded", "isaAdapting", " isConnectished", "IsConnectioned", "isAcceptaged", " isConnecting", " isAcceptted", "isConnecting", "isNECTed", "IsConnecting", "IsConnections", "isAdapted", "isAdapting", "isaConnectified", "isConnectified", "isAdaptified", " isConnectalled", "isConnectionished", "isaAdaptified", "isaConnecting", "isconnecteds", "isFined", "IsConnected", "isFinalled", "isconnectedp", "isConnectalled", "isConnectaged", " isConnectted", "isConnectionified", "isConnectioned", "isaConnecteded", "IsConnectionp", " isAcceptaged", "isAdapteded", "isConnectted", "isFinable", "isAcceptted", " isAccepted", "isConnectp", "isaConnected", "IsConnectioning", " isConnectionalled", "isConnecteded", "isConnects", "isFinted", "isconnecteding"]}}
{"id1": "13122204", "id2": "8788371", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["UnzipModel", "unzipmodel", "unarchiveProject", "Unzipmodel", "unpatchmodel", "unarchivemodel", "unarchiveModel", "UnarchiveFile", "UnarchiveProject", "unpatchFile", "UnzipFile", "unpatchProject", "unzipFile", "unarchiveFile", "UnzipProject", "unzipProject", "unpackmodel", "UnarchiveModel", "unpackProject", "unpackModel", "unpackFile", "unpatchModel", "Unarchivemodel"], "filename": ["fp", "url", "FILE", "title", "fil", "kl", "model", "path", "folder", "utf", "nil", "location", "string", "name", "database", "files", "jet", "username", "SourceFile", "File", "directory", "loc", "fits", "uri", "fd", "l", "source", "fn", "file", "download", "src", "bf", "txt", "Filename", "f", "il", "module"], "tempdir": ["tmpdirectory", "Tempdirectory", " tempfolder", "tmpDir", " tempDir", "temdir", "TempDir", "temfolder", "tempDir", "temppath", "tmpfolder", "tempfolder", "temDir", "Tempdir", "tmpDIR", " tempdirectory", "TempDIR", "tmppath", " temppath", "Tempfolder", "tempDIR", "temdirectory", "tempdirectory", " tempDIR", "tmpdir", "tempath"], "dest": ["rest", "test", "result", "de", "cont", "st", "sup", "prop", "gen", "delete", "builder", "output", "transfer", "tmp", "zip", "exit", "comb", "proc", "folder", "log", "walk", "default", "export", "target", "flat", "session", "ui", "obj", "inner", "tar", "std", "Dest", "transform", "dat", "desc", "cdn", "handler", "loc", "walker", "nt", "sync", "wb", "done", "dc", "store", "di", "source", "file", "usr", "dist", "dir", "src", "die", "later", "home", "trans", "opt", "txt", " Dest", "temp"], "fis": ["filebis", " fiss", "flisa", "fid", "flis", "liss", "fliss", "fileisa", "fsisa", "fsbis", " fi", "fileis", "li", "lid", "fileid", "fsiss", " fid", "fsis", "filei", "lis", "fbis", "fiss", "fileiss", "fi", "flbis", "fisa"], "BUFFER": ["UPFF", " BUVER", "SAPER", "BUUCK", "BUFER", "BUFF", "CUVER", "TAPER", "BOFFER", "BOPER", "CUUCK", "SAUCK", "CUFFER", "TAVER", "UPFFER", " BUFER", " BUVEN", "CUVEN", "CUPER", " BUFIX", "BOFIX", "CUFF", "SAFFER", "TAFFER", "MAFIX", " BUFF", "MAPER", "BUPER", " BUUCK", "BUFIX", "UPVEN", "BUVEN", "MAFER", "MAFFER", "BOFER", "SAVER", " BUPER", "UPVER", "BUVER", "TAUCK"], "zis": ["zipis", " zists", " zbis", "zipisa", " zisa", "xiss", "diss", " zii", "zins", "Zas", "xis", " zos", "zin", "zii", "xi", "Zisa", " ziss", "zas", " zIS", "yis", "zipIS", "zipas", "zos", "zists", "Zins", "xii", "yin", " zin", "jos", "yIS", "jists", "zi", "Zis", "xos", "jis", "zipins", "dis", "zIS", "yisa", "xists", "zbis", "dbis", "zisa", " zas", "xbis", "dii", " zins", "ji", "zipin", " zi", "ziss"], "entry": ["de", "result", "lc", "reader", "enter", "e", "id", "zip", "feed", "inc", "ace", "ou", "valid", "cel", "je", "ge", "row", "name", "end", "li", "inner", "archive", "image", "next", "spec", "si", "or", "element", "ie", "info", "way", "pe", "ent", "connection", "Entry", "nt", "porter", "her", "pack", "la", "iterator", "jo", "rc", "line", "file", "ry", "se", "match", "source", "server", "ident", "ries", "cat", "part", "record", "ce", "module"], "count": ["base", "cache", "allow", "e", "use", "id", "feed", "current", "_", "Count", "log", "val", "index", "start", "length", "name", "max", "time", "end", "core", "ind", "c", "write", "len", "next", "code", "read", "type", "writer", "i", "counter", "b", "number", "list", "weight", "cond", "buffer", "iter", "add", "key", "line", "in", "file", "last", "low", "pos", "limit", "coll", "part", "sum", "size", "f"], "data": ["result", "base", "reader", "str", "id", "feed", "load", "raw", "DATA", "index", "input", "start", "length", "name", "image", "next", "write", "size", "len", "read", "format", "a", "info", "batch", "dat", "number", "body", "block", "message", "pack", "buffer", "media", "array", "bytes", "alpha", "content", "la", "shift", "pos", "d", "value", "record", "zero"], "fos": ["foes", "dfoes", "fOS", "dfoos", "afos", " foos", "xoes", "afOS", "bis", "xoos", "bOS", " fOS", "dfos", " fops", "afis", "bos", "dfops", "bops", "xos", "fops", " foes", "xops", "afops", "foos"]}}
{"id1": "2525897", "id2": "15166511", "code1": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"decode": ["deccode", "deode", "Decoder", "Deccode", "encoder", "Decode", "Decrypt", "encrypt", "decoder", "encode", "decrypt", "deoder", "enccode", "derypt"], "cryptPassword": [" cryptPass", "ryptPassword", "cryptpassword", "CryptPassword", "encryptedPass", " cryptpassword", "cryptPass", "encryptedPassword", "Cryptpassword", "ryptpassword", "CryptPass", "ryptPass", "encryptedpassword"], "encoded": ["encrypted", "explrypted", "Encoded", "ecode", "Encrypted", "exploded", "decored", "Enccoded", "explcoded", "escrypted", "explored", "esccoded", "ecrypted", "decrypted", "enccoded", "ecoded", "encored", "deccoded", "escode", "eccoded", "encode", "escoded", "Encored"], "salt": ["SALT", "Sodium", "Sipher", " sALT", "sodium", "sipher", " seal", "essalt", " saled", "saled", "essodium", "sALT", "calt", "Saled", "Salt", " sipher", "Seal", "seal", "essALT", " sodium", "cALT", "caled", "esseal"], "digester": [" Diger", "generer", "signest", " Digester", "signitter", "digcher", " digcher", "Digcher", "digest", " Digamer", " digest", "Diger", "Digester", "digitter", " digitter", "signester", "diger", "Digamer", "generener", "Digest", " diger", "signer", "Digitter", "Digener", "signcher", "digamer", "generester", " digener", " digamer", "generest", "digener", " Digest"], "random": ["exclusive", "reader", "chain", "token", "clean", "gen", "re", "monkey", "right", "inv", "reg", "io", "cur", "worker", "default", "creator", "remote", "seed", "out", "inner", "regular", "winner", "driver", "range", "serial", "normal", "extra", "or", "crypt", "r", "user", "root", "handler", "query", "author", "config", "gener", "general", "resource", "unique", "server", "ro", "init", "password", "rand", "network", "initial", "runner", "temp"], "i": ["v", "k", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "start", "u", "li", "hi", "ui", "inner", "multi", "ci", "c", "si", "phi", "ii", "m", "j", "count", "b", "n", "o", "bi", "zi", "ri", "uri", "p", "it", "h", "gi", "abi", "in", "oi", "di", "init", "ni", "num", "chi", "mu", "f", "pi"], "hash": ["address", "url", "header", "sha", "master", "base", "ash", "cache", "chip", "id", "cover", "check", "Hash", "total", "row", "host", "seed", "kh", "image", "hex", "code", "auth", "crypt", "user", "hed", "block", "her", "message", "array", "version", "mac", "h", "phrase", "password", "secret", "pass", "sum", "ha"], "maxKeySize": ["maxSignSIZE", "maxSecretsize", " maxSecretLen", "maxBlockLen", "maxKeyLength", " maxKeysize", "maxBlockLength", "maxKeysize", " maxKeyLen", "maxSecretLen", " maxSecretSize", "maxCharSIZE", "maxSignSize", "maxKeySIZE", "maxCharSize", " maxKeySIZE", "maxSecretSize", " maxSecretLength", "maxBlockSize", " maxSecretSIZE", "maxSignLen", "maxKeyLen", "maxSecretSIZE", "maxCharsize", "maxCharLength", "maxSignLength", " maxSecretsize", " maxKeyLength", "maxSecretLength", "maxBlocksize", "maxCharLen"], "generator": ["generate", "Generator", "encation", "Generrator", "generer", "encator", "generation", "Generation", "genrator", "initate", "terminator", "generrator", "initiator", "encer", "geniator", "initator", "generiator", "gener", "genator", "termininator", "genation", "Generiator", "encate", "geninator", "Generate", "Generinator", "initrator", "genate", "terminer", "terminate", "Generer", "generinator"], "key": ["pair", "kid", "k", "ip", "client", "chain", "cache", "gen", "id", "sign", "raw", "row", "KEY", "name", "core", "seed", "word", "driver", "image", " secret", "or", "type", "box", "crypt", "connection", "user", "number", "service", " object", "p", "copy", " source", "Key", "phrase", "source", "char", "file", "server", "secret", "keys", "ce", "temp"], "cipher": ["coder", "encairo", "cursor", "scoder", "cairo", "encoder", "encrypt", "scairo", "Cryption", "Crypt", "scipher", "ecipher", "ecursor", "encryption", "Cipher", "ecrypt", "crypt", "Cursor", "encipher", "Coder", "ecryption", "scrypt", "cryption", "scryption", "Cairo", "encursor"], "decoded": ["decoding", "derypted", "decoder", " decoding", "recoder", "deoder", "ecoder", "ecrypted", "decrypted", " decoder", " decrypted", "ecoded", " deccoded", "recoded", "deccoded", "deoding", "eccoded", "recoding", "deoded", "recrypted"]}}
{"id1": "1966310", "id2": "13159394", "code1": "    public void init() {\n        super.init();\n        Runnable doActions = new Runnable() {\n\n            public void run() {\n                if (_plot == null) {\n                    _plot = newPlot();\n                }\n                getContentPane().add(plot(), BorderLayout.NORTH);\n                int width;\n                int height;\n                String widthspec = getParameter(\"width\");\n                if (widthspec != null) {\n                    width = Integer.parseInt(widthspec);\n                } else {\n                    width = 400;\n                }\n                String heightspec = getParameter(\"height\");\n                if (heightspec != null) {\n                    height = Integer.parseInt(heightspec);\n                } else {\n                    height = 400;\n                }\n                _setPlotSize(width, height);\n                plot().setButtons(true);\n                Color background = Color.white;\n                String colorspec = getParameter(\"background\");\n                if (colorspec != null) {\n                    background = PlotBox.getColorByName(colorspec);\n                }\n                setBackground(background);\n                plot().setBackground(background);\n                getContentPane().setBackground(background);\n                Color foreground = Color.black;\n                colorspec = getParameter(\"foreground\");\n                if (colorspec != null) {\n                    foreground = PlotBox.getColorByName(colorspec);\n                }\n                setForeground(foreground);\n                plot().setForeground(foreground);\n                plot().setVisible(true);\n                String dataurlspec = getParameter(\"dataurl\");\n                if (dataurlspec != null) {\n                    try {\n                        showStatus(\"Reading data\");\n                        URL dataurl = new URL(getDocumentBase(), dataurlspec);\n                        InputStream in = dataurl.openStream();\n                        _read(in);\n                        showStatus(\"Done\");\n                    } catch (MalformedURLException e) {\n                        System.err.println(e.toString());\n                    } catch (FileNotFoundException e) {\n                        System.err.println(\"PlotApplet: file not found: \" + e);\n                    } catch (IOException e) {\n                        System.err.println(\"PlotApplet: error reading input file: \" + e);\n                    }\n                }\n            }\n        };\n        try {\n            SwingUtilities.invokeAndWait(doActions);\n        } catch (Exception ex) {\n        }\n    }\n", "code2": "    public HttpResponse fetch(HttpServletRequest request) throws IOException {\n        GUI = SwingUI.getApplicatoin();\n        DefaultHttpClient httpclient = new DefaultHttpClient();\n        CookieSpecFactory csf = new CookieSpecFactory() {\n\n            public CookieSpec newInstance(HttpParams params) {\n                return new BrowserCompatSpec() {\n\n                    @Override\n                    public void validate(Cookie cookie, CookieOrigin origin) throws MalformedCookieException {\n                    }\n                };\n            }\n        };\n        if (Helper.useProxy()) {\n            HttpHost proxy = new HttpHost(Helper.getProxyServer(), Helper.getProxyPort());\n            httpclient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);\n        }\n        httpclient.getCookieSpecs().register(\"easy\", csf);\n        httpclient.getParams().setParameter(ClientPNames.COOKIE_POLICY, \"easy\");\n        String currentRemoteGAEHost = Helper.getRemoteServer();\n        try {\n            HttpUriRequest httpRequest = createRequest(request);\n            addHeader(request, httpRequest);\n            HttpResponse response = httpclient.execute(httpRequest);\n            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_FORBIDDEN) {\n                challengeProxy(currentRemoteGAEHost);\n            }\n            logger.info(Helper.count.incrementAndGet() + \" Response received from \" + request.getRequestURL().toString() + \", status is \" + response.getStatusLine());\n            GUI.updateFetchCount();\n            return response;\n        } catch (ClientProtocolException e) {\n            logger.error(\"Fetch ClientProtocol Error\", e);\n            throw e;\n        } catch (IOException e) {\n            logger.error(\"Fetch IO Error\", e);\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"init": ["exec", "reset", "base", "clean", "gen", "prep", "bin", "load", "boot", " Init", "ini", "plugin", "connect", "start", "core", "action", "clear", "setup", "set", "ci", "build", "alloc", "construct", "info", "Init", "empty", " initialize", "config", "pack", "done", "ize", "close", "it", "act", "create", "initialized", "initial", "open", "conf", "basic"], "doActions": [" animationCactions", " animationAaction", " animationAactions", " plotCaactions", " plotAlAction", " plotActionAction", " plotAaction", " animationCaaction", " plotCaAction", " animationActions", " plotCactions", " plotAlctions", " plotActionaction", " plotAAction", " animationCaactions", " plotAlactions", " plotAactions", " plotAlaction", " animationCaAction", " plotCaaction", " plotActions", " plotActionctions", " plotActionactions", " animationAAction"], "_plot": ["_chart", "_pl", "_log", "_project", "_fit", "_patch"], "width": ["flow", "wa", "w", "Width", "left", "window", "port", "platform", "crop", "high", "space", "fb", "index", "west", "filename", "hop", "length", "name", "border", "image", "write", "down", "widget", "dim", "large", "lon", "wn", "duration", "writer", "wait", "fill", "shape", "number", "pull", "speed", "layout", "weight", "padding", "fall", "amount", "idth", "wp", "age", "page", "work", "density", "style", "fw", "gender", "capacity", "value", "draw", "area", "size"], "height": ["shadow", " heights", "bottom", "thin", "ip", "wrap", "level", "upper", "resolution", "window", "right", "id", "port", "crop", "volume", "gravity", "index", "deep", "row", "length", "image", "build", "y", "duration", "gap", "shape", "Height", "head", "th", "rows", "pull", "slice", "weight", "pad", "padding", "layout", "alpha", "depth", "rank", "grow", "h", "data", "thumbnails", "quality", "density", "style", "arrow", "capacity", "draw", "inches", "size", "radius", "stroke"], "widthspec": [" widthstyle", "lengthparse", "weightspec", " widthscale", "Widthpec", " widthSpec", "sizestring", "lengthset", " widthparse", "sizespec", "Widthspec", "weightSpec", "WidthSpec", "weightpec", "lengthSpec", "widthstring", "lengthspec", "poolset", "widthstyle", "poolSpec", "widthscale", " widthstring", "widthpec", "weightstring", "poolspec", "Widthstyle", "widthSpec", "widthparse", "sizescale", " widthset", " widthpec", "weightstyle", "sizeSpec", "poolparse", "widthset", "weightscale"], "heightspec": ["heekspe", "peatspec", "peightsspec", "weightspec", "heightsync", "heightsSpec", "heakspect", "heightspe", "peatslip", "heightsspec", "heatspect", "peightspect", "heatslip", "peatsspec", "heetspec", "heaksspec", "heowsync", "peatsync", "heightspect", "heatspec", "heatsSpec", "weowsspec", "weowspec", "heowsspec", "heckspect", "peatspe", "heeksspec", "heekslip", "hecksspec", "weightsspec", "heightslip", "heatspe", "hecksSpec", "heowspect", "heckspec", "heetslip", "peightslip", "heetspe", "heatsspec", "weowsSpec", "heakspec", "heowsSpec", "peatspect", "peightspec", "heekspec", "heaksync", "peightsync", "weightspect", "heatsync", "weowspect", "heowspec", "heetsspec", "peightspe", "weightsSpec"], "background": ["shadow", "bc", "gold", "ghost", "base", "blue", "description", "panel", "shield", "brush", "gray", "sound", "shell", "default", "gradient", "ba", "border", "pattern", "foundation", "profile", "regular", "image", "callback", "prefix", "ruby", "ground", "large", "reference", "black", "null", "fill", "ignore", "bg", "ha", "back", "pull", "support", "buffer", "clip", "alpha", "resource", "wrapper", "rc", "Background", "focus", "pool", "brown", "summary", "draw", "theme", "area", "collection", "comment", "color"], "colorspec": ["colarspect", "coloresspec", "colororespect", "colororsspec", "colorespec", "Colorspir", "Colorsspec", "colonsSpec", "coloresSpec", "colororespec", "colarship", "colonship", "collorspace", "Colonspec", "collorespec", "colororesspec", "colorsnp", "Colorspace", "colloresspec", "colorespir", "collorespace", "colarspec", "colororspec", "Colonspace", "collorsspec", "colandspec", "colorspace", "coloreslip", "colourspir", "Colorespect", "coloursspec", "colandsspec", "colarsspec", "Colorship", "colionspec", "collectionsspec", "colourspec", "colandsSpec", "colionslip", "Colorsnp", "colionsspec", "Colonsspec", "colororsSpec", "colorspir", "colonspect", "colorsSpec", "colonsspec", "collorspec", "coloresnp", "Coloreship", "colonspace", "colorspect", "collectionspec", "colonspec", "colourspect", "colorespace", "colionspir", "Coloresspec", "coloreship", "coloursnp", "colionspace", "Colorespir", "Colorspect", "Colonslip", "Colorspec", "colourspace", "colorsspec", "colandspect", "collectionspect", "colorespect", "colonslip", "colorship", "collorspect", "Colorespec", "collorespect", "Coloresnp", "colororspect", "Colorslip", "colionsnp", "colorslip", "colororesSpec"], "foreground": [" forebackground", "backmission", "foreparent", "flyellow", "Foreground", "flyfill", "Foremission", "Forebackground", "backpoint", "foreellow", "Foreparent", "backbackground", "roughmission", "undercast", "forebackground", "fterGROUND", "roughellow", "broadellow", "Forecast", " foreparent", "broadcast", " forecast", "flyground", "broadfill", "underground", "forecast", "roughpoint", "flycast", "foremission", "fterground", "underparent", "foreGROUND", "fterbackground", "underbackground", "ForeGROUND", "roughground", "broadground", " foreGROUND", "roughcast", "roughfill", "forefill", "roughbackground", "Forepoint", "ftercast", "forepoint"], "dataurlspec": [" dataurlparse", " datalogparse", " dataurlSpec", "dataURLspace", " dataUrlspec", "datastringspec", "datalogstr", " dataurlspe", "datalogspace", "datafilestr", "dataURLspe", "dataURLSpec", "dataURLspec", "datalogparse", "dataurlSpec", "datafeedspec", "dataurlspace", "dataurlspe", "dataUrlspe", "datafilespace", " datalogspec", "datalogspec", "datastringSpec", " dataurlstr", "dataUrlspec", "datafeedSpec", " datalogstr", "datafilespec", " datalogspace", "dataUrlSpec", " dataUrlspe", "datastringspe", "dataURLparse", "datafileparse", " dataurlspace", " dataUrlSpec", "dataURLstr", "dataurlparse", "dataurlstr"], "dataurl": ["thisURL", "ataurl", "thisfile", "thisurl", " dataURL", "atabase", "DataURL", " dataUrl", "Datafile", "dataUrl", "Database", "datafile", "database", "thisUrl", "ataUrl", "DataUrl", "Dataurl", " database", " datafile", "dataURL", "ataURL"], "in": ["serv", "url", "ins", "reader", "din", "IN", "login", "bin", "isin", "inc", "ini", "input", "out", "In", "stream", "inner", "image", "c", "err", "inas", "t", "a", "i", "r", "b", "body", "socket", "win", "resource", "inn", "p", "h", "data", "source", "server", "d", "con", "as", "record", "f"]}}
{"id1": "10451698", "id2": "13891080", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["drop", "share", "change", "delete", "paste", "rm", "transfer", "zip", "Copy", "load", "replace", "remote", "py", "cp", "archive", "lock", "write", " cp", "type", "cop", "ignore", "parent", "sync", "list", "update", "clip", "get", "process", "move", "file", "download", "create", "dump", "split", "cat", "ssh", "part", "clone", "run"], "source": ["ource", "slave", "url", "result", "reader", "client", "cache", "project", "scope", "view", "site", "use", "current", "proxy", "model", "path", "folder", "remote", "target", "filename", "start", "name", "seed", "string", "secure", "stream", "flat", "archive", "section", "image", "Source", "storage", "ie", "info", "connection", "class", "root", "null", "directory", "object", "parent", "config", "slice", "iter", "service", "resource", "plus", "from", "document", "data", "file", "server", "src", "unit", "sf", "ce", "SOURCE"], "destinationDirectory": ["destributionDirectory", "destructionFolder", "DestributionHome", "destributionPath", "DestinationFolder", "DestinationDir", "destributionHome", "destructionDir", " destinationFolder", " destinationFile", " destinationsFolder", "destarationPoint", " destinationDir", "DestinationHome", "DestributionFolder", "destificationDirectory", "destinationFile", "DestinationDirectory", "destippingDirectory", "destinatorPoint", "destinationsDirectory", "destinationPath", "destinationDir", "DestributionDirectory", " destinationsFile", "destinationHome", "destippingFolder", "destinatorPath", "destificationFolder", "destippingHome", "destinationsDir", "destinationsFolder", "DestributionPath", "destippingDir", "DestributionDir", " destinationsDir", "destinatorDirectory", "destarationDirectory", "destinationsFile", "destructionDirectory", "destributionFolder", "DestributionPoint", "destructionFile", "destinationFolder", "destarationPath", " destinationsDirectory", "destinationPoint", "destributionPoint", "destificationHome", "destributionDir", "destributionFile", "destificationDir", "DestinationPoint", "DestinationPath"], "newDir": ["NewFolder", " newDirectory", " newFolder", "NewDir", "NewDirectory", "newDirectory", " newdir", "nextdir", "NewFile", "Newdir", "nextFolder", "nextDirectory", "newFolder", "nextDir", "newdir", "nextFile"], "children": ["rules", "iv", "url", "ins", "uc", "packages", "iblings", "roots", "which", "when", "ren", "child", "current", "sub", "members", "sort", "father", "kids", "filename", "parents", "values", "projects", "files", "words", "items", "ools", "rows", "parent", "loc", "each", "list", "begin", "ul", "events", "blocks", "mount", "opens", "content", "other", "pages", " Children", "data", "ums", "Children", "scenes", "balls", "collection", "names", "web", "pes", "tests"], "i": ["qi", "v", "lc", "k", "iv", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "q", "start", "end", "li", "ui", "u", "hi", "inner", "multi", "ci", "si", "mi", "ii", "m", "y", "j", "type", "ie", "info", "ori", "b", "n", "o", "slice", "ri", "uri", "p", "gi", "key", "h", "ix", "fi", "it", "di", "in", "oi", "d", "ji", "part", "mu", "f", "pi"], "newFile": ["createDir", "Newfile", "NewFiles", "oldFiles", " newDirectory", "nextfile", "createfile", "nextFiles", "NewDir", "NewDirectory", "newDirectory", "createSource", " newSourceFile", "NewFile", " newfile", "NewSource", "oldDir", " newFiles", "oldFile", "nextSource", "newfile", "newSource", "NewSourceFile", "nextSourceFile", "nextDir", "oldDirectory", "nextFile", "createFile", "newFiles", "newSourceFile"], "output": ["complete", "external", "flow", "address", "result", "oper", "error", "console", "change", "after", "current", "ou", "put", "Output", "target", "out", "core", "binary", "generation", "four", "ilo", "generated", "image", "write", "operation", "writer", "connection", "application", "object", "parent", "kernel", "o", "again", "config", "socket", "outer", "update", "display", "service", "resource", "option", "other", "page", "file", "unit", "web", "control", "response", "temp"], "input": ["exec", "flow", "error", "client", "reader", "audio", "feed", "current", "inc", "child", "raw", "Input", "operator", "request", "index", "keep", "out", "context", "stream", "inner", "image", "this", "self", "storage", "connection", "print", "text", "parent", "config", "pull", "socket", "buffer", "resource", "inf", "plus", "form", "http", "in", "data", "work", "before", "instance", "ink", "ack", "temp"], "buff": ["bind", "uf", "cf", "cod", "bb", "gb", "ob", "bin", "comb", "feed", "load", "cur", "boot", "fb", "length", "cp", "bug", "cmd", "bound", "fe", "info", "ph", "batch", "count", "b", "shape", "buf", "text", "cast", "Buff", "ff", "back", "oct", "slice", "pad", "hello", "buffer", "pack", "uff", "rb", "flush", "data", "char", "gz", "txt", "comment", "cb", "f"], "read": ["exec", "k", "ip", "send", "reader", "allow", "parse", "lex", "use", "id", "feed", "io", "load", "transfer", "check", "skip", "x", "readable", "ask", "index", "reading", "start", "length", "ind", "end", "seek", "play", "write", "next", "len", " load", "rate", "en", "type", "wait", "count", "b", "fill", "text", "n", "find", "Read", "config", "sync", "slice", "READ", "ok", "buffer", " write", "iter", "close", "add", "get", "se", "loop", "and", "reads", "pass", "ink", "open", " count", "size", "select", "f", "run"]}}
{"id1": "19934218", "id2": "5632808", "code1": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "        @Override\n        public void respondGet(HttpServletResponse resp) throws IOException {\n            setHeaders(resp);\n            final OutputStream os;\n            if (willDeflate()) {\n                resp.setHeader(\"Content-Encoding\", \"gzip\");\n                os = new GZIPOutputStream(resp.getOutputStream(), bufferSize);\n            } else os = resp.getOutputStream();\n            transferStreams(url.openStream(), os);\n        }\n", "label": 0, "substitutes": {"doCrypt": [" runCrypt", "DoMac", " runMac", "murDec", "DoExt", "DoCrypt", " runDec", " doExt", "DoDec", " doDec", "murCrypt", " runExt", "murExt", " doMac", "murMac"], "text": ["url", " Text", "token", "str", "path", "font", "input", "pattern", "string", "name", "binary", "ext", "obj", "length", "context", "seed", "struct", "image", "hex", "this", "word", "code", "editor", "format", "crypt", "connection", "class", "object", "config", "buffer", "message", "EXT", "key", "content", "Text", "in", "data", "source", "letter", " TEXT", "password", "secret", "contract", "value", "txt", "TEXT"], "UnsupportedEncodingException": ["UnsupportedEncodingError", "UnsupportedEncasingError", "UnsupportedEncodingEx", "UnsupportedEncoderError", "UnsupportedEncasingEx", "UnsupportedEncodedError", "UnsupportedEncoderException", "UnsupportedEncoderEx", "UnsupportedEncasingException", "UnsupportedEncodedException", "UnsupportedEncodedEx"], "md": ["mad", "MD", "hash", "map", " Md", "mc", "sha", "ms", "metadata", "rm", "pm", "bd", "valid", "amd", "am", "bm", "df", "mo", "meta", "mb", "mt", "cmd", "hd", "code", "mand", "m", "dd", "mode", "method", "def", "Cmd", "gd", "body", "sd", "od", "mg", "mm", "message", "ad", "ma", "pd", "ud", "wd", "mac", "mn", "mod", "dr", "me", "mp", "data", "hm", "ld", "d", "mag", "bf", "vd", "dm", "nm", " MD", "dig"], "sha1hash": ["SHA2sum", "sha6sha", "sha256h", "md1hash", "sha2hex", "shaonehex", "md6h", "sha6hex", "SHA2sha", "SHA1hash", "SHA2Hash", "SHA2hex", "SHA1Hash", "sha1Hash", "sha256hash", "sha5sha", "sha2h", "sha5Hash", "SHA1sha", "sha5hash", "sha2sum", "md6sha", "sha1sha", "sha2hash", "md1hex", "sha6h", "sha0sha", "md6hex", "sha1sum", "sha6hash", "sha0sum", "SHA1sum", "md1h", "md6hash", "sha2Hash", "shaonehash", "md1sha", "SHA2hash", "sha256hex", "sha5hex", "shaonesha", "sha1hex", "sha0hex", "sha1h", "sha256sum", "shaoneh", "sha0hash", "SHA2h", "SHA1hex", "sha256sha", "SHA1h", "sha256Hash", "sha2sha", "sha5h"]}}
{"id1": "771802", "id2": "9824814", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public void run() {\n        if (status == COMPLETE) {\n            return;\n        }\n        waitRandom();\n        RandomAccessFile file = null;\n        InputStream inputStream = null;\n        boolean success = false;\n        URL url = null;\n        try {\n            BeatportAccessor beatportAccessor = new BeatportAccessor();\n            if (sessionCookies == null) {\n                sessionCookies = beatportAccessor.getSessionCookies(user, password);\n            }\n            url = new URL(new BeatportAccessor().getTrackDownloadUrl(downloadId, sessionCookies));\n            log.info(\"Open (DownloadWorker.run): \" + url);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", BeatportAccessor.userAgent);\n            connection.setRequestProperty(\"Cookie\", sessionCookies);\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                log.error(\"Unexpected response from server: \" + connection.getResponseCode());\n                error();\n                return;\n            }\n            if (connection.getContentType().indexOf(\"text\") >= 0) {\n                log.error(\"Tried to request: \" + url.toString());\n                log.error(\"Unexpected file content type from server: \" + connection.getContentType());\n                log.error(\"Server replied:\\n\" + getContentAsString(connection));\n                error();\n                return;\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                log.error(\"Invalid content length: \" + connection.getContentLength());\n                error();\n                return;\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            } else if (size != contentLength) {\n                changeTotal(0, contentLength - size);\n            }\n            if (new File(tmpFileName(fileName)).exists()) {\n                if (!new File(tmpFileName(fileName)).delete()) {\n                    throw new Exception(\"Could not delete file: \" + tmpFileName(fileName));\n                }\n            }\n            file = new RandomAccessFile(tmpFileName(fileName), \"rw\");\n            file.seek(downloaded);\n            inputStream = connection.getInputStream();\n            if (started == 0) {\n                started = System.currentTimeMillis();\n                time = started;\n            }\n            statusChangedObserver.statusChanged(status);\n            byte buffer[] = new byte[MAX_BUFFER_SIZE];\n            while (status == DOWNLOADING) {\n                if (size - downloaded < MAX_BUFFER_SIZE) {\n                    buffer = new byte[(int) (size - downloaded)];\n                }\n                int read = inputStream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                changeTotal(read, 0);\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                stopped = System.currentTimeMillis();\n                status = COMPLETE;\n            }\n            statusChangedObserver.statusChanged(status);\n            stateChanged();\n            success = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            error();\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n            if (success) {\n                try {\n                    if (!new File(tmpFileName(fileName)).renameTo(new File(fileName))) {\n                        throw new Exception(\"Rename Failed\");\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error moving temp file \" + tmpFileName(fileName) + \" file: \" + fileName, e);\n                }\n            } else {\n                try {\n                    new File(tmpFileName(fileName)).delete();\n                } catch (Exception e) {\n                    log.error(\"Error deleting erroneous temp file: \" + tmpFileName(fileName), e);\n                }\n            }\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                log.error(\"Error closing input stream of: \" + url + \" / \" + fileName, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createOutputStream": [" createInputReader", "createInputFile", " createIOReader", "createInputSteam", " createOutputReader", " createIOFile", " createByteReader", "createOutputReader", "createInputStream", " createOutputSteam", " createByteFile", "createOutputFile", " createInputSteam", " createIOStream", " createOutputFile", "createInputReader", " createInputStream", " createByteStream", " createInputFile", "createOutputSteam", " createIOSteam", " createByteSteam"], "inFile": ["sourceFiles", "sourceStream", "inputFile", "incFile", "outStream", "infile", "insfile", "inputStream", "incfile", "sourcefile", "inStream", "insFile", "incStream", "sourceFile", "inputFiles", "incFiles", "insStream", "outfile", "inFiles", "outFiles", "insFiles", "inputfile"], "outFile": ["workingfile", "outDir", "inputDir", "workFile", "targetFile", "inputFile", "workTime", "workingStream", "targetfile", "outStream", "workfile", " outfile", "infile", "outDirectory", "inTime", "workDir", "inputTime", " outStream", " outDirectory", "targetStream", "targetDirectory", "outTime", "outfile", "workingFile", "inDir", "workingDirectory", "inputfile"], "k_blockSize": ["k_lockCount", "k_BlockLength", "k_BlockCode", "k_byteCode", "k_byteLength", "k_lineInfo", "k_BlockSize", "k_blockCount", "k_blocksSize", "k_byteLen", "k_bitSize", "k_lineCount", "k_blocksCount", "k_bitCount", "k_lockLength", "k_lockLen", "k_BlockCount", "k_blockLen", "k_byteSize", "k_blocksLen", "k_bitInfo", "k_blockInfo", "k_blockCode", "k_byteCount", "k_lockCode", "k_blocksLength", "k_lineSize", "k_lockSize", "k_byteInfo", "k_blockLength"], "byteCount": [" bytecount", "blockSum", "byteSize", "bytecount", "byteLength", "flushCount", " byteSize", "flushcount", "characterCount", "blockSize", "blockCount", "characterLength", "blockLength", "Bytecount", "ByteSize", "byteSum", "flushLength", "ByteCount", " byteLen", "byteLen", "characterSize", "ByteLength", "ByteSum", " byteSum", "ByteLen", "flushSize", "characterLen", " byteLength"], "buf": ["vec", "uf", "Buffer", "cap", "result", "base", "img", "exc", "tmp", "cv", "feed", "brace", "font", "ctx", "fb", "border", "seq", "cmd", "queue", "len", "alloc", "bag", "Buff", "batch", "b", "background", "loc", "config", "buffer", "la", "bytes", "rb", "flush", "cas", "fd", "feat", "rc", "ucc", "data", "append", "bh", "src", "bf", "cb", "buff"], "ofp": ["fort", "afc", "Ofnp", "afp", "OFl", "forc", "ofnp", "Oft", "oftp", "forp", "OFt", "Ofp", "OFp", "oft", "ofl", "afl", "ofc", "afnp", "fortp", "OFc", "OFnp", "Ofc", "Oftp", "Ofl", "OFtp"], "zos": ["osi", "outs", "kos", "core", "zon", "budget", "zes", "os", "modules", "ozo", "zyk", "los", "ossus", "cos", "jas", "inos", "robe", "ZI", "zik", "utils", "zy", "enos", "soon", "ls", "zen", "zona", "zn", "iframe", "zi", "css", "rons", "zag", "hz", "abi", "forge", "bes", "obb", "ros", "oS", "bitcoin", "zar", "ZA", "zh", "zip", "zers", "oda", "liquid", "tz", "zl", "webkit", "bos", "owicz", "js", "za", "lins", "oses", "zx", "nz", "rez", "gz", "lol", "dylib", "z", "zin", "ws", "uz", "ses", "cfg", "iffs", "zer", "ops", "zo", "fits", "zig", "ogl", "obs", "zb", "packs", "nox", "bs"], "osw": ["lsx", "osww", "ishell", "esow", "bwo", "ossww", "essw", "oshell", "esw", "lsws", "oswo", "esnow", "osssw", "lswo", " osow", "bx", "osnow", "bsws", "osow", "ossw", "bsw", "bws", "esfw", "osswd", "isy", "isnow", "isw", "ossnow", "ossd", "esd", "osy", "osshell", " osww", "osws", "esww", "isd", "esy", "lsw", "ossow", "eswd", "iswd", " osfw", "ossfw", "issw", "ossy", "bswo", "osfw", "eshell", "bsx", "osx", "osd", "oswd"], "bw": ["lbwh", "abW", "bbz", "bbw", "abw", "bW", "bbew", "bbwa", " bwh", " bws", "lwa", "lbw", "bwa", "Bws", "baw", "bbws", " bwa", "owa", "bx", "fbwd", "bwu", "ebwd", "bwd", "lx", "bsw", "Bwa", "bwh", "bz", "bws", "lbws", "ebw", "fsw", "fbwe", "lbwa", "Bew", "fbW", "fx", "fwh", "bwe", "lbr", " bwu", "Bw", "lw", "bbwu", "lbx", "ow", "owu", "lsw", "fr", "fwa", "lbsw", "abwe", "bew", " baw", "lbz", "ebwe", "fbw", "fw", "bbaw", " bz", " bew", "ebW", "oaw", "bbwh", "abwd"], "zot": ["jot", "zott", " zor", "jori", "Ziot", "azit", "zerot", "jit", "Zor", "zita", "azita", "zeros", " ziot", "azot", "zor", "jos", "azott", "zerott", "zerita", " zori", "aziot", "Zott", "zori", "Zot", "azor", "zerori", "ziot", "Zita", "Zit", "zerit"], "ifp": ["ipl", "ipc", "iff", " ifb", "Iff", " ifi", "IFi", "ifb", "Ifi", "IFf", " ifl", "IFb", "ifi", "ipp", " ifc", "IFp", "ifc", "ipb", "IFl", "Ifc", "IFc", "ifl", "Ifp", " iff"], "zis": ["zipis", "xib", " zits", " zisi", "zeis", "xis", "zip", "zeip", " zib", "jit", " zIS", "Zits", "Ziss", "jits", "zenIS", "xits", "zeits", "zenib", "xais", "zais", "jisi", "xisi", "zenais", "Zis", "jis", "zipiss", "zib", "zIS", "zipits", "zisi", "xIS", "zipip", "zenis", "zeiss", "Zip", "zits", "xit", " zais", "ziss"], "isr": ["IScr", "isrs", "risr", " issr", "issrs", "risrc", "isrc", "rispr", "isrb", "isscr", "ISsr", "irpr", "ISrs", "isssr", "irrb", "ispr", "ISrc", "ISrb", "ISpr", " isrs", "irrc", "risrb", "ISr", " iscr", "iscr", "issr", "irr"], "br": ["yr", "bc", "obl", "img", "mr", "sr", "str", "ob", "bp", " Br", "ibr", "ber", "HR", "arr", "div", "hr", "rib", "bsp", "obi", "bro", "err", "bl", "Br", "r", "b", "kr", "browser", "bar", "body", "tr", " dr", "fr", "lr", "ibl", "rb", " fr", " BR", "BR", "ch", "bh", "gr", "cro", "sp", "ctr", "rs", "shr", "ocr"], "zit": ["zenits", "zenitter", " zits", "zipit", "zipitter", "zenit", "zip", "zenith", "xi", "jita", " zip", "zipita", "jit", "zipith", "zeit", "jits", " zite", "zith", "jith", "zita", "zeits", "zIT", "zeIT", "zeith", "zipIT", "zitter", "jite", "zi", "xith", "xic", " zic", " zith", "zeitter", "zite", "jip", "zipits", "zipite", "jic", "zipip", "ji", "zits", "xit", "zic", "jIT", "zeita", " zi"]}}
{"id1": "3309233", "id2": "4168534", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "label": 0, "substitutes": {"doInBackground": ["buildInBackground", " doAsyncBackground", " doUsingBackground", " doAsyncConsole", "buildUsingStudio", " doAsBackground", "buildUsingBackground", " doAsConsole", " doAsyncAsync", " doInConsole", " doUsingAsync", " doUsingStudio", " doAsyncStudio", "buildInAsync", " doAsStudio", " doInAsync", "buildUsingConsole", " doInStudio", "buildUsingAsync", " doUsingConsole", "buildInStudio", "buildInConsole", " doAsAsync"], "params": ["address", "services", "objects", "posts", "types", "eps", "parse", "Param", "pm", "reports", "Parameters", "py", "values", "ls", "Par", "lines", "s", "resources", "results", "files", "comments", "strings", "properties", "type", "i", "arms", "options", "par", "ps", "config", "mes", "pins", "ds", "los", "parts", "p", "phrase", "ams", "page", "source", "data", "keys", "json", "details", "sp", "names", "ctx", "settings"], "param": ["cm", "address", "monitor", "lc", "mor", "amp", "project", "Param", "comment", "pm", "pri", "model", "camp", "proc", "am", "path", "default", "prem", "conn", "name", "string", "prom", "cp", "iam", "Parameter", "mand", "connection", "gram", "null", "object", "par", "parent", "arm", "km", "config", "mm", "rem", "option", "p", " parameter", "meter", "single", "aram", "channel", "pool", "pb", "ams", "vm", "password", "page", "contract", "pc", "ram", "part", "conf", "ctx", "temp"], "client": ["cm", "url", "cl", "base", "project", "app", "force", "proxy", "request", "plugin", "session", "host", "connect", "conn", "secure", "cp", "c", "comp", "self", "bird", "ssl", "connection", "handler", "Client", "config", "apache", "service", "api", "resource", "p", "http", "cli", "channel", "server", "google", "help", "con", "ce", "response"], "post": ["base", "send", "e", "pod", "zip", "pre", "load", "feed", "put", "proc", "request", "patch", "hop", "next", "set", "c", "upload", "dd", "head", "body", "query", "install", "api", "p", "add", "form", "http", "wp", "submit", "entry", "op", "pb", "push", "Post", "server", "pos", "create", "and", "posted", "POST", "pp", "json", "part", "comment", "f", "response"], "resp": ["exec", "error", "Resp", "received", " response", "status", "re", "rh", "rel", "e", "Response", "request", "comm", "res", "conn", "obj", "rep", "success", "err", "respond", "par", "body", "handler", "rec", "enc", "fc", "api", "resource", "content", "http", "page", "server", "download", "ref", "req", "reply", "json", "sp", "serv", "response"], "entity": ["base", "status", "ity", "output", "e", "el", "model", "xml", "node", "string", "conn", "obj", "code", "ec", "event", "element", "connection", "ent", "object", "body", "enc", "attribute", "resource", "person", "agent", "content", "translation", "Entity", "line", "data", "entry", "article", "instance", "coll", "json", "activity", "unit", "response"], "result": ["address", "url", "description", "place", "status", "output", "Result", "default", "row", "res", "string", "location", "name", "ret", "success", "results", "report", "desc", "object", "text", "message", "resource", "property", "content", "translation", "page", "line", "entry", "data", "match", "source", "record", "instance", "value", "json", "details", "response"]}}
{"id1": "3252116", "id2": "10176678", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "label": 0, "substitutes": {"getMD5": ["getMAC3", "getMP4", "getMP3", "getSHA4", " getSHA4", "getMAC5", "getSHA3", "getMD4", "getMAC4", "getSHA5", "getMP512", "getSHA512", "getMP5", " getSHA5", " getMD3", " getMD4", "getMD3", "getMD512", " getSHA512", " getMD512", "getMAC512", " getSHA3"], "source": ["ource", "fp", "url", "result", "base", "output", "e", "security", "sl", "input", "target", "string", "stream", "Source", "this", "code", "connection", "text", "object", "parent", "body", "dest", "config", "slice", "buffer", "uri", "service", "resource", "content", "from", "document", "data", "file", "password", "secret", "src", "sp", "f", "SOURCE"], "s": ["services", "ins", "e", "sets", "ts", "rs", "series", "bis", "ws", "sl", "es", "ns", "string", "ls", "results", "si", "als", "ses", "os", "sg", "strings", "m", "t", "ssl", "sb", "r", "g", "b", "js", "n", "rows", "ops", "ps", "sym", "S", "ends", "ds", "fs", "p", "bytes", "h", "its", "is", "d", "ss", "f", "gs", "ings"], "hexDigits": ["hexDigats", "hashDigists", "hexSignists", "hexDigites", "hexFormists", "hexDigists", "hexDigit", "hexdigists", "hashFormits", "hexdigites", "hexSignases", "tempSignites", "hexdigases", "hexdigats", "hexSignites", "hexSignals", " hexDigit", "hashDigits", "hexSignits", "hashDigats", "hexdigits", "hexEdists", "hexFormats", "hexdigings", "hexDigals", "hexEdites", "hexFormitives", "tempDigits", "tempSignists", "tempDigals", "tempDigists", " hexDigases", "hexDigases", "hexdigit", "hashFormists", "tempSignals", "hexSignitives", "hashDigitives", "hexEdits", "hexDigings", "hexFormits", "hexDigitives", "hashFormitives", "hashFormats", "hexEdals", "hexSignings", "tempDigites", "hexSignit", "hexdigals", "hexSignats", "tempSignits", " hexDigings", "hexdigitives"], "md": ["mad", "MD", "cm", "mc", "sha", "dig", "metadata", "rm", "pm", "bd", "amd", "am", "df", "um", "meta", "mb", "mt", "cmd", "hd", "sm", "mi", "rpm", "mand", "m", "dd", "mg", "mm", "ma", "mail", "pd", "cd", "dc", "em", "wd", "mac", "di", "mag", "bf", "nm", "dm", "vd", "f", "mu", " MD", "mp"], "tmp": ["v", "test", "stuff", "base", "params", "img", "sup", "now", "bp", "app", "pre", "proc", "meta", "ppo", "fb", "pointer", "seed", "obj", "np", "storage", "extra", " temp", "buf", "dest", "bt", "config", "pad", "buffer", "array", "api", "p", "rb", "wp", "data", "append", "pp", "area", "sp", "cpp", "txt", "cb", "buff", "mp", "cmp", "temp"], "str": ["exec", "v", "st", "dec", "sr", "br", "exp", "dict", "arr", "sec", "cur", "div", "sl", "string", "obj", "hr", "inner", "cr", " sp", "err", "spec", "doc", "hex", "code", "Str", "j", "r", "ctr", "text", "cs", "tr", "STR", "enc", "fr", "iter", " substr", "dr", "stri", "txt", "data", "char", "style", "pos", "sp", "unit", "ss", "part", "pr", "temp"], "k": ["v", "kid", "dk", "w", "e", "id", "kick", "x", "kw", "ks", "q", "mk", "ku", "u", "ak", "K", "c", "kk", "unk", "y", "j", "sk", "g", "b", "n", "o", "ki", "ek", "ok", "p", "key", "ck", "work", "ch", "kat", "d", "ko", "f"], "i": ["qi", "v", "z", "ip", "ai", "ti", "I", "e", "io", "iu", "xi", "x", "ini", "index", "u", "ui", "li", "hi", "multi", "c", "ci", "si", "phi", "ii", "y", "m", "j", "t", "a", "info", "b", "n", "bi", "ri", "uri", "p", "gi", "it", "abi", "in", "oi", "di", "l", "shift", "d", "chi", "ji", "mu", "f", "pi"], "byte0": ["word0", "byte2", "number6", "word5", "letter2", "pixel5", " byte6", "byte5", "byte1", "byte6", "letter00", "number1", "byte00", "pixel0", "bytek", "pixel00", "pixelk", " byte2", "word1", "number00", " byte1", "number0", "pixel6", "pixel2", "letterk", "numberk", "number2", "word2", " byte5", "number5", "letter0", " byte00"]}}
{"id1": "15580610", "id2": "12380475", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"trainClassifier": ["trainclassification", "trainModelifier", "trainModelLoader", "trainModelification", " trainclassification", "trainTestify", " trainClassify", "trainTestLoader", "trainClassLoader", "trainClassification", " trainClassLoader", "trainClassify", " trainclassLoader", "trainTestification", "trainclassify", " trainClassification", "trainclassLoader", "trainModelify", "trainclassifier", "trainTestifier", " trainclassify", " trainclassifier"], "dir": ["md", "url", " directory", "base", "project", "output", "window", "Dir", "model", "db", "path", "folder", "div", "target", "filename", "name", "out", "domain", "doc", "database", "files", "lib", "build", "report", "class", "root", "directory", "object", "DIR", "config", "direction", "loc", "uri", "cd", "du", "wd", "fd", "di", "data", "file", "dist", "d", "group", "home", "env", "module"], "command": ["exec", "slave", "error", "sudo", "system", "project", "delete", "force", "which", "child", "model", "volume", "shell", "path", "request", "one", "function", "input", "pattern", "machine", "string", "sequence", "name", "language", "cmd", "word", "action", "archive", "domain", "image", "argument", "database", "this", "clear", "operation", "reason", "event", "menu", "connection", "history", "component", "root", "info", "directory", "program", "category", "config", "query", "message", "array", "attribute", "service", "media", "usage", "document", "cli", "move", "power", "help", "password", "file", "control", "and", "three", "script", "Command", "comment", "module"], "length": ["position", "level", "now", "left", "id", "prime", "zip", "creator", "distance", "sequence", "end", "max", "time", "range", "section", "angle", "word", "inner", "len", "character", "dim", "or", "type", "Length", "duration", "count", "ength", "class", "ph", "number", "shape", "body", "join", "both", "th", "head", "span", "slice", "loc", "padding", "depth", "how", "strength", "form", "l", "match", "last", "power", "letter", "width", "before", "style", "limit", "capacity", "square", "value", "full", "part", "sum", "size"], "process": ["exec", "result", "processor", "master", "share", "cess", "console", "system", "status", "call", "parse", "project", "output", "handle", "app", "use", "child", "proc", "worker", "path", "function", "session", "host", "python", "out", "machine", "thread", "cmd", "this", "component", "connection", "method", "pid", "class", "application", "user", "parent", "program", "task", "sync", "post", "display", "service", "p", "plus", "document", "file", "processing", "Process", "script", "group", "run"]}}
{"id1": "12055086", "id2": "15445861", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copyDeletging", " copydeleing", " copyDeleing", " copyDeleteting", " copyDeleging", " copydeletting", " copyDeletting", " copyDeletter", " copyDeleteter", " copyDequeter", " copyDeleter", " copyDeleteing", " copydeleter", " copydeleging", " copyDequeging", " copydeleting", " copyDequeting", " copyDeleteging", " copydeletging", " copydeletter", " copyDequeing"], "source": ["ource", "base", "master", "reader", "cache", "view", "site", "use", "e", "path", "remote", "input", "target", "s", "stream", "inner", "archive", "image", "Source", "down", "storage", "ie", "connection", "i", "route", "sin", "config", "ources", "iter", "service", "resource", "from", "copy", "file", "src", "f", "SOURCE"], "dest": ["slave", "de", "result", "master", "thin", "img", "bin", "tmp", "comb", "path", "folder", "default", "target", "flat", "destruct", "Dest", "class", "orig", "desc", "null", "pipe", "slice", "wb", "done", "content", "destroy", "file", "dir", "dist", " destination", "src", "die", "later", "home", "opt", "trans", "exit", "temp"], "buf": ["Buffer", "uf", "vec", "bc", "result", "base", "img", "uc", "br", "tmp", "port", "cv", "bd", "bp", "feed", "raw", "ctx", "fb", "length", "seq", "cp", "cmd", "queue", "len", "off", "bag", "code", "batch", "b", "ff", "config", "loc", "pad", "buffer", "bytes", "rb", "feat", "rc", "data", "append", "bh", "pos", "src", "bf", "txt", "cb", "buff"], "in": ["exec", "url", "gin", "ins", "thin", "din", "reader", "IN", "login", "bin", "id", "isin", "inc", "io", "ini", "input", "In", "conn", "inner", "stream", "image", "c", "read", "i", "b", "n", "again", "sin", "tin", "socket", "nin", "win", "inn", "p", "min", "pin", "plus", "is", "data", "up", "file", "inside", "init", "src", "rin", "con", "f"], "out": ["exec", "img", "client", "OUT", "outs", "w", "output", "bin", "app", "exp", "io", "inc", "conn", "ext", "obj", "inner", "image", "err", "down", "Out", "lib", "at", "writer", "i", "b", "ex", "n", "again", "o", "parent", "sync", "socket", "win", "outer", "buffer", "pool", "file", "up", "part", "f"], "count": ["base", "cache", "allow", "handle", "use", "id", "feed", "current", "child", "zip", "path", "Count", "index", "val", "start", "length", "ind", "max", "name", "offset", "lock", "c", "len", "code", "read", "all", "type", "b", "number", "n", "parent", "weight", "cond", "buffer", "depth", "close", "key", "pool", "ch", "num", "limit", "coll", "part", "sum", "size", "f"]}}
{"id1": "9805906", "id2": "22366505", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"dump": ["ump", "save", "transfer", "Dir", "zip", "load", "db", "df", " dumps", "export", "out", "ln", " dumping", "files", " dumped", "all", "info", "println", "diff", "update", "flush", "copy", "store", "data", "dir", "download", "f"], "source": ["ource", "slave", "address", "base", "view", "site", "use", "current", "scene", "series", "remote", "input", "start", "core", "string", "s", "stream", "Source", "this", "connection", "parent", "sin", "slice", "ources", "uri", "service", "resource", "iter", "from", "http", "file", "server", "se", "src", "unit", "SOURCE"], "target": ["template", "address", "result", "base", "master", "alias", "arget", "project", "follow", "output", "port", "platform", "force", "replace", "path", "goal", "pointer", "host", "out", "top", "effect", "to", "next", "database", "large", "Target", "connection", "root", "enemy", "null", "object", "parent", "dest", "table", "office", "resource", "it", "file", "src", "settings"], "is": ["us", "im", "ais", "ip", "ins", "ai", "ois", "iso", "isa", "was", "io", "has", "IS", "bis", "ws", "Is", "es", "oss", "abs", "ui", "s", "ris", "ls", "isl", "iss", "ios", "ses", "nis", "or", "bos", "ori", "i", "info", "cs", "ops", "lis", "ps", "isi", "ics", "oses", "opens", "iris", "gets", "obs", "in", "ists", "its", "ens", "as", "bs", "mis"], "os": ["us", "ais", "OS", "osi", "Os", "nos", "outs", "io", "aos", "vs", "boot", "es", "ies", "oss", "ks", "ues", "s", "oes", "ios", "or", "bos", "ori", "i", "oos", "acs", "dos", "cs", "ops", "ose", "o", "ps", "ows", "oses", "ds", "los", "fs", "ols", "its", "ips", "obs", "cos", "oa", "ens", "pos", "ros", "as", "ss", "bs"], "done": ["complete", "foo", "defined", "de", "doing", "odo", "started", "yes", "after", "current", "nice", "progress", "ready", "got", "none", "one", "enabled", "always", "finished", "made", "next", " Done", "dirty", "checked", "confirmed", "running", "gone", "empty", "did", "dad", "future", "disabled", "loaded", " finished", "once", "data", "last", "due", "die", "later", "part", "Done", "expected"]}}
{"id1": "15241397", "id2": "14758866", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", "handleGET", "didget", " doPut", "didGET", "handlePut", "doGET", "didGet", "handleget", " doget", "didPut", "doget", "doPut", "handleGet"], "request": ["complete", "url", "result", "client", "reader", "received", "QUEST", "xml", "input", "er", "context", "queue", "image", "event", "type", "connection", "method", "report", "info", "application", "user", "object", "query", "message", "uri", "buffer", "resource", "Request", "document", "http", "data", "server", "subject", "req", "instance", "initial", "web"], "response": ["result", "error", "esi", "client", "status", "output", "view", "site", "model", "Response", "function", "host", "session", "out", "generation", "queue", "image", "next", "results", "respond", "writer", "connection", "report", "application", "object", "body", "parent", "message", "resource", "version", "wave", "document", "other", "page", "data", "resp", "server", "pool", "full", "reply", "onse", "json", "collection"], "rewrittenQueryString": ["rewwrittenQueryStr", "rewrittenUrlString", "rewrittenRequestString", "rewrittenPageArray", "rewwrittenRequestString", "rewwrittenQueryString", "rewrittenQuestionText", "rewwrittenQueryArray", "rewrittenQuestionArray", "rewrittenqueryString", "rewwrittenRequestService", "rewrittenQueryStr", "rewwrittenQueryText", "rewwrittenQueryService", "rewrittenqueryService", "rewrittenQueryList", "rewrittenRequestLine", "rewrittenUrlText", "rewrittenRequestText", "rewwrittenQueryList", "rewrittenRequestArray", "rewrittenUrlService", "rewrittenRequestList", "rewrittenQueryLine", "rewrittenQuestionLine", "rewrittenqueryLine", "rewrittenQueryArray", "rewrittenQuestionString", "rewrittenRequestStr", "rewwrittenRequestText", "rewrittenQueryText", "rewrittenqueryText", "rewwrittenRequestArray", "rewrittenPageString", "rewrittenUrlLine", "rewrittenRequestService", "rewrittenQuestionStr", "rewwrittenQueryLine", "rewrittenPageList", "rewrittenqueryStr", "rewwrittenRequestLine", "rewwrittenRequestList", "rewwrittenRequestStr", "rewrittenPageLine", "rewrittenQuestionList", "rewrittenQueryService"], "rewrittenUrl": ["RewrittenJar", "RewwrittenText", "rerittenLanguage", "rewardedURL", "rewardedUr", "rewmatchedURL", "rewrapedURL", "rewwrittenServer", "rewwrittenURL", "rerittenUrl", "rewardedLanguage", "rewmatchedFile", "rewedUr", "rewilledUrl", "rewrapedFile", "RewwrittenServer", "rewilledJar", "rewcraftedLocation", "rewodedUrl", "rewardedFile", "RewrittenURL", "rewatchedUrl", "rewatchedURL", "RewrittenServer", "rewrittenInt", "Rewwrittenurl", "rewodedFile", "rewriteText", "RewwrittenUrl", "rewardedJar", "rewedurl", "rewcraftedURL", "rewcraftedUr", "rewwrittenUr", "rewrittenLocation", "RewrittenFile", "RewwrittenURL", "rewardedInt", "rewmatchedUrl", "rewrittenJar", "RewrittenText", "rerittenFile", "rewrapedUr", "rewrittenServer", "rewatchedServer", "RewwrittenJar", "rewardedLocation", "rewwrittenLanguage", "rewedFile", "RewrittenInt", "rewrittenFile", "rewedURL", "rewwrittenFile", "rewardedUrl", "RewrittenUr", "rewrittenUr", "rewriteServer", "rewatchedText", "rewrittenText", "RewwrittenInt", "rewodedLanguage", "RewwrittenLocation", "rewwrittenJar", "RewrittenUrl", "rewilledInt", "rewmatchedurl", "Rewrittenurl", "rewilledURL", "RewwrittenFile", "rewwrittenurl", "rewriteURL", "rerittenUr", "rewcraftedUrl", "rerittenURL", "RewrittenLocation", "rewwrittenUrl", "rewrittenURL", "rewrittenurl", "rewwrittenLocation", "rewrapedUrl", "rewrittenLanguage", "rewodedURL", "rewwrittenInt", "RewwrittenUr", "rewedUrl", "rewwrittenText", "rewriteUrl"], "httpURLConnection": ["httpSSLConn", " httpURConnect", " httpStreamCurrent", "webURLConnection", "HttpURLConnection", " httpUrlConn", " httpURLConn", "httpURIconnection", "httpWebConnection", "webSSLConnection", "httpURLContext", "httpURLConn", "httpWebConnect", "httpELConn", "httpURLService", " httpURLConnect", " httpURConn", "httpURLconnection", "httpURLClient", "webURLClient", "httpGEconnection", "httpURIConnection", " httpStreamConnection", "httpPathconnection", "httpGEConnect", "httpurlSession", " httpURLSession", "httpWebConn", "httpUrlconnection", "httpCLConn", "httpURLCode", "httpUrlConnection", "httpURConn", "httpELConnection", "httpURIConn", "httpChannelConnection", "apacheURLconnection", "httpURconnection", "httpUrlContext", "HttpURLService", "httpStreamconnection", "httpUrlConnect", "httpurlConnection", "webURLConn", "httpChannelConnect", "httpURLSession", "httpPathSession", "httpURConnection", "httpStreamConnection", "httpELConnect", "apacheGEConnect", " httpURLCurrent", "httpurlCurrent", "httpSSLClient", "webSSLConn", " httpURConnection", " httpStreamconnection", " httpURLconnection", "httpChannelconnection", "HttpURLconnection", "httpURIFlow", "webSSLClient", "httpURIContext", "httpPathCurrent", "apacheGEconnection", "httpStreamCurrent", "httpGEFlow", " httpStreamSession", "httpURLFlow", "httpCLCode", "apacheGEFlow", " httpURLCode", "httpurlConnect", "httpurlFlow", "apacheGEConnection", "webSSLContext", "httpGEConnection", " httpUrlCode", "apacheURLConnect", "HttpChannelConnection", "httpUrlService", "httpurlConn", "httpurlCode", "apacheURLFlow", "httpSSLContext", "httpURLCurrent", "httpUrlConn", "httpurlconnection", "httpURConnect", "httpURIClient", "httpUrlClient", "httpURService", "HttpChannelService", "httpPathConnection", "httpURIConnect", "httpSSLConnection", "webURLContext", " httpUrlConnection", "HttpURLConnect", "httpUrlCode", "httpCLConnection", "HttpChannelConnect", "HttpChannelconnection", "httpStreamSession", "httpChannelService", "httpURLConnect", "apacheURLConnection"], "header": ["hash", "feature", "pair", "result", "item", "master", "error", "column", "token", "ter", "metadata", "after", "cover", "default", "function", "index", "er", "string", "bridge", "driver", "queue", "section", "next", "character", "layer", "event", "component", "writer", "info", "reference", "definition", "player", "head", "rule", "handler", "Header", "back", "list", "block", "headers", "outer", "buffer", "message", "iter", "version", "date", "her", "attribute", "key", "document", "dr", "line", "consumer", "entry", "filter", "server", "channel", "data", "match", "member", "director", "field", "second", "group", "part", "comment", "author"], "value": ["v", "sv", "description", "now", "current", "valid", "child", "Value", "model", "default", "function", "val", "label", "string", "name", "values", "end", "language", "set", "expression", "format", "type", "VALUE", "info", "element", "object", "text", "parent", "hello", "message", "office", "media", "version", "option", "property", "attribute", "key", "content", "V", "gi", "get", "document", "entry", "data", "server", "letter", "password", "variable", "field", "json", "comment", "item"], "inputStream": ["pullStreamer", "pullSteam", "inputSteam", "outputStreamer", "pullStream", "resourcestream", "InputChannel", "resourceSteam", "outputChannel", "resourceStream", "resourceChannel", "outputSteam", "InputStreamer", "Inputstream", "outputstream", "InputSteam", "inputstream", "inputChannel", "inputStreamer", "pullstream", "InputStream"], "outputStream": ["OutputFile", " outputSteam", "inputSteam", "outputStreamer", "OutputChannel", "OutputSteam", "externalStream", "outputChannel", "OutputStream", "externalstream", "externalSteam", "responseSteam", "outputSteam", "OutputStreamer", "responseStream", "outputstream", "responseChannel", "externalStreamer", "Outputstream", "responseFile", " outputChannel", " outputFile", "inputstream", "inputStreamer", "outputFile"]}}
{"id1": "3252116", "id2": "22022715", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMAC3", "getMP4", "getMP3", "getSHA4", " getSHA4", "getMAC5", "getSHA3", "getMD4", "getMAC4", "getSHA5", "getMP512", "getSHA512", "getMP5", " getSHA5", " getMD3", " getMD4", "getMD3", "getMD512", " getSHA512", " getMD512", "getMAC512", " getSHA3"], "source": ["ource", "fp", "url", "result", "base", "output", "e", "security", "sl", "input", "target", "string", "stream", "Source", "this", "code", "connection", "text", "object", "parent", "body", "dest", "config", "slice", "buffer", "uri", "service", "resource", "content", "from", "document", "data", "file", "password", "secret", "src", "sp", "f", "SOURCE"], "s": ["services", "ins", "e", "sets", "ts", "rs", "series", "bis", "ws", "sl", "es", "ns", "string", "ls", "results", "si", "als", "ses", "os", "sg", "strings", "m", "t", "ssl", "sb", "r", "g", "b", "js", "n", "rows", "ops", "ps", "sym", "S", "ends", "ds", "fs", "p", "bytes", "h", "its", "is", "d", "ss", "f", "gs", "ings"], "hexDigits": ["hexDigats", "hashDigists", "hexSignists", "hexDigites", "hexFormists", "hexDigists", "hexDigit", "hexdigists", "hashFormits", "hexdigites", "hexSignases", "tempSignites", "hexdigases", "hexdigats", "hexSignites", "hexSignals", " hexDigit", "hashDigits", "hexSignits", "hashDigats", "hexdigits", "hexEdists", "hexFormats", "hexdigings", "hexDigals", "hexEdites", "hexFormitives", "tempDigits", "tempSignists", "tempDigals", "tempDigists", " hexDigases", "hexDigases", "hexdigit", "hashFormists", "tempSignals", "hexSignitives", "hashDigitives", "hexEdits", "hexDigings", "hexFormits", "hexDigitives", "hashFormitives", "hashFormats", "hexEdals", "hexSignings", "tempDigites", "hexSignit", "hexdigals", "hexSignats", "tempSignits", " hexDigings", "hexdigitives"], "md": ["mad", "MD", "cm", "mc", "sha", "dig", "metadata", "rm", "pm", "bd", "amd", "am", "df", "um", "meta", "mb", "mt", "cmd", "hd", "sm", "mi", "rpm", "mand", "m", "dd", "mg", "mm", "ma", "mail", "pd", "cd", "dc", "em", "wd", "mac", "di", "mag", "bf", "nm", "dm", "vd", "f", "mu", " MD", "mp"], "tmp": ["v", "test", "stuff", "base", "params", "img", "sup", "now", "bp", "app", "pre", "proc", "meta", "ppo", "fb", "pointer", "seed", "obj", "np", "storage", "extra", " temp", "buf", "dest", "bt", "config", "pad", "buffer", "array", "api", "p", "rb", "wp", "data", "append", "pp", "area", "sp", "cpp", "txt", "cb", "buff", "mp", "cmp", "temp"], "str": ["exec", "v", "st", "dec", "sr", "br", "exp", "dict", "arr", "sec", "cur", "div", "sl", "string", "obj", "hr", "inner", "cr", " sp", "err", "spec", "doc", "hex", "code", "Str", "j", "r", "ctr", "text", "cs", "tr", "STR", "enc", "fr", "iter", " substr", "dr", "stri", "txt", "data", "char", "style", "pos", "sp", "unit", "ss", "part", "pr", "temp"], "k": ["v", "kid", "dk", "w", "e", "id", "kick", "x", "kw", "ks", "q", "mk", "ku", "u", "ak", "K", "c", "kk", "unk", "y", "j", "sk", "g", "b", "n", "o", "ki", "ek", "ok", "p", "key", "ck", "work", "ch", "kat", "d", "ko", "f"], "i": ["qi", "v", "z", "ip", "ai", "ti", "I", "e", "io", "iu", "xi", "x", "ini", "index", "u", "ui", "li", "hi", "multi", "c", "ci", "si", "phi", "ii", "y", "m", "j", "t", "a", "info", "b", "n", "bi", "ri", "uri", "p", "gi", "it", "abi", "in", "oi", "di", "l", "shift", "d", "chi", "ji", "mu", "f", "pi"], "byte0": ["word0", "byte2", "number6", "word5", "letter2", "pixel5", " byte6", "byte5", "byte1", "byte6", "letter00", "number1", "byte00", "pixel0", "bytek", "pixel00", "pixelk", " byte2", "word1", "number00", " byte1", "number0", "pixel6", "pixel2", "letterk", "numberk", "number2", "word2", " byte5", "number5", "letter0", " byte00"]}}
{"id1": "7872659", "id2": "18793482", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieIndexPath", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndmovieindexfile", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndmovieIndexfile"], "completePath": ["completeHome", " completeRoot", " completeCorp", "execpath", "doneLoader", "successPath", " CompleteDir", "completeCh", " completepath", "CompletePath", "doneVol", "CompleteDir", "completeVol", " completePoint", "itePath", "flatPath", " completeDir", "donePath", "completeCorp", "iteMusic", "successCh", "execLoader", "completeFile", "iteCh", "correctPoint", " CompletePath", "completeMusic", "completeRoot", "donepath", "successMusic", "completepath", "completeLoader", "itepath", "completePoint", "progressLoader", "progresspath", "CompleteHome", " completeCh", "progressPath", " completeHome", "flatRoot", "execPath", "flatCorp", "progressVol", "completeDir", "correctPath", "flatPoint", " CompleteHome", "execVol", "correctCorp", " completeMusic", " completeFile", " CompleteFile", "correctRoot", "CompleteFile", "successpath"], "masterFile": ["masterFiles", " masterName", "MasterFilename", "MasterName", "cacheFiles", "masterName", "MasterPath", "cachePath", "masterPath", "MasterFiles", "configFilename", "mastersFile", " masterPath", "cacheFile", "masterFilename", "MasterFILE", "mastersPath", " masterFilename", "MasterFile", "configPath", "configFile", "mastersFILE", "cacheFILE", "masterFILE", "mastersFiles", "configName"], "CustRatingFileName": ["CustRatingClassPath", "CustIndexFilesVersion", "CustIndexFileName", "CustRatingFilesName", "CustRatingFilenameSize", "CustRatingFilenameName", "CustRateFileName", "CustRateFilenameDesc", "CustRatingFilesDesc", "CustRatingFileVersion", "CustRatingFileSize", "CustIndexFilesType", "CustRateFileSize", "CustIndexFilesName", "CustRatingFilenamePath", "CustRatingFullDesc", "CustRateFilenameName", "CustIndexFilesPath", "CustRateFileDesc", "CustRatingFullPath", "CustRatingLineVersion", "CustRatingClassVersion", "CustRatingFileDesc", "CustRatingLineName", "CustRatingClassName", "CustRatingFilePath", "CustRatingFilesSize", "CustRateFilePath", "CustRatingFullName", "CustRatingLineType", "CustRateFilenamePath", "CustRatingFileType", "CustRatingLinePath", "CustRatingFullSize", "CustIndexFileVersion", "CustRatingClassType", "CustIndexFileType", "CustRatingFilesPath", "CustIndexFilePath", "CustRatingFilenameDesc", "CustRatingFilesType", "CustRateFilenameSize", "CustRatingFilesVersion"], "MovieIndexFileName": ["MovieIndexPlaceFile", "MovieConfigFolderFile", "MovieIndexFileHandle", "MovieIndexClassSize", "MovieIndexFName", "MovieEditFilename", "MovieConfigFolderName", "MovieConfigFileHandle", "MovieConfigFileVersion", "MovieIndexFolderName", "MovieIndexFileVersion", "MovieIndexPlaceName", "MovieIndexClassName", "MovieIndexFSize", "MovieIndexFilesUrl", "MovieEditFname", "MovieIndexClassname", "MovieConfigFolderVersion", "MovieEditFSize", "MovieConfigFileName", "MovieEditFUrl", "MovieIndexClassUrl", "MovieConfigFileFile", "MovieIndexFILEVersion", "MovieIndexFilesname", "MovieIndexFileSize", "MovieIndexFolderHandle", "MovieIndexFilesSize", "MovieConfigFolderHandle", "MovieIndexFILEFile", "MovieIndexFname", "MovieEditFileName", "MovieIndexFolderVersion", "MovieEditFileSize", "MovieIndexFUrl", "MovieIndexFolderFile", "MovieIndexPlaceHandle", "MovieEditFName", "MovieIndexFileFile", "MovieIndexFileUrl", "MovieIndexFILEName", "MovieIndexFILEHandle", "MovieEditFileUrl", "MovieIndexPlaceVersion", "MovieIndexFilename", "MovieIndexFilesName"], "inFile": ["Infile", "inputF", "inputFile", "InFile", "InF", "incFile", "inF", "incC", "InSourceFile", "inputSourceFile", "incSourceFile", "outFile", "infile", "outC", "incfile", " inF", " infile", "outfile", " inSourceFile", "outSourceFile", "inSourceFile", "inputfile"], "inC": ["inB", "InB", "inputF", " inCL", "innerCI", "outCC", "inputFile", "InFile", "InF", "outB", "inF", " inCC", "inCL", "outFile", "outC", "inputC", "innerFile", "inputCC", " inF", "InCI", " inB", "InCC", "innerCC", "outF", "outCL", "InCL", "outCI", "inCC", "innerC", "inCI", "InC"], "outFile1": ["outputFileName", "outFName", "againCFirst", "againC3", "outputFileId", "outPlaceId", "outCFirst", "outF1", "outFileName", "outFile3", "againFile1", "outPathFirst", "outPath1", "outFiles1", "outPath2", "outFilesFirst", "outfile1", "outfileId", "outF2", "outPath3", "outFileFirst", "outPlace1", "outFiles3", "outputFile1", "againFile3", "outC3", "againC1", "outFiles2", "againFile2", "outfileName", "outPlaceName", "outFileId", "outputFile2", "outputfileName", "outputfileId", "outputfile2", "outPlace2", "outFId", "outfile2", "againC2", "againFileFirst", "outputfile1"], "outC1": ["newc1", "outC81", "outD1", "outCFirst", "outD8", "outF1", "outcFirst", "outFOne", "newC81", "outCFFirst", "outD81", "newc81", "newCFirst", "outF2", "outD2", "againB8", "againC8", "outCF81", "outCFOne", "newCOne", "outDOne", "outc1", "outB1", "againB1", "outBOne", "againCOne", "outcOne", "outB8", "newcOne", "newcFirst", "outB2", "againBOne", "outF8", "outc81", "outC8", "newC1", "againC2", "againB2", "outCOne", "outCF1", "outDFirst", "againC1"], "outFile2": ["outFile4", "outputfile5", "outFiles6", "outDirectory4", "outFile5", "againFile6", "againFile1", "outFilesTwo", "againLine1", "outDirectory2", "outFiles1", "outDirectory5", "againFileTwo", "outLineTwo", "outputFile4", "outFileTwo", "outputFile5", "outChannel2", "outChannel1", "outLine2", "outDirectoryTwo", "outChannel6", "againLine2", "outfile4", "outFiles2", "outputFileTwo", "againFile2", "outFiles5", "outLine6", "outputFile2", "outfile5", "outChannelTwo", "againLine6", "outputfile2", "outfileTwo", "outLine1", "outfile2", "outputfileTwo", "againLineTwo", "outFile6", "outFiles4", "outputfile4"], "outC2": ["outFile4", "outFTwo", "outCache1", "outCII", "outF1", "outCache2", "outFII", "outB4", "OutF1", "againC4", "outCache4", "outF2", "OutF2", "OutC1", "outFileTwo", "outCacheII", "outCTwo", "OutCII", "OutC2", "OutC4", "OutFII", "outB1", "againB1", "againCTwo", "againBTwo", "outBTwo", "outF4", "outB2", "outC4", "outFileII", "againC2", "againB2", "againB4", "OutF4", "againC1"], "fileSize": ["bufferMode", " fileMode", " fileAddress", " fileSIZE", "imageLength", "imageSize", " fileLength", "fileAddress", "bufferSize", "fileMode", "bufferLength", "FileLength", "resourceSize", "resourceSIZE", "FileSize", "FileSIZE", "FileAddress", "fileLength", "FileMode", "imageSIZE", "resourceAddress", "fileSIZE"], "totalNoDataRows": ["totalNoPageRues", "totalNoDataChOWS", "totalNoDataRrows", "totalNoPageRrows", "totalNoDataCues", "totalNoPageLOWS", "totalNoDataRues", "totalNoDataLues", "totalNoPageLrows", "totalNoDataCows", "totalNoPageLows", "totalNoDataChows", "totalNoDataLows", "totalNoDataCrows", "totalNoDataChues", "totalNoDataCOWS", "totalNoPageRows", "totalNoDataLrows", "totalNoPageROWS", "totalNoDataROWS", "totalNoDataLOWS", "totalNoDataChrows", "totalNoPageLues"], "mappedBuffer": ["mappedBuff", "mappingBuffer", "mappingFile", "mappingBuff", "mashedBuffer", "Mappedbuffer", "mippedBuff", "mappedbuffer", "MachedURL", "MappedBuff", "machedBuffer", "mappingStream", "MappingChannel", "mapedFile", "MappedStream", "mppedStream", "MachedChannel", "mappingbuffer", "mactedStream", "MappingFile", "mappedURL", "MachedBuff", "mippedURL", "mappedChannel", "MappingBuff", "Machedbuffer", "mippedStream", "mappedFile", "mapedStream", "mapedURL", "MappedBuffer", "machedURL", "MappingBuffer", "MachedBuffer", "machedFile", "MachedFile", "mashedFile", "mashedChannel", "machedStream", "mappedStream", "machedbuffer", "mapedBuff", "MappedFile", "mppedChannel", "mashedBuff", "machedChannel", "mactedBuff", "machedBuff", "mactedbuffer", "mippedBuffer", "mapedBuffer", "mactedBuffer", "MappedURL", "mappingChannel", "MachedStream", "mppedBuff", "mppedBuffer", "MappedChannel"], "startIndex": ["endPoint", "startindex", "startSection", "endInfo", "stopCode", "stopindex", "stopIndex", "StartInfo", "initindex", "useindex", "startRow", " startindex", "endRow", "endCode", "startInfo", "endSection", " startOffset", "startingPosition", "startingIndex", " startCode", "startingPoint", "endIndex", "initIndex", "StartOffset", " startPosition", "startCode", " startInfo", "startPoint", "startPosition", "StartPosition", "initOffset", "endindex", "useIndex", " startPoint", "stopRow", "usePosition", " startRow", "Startindex", " startSection", "startOffset", "StartIndex", "useInfo", "startingSection", "initInfo", "endPosition"], "count": ["first", "test", "cache", "follow", "call", "allow", "found", "id", "force", "current", "child", "old", "total", "Count", "index", "start", "length", "keep", "ind", "time", "more", "thread", "name", "max", "c", "order", "len", "self", "code", "all", "type", "i", "counter", "number", "find", "weight", "list", "depth", "close", "add", "key", "other", "col", "pool", "loop", "coll", "limit", "group", "part", "sum", "size"], "currentMovie": [" currentmovie", "currentFilm", "thismovie", "CurrentTheme", "currentmovie", "defaultMusic", "currentlyPicture", "CurrentMovie", "currentPicture", "parentMovie", "validMovie", "reportedMovie", "reportedFilm", "thisPicture", "thisMovie", "defaultFilm", "validTheme", "reportedImage", "reportedmovie", "defaultMovie", "validFilm", "CurrentFilm", "defaultImage", " currentMusic", "validmovie", "parentmovie", "currentTheme", "Currentmovie", " currentFilm", "thisFilm", "currentMusic", " currentPicture", " currentImage", "currentImage", "currentlyMovie", "reportedMusic", "parentPicture", "reportedPicture", "currentlyMusic", "parentFilm", "reportedTheme"], "movieName": ["Moviename", "filmName", "MovieName", " moviename", "camName", "filmNumber", " movieId", "voiceName", "movieInfo", "moneyName", "moneyFamily", "voicename", "moneyNumber", "voiceId", " movieFamily", "MovieFamily", "moviename", "MovieInfo", "filmname", "MovieId", "voiceInfo", "movieId", "movieNumber", "camFamily", "movieFamily", " movieInfo", "camname", "filmFamily", "MovieNumber"], "customer": ["Customer", "customor", "ustomeri", "mixer", "ustomers", "customER", "CustomER", "Customers", " customER", "mixER", "customers", " customers", " customeri", "ustomer", "mixor", "ustomER", "ustomor", "Customeri", "Customor", "customeri", "mixers"], "rating": ["score", "ring", "url", "feature", "error", "reader", "id", "rr", "string", "ranking", "range", "missing", "ruby", "rate", "type", "writer", "info", "r", "number", "rage", "rated", "Rating", "packing", "setting", "ing", "padding", "alpha", "attribute", "resource", "rolling", "rank", "http", "rc", "data", "RC", "value", "rates", "rice", "including", "reading", "comment", "radius", "writing"], "outBuf1": ["outFufCloud", "outKuf8", "outBafCloud", "outFuf1", "outBummerOne", "outFbuf01", "outBbuff8", "outBbufn", "outBbuf11", "outBaf1", "outBuf3", "outFuf91", "outBaft3", "outBbuff0", "outBuf91", "outBuff8", "outFufOne", "outBuf8", "outCuf0", "outBaf3", "outBuffCloud", "outBalth3", "outBbuf91", "outFbuf1", "outBiff91", "outBaftn", "outKufOne", "outBuf01", "outFafCloud", "outBbuf3", "outBuff3", "outBum91", "outBufOne", "outKbuffOne", "outDuff1", "outKbuff3", "outBufn", "outDuff3", "outKbuff1", "outKuf1", "outBuff1", "outDuf1", "outBaf8", "outFuf01", "outBaf0", "outBbufOne", "outBalth1", "outBaft11", "outCuf1", "outCufOne", "outFafOne", "outKbuf3", "outFbuf91", "outBbuf1", "outBuffOne", "outFbufOne", "outKuf3", "outBbuffOne", "outCuffOne", "outFaf1", "outDuff11", "outKbuff8", "outBbuf2", "outBumOne", "outBuff11", "outBuff2", "outBbuff3", "outBummerCloud", "outBuf0", "outBafOne", "outBbuff1", "outDuf11", "outBiff1", "outBbuf01", "outBiff01", "outBaft1", "outDuf3", "outDuffn", "outBiffOne", "outBuff0", "outKbuf1", "outKuf2", "outBum01", "outCuff1", "outCuff0", "outBummer1", "outDufn", "outBalth2", "outKbuf2", "outBufCloud", "outBuffn", "outBuf11", "outBum1"], "outBuf2": ["outBuf4", "outFbuf2", "outBbuffTwo", "outBuber8", "outFbufB", "outFuf1", "outBoffTwo", "outFuf20", "outBum20", "outBbuff8", "outBuber20", "outBait200", "outBbuff20", "outBbuffer4", "outBbuff0", "outBuff8", "outBuf20", "outFuf8", "outBuf8", "outBbufB", "outBufTwo", "outBum82", "outBuff4", "outWBuf200", "outFbuff20", "outBuffTwo", "outBufB", "outBbufTwo", "outWBuf8", "outFbuff4", "outWBuf2", "outWBbuff200", "outBuff12", "outBbuffer2", "outWBuff4", "outFbuff2", "outBbuff200", "outBuffB", "outBbuff4", "outBum8", "outBait2", "outBait4", "outBbuff82", "outBuber2", "outBuff1", "outFufTwo", "outBuf12", "outFbuf12", "outWBbuffTwo", "outFuf4", "outWBuff0", "outBbuf1", "outBoff8", "outFbuff1", "outBbuf4", "outWBuff8", "outBuber82", "outBait0", "outBbuf2", "outFbuf4", "outBuff2", "outBuf0", "outWBbuff8", "outBbuff1", "outBuf200", "outWBufTwo", "outBaitTwo", "outFbuff8", "outBoff200", "outFuf12", "outFuf82", "outBbuffer12", "outBuff0", "outBum2", "outBbuff2", "outFbuff82", "outBoff2", "outBbuf12", "outWBuf4", "outBuf82", "outFbuffTwo", "outBbufferB", "outFuf2", "outWBuf0", "outFufB", "outWBbuff2", "outBait8", "outWBuff2"], "endOfIndexFile": ["endOfImageFolder", "endOfDataFile", "endofindexTime", "endOfIndexFolder", "endofIndexFile", "endOfindexFile", "endOfImageFiles", "endOfDataDir", "endOfindexFiles", "endofIndexDir", "endofindexFolder", "endofLinkFiles", "endofindexFile", "endOfIndexfile", "end\n", "endOfindexTime", "ended\n", "endfile", "endOfIndexFiles", "endofindexFiles", "endedfile", "endOfIndexTime", "endOfLinkFile", "endOfIndexDir", "endOfLinkfile", " end\n", "endOfClientDir", " endfile", "endOfindexFolder", "endOfDataTime", "endOfClientFiles", "endOfClientTime", "endOfClientFile", "endofIndexFolder", "endOfindexfile", "endOfindexDir", "endOfLinkFiles", "endOfLinkDir", "Endfile", "End\n", "endOfImageTime", "endofLinkDir", "endofLinkTime", "endOfDatafile", "endOfImageFile", "endofLinkFile", "endOfLinkTime", "endofIndexFiles", "endofIndexTime"]}}
{"id1": "3430784", "id2": "22536033", "code1": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"decodeBody": ["decodesFile", "decodedPart", " decodedFile", "decodeStream", "decodesStream", "decodedFile", " decodedStream", "decodesBody", "decodedStream", "decodeFile", "decodingBody", "decodePart", "decodingFile", "decodingStream", "decodedBody", " decodeFile", " decodePart", "decodingPart", " decodedBody", " decodeStream", "decodesPart", " decodedPart"], "in": ["exec", "serv", "url", "gin", "ins", "din", "reader", "IN", "login", "bin", "id", "isin", "inc", "load", "request", "ini", "input", "session", "In", "conn", "inner", "image", "err", "c", "inas", "read", "m", "i", "connection", "r", "b", "ex", "again", "body", "config", "socket", "loader", "nin", "win", "buffer", "resource", "inn", "version", "min", "it", "content", "get", "is", "into", "cin", "source", "data", "file", "work", "init", "inside", "src", "pass", "con", "ac", "as", "f"], "contentTransferEncoding": ["contentTransferEasing", "contentTransferCaming", "contentRestEnoding", "contentTransferCoding", "contentTransferEcording", "contentRestEncording", "contentRestEncoding", "contentTransferencoding", "contentTransferencitting", "contentPartEncasing", "contentTransferCasing", "contentTransferEndoder", "contentPartEncryption", "contentTransferEngoding", "contentTransferencoder", "contentTransferAcosing", "contentTransferEncoded", "contentTransferencording", "contentTransferEoder", "contentTransferEncording", "contentTransferEoding", "contentPartEoding", "contentTransferEnosing", "contentPartEncoder", "contentRestEnording", "contentTransferCoded", "contentTransferEngasing", "contentTransferCoder", "contentTransferEosing", "contentRestEnoder", "contentTransferEnaming", "contentPartEncoding", "contentTransferEncoder", "contentTransferEnoding", "contentTransferEndoded", "contentTransferEcaming", "contentTransferCearing", "contentTransferEnearing", "contentTransferEnitting", "contentTransferEnording", "contentTransferEndasing", "contentTransferEncaming", "contentTransferEryption", "contentTransferEcoding", "contentTransferEncasing", "contentTransferEngoded", "contentTransferEnasing", "contentTransferAcasing", "contentPartEasing", "contentRestEncoder", "contentRestEncaming", "contentTransferEnoded", "contentTransferEcitting", "contentTransferEncryption", "contentTransferAcoder", "contentTransferEnoder", "contentTransferCording", "contentRestEnaming", "contentTransferEncitting", "contentTransferEngearing", "contentTransferEncearing", "contentPartEoder", "contentPartEryption", "contentTransferEndoding", "contentTransferCryption", "contentTransferEnryption", "contentTransferAcoding", "contentTransferEncosing", "contentTransferEcoder"], "tempBody": ["outputbody", "tmpBody", "TempBody", "TempFile", "tempLife", "outputBody", "tmpFile", "tempFile", "tempCore", "TempCore", "tmpCore", " tempbody", "Tempbody", "tmpLife", "tmpbody", "tempbody", "outputLife", " tempCore", " tempLife", "outputFile", " tempFile"], "out": ["exec", "base", "OUT", "client", "outs", "cache", "output", "bin", "app", "io", "raw", "path", "conn", "obj", "ext", "inner", "err", "c", "off", "this", "Out", "extra", "writer", "connection", "a", "i", "user", "ex", "object", "body", "null", "o", "again", "parent", "socket", "sync", "resource", "copy", "line", "data", "page", "file", "source", "channel", "init", "pool", "temp"]}}
{"id1": "23291583", "id2": "4750967", "code1": "    private ByteArrayInputStream fetchUrl(String urlString, Exception[] outException) {\n        URL url;\n        try {\n            url = new URL(urlString);\n            InputStream is = null;\n            int inc = 65536;\n            int curr = 0;\n            byte[] result = new byte[inc];\n            try {\n                is = url.openStream();\n                int n;\n                while ((n = is.read(result, curr, result.length - curr)) != -1) {\n                    curr += n;\n                    if (curr == result.length) {\n                        byte[] temp = new byte[curr + inc];\n                        System.arraycopy(result, 0, temp, 0, curr);\n                        result = temp;\n                    }\n                }\n                return new ByteArrayInputStream(result, 0, curr);\n            } finally {\n                if (is != null) {\n                    try {\n                        is.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            if (outException != null) {\n                outException[0] = e;\n            }\n        }\n        return null;\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 0, "substitutes": {"fetchUrl": ["fetchurl", "fdownloadurl", "furlURL", "fdownloadURL", "furlUrl", "fdownloadUrl", "FetchUrl", "fetchURL", "furlurl", "fetchString", "FetchURL", "fdownloadString", "FetchString", "furlString", "Fetchurl"], "urlString": ["urlUrl", " urlFile", "sourceUrl", "sourceSource", "sourceStream", "httpstring", "fileSource", "filestring", "urlFile", "urlStream", " urlUrl", "httpFile", "urlSource", " urlStream", "sourceString", "httpSource", "urlstring", "fileString", "ruleSource", "ruleUrl", "ruleStream", "httpString", " urlSource", "fileFile", " urlstring", "ruleString"], "outException": ["inception", " outError", " outception", "OutError", "outEvent", "outception", " outEvent", "againception", "againException", "Outception", "inEvent", "againError", "inError", "inException", "OutException", "outError", "againEvent"], "url": ["base", "ver", "job", "str", "el", "e", "feed", "URL", "jar", "log", "sl", "fl", "Url", "fb", "string", "conn", "li", "ls", "image", "build", "lib", "ssl", "i", "r", "b", "rule", "ll", "www", "loc", "ur", "ul", "lr", "uri", "api", "resource", "bel", "http", "l", "store", "source", "file", "data", "page", "server", "open", "web", "rl", "f", "il"], "is": ["us", "ais", "iv", "ip", "ms", "ai", "ib", "ois", "ob", "app", "isa", "ar", "was", "are", "id", "iso", "has", "IS", "bis", "ws", "Is", "es", "oss", "eni", "abs", "ir", "out", "hi", "stream", "ris", "err", "isl", "si", "iss", "os", "nis", "or", "ie", "i", "info", "ori", "isf", "js", "internet", "isc", "isi", "ri", "uri", "fs", "api", "close", "it", "get", "its", "http", "in", "init", "src", "as", "web", "il", "be"], "inc": ["lc", "ins", "dec", "uc", "level", "pri", "exp", "sec", "circ", "Inc", "index", "keep", "length", "ind", "conn", "ir", "inner", "incre", "err", "c", "lock", "ci", "acc", "ii", "ec", "const", "rec", "enc", "loc", "inse", "iter", "inn", "inf", "min", "rc", "in", "col", "sc", "occ", "init", "num", "limit", "nc", "con", "ac", "spl", "INC", "ign"], "curr": ["ferrs", " curry", " currb", "CurR", "ferr", "urrc", " curpr", "terril", "urrd", "charrr", "verrs", "Curru", "perru", "charrn", " currs", "urrb", "carril", "currn", "carrc", "urr", " curru", "carr", "perr", "terr", "verrc", "charr", "currs", "Currc", "Currs", "urro", "currr", "surr", "surrs", "curril", "perrn", "perrc", "terrd", "grrs", "perro", "verpr", " curre", "carR", "surre", "surrc", "perrb", "perrr", "curR", "curre", "ferro", "curru", "currb", "carru", "curry", "charro", "urrn", "curro", "surR", "perrd", "surru", " curbr", "carrd", "currc", "Curpr", "grr", "verr", "currd", "ferry", " currd", "Curbr", " curril", "Curr", "terrs", "perrs", " currc", "perbr", " curro", "curpr", "grro", "curbr", "carrs", "urrr", "grry", "perre"], "result": ["complete", "test", "master", "error", "ver", "cache", "grade", "status", "output", "found", "comment", "current", "cover", "arr", "Result", "request", "default", "function", "res", "length", "ret", "memory", "range", "err", "success", "results", "order", "event", "info", "r", "report", "root", "text", "parent", "diff", "list", "fr", "buffer", "array", "message", "iter", "resource", "date", "done", "uri", "content", "search", "rc", "page", "continue", "match", "data", "source", "json", "sum", "product", "response"], "n": ["net", "an", "z", "k", "rn", "ng", "N", "e", "un", "nb", "x", "nl", "nr", "ns", "conn", "u", "nor", "s", "ln", "no", "err", "len", "nn", "c", "pn", "m", "j", "en", "t", "i", "r", "number", "nu", "o", "rec", "enc", "nt", "sn", "p", "min", "nd", "dn", "l", "na", "fn", "cn", "init", "ni", "num", "ne", "nc", "size"], "temp": ["emp", "v", "test", "base", "lc", "unsigned", "cache", "clean", "now", "str", "output", "tmp", "pre", "current", "zip", "raw", "cur", "old", "tc", "input", "py", "err", "extra", "wait", "null", "empty", "tr", "dest", "stable", "loc", "diff", "buffer", "iter", "key", "content", "copy", "txt", "data", "source", "init", "shared", "Temp", "full", "part", "fake", "cut"]}}
{"id1": "14758866", "id2": "20886320", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"getResourceAsStream": ["getResourceasSteam", "getResourceAsFile", "getResourcesasString", "getResourceASStream", "getResourceToStream", "getResourceasStream", "getResourceASString", "getResourceASSteam", "getResourcesAsString", "getResourcesasFile", "getResourcesasSteam", "getResourcesAsSteam", "getResourceasString", "getResourceToSteam", "getResourcesAsStream", "getResourceAsSteam", "getResourcesAsFile", "getResourceAsString", "getResourceToFile", "getResourceToString", "getResourceasFile", "getResourcesasStream", "getResourceASFile"], "name": ["hash", "address", "base", "ip", "cache", "alias", "str", "id", "ame", "path", "Name", "remote", "filename", "location", "string", "time", "named", "memory", "word", "domain", "prefix", "username", "type", "info", "connection", "object", "NAME", "parent", "config", "uri", "resource", "version", "key", "source", "data", "file", "full", "part", "names", "size"], "inputStream": ["InputConnection", " inputConnection", "cacheStream", "pullSteam", "cacheSteam", "inputSteam", " inputBody", "InputFeed", " inputstream", "pullStream", "InputBody", "currentStream", "InputChannel", " inputSteam", "cacheFeed", "inputConnection", "currentSteam", "Inputstream", "inputBody", " inputFeed", "InputSteam", "inputstream", "pullChannel", "inputFeed", "cachestream", "inputChannel", " inputChannel", "currentBody", "pullConnection", "currentstream", "InputStream"], "in": ["exec", "ins", "reader", "din", "IN", "re", "bin", "path", "log", "input", "In", "inner", "image", "c", "err", "Out", "read", "m", "r", "rec", "socket", "buffer", "source", "data", "src"], "out": ["sys", "ger", "error", "params", "client", "OUT", "outs", "cache", "gen", "output", "bin", "window", "pre", "io", "raw", "proc", "log", "obj", "conn", "cmd", "state", "lock", "err", "Out", "writer", "r", "user", "bar", "ex", "object", "query", "println", "list", "outer", "buffer", "debug", "key", "flush", "point", "copy", "line", "data", "pool", "server", "cli", "up", "file", "ref", "page", "dump", "group", "part", "inter", "msg", "temp"], "url": ["address", "result", "https", "base", "client", "cache", "rel", "ob", "left", "feed", "URL", "path", "log", "sl", "remote", "Url", "location", "string", "gl", "stream", "li", "image", "org", "event", "ssl", "connection", "r", "user", "b", "route", "browser", "object", "config", "pull", "socket", "loc", "ur", "update", "uri", "service", "resource", "api", "bel", "http", "l", "page", "data", "file", "server", "source", "download", "coll", "full", "open", "web", "f"], "remoteName": ["fullKey", "remotePath", " remoteKey", "localKey", "remotename", "localUrl", "localPath", "RemoteKey", "fullname", "remoteUrl", "RemotePath", " remotePath", "RemoteName", "RemoteUrl", "fullPath", " remoteUrl", "fullName", " remotename", "remoteKey", "Remotename"], "localName": [" localname", "globalname", "locname", "LocalName", "localname", "remotePath", " localString", "globalName", "localKey", "remotename", "locString", "localUrl", "localPath", " localUrl", "LocalPath", "Localname", "remoteUrl", "globalKey", "globalPath", " localPath", "locPath", " localKey", "locUrl", "locName", " localFile", "globalString", "remoteFile", "remoteString", "globalFile", "localString", "LocalKey", "remoteKey", "localFile"], "host": ["address", "header", "ip", "Host", "proxy", "path", "remote", "target", "hop", "string", "conn", "driver", "domain", "hard", "prefix", "database", "username", "format", "type", "head", "config", "loc", "uri", "service", "h", "http", "server", "addr", "dir", "src", "home", "localhost", "arch"], "prot": [" protocols", " plat", "pro", "stat", "client", " protocol", "prop", "Prot", "rel", "platform", " proto", "family", "proc", "cert", "pt", "nat", "pattern", "conn", "conv", "prefix", "ios", "afi", "ssl", "def", "rot", "config", "att", "api", "ocol", "col", "cli", "channel", "addr", "password", "pos", "ref", "pass", "ht", "lat", "part", "serv", "txt"], "port": ["rest", "position", "address", "ip", "PORT", "project", "allow", "phone", "Port", "proxy", "path", "index", "ort", "length", "string", "time", "hop", "patch", "target", "pi", "type", "pid", "number", "direction", "slice", "future", "uri", "service", "version", "timeout", "p", "point", "ports", "file", "server", "width", "password", "limit", "pass", "value", "priority", "size", "select", "f", "pr"], "cacheFile": ["proxyfile", "cachefile", " cacheDirectory", "remoteLine", "acheFiles", "Cachefile", " cachePlace", "remotefile", "cacheLine", "localFiles", "cacheDir", "CacheFile", " cacheDir", "localfile", "storageFile", "achePlace", "CacheDirectory", "localDir", "cacheFiles", " cacheHandle", "fakefile", "cacheDirectory", "cachePlace", "fakeUrl", "outputConnection", " cacheMessage", "acheFile", "remoteUrl", "proxyHandle", "tempDir", "tempFile", "proxyFile", "cacheUrl", "fakeLine", "CacheDir", " cacheConnection", " cacheLine", "baseMessage", "cacheMessage", "outputfile", "baseConnection", "baseFile", " cacheUrl", "outputMessage", "remoteFile", "localDirectory", " cachefile", "sessionFiles", "CacheFiles", "basefile", "sessionDir", "tempfile", "cacheConnection", " cacheFiles", "storageFiles", "sessionFile", "cacheHandle", "CacheUrl", "fakeFile", "storagePlace", "proxyDir", "outputFile", "localFile", "tempHandle", "sessionUrl"], "urlConnection": ["sslFile", " urlFile", "fileConnect", "httpResponse", "URLConnect", " urlEntry", " urlCommand", "urlConnect", "webCon", "slCode", "webConnection", "urlResponse", " urlConnect", "URLPart", "sslConnection", "httpconnection", "cacheConn", "sslEntry", "URLCon", " urlPool", "downloadEntry", "fileConn", "slCommand", " urlConn", "URLConnection", "webconnection", "urlFile", "urlCommand", "downloadConnection", "urlconnection", "slChannel", "slConnection", "httpChannel", " urlChannel", "httpConnection", "httpConnect", "sslconnection", "sslConn", "sslConnect", "httpCode", "downloadFile", "httpCommand", "urlEntry", "fileConnection", "cacheConnect", " urlPart", "urlConn", "URLConn", "httpCon", "sslResponse", "filePart", "webConnect", "URLconnection", "downloadconnection", "cacheConnection", "urlCon", " urlCode", "urlCode", "cachePool", " urlconnection", "urlPool", "httpPool", "urlPart", "urlChannel", "URLResponse", "httpConn"], "httpURLConnection": ["upperRNode", "shortSLConnection", "httpURLQuery", "httpURNode", "shortSLconnection", "httpHTTPFunction", "httpLLConnection", " httpURLQuery", "httpMLConnect", "httpREConstruction", "httpDOMConnection", "httpMConnect", "httpMConnection", " httpURLConn", "httpUrlConnector", "httpDateconnection", "httpMconnection", "httpDateConstruction", "httpMCode", "currentURLCode", "httpWSNode", "httpRLConnection", "httpurlStatement", "httpURLConn", "httpRNode", " httpHTTPConnection", " httpHTTPQuery", "upperURLTransaction", " httpURLConnect", "urlURLconnection", "cacheUrlClient", "urlUrlconnection", "cacheURLConnection", "httpFormConnection", "httpURLconnection", "httpURLClient", "httpURFunction", "shortURLConnect", "httpRTransaction", "urlUrlStatement", " httpLLConnection", " httpHTTPOperation", "upperRConnection", "httpBLConnection", "shortURLconnection", "httpURLConnector", "httpLLconnection", " httpURLOperation", "httpREConnection", "httpUrlconnection", "httpREStatement", "httpURLCode", "httpUrlConnection", "httpHTTPOperation", "httpUrlFunction", "httpBLFunction", "httpBLOperation", "httpLLConn", " httpUrlconnection", " httpUrlFunction", "httpRconnection", "httpURconnection", "httpHTTPConnection", "httpURLTransaction", " httpHTTPFunction", "httpDOMconnection", "httpUrlConnect", " httpURLConstruction", "httpurlConnection", "cacheURLClient", "upperRconnection", "currentURLConnect", "httpSLConnect", "httpRConnection", "httpUROperation", "httpDOMFunction", "httpURConnection", "cacheURLConnect", "urlURLConnection", "httpDOMConnect", "httpFormConnect", "upperURLconnection", "urlURLStatement", " httpLLconnection", "currentURLconnection", "httpurlClient", "httpDateConn", "httpREConn", " httpURLconnection", "httpSLConnection", "httpRLconnection", "httpSLconnection", "httpCLConnector", "httpURLOperation", "httpRLConnector", "httpWSconnection", "httpURLStatement", "upperURLNode", "cacheUrlConnector", "cacheUrlConnect", "currentURLConnection", "httpURTransaction", "httpURLFunction", "urlUrlConnection", " httpURLFunction", "httpURLNode", "httpMLConnection", " httpUrlConnect", "upperRTransaction", " httpLLConstruction", "httpURQuery", "httpREClient", "httpWSTransaction", "httpWSConnection", "httpHTTPQuery", "shortURLConnection", "httpRLClient", "httpFormconnection", "httpUrlStatement", "urlURLClient", "shortSLConnect", "httpurlconnection", "cacheUrlConnection", "httpCLClient", "httpMLconnection", "httpUrlClient", "httpURLConstruction", "httpSLCode", "upperURLConnection", "httpLLConstruction", "httpMLFunction", " httpUrlConnection", "httpDateConnection", "httpREconnection", " httpLLConn", "cacheURLConnector", "httpRLConnect", "httpBLQuery", "httpCLConnection", "urlUrlClient", "httpCLConnect", "httpURLConnect"], "responseCode": ["statusStatus", "responseType", "ResponseCount", "statusCount", "ResponseStatus", "responseStatus", "ResponseType", "replyCode", "ResponseMessage", "responseMessage", "statusType", "replyCount", " responseMessage", "ResponseCode", " responseStatus", " responseType", "statusMessage", "responseCount", "replyType", "statusCode", "replyMessage"], "lastModified": ["nextMODified", "lastMODined", "lastmodied", "nextMODIFIED", " lastModined", "nextModed", "lastMinined", "lastmoded", "nextModied", "lastModIFIED", " lastModied", "nextMODed", "nextModified", "New", "lastMODied", " lastMODined", "s", " lastMODied", " lastModIFIED", "lastEdification", "nextMODied", "lastMinied", "nextMODification", "lastMODification", "lastModification", "lastEdified", "lastMinIFIED", "_", " lastMODified", "lastMODified", "lastModed", "lastMODed", "nextModification", "lastEded", "lastEdIFIED", "lastMinified", "lastModined", " lastMODIFIED", "nextModIFIED", "this", "lastmodification", "lastmodIFIED", "lastMODIFIED", "lastModied", "lastmodified"]}}
{"id1": "1798720", "id2": "15645004", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"save": ["change", "apply", "transfer", "load", "make", "archive", "setup", "upload", "build", "release", "report", "transform", "Save", "install", "update", "pack", "copy", "store", "data", "process", "move", "stage", "saving", "create", "dump", "open", "clone"], "packageName": ["modulePath", " packagePart", "moduleName", "sourcename", "pluginName", "moduleInfo", "directoryPath", " packagePath", "packagePart", " packagename", "sourceName", "packageInfo", "packagename", "directoryname", "sourcePath", "directoryName", " packageNames", "PackagePath", "PackageName", "directoryInfo", "packageNames", "directoryDir", "directoryPart", "pluginDir", "pluginPart", "PackageDir", "directoryNames", "pluginPath", "packagePath", " packageInfo", "moduleDir", "PackageNames", "sourceDir", "PackageInfo"], "fileContents": ["getContents", "getNames", "FileContent", "imageNames", " fileHours", "imageParts", " fileContent", "ileContents", "fileSources", " fileTextures", "FileContents", "ileNames", "fileContent", "ileTextures", " fileSources", "imageContents", "FileSources", "fileParts", "fileHours", "imageHours", "fileTextures", "FileTextures", "ileSources", "FileNames", "FileHours", "getParts", "getContent", "FileParts", " fileParts"], "fileNames": ["fileTypes", "FileTypes", "fNumbers", "pagenames", "viewTypes", "pageNames", "filenames", "playName", "FileName", "fullContents", "FileContents", "fTypes", "pageTypes", "playContents", "logNames", " fileName", "fName", "logName", "fullNames", "fNames", " filenames", "logTypes", "fullTypes", "fullName", "logContents", "viewnames", "FileNames", "viewNames", "playNames", " fileTypes", "fileNumbers", "fileName", "FileNumbers", " fileNumbers"], "dirBase": ["directoryBased", "packageRoot", "folderBase", "directoryBase", "DirDir", "modulebase", " dirbase", "Dirbase", "dirRoot", "DirKit", " dirRoot", "dirBased", "directoryKit", "moduleBased", "packageBase", " dirPath", "directorybase", "dirbase", "dirDir", "dirPath", "packagebase", "DirBase", "directoryDir", "folderBased", "DirRoot", "moduleKit", "folderbase", "DirPath", "packagePath", "moduleDir", "folderDir", "dirKit", "moduleBase"], "packageDir": ["modulePath", "folderBase", "directoryFolder", " packagePath", "directoryPath", "directoryUrl", "PackageDirectory", "folderPath", "packageDirectory", "packageFolder", "parentFile", "directoryFile", "parentDir", "packageBase", "PackageFile", "PackagePath", "directoryDirectory", " packageBase", "directoryDir", "packageUrl", " packageUrl", "PackageDir", " packageFile", "packagePath", "packageLib", " packageFolder", "folderLib", "moduleDir", "moduleLib", "parentUrl", " packageDirectory", "folderDir", "parentFolder", "packageFile", " packageLib", "moduleBase"], "created": ["result", "controlled", "edited", "required", "established", "needed", "formed", "updated", "left", "found", "activated", "path", "creator", "paid", "Created", "true", "released", "creation", " Created", "made", "aaaa", "generated", "failed", "added", "confirmed", "used", "null", "icated", "produced", "existent", "loaded", "raised", "founded", "owned", " existed", "create", "were", "successful", "worked", "authorized", "called", "ed"], "currentPath": ["newPath", "CurrentDirectory", "newpath", "currentLocation", "CurrentPath", "currentPage", "newLocation", "CurrentRoot", " currentLocation", "CurrentPage", " currentRoot", "currentlypath", "Currentpath", "currentlyDirectory", " currentPage", "currentDirectory", "currentRoot", "currentlyPath", " currentpath", "currentlyPage", "newRoot", "CurrentLocation", " currentDirectory", "currentpath"], "i": ["qi", "v", "z", "k", "ip", "ai", "ti", "I", "e", "id", "io", "current", "iu", "xi", "x", "ini", "index", "eni", "start", "name", "ui", "li", "u", "hi", "inner", "s", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "j", "ie", "info", "ori", "b", "n", "bi", "zi", "slice", "isi", "ri", "uri", "p", "gi", "ix", "it", "h", "fi", "key", "di", "oi", "me", "init", "d", "yi", "ji", "part", "mu", "f", "pi"], "file": ["fp", "base", "place", "feed", "io", "child", "path", "folder", "log", "filename", "out", "name", "s", "play", "ile", "files", "fe", "or", "File", "pe", "b", "rule", "per", "il", "ul", "uri", "resource", "http", "l", "source", "work", "up", "dir", "entry", "letter", "data", "full", "unit", "book", "f", "le"], "fos": ["foes", "ufos", " fosh", "Fou", "vops", "flou", "flis", " fis", "voes", "fou", "flops", " fob", "Fops", "Fosh", "Fos", "ofosh", "Fis", "ofos", " fo", "flosh", "cfob", " fops", "ufob", "fios", "Foes", "Fios", "fosh", "vios", "ufoes", "ufo", "fis", "cfo", " fios", "vos", "ofou", "fo", "cfoes", "cfos", "fops", "flos", " foes", "ofops", "fob"], "fileSrc": ["fileDrs", "fileDrec", "fileSsrc", "fileSrec", "fileAsrec", "FileSrc", "fileAsource", "fileNRC", " fileSrs", "fileDrc", "fileSrs", "fileAsRC", " fileDRC", "fileAssrc", " fileSsrc", "FileSource", "FileDRC", "fileSource", "FileDrec", " fileDsrc", " fileDrs", "fileAsrc", "fileSRC", "fileAsrs", "FileSRC", "fileNrs", "fileDource", " fileSRC", "fileNsrc", "fileDRC", "fileNrc", "FileDrc", "FileSrec", "FileDource", " fileDrc", "fileDsrc"], "fileDst": ["fileDsc", "FileSsc", "FileFst", "fileSsrc", "fileEnsc", "FileSrc", "fileSst", "fileFST", "fileDrc", "fileEnST", "fileNsc", "FileDST", "FileDsc", "fileSST", "fileFst", "FileFST", "fileDaysc", "fileDayrc", "FileDst", "fileFrc", "FileFsc", "fileDST", "fileNst", "FileFrc", "fileNsrc", "fileNrc", "FileDrc", "FileSst", "fileEnrc", "FileDsrc", "FileSsrc", "fileSsc", "fileFsc", "fileDayst", "fileDaysrc", "fileEnst", "fileDsrc"], "reader": ["audio", "builder", "re", "e", "right", "io", "rr", "worker", "rer", "ler", "row", "er", "stream", "driver", "inner", "editor", "read", "Reader", "keeper", "or", "layer", "r", "report", "rx", "handler", "oder", "per", "loader", "ner", "ri", "parser", "iter", "buffer", "rc", "data", "entry", "ro", "ry", "server", "rar", "director", "reading", "book", "author"], "writer": ["ger", "wa", "written", "wire", "master", "maker", "writ", "builder", "w", "output", "e", "war", "worker", "ws", "ler", "er", "out", "inner", "driver", "word", "write", "rw", "widget", "wr", "editor", "words", "element", "Writer", "riter", "r", "connection", "player", "o", "with", "handler", "per", "walker", "socket", "loader", "outer", "parser", "buffer", "message", "office", "wrapper", "key", "document", "writers", "data", "entry", "server", "width", "sheet", "work", "value", "later", "book", "author", "writing"], "line": ["url", "lc", "header", "error", "column", "job", "str", "id", "feed", "model", "log", "le", "ge", "row", "string", "name", "end", "Line", "response", "lines", "word", "cr", "write", "link", "character", "code", "LINE", "look", "type", "connection", "definition", "text", "object", "rule", "block", "sync", "cle", "message", "buffer", "key", "jo", "lf", "page", "data", "lin", "entry", "source", "l", "letter", "char", "style", "inline", "pass", "part", "unit", "comment", "item", "cell", "stroke"]}}
{"id1": "22235113", "id2": "21368981", "code1": "    protected Object unmarshallXml(final Unmarshaller unmarshaller, final String accessUrl, final String nameSpace, final String replace, final String with) throws Exception {\n        final URL url = new URL(accessUrl);\n        final BufferedReader inputStream = new BufferedReader(new InputStreamReader(url.openStream()));\n        String xmlContent = readWithStringBuffer(inputStream);\n        if (replace != null) {\n            xmlContent = xmlContent.replace(replace, with);\n        }\n        LOGGER.info(\"Calls \" + accessUrl);\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"\\nXml:\" + accessUrl + \"\\n\" + xmlContent);\n        }\n        if (LOGGER.isDebugEnabled()) {\n            final BufferedWriter out = new BufferedWriter(new FileWriter(\"target/XmlAgentLog\" + xmlRequestNumber++ + \".txt\"));\n            out.write(xmlContent);\n            out.close();\n        }\n        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xmlContent.getBytes());\n        Source source;\n        if (nameSpace != null) {\n            source = setNameSpaceOnXmlStream(byteArrayInputStream, nameSpace);\n        } else {\n            source = new StreamSource(byteArrayInputStream);\n        }\n        return unmarshaller.unmarshal(source);\n    }\n", "code2": "    public APIResponse create(Application application) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/application/create\").openConnection();\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n        connection.setUseCaches(false);\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\")));\n        connection.getOutputStream().flush();\n        connection.getOutputStream().close();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine()));\n            response.setDone(true);\n            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));\n            connection.getInputStream().close();\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Create Application Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "label": 0, "substitutes": {"unmarshallXml": ["unmarshallXil", "unmarshallXson", "unmarshallExML", "unmarshallExml", "unmarshalXml", "unmarshallxson", "unmarshalXson", "unmarshalExml", "unmarshalXil", "unmarshallYson", "unmarshallxil", "unmarshallExil", "unmarshalExil", "unmarshallYML", "unmarshalExML", "unmarshalXML", "unmarshalExson", "unmarshallxml", "unmarshallExson", "unmarshallYml", "unmarshallYil", "unmarshallxML", "unmarshallXML"], "unmarshaller": ["unmarshalable", "unmockallinging", "unmockalling", "unmarshallers", "unmarshiller", "unmarshaler", "unmarshaling", "unmashalledor", "unmashalledable", "unmarshalleder", "unmarshallingers", "unmockallers", "unmashallor", "unmarshalleders", "unmarshallor", "unmarshallinger", "unmashallers", "unmarshillers", "unmarshalor", "unmarshalling", "unmarshalledable", "unmarshalinging", "unmockaller", "unmockallinger", "unmashalleder", "unmarshallable", "unmarshillor", "unmarshalingers", "unmashalleders", "unmarshalledor", "unmockallingers", "unmashaller", "unmarshallinging", "unmarshalers", "unmarshalinger", "unmarshillable", "unmashallable"], "accessUrl": ["AccessStream", "requestLine", "execUr", " accessPath", "inputURL", "requestLog", "requestUr", " accessFile", " accessLine", "AccessPath", " accessStream", " accessLog", "accessLink", "accessPath", "serviceLink", "inputLink", "accessLine", " accessUr", "inputUr", "execURL", "accessLog", " accessURL", "serviceUr", "execUrl", "AccessLog", "accessURL", "execFile", "requestLink", "AccessURL", "accessFile", "requestURL", "requestStream", "inputUrl", "requestPath", "requestUrl", "requestFile", "AccessLine", "AccessUrl", "serviceURL", "serviceUrl", "accessStream", "accessUr"], "nameSpace": ["resourceSp", "resourceSpace", "namespace", "NamePath", "resourceFrame", " nameName", "NameString", "resourceString", "resourcespace", "namesName", "nameSp", "nameString", "namesSpace", "NameSp", " namespace", "namesSp", "NameFrame", "nameFrame", " nameFrame", "NameName", "namePath", "Namespace", "NameSpace", " namePath", "namesspace", " nameString", "nameName", "resourcePath", " nameSp"], "replace": ["complete", "be", "pair", "address", "alias", "change", "place", "apply", "save", "parse", "re", "br", "use", "force", "flash", "cover", "places", "sub", "space", "protect", "patch", "repeat", "string", "name", "same", "section", "write", "prefix", "where", "like", "remove", "format", "operation", "repl", "align", "r", "fill", "escape", "tag", "join", "quote", "see", "over", "find", "strip", "update", "add", "get", "search", "insert", "store", "match", "append", "fix", "reply", "group", "placed", "comment", "settings"], "with": [" With", "params", "place", "flash", "apply", "id", "partial", "none", "xml", "x", "include", "plugin", "host", "context", "name", "then", "prefix", "spec", "around", "properties", "format", "at", "tag", "join", "layout", "without", " without", "message", "resource", "add", "by", "get", "search", "from", "document", "other", "before", "work", "claim", "style", "and", "With", "some", "settings"], "url": ["address", "base", "client", "window", "feed", "zip", "URL", "path", "xml", "log", "sl", "fl", "Url", "host", "string", "conn", "stream", "image", "ssl", "connection", "user", "browser", "ll", "socket", "buffer", "uri", "service", "resource", "api", "http", "l", "page", "file", "server", "channel", "rl", "blog"], "inputStream": [" inputReader", "outputBuffer", "outputStream", "inputSteam", "xmlSteam", " inputstream", "xmlReader", " inputSteam", "inputContent", "InputContent", "Inputstream", "xmlStream", "outputstream", "outputReader", "InputBuffer", "inputReader", " inputContent", "InputSteam", "inputstream", "inputBuffer", "InputReader", "InputStream", " inputBuffer"], "xmlContent": ["jsonHeader", "xmlContents", "xmlDocument", " xmlData", "broadMessage", " xmlAddress", "eventAddress", "eventContent", " xmlContents", "mlDocument", " xmlReader", " xmlDocument", "txtContent", "xmlReader", "txtFile", "broadDocument", "phpData", "fileContent", "mlData", "jsonMessage", "phpContent", "xmlData", "eventContents", "mlString", " xmlFile", " xmlHeader", "fileMessage", "broadText", "jsonReader", "txtAddress", "broadContent", "txtContents", "xmlText", "jsonContent", "mlReader", "xmlFile", "fileString", " xmlText", "eventFile", "xmlString", " xmlString", "phpFile", "xmlHeader", "mlContent", "phpString", "xmlAddress", "mlText", "mlMessage", "mlFile", "mlHeader", "xmlMessage", " xmlMessage", "fileDocument"], "out": ["result", "OUT", "outs", "cache", "builder", "w", "gen", "project", "output", "window", "exp", "io", "path", "log", "name", "ext", "stream", "word", "write", "doc", "err", "prefix", "Out", "plain", "extra", "writer", "report", "user", "b", "ex", "object", "again", "sync", "outer", "array", "key", "flush", "copy", "in", "page", "data", "file", "up", "password", "full", "group", "f", "response", "temp"], "xmlRequestNumber": ["httpRequestNum", "xmlResponseNum", "httpResponsenumber", "xmlRequestCounter", "httpResponseCounter", "xmlFileCounter", "xmlResponseNumber", "xmlVersionnumber", "httpResponseNum", "xmlResponseCounter", "xmlVersionCounter", "httpResponseNumber", "httpRequestNumber", "xmlFileNum", "xmlRequestNum", "xmlFilenumber", "xmlFileNumber", "xmlResponsenumber", "httpRequestCounter", "xmlVersionNum", "xmlVersionNumber", "httpRequestnumber", "xmlRequestnumber"], "byteArrayInputStream": ["byteArrayTextArray", "byteArrayOutputArray", "byteArrayByteStream", "byteStreamInputArray", "byteArrayReadSteam", "byteArrayReadFile", "byteStreamInputStyle", "byteArrayOutputSteam", "byteStreamInputFile", "byteStreamOutputstream", "byteStringInputSteam", "byteStreamOutputStream", "byteArrayTextStream", "byteStringInputstream", "byteArrayOutputFile", "byteArrayByteSteam", "byteArrayReadstream", "byteArrayInputStyle", "byteArrayOutputStyle", "byteArrayInputFile", "byteArrayReadStream", "byteStreamInputSteam", "byteStreamOutputFile", "byteStringOutputstream", "byteArrayOutputStream", "byteStreamOutputSteam", "byteArrayByteStyle", "byteStreamInputstream", "byteArrayInputSteam", "byteStreamInputStream", "byteStringOutputSteam", "byteArrayTextFile", "byteArrayReadArray", "byteStreamOutputStyle", "byteStreamOutputArray", "byteArrayOutputstream", "byteStringInputStream", "byteArrayInputstream", "byteArrayTextstream", "byteStringOutputStream", "byteArrayInputArray", "byteArrayBytestream"], "source": ["ource", "slave", "position", "result", "reader", "scope", "str", "view", "use", "id", "zip", "proxy", "model", "scene", "sl", "input", "target", "node", "session", "string", "secure", "core", "ge", "stream", "inner", "Source", "spec", "rate", "event", "type", "component", "connection", "info", "class", "g", "null", "text", "object", "rule", "config", "slice", "speed", "uri", "service", "resource", "wrapper", "iter", "plus", "content", "copy", "get", "data", "style", "kin", "src", "sp", "unit", "size", "ce", "SOURCE"]}}
{"id1": "8490710", "id2": "14191679", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 0, "substitutes": {"actualizar": ["actualisiada", "actualizeado", "actualizerar", " actualizeas", "actualizear", "actualizada", " actualizeado", "actualizeras", "actualizeas", " actualizado", " actualizas", "actualizas", "actualizeada", "actualisias", " actualizada", "actualizerado", "actualisiado", " actualizear", "actualisiar", "actualizado", "actualizerada", " actualizeada"], "ClassNotFoundException": ["ClassNameSupportedES", "ClassNameSupportedError", "ClassNotFindError", "ClassNotFoundES", "ClassNotPresentException", "ClassNameFoundException", "ClassNotPresentError", "ClassNotPresentES", "ClassNameFoundError", "ClassNotSupportedException", "ClassNotFindException", "ClassNotSupportedES", "ClassNameSupportedException", "ClassNameFoundES", "ClassNotFindES", "ClassNotSupportedError", "ClassNotFoundError"], "Exception": ["Application", "Event", "ERROR", "ceptions", "Default", "Warning", "Null", "Transaction", "Except", "EX", "X", "Element", "T", " exception", "Ex", "Exc", "Abstract", "Throw", "E", "Exp", "Connection", "Problem", "Failure", "ception", "F", "except", "Unknown", "Un", "Document", "Adapter", "Context", "Request", "Information", "Entity", "Fail", "W", "Error", "Class", "Interface", "IO", "Engine"], "conn": ["cm", "mc", "client", "ca", "ann", "util", "Connect", "ob", "ou", "reg", "jc", "cb", "db", "oci", "comm", "connect", "session", "oss", "sql", "state", "cr", "cp", "c", "ci", "cc", "ct", "en", "connection", "Connection", "n", "cs", "config", "enc", "loc", "nt", "pub", "mm", "sn", "ok", "dc", "p", "h", "pg", "rc", "col", "cli", "cn", "ch", "dh", "ens", "coll", "con", "nc", "cat", "Conn", "conf", "ctx"], "ms": ["mos", "md", "mc", "ins", "MS", "gm", "pse", "pm", "sem", "ts", "rs", "vs", "ws", "bm", "mo", "es", "ims", "mb", "ns", "mt", "ks", "res", "s", "cms", "ls", "sql", "mi", "os", "m", "ys", "models", "js", "cs", "mis", "ops", "ans", "ps", "mes", "mm", "tm", "cus", "ma", "ds", "fs", "em", "oms", "Ms", "mn", "mod", "hm", "me", "is", "ums", "ens", "ems", "mx", "mas", "qs", "DS", "keys", "ml", "details", "bs", "mp", "gs"], "fechaSystem": ["fechlaSys", "fechasSTEM", "febaServer", "fechetaSys", "fekaSystem", "fechaService", "fichasystem", "fechmasystem", "fetchasystem", "fetchaSTEM", "fechasSys", "fekaSTEM", "fechmaSTEM", "fechmaServer", "fekaSys", "fechlaSTEM", "febasService", "fechlaSystem", "fechtasystem", "fechmaService", "fechetaSystem", "fechtaSys", "fetchmaSTEM", "fechaServer", "fekasSys", "fechaSys", "febasServer", "fichlaSystem", "fechlasystem", "fetchmasystem", "fekasSystem", "febaService", "fechaSTEM", "fechasystem", "fechoSystem", "fechoSTEM", "fechosystem", "fechasServer", "fetchaSystem", "febasSys", "fechtaSystem", "fichaSys", "fekasSTEM", "febaSys", "fechmaSys", "fechetaService", "fechetaServer", "febasSystem", "fechasSystem", "fechasService", "fichaSystem", "fechmaSystem", "fetchmaSystem", "fichlasystem", "fechassystem", "fichlaSys", "febaSystem"], "aaaammdd": ["aaaymmdd", "aaaammd", "aaaaamdd", "aaaaamsd", "aaaaammsd", "aaaammsd", "aaaymmds", "aaaamtz", "aaaaammtz", "aaaasmds", "aaaaamds", "aaaymmd", "aaaaamtz", "aaaamds", "aaaymmsd", "aaaaammd", "aaaasmd", "aaaaammdd", "aaammtz", "aaaasmdd", "aaammds", "aaammsd", "aaaaamd", "aaaamdd", "aaaamd", "aaaammds", "aaammd", "aaaammtz", "aaammdd", "aaaaammds", "aaaasmtz", "aaaamsd"], "fzafsis": ["fzhahtics", "fzafsi", "fzahtics", "fzaphsi", "fzhahs", "fzaftics", "fzhafsi", "fzAFs", "fzaphtics", "fzhahsis", "fzaphsis", "fzahsi", "fzhahsi", "fzAFsis", "fzahs", "fzhafs", "fzafs", "fzaphs", "fzhaftics", "fzhafsis", "fzAFtics", "fzAFsi"], "hhmmss": ["HHMMds", "hhhmms", "hhmdess", "HHmmds", "hhMMs", "hhmmds", "hhmdds", "hhmlss", "hhhmmmds", "hhmds", "hhhmmess", "hhmmess", "HHmmms", "hhhmmms", "hhmss", "HHmmss", "hhhmmmess", "hhmlds", "hhhmmmss", "hhmdss", "hhmms", "HHMMms", "hhhmmds", "hhms", "HHmms", "hhmls", "hhMMess", "hhMMss", "hhmmmds", "hhMMms", "hhmlms", "hhMMds", "hhmmms", "hhhmmss", "hhmmmess", "hhmmmss", "HHMMs", "HHMMss"], "sss": ["rssp", "ussses", "\u00dfls", "\u00dfss", "hessns", "ssses", "\u00dfs", " ssses", "ssls", "rsss", " ssp", " ssss", "rssses", "hessls", "usss", "ussp", "hessss", "ssp", "rssns", "rssss", "ssss", "rssls", "ussss", "ssns", "hesss", "\u00dfns"], "ss": ["ross", "su", "less", "sv", "st", "account", "ng", "eps", "str", "ts", "rs", "vs", "ws", "ess", "uss", "sl", "oss", "ns", "string", "s", "ls", "styles", "struct", "tz", "xx", "nn", "si", "iss", "SS", "ses", "hh", "pps", "ssl", "hess", "sq", "js", "\u00df", "cs", "WS", "ps", "ass", "css", "ds", "fs", "pg", "pass", "rss", "ssh", "sf", "bs", "settings"], "fzahsis": ["fzafses", "fzafsi", "fzahtics", "fzavsi", "fzaftics", "fzavsis", "fzajses", "fzeaftics", "fzajsis", "fzeafsi", "fzavses", "fzeajses", "fzahsi", "fzeajtics", "fzajtics", "fzeafsis", "fzavtics", "fzahses", "fzeafses", "fzajsi", "fzeajsis", "fzeajsi"], "afectados": ["rafctados", "afemptados", "rafectado", "rafectados", "afescados", "afectionanos", "afescadas", "AFectadas", "afectionatos", "afemptatos", "rafectatos", "afescanos", "AFectanos", "rafctadas", "afemptadas", "afctados", "rafctatos", "afecanos", "afctado", "afctatos", "afectantes", "afectadas", "afectionados", "afecados", "rafctado", "afecantes", "afectionado", "AFectados", "AFecados", "AFecantes", "afescantes", "afectionantes", "afectionadas", "afectado", "AFectantes", "afemptado", "afectatos", "rafectadas", "AFecadas", "afectanos", "afctadas", "afecadas", "AFecanos"]}}
{"id1": "10674824", "id2": "5682569", "code1": "    @Before\n    public void setUp() throws Exception {\n        final URL url = getClass().getClassLoader().getResource(\"insecureSSL.keystore\");\n        final KeyStore keystore = KeyStore.getInstance(\"jks\");\n        final char[] pwd = \"nopassword\".toCharArray();\n        keystore.load(url.openStream(), pwd);\n        final TrustManagerFactory trustManagerFactory = createTrustManagerFactory();\n        trustManagerFactory.init(keystore);\n        final TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\n        final KeyManagerFactory keyManagerFactory = createKeyManagerFactory();\n        keyManagerFactory.init(keystore, pwd);\n        final KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();\n        final SSLContext serverSSLContext = SSLContext.getInstance(\"TLS\");\n        serverSSLContext.init(keyManagers, trustManagers, null);\n        localServer_ = new LocalTestServer(serverSSLContext);\n        localServer_.registerDefaultHandlers();\n        localServer_.start();\n    }\n", "code2": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"setUp": ["cleanup", "startDown", "cleanUP", "startUP", "startUp", "cleanUp", "setup", " setDown", "startup", " setup", "setUP", "setDown", " setUP", "cleanDown"], "url": ["address", "base", "client", "system", "feed", "URL", "path", "cert", "sl", "Url", "host", "string", "name", "ls", "context", "gl", "image", "ssl", "connection", "class", "user", "browser", "config", "loader", "buffer", "uri", "service", "resource", "api", "key", "http", "l", " URL", "source", "file", "server", "channel", "page", "entry", "src", "manager", "f"], "keystore": ["certStore", "airStore", "trustcache", "trustbase", " keytool", "Keybase", "keystorage", "rowstorage", "certserver", "rowtool", "keytool", " keybase", "trusttool", " keyStore", "truststore", "rowstore", "trustserver", "Keycache", "trustmanager", " keyserver", "Keystore", "keybase", " keycache", "airstore", "airstorage", "rowserver", "trustStore", " keymanager", "KeyStore", "certstore", "Keyserver", "airmanager", "certbase", "keyserver", "truststorage", " keystorage", "keyStore", "keymanager", "keycache"], "pwd": [" pword", " pWD", "ppass", "Ppass", "prepass", " ppass", "cpass", "preword", " pw", "Pw", "PWD", "Pword", "cw", "cwd", "Pwd", "fwd", "pWD", "pw", "prewd", "prew", "pword", "cword", "fword", "fw", "cWD", "fpass"], "trustManagerFactory": ["keyManagerBuilder", "trustDirectoryService", "keyManagerService", "trustManagerBuilder", "trustmanagerInterface", "trustManagementStore", "trustLayerHelper", "trustDirectorBuilder", "trustmanagerHelper", " trustManagerService", "trustDirectorStore", "trustmanagerBuilder", "trustManagerHelper", "keymanagerFactory", "trustmanagerStore", " trustDirectorStore", "trustManInterface", " trustManagerStore", "trustDirectoryBuilder", " trustDirectorFactory", "trustDirectorFactory", "keymanagerBuilder", "keymanagerInterface", "TrustManagerService", "trustManagerInterface", "TrustLayerHelper", "keymanagerService", "TrustLayerService", "trustLayerFactory", "trustManFactory", "TrustManagerFactory", "keyManagerInterface", "trustmanagerFactory", "trustmanagerService", " trustDirectorService", "trustManagementService", " trustDirectorBuilder", " trustManagerBuilder", "trustManagementFactory", "trustManagerService", "trustDirectorHelper", "trustDirectorService", "trustManagerStore", "trustManBuilder", "TrustLayerFactory", "trustLayerService", "trustManService", "trustManagementBuilder", "trustDirectoryInterface", "TrustManagerHelper", "trustDirectoryFactory"], "trustManagers": ["trustMatager", "trustMatagers", "keymanagers", "trustmanagers", " trustmanager", "keyManager", "trustmanages", "trustMages", "trustManagerurers", "keyManages", "trustMager", "trustMaturers", "keymanurers", "trustMatages", " trustManages", "trustmanager", " trustManurers", "trustMagers", "trustManurers", "keymanages", "keyManurers", "trustmanurers", "trustManagerager", "trustManages", " trustmanagers", "trustManageragers", "trustManagerages", " trustManager", " trustmanurers", " trustmanages", "keymanager", "trustManager", "trustMurers"], "keyManagerFactory": ["sslManagementHelper", "keyManagementF", "keyManagerService", "keyManagerF", "keymanagerHelper", "sslManagerInterface", "sslManagerService", "keyManagementFactory", "keymanagerFactory", "keyLayerService", "keyManagementInterface", "keyManagementHelper", "keymanagerF", "keyDirectorService", "keymanagerInterface", "sslManagementFactory", "keymanagerService", "keyDirectorInterface", "trustmanagerF", "keyLayerProvider", "keyManagerInterface", "sslManagementInterface", "keyManagementService", "sslManagementService", "sslManagerHelper", "sslManagerFactory", "trustmanagerService", "keyManagerHelper", "keyDirectorHelper", "trustmanagerFactory", "keyManagerProvider", "trustmanagerProvider", "trustManagerProvider", "trustManagerService", "keyDirectorFactory", "keymanagerProvider", "keyLayerFactory", "trustManagerF"], "keyManagers": ["KeyManagers", "keymanagers", "trustmanagers", "keyMANainers", "keyMuturers", "KeyManapters", "keyMANurers", "keymanapters", "trustmanainers", "keyMANagers", "KeyMANagers", "keyManages", "KeyMANurers", "KeyMANages", "keymanurers", "keyMANages", "keyMANisters", "trustManainers", "KeyManurers", "keyMutagers", "keyMutainers", "keyManisters", "trustManurers", "keyManurers", "trustmanurers", "keymanages", "keymanisters", "trustManisters", "KeyManages", "keyMANapters", "KeyMANapters", "keymanainers", "keyManainers", "keyManapters", "keyMutisters", "trustmanisters"], "serverSSLContext": [" serverSSLFactory", "serverHTTPChannel", "serverSecureClient", " serverSSLClient", "masterSSLChannel", "serverSLFactory", "serverSSLSupport", "serverLSConn", "serverLSContext", "serverSSLFactory", " serverSLSession", "serverSSLChannel", "serverServerContext", "serverHTTPContext", "serverSecurityChannel", "serverHttpSupport", "masterSecurityChannel", "serverLSFactory", " serverSecureConn", "serverServerFactory", "serverSecureContext", "masterSecurityContext", "serverSLSupport", " serverSLSupport", "serverHTTPService", "serverSSLService", "serverSecurityContext", "serverLSClient", "serverSSLClient", "serverSecureConn", "serverSecureFactory", "serverSLSession", " serverSLFactory", "serverSSLConn", " serverSecureFactory", " serverSSLConn", " serverSecureClient", " serverSLContext", "serverSLConn", "serverSLClient", "serverSSLSession", " serverSSLSession", "masterSecurityService", "masterSSLService", "masterSSLContext", "serverServerSupport", " serverSSLSupport", "serverServerSession", "serverSLContext", "serverHttpSession", "serverHttpFactory", "serverSecurityService", "serverHttpContext", " serverSecureContext"], "localServer_": [" localConnectorRes", "serverClientPool", " localConnector_", "localServicelib", "globalServerPool", "localserverPool", "localService_", " localConnectorlib", "localserverWork", "localServerWork", "serverServerWork", " localServerlib", "globalServer_", "serverClient_", "localConnectorlib", "localClientWork", "localSocketPool", "localManager_", "serverClientWork", "localClientPool", "localPort_", "localPortWork", "localConnectorRes", "localPortPool", "localClient_", "localManagerRes", "localServerRes", "globalSocket_", "localConnector_", "localserver_", "localServerlib", "serverServerPool", "globalSocketPool", "localServerPool", "localSocket_", "localManagerlib", "localServiceRes", "serverServer_", " localServerRes"]}}
{"id1": "16466743", "id2": "14590676", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    public static void download(String address, String localFileName) {\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            URL url = new URL(address);\n            out = new BufferedOutputStream(new FileOutputStream(localFileName));\n            conn = url.openConnection();\n            in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n            System.out.println(localFileName + \"\\t\" + numWritten);\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getmd5": ["getmd6", "getmn5", " getMD12", "getmd12", " getmd6", "getmetadata6", "getmd512", " getMD5", "getmn512", "getmetadata5", "getmetadata512", "getMD5", "getmn6", "getMD12", "getmetadata12", " getMD6", " getmd12", "getMD512", " getmd512", " getMD512", "getmn12", "getMD6"], "password": ["hash", "address", "encrypted", "account", "token", "Password", "login", "sword", "path", "input", "pattern", "string", "name", "word", "prefix", "auth", " Password", "words", "username", "crypt", "number", "text", "config", "pad", "padding", "message", "buffer", "attribute", "array", "p", " passwords", "key", "wd", "phrase", "data", "PASS", "secret", "email", "pass", "f"], "pwHash": ["PWSum", "pwhMac", "pwhash", "PwSum", "pxMac", "qxSum", "pwaHash", "pwMac", "pwdDig", "PWHash", "qwSum", " pwSum", "pwdSum", "PWMac", "pweHash", "pwehash", "pwdMac", "pwaSum", "pwaMac", "pwdHash", "pWMac", "pwBlock", "pwtMac", "pwhBlock", "pwSum", "pWSum", " pwaSum", "qxDig", "qxHash", "pxDig", "qxMac", "pWHash", "qwMac", "pwaDig", "pxHash", "PwHash", "pwdhash", "pwahash", " pwDig", "pwtBlock", " pwaHash", "pxSum", "PwMac", "pWBlock", "pwDig", " pwahash", "PWBlock", "pwhHash", "pwtSum", " pwaDig", " pwhash", "pwhSum", "qwHash", "pweSum", "pwtHash", "PwBlock", "qwDig", "pweDig"], "md": ["MD", "hash", "cm", "mc", "dig", "ms", "sha", "metadata", "rm", "pm", "bd", "amd", "db", "am", "bm", "um", "mo", "meta", "mb", "mt", "mage", "cmd", "M", "sm", "mi", "mand", "m", "dd", "Cmd", "od", "mg", "mm", "ma", "ad", "pd", "cd", "dc", "kg", "mac", "hm", "mod", "me", "ld", "d", "mag", "nm", "dm", "mu", " MD", "mp"], "b": ["base", "ib", "bb", "gb", "ob", "bin", "br", "e", "bd", "nb", "emb", "db", "bis", "fb", "ba", "mb", "binary", "u", "orb", "buff", "sb", "a", "batch", "r", "lb", "buf", "bi", "wb", "buffer", "ab", "eb", "p", "bytes", "rb", "reb", "l", "B", "d", "bf", "bs", "cb", "f", "be"], "i": ["qi", "v", "z", "base", "ip", "ai", "ti", "vi", "I", "e", "id", "io", "xi", "x", "index", "start", "u", "li", "s", "ui", "multi", "c", "ci", "si", "phi", "ii", "j", "a", "r", "info", "n", "o", "bi", "zi", "block", "slice", "ri", "uri", "p", "it", "gi", "h", "abi", "l", "oi", "data", "di", "ni", "d", "chi", "ji", "mu", "f", "pi"]}}
{"id1": "160739", "id2": "884867", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createInputReader", "createInputFile", " createIOReader", "createInputSteam", " createOutputReader", " createIOFile", " createByteReader", "createOutputReader", "createInputStream", " createOutputSteam", " createByteFile", "createOutputFile", " createInputSteam", " createIOStream", " createOutputFile", "createInputReader", " createInputStream", " createByteStream", " createInputFile", "createOutputSteam", " createIOSteam", " createByteSteam"], "inFile": ["sourceFiles", "sourceStream", "inputFile", "incFile", "outStream", "infile", "insfile", "inputStream", "incfile", "sourcefile", "inStream", "insFile", "incStream", "sourceFile", "inputFiles", "incFiles", "insStream", "outfile", "inFiles", "outFiles", "insFiles", "inputfile"], "outFile": ["workingfile", "outDir", "inputDir", "workFile", "targetFile", "inputFile", "workTime", "workingStream", "targetfile", "outStream", "workfile", " outfile", "infile", "outDirectory", "inTime", "workDir", "inputTime", " outStream", " outDirectory", "targetStream", "targetDirectory", "outTime", "outfile", "workingFile", "inDir", "workingDirectory", "inputfile"], "k_blockSize": ["k_lockCount", "k_BlockLength", "k_BlockCode", "k_byteCode", "k_byteLength", "k_lineInfo", "k_BlockSize", "k_blockCount", "k_blocksSize", "k_byteLen", "k_bitSize", "k_lineCount", "k_blocksCount", "k_bitCount", "k_lockLength", "k_lockLen", "k_BlockCount", "k_blockLen", "k_byteSize", "k_blocksLen", "k_bitInfo", "k_blockInfo", "k_blockCode", "k_byteCount", "k_lockCode", "k_blocksLength", "k_lineSize", "k_lockSize", "k_byteInfo", "k_blockLength"], "byteCount": [" bytecount", "blockSum", "byteSize", "bytecount", "byteLength", "flushCount", " byteSize", "flushcount", "characterCount", "blockSize", "blockCount", "characterLength", "blockLength", "Bytecount", "ByteSize", "byteSum", "flushLength", "ByteCount", " byteLen", "byteLen", "characterSize", "ByteLength", "ByteSum", " byteSum", "ByteLen", "flushSize", "characterLen", " byteLength"], "buf": ["vec", "uf", "Buffer", "cap", "result", "base", "img", "exc", "tmp", "cv", "feed", "brace", "font", "ctx", "fb", "border", "seq", "cmd", "queue", "len", "alloc", "bag", "Buff", "batch", "b", "background", "loc", "config", "buffer", "la", "bytes", "rb", "flush", "cas", "fd", "feat", "rc", "ucc", "data", "append", "bh", "src", "bf", "cb", "buff"], "ofp": ["fort", "afc", "Ofnp", "afp", "OFl", "forc", "ofnp", "Oft", "oftp", "forp", "OFt", "Ofp", "OFp", "oft", "ofl", "afl", "ofc", "afnp", "fortp", "OFc", "OFnp", "Ofc", "Oftp", "Ofl", "OFtp"], "zos": ["osi", "outs", "kos", "core", "zon", "budget", "zes", "os", "modules", "ozo", "zyk", "los", "ossus", "cos", "jas", "inos", "robe", "ZI", "zik", "utils", "zy", "enos", "soon", "ls", "zen", "zona", "zn", "iframe", "zi", "css", "rons", "zag", "hz", "abi", "forge", "bes", "obb", "ros", "oS", "bitcoin", "zar", "ZA", "zh", "zip", "zers", "oda", "liquid", "tz", "zl", "webkit", "bos", "owicz", "js", "za", "lins", "oses", "zx", "nz", "rez", "gz", "lol", "dylib", "z", "zin", "ws", "uz", "ses", "cfg", "iffs", "zer", "ops", "zo", "fits", "zig", "ogl", "obs", "zb", "packs", "nox", "bs"], "osw": ["lsx", "osww", "ishell", "esow", "bwo", "ossww", "essw", "oshell", "esw", "lsws", "oswo", "esnow", "osssw", "lswo", " osow", "bx", "osnow", "bsws", "osow", "ossw", "bsw", "bws", "esfw", "osswd", "isy", "isnow", "isw", "ossnow", "ossd", "esd", "osy", "osshell", " osww", "osws", "esww", "isd", "esy", "lsw", "ossow", "eswd", "iswd", " osfw", "ossfw", "issw", "ossy", "bswo", "osfw", "eshell", "bsx", "osx", "osd", "oswd"], "bw": ["lbwh", "abW", "bbz", "bbw", "abw", "bW", "bbew", "bbwa", " bwh", " bws", "lwa", "lbw", "bwa", "Bws", "baw", "bbws", " bwa", "owa", "bx", "fbwd", "bwu", "ebwd", "bwd", "lx", "bsw", "Bwa", "bwh", "bz", "bws", "lbws", "ebw", "fsw", "fbwe", "lbwa", "Bew", "fbW", "fx", "fwh", "bwe", "lbr", " bwu", "Bw", "lw", "bbwu", "lbx", "ow", "owu", "lsw", "fr", "fwa", "lbsw", "abwe", "bew", " baw", "lbz", "ebwe", "fbw", "fw", "bbaw", " bz", " bew", "ebW", "oaw", "bbwh", "abwd"], "zot": ["jot", "zott", " zor", "jori", "Ziot", "azit", "zerot", "jit", "Zor", "zita", "azita", "zeros", " ziot", "azot", "zor", "jos", "azott", "zerott", "zerita", " zori", "aziot", "Zott", "zori", "Zot", "azor", "zerori", "ziot", "Zita", "Zit", "zerit"], "ifp": ["ipl", "ipc", "iff", " ifb", "Iff", " ifi", "IFi", "ifb", "Ifi", "IFf", " ifl", "IFb", "ifi", "ipp", " ifc", "IFp", "ifc", "ipb", "IFl", "Ifc", "IFc", "ifl", "Ifp", " iff"], "zis": ["zipis", "xib", " zits", " zisi", "zeis", "xis", "zip", "zeip", " zib", "jit", " zIS", "Zits", "Ziss", "jits", "zenIS", "xits", "zeits", "zenib", "xais", "zais", "jisi", "xisi", "zenais", "Zis", "jis", "zipiss", "zib", "zIS", "zipits", "zisi", "xIS", "zipip", "zenis", "zeiss", "Zip", "zits", "xit", " zais", "ziss"], "isr": ["IScr", "isrs", "risr", " issr", "issrs", "risrc", "isrc", "rispr", "isrb", "isscr", "ISsr", "irpr", "ISrs", "isssr", "irrb", "ispr", "ISrc", "ISrb", "ISpr", " isrs", "irrc", "risrb", "ISr", " iscr", "iscr", "issr", "irr"], "br": ["yr", "bc", "obl", "img", "mr", "sr", "str", "ob", "bp", " Br", "ibr", "ber", "HR", "arr", "div", "hr", "rib", "bsp", "obi", "bro", "err", "bl", "Br", "r", "b", "kr", "browser", "bar", "body", "tr", " dr", "fr", "lr", "ibl", "rb", " fr", " BR", "BR", "ch", "bh", "gr", "cro", "sp", "ctr", "rs", "shr", "ocr"], "zit": ["zenits", "zenitter", " zits", "zipit", "zipitter", "zenit", "zip", "zenith", "xi", "jita", " zip", "zipita", "jit", "zipith", "zeit", "jits", " zite", "zith", "jith", "zita", "zeits", "zIT", "zeIT", "zeith", "zipIT", "zitter", "jite", "zi", "xith", "xic", " zic", " zith", "zeitter", "zite", "jip", "zipits", "zipite", "jic", "zipip", "ji", "zits", "xit", "zic", "jIT", "zeita", " zi"]}}
{"id1": "400275", "id2": "22879400", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "label": 0, "substitutes": {"url": ["address", "base", "ob", "el", "id", "feed", "io", "URL", "path", "xml", "sl", "Url", "host", "location", "string", "name", "filename", "image", "link", "ssl", "connection", "html", "null", "ll", "www", "config", "loc", "loader", "ur", "buffer", "uri", "service", "resource", "fr", "bel", "lr", "http", "href", "l", "source", "file", "server", "ref", "rl", "f"], "in": ["gin", "ins", "reader", "din", "IN", "token", "login", "bin", "id", "io", "inc", "isin", "xml", "ini", "val", "input", "out", "In", "conn", "cms", "inner", "image", "err", "c", "this", "m", "or", "ssl", "a", "i", "r", "ex", "n", "again", "config", "socket", "nin", "inn", "resource", "min", "pin", "is", "data", "source", "file", "init", "inside", "rin", "con", "as", "part", "serv", "impl", "f"]}}
{"id1": "20929570", "id2": "19810820", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"toMd5": ["toMcd5", "toBd15", "toBmd15", "toMm5", "toMmd7", "toMcd512", "toMm512", "toMm15", "toMd512", "toMd7", "toBmd5", "toMcd15", "toBmd7", "toMmd5", "toBmd512", "toMmd512", "toMmd15", "toMm7", "toMcd7", "toBd7", "toBd512", "toBd5", "toMd15"], "str": ["url", "result", "st", "sr", "e", "br", "exp", "arr", "sec", "input", "string", "out", "s", "obj", "conn", "name", "err", "Str", "r", "b", "kr", "text", "tr", "STR", "enc", "fr", "buffer", "bytes", "dr", "in", "stri", "data", "char", "source", "pass", "sp", "txt", "f", "msg", "temp"], "messageDigest": ["Messagedigester", "moreDigester", "messageHashester", "MessageMarkester", "moredigeter", "messageHashest", "MessageDefester", " messageDigEST", "messagedigester", "Messagedigested", "MessageMarkest", "MessagedigEST", "moredigested", "messageUploadested", " messageDiguster", "messageGest", "messageMarketter", "MessageDefested", "messageUploadest", "messageDse", "messageDigested", "messageDigeter", "messageDuster", "messageMarkester", "messagedigetter", "MessageDigester", "MessageDigested", "messageDigester", "messageDigher", "messageDher", " messageDest", "messageDiguster", "messageGuster", "moreDigest", "MessageDigEST", "MessageMarkher", " messageDEST", "messageMarkher", "moreDigested", "MessageDefest", "messageDigse", "messageGester", "Messagedigest", "MessageDigher", "MessageMarketter", "messageDest", "MessageDefse", " messageDuster", " messageDigester", "MessageDigse", "moreDigeter", "messageGEST", "messageDEST", "messagediguster", "MessageDigest", "messageMixse", "messagedigeter", "messagedigEST", "messageDested", "messageDeter", "messageMarkest", "messageDigEST", "messagedigested", "messageDefested", "messageHasheter", "messagedigest", "messageDester", "messageDigetter", "messageMixested", "messageMixester", "messageDefest", "messageDefester", "messageHashested", " messageDester", "moredigester", "messageDefse", "messageUploadEST", "messageMixest", "messageUploadester", "messagedigher", "messageDetter", "MessageDigetter", "moredigest"], "byteArray": ["ByteOrder", "wordBuffer", "wordString", "pixelArray", "bitBuffer", "byteIndex", "byteAmount", " byteAddress", "byteLength", "charObject", "resourcearray", "charAddress", "resourceLength", "bitIndex", "wordArray", "byteBuffer", "charLength", "bitLength", "charBuffer", "ByteAddress", "pixelObject", "wordarray", "charArray", " byteNumber", "ByteNumber", " byteString", "doublearray", "byteNumber", "byteString", " byteIndex", "charNumber", "doubleArray", "bitObject", "ByteAmount", "pixelLength", "ByteBuffer", "byteAddress", "doubleString", "bitArray", "doubleBuffer", " byteOrder", "bytearray", "charOrder", "resourceArray", "resourceIndex", "charAmount", "ByteLength", "ByteArray", "byteOrder", "byteObject", " byteAmount", "pixelBuffer", " byteBuffer", "bitarray", " byteLength", " bytearray"], "md5StrBuff": ["md5StRef", "md5STRBuff", "md6strBuffer", "md2StringComp", "md2StrBuffer", "md2StringRest", "md5TrDb", "md2StringText", "md5StringRest", "md2StringDb", "md6strBuff", "md6StrBuffer", "md2StringRef", "md5StrApp", "md5StrRest", "md5StringComp", "md5STRRest", "md5TrBuff", "md5StringText", "md5STRComp", "md5StText", "md2StrBuff", "md6StrBuff", "md2StringBuffer", "md5StrDb", "md5strText", "md6strText", "md5TrRef", "md2StrDb", "md6Strbuff", "md5StringApp", "md5strApp", "md5StComp", "md5StDb", "md5strbuff", "md5Stringbuff", "md2StrText", "md5StringDb", "md5TrText", "md5StringBuffer", "md2StrComp", "md2StrRest", "md5StrRef", "md5StApp", "md5TrBuffer", "md5StRest", "md5Strbuff", "md5StringBuff", "md6StrText", "md5StrComp", "md2StringApp", "md5StrBuffer", "md5STRBuffer", "md5strBuffer", "md2StrRef", "md5Trbuff", "md2StrApp", "md5StringRef", "md5StrText", "md6strbuff", "md2StringBuff", "md5StBuff", "md5StBuffer", "md5strBuff"], "i": ["qi", "v", "lc", "k", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "index", "length", "name", "li", "u", "ui", "inner", "multi", "ci", "c", "si", "phi", "ii", "y", "j", "ie", "info", "b", "n", "o", "bi", "slice", "ri", "uri", "p", "gi", "it", "h", "fi", "abi", "ix", "in", "di", "oi", "l", "d", "field", "ji", "part", "mu", "f", "pi"]}}
{"id1": "13563706", "id2": "20619879", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", "handleGET", "didget", " doPut", "didGET", "handlePut", "doGET", "didGet", "handleget", " doget", "didPut", "doget", "doPut", "handleGet"], "request": ["complete", "url", "result", "client", "view", "QUEST", "current", "model", "Response", "xml", "remote", "input", "string", "queue", "image", "event", "type", "info", "report", "method", "user", "application", "connection", "object", "query", "config", "message", "buffer", "attribute", "resource", "p", "Request", "document", "data", "server", "req", "create", "instance", "frame"], "response": ["wa", "result", "header", "error", "client", "description", "status", "re", "output", "view", "site", "feed", "model", "Response", "index", "res", "location", "image", "results", "respond", "reason", "writer", "connection", "report", "application", "object", "body", "query", " Response", "message", "service", "resource", "api", "document", "http", "resp", "server", "pool", "subject", "reply", "onse", "json", "collection"], "selectedPage": [" selectedButton", "namedSite", "namedpage", "electedButton", "selectedpage", "electedLine", " selectedpage", "namedFile", "selectedLine", "selectionFile", "lectedItem", "selectionLine", "selectedHour", "namedPage", "selectionButton", "lectedpage", "selectionHour", "selectionPage", "selectedAction", " selectedHour", "electedPage", "selectionItem", "lectedSite", "lectedFile", "selectionpage", "selectionAction", "selectedButton", "selectedItem", "lectedLine", " selectedItem", "lectedHour", " selectedLine", "namedLine", "lectedPage", "electedpage", " selectedSite", "lectedButton", " selectedFile", "selectedFile", "lectedAction", "selectedSite", " selectedAction"], "page": ["address", "cache", "port", "model", "row", "location", "queue", "section", "route", "message", "display", "p", "document", "age", "peer", "article", "server", "sp", "f", "client", "child", "je", "pl", "fe", "user", "number", "rule", "block", "pg", "pool", "pp", "item", "position", "result", "account", "change", "project", " Page", "language", "menu", "parent", "ice", "per", "office", "resource", "me", "channel", "unit", "module", "url", "ip", "phone", "site", "view", "proxy", "plugin", "ge", "node", "profile", "image", "Page", "type", "connection", "html", "handler", "layout", "point", "instance", "photo", "record", "po"], "portalRequest": ["portpalRequest", "portelRequest", "portallServer", "PortortalUser", "PortalAccess", "portugalOrder", "portallingAccess", "portbalResponse", "portelQuery", " portalPage", "PortortalCommand", "PortalOrder", "portailResponse", "portalCommand", "portelCommand", "portortalAccess", "portalUser", "portpalResponse", " portalQuery", "portortalRequest", "portialQuery", " portialResponse", "portallingRequest", "portALUser", "portailUser", "PortalPage", "PortalUser", "portugalResponse", "portalResponse", "portalServer", "PortalResponse", "PortalRequest", "portbalRequest", "PortalEvent", "PortortalEvent", "portugalUser", "portallRequest", "portailOrder", "portalOrder", "portpalAccess", "portalAccess", "portelResponse", "PortortalAccess", "portortalOrder", "portALRequest", "PortortalResponse", " portialPage", "PortalServer", "portortalEvent", "portortalUser", "portailRequest", "portalPage", "portugalEvent", "portialRequest", "portialResponse", "portbalPage", "portortalServer", "PortortalServer", "portortalPage", "PortortalPage", "portpalPage", "portalEvent", " portalResponse", "portALEvent", "portortalResponse", "portallingCommand", "portallResponse", "portelPage", " portialQuery", "portialPage", "portalQuery", "portallingResponse", "portallUser", "PortortalRequest", "portortalCommand", "portugalServer", "portallingPage", "PortortalOrder", "portugalRequest", "portbalQuery", " portialRequest", "portALResponse", "PortalCommand"], "pageProp": ["PagePro", "parentProperty", "projectProperty", "resourceprop", " pageProperty", "pluginProperty", "pageProperty", "peerProp", "parentObj", "pluginProp", " pageStr", "parentProp", "Pageprop", "pageStr", "agePro", "PageStr", "resourceProperty", "resourcePro", "pluginprop", "projectPro", "ageProp", "peerStr", "pluginPro", "PageProp", "PageObj", "projectprop", "projectProp", " pagePro", "peerProperty", "pagePro", "resourceProp", "peerPro", "parentPro", "PageProperty", "ageProperty", "pageObj", " pageObj", "ageprop", "pageprop"], "possiblePage": ["possiblyLine", "possiblyPages", "puredItem", "patchingpage", "possibilityPage", "permanentPage", "pablePage", "patchedOrder", "possibilitypage", "PossibleItem", "PossiblyPage", "possiblyGroup", "possibilityPages", "possiblypage", "PossibleGroup", "possibleItem", "PossiblyLine", "PossibilityPages", "PossibleLine", "PossiblyOrder", "PossiblePage", "possiblePages", "PossiblyItem", "Possiblepage", "PossibilityLine", "patchingPage", "possiblyOrder", "patchedLine", "PossiblePages", "patchingGroup", "permanentpage", "patchingItem", "permanentOrder", "possiblepage", "possibleOrder", "possibleLine", "PossibleOrder", "possiblyItem", "Possibilitypage", "Possiblypage", "possiblyPage", "pableLine", "possibilityLine", "possibleGroup", "PossiblyGroup", "patchedPage", "permanentLine", "puredPage", "pablepage", "puredpage", "pablePages", "PossibilityPage", "puredGroup", "patchedpage"], "property": ["address", "feature", "result", "header", "prop", "project", "term", "operator", "function", "uration", "name", "string", "profile", "binary", "language", "section", "set", "prefix", "binding", "character", "expression", "entity", "properties", "layer", "t", " Property", "type", "duration", "class", "number", "object", "Property", "config", "future", "integer", "table", "attribute", "resource", "p", "key", "perties", "data", "notation", "maximum", "variable", "value", "label", "f"], "referer": [" refrer", " refeline", "affrer", "defrer", "redeline", "rederer", "Referers", "diffender", "refber", "refender", "deferer", "ferers", "redrer", " refere", "Refre", "afferen", "rerer", "reere", "refrer", " referers", " refiner", "differer", "refre", "reerer", "Referen", "afferer", "defber", "redber", " refber", "Refender", "defere", "Refiner", "reiner", "fere", "referen", "refeline", "Refber", "refiner", "diffiner", "rere", " refre", "frer", "Referer", "referers", "Refere", "ferer", "Refeline", " referen", "diffrer", "affere", "Refrer", "refere", "defender", " refender"], "e": ["de", "esi", "error", "exc", "ele", "one", "ea", "es", "er", "ee", "err", "this", "E", "fe", "eme", "or", "event", "element", "ie", "i", "type", "a", "null", "ception", "see", "o", "message", "ae", "p", "me", "se", "d", "ed", "f"]}}
{"id1": "530882", "id2": "88047", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewwrite", "readandRewrite", "readandrewrites", "readAndSwrites", "readAndrewrite", "readAndRebrite", "readandRewwrite", "readAndrewwrite", "readAndRebrites", "readandrewwrite", "readandrewrap", "readAndSwwrite", "readandRewrap", "readandRewrites", "readAndrewrap", "readAndRewrites", "readAndrewrites", "readAndRebrap", "readAndRewrap", "readAndSwrap", "readandrewrite", "readAndSwrite", "readAndRebwrite"], "inFile": ["oldFilename", "InFiles", "Infile", "oldFiles", "loginFilename", "inputFile", "InFile", "InSourceFile", "loginFile", "infile", "oldfile", "inputFiles", "oldFile", " infile", "inputFilename", " inFilename", "loginfile", "outfile", "loginFiles", "inFilename", " inSourceFile", "outSourceFile", "inFiles", "outFiles", "outFilename", "inSourceFile", " inFiles", "inputfile"], "outFile": ["newDir", "thisfile", "outDir", "processPlace", "OutStream", "thisFILE", "OutDir", "outFILE", "newFile", "offFile", "offFILE", "thisFilename", "outputFILE", "outStream", "outputFilename", "offFilename", " outfile", "exfile", "offPlace", "processFILE", "outputPlace", "thisFile", "processFilename", " outStream", " outDir", "outputfile", "newfile", "newStream", "exFilename", "outfile", "exFILE", "outPlace", "OutFile", "processFile", "exFile", "Outfile", "outFilename", "outputFile"], "iis": ["Iis", "iiris", " iiss", "iiIs", "ciIs", "ciIS", "ciis", "Iiss", "Iais", "iniiss", "iniIs", "iiss", "iniris", "ciais", "iiiss", " iIS", "iniIS", " iais", "iIS", " iIs", "iiIS", "iIs", " iris", "iris", "ciiss", "iniis", "iiis", "IIS", "ciris", "iais"], "dcmParser": [" dcrPlugin", "dmParser", " dcmHelper", " dcmarser", "fcmHandler", "dpmPlugin", "dcrPar", "fpmParser", "dCMReader", "dcmLoader", " dcmPlugin", "dpmLanguage", "dkmParser", "fpmparser", "dcmHelper", " dpmLanguage", "dmcParser", "dbmPolicy", "dcrReader", "dmcPar", " dpmParser", "dmissionReader", "dCMHandler", " dcmparser", "dmissionPlugin", "dmPlugin", "dmmparser", "dCMParser", "dpmHandler", "dbmHelper", "dpmReader", "dpmInstallation", " dcrLoader", "dbmPlugin", " dpmarser", "dmmLoader", "dhemJar", "dmoduleparser", "DcmReader", " dcrParser", " dpmJar", "dcmPolicy", "DcmInstallation", "dhemInstallation", "dmcJar", " dpmPolicy", "dpmparser", " dpmHelper", "dmissionLanguage", "dcmPar", " dpmparser", "dcmReader", "dpmPar", "fpmHandler", "dmodulePlugin", "dkmPlugin", "dbmParser", "dcmparser", " dcmPar", "dkmPolicy", "dmoduleParser", "dcrPlugin", "fcmParser", "dCMPlugin", "dmoduleJar", "dmcarser", "dcmPlugin", "dmoduleReader", " dcmPolicy", "DcmJar", "dcrParser", " dpmPlugin", "dCMLoader", " dcrReader", "DcmParser", " dcmLanguage", "dpmJar", "dmissionParser", "dhemParser", "dcmarser", " dcmJar", "dcmInstallation", "dpmParser", "dCMparser", "dmmPlugin", "dcrLoader", "dcrarser", "fpmReader", " dpmPar", "dcrJar", "dpmLoader", " dpmLoader", "dmLoader", "dmmParser", " dpmReader", "dcmJar", "fcmReader", "dhemReader", "dkmHelper", "fcmparser", "dpmarser", "dpmHelper", "dpmPolicy", " dcmLoader", "dcmHandler", "dcmLanguage", "dmReader", " dcmReader"], "ds": ["sys", "services", "da", "Os", "ins", "Ds", "ays", "eps", "xs", "ts", "ils", "db", "vs", "tx", "ws", "nas", "ads", "df", "session", "ns", "ks", "asi", "ls", "s", "conn", "iss", "os", "dd", "Db", "gd", "des", "ys", "dat", "js", "cs", "vals", "drivers", "cdn", "ps", "sync", "pd", "dc", "parts", "uds", "ants", "dt", "dr", "di", "dds", "data", "is", "ld", "qs", "amps", "DS", "d", "src", "icks", "details", "utils", "points", "ss", "bs", "ros", "tes", "rs", "gs", "ras"], "pdReader": ["pcRead", "pcLoader", "dsreader", "hdWriter", "xdReader", "xdRead", "hdRunner", "hdStream", "pcWriter", "hdRead", "ddStream", "dsLoader", "pbRunner", "pcReader", "dsReader", "dsRead", "hdreader", "pbLoader", "hdLoader", "ddRunner", "pdLoader", "pbStream", "pdStream", "pdreader", "pdRunner", "dsWriter", "pbReader", "hdReader", "xdreader", "pdRead", "xdWriter", "ddReader", "ddLoader"], "out": ["external", "outs", "cache", "gen", "inc", "model", "session", "conn", "name", "doc", "ssl", "writer", "at", "null", "with", "data", "file", "full", "group", "part", "as", "client", "child", "term", "db", "dot", "s", "ext", "word", "to", "lock", "write", "down", "Out", "user", "object", "o", "her", "key", "store", "page", "in", "cli", "password", "device", "later", "net", "result", "base", "OUT", "w", "login", "io", "auto", "obj", "inner", "err", "lib", "code", "layer", "again", "parent", "over", "oder", "list", "outer", "copy", "director", "temp", "exec", "flow", "sys", "url", "img", "builder", "output", "exp", "default", "image", "order", "connection", "ex", " in", "co", "sync", "diff", "array", "point", "line", "up", "pass", "dev", "manager"], "dcmEncParam": ["dcmElType", "dcmEnParam", "dcmEstType", "dcmEstPar", "dcmDecPart", "dcmDecParameter", "dcmArchParameter", "dcmEnArg", "dcmEncArg", "dcmElPar", "dcmEncParameter", "dcmDecType", "dcmSecType", "dcmEncPart", "dcmDecParam", "dcmEnType", "dcmSecPart", "dcmEncType", "dcmArchParam", "dcmSecPar", "dcmEnPart", "dcmSecParam", "dcmDecArg", "dcmEnPar", "dcmEstParam", "dcmElParameter", "dcmElParam", "dcmEstParameter", "dcmDecPar", "dcmEnParameter", "dcmArchArg", "dcmEncPar"], "pdWriter": ["PDWrite", "dpWrite", "hdWriter", "htReader", "ddWrite", "dpReader", "pdWriting", "dsOutput", "dsReader", "dpWriter", "hdWrite", "PDWriter", "dpWriting", "PDReader", "htWriting", "dsWriter", "hdReader", "htWrite", "htWriter", "PDWriting", "ddWriter", "ddOutput", "hdOutput", "pdOutput", "dsWrite", "ddReader", "pdWrite"]}}
{"id1": "5683576", "id2": "812803", "code1": "    public String shorten(String url) {\n        List<NameValuePair> qparams = new ArrayList<NameValuePair>();\n        qparams.add(new BasicNameValuePair(\"version\", \"2.0.1\"));\n        qparams.add(new BasicNameValuePair(\"longUrl\", url));\n        if (login != null) {\n            qparams.add(new BasicNameValuePair(\"login\", login));\n            qparams.add(new BasicNameValuePair(\"apiKey\", apiKey));\n            qparams.add(new BasicNameValuePair(\"history\", \"1\"));\n        }\n        try {\n            BasicHttpParams params = new BasicHttpParams();\n            DefaultHttpClient httpclient = new DefaultHttpClient(params);\n            URI uri = URIUtils.createURI(\"http\", \"api.j.mp\", -1, \"/shorten\", URLEncodedUtils.format(qparams, \"UTF-8\"), null);\n            HttpGet httpget = new HttpGet(uri);\n            if (logger.isDebugEnabled()) logger.debug(\"HttpGet.uri={}\", httpget.getURI());\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                InputStream instream = entity.getContent();\n                JsonFactory f = new JsonFactory();\n                JsonParser jp = f.createJsonParser(instream);\n                JmpShortenResponse responseObj = new JmpShortenResponse();\n                for (; ; ) {\n                    JsonToken token = jp.nextToken();\n                    String fieldname = jp.getCurrentName();\n                    if (logger.isDebugEnabled()) logger.debug(\"Token={}, currentName={}\", token, fieldname);\n                    if (token == JsonToken.START_OBJECT) {\n                        continue;\n                    }\n                    if (token == JsonToken.END_OBJECT) {\n                        break;\n                    }\n                    if (\"errorCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorCode(jp.getIntValue());\n                    } else if (\"errorMessage\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorMessage(jp.getText());\n                    } else if (\"statusCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setStatusCode(jp.getText());\n                    } else if (\"results\".equals(fieldname)) {\n                        Map<String, ShortenedUrl> results = parseResults(jp);\n                        responseObj.setResults(results);\n                    } else {\n                        throw new IllegalStateException(\"Unrecognized field '\" + fieldname + \"'!\");\n                    }\n                }\n                Map<String, ShortenedUrl> results = responseObj.getResults();\n                if (results == null) {\n                    return null;\n                }\n                ShortenedUrl shortened = results.get(url);\n                if (shortened == null) {\n                    return null;\n                }\n                if (logger.isDebugEnabled()) logger.debug(\"JmpShortenResponse: {}\", responseObj);\n                if (\"OK\".equals(responseObj.getStatusCode())) {\n                    return shortened.getShortUrl();\n                }\n                if (logger.isWarnEnabled()) logger.warn(\"JmpShortenResponse: {}\", responseObj);\n            }\n        } catch (IOException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        } catch (URISyntaxException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        }\n        return null;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"shorten": ["Shorten", "shortener", "shortening", "offening", " Shortend", "shortend", "Shortend", " Shortening", "Shortening", "offend", "offen", " Shorten", "Shortener", " Shortener", "offener"], "url": ["address", "base", "account", "login", "str", "id", "URL", "term", " resource", "path", "request", "sl", "Url", "host", "location", " webpage", "string", "ls", "language", "name", "username", "info", "method", "route", "text", "www", "config", "service", "api", "resource", "version", "key", "http", "l", "page", "source", "data", "server", "file", "email", "secret", "json"], "qparams": [" qtypes", "kparams", "kresults", "Qtypes", "questproperties", "reqproperties", "qutags", "reqtags", "kams", "Qplugins", "qvals", "sqchanges", "questplugins", "reqparams", "qutypes", "quproperties", "qParameters", " qams", "sqresults", "sqtags", " qchanges", "Qnames", "qtproperties", " qParameters", "quannels", "questapi", "Qapi", "qtypes", "kchanges", "qtParameters", "Qdetails", "quparams", " qproperties", " qdetails", "Qparams", "sqoptions", "qresults", "sqams", "reqmac", "sqmac", " qannels", "qoptions", "questdetails", "qquery", "qtquery", "qnames", " qoptions", "qchanges", "quapi", "questannels", "qannels", "Qvals", " qmac", "qams", " qnames", " qapi", "questparams", "qtparams", " qresults", " qtags", " qquery", "questvals", "qunames", "qdetails", "qmac", "qproperties", "qplugins", "qtags", "Qproperties", " qplugins", " qvals", "qapi", "reqoptions", "Qtags", "reqParameters", "reqquery", "sqparams"], "params": ["services", "posts", "base", "pro", "radius", "lp", "apter", "Parameters", "py", "s", "param", " parameters", "properties", "ssl", "afi", "i", "ras", "options", "ps", "config", "per", "plugins", "mm", "license", "api", "p", "http", "phrase", "ams", "server", "qs", "password", "secret", "instance", "json", "details", "ctx", "rules", "cmp", "pi", "settings"], "httpclient": [" httpapi", "httppublic", "webconn", "httpconnection", "httpapi", " httppublic", "webconnection", " httpconnection", "webClient", "htmlconnection", "webapi", " httpcli", "httpconn", "phpclient", "httpClient", " httpconn", "phppublic", "httpcli", "phpapi", " httpClient", "phpClient", "htmlconn", "webclient", "webpublic", "htmlcli", "webcli", "htmlclient"], "uri": ["qi", "address", "base", "client", "URL", "iri", "proxy", "path", "request", "environment", "plugin", "location", "u", "ui", " URI", "range", "ilo", "doi", "uni", " ur", "database", "mi", "adi", "i", "connection", "route", "directory", "direction", "ri", "ur", "service", "api", "resource", "gi", "URI", "document", "http", "href", "cli", "server", "universal", "pi"], "httpget": ["httpsshow", "httplike", "httpstart", "harfind", " httpshow", "httget", " httplike", "ttpsend", "ttpshow", "ttpGet", " httpfind", "httpssend", " httpGet", "urlget", "httpshow", "httpsGet", "httpquery", "harGet", " httpsend", "httpfind", "httstart", " httpstart", "httpsend", "htmllike", "ttpget", "urlGet", "httpGet", " httpquery", "harget", "urlstart", "urlquery", "htmlget", "htmlfind", "htmlGet", "harlike", "httpsget", "httquery", "httGet"], "response": ["result", "received", "status", "output", "feed", "Response", "request", "environment", "generation", "next", "respond", "connection", "application", "object", "body", "message", "service", "resource", "api", "document", "page", "data", "resp", "server", "entry", "successful", "value", "full", "reply", "json", "collection", "onse", "relation"], "entity": ["result", "error", "el", "e", "output", "iso", "metadata", "model", "xml", "environment", "issue", "node", "eni", "obj", "ilo", "image", "company", "event", "element", "component", "info", "connection", "ent", "object", "body", "message", "api", "resource", "p", "person", "em", "content", "document", "get", "translation", "Entity", "page", "data", "article", "file", "server", "email", "coll", "value", "json", "collection", "po"], "instream": ["innstream", "Infile", "inputstruct", "Invideo", "Instring", " invideo", " instring", "Instream", "innstring", "outstream", "instruct", " instruct", "outStream", "invideo", "infile", "inputStream", " inStream", "inStream", "innvideo", "innfile", "outstruct", " infile", "outfile", "inputstream", "instring", "inputfile"], "f": ["fp", "v", "cf", "w", "e", "feed", "fab", "tf", "rf", "df", "fb", "fm", "aff", "c", "fe", "m", "t", "j", "fx", "i", "info", "F", "fc", "fr", "fs", "api", "inf", "p", "h", "fd", "l", "d", "bf", "framework", "full", "json", "fing", "sf", "fac"], "jp": ["fp", "bj", "prot", "uj", "pa", "ja", "tp", "JP", "bp", "lp", "zip", "jc", "jar", "kj", "git", "je", "py", "ppo", "vp", "fm", "hp", "obj", "cp", "jing", "rup", "pkg", "orb", "aja", "bot", "np", "adj", "keeper", "j", "java", "ijk", "gp", "js", "appy", "dj", "jen", "api", "p", "jo", "dt", "jl", "data", "pb", "qt", "pai", "ji", "pp", "json", "txt", "jj", "mp"], "responseObj": ["respondObj", "responseInfo", "ResponseOb", "Responseobj", "respInfo", " responseExt", "serverObject", " responseObject", "responseObject", "respondObject", "serverOb", "respondExt", "responseOb", " responseOb", "respondInfo", "responseExt", "responseobj", "ResponseObj", "ResponseObject", "respExt", " responseInfo", "serverobj", " responseobj", "respObj", "respObject", "serverObj"], "token": ["complete", "wt", "template", "header", "KEN", "after", "oken", "current", "sign", "valid", "operator", "Token", "node", "pattern", "start", "name", "string", "note", "seed", "session", "generation", "action", "language", "next", "prefix", "bot", "character", "or", "format", "event", "type", "element", "info", "notice", "active", "cho", "writer", "object", "tag", "rule", "tick", "aa", "ok", "parser", "tree", "date", "api", "iter", "p", "option", "key", "document", "cookie", "in", "data", "fn", "channel", "init", "qt", "variable", "field", "random", "json", "atom", "open", "po"], "fieldname": ["handname", " fieldalias", "Fieldnan", "FieldName", "handame", "groupn", "columname", "fieldnan", "columnnan", "ieldname", "managern", "handnan", "groupName", "columnName", "groupname", "ieldalias", "groupalias", "Fieldname", "handName", "fieldvalue", "managervalue", "ieldName", " fieldn", "groupvalue", "ieldvalue", " fieldName", "managerName", "fieldn", "columnname", "fieldalias", "managername", "fieldName", " fieldvalue", "Fieldame", "fieldame"]}}
{"id1": "14691829", "id2": "15351863", "code1": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"getMD5Hash": [" getSHA5String", " getMD4hash", " getSHA5Hash", " getSHA5Block", " getMD4Block", " getMDHashHash", " getMD512Block", " getSHA512Hash", " getSHA512hash", " getMD5hash", " getMD4Hash", " getMD4String", " getMD512hash", " getMDHashString", " getMDHashhash", " getSHA5hash", " getSHA512String", " getMD5Block", " getMD512String", " getSHA512Block", " getMD512Hash", " getMDHashBlock", " getMD5String"], "in": ["base", "ins", "reader", "IN", "cache", "gen", "login", "str", "bin", "id", "inc", "val", "input", "out", "In", "string", "s", "conn", "image", "c", "this", "m", "a", "i", "info", "connection", "n", "text", "config", "buffer", "inf", "p", "plus", "data", "source", "file", "as"], "result": ["ger", "hash", "v", "url", "cache", "str", "output", "br", "tmp", "valid", "db", "Result", "rf", "df", "default", "fb", "res", "string", "out", "ret", "memory", "err", "results", "this", "trace", "format", "info", "report", "r", "null", "join", "tr", "diff", "fr", "message", "buffer", "array", "table", "page", "data", "match", "up", "work", "response"], "md5": ["mand52", "mand2", "amd4", "md85", "md52", "mand5", "dig85", "MD4", "dig4", "MD2", "dig7", "MD7", "dig5", " md6", " md85", "digql", "dig6", "amd5", "md2", "md6", " md2", " md7", "MDql", "amd6", "amd85", "mand4", "dig2", " md4", "md7", " md52", "md4", "MD5", "mdql", " mdql", "MD52"], "f": ["fp", "v", "cf", "fun", "fast", "output", "feed", "tf", "df", "rf", "fb", "function", "of", "fm", "c", "fe", "fa", "format", "t", "fx", "info", "F", "fc", "fr", "fs", "inf", "p", "fo", "form", "af", "fd", "h", "l", "fn", "fw", "d", "bf", "sf", "fac"], "b": ["v", "k", "xb", "bit", " B", "ib", "bb", "ob", "e", "bin", "bd", " a", "db", "boot", "ba", "fb", "name", "string", "binary", "s", "c", "a", "i", "r", "sb", "g", "lb", "n", "text", "body", "back", "block", "ab", "p", "bytes", "rb", "l", "B", "d", "bf", "cb", "bs", "be"]}}
{"id1": "17583193", "id2": "3514286", "code1": "    public boolean populateRecord(int[] attrIDs) throws IOException {\n        if (device == null) {\n            throw new RuntimeException(\"This is local device service record\");\n        }\n        if (attrIDs == null) {\n            throw new NullPointerException(\"attrIDs is null\");\n        }\n        if (attrIDs.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        for (int i = 0; i < attrIDs.length; i++) {\n            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {\n                throw new IllegalArgumentException();\n            }\n        }\n        int[] sortIDs = new int[attrIDs.length];\n        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);\n        for (int i = 0; i < sortIDs.length; i++) {\n            for (int j = 0; j < sortIDs.length - i - 1; j++) {\n                if (sortIDs[j] > sortIDs[j + 1]) {\n                    int temp = sortIDs[j];\n                    sortIDs[j] = sortIDs[j + 1];\n                    sortIDs[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < sortIDs.length - 1; i++) {\n            if (sortIDs[i] == sortIDs[i + 1]) {\n                throw new IllegalArgumentException();\n            }\n            DebugLog.debug0x(\"query for \", sortIDs[i]);\n        }\n        DebugLog.debug0x(\"query for \", sortIDs[sortIDs.length - 1]);\n        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"populateRecord": ["populateModel", "extractModel", "extractAll", "extractRecord", "extulateInstance", "populatesAll", "populatesRecord", "populatesInstance", "poputeAll", "extulateModel", "poputeRecord", "extractInstance", "extulateRecord", "populateInstance", "poputeModel", "popractInstance", "popractRecord", "poputeInstance", "extulateAll", "populateAll", "popractModel", "popractAll", "populatesModel"], "attrIDs": ["attIDS", "addrID", "addrENTS", "attributeID", "attrIDS", "sortids", "tagIDES", "attributeENTS", "attENTS", "attributeIDES", "tagIDs", "attributeIDS", "addrIDS", "attrID", "attrIDES", "attributeids", "sortIDES", "attID", "addrIDs", "sortIDS", "attrENTS", "tagID", "attIDES", "sortID", "tagIDS", "attIDs", "attrids", "attids", "attributeIDs"], "i": ["v", "I", "e", "ami", "id", "iu", "xi", "start", "length", "li", "si", "mi", "ie", "a", "g", "ri", "api", "p", "is", "yi", "f", "phi", "ti", "my", "left", "x", "u", "c", "b", "o", "ki", "key", "in", "di", "cli", "l", "bi", "k", "io", "ini", "eni", "inner", "multi", "ij", "ii", "y", "m", "info", "slice", "uri", "it", "ji", "pi", "qi", "z", "ip", "ai", "index", "ind", "ui", "ci", "ori", "n", "gi", "ix", "h", "fi", "oi", "ik", "init", "ni", "d"], "sortIDs": ["altID", "filterIDs", "updateIDS", "sortUID", "allID", "altIDES", "useIDS", "ortUID", "updateID", "orderIDS", "updateFiles", "SortIDs", "attrFiles", " sortFiles", "orderFiles", "attrIDS", "orderID", "sortids", "altIDs", " sortids", "ortIDs", "orderIDs", "useIDs", " sortUID", "syncID", "searchIDS", "allIDS", " sortID", "altIDS", "orderIDES", "syncIDES", "ortids", "sortFiles", "ortIDES", "attrID", " sortIDS", "sortADS", "searchID", "searchIDES", "sortIDES", "ortIDS", "searchIDs", "syncIDS", "attrUID", " sortADS", "allIDES", "SortUID", "useID", "attrADS", "sortIDS", "updateIDES", "ortID", "orderids", "filterIDS", "useIDES", "searchids", "SortIDS", "syncIDs", "sortID", "SortID", "updateIDs", "filterID", " sortIDES", "allIDs", "SortIDES", "filterUID", "orderADS"], "j": ["qi", "jp", "J", "bj", "z", "uj", "v", "k", "ja", "job", "w", "e", "br", "left", "jc", "xi", "x", "je", "q", "u", "li", "ui", "obj", "section", "next", "ij", "jet", "adj", "oj", "ii", "y", "aj", "ie", "b", "js", "n", "o", "dj", "fr", "p", "key", "ix", "h", "jo", "l", "jl", "di", "last", "d", "ji", "part", "jj", "f", "pr"], "temp": ["emp", "test", " temporary", " test", "ed", "wrap", "ash", "needed", " tmp", "tmp", " Temp", "partial", "tc", "alt", "flat", "holder", "max", " result", "tem", " orig", "porary", "used", "orig", "ex", "empty", "tr", " dummy", "stable", " fake", "pack", "iter", "key", " modified", "get", "non", " original", "Temp", "modified", "fake", " unused"]}}
{"id1": "397240", "id2": "10385815", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewwrite", "readandRewrite", "readandrewrites", "readAndSwrites", "readAndrewrite", "readAndRebrite", "readandRewwrite", "readAndrewwrite", "readAndRebrites", "readandrewwrite", "readandrewrap", "readAndSwwrite", "readandRewrap", "readandRewrites", "readAndrewrap", "readAndRewrites", "readAndrewrites", "readAndRebrap", "readAndRewrap", "readAndSwrap", "readandrewrite", "readAndSwrite", "readAndRebwrite"], "inFile": ["oldFilename", "InFiles", "Infile", "oldFiles", "loginFilename", "inputFile", "InFile", "InSourceFile", "loginFile", "infile", "oldfile", "inputFiles", "oldFile", " infile", "inputFilename", " inFilename", "loginfile", "outfile", "loginFiles", "inFilename", " inSourceFile", "outSourceFile", "inFiles", "outFiles", "outFilename", "inSourceFile", " inFiles", "inputfile"], "outFile": ["newDir", "thisfile", "outDir", "processPlace", "OutStream", "thisFILE", "OutDir", "outFILE", "newFile", "offFile", "offFILE", "thisFilename", "outputFILE", "outStream", "outputFilename", "offFilename", " outfile", "exfile", "offPlace", "processFILE", "outputPlace", "thisFile", "processFilename", " outStream", " outDir", "outputfile", "newfile", "newStream", "exFilename", "outfile", "exFILE", "outPlace", "OutFile", "processFile", "exFile", "Outfile", "outFilename", "outputFile"], "iis": ["Iis", "iiris", " iiss", "iiIs", "ciIs", "ciIS", "ciis", "Iiss", "Iais", "iniiss", "iniIs", "iiss", "iniris", "ciais", "iiiss", " iIS", "iniIS", " iais", "iIS", " iIs", "iiIS", "iIs", " iris", "iris", "ciiss", "iniis", "iiis", "IIS", "ciris", "iais"], "dcmParser": [" dcrPlugin", "dmParser", " dcmHelper", " dcmarser", "fcmHandler", "dpmPlugin", "dcrPar", "fpmParser", "dCMReader", "dcmLoader", " dcmPlugin", "dpmLanguage", "dkmParser", "fpmparser", "dcmHelper", " dpmLanguage", "dmcParser", "dbmPolicy", "dcrReader", "dmcPar", " dpmParser", "dmissionReader", "dCMHandler", " dcmparser", "dmissionPlugin", "dmPlugin", "dmmparser", "dCMParser", "dpmHandler", "dbmHelper", "dpmReader", "dpmInstallation", " dcrLoader", "dbmPlugin", " dpmarser", "dmmLoader", "dhemJar", "dmoduleparser", "DcmReader", " dcrParser", " dpmJar", "dcmPolicy", "DcmInstallation", "dhemInstallation", "dmcJar", " dpmPolicy", "dpmparser", " dpmHelper", "dmissionLanguage", "dcmPar", " dpmparser", "dcmReader", "dpmPar", "fpmHandler", "dmodulePlugin", "dkmPlugin", "dbmParser", "dcmparser", " dcmPar", "dkmPolicy", "dmoduleParser", "dcrPlugin", "fcmParser", "dCMPlugin", "dmoduleJar", "dmcarser", "dcmPlugin", "dmoduleReader", " dcmPolicy", "DcmJar", "dcrParser", " dpmPlugin", "dCMLoader", " dcrReader", "DcmParser", " dcmLanguage", "dpmJar", "dmissionParser", "dhemParser", "dcmarser", " dcmJar", "dcmInstallation", "dpmParser", "dCMparser", "dmmPlugin", "dcrLoader", "dcrarser", "fpmReader", " dpmPar", "dcrJar", "dpmLoader", " dpmLoader", "dmLoader", "dmmParser", " dpmReader", "dcmJar", "fcmReader", "dhemReader", "dkmHelper", "fcmparser", "dpmarser", "dpmHelper", "dpmPolicy", " dcmLoader", "dcmHandler", "dcmLanguage", "dmReader", " dcmReader"], "ds": ["sys", "services", "da", "Os", "ins", "Ds", "ays", "eps", "xs", "ts", "ils", "db", "vs", "tx", "ws", "nas", "ads", "df", "session", "ns", "ks", "asi", "ls", "s", "conn", "iss", "os", "dd", "Db", "gd", "des", "ys", "dat", "js", "cs", "vals", "drivers", "cdn", "ps", "sync", "pd", "dc", "parts", "uds", "ants", "dt", "dr", "di", "dds", "data", "is", "ld", "qs", "amps", "DS", "d", "src", "icks", "details", "utils", "points", "ss", "bs", "ros", "tes", "rs", "gs", "ras"], "pdReader": ["pcRead", "pcLoader", "dsreader", "hdWriter", "xdReader", "xdRead", "hdRunner", "hdStream", "pcWriter", "hdRead", "ddStream", "dsLoader", "pbRunner", "pcReader", "dsReader", "dsRead", "hdreader", "pbLoader", "hdLoader", "ddRunner", "pdLoader", "pbStream", "pdStream", "pdreader", "pdRunner", "dsWriter", "pbReader", "hdReader", "xdreader", "pdRead", "xdWriter", "ddReader", "ddLoader"], "out": ["external", "outs", "cache", "gen", "inc", "model", "session", "conn", "name", "doc", "ssl", "writer", "at", "null", "with", "data", "file", "full", "group", "part", "as", "client", "child", "term", "db", "dot", "s", "ext", "word", "to", "lock", "write", "down", "Out", "user", "object", "o", "her", "key", "store", "page", "in", "cli", "password", "device", "later", "net", "result", "base", "OUT", "w", "login", "io", "auto", "obj", "inner", "err", "lib", "code", "layer", "again", "parent", "over", "oder", "list", "outer", "copy", "director", "temp", "exec", "flow", "sys", "url", "img", "builder", "output", "exp", "default", "image", "order", "connection", "ex", " in", "co", "sync", "diff", "array", "point", "line", "up", "pass", "dev", "manager"], "dcmEncParam": ["dcmElType", "dcmEnParam", "dcmEstType", "dcmEstPar", "dcmDecPart", "dcmDecParameter", "dcmArchParameter", "dcmEnArg", "dcmEncArg", "dcmElPar", "dcmEncParameter", "dcmDecType", "dcmSecType", "dcmEncPart", "dcmDecParam", "dcmEnType", "dcmSecPart", "dcmEncType", "dcmArchParam", "dcmSecPar", "dcmEnPart", "dcmSecParam", "dcmDecArg", "dcmEnPar", "dcmEstParam", "dcmElParameter", "dcmElParam", "dcmEstParameter", "dcmDecPar", "dcmEnParameter", "dcmArchArg", "dcmEncPar"], "pdWriter": ["PDWrite", "dpWrite", "hdWriter", "htReader", "ddWrite", "dpReader", "pdWriting", "dsOutput", "dsReader", "dpWriter", "hdWrite", "PDWriter", "dpWriting", "PDReader", "htWriting", "dsWriter", "hdReader", "htWrite", "htWriter", "PDWriting", "ddWriter", "ddOutput", "hdOutput", "pdOutput", "dsWrite", "ddReader", "pdWrite"]}}
{"id1": "7425022", "id2": "14785308", "code1": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"transferWSDL": ["transferSWSDDL", "transferWSDLS", "transferSWSDl", "transferWDDL", "transferWSDDL", "transferWsdL", "transferWsdLS", "transferWDDLS", "transferWDDl", "transferWDDDL", "transferWNDLS", "transferSWsdLS", "transferSWsdL", "transferWNDL", "transferWsdDL", "transferWNDDL", "transferWSDl", "transferWsdl", "transferWNDl", "transferSWsdl", "transferSWSDL", "transferSWsdDL", "transferSWSDLS"], "wsdlURL": ["wsslUrl", "wllURL", "wsdalPath", "wsdlFILE", "wssdPath", "wsdlURI", "wslUrl", "wdlPath", "wssdUrl", "wslPath", "wdlURL", "wsslURL", "wssdURL", "wdlUrl", "wsdalUrl", "wllFILE", "wllPath", "wsllPath", "wsdnFILE", "wslURL", "wsllUrl", "wsdalURL", "wllUrl", "wsdlUrl", "wsllURI", "wsslPath", "wsdnPath", "wsllFILE", "wssdFILE", "wdlFILE", "wsllURL", "wsdnURL", "wsdlPath", "wdlURI", "wsdnUrl", "wsslURI", "wsdalURI", "wslURI"], "userPassword": ["Userpassword", "userpassword", "useAuth", " userPass", "userAuth", "useData", "UserWord", "UserName", "usepassword", " userData", "UserAuth", "UserData", "userName", "USERpassword", "USERPassword", "usePassword", "userPass", " userAuth", " userpassword", "userData", " userName", " userWord", "UserPass", "usePass", "userWord", "UserPassword", "USERName", "USERWord"], "filePath": ["fileStr", "transferPath", " filepath", "transferLocation", "transferStr", "Filepath", "transferpath", "FileStr", " fileLocation", "FileLocation", "FilePath", "fileLocation", "filepath", " fileStr"], "endpoint": ["endPoint", "adPoint", "Endwall", "endwall", "adpoints", "adwall", " endpoints", " endPoint", "EndPoint", "Endpoint", "Endpoints", " endwall", "adpoint", "endpoints"], "conn": ["exec", "cm", "url", "cf", "mc", "client", "ca", "ann", "w", "Connect", "ob", "reg", "cb", "ws", "comm", "connect", "ns", "oss", "sql", "conv", "cp", "inner", "c", "ci", "adj", "auth", "org", "ct", "en", "ssl", "connection", "ec", "g", "Connection", "n", "enc", "loc", "co", "nt", "Con", "sync", "pub", "socket", "dc", "open", "p", "close", "h", "pg", "dn", "rc", "cli", "col", "fn", "ch", "cn", "dh", "init", "act", "coll", "pc", "con", "nc", "ac", "Conn", "oa", "part", "conf", "ctx", "impl"], "is": ["iv", "ib", "ois", "Is", "es", "hi", "si", "ios", "os", "ipp", "ie", "i", "irc", "ps", "ri", "fs", "p", "sc", "as", "rs", "rest", "has", "bis", "x", "res", "ir", "s", "ris", "iss", "or", "rx", "mes", "in", "src", "mis", "us", "im", "ais", "ins", "iet", "sr", "was", "ar", "io", "sec", "oc", "stream", "isl", "info", "js", "lis", "isc", "isi", "it", "isp", " IS", "rss", "ss", "ip", "ai", "iso", "IS", "ws", "ism", "index", "out", "est", "r", "ops", "any", "h", "its", "act", "serv", "il"], "isr": ["issp", "ISl", " isw", "isrs", "ssr", "issl", "issrs", "isrb", "ISw", "iscrb", "isl", "isw", "ssrs", "iscp", "issw", "ssp", "isp", "ssrb", " isp", "issrb", "ISp", "ISr", " isl", "iscrs", "issr", "iscr"], "sw": ["su", "wt", "wa", "im", "sv", "tw", "wrap", "aw", "w", "war", "was", "sem", "wl", "xml", "ws", "x", "sl", "hop", "cr", "wx", "stream", "hw", "hi", "rew", "ww", "rw", "sm", "wr", "sb", "r", "rx", "SW", "so", "eng", "ow", "ew", "wb", "nw", "wh", "pg", "wp", "iw", "sh", "sc", "wra", "rss", "sf", "wo", "response", "Sw"], "buf": ["vec", "uf", "bc", "Buffer", "base", "uc", "prop", "str", "bb", "bin", "br", "cv", "bd", "feed", "raw", "brace", "cur", "func", "fb", "cr", "seq", "err", "len", "bag", "box", "batch", "b", "rx", "text", "ha", "ff", "block", "pad", "wb", "buffer", "la", "bytes", "rb", "cas", "rc", "data", "pool", "shift", "bh", "char", "cb", "buff"], "read": ["k", "send", "reader", "w", "parse", "use", "feed", "load", "child", "raw", "old", "check", "skip", "default", "boot", "log", "reading", "index", "input", "connect", "start", "length", "end", "play", "max", "stream", "need", "write", "en", "i", "count", "ride", "wait", "g", "r", "text", "n", "find", "Read", "sync", "block", "READ", "ok", "buffer", " write", "iter", "add", "get", "copy", "in", "work", "sleep", "se", "data", "num", "reads", "pass", "open", "size", "select", "f", "run"], "outputDir": ["OutputFile", "OutputPath", "outputFolder", "outDir", "inputDir", "tmpDir", "outFolder", "tmpPath", "inputFile", "OutputFolder", " outputDirectory", "tmpFolder", "OutputDirectory", "outFile", "OutputDir", "outDirectory", "tmpDirectory", " outputFolder", " outputPath", "inputDirectory", " outputFile", "outputDirectory", "inputFolder", "outputFile", "outputPath"], "file": ["fp", "url", "FILE", "base", "local", "output", "feed", "zip", "db", "path", "folder", "log", "function", "filename", "name", "out", "stream", "lock", "ile", "files", "build", "File", "writer", "info", "b", "object", "directory", "parent", "handler", "future", "buffer", "message", "resource", "content", "store", "line", "data", "work", "letter", "dir", "up", "full", "unit", "f", "le"], "fos": ["FOS", " fOs", "fOS", "F\n", " faos", " fOS", "Fos", "t\n", "infOS", "f\n", "Faos", "infaos", " f\n", "fOs", "FOs", "infOs", "faos", "infos"]}}
{"id1": "18793482", "id2": "10212189", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 0, "substitutes": {"modifyApplicationMessage": ["modifyAppmessage", "modifyAppMessage", "modifiedApplicationMessage", "modifyAppMsg", "modifyApplicationContent", "modifiedApplicationContent", "modifiedapplicationContent", "modifiedapplicationmessage", "modifyExternalMsg", "modifyapplicationMsg", "modifyapplicationmessage", "modifyApplicationmessage", "modifyapplicationMessage", "modifyapplicationContent", "modifiedapplicationMsg", "modifiedapplicationMessage", "modifiedApplicationmessage", "modifiedApplicationMsg", "modifyAppContent", "modifyExternalContent", "modifyExternalmessage", "modifyExternalMessage", "modifyApplicationMsg"], "locale": ["localator", "locator", "placeALE", "locationALE", "placeale", "localue", "localale", "localame", "Locator", "locationales", "Locales", " locator", "locales", "Locame", "locue", " locame", "LocALE", " locales", "locationale", "Locale", "placeales", "locALE", "placeame", "localales", "localALE", "locationue", "locame", "Locue"], "messageName": ["MessageKey", "MessageValue", " messagename", "messageKey", " messageKey", "msgName", "MessageName", "messageType", "phraseName", "reasonname", "msgValue", "phraseKey", "msgType", "Messagename", "MessageType", " messageType", "msgKey", "phraseType", "reasonName", "reasonValue", "messagename", "phraseValue", "reasonType"], "messageValue": ["responseType", "MessageValue", "msgName", "MessageName", "MessageVal", "messageType", "msgValue", "msgType", "responseValue", " messageType", "MessageType", "responseVal", " messageVal", "responseName", "messageVal", "msgVal"], "properties": ["params", "pro", "prop", "metadata", "tmp", "xml", "py", "stats", "obj", "resources", "options", "ops", "Pro", "ps", "config", "Property", " props", "property", "api", "perties", "ips", " Properties", "data", "pb", "json", "txt", "conf", "settings"], "i18nPath": ["i18nPart", "i18bStr", "i18nsUrl", "i18nCorp", "i18bPath", "i18fCorp", "i18naPart", "i18fPath", "i18ninFile", "i16nPart", "i18naStr", "i18fpath", "i18bPart", "i11fPath", "i18nLocation", "i18nUrl", "i18nsFile", "i16npath", "i18onPath", "i11nCorp", "i16nStr", "i18onLocation", "i18nsPart", "i18nepath", "i11fUrl", "i18onFile", "i18nspath", "i18naPath", "i32nUrl", "i18ninUrl", "i18nsLocation", "i11nUrl", "i18bpath", "i32ninPath", "i16nsStr", "i18nsPath", "i32ninFile", "i18neUrl", "i18ninLocation", "i32nPath", "i18ninPath", "i32nLocation", "i32ninUrl", "i18onUrl", "i18npath", "i11fCorp", "i18neCorp", "i18nePath", "i32nFile", "i16nsPath", "i16nspath", "i18nStr", "i18nsCorp", "i11fpath", "i18nFile", "i32ninLocation", "i18nsStr", "i16nPath", "i16nsPart", "i18napath", "i11npath", "i18fUrl", "i11nPath"], "englishFile": ["languagefile", "languageFiles", "EnglishPath", "exampleFile", " englishDir", "examplePath", "examplefile", "propertiesPath", "propertiesFolder", "ianaPath", "ianaJar", "languageJar", "EnglishFile", "englishJar", "propertiesfile", " englishJar", "ianaDir", "languageFile", "ianaFile", "exampleFolder", "englishDir", " englishFiles", "EnglishFiles", "englishFolder", "languagePath", "propertiesFile", "EnglishFolder", "languageDir", " englishPath", "Englishfile", "englishFiles", "englishPath", " englishfile", "englishfile"], "propertiesFilePath": ["propertiesSourceFileName", "pertiesfilepath", "propertiesFileName", "propertiesFilesUrl", "pertiesfilePath", "propertiesSourceFilepath", "propertiesFileURL", "pertiesDirUrl", "pertiesfileName", "pertiesFileUrl", "propertiesfilepath", "propertiesFilesURL", "propertiesfileUrl", "pertiesFileName", "propertiesFileUrl", "propertiesDirpath", "propertiesFilesName", "pertiesFilepath", "pertiesFilePath", "propertiesfileURL", "propertiesFilespath", "propertiesDirName", "propertiesfileName", "propertiesSourceFilePath", "propertiesFilesPath", "pertiesFileURL", "pertiesDirName", "propertiesDirUrl", "propertiesDirPath", "pertiesDirpath", "pertiesDirPath", "propertiesfilePath", "propertiesFilepath", "propertiesSourceFileURL", "pertiesfileURL"], "file": ["FILE", "force", "model", "path", "one", "log", "filename", "name", "format", "File", "show", "directory", "message", "p", "data", "letter", "full", "part", "f", "fp", "use", "child", "folder", "function", "string", "word", "lock", "fe", "or", "pe", "class", "b", "object", "buffer", "property", "http", "single", "l", "page", "base", "reader", "php", "zip", "language", "binary", "stream", "files", "entity", "parent", "socket", "media", "resource", "it", "content", "source", "field", "unit", "book", "module", "url", "play", "ile", "connection", "application", "text", "handler", "future", "h", "up", "die", "le"], "in": ["gin", "ins", "reader", "din", "IN", "login", "bin", "io", "inc", "isin", "ini", "input", "er", "ic", "In", "s", "inner", "image", "err", "or", "i", "r", "b", "n", "again", "sin", "nin", "ri", "win", "inn", "p", "pin", "plus", "it", "into", "l", "lin", "cin", "inside", "kin", "init", "d", "rin", "con", "f"], "out": ["net", "exec", "v", "error", "OUT", "outs", "builder", "w", "output", "bin", "ou", "io", "inc", "exp", "one", "string", "s", "end", "inner", "word", "ext", "to", "image", "err", "write", "Out", "plain", "lib", "i", "r", "b", "ex", "n", "again", "o", "co", "sync", "socket", "outer", "p", "by", "cli", "work", "up", "and", "full", "home", "part", "f"], "c": ["v", "bc", "k", "cl", "cf", "lc", "cy", "uc", "dec", "cont", "w", "C", "cur", "x", "pointer", "cr", "ci", "cc", "character", "code", "ct", "ec", "a", "i", "t", "r", "arc", "b", "cu", "n", "ice", "esc", "o", "enc", "dc", "p", "h", "rc", "col", "l", "char", "ch", "sc", "d", "pc", "ac", "con", "abc", "f", "size", "xc", "ce"], "is": ["us", "ais", "ins", "ib", "re", "str", "does", "iso", "are", "has", "id", "isa", "IS", "bis", "Is", "es", "res", "ir", "ui", "s", "stream", "ris", "si", "ios", "iss", "os", "i", "info", "ps", "ri", "isu", "iter", "api", "it", "get", "its", "as", "serv"], "breader": [" cakeER", "breaditer", "brewiter", " cakeler", " Breader", "breaders", " breaders", " cakeer", " cakeers", "feediter", "webiter", "breadamer", "feedamer", " BreadER", "breadler", " breadler", "brewer", "webr", " Breaders", "weber", "feeder", "breadER", " Breadler", "brewamer", "breadr", "feedr", " breadER", "webamer", "brewr"], "line": ["url", "lc", "header", "ip", "error", "base", "status", "phrase", "str", "parse", "el", "lo", "feed", "model", "one", "log", "le", "row", "nl", "lined", "sl", "plugin", "string", "name", "Line", "response", "lines", "word", "section", "end", "li", "no", "link", "write", "next", "character", "code", "look", "LINE", "day", "band", "definition", "text", "body", "rule", "block", "sync", "strip", "message", "key", "lf", "page", "lin", "data", "l", "letter", "style", "inline", "entry", "frame", "pass", "value", "split", "liner", "part", "comment", "side", "item", "cell"], "strBuilder": ["stringbuilder", " strBuilding", "StrBuffer", "stringBuilding", "stringBuild", "stringBuilder", "brbuilder", "brBuild", "StrBuild", "brBlock", "strBuild", "strBuffer", "Strbuilder", " strBuild", "StrBlock", "StrBuilding", " strBlock", "strbuilder", "brBuffer", "brBuilder", "StrBuilder", " strbuilder", "strBlock", "stringBuffer", " strBuffer", "brBuilding", "strBuilding"], "pieces": ["services", "objects", "tops", "groups", "marks", "steps", "seconds", "letters", "places", "flows", "forms", "lists", "values", "sections", "cells", "lines", "styles", "files", "rings", "words", "strings", "circle", "items", "vals", "ops", "tips", "bits", "pots", "pins", "nets", "boxes", "apps", "parts", "blocks", "cards", "bytes", "ips", "pages", "planes", "phones", "piece", "keys", "packs", "cuts", "bones", "split", "names", "features"], "found": ["first", "defined", "result", "required", "updated", "left", "filled", "valid", "not", "old", "got", "created", "based", "val", "fl", "true", "identified", "Found", "made", "given", "err", "missing", "failed", "normal", "all", "lost", "confirmed", "used", "count", "null", "changed", "find", "built", "still", "matched", "fall", " Found", "broken", "loaded", "successfully", "search", "l", "letter", "fixed", "printed", "successful", "full", "f", "sent", "expected", "finding", "temp"]}}
{"id1": "22057083", "id2": "9327525", "code1": "    private void Connect() throws NpsException {\n        try {\n            client = new FTPClient();\n            client.connect(host.hostname, host.remoteport);\n            int reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                client.disconnect();\n                client = null;\n                com.microfly.util.DefaultLog.error_noexception(\"FTP Server:\" + host.hostname + \"refused connection.\");\n                return;\n            }\n            client.login(host.uname, host.upasswd);\n            client.enterLocalPassiveMode();\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            client.changeWorkingDirectory(host.remotedir);\n        } catch (Exception e) {\n            com.microfly.util.DefaultLog.error(e);\n        }\n    }\n", "code2": "    @Test\n    public void test02_ok() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(chartURL);\n            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);\n            nameValuePairs.add(new BasicNameValuePair(\"ws\", \"getDomainEvolution\"));\n            nameValuePairs.add(new BasicNameValuePair(\"chartTitle\", \"test\"));\n            nameValuePairs.add(new BasicNameValuePair(\"type\", \"chart\"));\n            nameValuePairs.add(new BasicNameValuePair(\"firstDate\", \"20111124\"));\n            nameValuePairs.add(new BasicNameValuePair(\"lastDate\", \"20111125\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParams\", \"type,counting,protocol,unit,proxy,domain,timeScale,period\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParamsValues\", \"chart,volume,all,hits,all,google.com,day,360\"));\n            nameValuePairs.add(new BasicNameValuePair(\"serieTitle\", \"serie\"));\n            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            assertNotNull(entity);\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));\n            System.out.println(reader.readLine());\n            instream.close();\n            assertEquals(\"error :\" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"Connect": ["Load", "Dial", "Run", "New", "Host", "Login", "Setup", "Socket", "Close", "connect", "Config", "Build", "Connector", "Create", "Sync", "Construct", "Init", "Connection", "Client", " Connection", "Open", " Close", "Fail", "Subscribe", "Remote", "Process", "Conn", "connected"], "client": ["cm", "cl", "console", "cache", "clean", "cod", "local", "util", "project", "call", "force", "port", "proxy", "ace", "child", "command", "request", "default", "plugin", "remote", "host", "connect", "session", "conn", "secure", "core", "cp", "end", "name", "friend", "c", "cc", "ci", "lib", "code", "ssl", "connection", "user", "parent", "cloud", "handler", "Client", "per", "socket", "config", "co", "service", "resource", "api", "close", "get", "http", "grid", "cli", "pool", "server", "cn", "channel", "pc", "con", "open", "manager", "ce", "cell"], "reply": ["address", "result", "ping", "error", "send", " response", "status", "call", "answer", "comment", "replace", "request", "state", "ret", "err", "next", "link", "bot", "prefix", "code", "respond", "read", "reason", "repl", "connection", "info", "Reply", "echo", "query", "sync", "ply", "message", "related", "buffer", "post", "rc", "dy", "continue", "resp", " replies", "part", "response"]}}
{"id1": "5977352", "id2": "8932510", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferfile", "copyDir", " copyDir", "CopyFile", "CopyFiles", "transferFiles", "transferDir", " copyfile", "CopyDir", "Copyfile", "transferFile", "copyfile", " copyFiles"], "src": ["ource", "fp", "url", "ins", "img", "gb", "view", "tmp", "proxy", "proc", "path", "sl", "input", "filename", "conn", "obj", "s", "stream", "this", "files", "sel", "sb", "b", "buf", "config", "loc", "slice", "loader", "inst", "uri", "resource", "rb", "rc", "source", "data", "file", "sc", "dist"], "dest": ["rest", "de", "url", "cont", "st", "thin", "master", "img", "cache", "project", "delete", "dep", "output", "tmp", "zip", "path", "folder", "target", "name", "obj", "cp", "this", "Dest", "class", "route", "desc", "orig", "parent", "null", "cdn", "config", "wb", "table", "done", "dc", "store", "source", "destroy", "file", "dir", "dist", "d", " destination", "die", "later", "home", "opt", "trans", "txt", " Dest", "part", "temp"], "bufSize": ["queueLen", "bufLen", "queuesize", "buf2", "queueSize", " bufLen", " buf2", "bufsize", "buffer2", "bufferSize", "ufSize", "ufsize", " bufsize", "uf2", "buffersize", "bufferLen", "ufLen"], "force": ["Force", "base", "forces", "place", "delete", "apply", "use", "id", "load", "replace", "deep", "remote", "auto", "urse", "hard", "write", "no", "ist", "require", "like", "forced", "dirty", "count", "ride", "route", "front", "parent", "pull", "sync", "p", "flush", "store", "rc", "source", "push", "file", "forcing", "only", "f"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bin", "transfer", "feed", "load", "raw", "request", "fb", "border", "length", "seed", "binary", "offset", "memory", "queue", "write", "reference", "batch", "b", "null", "buf", "slice", "padding", "iter", "bytes", "flush", "data", "source", "append", "limit", "value", "split", "zero", "buff"], "read": ["exec", "k", "ip", "ed", "reader", "level", "send", "parse", "lex", "view", "allow", "use", "id", "feed", "io", "load", "current", "raw", "skip", "check", "index", "input", "connect", "seek", "length", "ind", "play", "start", "end", "write", "next", "len", "build", "i", "count", "wait", "show", "b", "fill", "n", "text", "ride", "find", "Read", "sync", "block", "READ", " write", "ad", "iter", "close", "add", "get", "copy", "sleep", "work", "data", "se", "d", "create", "reads", "pass", "open", "reading", "size", "select", "run"], "in": ["serv", "url", "gin", "base", "ins", "thin", "din", "reader", "IN", "login", "bin", "id", "isin", "inc", "ini", "input", "In", "conn", "inner", "image", "err", "c", "lib", "m", "a", "i", "r", "connection", "b", "ex", "again", "n", "sin", "pull", "socket", "nin", "win", "inn", "min", "pin", "cin", "source", "up", "init", "kin", "inside", "rin", "pass", "con", "ac", "part", "as", "f"], "out": ["exec", "net", "url", "OUT", "client", "outs", "cache", "w", "call", "output", "app", "bin", "exp", "io", "inc", "ou", "id", "one", "conn", "obj", "ext", "inner", "max", "name", "image", "write", "no", "off", "err", "this", "Out", "plain", "lib", "at", "writer", "i", "connection", "user", "b", "ex", "n", "again", "o", "with", "co", "sync", "socket", "nin", "outer", "key", "by", "line", "source", "up", "init", "ac", "home", "part", "can"]}}
{"id1": "14047629", "id2": "9398454", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"source": ["ource", "exec", "fp", "result", "processor", "reader", "status", "project", "parse", "transfer", "load", "proxy", "proc", "path", "request", "remote", "input", "session", "target", "out", "cp", "stream", "inner", "image", "Source", "comp", "info", "connection", "class", "text", "object", "parent", "config", "ources", "loader", "buffer", "service", "resource", "content", "document", "in", "file", "server", "src", "SOURCE"], "process": ["exec", "result", "processor", "master", "share", "cess", "console", "system", "job", "project", "call", "status", "output", "use", "port", "app", "command", "progress", "proc", "worker", "path", "index", "target", "python", "machine", "session", "node", "thread", "image", "method", "pid", "class", "object", "parent", "program", "task", "pipe", "press", "the", "post", "parser", "display", "resource", "p", "copy", "document", "file", "processing", "work", "loop", "Process", "script", "open", "run"], "processStdOut": ["processStdinOut", "processSTdinOUT", "processSTdOut", "processStdOutput", "processSTdinOut", "processStdOUT", "processStdinOUT", "processStDOUT", "processStDObj", "processStdinObj", "processSttObj", "processStDOut", "processStdObj", "processStDOutput", "processSttOutput", "processSTdinObj", "processSTdOUT", "processSttOut", "processSttOUT", "processSTdObj", "processSTdinOutput", "processSTdOutput", "processStdinOutput"], "processStdIn": ["processStdinOut", "processStrdIn", "processSttin", "processStsin", "processSttInput", "processStrdIns", "processStsIn", "processStbin", "processStbIns", "processSttIN", "processStdIN", "processStrdInput", "processStrtIn", "processStbIn", "processStdInput", "processStdin", "processSttIn", "processStsInput", "processStrdin", "processStsIns", "processStbIN", "processStrtIns", "processSttOut", "processStdinIn", "processStbOut", "processStrtInput", "processStbInput", "processStdinIN", "processStdIns", "processSttIns", "processStrtin", "processStdinin"]}}
{"id1": "22268798", "id2": "9398454", "code1": "    @Override\n    public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException {\n        String uniqueName = path.getBaseName();\n        URL url = buildURL(uniqueName);\n        URLContent content = new URLContent(url, this.getName(), uniqueName);\n        content.setUniqueName(uniqueName);\n        content.setReadable(true);\n        content.setWritable(writable);\n        content.setExists(true);\n        try {\n            URLConnection connection = url.openConnection();\n            String mimeType = connection.getContentType();\n            content.setMimeType(mimeType);\n            content.setWritable(true);\n        } catch (IOException ex) {\n            throw new ContentException(\"unable to obtain mime type of \" + url, ex);\n        }\n        return content;\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"getContent": ["getContents", "createContent", "buildContent", "getcontent", "loadResource", "createContents", "buildcontent", "getResource", "createResource", "createcontent", "buildResource", "loadcontent", "loadContent", "loadContents", "buildContents"], "principal": ["Princincipal", "prercipal", "Princunctipal", "prerceter", "prercificate", "Princunctential", "prunctential", "princificate", "pricipential", "Princincificate", "prercential", "Princincential", "prunctificate", "pricipeter", "prunctipal", "pricipificate", "princential", "pruncteter", "Princuncteter", "Princunctificate", "princeter", "Princinceter", "pricipipal"], "path": ["PATH", "client", "prop", "project", "request", "node", "pattern", "location", "context", "name", "pointer", "string", "Path", "next", "link", "prefix", "format", "info", "method", "class", "root", "user", "object", "text", "parent", "loader", "uri", "ath", "resource", "api", "property", "data", "source", "file", "instance", "part"], "version": ["v", "ver", "level", "project", "str", "current", "model", "val", "target", "node", "string", "out", "format", "vision", "release", "Version", "object", "parent", " versions", "depth", "date", "resource", "versions", "server", "VERSION", "value", "json"], "properties": ["address", "objects", "params", "pro", "types", "classes", "prop", "metadata", "state", "values", "resources", "results", "items", "options", "Pro", "Property", "ps", "plugins", "property", "perties", "ips", "fields", "data", "details", "json", "features", "settings"], "uniqueName": ["UniqueName", "blockName", "uniquename", "stringKey", "UniqueType", "blockPath", "filename", "uniquePath", "stringName", "fileTime", "basePath", "UniquePath", "stringPath", "Uniquename", "stringname", "baseName", "blockKey", " uniquePath", "basename", "uniqueType", "baseKey", " uniquename", " uniqueTime", "uniqueTime", "UniqueKey", " uniqueType", "UniqueTime", "blockType", " uniqueKey", "uniqueKey", "filePath", "fileName"], "url": ["address", "position", "base", "error", "client", "bb", "ob", "el", "found", "feed", "URL", "proxy", "log", "sl", "Url", "host", "location", "name", "string", "conn", "ls", "image", "link", "this", "build", "layer", "ssl", "html", "user", "object", "parent", "ll", "www", "loc", "uri", "resource", "http", "l", "page", "source", "file", "server", "channel", "download", "coll", "open", "web", "f"], "content": ["complete", "address", "result", "cm", "cont", "cf", "client", "ca", "lc", "cache", "change", "reader", "output", "current", "load", "child", "proxy", "container", "model", "cover", "default", "remote", "creator", "host", "node", "location", "conn", "core", "ext", "section", "image", "c", "this", "code", "layer", "user", "object", "parent", "const", "handler", "config", "update", "message", "media", "resource", "Content", "wrapper", "common", "copy", "condition", "key", "page", "document", "data", "source", "file", "server", "create", "instance", "coll", "ac", "full", "comment", "ce", "response", "temp"], "connection": ["position", "client", "reader", "connected", "io", "proxy", "container", "creator", "session", "connect", "conn", "context", "string", "section", "image", "c", "database", "character", "communication", "Connection", "application", "object", "directory", "number", "handler", "config", "loc", "uri", "resource", "http", "data", "channel", "pool", "server", "coll", "con", "open", "control", "response", "relation"], "mimeType": ["mimestype", "metytype", "metyInfo", "mmimeType", "MimeType", "mimesPath", "mmiveInfo", "mimesType", "mimeInfo", "mmiveType", "mimePath", "mIMEType", "mimesName", "MIMEtype", "mimeName", "mIMEPath", "MIMEPath", "miveInfo", "mimetype", "MIMEType", "mIMEInfo", "mIMEName", "mangName", "MIMEName", "mmimetype", "MimeName", "mivetype", "MimePath", "mmimeInfo", "mmivetype", "Mimetype", "mIMEtype", "mangtype", "metyType", "mangType", "miveType", "mangPath"]}}
{"id1": "12197169", "id2": "16969205", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    private List<JarFile> webArchives(ServletContext servletContext) throws IOException {\n        List<JarFile> list = new ArrayList<JarFile>();\n        Set<Object> paths = servletContext.getResourcePaths(WEB_LIB_PREFIX);\n        for (Object pathObject : paths) {\n            String path = (String) pathObject;\n            if (!path.endsWith(\".jar\")) {\n                continue;\n            }\n            URL url = servletContext.getResource(path);\n            String jarURLString = \"jar:\" + url.toString() + \"!/\";\n            url = new URL(jarURLString);\n            JarFile jarFile = ((JarURLConnection) url.openConnection()).getJarFile();\n            JarEntry signal = jarFile.getJarEntry(FACES_CONFIG_IMPLICIT);\n            if (signal == null) {\n                if (log().isTraceEnabled()) {\n                    log().trace(\"Skip JAR file \" + path + \" because it has no META-INF/faces-config.xml resource\");\n                }\n                continue;\n            }\n            list.add(jarFile);\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"read": ["reader", "parse", "load", "ready", "replace", "check", "readable", "request", "start", "end", "stream", "write", "print", "report", "Read", "println", "get", "continue", "process", "work", "init", "download", "create", "loop", "open", "reading", "run"], "in": ["url", "ins", "error", "reader", "din", "IN", "token", "login", "e", "bin", "id", "io", "inc", "isin", "path", "log", "of", "ini", "index", "input", "er", "out", "In", "s", "conn", "stream", "inner", "on", "image", "c", "err", "doc", "cms", "ssl", "a", "r", "connection", "at", "b", "info", "again", "n", "scan", "ex", "o", "ing", "nin", "fr", "buffer", "inn", "min", "by", "it", "from", "is", "l", "data", "file", "source", "server", "con", "f"], "line": ["url", "lc", "reader", "status", "str", "parse", "el", "e", "id", "log", "le", "row", "val", "sl", "ge", "string", "name", "end", "Line", "lines", "L", "link", "code", "LINE", "b", "object", "text", "block", "message", "buffer", "key", "lf", "l", "lin", "data", "file", "col", "page", "source", "inline", "entry", "ne", "frame", "record", "value", "unit", "ine", "se", "comment", "f", "cell"], "i": ["qi", "ip", "ai", "ti", "I", "e", "io", "xi", "x", "ini", "index", "eni", "u", "li", "ui", "uni", "ci", "si", "phi", "ii", "j", "ie", "info", "ori", "b", "n", "o", "bi", "zi", "slice", "ski", "ri", "p", "gi", "ix", "fi", "is", "abi", "l", "oi", "di", "ni", "f", "pi"], "logDatum": ["logDam", "LogDum", "logFata", "logDsata", "logFictionary", "Logdict", "logDict", "exDDatum", "exDam", "logFam", "logDatictionary", "exDDictionary", "logDsum", "logdict", "logDsatum", "Logdatum", "exDictionary", "logDatata", "logDDam", "LogDatum", "logFatum", "exDData", "logDictionary", "logDDictionary", "logdatum", "logdata", "logDatatum", "logDData", "Logdum", "logDum", "exData", "logData", "exDDam", "logDatam", "exDatum", "logDsict", "Logdata", "LogData", "logDatict", "logDDatum", "LogDict", "logdum"]}}
{"id1": "3558512", "id2": "17999474", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "label": 1, "substitutes": {"serialize": ["Serialze", "finalze", "Serialize", " serialze", "erialize", "Serialized", "erialze", "Serialization", "Serialify", "serialze", " serialization", "serializable", "erialization", "normalify", "normalized", "finalize", "normalze", "serialify", "finalized", "finalify", "erializable", "Serializable", "serialized", "serialization", "normalize", " serializable"], "out": ["exec", "OUT", "png", "outs", "cache", "client", "w", "gen", "output", "bin", "io", "raw", "filename", "name", "string", "obj", "conn", "archive", "image", "err", "Out", "writer", "i", "report", "a", "ex", "parent", "o", "loader", "buffer", "content", "copy", "page", "data", "pool", "file", "up", "source", "server", "dump", "temp"], "parser": ["test", "processor", "base", "master", "reader", "system", "cache", "builder", "parse", "php", "lp", "tt", "worker", "xml", "plugin", "arser", "er", "seed", "cp", "pkg", "upload", "writer", "pe", "Parser", "class", "parent", "handler", "pillar", "per", "loader", "p", "wrapper", "copy", "file", "up", "server", "instance", "rar", "pp", "ss", "as", "txt", "manager"], "on_disk": ["onJdemand", "onnetfile", "onnetspace", "off_space", "off_delete", "onbootlock", "on_lock", "onbookdelete", "off_lock", "on_file", "off_drive", "onjspace", "off_storage", "onbootdrive", "onJdrive", "onbootdisk", "on_drive", "onJlock", "onjdrive", "onJdisk", "onbootstorage", "off_demand", "onbookdrive", "off_disk", "onjfile", "onbookdisk", "on_storage", "onnetdemand", "onjdisk", "on_demand", "onnetdisk", "on_delete", "onnetdrive", "on_space", "off_file"], "in": ["ins", "thin", "din", "reader", "IN", "login", "bin", "inc", "ini", "input", "In", "conn", "inner", "stream", "c", "inas", "ax", "i", "connection", "info", "r", "again", "o", "socket", "win", "inn", "min", "pin", "copy", "data", "lin", "file", "source", "kin", "rin", "pass", "con", "ac", "as", "f"]}}
{"id1": "17522011", "id2": "23677147", "code1": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 0, "substitutes": {"read": ["exec", "reader", "send", "parse", "use", "feed", "load", "invoke", "readable", "check", "default", "include", "input", "connect", "start", "play", "write", "resources", "eval", "build", "type", "print", "report", "class", "find", "Read", "READ", "resource", "add", "get", "data", "process", "work", "create", "reads", "open", "reading", "select", "run"], "classLoader": ["resourceLoader", "ClassPath", "ClassLoad", "classReader", "resourceLoading", " classDir", "classDir", " classloader", "fileDir", "classLoading", " classReader", "fileLoader", "resourceReader", "classPath", "classLoad", "ClassLoading", "ClassReader", "fileloader", "ClassDir", "Classloader", "ClassLoader", " classPath", "resourceloader", "classloader", " classLoad", " classLoading", "filePath", "fileLoad"], "name": ["address", "base", "alias", "str", "comment", "id", "ame", "child", "none", "old", "path", "Name", "x", "default", "filename", "string", "time", "named", "word", "image", "prefix", "no", "large", "code", "type", "connection", "active", "class", "root", "null", "n", "NAME", "parent", "resource", "key", "search", "data", "file", "pass", "value", "home", "names", "part", "size"], "all": ["ann", "call", "allow", "ALL", "local", "left", "apply", "app", "not", "none", "sort", "am", "alls", "total", "one", "al", "auto", "named", "this", "All", "at", "global", "batch", "active", "both", "any", "with", "each", "list", "sync", "alpha", "array", "attribute", "l", "process", "and", "only", "pass", "full", "part", "f", "partial"], "sm": ["su", "cm", "im", "serv", "sv", "sw", "imm", "ms", "Sm", "sr", "gm", "rm", "sim", "zip", "sam", "smith", "bm", "mo", "sl", "ama", "fm", "si", "ym", "sa", "asm", "m", "sk", "sb", "om", "SM", "so", "km", "sym", "mm", "tm", "sn", "sy", "service", "api", "em", "hm", "wm", "sh", "source", "vm", "nm", "spe", "sp", "sum", "sf", "ss"], "enu": ["enun", " enus", "anU", "Encu", "EnU", " encu", "venus", "Enun", "enou", "anun", "anu", "enncu", "ENc", "Enu", " ennu", "enus", "enU", "ennus", "munun", "ENu", "ennnu", "munus", "Enou", "enc", "Ennu", "venou", "ennu", "Enc", "munu", "venu", "Enus", "encu", "munU", "anus", "ENou", "ENus", "venc"], "url": ["address", "base", "job", "rel", "str", "id", "zip", "URL", "path", "sl", "Url", "string", "li", "ls", "image", "layer", "ssl", "i", "r", "connection", "browser", "ll", "pull", "loc", "loader", "ur", "uri", "resource", "key", "http", "l", "in", "source", "file", "server", "plug", "download", "page", "impl", "web", "f"], "is": ["us", "im", "ais", "esi", "ip", "ins", "ois", "app", "iso", "id", "are", "isa", "was", "io", "has", "IS", "ar", "vs", "bis", "Is", "es", "ic", "abs", "ir", "cms", "ls", "ris", "inner", "image", "isl", "si", "iss", "ios", "os", "ii", "or", "ori", "i", "info", "ie", "js", "ignore", "ops", "lis", "il", "isc", "isi", "ri", "uri", "api", "p", "close", "it", "its", "iris", "http", "in", "act", "init", "as", "serv", "web", "mis"], "s": ["su", "services", "sv", "ins", "ms", "outs", "w", "sets", "e", "ts", "rs", "ws", "ions", "sl", "es", "session", "ns", "abs", "string", "ies", "ls", "u", "lines", "ks", "c", "spec", "results", "si", "als", "os", "ses", "comments", "strings", "m", "storage", "sg", "ssl", "sb", "i", "r", "ments", "g", "rows", "js", "n", "cs", "o", "ans", "ps", "S", "ows", "ds", "p", "les", "h", "its", "ips", "l", "se", "sc", "ches", "d", "details", "ss", "sf", "f", "gs", "ings"]}}
{"id1": "9647576", "id2": "8079516", "code1": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"Reserve": ["Rolve", "Resolve", " Resolve", "Rerve", "Send", "Rend", "Resend", "Rerves", "Serve", "Reserves", " Resend", "Serves", "Solve", " Reserves"], "stbookings": ["stbookies", "ssbooksings", "stbooksifications", "ssbookalls", "stbooksalls", "ssbookifications", "ssbooksalls", "stBookifications", "stbookalls", "stBookies", "stbookifications", "ssbooksifications", "stbooksies", "stbooksings", "stauthories", "ssbookies", "stauthorifications", "stauthoralls", "ssbookings", "stBookalls", "stBookings", "stauthorings", "ssbooksies"], "stchartwl": ["STconfigwl", "stplotml", "stchartml", "stplotls", "STchartwl", "stchartowl", "stchartls", "stplotwl", "stconfigls", "st_ls", "st_wl", "STchartls", "stconfigowl", "STconfigowl", "STchartowl", "stplotowl", "st_ml", "stconfigml", "stconfigwl", "STconfigls", "STchartml", "st_owl", "STconfigml"], "sp": ["jp", "ip", "arp", "amp", "tp", "sf", "scope", "str", "ap", "bp", "pace", "spr", "xml", "space", "sl", "session", "name", "profile", "bsp", "pl", "si", "yp", "sg", "rap", "ipp", "type", "sk", "Sp", "html", "span", "text", " Sp", "ps", "ig", "inst", "service", "p", " sc", "isp", "page", "source", "op", "sc", "sil", "email", "osp", " esp", "script", "pp", "spe", "SP", "esp", "spl", "ss", "mp", "pr", " SP"], "userbooksql": ["userlocksQL", "userreadskel", " useraveskel", "usersbooksearch", "userbooksil", "otherbookql", "otherbooksqs", "userbooksearch", "usersbookQL", " useraveskl", "userbookQL", "userbooksprintf", "usersbookql", "userbookskel", "userbanksil", "userbookssql", "userbookskl", "userlocksprintf", "userordersqs", "otherbooksql", " userbookskel", "userordersQL", "otherbookssql", "userreadsQL", "userbookql", "usersbookearch", "userreadsil", "userbooksQL", "otherbooksQL", "usersbooksql", "usersbooksprintf", "userreadsql", "useravesql", "userreadsearch", "userpagesQL", "userreadskl", "otherbookQL", " userbookskl", " userbooksil", "userbookearch", "userlocksearch", "userordersql", "usersbookprintf", "userbanksql", "userbankskel", "userreadsprintf", "userpagesqs", " useravesil", "useraveskel", "useraveskl", "userpagesql", "userpagessql", "userlocksql", "userbookprintf", "usersbooksQL", "userorderssql", "userbankskl", "userbooksqs", "useravesil", "userbookqs", " useravesql", "otherbookqs"], "agentbooksql": ["userbooksil", "agentbooksil", "agentstylesql", "agentstylesil", "agentstylesqu", "agentstylessql", "agentbooksci", "userbookssql", "userbooksli", "userpagesli", "agentBookssql", "agentbookQL", "agentpagesci", "agentbooksli", "agentpagesQL", "agentgroupsli", "agentgroupsQL", "agentbooksQL", "agentgroupssql", "agentpluginsci", "userbooksQL", "agentpagesli", "agentpluginsQL", "userpagesQL", "agentBooksqu", "userbooksqu", "agentbooksqu", "agentgroupsql", "agentBooksil", "agentpagesql", "userbooksci", "agentBooksql", "agentpagessql", "agentbookssql", "userpagesql", "userpagessql", "userpagesci", "agentbookli", "agentpluginssql", "agentbookql", "agentpluginsql"], "bookingid": ["bookingurl", "bookingsinfo", "bookillingid", "bookinginfo", "bookINGurl", "bookillingurl", "bookingname", "bookillinginfo", "bookingsname", "booksingsname", "bookINGname", "booksingsid", "booksinginfo", "booksingurl", "bookINGid", "booksingsinfo", "bookillingname", "booksingname", "bookINGinfo", "bookingsurl", "booksingid", "booksingsurl", "bookingsid"], "currentcoach": ["currentlypoach", "currentloache", " currentcoache", " currentcoac", " currentpoach", "currentpoaching", "currentCOach", "currentchoase", "currentloach", "currentgoaching", "currentlycoach", "currentgoac", "currentcoached", "currentnoache", "currentcoaching", "currentlycoache", " currentpoac", "currentnoach", " currentloache", "currentlypoaching", " currentcoase", "currentpoache", "currentboach", "currentcoache", "currentpoached", "currentgoach", "currentpoac", "currentCOase", "currentpoach", "currentgoache", "currentlypoac", "currentcoam", "currentboache", "currentchoach", "currentpoase", "currentloached", "currentpoam", " currentpoase", "currentlycoac", "currentpoah", " currentcoam", " currentloach", "currentcoase", "currentcoah", " currentpoam", "currentboached", "currentlypoache", "currentCOac", "currentnoac", "currentchoam", "currentboah", "currentchoac", " currentloached", "currentloah", " currentcoah", "currentnoaching", "currentcoac", "currentlycoaching", " currentcoached", " currentloah", "currentCOam"], "currentseat": ["currentlyslave", "Currentseason", " currentcourse", "currentticket", "currentslave", "Currentseat", "Currentcourse", "activecourse", " currentslave", " currentsex", "currentlysex", "activeticket", "activecomponent", "Currentsex", "currentlyseason", "currentseason", "Currentslave", "currentlyseat", "Currentticket", "currentsex", "Currentcomponent", "currentcourse", "activeseat", "currentcomponent", " currentcomponent", " currentticket", " currentseason"], "tickpos": ["ickpointer", "hellopointer", "hellopos", " tickPOS", "stickpos", "ickposition", "ickPOS", " tickPos", "ickPos", "ickpo", "trialPos", "tickpose", "helloposition", "crosspos", "trialPOS", "helloPOS", "tickposition", "crossPos", " tickpo", "crosspo", " tickposition", "helloPos", "trialpose", "ickerPos", "ickerpos", "ickpose", "ickerpointer", " tickpose", "tickpointer", "stickPos", "ickerposition", "trialpos", "tickPOS", "ickpos", "stickposition", "tickpo", "tickPos"], "chartavailupdsql": ["chartavailupdatesql", "chartavailumpdssql", "chartavailumpssqs", "chartavailupdssql", "chartavailupcsql", "chartavailupdatesqs", "chartavailupcssql", "chartavailupcsqs", "chartavailumpdsql", "chartavailupssqs", "chartavailupsssql", "chartavailumpssql", "chartavailupdsqs", "chartavailupssql", "chartavailumpdsqs", "chartavailupdatessql", "chartavailumpsssql"]}}
{"id1": "8166767", "id2": "10158738", "code1": "    public Object invoke(MethodInvocation invocation, int retryTimes) throws Throwable {\n        retryTimes--;\n        try {\n            String url = getServiceUrl() + \"/\" + invocation.getMethod().getName();\n            HttpPost postMethod = new HttpPost(url);\n            if (invocation.getMethod().getParameterTypes().length > 0) postMethod.setEntity(new StringEntity(JsonUtils.toJson(invocation.getArguments())));\n            HttpResponse rsp = HttpClientUtils.getDefaultInstance().execute(postMethod);\n            StatusLine sl = rsp.getStatusLine();\n            if (sl.getStatusCode() >= 300) {\n                throw new RuntimeException(\"Did not receive successful HTTP response: status code = \" + sl.getStatusCode() + \", status message = [\" + sl.getReasonPhrase() + \"]\");\n            }\n            HttpEntity entity = rsp.getEntity();\n            StringBuilder sb = new StringBuilder();\n            InputStream is = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n            String line;\n            while ((line = reader.readLine()) != null) sb.append(line).append(\"\\n\");\n            reader.close();\n            is.close();\n            String responseBody = null;\n            if (sb.length() > 0) {\n                sb.deleteCharAt(sb.length() - 1);\n                responseBody = sb.toString();\n            }\n            Type t = invocation.getMethod().getGenericReturnType();\n            if (t.equals(Void.class) || responseBody == null) return null;\n            return JsonUtils.fromJson(responseBody, t);\n        } catch (ConnectTimeoutException e) {\n            if (retryTimes < 0) throw e;\n            if (urlFromDiscovery) {\n                String serviceUrl = discoverServiceUrl(getServiceInterface().getName());\n                if (!serviceUrl.equals(getServiceUrl())) {\n                    setServiceUrl(serviceUrl);\n                    log.info(\"relocate service url:\" + serviceUrl);\n                }\n            }\n            return invoke(invocation, retryTimes);\n        }\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"invoke": ["exec", "wrap", "send", "call", "apply", "olve", "handle", "oke", "func", "request", "fire", "start", "to", "next", "operation", "via", "construct", "java", "connection", "info", "object", "online", "post", " invoking", "evaluate", "service", "resource", "timeout", " execute", "submit", "http", "in", "process", "execute", "reflect", "create", "instance", "reply", "initial", "open", "run"], "invocation": ["imploked", "Invoking", "alloker", "invoid", "enviation", "installoker", " invoked", "imploke", "alloke", "convoke", " invoker", "inviation", "alloice", "invoked", "inocation", "invoice", "invoker", "Invoke", "installocation", "inoker", "convocation", "installiation", "implocation", " invoking", "Invocation", "Invoker", "Invoid", "envoid", "convoker", "envoker", "Invoice", "envocation", "invoking", "inoking", " invoice", "allocation", "imploice", "alloked", "convoice", "installoid", "Inviation"], "retryTimes": ["rettryTimes", "RetryingTS", "RetryingTokens", "retrowTimes", "RetryTime", "reryTime", "retryHours", "retrowPoints", "reryTimes", "retayTime", "RetryTokens", "retvalDays", "retryingYears", "retryingTime", "retryingHours", "retryingTokens", "retryTime", "RetryingYears", "retayTimes", "retryPoints", "retrainPoints", "retryDays", "retryingTS", "retryTS", "retrainTime", "RetryHours", "RetryPoints", "retvalPoints", "retriedTime", "retyPoints", "RetryingTime", "rettryTime", "retayYears", "retyHours", "RetryTimes", "RetryingPoints", "retrowTokens", "retriedYears", "retvalTime", "RetryingTimes", "retrainTimes", "RetryYears", "retyTimes", "retriedPoints", "reryPoints", "retryingTimes", "retyTime", "retriedHours", "retayTS", "retriedTimes", "retryingPoints", "retriedTS", "RetryingHours", "retryTokens", "rettryPoints", "retryingDays", "retryYears", "retrowTime", "rettryDays", "RetryTS", "retvalTimes", "reryDays", "retrainTokens"], "url": ["address", "base", "id", "URL", "path", "enabled", "Url", "host", "location", "string", "name", "ls", "image", "ssl", "method", "r", "html", "route", "ll", "www", "config", "loc", "uri", "service", "resource", "http", "href", "l", "source", "server", "channel", "email", "src", "json", "rl", "f", "response"], "postMethod": ["postRequest", "headMethods", "postOperation", "PostRequest", "getMethod", "getMethods", "PostFunction", "PostMethods", "POSTFunction", " postRequest", "headPost", "headMethod", "PostMethod", "getFunction", " postFunction", " postOperation", "postMethods", "PostOperation", " postMethods", "postPost", "POSTOperation", "POSTMethod", "getRequest", "postFunction", "PostPost", "POSTPost", "headFunction", " postPost"], "rsp": ["rssp", "rssh", "rcsc", "Rserv", "rcsp", "RSp", "Rsp", "frsl", "frsc", " rsl", "rssl", "rSp", "rsl", "rcsl", "rpc", "Rsl", "srpc", "srsp", "Rpc", "srserv", "rserv", "rcsh", " rsh", "rssc", "rsc", "frSp", " rserv", " rpc", "srsl", "Rsc", "frsp", " rsc", " rSp", "rsh"], "sl": ["ser", "su", "lc", "cl", "status", "sr", "dl", "el", "hl", "kl", "shell", "cel", "nl", "fl", "ls", "isl", "bl", "si", "pl", "sel", "sle", " Sl", "ssl", "SB", "ll", "il", "sync", "sn", "SL", "fr", "la", "l", "sh", "cli", "se", "sil", "coll", "sp", "sw", "sf", "rl", "Sl"], "entity": ["result", "el", "e", "output", "metadata", "model", "xml", "environment", "oter", "node", "string", "obj", "type", "info", "connection", "ent", "application", "et", "body", "enc", "message", "service", "resource", "api", "em", "person", "agent", "content", "document", "translation", "http", "Entity", "page", "data", "source", "article", "email", "json", "collection", "response"], "sb": ["su", "bc", "bj", "sv", "xb", "ib", "sr", "bb", "gb", "ob", "bp", "nb", "bd", "db", "bm", "ws", "fb", "mb", "abs", "string", "s", "bsp", "sth", "orb", "sm", "si", "sa", "sg", "buff", "ssl", "info", "SB", "lb", "sq", "b", "ub", "bg", "bt", "wb", "kb", "lr", "ab", "rob", "eb", "rb", "lab", "txt", "pb", "usb", "bh", "src", "bf", "split", "obb", "sp", "ss", "sf", "cb", "bs"], "is": ["ser", "serv", "ais", "address", "ip", "ai", "ib", "str", "ob", "has", "ar", "isa", "io", "iso", "iri", "was", "id", "IS", "bis", "Is", "es", "ir", "out", "ui", "s", "ris", "stream", "si", "iss", "ios", "os", "or", "i", "info", "ie", "rx", "lis", "isi", "ri", "uri", "fs", "api", "iter", "it", "iris", "its", "in", "data", "src", "as"], "reader": ["ser", "ob", "e", "feed", "io", "rr", "rer", "ler", "row", "er", "ini", "ir", "s", "stream", "inner", "editor", "read", "Reader", "or", "writer", "i", "r", " Reader", "rx", "handler", "oder", "per", "ner", "ri", "buffer", "iter", "lr", "parser", "rb", "it", "rc", "l", "in", "ry", "server", "entry", "rar", "ink", "reading", "f"], "line": ["lc", "cl", "header", "base", "job", "str", "e", "feed", "le", "row", "ge", "string", "name", "li", "Line", "end", "lines", "no", "len", "character", "code", "sel", "LINE", "i", "pe", "b", "number", "text", "body", "block", "sync", "cle", "message", "key", "non", "lf", "l", "lin", "data", "char", "page", "letter", "style", "entry", "inline", "frame", "pass", "part", "unit", "comment", "response", "cell"], "responseBody": ["entityText", "replyContent", " responsePart", " responseContent", "responseContent", "ResponseContent", "requestContent", "responseMail", "respText", "respMail", "replyBody", "replyPart", "ResponseMessage", "respbody", "responseMessage", "entityMail", "ResponseBody", "entitybody", "requestbody", " responseMessage", " responseText", "replybody", "respBody", "Responsebody", "requestBody", "responseText", " responsebody", "responsebody", "responsePart", "entityBody", "ResponsePart", "replyMessage", " responseMail"], "t": ["wt", "v", "template", "k", "st", "types", "w", "e", "ot", "ts", "total", "tf", "x", "T", "target", "te", "u", "s", "ext", "c", "y", "m", "format", "ct", "type", "en", "r", "i", "et", "g", "class", "n", " T", "o", "Type", "p", "it", "h", "dt", "l", "ant", "d", " type", "tor", "f"], "serviceUrl": ["ServiceName", "serverURL", "playSl", "ServiceUr", " serviceName", "storageLine", " serviceURL", "serviceLine", " serviceId", "playName", "serviceLink", "storageUrl", "serverName", " serviceSl", "responseLine", "serverUrl", "ServiceURL", "ServiceStr", "playUrl", "ServiceSl", "serviceStr", "ServiceId", "serviceUr", " serviceStr", "serverStr", "serviceId", "serverUr", "serviceSl", "playURL", "storageLink", "serviceName", "ServiceUrl", "storageURL", "responseURL", "ServiceLink", "ServiceLine", "serviceURL", "responseUrl", "serverId", "responseLink", " serviceUr"]}}
{"id1": "15510198", "id2": "8468859", "code1": "    protected static Parser buildParser(URL url) throws IOException, ParserException {\n        Parser parser;\n        URLConnection connection = openConnection(url);\n        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {\n            parser = new Parser(connection);\n        } else {\n            parser = null;\n        }\n        return parser;\n    }\n", "code2": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"buildParser": ["newWriter", "buildReader", "constructWriter", "makeHandler", "newParser", "makeParser", "constructHandler", "newReader", "constructReader", "makeReader", "newHandler", "buildWriter", "makeWriter", "buildHandler", "constructParser"], "url": ["address", "base", "str", "io", "URL", "proxy", "path", "sl", "Url", "host", "location", "name", "obj", "bug", "image", "c", "link", "this", "ssl", "class", "null", "object", "www", "config", "loc", "loader", "uri", "service", "resource", "http", " URL", "l", "source", "file", "server", "data", "channel", "page", "open"], "ParserException": ["ParserError", "IOError", "ParserExc", " IOException", " IOExc", "SSLExc", "SSLError", " IOError", "IOExc", "SSLException", "IOException"], "parser": ["slave", "jp", "test", "result", "processor", "master", "fp", "reader", "cache", "builder", "parse", "php", "worker", "xml", "x", "fruit", "ler", "plugin", "arser", "er", "seed", "this", "type", "writer", "pe", "Parser", "class", "null", "library", "parent", "root", "object", "jack", "handler", "config", "loader", "pard", "pd", "api", "p", "http", "angler", "data", "pool", "se", "server", "style", "instance", "pc", "manager", "au"], "connection": ["bc", "lc", "position", "reader", "client", "connected", "io", "proxy", "db", "function", "connect", "session", "pointer", "conn", "context", "section", "image", "c", "this", "database", "link", "character", "event", "communication", "reference", "j", "Connection", "class", "application", "object", "directory", "handler", "config", "loc", "socket", " Connection", "message", "uri", "service", "resource", "condition", "document", "http", "ion", "channel", "server", "instance", "con", "collection", "open", "response", "relation"]}}
{"id1": "22734545", "id2": "1985677", "code1": "    public void generate(String urlString, String target) throws Exception {\n        URL url = new URL(urlString);\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream());\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target));\n        byte[] buf = new byte[10 * 1024];\n        int len;\n        while ((len = inputStream.read(buf, 0, buf.length)) != -1) {\n            outputStream.write(buf, 0, len);\n        }\n        inputStream.close();\n        outputStream.close();\n        urlConnection.disconnect();\n    }\n", "code2": "    public SRWGuiClient(String initialURL) {\n        super(\"Simple Swing Browser\");\n        this.initialURL = initialURL;\n        addWindowListener(new ExitListener());\n        WindowUtilities.setNativeLookAndFeel();\n        JPanel topPanel = new JPanel();\n        topPanel.setBackground(Color.lightGray);\n        homeButton = new JIconButton(\"home.gif\");\n        homeButton.addActionListener(this);\n        JLabel urlLabel = new JLabel(\"URL:\");\n        urlField = new JTextField(30);\n        urlField.setText(initialURL);\n        urlField.addActionListener(this);\n        topPanel.add(homeButton);\n        topPanel.add(urlLabel);\n        topPanel.add(urlField);\n        getContentPane().add(topPanel, BorderLayout.NORTH);\n        try {\n            URL url = new URL(initialURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            boolean xml = true;\n            String inputLine;\n            StringBuffer content = new StringBuffer(), stylesheet = null;\n            Transformer transformer = null;\n            inputLine = in.readLine();\n            if (inputLine == null) {\n                System.out.println(\"No input read from URL: \" + initialURL);\n                return;\n            }\n            if (!inputLine.startsWith(\"<?xml \")) {\n                xml = false;\n                content.append(inputLine);\n            }\n            if (xml) {\n                inputLine = in.readLine();\n                if (inputLine.startsWith(\"<?xml-stylesheet \")) {\n                    int offset = inputLine.indexOf(\"href=\");\n                    String href = (inputLine.substring(inputLine.indexOf(\"href=\") + 6));\n                    href = href.substring(0, href.indexOf('\"'));\n                    System.out.println(\"href=\" + href);\n                    url = new URL(url, href);\n                    String stylesheetURL = url.toString();\n                    System.out.println(\"stylesheet URL=\" + url.toString());\n                    transformer = (Transformer) transformers.get(stylesheetURL);\n                    if (transformer == null) {\n                        BufferedReader sheetIn = new BufferedReader(new InputStreamReader(url.openStream()));\n                        sheetIn.readLine();\n                        stylesheet = new StringBuffer();\n                        while ((inputLine = sheetIn.readLine()) != null) stylesheet.append(inputLine).append('\\n');\n                        System.out.println(stylesheet.toString());\n                        TransformerFactory tFactory = TransformerFactory.newInstance();\n                        StreamSource xslSource = new StreamSource(new StringReader(stylesheet.toString()));\n                        transformer = tFactory.newTransformer(xslSource);\n                        transformers.put(stylesheetURL, transformer);\n                    }\n                }\n            }\n            while ((inputLine = in.readLine()) != null) content.append(inputLine).append('\\n');\n            htmlPane = new JEditorPane();\n            if (transformer != null) {\n                StringReader stringRecordReader = new StringReader(content.toString());\n                StringWriter xmlRecordWriter = new StringWriter();\n                StreamSource streamXMLRecord = new StreamSource(stringRecordReader);\n                transformer.transform(streamXMLRecord, new StreamResult(xmlRecordWriter));\n                String html = xmlRecordWriter.toString();\n                int i = html.indexOf('>');\n                html = \"<html>\" + html.substring(html.indexOf('>') + 1);\n                System.out.println(html);\n                htmlPane.setContentType(\"text/html\");\n                htmlPane.setText(\"<html><head><META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"><title>GSAFD Thesaurus</title></head><body><center><h2>GSAFD Thesaurus</h2></center><p>A thesaurus of genre terms to support the \\\"Guidelines on Subject Access to Individual Works of Fiction , Drama\\\" (GSAFD)</p><table cellspacing=\\\"5\\\" width=\\\"100%\\\"><tr><td><h3>Search</h3><p></p></td><td valign=\\\"top\\\"><h3>Browse</h3></td></tr></table></body></html>\");\n            } else htmlPane.setText(content.toString());\n            htmlPane.setEditable(false);\n            htmlPane.addHyperlinkListener(this);\n            JScrollPane scrollPane = new JScrollPane(htmlPane);\n            getContentPane().add(scrollPane, BorderLayout.CENTER);\n        } catch (IOException ioe) {\n            warnUser(\"Can't build HTML pane for \" + initialURL + \": \" + ioe);\n        } catch (TransformerException e) {\n        }\n        Dimension screenSize = getToolkit().getScreenSize();\n        int width = screenSize.width * 8 / 10;\n        int height = screenSize.height * 8 / 10;\n        setBounds(width / 8, height / 8, width, height);\n        setVisible(true);\n    }\n", "label": 0, "substitutes": {"generate": ["Generate", "Generile", "GenerATE", " interpolile", "Generating", " interpolating", " generating", " generATE", "generating", "generATE", " interpolate", " interpolATE", " generile", "generile"], "urlString": ["fileStr", "urlUrl", " urlFile", "addressFile", "fileStream", "resourceFile", "httpStr", "urlStr", "resourcestring", "resourceString", "httpstring", "addressUrl", "filestring", "urlFile", " urlUrl", "urlStream", "addressStream", " urlStream", "urlstring", "fileString", "resourceStr", "fileFile", "fileUrl", "httpString", "addressString", "httpFile"], "target": ["external", "address", "result", "base", "arget", "project", "output", "path", "remote", "filename", "location", "host", "name", "string", "top", "context", "to", "next", "database", "format", "Target", "connection", "object", "parent", "text", "dest", "buffer", "timeout", "resource", "content", "source", "match", "file", "download", "src", "temp"], "url": ["base", "client", "bb", "feed", "URL", "ball", "log", "sl", "Url", "host", "string", "conn", "ls", "gl", "stream", "image", "c", "this", "build", "ssl", "connection", "r", "user", "b", "ll", "www", "config", "buffer", "uri", "resource", "http", "plug", "l", "page", "source", "file", "server", "download", "open", "web", "blog", "f"], "urlConnection": [" urlConnector", "urlNetwork", "urlConnect", "webConnection", "inputConn", "httpconnection", " urlPool", "webNetwork", "URLConnection", "webconnection", " urlConn", "inputConnection", "urlconnection", "URLNetwork", "URLPool", "inputConnect", "httpConnect", "httpConnection", "fileConnection", "inputconnection", "urlConn", "URLConn", "fileNetwork", "webUnit", "webConnect", "URLconnection", "inputPool", "urlUnit", "urlConnector", "fileconnection", "URLConnector", "urlPool", "webConn", "inputConnector", "URLUnit", "httpConn", "fileUnit"], "inputStream": ["InputConnection", " inputConnection", "inputSteam", " inputView", "outputConnection", "InputChannel", " inputSteam", "inSteam", "outputChannel", "inputConnection", "outputSteam", "inStream", "outputView", "InputView", "inputView", "inConnection", "InputQueue", "InputSteam", "inputQueue", "outputQueue", "inputChannel", " inputChannel", " inputQueue", "InputStream", "inView"], "outputStream": [" outputSteam", " outputstream", "inputSteam", "OutputView", "outputStreamer", "OutputSteam", "resourceConnection", " outputConnection", " outputDirectory", " outputView", "resourcestream", "outputConnection", "resourceSteam", "putStream", "OutputStream", "OutputDirectory", "resourceStream", "inputConnection", "outputSteam", "OutputStreamer", "outputView", "putSteam", "outputstream", "inputView", "Outputstream", "putstream", "inputDirectory", " outputStreamer", "inputstream", "outputDirectory", "putStreamer"], "buf": ["vec", "uf", "cap", "bc", "v", "Buffer", "dec", "uc", "job", "bb", "gb", "output", "bin", "br", "bp", "cv", "bd", "raw", "func", "ba", "fb", "input", "seq", "queue", "c", "off", "bag", "count", "batch", "Buff", "b", "ff", "loc", "block", "pad", "wb", "buffer", "ab", "blocks", "la", "done", "bytes", "rb", "cas", "fd", "rc", "data", "pool", "bh", "pos", "num", "bf", "cat", "bs", "cb", "buff"], "len": ["cap", "base", "ann", "bin", "el", "pre", "Len", "db", "ler", "val", "fl", "start", "length", "end", "li", "fin", "ln", "c", "no", "off", "err", "read", "en", "ie", "i", "r", "count", "b", "n", "nt", "iter", "la", "min", "lf", "line", "l", "data", "lin", "in", "pos", "limit", "part", "size", "f", "le"]}}
{"id1": "17296916", "id2": "2465747", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 0, "substitutes": {"logging": ["Logting", "loging", " loging", "bloging", " logting", "Logging", "blogging", "Logger", "blogting", "logting", "Loging", " logger", "logger", "blogger"], "wrap": ["wa", "wire", "util", "cache", "w", "now", "parse", "flash", "war", "handle", "use", "force", "cover", "ws", "default", "div", "binary", "stream", "word", "image", "lock", "widget", "self", "build", "rap", "bag", "we", "format", "or", "box", "transform", "b", "handler", "pipe", "ow", "nw", "wb", "message", "ad", "api", "p", "wrapper", "get", "h", "wp", "process", "work", "init", "create", "frame", "wra", " Wrap", "sw", "web", " wrapped", "f", "run"], "buffer": ["Buffer", "template", "bc", "url", "result", "uf", "header", "base", "uffer", "reader", "cache", "builder", "flash", "bb", "ob", "view", "bin", "transfer", "pause", "feed", "nb", "cover", "surface", "shell", "bm", "log", "manager", "fb", "bridge", "binary", "queue", " buf", "image", "code", "layer", " buffers", "reference", "writer", "print", "report", "batch", "b", "bar", "buf", "player", "null", " receive", "loader", "table", "iter", "message", "BU", "wrapper", "copy", "document", "source", "pb", "server", "ref", "frame", "reply", "board", "comment", "cb", "buff", "response", "msg"], "encoding": ["coder", "Encet", "unicode", "decoding", "decode", "encoder", "coding", "enoding", "packoded", "cet", "Encoded", "decoder", "Encryption", "encoded", "unicoded", "ecoding", "unicoder", "decoded", "encryption", "unicoding", "Encoder", "ecoder", "enoded", "packet", "packoding", "enode", "packoder", "ecoded", "coded", "ecryption", "encet", "decryption", "Encoding", "encode", "enoder"], "getEncoding": ["getCocol", " getEnasing", "getencoding", "getCasing", "getEnocol", " getEnoder", " getEncocol", "getEnoded", "getEnasing", "getencoded", " getEnocol", " getEncoder", "getCoder", " getEncasing", "getEnoder", " getEncoded", "getCoded", "getEnoding", "getencocol", "getCoding", "getEncocol", "getEncoded", "getencoder", " getEnoding", "getEncasing", "getEncoder", " getEnoded", "getencasing"], "headers": ["workers", "objects", "header", "ppers", "params", "ers", "types", "relations", "ints", "groups", "str", "ids", "dict", "ters", "host", "s", "values", "lines", "files", "strings", "properties", "vals", "breaks", "options", "head", "body", "caps", "bits", "plugins", "padding", "frames", "parts", "blocks", "wrapper", "content", "h", "links", "http", "fields", "ports", "keys", "details", "names", "heads", "rs", "features", "writers", "ings", "settings"], "is": ["us", "\u00eds", "las", "ais", "ins", "ms", "tis", "ois", "isol", "iso", "isa", "was", "io", "are", "has", "aos", "IS", "bis", "ws", "Is", "sis", "es", "oss", "abs", "out", "cms", "ui", "s", "ris", "isl", "ios", "iss", "os", "ses", "nis", "bas", "or", "ori", "i", "js", "ops", "so", "lis", "isi", "fs", "api", "iris", "its", "http", "in", "obs", "ists", "as", "bs", "mis"], "bos": ["shadow", "mos", "bott", "bc", "las", "osi", "base", "mobi", "osa", "tis", "outs", "ois", "ob", "bin", "aos", "bis", "ws", "opus", "zos", "cms", "obi", "oks", "oes", "bot", "ios", "obos", "os", "bo", "bas", "ses", "org", "oos", "obo", "beans", "ops", "so", "zo", "bi", "bits", "fits", "flo", "bots", "oses", "pins", "ubs", "los", "fs", "lins", "uds", "obs", "cos", "abi", "bh", "bes", "ubis", "bones", "home", "ros", "ko", "oops", "bs", "mis"], "e": ["oe", "de", "esi", "error", "exc", "re", "ise", "one", "x", "ea", "je", "er", "ee", "err", "c", "E", "fe", "ec", "type", "ie", "i", "a", "pe", "ite", "ce", "ception", "o", "ale", "ae", "p", "me", "l", "ev", "ke", "se", "d", "ze", "f", "be"]}}
{"id1": "9802073", "id2": "4852691", "code1": "    public void testAutoCommit() throws Exception {\n        Connection con = getConnectionOverrideProperties(new Properties());\n        try {\n            Statement stmt = con.createStatement();\n            assertEquals(0, stmt.executeUpdate(\"create table #testAutoCommit (i int)\"));\n            con.setAutoCommit(false);\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (0)\"));\n            con.setAutoCommit(false);\n            con.rollback();\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (1)\"));\n            con.setAutoCommit(true);\n            con.setAutoCommit(false);\n            con.rollback();\n            con.setAutoCommit(true);\n            ResultSet rs = stmt.executeQuery(\"select i from #testAutoCommit\");\n            assertTrue(rs.next());\n            assertEquals(1, rs.getInt(1));\n            assertFalse(rs.next());\n            rs.close();\n            stmt.close();\n        } finally {\n            con.close();\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"testAutoCommit": ["testAutoComIT", "testAutoommit", "testAutoComit", "testSyncCommit", "testAutoommits", "testAutoommIT", "testSyncDebit", "testSyncCommits", "testSyncCommIT", "testSyncDebits", "testSyncDebite", "testAutoDebIT", "testAutoDebite", "testAutoCommIT", "testAutoommite", "testAutoCommits", "testAutoComits", "testSyncDebIT", "testAutoDebit", "testAutoCommite", "testAutoComite", "testSyncCommite", "testAutoDebits"], "con": ["bc", "cl", "cache", "gen", "union", "ran", "cur", "log", "session", "conn", "core", "context", "pub", "win", " CON", "col", "cn", "coll", "Conn", "ctrl", "conf", "fac", "pr", "cm", "ocon", "client", "un", "db", "cr", "conv", "lock", "c", "en", "ct", "class", "pen", "fc", "close", "pool", "fn", " conn", "ac", "can", "cf", "syn", "mc", "uc", "ca", "util", "connect", "cc", "m", "config", "Con", "cond", "min", "non", "CON", "rc", "pc", "an", "ver", "com", "platform", "pre", "tc", "sql", "connection", "crit", "Connection", "n", "co", "sync", "common", "cas", "act", "ctx"], "stmt": ["stm", "ctmb", "STMT", "Stmp", " stm", " stmn", "Stmd", "stur", "Stm", "stnt", "estmb", "storp", "estMT", " stMT", "estmt", "rmt", " stmb", "rmd", " stbl", "slmt", "slmp", "STmp", "Storp", "STsp", "STm", " stb", " stpt", "stmd", "Stbl", "estsp", "stb", "ctmt", "STpt", "Stmb", " stnt", "stMT", " stmp", "stpt", "Stmn", "STmb", "stor", "STbl", "slur", "stmn", "rorp", "slmn", " stsp", "rb", "stmp", "Stur", "Stpt", " storp", " stor", "Stmt", "STmt", "stbl", "Stnt", " stur", "stmb", "Stor", "STnt", " stmd", "ctmp", "stsp", "ctor", "Stb"], "rs": ["ins", "ra", "ms", "relations", "reader", "mr", "sr", "xs", " rows", " results", "ges", "rr", "row", " r", "res", "pr", "cr", "ls", "hr", "ris", "vers", " RS", "RS", "results", "rt", "hs", " sr", " res", "repl", "ras", "r", "errors", "rows", "acks", "cs", "rx", "runs", " Rs", "ps", "ars", "ows", "ubs", "Rs", "rc", "ry", "sc", "rys", "eers", "RC", "src", " rc", "rss", "ros", "rl", "rd"]}}
{"id1": "15241397", "id2": "3495460", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public boolean actEstadoEnBD(int idRonda) {\n        int intResult = 0;\n        String sql = \"UPDATE ronda \" + \" SET estado = 1\" + \" WHERE numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"doGet": [" doGET", "handleGET", "didget", " doPut", "didGET", "handlePut", "doGET", "didGet", "handleget", " doget", "didPut", "doget", "doPut", "handleGet"], "request": ["complete", "url", "result", "client", "reader", "received", "QUEST", "xml", "input", "er", "context", "queue", "image", "event", "type", "connection", "method", "report", "info", "application", "user", "object", "query", "message", "uri", "buffer", "resource", "Request", "document", "http", "data", "server", "subject", "req", "instance", "initial", "web"], "response": ["result", "error", "esi", "client", "status", "output", "view", "site", "model", "Response", "function", "host", "session", "out", "generation", "queue", "image", "next", "results", "respond", "writer", "connection", "report", "application", "object", "body", "parent", "message", "resource", "version", "wave", "document", "other", "page", "data", "resp", "server", "pool", "full", "reply", "onse", "json", "collection"], "rewrittenQueryString": ["rewwrittenQueryStr", "rewrittenUrlString", "rewrittenRequestString", "rewrittenPageArray", "rewwrittenRequestString", "rewwrittenQueryString", "rewrittenQuestionText", "rewwrittenQueryArray", "rewrittenQuestionArray", "rewrittenqueryString", "rewwrittenRequestService", "rewrittenQueryStr", "rewwrittenQueryText", "rewwrittenQueryService", "rewrittenqueryService", "rewrittenQueryList", "rewrittenRequestLine", "rewrittenUrlText", "rewrittenRequestText", "rewwrittenQueryList", "rewrittenRequestArray", "rewrittenUrlService", "rewrittenRequestList", "rewrittenQueryLine", "rewrittenQuestionLine", "rewrittenqueryLine", "rewrittenQueryArray", "rewrittenQuestionString", "rewrittenRequestStr", "rewwrittenRequestText", "rewrittenQueryText", "rewrittenqueryText", "rewwrittenRequestArray", "rewrittenPageString", "rewrittenUrlLine", "rewrittenRequestService", "rewrittenQuestionStr", "rewwrittenQueryLine", "rewrittenPageList", "rewrittenqueryStr", "rewwrittenRequestLine", "rewwrittenRequestList", "rewwrittenRequestStr", "rewrittenPageLine", "rewrittenQuestionList", "rewrittenQueryService"], "rewrittenUrl": ["RewrittenJar", "RewwrittenText", "rerittenLanguage", "rewardedURL", "rewardedUr", "rewmatchedURL", "rewrapedURL", "rewwrittenServer", "rewwrittenURL", "rerittenUrl", "rewardedLanguage", "rewmatchedFile", "rewedUr", "rewilledUrl", "rewrapedFile", "RewwrittenServer", "rewilledJar", "rewcraftedLocation", "rewodedUrl", "rewardedFile", "RewrittenURL", "rewatchedUrl", "rewatchedURL", "RewrittenServer", "rewrittenInt", "Rewwrittenurl", "rewodedFile", "rewriteText", "RewwrittenUrl", "rewardedJar", "rewedurl", "rewcraftedURL", "rewcraftedUr", "rewwrittenUr", "rewrittenLocation", "RewrittenFile", "RewwrittenURL", "rewardedInt", "rewmatchedUrl", "rewrittenJar", "RewrittenText", "rerittenFile", "rewrapedUr", "rewrittenServer", "rewatchedServer", "RewwrittenJar", "rewardedLocation", "rewwrittenLanguage", "rewedFile", "RewrittenInt", "rewrittenFile", "rewedURL", "rewwrittenFile", "rewardedUrl", "RewrittenUr", "rewrittenUr", "rewriteServer", "rewatchedText", "rewrittenText", "RewwrittenInt", "rewodedLanguage", "RewwrittenLocation", "rewwrittenJar", "RewrittenUrl", "rewilledInt", "rewmatchedurl", "Rewrittenurl", "rewilledURL", "RewwrittenFile", "rewwrittenurl", "rewriteURL", "rerittenUr", "rewcraftedUrl", "rerittenURL", "RewrittenLocation", "rewwrittenUrl", "rewrittenURL", "rewrittenurl", "rewwrittenLocation", "rewrapedUrl", "rewrittenLanguage", "rewodedURL", "rewwrittenInt", "RewwrittenUr", "rewedUrl", "rewwrittenText", "rewriteUrl"], "httpURLConnection": ["httpSSLConn", " httpURConnect", " httpStreamCurrent", "webURLConnection", "HttpURLConnection", " httpUrlConn", " httpURLConn", "httpURIconnection", "httpWebConnection", "webSSLConnection", "httpURLContext", "httpURLConn", "httpWebConnect", "httpELConn", "httpURLService", " httpURLConnect", " httpURConn", "httpURLconnection", "httpURLClient", "webURLClient", "httpGEconnection", "httpURIConnection", " httpStreamConnection", "httpPathconnection", "httpGEConnect", "httpurlSession", " httpURLSession", "httpWebConn", "httpUrlconnection", "httpCLConn", "httpURLCode", "httpUrlConnection", "httpURConn", "httpELConnection", "httpURIConn", "httpChannelConnection", "apacheURLconnection", "httpURconnection", "httpUrlContext", "HttpURLService", "httpStreamconnection", "httpUrlConnect", "httpurlConnection", "webURLConn", "httpChannelConnect", "httpURLSession", "httpPathSession", "httpURConnection", "httpStreamConnection", "httpELConnect", "apacheGEConnect", " httpURLCurrent", "httpurlCurrent", "httpSSLClient", "webSSLConn", " httpURConnection", " httpStreamconnection", " httpURLconnection", "httpChannelconnection", "HttpURLconnection", "httpURIFlow", "webSSLClient", "httpURIContext", "httpPathCurrent", "apacheGEconnection", "httpStreamCurrent", "httpGEFlow", " httpStreamSession", "httpURLFlow", "httpCLCode", "apacheGEFlow", " httpURLCode", "httpurlConnect", "httpurlFlow", "apacheGEConnection", "webSSLContext", "httpGEConnection", " httpUrlCode", "apacheURLConnect", "HttpChannelConnection", "httpUrlService", "httpurlConn", "httpurlCode", "apacheURLFlow", "httpSSLContext", "httpURLCurrent", "httpUrlConn", "httpurlconnection", "httpURConnect", "httpURIClient", "httpUrlClient", "httpURService", "HttpChannelService", "httpPathConnection", "httpURIConnect", "httpSSLConnection", "webURLContext", " httpUrlConnection", "HttpURLConnect", "httpUrlCode", "httpCLConnection", "HttpChannelConnect", "HttpChannelconnection", "httpStreamSession", "httpChannelService", "httpURLConnect", "apacheURLConnection"], "header": ["hash", "feature", "pair", "result", "item", "master", "error", "column", "token", "ter", "metadata", "after", "cover", "default", "function", "index", "er", "string", "bridge", "driver", "queue", "section", "next", "character", "layer", "event", "component", "writer", "info", "reference", "definition", "player", "head", "rule", "handler", "Header", "back", "list", "block", "headers", "outer", "buffer", "message", "iter", "version", "date", "her", "attribute", "key", "document", "dr", "line", "consumer", "entry", "filter", "server", "channel", "data", "match", "member", "director", "field", "second", "group", "part", "comment", "author"], "value": ["v", "sv", "description", "now", "current", "valid", "child", "Value", "model", "default", "function", "val", "label", "string", "name", "values", "end", "language", "set", "expression", "format", "type", "VALUE", "info", "element", "object", "text", "parent", "hello", "message", "office", "media", "version", "option", "property", "attribute", "key", "content", "V", "gi", "get", "document", "entry", "data", "server", "letter", "password", "variable", "field", "json", "comment", "item"], "inputStream": ["pullStreamer", "pullSteam", "inputSteam", "outputStreamer", "pullStream", "resourcestream", "InputChannel", "resourceSteam", "outputChannel", "resourceStream", "resourceChannel", "outputSteam", "InputStreamer", "Inputstream", "outputstream", "InputSteam", "inputstream", "inputChannel", "inputStreamer", "pullstream", "InputStream"], "outputStream": ["OutputFile", " outputSteam", "inputSteam", "outputStreamer", "OutputChannel", "OutputSteam", "externalStream", "outputChannel", "OutputStream", "externalstream", "externalSteam", "responseSteam", "outputSteam", "OutputStreamer", "responseStream", "outputstream", "responseChannel", "externalStreamer", "Outputstream", "responseFile", " outputChannel", " outputFile", "inputstream", "inputStreamer", "outputFile"]}}
{"id1": "481364", "id2": "8667872", "code1": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"downloadFiles": ["processItems", "DownloadFiles", "processFiles", "uploadFile", "DownloadImages", "DownloadFile", "downloadFile", "downloadImages", "processFile", "uploadImages", "DownloadItems", "downloadItems", "uploadItems", "processImages", "uploadFiles"], "downloadFilesWorker": ["downloadFilesWER", "downloadPhotosWorkers", "downloadFilesLinker", "downloadPhotosPooller", "downloadFilesLinkers", "downloadFilesWorkER", "downloadFilesWorkers", "downloadFilesLinkER", "downloadFilesPoolers", "downloadFilesPooler", "downloadFilesPoolER", "downloadFilesWer", "downloadPhotosWorkER", "downloadPhotosPooler", "downloadFilesWler", "downloadFilesPooller", "downloadFilesWers", "downloadPhotosPoolers", "downloadPhotosWorkler", "downloadPhotosWorker", "downloadFilesLinkler", "downloadFilesWorkler", "downloadPhotosPoolER"], "startDownloadDate": ["startFileData", "startFileMark", " startDownloadData", " startDownloadDay", "startPullMark", "startUploadDay", "startFileDate", "StartDownloadDate", " startDownloadStatus", "startUploadStatus", "StartReviewYear", "startInstallDay", "StartReviewDate", "StartDownloadData", "startInstallStatus", "startImportDay", " startUploadDate", "startImportStatus", "startInstallDate", "startDownloadData", " startUploadStatus", " startUploadDay", "startReviewYear", "StartDownloadYear", "startDownloadMark", "startDownloadYear", "startInstallTime", "startUploadMark", "startPullDate", "startReviewTime", "startUploadData", " startUploadMark", "startDownloadDay", "startUploadTime", "startDownloadTime", "startReviewData", " startDownloadMark", "startDownloadStatus", "startUploadYear", "startUploadDate", " startDownloadTime", "startInstallYear", "startInstallData", "StartReviewData", "StartDownloadTime", "startPullTime", "startFileTime", " startUploadData", "startPullData", "startImportTime", "startImportDate", "startReviewDate", " startUploadTime", "StartReviewTime"], "refreshSpeed": ["refetchScore", "refractionSpeed", "refetchSpeed", "defreshScore", "defreshStep", "defreshStyle", "refetchStyle", "refetchStep", "refractionScore", "defractionStyle", "defractionScore", "defractionSpeed", "refractionStep", "defractionStep", "refractionStyle", "defreshSpeed", "refillStyle", "refreshStyle", "refreshScore", "refillSpeed", "refreshStep", "refillScore", "refillStep"], "lastDate": ["LastData", "LastTime", "firstData", "lastData", "firstDate", "LastDate", " lastDay", "lastDay", "LastDay", "lastTime", " lastTime", " lastData", "firstTime", "firstDay"], "totalSizeRead": ["totalStringRead", "totalUrlRead", "totalNameWritten", "totalSizeEx", "totalSizeReader", " totalSizeREAD", "totalsizeWritten", "totalTimeRead", "TotalSizeEx", "totalSectionRead", "totalSectionReader", "totalSectionREAD", "totalsizeEx", "totalSizeNeed", "totalNumberWritten", " totalSizeReader", " totalNumberReader", "totalNumberEx", "totalNumberNeed", "TotalNumberWritten", " totalNumberWritten", "totalNameRead", "totalSectionWritten", " totalNumberREAD", "totalsizeRead", "totalUrlREAD", "totalSizeREAD", "totalStringNeed", "totalStringWritten", "totalNumberReader", "TotalNumberRead", "totalUrlReader", "TotalNumberEx", "totalUrlWritten", "TotalSizeWritten", " totalSizeWritten", "TotalSizeNeed", "totalNumberREAD", "totalNameNeed", "totalSizeWritten", "TotalNumberNeed", "TotalSizeRead", "totalTimeWritten", "totalTimeEx"], "totalNumberRead": ["totalStringRead", "totalNumberWrite", "totalnumberFound", "totalNumFound", " totalNumberFound", "totalLengthWritten", "totalAmountWritten", "totalnumberRead", "totalNumberread", "totalnumberread", "totalLengthRead", " totalSizeWrite", "totalNumRead", " totalnumberFound", " totalnumberWritten", "totalNumberWritten", "totalLengthWrite", "totalSizeread", "totalNumread", " totalSizeread", "totalAmountWrite", "totalnumberWritten", " totalNumberread", " totalNumberWritten", "totalNumWritten", "totalSizeFound", "totalStringWritten", " totalNumberWrite", "totalStringread", " totalSizeWritten", "totalAmountRead", " totalnumberread", "totalLengthread", "totalSizeWrite", "totalSizeWritten", "totalNumberFound", "totalAmountread", " totalnumberRead"], "photo": ["camera", "picture", "jp", "photos", "result", "audio", "voice", "job", "project", "jpg", "login", "Photo", "phone", "pixel", "lo", "cover", "opus", "student", "filename", "ickr", " photograph", "language", "profile", "obj", "room", " Photo", "image", "friend", "sharing", "facebook", "widget", "large", "Photos", "journal", "layer", "username", "vision", "info", "trial", "avi", "video", "phot", "favorite", "slice", "gal", "license", "media", "api", "album", "person", "la", "pin", " photographer", " photography", "copy", "document", "single", "page", "pic", "data", "l", "entry", "Flickr", "member", "instance", "gallery", " photos", "collection", "json", "record", "item", "opa"], "url": ["address", "position", "client", "system", "URL", "path", "sl", "Url", "host", "location", "conn", "string", "out", "name", "stream", "contact", "image", "link", "org", "ssl", "user", "www", "config", "loc", "socket", "uri", "resource", "api", "document", "http", "l", "page", "source", "file", "channel", "server", "download", "open", "web", "response"], "connection": ["bc", "position", "client", "reader", "connected", "uno", "which", "io", "URL", "function", "connect", "session", "conn", "out", "context", "stream", "image", "c", "database", "or", "communication", "info", "Connection", "directory", "application", "body", "handler", "loc", "socket", "uri", "api", "document", "http", "l", "in", "channel", "server", "director", "con", "web", "control", "response"], "dis": ["de", "pro", "reader", "mor", "DIS", "re", "dl", "pre", "io", "ws", "res", "conn", "out", "ui", "det", "to", "no", "Dis", " Dis", "normal", "lib", "or", "info", "des", "body", "rec", "loc", "fr", "service", "api", "resource", "non", "http", "di", "data", "channel", "file", "se", "dir", "dist", "pos", "device", "coll", "con", "serv", "web"], "fos": ["Fou", "FOS", "phos", " fis", "fOS", "fou", "Fops", "bis", "Foses", " faos", " foses", "Fos", "phaos", "Fis", "fose", " fops", "bos", "phou", "boses", "bops", "fis", "phOS", "paos", "bose", " fose", "pOS", "Fose", "fops", "foses", "pos", "faos", "Faos", "baos", "pou"], "b": ["v", "base", "xb", "job", "bit", "bb", "gb", "ob", "bin", "br", "e", "nb", "emb", "db", "boot", "ba", "mb", "binary", "c", "bl", "buff", "sb", "r", "batch", "lb", "bar", "n", "wb", "buffer", "ab", "eb", "p", "bytes", "rb", "l", "pb", "B", "bf", "f", "split", "cb", "bs", "be"], "sizeRead": ["lengthReader", " sizeWalk", "SizeWalk", " sizeIn", " sizeWrite", "lengthFind", "lengthLoad", "externalReader", "SizeFind", "SizeIn", "nowRead", "sizeLoad", "externalWrite", "scaleRead", "sizeWalk", "stringReader", "sizeUse", " sizeUse", "nowLoad", "nowReader", "externalRead", "izeRead", "stringRead", "sizeFind", "izePass", "sizePass", " sizeReader", "lengthPass", " sizePass", "izeUse", " sizeLoad", "scaleFind", "izeReader", "SizeRead", "sizeWrite", "stringWrite", "scaleWalk", " sizeFind", "SizeUse", "sizeIn", "stringFind", "sizeReader", "externalFind", "nowFind", "izeIn", "lengthRead"], "totalDiffTime": ["totalDiffSpeed", "partialDiffTime", "totaldiffTimes", "totalDeltaRate", "finalDiffSpeed", "partialDiffSize", "finalDiffTime", "finaldiffSpeed", "totalChangeTimes", "totalDistTime", "totaldiffSize", "totalChangeTime", "totalDistSpeed", "finaldiffCount", "totalDiffSize", "totalDeltaSpeed", "totaldiffCount", "totalDeltaTime", "partialDiffTimes", "finaldiffRate", "finalDiffRate", "totalDiffTimes", "totaldiffTime", "finalDiffCount", "totalChangeSize", "totaldiffRate", "finaldiffTime", "totalDeltaCount", "totalDiffCount", "totalDiffRate", "totalDistRate", "totaldiffSpeed", "totalDistCount"], "totalSpeed": ["completeSpeed", "totalRate", "TotalDiff", "tTime", "Totalspeed", "TotalAverage", "TotalRate", "TotalSpeed", "validDiff", "completeAverage", "totalDiff", "totalTime", "completeRate", "TotalTime", "tspeed", " totalRate", " totalspeed", "validRate", "completeDiff", "tRate", "totalspeed", " totalTime", "totalAverage", "tSpeed", "validAverage", "validSpeed"], "list": ["complete", "test", "result", "cl", "cont", "st", "status", "view", "left", "lp", "load", "not", "fl", "lists", "ls", "li", "queue", "set", "bl", "code", "all", "LIST", "live", "type", "batch", "object", "see", "best", "slice", "layout", "table", "ul", "array", "la", "p", "detail", "stack", "l", "page", "source", "pool", "low", "entry", "cli", "coll", "gallery", "full", "collection", "part", "record"]}}
{"id1": "3558512", "id2": "20375440", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"serialize": ["Serialze", "finalze", "Serialize", " serialze", "erialize", "Serialized", "erialze", "Serialization", "Serialify", "serialze", " serialization", "serializable", "erialization", "normalify", "normalized", "finalize", "normalze", "serialify", "finalized", "finalify", "erializable", "Serializable", "serialized", "serialization", "normalize", " serializable"], "out": ["exec", "OUT", "png", "outs", "cache", "client", "w", "gen", "output", "bin", "io", "raw", "filename", "name", "string", "obj", "conn", "archive", "image", "err", "Out", "writer", "i", "report", "a", "ex", "parent", "o", "loader", "buffer", "content", "copy", "page", "data", "pool", "file", "up", "source", "server", "dump", "temp"], "parser": ["test", "processor", "base", "master", "reader", "system", "cache", "builder", "parse", "php", "lp", "tt", "worker", "xml", "plugin", "arser", "er", "seed", "cp", "pkg", "upload", "writer", "pe", "Parser", "class", "parent", "handler", "pillar", "per", "loader", "p", "wrapper", "copy", "file", "up", "server", "instance", "rar", "pp", "ss", "as", "txt", "manager"], "on_disk": ["onJdemand", "onnetfile", "onnetspace", "off_space", "off_delete", "onbootlock", "on_lock", "onbookdelete", "off_lock", "on_file", "off_drive", "onjspace", "off_storage", "onbootdrive", "onJdrive", "onbootdisk", "on_drive", "onJlock", "onjdrive", "onJdisk", "onbootstorage", "off_demand", "onbookdrive", "off_disk", "onjfile", "onbookdisk", "on_storage", "onnetdemand", "onjdisk", "on_demand", "onnetdisk", "on_delete", "onnetdrive", "on_space", "off_file"], "in": ["ins", "thin", "din", "reader", "IN", "login", "bin", "inc", "ini", "input", "In", "conn", "inner", "stream", "c", "inas", "ax", "i", "connection", "info", "r", "again", "o", "socket", "win", "inn", "min", "pin", "copy", "data", "lin", "file", "source", "kin", "rin", "pass", "con", "ac", "as", "f"]}}
{"id1": "17791385", "id2": "6988216", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "src": ["url", "sit", "ipl", "st", "img", "ins", "sup", "sl", "input", "filename", "s", "ls", "stream", "obj", "image", "upload", "files", "sel", "sb", "b", "sin", "dest", "back", "config", "loc", "inst", "uri", "resource", "inf", "rb", "http", "rc", "source", "file", "sc", "dist", "txt"], "dst": ["fdst", "ddst", "Dlt", "ddest", "ddfd", "pdsp", "Dsts", "ddsp", "pdft", "ststs", "dft", "fdsp", "dlt", " dlt", "stdest", "Dst", "fdfd", "dsp", "ddft", "pdfd", "dfd", " ddest", "stst", "Ddest", "stlt", "dsts", "pdst", "fdft", " dsts"], "in": ["url", "gin", "ins", "din", "reader", "IN", "login", "bin", "id", "inc", "ini", "input", "In", "conn", "inner", "ln", "err", "oin", "m", "i", "r", "n", "again", "sin", "pull", "socket", "nin", "win", "inn", "pin", "h", "is", "cin", "lin", "data", "file", "init", "inside", "kin", "rin", "con", "impl", "as", "f"], "out": ["net", "exec", "OUT", "client", "outs", "cache", "w", "output", "bin", "exp", "io", "inc", "raw", "x", "conn", "s", "ext", "obj", "err", "off", "Out", "plain", "self", "at", "writer", "i", "ex", "n", "again", "parent", "o", "null", "sync", "post", "outer", "copy", "other", "line", "file", "up", "server", "part", "f", "temp"], "buf": ["vec", "uf", "v", "cap", "bc", "base", "uc", "bb", "bin", "br", "bd", "raw", "cur", "ctx", "val", "fb", "fl", "length", "seq", "cmd", "queue", "c", "off", "bl", "bag", "batch", "count", "b", "ff", "loc", "pad", "wb", "buffer", "bytes", "rb", "fd", "rc", "data", "bh", "bf", "lim", "cat", "cb", "buff"], "len": ["cap", "lc", "cl", "base", "bin", "el", "Len", "val", "sl", "fl", "length", "ind", "li", "fin", "name", "ln", "end", "no", "c", "err", "all", "en", "i", "count", "n", "ll", "nt", "ix", "fd", "lf", "line", "data", "l", "lin", "pos", "lt", "lim", "split", "part", "size", "f", "le", "rev"]}}
{"id1": "4468255", "id2": "20619879", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["share", "save", "delete", "parse", "paste", "rm", "transfer", "zip", "Copy", "load", "put", "replace", "log", "cp", "write", "link", " cp", "info", "cop", "ignore", "sync", "update", "clip", "get", "process", "move", "file", "download", "create", "dump", "split", "cat", "ssh", "clone", "opy"], "from": ["url", "base", "client", "vol", "left", "e", "id", "zip", "io", "old", "path", "one", " form", "of", "log", "er", "start", "name", "context", "string", "stream", "original", "range", "c", "missing", "this", "link", "os", "normal", "code", " the", "or", "at", "connection", "html", "user", "ce", "parent", "empty", "so", "o", "with", "back", "config", "without", "the", "resource", "add", "by", "form", "http", "ate", "source", "data", "file", "before", "dir", "entry", "From", "se", " file", "part", "open", "f"], "to": ["disk", "eto", "cache", "son", "one", "path", "name", "comp", "os", "null", "front", "flo", "p", "jo", "too", "data", "file", "process", "sp", "as", "size", "client", "stat", "token", "db", "x", "TO", "target", "on", "termin", "yet", "database", "or", "tom", "pe", "user", "To", "so", "o", "back", "dis", "by", "http", "template", "two", "de", "base", "system", "io", "not", "but", "auto", "top", "no", "toc", "all", "t", "parent", "socket", "office", "resource", "me", "source", "dir", "temp", "output", "site", "load", "storage", "connection", "root", "sync", "plus", "line", "se", "tto", "about", "po"], "result": ["ure", "test", "url", "error", "ver", "cache", "status", "follow", "allow", "found", "use", "comment", "br", "current", "valid", "force", "sign", "term", "replace", "cur", "Result", "arr", "default", "function", "val", "mask", "res", "true", "length", "mer", "ret", "effect", "lock", "err", "success", "results", "compl", "card", "event", "info", "r", "method", "count", "report", "future", "diff", "ok", "var", "date", "plus", "search", "math", "rc", "continue", "match", "work", "data", "source", "accept", "up", "ult", "entry", "member", "pass", "die", "fail", "part", "sum"], "subFiles": ["subTokens", "newPages", "singfiles", "subParts", " subDir", "subFs", "Subfiles", " subParents", "newsFiles", " subPages", "newsParts", "newFile", "subPages", " subFile", "SubPages", "partFs", "newsfiles", "newParts", "singFs", "partFiles", "subContents", "ubFiles", "subFile", "partParents", "ubPages", "singFiles", " subFs", "newfiles", "subfiles", "SubContents", "subParents", "subDir", "SubParts", "ubContents", "ubDir", "ubfiles", "ubFile", " subTokens", "newsTokens", " subParts", "SubFiles", " subfiles", "singParents", "newFiles", "partfiles", "SubTokens", "SubFile", " subContents"], "i": ["v", "k", "iv", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "q", "name", "li", "u", "ui", "hi", "s", "inner", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "j", "ori", "ie", "a", "b", "n", "o", "bi", "slice", "ri", "uri", "p", "key", "it", "h", "ix", "is", "gi", "di", "oi", "l", "d", "f", "pi"], "newDir": ["nowDIR", " newD", "subQu", "NewJar", "newJar", "NewFolder", "newFile", " newDirectory", " newFolder", "oldDIR", "NewDir", "NewDirectory", "newDirectory", " newJar", "nextQu", " newDIR", "nowDirectory", "subFile", "NewFile", "subFolder", " newFile", "nextFolder", "subDirectory", "subD", "oldFolder", "subDir", "nextDirectory", "oldDir", "oldFile", "nowDir", "newDIR", "newFolder", "nextDir", "oldDirectory", "nextFile", "subJar", "nowFolder", "newQu", "newD", " newQu", "NewD"], "in": ["url", "gin", "ins", "thin", "reader", "din", "IN", "login", "re", "bin", "e", "id", "isin", "inc", "ini", "index", "input", "In", "conn", "on", "inner", "lock", "c", "image", "this", "err", "m", "a", "r", "ie", "b", "ex", "again", "o", "pull", "socket", "diff", "nin", "win", "inn", "min", "pin", "it", "is", "l", "lin", "data", "file", "up", "init", "cin", "source", "con", "part", "serv", "f"], "out": ["net", "exec", "serv", "base", "img", "OUT", "client", "outs", "cy", "w", "call", "output", "bin", "exp", "io", "ou", "inc", "one", "log", "conn", "ext", "name", "inner", "obj", "word", "on", "write", "err", "off", "c", "lock", "Out", "lib", "all", "at", "writer", "b", "ex", "n", "again", "o", "with", "co", "sync", "socket", "post", "line", "op", "file", "up", "ch", "cat", "sum", "can"], "fileLength": ["lineName", "Filelength", " fileSize", "linelength", "pageLength", "pagelength", " fileLen", "lineSize", "pageName", "baseLen", "lineLength", "FileLength", " fileName", "filelength", "fileLen", " filelength", "pageSize", "baseLength", "baseSize", "FileSize", "baselength", "fileSize", "fileName", "FileLen"], "charBuff": ["stringBuff", "charBuffer", "pairBuff", "pairMatrix", "charMatrix", "stringBuffer", "stringMatrix", " charMatrix", " charBuffer", "pairBuffer"], "len": ["lit", "bin", "id", "Len", "val", "fl", "start", "name", "li", "fin", "ln", " pos", "en", "n", "nt", "iter", "lf", "l", "line", "pos", "ni", " split", "split", "part", " Len", "cmp", "rev"], "oneChar": ["singlechar", "singleCor", " oneCar", "singleCharacter", "oneCor", "nextCor", "eachCharacter", "fourchar", "eachchar", " oneCh", "onechar", "nextCar", "singleCh", "fourChar", "singleCar", " oneCharacter", "zeroChar", "singleChar", "oneCh", " onechar", " oneCor", "zerochar", "eachChar", "eachCor", "fourCharacter", "zeroCharacter", "nextChar", "oneCar", "fourCor", "oneCharacter", "nextCh", "zeroCor"]}}
{"id1": "149935", "id2": "4716110", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"convert": ["CONception", " deconversion", "Converted", "oconversion", "subversion", "CONverted", "unception", "subverting", "CONvert", "subverted", "unvert", "unverted", "Conception", "CONverting", " deconverting", "oconverted", "Conversion", "Converting", "CONversion", "oconvert", " deconverted", "conception", "converting", "subvert", "oconverting", "Convert", "conversion", "converted", "unversion", " deconvert"], "src": ["sys", "ource", "fp", "url", "sit", "prot", "st", "img", "reader", "gb", "tmp", "load", "cb", "proc", "scene", "path", "input", "filename", "string", "name", "obj", "s", "stream", "secure", "sth", "Source", "spec", "upload", "storage", "sel", "code", "username", "SourceFile", "ssl", "sb", "component", "Dest", "supp", "buf", "video", "sin", "attr", "back", "config", "loc", "slice", "inst", "sn", "uri", "resource", "rb", "feat", "rc", "href", "source", "fn", "sc", "file", "download", "ref", "RC", "gz", "dist", "req", "stage", "impl", "cpp", "rl", "ctx", "cmp"], "dest": ["disk", "test", "cont", "img", "bin", "tmp", "path", "target", "obj", "lib", "std", " dst", "Dest", "class", "dat", "orig", "null", "dc", "di", "source", "fn", "dir", "dist", " destination", "home", "txt", "temp"], "in": ["ins", "din", "reader", "IN", "login", "bin", "isin", "inc", "io", "ini", "val", "input", "In", "stream", "err", "doc", "inas", "t", "a", "i", "r", "ex", "n", "ps", "win", "inn", "inf", "pin", "is", "data", "source", "up", "file", "d", "pass", "as", "f"], "p": ["fp", "jp", "v", "pa", "tp", "bp", "e", "lp", "pre", "pm", "P", "py", "pr", "s", "cp", "c", "np", "m", "t", "j", "i", "r", "pe", "g", "b", "cop", "o", "ps", "per", "parser", "pd", "pg", "h", "wp", "l", "op", "pb", "d", "pc", "pp", "sp", "part", "f", "pi", "po"], "ds": ["posts", " DS", "eps", "dp", "ths", "vs", "els", "os", " ps", "dat", "ps", " sd", "pd", "uds", "data", "qs", "utils", "points", "rs", "services", "da", "groups", "db", "docs", "s", "ls", "hs", "words", "ys", "models", "cs", "ans", "di", "ld", "cons", "gs", "ins", "xs", "ges", "ts", "nas", "ks", "sts", "ded", "lines", "vals", "js", "ups", "plugins", "dates", "ants", "dds", "ss", "scripts", "tests", "ils", "ads", "sys", "Ds", "ays", "dl", "lp", "tools", "df", "ns", "styles", "dd", "gd", "des", "dos", "sync", " props", "dc", "parts", "dt", "obs", "dist", "amps", "d", "DS", "icks", "dm", "ipes", "bs"], "format": ["template", "atter", "url", "fp", "magic", "model", "path", "function", "plugin", "host", "pattern", "filename", "string", "nat", "language", "struct", "name", "prefix", "spec", "t", "type", "at", "Format", "class", "tag", "handler", "config", "layout", "sche", "table", "parser", "api", "version", "scale", "form", "feat", "fd", "data", "source", "file", "filter", "letter", "ant", "fn", "style", "act", "frame", "unit", "part", "record", "f"], "hasPixelData": ["hasByteData", "showsPixelDATA", "hasPictureSize", "haspixelSize", " hasPixelSize", " hasPixeldata", "showsByteData", "showsByteStyle", "showsBytedata", "showsPixeldata", "hasPixelSize", "hasPicturedata", "showsPixelStyle", "hasByteSize", "hasPixelDATA", "hasPictureData", "hasPixeldata", "hasByteStyle", "haspixelData", "showsByteDATA", "haspixeldata", "hasPixelStyle", "hasBytedata", "showsPixelData", "hasByteDATA"], "inflate": ["inflace", "invenATE", "Inflation", "inFlate", "inflating", "infolode", "insvenate", "inFlation", "insvenATE", "invenode", "insvenating", "inflated", "Inflated", "inadequode", "inadequate", "inffation", "invenate", "insflate", "inflATE", "Inflate", "infloated", "inFlated", "infface", "InFlate", "insflATE", "Inflace", "InFlace", "inadequATE", "insflating", "inFlace", "infloate", "InFlation", "infloation", "insvenode", "inflode", "infolATE", "infloace", "inffate", "infolate", "inflation", "invenating", "inadequating", "InFlated", "insflode", "infolating", "inffated"], "pxlen": ["mxlen", "pxsize", "mxdata", "fxlen", "pgLen", "mxcount", "pgl", "fxden", "pxdata", "fxl", "axlon", "pxl", "pxlength", "pxlon", "pnglength", "xpsize", "pplen", "mxsize", "txlon", "axln", "pclin", "camlen", "pxLen", "camdata", "fxLen", "pxden", "pglen", "pxcount", "pxpos", "fxpos", "pclen", "txlen", "pxln", "pxlin", "campos", "txln", "fxdata", "pclon", "camln", "txlin", "xplen", "xplength", "fxln", "axlin", "ppden", "mxlength", "ppl", "pgden", "pnglen", "ppLen", "pngsize", "mxpos", "pngcount", "axlen", "xpcount", "mxln", "pcln"], "out": ["sys", "v", "error", "OUT", "outs", "cache", "gen", "re", "output", "io", "log", "session", "conn", "obj", "state", "lock", "err", "Out", "step", "lib", "user", "again", "parent", "co", "query", "list", "pad", "post", "copy", "point", "store", "cli", "line", "work", "up", "server", "page", "dump", "group", "inter"]}}
{"id1": "3252116", "id2": "5682569", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getMD5": ["getMAC3", "getMP4", "getMP3", "getSHA4", " getSHA4", "getMAC5", "getSHA3", "getMD4", "getMAC4", "getSHA5", "getMP512", "getSHA512", "getMP5", " getSHA5", " getMD3", " getMD4", "getMD3", "getMD512", " getSHA512", " getMD512", "getMAC512", " getSHA3"], "source": ["ource", "fp", "url", "result", "base", "output", "e", "security", "sl", "input", "target", "string", "stream", "Source", "this", "code", "connection", "text", "object", "parent", "body", "dest", "config", "slice", "buffer", "uri", "service", "resource", "content", "from", "document", "data", "file", "password", "secret", "src", "sp", "f", "SOURCE"], "s": ["services", "ins", "e", "sets", "ts", "rs", "series", "bis", "ws", "sl", "es", "ns", "string", "ls", "results", "si", "als", "ses", "os", "sg", "strings", "m", "t", "ssl", "sb", "r", "g", "b", "js", "n", "rows", "ops", "ps", "sym", "S", "ends", "ds", "fs", "p", "bytes", "h", "its", "is", "d", "ss", "f", "gs", "ings"], "hexDigits": ["hexDigats", "hashDigists", "hexSignists", "hexDigites", "hexFormists", "hexDigists", "hexDigit", "hexdigists", "hashFormits", "hexdigites", "hexSignases", "tempSignites", "hexdigases", "hexdigats", "hexSignites", "hexSignals", " hexDigit", "hashDigits", "hexSignits", "hashDigats", "hexdigits", "hexEdists", "hexFormats", "hexdigings", "hexDigals", "hexEdites", "hexFormitives", "tempDigits", "tempSignists", "tempDigals", "tempDigists", " hexDigases", "hexDigases", "hexdigit", "hashFormists", "tempSignals", "hexSignitives", "hashDigitives", "hexEdits", "hexDigings", "hexFormits", "hexDigitives", "hashFormitives", "hashFormats", "hexEdals", "hexSignings", "tempDigites", "hexSignit", "hexdigals", "hexSignats", "tempSignits", " hexDigings", "hexdigitives"], "md": ["mad", "MD", "cm", "mc", "sha", "dig", "metadata", "rm", "pm", "bd", "amd", "am", "df", "um", "meta", "mb", "mt", "cmd", "hd", "sm", "mi", "rpm", "mand", "m", "dd", "mg", "mm", "ma", "mail", "pd", "cd", "dc", "em", "wd", "mac", "di", "mag", "bf", "nm", "dm", "vd", "f", "mu", " MD", "mp"], "tmp": ["v", "test", "stuff", "base", "params", "img", "sup", "now", "bp", "app", "pre", "proc", "meta", "ppo", "fb", "pointer", "seed", "obj", "np", "storage", "extra", " temp", "buf", "dest", "bt", "config", "pad", "buffer", "array", "api", "p", "rb", "wp", "data", "append", "pp", "area", "sp", "cpp", "txt", "cb", "buff", "mp", "cmp", "temp"], "str": ["exec", "v", "st", "dec", "sr", "br", "exp", "dict", "arr", "sec", "cur", "div", "sl", "string", "obj", "hr", "inner", "cr", " sp", "err", "spec", "doc", "hex", "code", "Str", "j", "r", "ctr", "text", "cs", "tr", "STR", "enc", "fr", "iter", " substr", "dr", "stri", "txt", "data", "char", "style", "pos", "sp", "unit", "ss", "part", "pr", "temp"], "k": ["v", "kid", "dk", "w", "e", "id", "kick", "x", "kw", "ks", "q", "mk", "ku", "u", "ak", "K", "c", "kk", "unk", "y", "j", "sk", "g", "b", "n", "o", "ki", "ek", "ok", "p", "key", "ck", "work", "ch", "kat", "d", "ko", "f"], "i": ["qi", "v", "z", "ip", "ai", "ti", "I", "e", "io", "iu", "xi", "x", "ini", "index", "u", "ui", "li", "hi", "multi", "c", "ci", "si", "phi", "ii", "y", "m", "j", "t", "a", "info", "b", "n", "bi", "ri", "uri", "p", "gi", "it", "abi", "in", "oi", "di", "l", "shift", "d", "chi", "ji", "mu", "f", "pi"], "byte0": ["word0", "byte2", "number6", "word5", "letter2", "pixel5", " byte6", "byte5", "byte1", "byte6", "letter00", "number1", "byte00", "pixel0", "bytek", "pixel00", "pixelk", " byte2", "word1", "number00", " byte1", "number0", "pixel6", "pixel2", "letterk", "numberk", "number2", "word2", " byte5", "number5", "letter0", " byte00"]}}
{"id1": "6421904", "id2": "88047", "code1": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"addRecord": [" addRec", "createRecord", "createFile", "addRec", " addFile", "createrecord", "appendRecord", " addrecord", "appendRec", "createRec", "appendFile", "addrecord", "appendrecord", "addFile"], "input": ["exec", "flow", "error", "reader", "audio", "php", "current", "load", "raw", "progress", "Input", "xml", "request", "session", "out", "conn", "context", "stream", "image", "this", "storage", "hole", "active", "null", "text", "back", "config", "buffer", "media", "resource", "inf", "form", "document", "http", "data", "source", "up", "instance", "value", "temp"], "temporary": ["temmanent", "transporary", "typoral", "Temperature", "Temmanent", "emporal", "theemporary", "emporary", "separporal", "temperature", "mporary", "typerature", "transperature", "timemporary", "Temporal", "separperature", "transolute", "semporary", "semporal", "thetemp", "timermanent", "tempporary", "tmporary", "temermanent", "exporal", "temolute", "formtemp", "timperature", "tempemporary", "tmperature", "tememporary", "destporal", "mporal", "temacher", "experature", "tporal", "tmemporary", "theermanent", "temptemp", "formmanent", "mperature", "theporal", "emperature", "exolute", "semperature", "tempperature", "tporary", "tytemp", "timporal", "temporal", "tmacher", "destemporary", "tomporal", "Temporary", "tommanent", "temtemp", "timolute", "tempporal", "timporary", "Temtemp", "semmanent", "formporal", "formporary", "separporary", "tymanent", "tacher", "tmtemp", "tmermanent", "theporary", "destporary", "theperature", "tmporal", "typorary", "tomporary", "transporal", "exporary", "destacher", "tomperature", "separmanent"], "tempId": ["tmpID", "tmpId", " tempid", "tmpPath", "TempPath", "inputId", "inputid", "TempId", "fakeid", "TempID", "tempid", "inputID", "fakeId", "tempID", "inputPath", "Tempid", "TempName", "poraryId", "tempName", "fakeName", "tempPath", "tmpid", " tempName", "poraryid"], "length": ["position", "url", "result", "audio", "description", "ob", "id", "load", "volume", "path", "total", "distance", "filename", "string", "sequence", "time", "name", "driver", "range", "angle", "lock", "section", "len", "write", "code", "read", "duration", "Length", "type", "count", "library", "shape", "number", "text", "offset", "slice", "loc", "array", "version", "key", "content", "l", "data", "width", "style", "download", "ext", "limit", "capacity", "value", "full", "json", "open", "size"], "digest": [" digested", "signEST", "fests", "digraph", "signest", "fester", " Digester", " digests", "generEST", " digraph", "digEST", "fest", " digester", "digester", " digEST", "decest", "digests", "signests", "DigEST", "digested", "Digester", "signester", "Digest", "decested", "digist", "signraph", "Digested", "generist", "Digist", "fraph", " DigEST", "generested", "decist", "signested", "generest", "decEST", " Digest"], "output": ["external", "address", "result", "console", "exit", "put", "log", "Output", "target", "export", "out", "binary", "queue", "image", "write", "tube", "plain", "operation", "writer", "connection", "application", "null", "object", "config", "socket", "outer", "message", "office", "resource", "copy", "document", "other", "data", "channel", "source", "letter", "unit", "web", "control", "response", "cut", "temp"], "file": ["FILE", "cache", "local", "e", "force", "id", "model", "path", "log", "filename", "name", "queue", "plain", "File", "show", "null", "directory", "message", "p", "document", "data", "letter", "server", "full", "f", "complete", "fp", "use", "feed", "child", "folder", "function", "string", "word", "lock", "fe", "or", "pe", "class", "user", "object", "rule", "buffer", "get", "http", "single", "l", "page", "pool", "let", "create", "open", "comment", "picture", "base", "place", "php", "zip", "current", "auto", "binary", "lib", "entity", "code", "per", "socket", "uri", "resource", "it", "source", "work", "dir", "home", "unit", "temp", "url", "view", "play", "time", "image", "ile", "this", "self", "type", "live", "connection", "real", "handler", "future", "other", "line", "up", "style", "po"], "parent": ["base", "master", "pa", "cache", "id", "port", "current", "child", "container", "path", "remote", " Parent", "parents", "out", "name", "location", "to", "image", "large", "or", "type", "root", "class", "null", "directory", "handler", "per", "block", "resource", "p", "key", "copy", "data", "source", "dir", "and", "create", "full", "Parent", "home", "part", "unit", "fat", "temp"], "now": ["first", " NOW", "gen", "view", "cycle", "id", "current", "load", "not", "cur", "always", "node", "start", "auto", "NOW", "max", "time", "next", "set", "this", "ci", "comp", "day", "or", "ct", "type", "info", "wait", "active", "today", "Now", "co", "ow", "currently", "post", "date", "once", "from", "age", "last", "low", "since", "night", "lim", "hour", "size", "cmp"]}}
{"id1": "19934218", "id2": "15465293", "code1": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"Usage:  URLDumper <URL> <file>\");\n            System.exit(1);\n        }\n        String location = args[0];\n        String file = args[1];\n        URL url = new URL(location);\n        FileOutputStream fos = new FileOutputStream(file);\n        byte[] bytes = new byte[4096];\n        InputStream is = url.openStream();\n        int read;\n        while ((read = is.read(bytes)) != -1) {\n            fos.write(bytes, 0, read);\n        }\n        is.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"doCrypt": [" runCrypt", "DoMac", " runMac", "murDec", "DoExt", "DoCrypt", " runDec", " doExt", "DoDec", " doDec", "murCrypt", " runExt", "murExt", " doMac", "murMac"], "text": ["url", " Text", "token", "str", "path", "font", "input", "pattern", "string", "name", "binary", "ext", "obj", "length", "context", "seed", "struct", "image", "hex", "this", "word", "code", "editor", "format", "crypt", "connection", "class", "object", "config", "buffer", "message", "EXT", "key", "content", "Text", "in", "data", "source", "letter", " TEXT", "password", "secret", "contract", "value", "txt", "TEXT"], "UnsupportedEncodingException": ["UnsupportedEncodingError", "UnsupportedEncasingError", "UnsupportedEncodingEx", "UnsupportedEncoderError", "UnsupportedEncasingEx", "UnsupportedEncodedError", "UnsupportedEncoderException", "UnsupportedEncoderEx", "UnsupportedEncasingException", "UnsupportedEncodedException", "UnsupportedEncodedEx"], "md": ["mad", "MD", "hash", "map", " Md", "mc", "sha", "ms", "metadata", "rm", "pm", "bd", "valid", "amd", "am", "bm", "df", "mo", "meta", "mb", "mt", "cmd", "hd", "code", "mand", "m", "dd", "mode", "method", "def", "Cmd", "gd", "body", "sd", "od", "mg", "mm", "message", "ad", "ma", "pd", "ud", "wd", "mac", "mn", "mod", "dr", "me", "mp", "data", "hm", "ld", "d", "mag", "bf", "vd", "dm", "nm", " MD", "dig"], "sha1hash": ["SHA2sum", "sha6sha", "sha256h", "md1hash", "sha2hex", "shaonehex", "md6h", "sha6hex", "SHA2sha", "SHA1hash", "SHA2Hash", "SHA2hex", "SHA1Hash", "sha1Hash", "sha256hash", "sha5sha", "sha2h", "sha5Hash", "SHA1sha", "sha5hash", "sha2sum", "md6sha", "sha1sha", "sha2hash", "md1hex", "sha6h", "sha0sha", "md6hex", "sha1sum", "sha6hash", "sha0sum", "SHA1sum", "md1h", "md6hash", "sha2Hash", "shaonehash", "md1sha", "SHA2hash", "sha256hex", "sha5hex", "shaonesha", "sha1hex", "sha0hex", "sha1h", "sha256sum", "shaoneh", "sha0hash", "SHA2h", "SHA1hex", "sha256sha", "SHA1h", "sha256Hash", "sha2sha", "sha5h"]}}
{"id1": "1421557", "id2": "21491791", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeFileToFiles", "encodeStringToFiles", "encodeFile2Stream", "encodeFiletoStream", "encodeFileFromFile", "encodeFileFromStream", "encodeFiletoFile", "encodeString2File", "encodeFiletoFiles", "encodeString2Files", "encodeFile2File", "encodeString2String", "encodeString2Stream", "encodeFileFromString", "encodeFileToString", "encodeFile2String", "encodeStringToString", "encodeFileToStream", "encodeFiletoString", "encodeStringToStream", "encodeFile2Files", "encodeStringToFile"], "infile": ["Infile", "infiles", "inputFile", "InFile", "inFile", "Infiles", "outFile", "inputfiles", "infilename", "outfilename", " infilename", "outfiles", "inputfp", "infp", " infiles", "inputfilename", " infp", "outfp", "Infilename", "inputfile"], "outfile": ["outputfilename", "newname", "Outname", "newFile", "outname", "infolder", "newfolder", " outname", "Outfolder", "outFile", "outfolder", " outfolder", "infilename", "outfilename", "outputfp", " outFile", "outputfile", " outfilename", " outfp", "newfile", "infp", "OutFile", "outputfolder", "Outfile", "outfp"], "in": ["gin", "base", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "vin", "ini", "input", "ic", "In", "s", "conn", "inner", "image", "err", "inas", "m", "a", "i", "r", "b", "again", "sin", "socket", "nin", "win", "inn", "min", "pin", "is", "into", "cin", "data", "source", "init", "inside", "rin", "pass", "ac", "con", "as"], "out": ["net", "exec", "base", "error", "OUT", "client", "outs", "cache", "job", "output", "bin", "ou", "io", "inc", "one", "session", "conn", "obj", "In", "inner", "on", "name", "to", "image", "err", "write", "off", "no", "Out", "lib", "or", "writer", "ex", "parent", "again", "o", "co", "socket", "sync", "post", "outer", "timeout", "point", "copy", "line", "source", "work", "file", "up", "home", "exit"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bb", "transfer", "feed", "raw", "fb", "input", "border", "length", "seed", "binary", "offset", "queue", "write", "len", "layer", "type", "reference", "batch", "count", "b", "null", "buf", "slice", "padding", "iter", "bytes", "wave", "flush", "data", "source", "server", "limit", "value", "split", "size", "buff"], "read": ["exec", " skip", " Read", "ip", "reader", "send", " copy", "parse", "lex", "allow", "use", "id", "feed", "io", "load", "inc", "raw", "current", "_", "check", "x", " count", "input", "connect", "start", "length", "ind", "play", "seek", "end", "write", "next", "len", "i", "count", "ride", "wait", "fill", "n", "find", "Read", "slice", "sync", "READ", "tell", " write", "ad", "iter", "close", "add", "get", "copy", "work", "sleep", "se", "limit", "reads", "pass", "reading", "size", "select", "f", "run"], "success": ["complete", "first", "result", "error", "cess", " succ", "fast", "status", "ccess", "growth", "follow", "flash", "primary", "right", "Success", "valid", "model", "func", "path", "default", " succeed", " Success", "true", "winner", "rolled", "results", "xx", "failed", "danger", " successful", "construct", "method", "null", "again", "ceed", "good", "message", "done", "rolling", "successfully", "respons", "content", "continue", "data", "warning", "successful", "pass", "roll", "initial", "better", "fail", "value", "open", "modified", "comment", "response"]}}
{"id1": "5676111", "id2": "23273706", "code1": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 0, "substitutes": {"get": ["exec", "output", " download", "export", "start", " extract", "end", " upload", "build", "info", "print", " it", " quit", "close", "it", "process", "let", "init", "download", " this", " exit", "open", "run"], "cnt": ["rcnt", "Cwd", "cnn", "fount", "cst", "Cnc", "cnd", " cnd", "rcnd", "Cst", "encNT", "Count", " count", "cwd", " cnc", "fwd", "cNT", " cst", "count", "encnn", " cnn", "rcNT", "fnt", "encnt", "CNT", "Cnn", "Cnt", " cNT", " cwd", "rcnc", "fNT", "encst", "Cnd", "cnc"], "url": ["client", "cache", "str", "bb", "URL", "git", "cur", "path", "log", "sl", "Url", "host", "session", "ir", "ls", "name", "image", "c", "org", "ssl", "connection", "r", "b", "ll", "www", "config", "loc", "socket", "ur", "uri", "resource", "bel", "http", "l", "page", "source", "file", "server", "channel", "download", "coll", "impl", "open", "web", "blog", "f"], "conn": ["exec", "cm", "client", "ai", "ann", "ca", "ob", "io", "not", "cur", "ctx", "connect", "oss", "out", "conv", "cp", "c", "ci", "err", "os", "org", "en", "ec", "ct", "connection", "ssl", "Connection", "n", "enc", "co", "loc", "socket", "dc", "api", "p", "http", "col", "cli", "ch", "server", "init", "cn", "act", "coll", "ens", "con", "nc", "Conn", "open", "cb"], "is": ["us", "im", "ais", "ip", "ai", "ib", "ois", "ob", "are", "isa", "iso", "io", "id", "IS", "bis", "ws", "Is", "es", "res", "ir", "s", "ui", "ris", "ci", "isl", "ios", "iss", "os", "or", "ssl", "ie", "i", "info", "lis", "loc", "isc", "isi", "ri", "uri", "iter", "api", "open", "close", "iris", "http", "in", "init", "src", "as", "bs", "il"], "filename": ["fp", "title", "login", "output", "fil", "family", "ename", "path", "folder", "utf", "nl", "nil", "location", "name", "string", "length", "queue", "size", "prefix", "files", "username", "format", "connection", "class", "directory", "loc", "uri", "key", "fd", "phrase", "l", "source", "fn", "file", "password", "ername", "sf", "Filename", "f", "il"], "fos": ["Fo", " foss", "gos", "fus", "fdo", "fdicks", " fis", "loses", "lo", "Fus", "Foses", "foss", "lios", "efose", "efos", "Fos", "Fis", " fo", "Foss", "fios", "fose", "go", "gios", "Fios", "fis", "Ficks", "fdos", " fus", "los", "goses", "fo", "ficks", " ficks", " fose", "efoss", "fdis", "Fose", "foses", "efus"], "buffer": ["Buffer", "position", "address", "result", "base", "header", "uffer", "reader", "cache", "bb", "output", "transfer", "pause", "feed", "vector", "fb", "border", "input", "length", "sequence", "binary", "offset", "seed", "memory", "queue", "read", "layer", "duration", "reference", "batch", "counter", "b", "shape", "buf", "null", "number", "padding", "iter", "bytes", "wave", "flush", "document", "phrase", "page", "data", "channel", "file", "source", "server", "limit", "size", "buff"]}}
{"id1": "6625074", "id2": "2936678", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"SHA1": ["SHAOne", "SHA256", "sha256", "SHA384", "HA1", " SHA384", "HA384", " SHAOne", "HA256", "shaOne", "sha1", " SHA256", "sha384", "HAOne"], "text": ["template", "test", " Text", "token", "str", "output", "transfer", "path", "font", "input", "pattern", "string", "name", "out", "obj", "context", "ext", "struct", "word", "image", "hex", "plain", "code", "editor", "format", "class", "object", "config", "message", "buffer", "bytes", "content", "translation", "Text", "in", "data", "letter", "source", "password", "contract", "value", "txt", "TEXT"], "sha1hash": ["ha1hex", "shaOnetext", "sha1cap", "ha2Hash", "shaOneHash", "sha2cap", "sha81cap", "sha81Hash", "sha256password", "sha1text", "sha256text", "sha2hex", "SHA1hash", "sha81log", "sha6cap", "SHA2Hash", "sha_hash", "sha_Hash", "sha6Hash", "SHA1Hash", "sha1Hash", "sha256hash", "sha2log", "SHA1log", "SHA1cap", "ha1sum", "SHA2cap", "ha2hex", "sha81hash", "sha2sum", "sha2hash", "sha_hex", "ha2hash", "SHA1password", "sha1sum", "ha1hash", "SHA1text", "sha6hash", "sha_sum", "sha1log", "shaOnepassword", "sha2Hash", "ha1Hash", "sha1password", "ha2sum", "SHA2hash", "SHA2log", "sha1hex", "shaOnehash", "sha6log", "sha256Hash"], "md": ["MD", "hash", "de", "cf", "mc", "sha", "ms", "dig", "gb", "metadata", "rm", "pm", "bd", "amd", "df", "mo", "meta", "um", "mb", "mt", "cmd", "hd", "pkg", "sm", "rpm", "editor", "m", "dd", " MD", "od", "mm", "ma", "ad", "pd", "cd", "wd", "nd", "mac", "hm", "ld", "d", "mag", "nm", "vd", "dm", "f", "mp"]}}
{"id1": "16590954", "id2": "20426057", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "label": 0, "substitutes": {"createJAR": ["createJPJar", "createAMARS", "createJJar", "createJAP", "createPHAP", " createJAP", "createPHAR", " createPHJar", "createAMJar", "createAMAR", " createPHAR", "createAMAP", "createJPARS", " createJARS", " createPHAP", "createJPAR", "createPHJar", " createJJar", "createPHARS", "createJPAP", "createJARS", " createPHARS"], "fileString": ["fileStr", "basestring", "lineName", "fileStream", "FileStr", " fileFile", "FileText", "baseString", " fileArray", "resourceString", "linestring", "fileText", "modelText", "modelStream", "loadstring", "FileName", "filestring", "loadName", "resourceStream", "fileArray", " fileStr", " fileName", "lineString", "loadText", "FileArray", "FileString", "resourceText", "baseFile", "Filestring", "lineArray", "FileFile", "modelString", "FileStream", "resourceStr", "baseStr", " filestring", " fileText", "loadString", "modelStr", "fileName", "fileFile"], "ext": ["external", "v", "url", "prot", "str", "dep", "app", "exp", "zip", "exe", "path", "x", "filename", "name", "end", "Ext", "ax", "code", "extra", "format", "type", "xt", "info", "class", "desc", "text", "ex", "enc", "config", "EXT", "version", "content", "data", "append", "dist", " Ext", "req", "txt"], "file": ["ger", "fp", "url", "test", "FILE", "base", "cache", "place", "change", "local", "output", "use", "force", "zip", "module", "model", "jar", "db", "path", "folder", "log", "flat", "filename", "name", "binary", "queue", "doc", "ile", "fe", "files", "build", "File", "pe", "class", "b", "bar", "parent", "per", "socket", "buffer", "resource", "wave", "it", "get", "h", "http", "single", "l", "page", "source", "work", "up", "line", "let", "full", "part", "unit", "f", "le"], "i": ["qi", "v", "ip", "ai", "mini", "I", "iu", "xi", "x", "ini", "index", "eni", "ind", "ui", "li", "hi", "uni", "ci", "multi", "c", "si", "mi", "phi", "ii", "j", "ori", "slice", "uri", "p", "key", "it", "abi", "di", "l", "ni", "limit", "yi", "f", "pi"], "dir": ["url", " directory", "base", "rel", "str", "output", "Dir", "id", "zip", "tmp", "jar", "cur", "db", "path", "folder", "div", "filename", "name", "string", "ir", "domain", "prefix", "doc", "pkg", "lib", "format", "type", "info", "class", "directory", "DIR", "config", "direction", "loc", "uri", "data", "dist", "src", "coll", "area", "manager", "module"], "jarFile": ["archiveDir", " jarLine", "archiveFile", " jarFiles", "archiveFolder", "tarFile", "jarF", "sessionSourceFile", " jarSourceFile", "javaFolder", "reportfile", "javaF", "javaSourceFile", "jarDir", "reportSourceFile", "jarSourceFile", "tarfile", "tarF", "tarLine", " jarfile", " jarFolder", " jarDir", "javafile", "javaFile", "reportFile", "javaDir", "sessionLine", "jarFolder", "jarfile", "archiveFiles", "jarFiles", "tarSourceFile", "javaFiles", "reportF", "sessionFile", "sessionfile", "jarLine"], "fstrm": ["fgrM", "fstum", " fsrum", " fsrm", "fsrM", "fsrum", "Fstrm", "Fstrmd", " fstrM", " fstrcm", "fstM", "fsrcm", "fstrmd", "fstrM", "Fsrm", "fstmd", " fstrum", "FstrM", "fbrcm", "fstcm", "fbrum", "Fsrcm", "fstrcm", " fsrcm", "fstrum", "Fstrcm", "fbrm", "fgrmd", " fsrM", "fstm", "Fsrmd", "fgrcm", "fsrmd", "fbrM", "FsrM", "fsrm", "fgrm"], "in": ["gin", "ins", "din", "reader", "IN", "login", "bin", "id", "io", "inc", "input", "In", "conn", "s", "stream", "inner", "binary", "to", "image", "c", "read", "m", "or", "r", "n", "again", "pull", "sync", "socket", "nin", "inn", "p", "min", "pin", "is", "into", "l", "up", "init", "inside", "rin", "ac", "part", "f"], "out": ["net", "flow", "v", "OUT", "client", "outs", "call", "output", "bin", "exp", "io", "inc", "outside", "conn", "inner", "to", "image", "c", "doc", "off", "err", "this", "Out", "plain", "self", "m", "all", "writer", "connection", "user", "b", "again", "null", "sync", "outer", "resource", "plus", "line", "source", "channel", "pool", "init", "up", "server", "group", "part"], "temp": ["template", "v", "test", " temporary", "emp", "base", "wrap", "cache", "clean", "w", " tmp", "local", "output", "tmp", "controller", " Temp", "zip", "db", "path", "folder", "input", "export", "archive", "doc", "c", "tem", "storage", "build", "porary", "or", "writer", "directory", "dest", "config", "pipe", "buffer", "iter", "api", "p", "it", "get", "form", "key", "store", "single", "source", "server", "Temp", "dump", "full", "home", "unit", "fake", "f", "Output"], "fstrm2": ["fstM1", "fstrmr002", "fstrmr1", "fhrm1", "fstrms2", "fstrmr2", "fhrms002", "fhrm02", "fstrM1", "fstm1", "fstrms02", "fstrp1", "fstrm0", "fhrms2", "fstrp0", "fstrM2", "fstrms1", "fstrM02", "fhrm002", "fstrm02", "fstrM0", "fstrms0", "fstrm1", "fstM0", "fstrms002", "fstm2", "fstm0", "fstM2", "fstrm002", "fstrp2", "fstrmr02", "fhrm2", "fhrms02", "fhrms1", "fstrM002"], "ostrm": ["ostrem", "obsrm", "otherrt", "oscrt", "obsrob", "obsrt", "oscmr", "oodrt", "odrm", "odm", "oodrem", "oscm", "istrt", "obrm", "ostrob", "ophrm", "othermr", "oodrob", "ooprm", "obmr", "oopmr", "istmr", "ophrt", "ooprom", "oscrm", "ostrt", "oodrm", "otherrm", "obrt", "istrm", "otherrom", "istrom", "ooprt", "odrt", "ostrom", "odmr", "ophm", "ostm", "ophmr", "obrom", "ostmr", "obsrem"], "docFile": ["docF", "DocF", "documentFile", " docFiles", "documentDir", "docDir", "documentF", "documentFiles", "docFiles", " docF", "DocFiles", "DocFile", "DocDir", " docDir"]}}
{"id1": "9033641", "id2": "17729554", "code1": "    public void testHttpsConnection_Not_Found_Response() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            try {\n                doInteraction(connection, ss, NOT_FOUND_CODE);\n                fail(\"Expected exception was not thrown.\");\n            } catch (FileNotFoundException e) {\n                if (DO_LOG) {\n                    System.out.println(\"Expected exception was thrown: \" + e.getMessage());\n                }\n            }\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 0, "substitutes": {"testHttpsConnection_Not_Found_Response": ["testHttpsConnection_Not_FoundHeaderresponse", "testHttpsConnection_Not_Found_response", "testHttpsConnection_Not_Found_Request", "testHttpsConnection_Not_FoundHttpResponse", "testHttpsConnection_Not_foundServerCode", "testHttpsConnection_Not_found_Request", "testHttpsConnection_Not_foundServerRequest", "testHttpsConnection_Not_foundServerresponse", "testHttpsConnection_Not_FoundServerResponse", "testHttpsConnection_Not_FoundServerresponse", "testHttpsConnection_Not_FoundHttpCode", "testHttpsConnection_Not_FoundServerRequest", "testHttpsConnection_Not_FoundHeaderResponse", "testHttpsConnection_Not_FoundHeaderRequest", "testHttpsConnection_Not_Found_Code", "testHttpsConnection_Not_FoundHeaderCode", "testHttpsConnection_Not_found_response", "testHttpsConnection_Not_foundServerResponse", "testHttpsConnection_Not_FoundHttpRequest", "testHttpsConnection_Not_FoundServerCode", "testHttpsConnection_Not_found_Code", "testHttpsConnection_Not_FoundHttpresponse", "testHttpsConnection_Not_found_Response"], "ctx": ["bc", "fp", "lc", "cf", "jp", "mc", "client", "ca", "cb", "tx", "x", "tc", "cci", "context", "conn", "cms", "cp", "conv", "hw", "c", "cc", "ci", "ctrl", "ct", "cca", "cs", "config", "css", "Context", "cas", "h", "rc", "sc", "cn", "ref", "pc", "Conn", "cpp", "sf", "conf"], "ss": ["sv", "sw", "cf", "site", "Socket", "vs", "ws", "ess", "sl", "oss", "connect", "conn", "s", "ls", "localhost", "si", "iss", "SS", "ses", "sa", "ssl", "sq", "sb", "cs", "WS", "ps", "socket", "css", "sn", "ds", "fs", "cas", "sc", "se", "server", "rss", "ssh", "serv", "sf", "sp", "bs", "settings"], "hnv": ["rnV", "bnf", "bnV", "gnvd", "knx", "gnw", "gnx", "hnvd", "cnV", "hnx", "rnx", "rnf", "uhx", "knvd", "uhw", "bnx", "hnf", "hnw", "knw", "uhvd", "rnv", "hnV", "knv", "gnv", "bnv", "cnf", "cnx", "cnv", "uhv"], "url": ["address", "rl", "base", "job", "feed", "URL", "proxy", "path", "log", "sl", "fl", "Url", "host", "location", "context", "string", "ls", "conn", "image", "link", "org", "ssl", "user", "www", "loc", "ur", "uri", "lr", "http", "plug", "l", "page", "server", "file", "channel", "impl", "web", "control", "blog", "f"], "connection": ["bc", "lc", "cf", "client", "reader", "builder", "connected", "io", "proxy", "function", "connect", "session", "conn", "context", "out", "driver", "c", "database", "character", "j", "ssl", "communication", "event", "Connection", "application", "b", "handler", "config", "socket", "service", "wrapper", "condition", "http", "l", "channel", "server", "nc", "con", "response", "relation"]}}
{"id1": "7166270", "id2": "9846843", "code1": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 0, "substitutes": {"issueCommandToServer": [" sendCommandtoserver", " sendRequestToServer", " sendRequestFromServer", " sendCommandtoServer", " sendRequestToService", " sendCommandFromService", " sendCommandToserver", " sendRequestToserver", " sendCommandWithserver", " sendCommandFromClient", " sendCommandFromServer", " sendCommandtoService", " sendRequestFromserver", " sendCommandToService", " sendCommandWithServer", " sendCommandFromserver", " sendCommandToServer", " sendCommandWithClient", " sendCommandToClient", " sendCommandWithService", " sendRequestToClient", " sendRequestFromService", " sendCommandtoClient", " sendRequestFromClient"], "command": ["address", "description", "request", "function", "comm", "pattern", "patch", "string", "sequence", "cmd", "action", "queue", "domain", "argument", "code", "operation", "event", "component", "menu", "connection", "method", "application", "text", "directory", "query", "message", "buffer", "service", "resource", "timeout", "version", "attribute", "document", "data", "execute", "password", "script", "value", "Command", "module"], "changeCapsule": ["changeScapsulate", "changeCapsulation", "changeScapure", "changeCapules", "changeScapole", "changeCAPSules", "changecAPSulation", "changeCapure", "changecapsule", "changeCapesules", "changeCapsure", "changecAPSule", "changeCAPSulate", "changeCapulation", "changeCapule", "changeCapole", "changeCorpole", "changeCapesule", "changecapsulation", "changeScapule", "changeCorpulate", "changeScapsule", "changeCambulate", "changeCapesulate", "changeCAPSule", "changeCambule", "changeCapesulation", "changeScapsure", "changeCorpule", "changeCapsules", "changeScapulate", "changeCambure", "changeCapulate", "changeCambole", "changecapsulate", "changecAPSules", "changecAPSulate", "changeCorpure", "changecapsules", "changeCapsulate", "changeCapsole", "changeScapsole", "changeCAPSulation"], "urlConn": ["httpOpen", " urlConnector", "httpDec", "UrlConnector", "httpCo", "UrlAuth", "urlConnect", " urlEnc", "serverConn", " urlConnection", " urlConnect", "lFs", "serverAuth", "userConn", "serverConnect", "lConnect", "lConn", "serverDec", "UrlExec", "userConnect", "serverExec", "serverConnector", "urlEnc", "UrlEnc", "urlFs", "urlDec", "httpConnection", "httpConnect", "userOpen", "serverConnection", "urlCo", " urlAuth", " urlCo", "UrlConn", "serverCo", "lConnection", "urlOpen", "UrlConnect", "httpFs", " urlFs", "urlConnector", "urlExec", " urlExec", "serverEnc", " urlDec", "urlAuth", "urlConnection", " urlOpen", "httpConn", "userConnection"], "wr": ["wt", "wa", "wk", "wire", "vr", "tw", "rh", "sr", "w", "mr", "war", "wl", "rr", "worker", "ws", "nr", "wer", "conn", "raft", "cr", "wx", "hr", "err", "rw", "NW", "writer", "Writer", "r", "rx", "kr", "Wr", "wb", "nw", "wh", "wd", "wcs", "wp", "wm", "RW", "usr", "fw", "sw", "shr", "WR"], "content": ["exec", "url", "header", "cont", "description", "output", "child", "raw", "request", "xml", "equ", "string", "context", "section", "c", "write", "code", "format", "method", "esc", "text", "body", "const", "config", "enc", "message", "array", "buffer", "resource", "Content", "wave", "document", "data", "work", "server", "source", "password", "create", "value", "script", "json", "activity", "comment", "temp"], "input": ["error", "reader", "audio", "amp", "w", "enter", "output", "inc", "raw", "cur", "Input", "rr", "request", "worker", "xml", "er", "keep", "out", "conn", "hr", "stream", "inner", "image", "self", "acl", "ssl", "writer", "i", "r", "active", "element", "pull", "socket", "through", "buffer", "iter", "resource", "inf", "wave", "form", "rc", "in", "data", "usr", "source", "inside", "init", "rss", "json", "ink", "ack", "inch", "ctx", "temp"], "response": ["result", "output", "answer", "site", "feed", "vector", "model", "Response", "request", "string", "generation", "image", "respond", "writer", "connection", "reference", "report", "application", "object", "ception", " Response", "message", "array", "buffer", "resource", "api", "uri", "wave", "tree", "office", "service", "page", "line", "data", "resp", "server", "secret", "value", "reply", "json", "onse", "collection"], "str": ["exec", "url", "result", "cl", "lc", "st", "dec", "br", "id", "exp", "arr", "raw", "div", "er", "sl", "string", "name", "hr", "cr", "obj", "err", "spec", "Str", "type", "i", "r", "kr", "text", "tr", "STR", "enc", "list", "ner", "fr", "iter", "dr", "line", "stri", "data", "char", "l", "letter", "style", "coll", "sp", "strike", "f", "pr"]}}
{"id1": "16556717", "id2": "9996334", "code1": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "code2": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "label": 1, "substitutes": {"getSHADigest": ["getSHAPigest", "getSHAPigester", "getSHADIGher", "getSHAPegEST", "getSHAPigEST", "getSHADegester", "getSHADegEST", "getSHADipest", "getSHAPegest", "getSHADigEST", "getSHADegest", "getSHADipester", "getSHADegher", "getSHAPegester", "getSHADigester", "getSHADIGest", "getSHAPegher", "getSHADIGEST", "getSHAPigher", "getSHADIGester", "getSHADipher", "getSHADigher", "getSHADipEST"], "password": ["hash", "address", "encrypted", "token", "Password", "id", "sword", "security", "path", "input", "pattern", "string", "name", "word", "prefix", "code", "auth", "words", "username", "crypt", "user", "text", "config", "padding", "buffer", "attribute", "p", "key", "wd", " passwords", "phrase", "data", "PASS", "secret", "email", "pass", "Pass"], "digest": ["hashest", " digusher", "hexkey", "hexString", "Digress", "greatester", "greatest", "generEST", "generhest", " dighest", " digress", "digEST", "hashkey", "greatesting", "digString", " digester", "digesting", "digester", " digEST", "digests", "digusher", "Digests", "Digesting", "Digusher", "Digkey", "DigEST", "hexest", "digress", "hexests", "Digester", "hashress", "hashusher", "hashester", "greatEST", "hashString", "Digest", "digkey", " digesting", "dighest", "generester", "Dighest", "generest", "hashests", "DigString"], "sha": ["ga", "slave", "hash", "wa", "da", "pa", "mc", "ca", "asha", "alias", "ua", "ami", "volume", "po", " SHA", "ba", "meta", "hh", "si", "sa", "SHA", "lambda", "eta", "ka", "sum", "a", "ph", "cca", "ppa", "ha", "ema", "aa", "ma", "alpha", "la", "api", "acha", "pg", "mac", "h", "sh", "shi", "na", "qa", "ta", "HA", "ah", "ssh", "oa", "va", "pi", "acl"], "pwhash": ["pWhash", "pphashed", " pwhade", "jpWHash", "jpwhest", "jpWHashed", "pwhea", "pWhade", "pwheash", "pWhest", "pwa", "pwhest", " pwade", " pwhest", " pwashed", "pwashed", "jpWHest", "pWHash", "jpwha", "pwha", "pwheashed", "pwheest", "pwhade", "pwest", "pphash", " pwhashed", "jpwhashed", "pphade", "pwhashed", "pWHashed", "pwade", "pWHa", "pphest", " pwest", "jpwhash", "jpWHa", "pWHest", "pWhashed", "pwash", " pwash"]}}
{"id1": "13414771", "id2": "4118412", "code1": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 0, "substitutes": {"encriptPassword": [" desjectPassword", " desryptPass", " enjectSecret", " desryptpassword", " descodePass", " desryptPassword", " enjectpassword", " descriptSecret", " encriptPass", " descriptpassword", " descodePassword", " encriptpassword", " desryptSecret", " encriptSecret", " enjectPass", " enjectPassword", " desjectSecret", " desjectPass", " descodeSecret", " descodepassword", " desjectpassword", " descriptPassword", " descriptPass"], "passwd": ["failpassword", "Password", "asspassword", " passpassword", "Passw", "Passwd", "passw", " password", "Passwt", "assword", " passwt", "failword", "Passpassword", " passw", "password", "asswd", "failwt", "assw", "failwd", "passpassword", "passwt"], "md": ["mad", "MD", "mc", "dig", "ms", "sha", "gb", "metadata", "rm", "pm", "bd", "amd", "bm", "mo", "mb", "mt", "cmd", "hd", "sm", "mand", "m", "dd", "gd", "od", "mg", "mm", "ma", "ad", "pd", "cd", "kg", "wd", "nd", "mac", "mod", "hm", "di", "ld", "d", "mag", "nm", "vd", "dm", " MD", "mp"], "hash": ["shadow", "sha", "ash", "rh", "check", "Hash", "log", "index", "node", "string", "kh", "image", "hex", "build", "auth", "print", "html", "user", "count", "number", "object", "body", "hed", "her", "message", "array", "version", "key", "mac", "h", "copy", "sh", "password", "num", "oh", "value", "square", "sum", "f", "dig"]}}
{"id1": "841724", "id2": "536614", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewwrite", "readandRewrite", "readandrewrites", "readAndSwrites", "readAndrewrite", "readAndRebrite", "readandRewwrite", "readAndrewwrite", "readAndRebrites", "readandrewwrite", "readandrewrap", "readAndSwwrite", "readandRewrap", "readandRewrites", "readAndrewrap", "readAndRewrites", "readAndrewrites", "readAndRebrap", "readAndRewrap", "readAndSwrap", "readandrewrite", "readAndSwrite", "readAndRebwrite"], "inFile": ["oldFilename", "InFiles", "Infile", "oldFiles", "loginFilename", "inputFile", "InFile", "InSourceFile", "loginFile", "infile", "oldfile", "inputFiles", "oldFile", " infile", "inputFilename", " inFilename", "loginfile", "outfile", "loginFiles", "inFilename", " inSourceFile", "outSourceFile", "inFiles", "outFiles", "outFilename", "inSourceFile", " inFiles", "inputfile"], "outFile": ["newDir", "thisfile", "outDir", "processPlace", "OutStream", "thisFILE", "OutDir", "outFILE", "newFile", "offFile", "offFILE", "thisFilename", "outputFILE", "outStream", "outputFilename", "offFilename", " outfile", "exfile", "offPlace", "processFILE", "outputPlace", "thisFile", "processFilename", " outStream", " outDir", "outputfile", "newfile", "newStream", "exFilename", "outfile", "exFILE", "outPlace", "OutFile", "processFile", "exFile", "Outfile", "outFilename", "outputFile"], "iis": ["Iis", "iiris", " iiss", "iiIs", "ciIs", "ciIS", "ciis", "Iiss", "Iais", "iniiss", "iniIs", "iiss", "iniris", "ciais", "iiiss", " iIS", "iniIS", " iais", "iIS", " iIs", "iiIS", "iIs", " iris", "iris", "ciiss", "iniis", "iiis", "IIS", "ciris", "iais"], "dcmParser": [" dcrPlugin", "dmParser", " dcmHelper", " dcmarser", "fcmHandler", "dpmPlugin", "dcrPar", "fpmParser", "dCMReader", "dcmLoader", " dcmPlugin", "dpmLanguage", "dkmParser", "fpmparser", "dcmHelper", " dpmLanguage", "dmcParser", "dbmPolicy", "dcrReader", "dmcPar", " dpmParser", "dmissionReader", "dCMHandler", " dcmparser", "dmissionPlugin", "dmPlugin", "dmmparser", "dCMParser", "dpmHandler", "dbmHelper", "dpmReader", "dpmInstallation", " dcrLoader", "dbmPlugin", " dpmarser", "dmmLoader", "dhemJar", "dmoduleparser", "DcmReader", " dcrParser", " dpmJar", "dcmPolicy", "DcmInstallation", "dhemInstallation", "dmcJar", " dpmPolicy", "dpmparser", " dpmHelper", "dmissionLanguage", "dcmPar", " dpmparser", "dcmReader", "dpmPar", "fpmHandler", "dmodulePlugin", "dkmPlugin", "dbmParser", "dcmparser", " dcmPar", "dkmPolicy", "dmoduleParser", "dcrPlugin", "fcmParser", "dCMPlugin", "dmoduleJar", "dmcarser", "dcmPlugin", "dmoduleReader", " dcmPolicy", "DcmJar", "dcrParser", " dpmPlugin", "dCMLoader", " dcrReader", "DcmParser", " dcmLanguage", "dpmJar", "dmissionParser", "dhemParser", "dcmarser", " dcmJar", "dcmInstallation", "dpmParser", "dCMparser", "dmmPlugin", "dcrLoader", "dcrarser", "fpmReader", " dpmPar", "dcrJar", "dpmLoader", " dpmLoader", "dmLoader", "dmmParser", " dpmReader", "dcmJar", "fcmReader", "dhemReader", "dkmHelper", "fcmparser", "dpmarser", "dpmHelper", "dpmPolicy", " dcmLoader", "dcmHandler", "dcmLanguage", "dmReader", " dcmReader"], "ds": ["sys", "services", "da", "Os", "ins", "Ds", "ays", "eps", "xs", "ts", "ils", "db", "vs", "tx", "ws", "nas", "ads", "df", "session", "ns", "ks", "asi", "ls", "s", "conn", "iss", "os", "dd", "Db", "gd", "des", "ys", "dat", "js", "cs", "vals", "drivers", "cdn", "ps", "sync", "pd", "dc", "parts", "uds", "ants", "dt", "dr", "di", "dds", "data", "is", "ld", "qs", "amps", "DS", "d", "src", "icks", "details", "utils", "points", "ss", "bs", "ros", "tes", "rs", "gs", "ras"], "pdReader": ["pcRead", "pcLoader", "dsreader", "hdWriter", "xdReader", "xdRead", "hdRunner", "hdStream", "pcWriter", "hdRead", "ddStream", "dsLoader", "pbRunner", "pcReader", "dsReader", "dsRead", "hdreader", "pbLoader", "hdLoader", "ddRunner", "pdLoader", "pbStream", "pdStream", "pdreader", "pdRunner", "dsWriter", "pbReader", "hdReader", "xdreader", "pdRead", "xdWriter", "ddReader", "ddLoader"], "out": ["external", "outs", "cache", "gen", "inc", "model", "session", "conn", "name", "doc", "ssl", "writer", "at", "null", "with", "data", "file", "full", "group", "part", "as", "client", "child", "term", "db", "dot", "s", "ext", "word", "to", "lock", "write", "down", "Out", "user", "object", "o", "her", "key", "store", "page", "in", "cli", "password", "device", "later", "net", "result", "base", "OUT", "w", "login", "io", "auto", "obj", "inner", "err", "lib", "code", "layer", "again", "parent", "over", "oder", "list", "outer", "copy", "director", "temp", "exec", "flow", "sys", "url", "img", "builder", "output", "exp", "default", "image", "order", "connection", "ex", " in", "co", "sync", "diff", "array", "point", "line", "up", "pass", "dev", "manager"], "dcmEncParam": ["dcmElType", "dcmEnParam", "dcmEstType", "dcmEstPar", "dcmDecPart", "dcmDecParameter", "dcmArchParameter", "dcmEnArg", "dcmEncArg", "dcmElPar", "dcmEncParameter", "dcmDecType", "dcmSecType", "dcmEncPart", "dcmDecParam", "dcmEnType", "dcmSecPart", "dcmEncType", "dcmArchParam", "dcmSecPar", "dcmEnPart", "dcmSecParam", "dcmDecArg", "dcmEnPar", "dcmEstParam", "dcmElParameter", "dcmElParam", "dcmEstParameter", "dcmDecPar", "dcmEnParameter", "dcmArchArg", "dcmEncPar"], "pdWriter": ["PDWrite", "dpWrite", "hdWriter", "htReader", "ddWrite", "dpReader", "pdWriting", "dsOutput", "dsReader", "dpWriter", "hdWrite", "PDWriter", "dpWriting", "PDReader", "htWriting", "dsWriter", "hdReader", "htWrite", "htWriter", "PDWriting", "ddWriter", "ddOutput", "hdOutput", "pdOutput", "dsWrite", "ddReader", "pdWrite"]}}
{"id1": "2461169", "id2": "23611770", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2String", "decodeStringToFile", "decodeFile2Stream", "decodeFile2Files", "decodeFileFromFiles", "decodeStringToStream", "decodeFileAsFiles", "decodeFileAsString", "decodeStringToFiles", "decodeFileFromFile", "decodeFileToStream", "decodeString2File", "decodeFileToString", "decodeFileFromString", "decodeFileFromStream", "decodeFile2String", "decodeFileAsFile", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeFile2File", "decodeString2Files", "decodeFileAsStream"], "infile": ["Inbase", "Infile", "infiles", "InFile", " inFile", " instream", "inFile", "Instream", "minstream", "inputfiles", "infilename", "inbase", "outfilename", "minfile", " infilename", "outfiles", "minbase", "inputfp", "infp", " infiles", "inputfilename", " infp", "outfp", "instream", " inbase", "inputfile", "minFile"], "outfile": ["outputfilename", "outputpath", "outpath", "inputdatabase", "infolder", "inputFile", " outpath", "outdatabase", "inFile", "outFile", "outputdatabase", "outfolder", " outfolder", "infilename", "outfilename", " outFile", "outputfile", "inputpath", " outfilename", "outputfolder", " outdatabase", "outputFile", "inputfile"], "in": ["gin", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "ini", "input", "ic", "In", "s", "conn", "inner", "err", "inas", "m", "a", "i", "r", "b", "again", "sin", "socket", "nin", "win", "inn", "min", "pin", "is", "into", "cin", "data", "source", "lin", "init", "inside", "rin", "pass", "ac", "con", "as"], "out": ["net", "exec", "base", "error", "OUT", "client", "outs", "cache", "job", "output", "bin", "ou", "io", "inc", "one", "log", "session", "conn", "obj", "In", "inner", "name", "to", "image", "write", "err", "off", "no", "Out", "lib", "or", "writer", "ex", "parent", "again", "o", "co", "socket", "sync", "post", "outer", "timeout", "point", "copy", "line", "channel", "file", "up", "work", "pass", "home", "exit"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bb", "bin", "transfer", "feed", "raw", "input", "border", "length", "seed", "binary", "offset", "queue", "write", "layer", "type", "reference", "batch", "count", "b", "null", "buf", "slice", "padding", "iter", "bytes", "wave", "flush", "data", "channel", "server", "source", "limit", "value", "split", "size", "buff"], "read": ["exec", " skip", " Read", "ip", "reader", "send", " copy", "parse", "lex", "allow", "use", "id", "feed", "io", "load", "inc", "raw", "current", "_", "check", "x", " count", "connect", "seek", "length", "ind", "play", "start", "end", "write", "next", "len", "i", "count", "ride", "wait", "r", "n", "fill", "find", "Read", "slice", "sync", "READ", "tell", " write", "ad", "iter", "add", "get", "copy", "work", "sleep", "se", "limit", "reads", "pass", "reading", "size", "select", "f", "run"], "success": ["complete", "first", "result", "positive", "error", "cess", " succ", "primary", "status", "follow", "ccess", "growth", "flash", "fast", "right", "Success", "valid", "model", "func", "path", "default", " succeed", " Success", "true", "winner", "rolled", "results", "xx", "failed", "danger", "construct", " successful", "method", "null", "again", "ceed", "good", "message", "done", "rolling", "successfully", "content", "continue", "data", "warning", "successful", "pass", "roll", "initial", "better", "fail", "value", "open", "comment", "response"]}}
{"id1": "22603577", "id2": "17558353", "code1": "    public static String getFileContentFromPlugin(String path) {\n        URL url = getURLFromPlugin(path);\n        StringBuffer sb = new StringBuffer();\n        try {\n            Scanner scanner = new Scanner(url.openStream());\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                sb.append(line + \"\\n\");\n            }\n            scanner.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n        return sb.toString();\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            URL urlhome = new URL(\"http://www.verussolutions.biz/NGLDashBoard.xml\");\n            URLConnection uc = urlhome.openConnection();\n            InputStreamReader input = new InputStreamReader(uc.getInputStream());\n            BufferedReader in = new BufferedReader(input);\n            String inputLine;\n            String xmlData = \"\";\n            while ((inputLine = in.readLine()) != null) {\n                xmlData += inputLine;\n            }\n            in.close();\n            PrintWriter fw = new PrintWriter(new FileWriter(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            fw.println(xmlData);\n            fw.flush();\n            fw.close();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n        try {\n            Document doc = new SAXBuilder().build(new File(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            String onlinsuppcdat = doc.getRootElement().getChild(\"OnlineSupportInformation\").getText();\n            CDATA cdata = new CDATA(onlinsuppcdat);\n            host.setOnlineInformationHTML(cdata.getText());\n            onlinsuppcdat = doc.getRootElement().getChild(\"News\").getText();\n            cdata = new CDATA(onlinsuppcdat);\n            host.setNewsHTML(cdata.getText());\n            host.fillData();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getFileContentFromPlugin": ["getFileContentOfPlugin", "getFileContentfromFile", "getFileContentFormModule", "getFileContentfromplugin", "getFileContentFromModule", "getFileDataOfFile", "getFileDataFromModule", "getFileContentFromplugin", "getFileDataFromPlugin", "getFileContentFormFile", "getFileDataFromplugin", "getFileContentOfFile", "getFileDataOfplugin", "getFileContentOfModule", "getFileContentfromPlugin", "getFileContentFormPlugin", "getFileContentFromFile", "getFileContentfromModule", "getFileContentFormplugin", "getFileDataOfPlugin", "getFileDataFromFile", "getFileDataOfModule", "getFileContentOfplugin"], "path": ["PATH", "system", "job", "str", "id", "platform", "port", "child", "plugin", "input", "filename", "location", "name", "string", "pointer", "pattern", "Path", "stream", "image", "prefix", "code", "type", "class", "text", "object", "config", "install", "loader", "plugins", "uri", "ath", "resource", "p", "key", "content", "data", "work", "file", "entry", "dir", "src", "full", "part"], "url": ["base", "client", "job", "bb", "feed", "io", "URL", "jar", "log", "plugin", "sl", "er", "Url", "string", "ls", "stream", "image", "hub", "this", "org", "ssl", "connection", "r", "user", "b", "browser", "ll", "socket", "loader", "ur", "lr", "uri", "resource", "service", "bel", "http", "plug", "l", "page", "source", "file", "server", "download", "impl", "blog", "f"], "sb": ["bc", "fp", "sv", "job", "ib", "bb", "ob", "gb", "bp", " SB", "nb", "db", "ws", "bm", "fb", "ls", "binary", "bsp", "ruby", "sa", "bag", "sg", "storage", "ssl", "BB", "SB", "lb", "b", "buf", "bg", "bt", "wb", "buffer", "ab", "eb", "rb", "pb", "bh", "vm", "src", "bf", "erb", "sf", "comment", "cb", "gs"], "scanner": ["aninner", "Scanaster", "nerner", "caninner", "Scaner", "canner", "canning", "Scanener", " scaninner", "nerener", " scaner", "scaner", "Scanter", "scanter", "Scaninner", "caner", "scanning", "anner", "scanners", "anninner", "Scanner", "nerners", "anning", "canners", "canter", "scaninner", "annning", "Scanning", "Scanners", "scanaster", " scanaster", "scanener", "canener", "canaster", "aner", "nerter", "annner"], "line": ["cl", "lc", "base", "header", "job", "str", "e", "id", "feed", " inline", "model", " Line", "sl", "lined", "row", "string", "Line", "lines", "section", "next", "link", "character", "code", " lines", "LINE", "layer", "connection", "text", "object", "rule", "block", "sync", "message", "l", "lin", "source", "entry", "data", "page", "col", "file", "style", "inline", "pass", "comment", "cell"]}}
{"id1": "536614", "id2": "8079516", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewwrite", "readandRewrite", "readandrewrites", "readAndSwrites", "readAndrewrite", "readAndRebrite", "readandRewwrite", "readAndrewwrite", "readAndRebrites", "readandrewwrite", "readandrewrap", "readAndSwwrite", "readandRewrap", "readandRewrites", "readAndrewrap", "readAndRewrites", "readAndrewrites", "readAndRebrap", "readAndRewrap", "readAndSwrap", "readandrewrite", "readAndSwrite", "readAndRebwrite"], "inFile": ["oldFilename", "InFiles", "Infile", "oldFiles", "loginFilename", "inputFile", "InFile", "InSourceFile", "loginFile", "infile", "oldfile", "inputFiles", "oldFile", " infile", "inputFilename", " inFilename", "loginfile", "outfile", "loginFiles", "inFilename", " inSourceFile", "outSourceFile", "inFiles", "outFiles", "outFilename", "inSourceFile", " inFiles", "inputfile"], "outFile": ["newDir", "thisfile", "outDir", "processPlace", "OutStream", "thisFILE", "OutDir", "outFILE", "newFile", "offFile", "offFILE", "thisFilename", "outputFILE", "outStream", "outputFilename", "offFilename", " outfile", "exfile", "offPlace", "processFILE", "outputPlace", "thisFile", "processFilename", " outStream", " outDir", "outputfile", "newfile", "newStream", "exFilename", "outfile", "exFILE", "outPlace", "OutFile", "processFile", "exFile", "Outfile", "outFilename", "outputFile"], "iis": ["Iis", "iiris", " iiss", "iiIs", "ciIs", "ciIS", "ciis", "Iiss", "Iais", "iniiss", "iniIs", "iiss", "iniris", "ciais", "iiiss", " iIS", "iniIS", " iais", "iIS", " iIs", "iiIS", "iIs", " iris", "iris", "ciiss", "iniis", "iiis", "IIS", "ciris", "iais"], "dcmParser": [" dcrPlugin", "dmParser", " dcmHelper", " dcmarser", "fcmHandler", "dpmPlugin", "dcrPar", "fpmParser", "dCMReader", "dcmLoader", " dcmPlugin", "dpmLanguage", "dkmParser", "fpmparser", "dcmHelper", " dpmLanguage", "dmcParser", "dbmPolicy", "dcrReader", "dmcPar", " dpmParser", "dmissionReader", "dCMHandler", " dcmparser", "dmissionPlugin", "dmPlugin", "dmmparser", "dCMParser", "dpmHandler", "dbmHelper", "dpmReader", "dpmInstallation", " dcrLoader", "dbmPlugin", " dpmarser", "dmmLoader", "dhemJar", "dmoduleparser", "DcmReader", " dcrParser", " dpmJar", "dcmPolicy", "DcmInstallation", "dhemInstallation", "dmcJar", " dpmPolicy", "dpmparser", " dpmHelper", "dmissionLanguage", "dcmPar", " dpmparser", "dcmReader", "dpmPar", "fpmHandler", "dmodulePlugin", "dkmPlugin", "dbmParser", "dcmparser", " dcmPar", "dkmPolicy", "dmoduleParser", "dcrPlugin", "fcmParser", "dCMPlugin", "dmoduleJar", "dmcarser", "dcmPlugin", "dmoduleReader", " dcmPolicy", "DcmJar", "dcrParser", " dpmPlugin", "dCMLoader", " dcrReader", "DcmParser", " dcmLanguage", "dpmJar", "dmissionParser", "dhemParser", "dcmarser", " dcmJar", "dcmInstallation", "dpmParser", "dCMparser", "dmmPlugin", "dcrLoader", "dcrarser", "fpmReader", " dpmPar", "dcrJar", "dpmLoader", " dpmLoader", "dmLoader", "dmmParser", " dpmReader", "dcmJar", "fcmReader", "dhemReader", "dkmHelper", "fcmparser", "dpmarser", "dpmHelper", "dpmPolicy", " dcmLoader", "dcmHandler", "dcmLanguage", "dmReader", " dcmReader"], "ds": ["sys", "services", "da", "Os", "ins", "Ds", "ays", "eps", "xs", "ts", "ils", "db", "vs", "tx", "ws", "nas", "ads", "df", "session", "ns", "ks", "asi", "ls", "s", "conn", "iss", "os", "dd", "Db", "gd", "des", "ys", "dat", "js", "cs", "vals", "drivers", "cdn", "ps", "sync", "pd", "dc", "parts", "uds", "ants", "dt", "dr", "di", "dds", "data", "is", "ld", "qs", "amps", "DS", "d", "src", "icks", "details", "utils", "points", "ss", "bs", "ros", "tes", "rs", "gs", "ras"], "pdReader": ["pcRead", "pcLoader", "dsreader", "hdWriter", "xdReader", "xdRead", "hdRunner", "hdStream", "pcWriter", "hdRead", "ddStream", "dsLoader", "pbRunner", "pcReader", "dsReader", "dsRead", "hdreader", "pbLoader", "hdLoader", "ddRunner", "pdLoader", "pbStream", "pdStream", "pdreader", "pdRunner", "dsWriter", "pbReader", "hdReader", "xdreader", "pdRead", "xdWriter", "ddReader", "ddLoader"], "out": ["external", "outs", "cache", "gen", "inc", "model", "session", "conn", "name", "doc", "ssl", "writer", "at", "null", "with", "data", "file", "full", "group", "part", "as", "client", "child", "term", "db", "dot", "s", "ext", "word", "to", "lock", "write", "down", "Out", "user", "object", "o", "her", "key", "store", "page", "in", "cli", "password", "device", "later", "net", "result", "base", "OUT", "w", "login", "io", "auto", "obj", "inner", "err", "lib", "code", "layer", "again", "parent", "over", "oder", "list", "outer", "copy", "director", "temp", "exec", "flow", "sys", "url", "img", "builder", "output", "exp", "default", "image", "order", "connection", "ex", " in", "co", "sync", "diff", "array", "point", "line", "up", "pass", "dev", "manager"], "dcmEncParam": ["dcmElType", "dcmEnParam", "dcmEstType", "dcmEstPar", "dcmDecPart", "dcmDecParameter", "dcmArchParameter", "dcmEnArg", "dcmEncArg", "dcmElPar", "dcmEncParameter", "dcmDecType", "dcmSecType", "dcmEncPart", "dcmDecParam", "dcmEnType", "dcmSecPart", "dcmEncType", "dcmArchParam", "dcmSecPar", "dcmEnPart", "dcmSecParam", "dcmDecArg", "dcmEnPar", "dcmEstParam", "dcmElParameter", "dcmElParam", "dcmEstParameter", "dcmDecPar", "dcmEnParameter", "dcmArchArg", "dcmEncPar"], "pdWriter": ["PDWrite", "dpWrite", "hdWriter", "htReader", "ddWrite", "dpReader", "pdWriting", "dsOutput", "dsReader", "dpWriter", "hdWrite", "PDWriter", "dpWriting", "PDReader", "htWriting", "dsWriter", "hdReader", "htWrite", "htWriter", "PDWriting", "ddWriter", "ddOutput", "hdOutput", "pdOutput", "dsWrite", "ddReader", "pdWrite"]}}
{"id1": "5977352", "id2": "13783549", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferfile", "copyDir", " copyDir", "CopyFile", "CopyFiles", "transferFiles", "transferDir", " copyfile", "CopyDir", "Copyfile", "transferFile", "copyfile", " copyFiles"], "src": ["ource", "fp", "url", "ins", "img", "gb", "view", "tmp", "proxy", "proc", "path", "sl", "input", "filename", "conn", "obj", "s", "stream", "this", "files", "sel", "sb", "b", "buf", "config", "loc", "slice", "loader", "inst", "uri", "resource", "rb", "rc", "source", "data", "file", "sc", "dist"], "dest": ["rest", "de", "url", "cont", "st", "thin", "master", "img", "cache", "project", "delete", "dep", "output", "tmp", "zip", "path", "folder", "target", "name", "obj", "cp", "this", "Dest", "class", "route", "desc", "orig", "parent", "null", "cdn", "config", "wb", "table", "done", "dc", "store", "source", "destroy", "file", "dir", "dist", "d", " destination", "die", "later", "home", "opt", "trans", "txt", " Dest", "part", "temp"], "bufSize": ["queueLen", "bufLen", "queuesize", "buf2", "queueSize", " bufLen", " buf2", "bufsize", "buffer2", "bufferSize", "ufSize", "ufsize", " bufsize", "uf2", "buffersize", "bufferLen", "ufLen"], "force": ["Force", "base", "forces", "place", "delete", "apply", "use", "id", "load", "replace", "deep", "remote", "auto", "urse", "hard", "write", "no", "ist", "require", "like", "forced", "dirty", "count", "ride", "route", "front", "parent", "pull", "sync", "p", "flush", "store", "rc", "source", "push", "file", "forcing", "only", "f"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bin", "transfer", "feed", "load", "raw", "request", "fb", "border", "length", "seed", "binary", "offset", "memory", "queue", "write", "reference", "batch", "b", "null", "buf", "slice", "padding", "iter", "bytes", "flush", "data", "source", "append", "limit", "value", "split", "zero", "buff"], "read": ["exec", "k", "ip", "ed", "reader", "level", "send", "parse", "lex", "view", "allow", "use", "id", "feed", "io", "load", "current", "raw", "skip", "check", "index", "input", "connect", "seek", "length", "ind", "play", "start", "end", "write", "next", "len", "build", "i", "count", "wait", "show", "b", "fill", "n", "text", "ride", "find", "Read", "sync", "block", "READ", " write", "ad", "iter", "close", "add", "get", "copy", "sleep", "work", "data", "se", "d", "create", "reads", "pass", "open", "reading", "size", "select", "run"], "in": ["serv", "url", "gin", "base", "ins", "thin", "din", "reader", "IN", "login", "bin", "id", "isin", "inc", "ini", "input", "In", "conn", "inner", "image", "err", "c", "lib", "m", "a", "i", "r", "connection", "b", "ex", "again", "n", "sin", "pull", "socket", "nin", "win", "inn", "min", "pin", "cin", "source", "up", "init", "kin", "inside", "rin", "pass", "con", "ac", "part", "as", "f"], "out": ["exec", "net", "url", "OUT", "client", "outs", "cache", "w", "call", "output", "app", "bin", "exp", "io", "inc", "ou", "id", "one", "conn", "obj", "ext", "inner", "max", "name", "image", "write", "no", "off", "err", "this", "Out", "plain", "lib", "at", "writer", "i", "connection", "user", "b", "ex", "n", "again", "o", "with", "co", "sync", "socket", "nin", "outer", "key", "by", "line", "source", "up", "init", "ac", "home", "part", "can"]}}
{"id1": "10131427", "id2": "6470716", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferfile", " copyChannel", "CopyFile", "CopyChannel", "CopyFiles", "transferFiles", "transferChannel", " copyfile", "Copyfile", "transferFile", "copyfile", "copyChannel", " copyFiles"], "in": ["url", "base", "ins", "reader", "IN", "login", "bin", "id", "io", "inc", "ini", "index", "input", "In", "name", "inner", "image", "c", "m", "or", "at", "a", "i", "b", "ex", "again", "config", "diff", "buffer", "inn", "resource", "min", "copy", "data", "work", "file", "source", "ac"], "out": ["exec", "external", "v", "base", "OUT", "client", "outs", "cache", "w", "output", "io", "x", "target", "name", "conn", "string", "image", "c", "prefix", "off", "Out", "at", "writer", "connection", "ex", "n", "object", "o", "dest", "buffer", "p", "copy", "point", "source", "data", "file", "part", "temp"], "sourceChannel": ["srcConnection", "SourceStream", "sourceSocket", "srcStream", " sourcechannel", "targetchannel", "sourceStream", "ourceStream", "ourcechannel", "sourceManager", " sourceStream", "sourceChan", "srcSocket", "SourceQueue", "SourceSocket", "ourceChan", "Sourcechannel", " sourceQueue", " sourceSocket", "srcChan", "SourceManager", "sourceQueue", "srcManager", "targetStream", "targetChannel", "srcQueue", " sourceChan", "SourceChannel", " sourceConnection", "SourceConnection", "ourceChannel", "srcChannel", "SourceChan", " sourceManager", "sourcechannel", "targetChan", "sourceConnection"], "destinationChannel": ["destationChan", "destationchannel", "destinatedChan", "destinatorChan", "destinationsConnection", "destinationStream", "DestinatorConnection", "destationCh", "destationChannel", "destinationschannel", "destinatorchannel", "destinatedCh", "Destinationchannel", "DestinatorChan", "destinationChan", "destinatedChannel", "Destinatorchannel", "DestinationStream", "DestinationCh", "destationConnection", "destinateStream", "destinatedConnection", "destinatorChannel", "DestinatorStream", "DestinatorCh", "destinatechannel", "destinationchannel", "destinationsStream", "DestinationChan", "DestinationConnection", "destinatorStream", "destinatorCh", "destinationsChannel", "destinateConnection", "destinatorConnection", "DestinatorChannel", "DestinationChannel", "destinationConnection", "destinateChannel", "destinationCh"]}}
{"id1": "21827619", "id2": "6756635", "code1": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"SHA1": ["SHAOne", "SHA256", "sha256", "SHA384", "HA1", " SHA384", "HA384", " SHAOne", "HA256", "shaOne", "sha1", " SHA256", "sha384", "HAOne"], "text": ["template", "test", "url", " Text", "token", "str", "output", "path", "font", "input", "pattern", "string", "name", "ext", "obj", "struct", "word", "image", "hex", "this", "code", "editor", "format", "connection", "class", "number", "object", "config", "message", "EXT", "version", "key", "content", "translation", "Text", "in", "data", "source", "letter", " TEXT", "password", "secret", "contract", "value", "txt", "TEXT"], "UnsupportedEncodingException": ["UnsupportedEncodingEx", "UnsupportedEncoderception", "UnsupportedEncasingEx", "UnsupportedEncoderException", "UnsupportedEncodedception", "UnsupportedEncoderEx", "UnsupportedEncasingException", "UnsupportedEncodingception", "UnsupportedEncodedException", "UnsupportedEncodedEx", "UnsupportedEncasingception"], "md": ["mad", "MD", "hash", "map", "mc", "sha", "ms", "metadata", "rm", "pm", "bd", "valid", "amd", "am", "df", "mo", "meta", "mb", "mt", "ind", "cmd", "hd", "sm", "code", "mand", "editor", "m", "dd", "mode", "Cmd", "gd", "body", "od", "mg", "mm", "message", "ma", "pd", "ad", "cd", "wd", "mac", "mp", "mod", "mn", "me", "di", "data", "ld", "d", "mag", "bf", "vd", "dm", "nm", " MD", "dig"], "sha1hash": ["SHA2sum", "wa5hash", "sha11hash", "sha4sum", "sha256h", "sha4h", "SHA2sha", "SHA1hash", "SHA2Hash", "sha5sum", "wa1hex", "SHA1Hash", "sha1Hash", "sha256hash", "sha64hash", "sha2h", "wa5sum", "sha1copy", "sha11sum", "wa5hex", "wa1copy", "SHA1sha", "sha5hash", "sha2sum", "sha4Hash", "sha1sha", "sha2hash", "wa5copy", "sha1sum", "sha4hash", "sha64copy", "sha4copy", "SHA1sum", "sha2Hash", "wa1sum", "sha64sum", "SHA2hash", "sha5hex", "sha11sha", "sha1hex", "sha64hex", "sha1h", "sha256sum", "sha5copy", "SHA2h", "sha4sha", "SHA1h", "sha4hex", "sha256Hash", "sha2sha", "wa1hash"]}}
{"id1": "17580775", "id2": "10445819", "code1": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "code2": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"runInternal": ["doImpl", "doSync", "runImpl", "processInternal", "processExternal", " runSync", "doInternal", "processSync", "doExternal", "processImpl", " runImpl", "runExternal", " runExternal", "runSync"], "connection": ["error", "cache", "port", "log", "engine", "session", "location", "context", "section", "character", "operation", "directory", "graph", "message", "option", "document", "ion", "server", "connected", "client", "description", "use", "environment", "function", "remote", "creator", "machine", "c", "database", "event", "component", "object", "timeout", "wrapper", "password", "statement", "relation", "position", "lc", "reader", "current", "command", "container", "volume", "connect", "inner", "driver", "entity", "layer", "communication", "body", "config", "loc", "socket", "resource", "condition", "source", "channel", "con", "builder", "proxy", "request", "default", "index", "image", "expression", "Connection", "application", "handler", "service", "version", "translation", "entry", "collection"], "visited": ["VISited", "viewed", "invitted", "viewited", "VISalled", "viewITED", "visITED", "Visalled", "invITED", "visalled", "Visitted", "invalled", "VISitted", "VISITED", "Vised", "viewitted", "invited", "Visited", "vised", "visitted", "VISed", "VisITED"], "startTimeStamp": ["startLineStng", "startTimeStamps", "startTimeestamp", "startTimeStamped", "startTimeestng", "startTimeStng", "startTimeEstamped", "startTimeEstng", "startLineEstng", "startTimestng", "startLineEstamps", "startTimestamps", "startTimeestamped", "startLineStamped", "startTimeEstamps", "startTimestamped", "startTimeestamps", "startLineStamp", "startLineEstamp", "startLineStamps", "startLineEstamped", "startTimeEstamp", "startTimestamp"], "delayedProgress": ["elayedProgress", "delivedStatus", "eladedProgress", "delivedContent", "elayedContent", "delivedComplete", "deladedStatus", "delayedComplete", "delivedProgress", "delayedContent", "deliverStatus", "deliverContent", "eladedStatus", "deladedContent", "eladedContent", "delayedStatus", "elayedStatus", "elayedComplete", "deladedProgress", "deladedComplete", "deliverComplete", "deliverProgress", "eladedComplete"], "conn": ["exec", "lc", "cf", "mc", "client", "uc", "ann", "io", "db", "ctx", "comm", "connect", "conv", "cp", "ls", "obj", "c", "ci", "cc", "ct", "ssl", " con", "Connection", "n", "config", "loc", "att", "nt", "enc", "sync", "co", "ad", "dc", "h", "http", "rc", "l", "cli", "channel", "ch", "cn", "act", "con", "nc", "Conn", "open", "cb", "connected", "cmp"], "fileName": ["contentname", "FileKey", "urlArea", "fileArea", "imagename", " filePath", "contentName", "FileName", "filename", "contentPath", " fileSpace", " fileArea", "urlName", "imageName", "urlKey", "FilePath", "fileKey", "contentSpace", "urlPath", " filename", "imagePath", "filePath", "FileArea", "fileSpace", " fileKey", "imageSpace"], "disp": ["interpatch", "broadpart", "detpp", "detp", "prop", "Dispp", "dispart", "defp", "defpend", "schep", "interpp", "schepe", "dispatch", " dispr", "dispr", "Dispr", " dispose", "propose", "broadp", "Dispose", "dispp", "dispend", "disap", "disP", "defps", "detpatch", "Dispe", "DisP", "detP", "Dispatch", "schepatch", "scheap", "disps", "interP", "interpe", "propr", "interp", "dispe", "Disap", "defpart", " dispe", "broadps", "interap", "dispose", "broadpend", "Dispart", "Disp", "Dispend", "prope", "Disps"], "p": ["v", "jp", "ping", "ip", "pa", "pat", "tp", "ap", "e", "bp", "lp", "pre", "after", "P", "index", "vp", "patch", "q", "end", "pr", "c", "rep", "pl", "np", "y", "m", "t", "j", "at", "i", "r", "pe", "g", "b", "n", "o", "loc", "api", "point", "h", "l", "col", "op", "pos", "d", "pp", "part", "sp", "f", "pi", "po"], "response": ["complete", "reset", "prot", "result", "error", "received", "description", "status", "output", "site", "found", "id", "feed", "model", "Response", "path", "request", "function", "index", "pointer", "image", "next", "success", "respond", "code", "en", "body", "ception", "message", "uri", "timeout", "version", "api", "resource", "respons", "http", "page", "data", "resp", "server", "successful", "value", "reply", "json", "collection", "radius"], "contentType": ["ContentType", "ContentInfo", "documentTyp", "documentType", "contentInfo", "contentName", " contentLength", " contentInfo", "documentName", "ContentTyp", "contentTyp", "messageType", "ContentLen", " contentName", "messageLen", "ContentLength", " contentTyp", "documentLength", "ContentName", "contentLength", "messageInfo", "messageLength"], "contentEncoding": ["loadEnasing", "contentEnryption", "contentencocol", "ContentEncoder", "contentencoding", "loadEnoding", "contentLocaring", "loadEncryption", "contentEncaring", "contentEnasing", "contentEncoder", "contentEncocol", "loadEncasing", "contentLocasing", "contentencReading", "contentencoder", "ContentEncoding", "ContentDecocol", "contentDecoding", "contentEoder", "contentEncReading", "contentDecReading", "contentEncryption", "contentCryption", "contentCasing", "contentDecoder", "ContentEncocol", "contentEncasing", "loadEnaring", "loadEncaring", "loadEncoding", "contentEnaring", "ContentEncReading", "loadEnryption", "contentEReading", "contentCaring", "contentLocryption", "contentLocoding", "contentEoding", "ContentDecReading", "ContentDecoding", "contentCoding", "ContentDecoder", "contentEocol", "contentEnoding", "contentDecocol"], "contentLen": ["contentSl", "Contentlen", "resourceLength", " contentSl", "contentlen", " contentlen", " contentLength", " contentSize", "resourcelen", "ContentLen", "ContentSl", "ContentLength", "resourceSize", "activitySize", "resourceLen", "activitySl", "activityLen", "contentLength", "contentSize", "ContentSize", "activityLength"], "is": ["us", "net", "im", "ip", "are", "un", "ot", "not", "IS", "out", "ync", "isl", "iss", "ios", "os", "ys", "ub", "ig", "isc", "version", "igh", "it", "isp", "ion", "ss", "can", "mis"], "url": ["address", "client", "status", "str", "feed", "URL", "path", "log", "sl", "Url", "host", "location", "context", "string", "image", "link", "org", "layer", "username", "ssl", "html", "user", "text", "config", "socket", "buffer", "uri", "service", "resource", "document", "http", "page", "source", "server", "file", "channel", "email", "download", "json"], "loadNext": ["loadingPrevious", "checkPrevious", "loadsPrevious", "loadsLast", "loadPrevious", "checkLast", "loadingLast", "checkNext", "checkFirst", "loadLast", "loadsNext", "loadFirst", "loadingFirst", "loadsFirst", "loadingNext"], "itemsLoadedPartially": ["itemsLoadedPartials", "itemsLoadedCopally", "itemsLoadippedPartials", "itemsLoadedpartally", "itemsLoadedPARTially", "itemsLoadedpartially", "itemsLoadedCopial", "itemsLoadippedPartially", "itemsLoadippedpartially", "itemsLoadedCopially", "itemsLoadippedpartial", "itemsLoadedPARTial", "itemsLoadippedpartials", "itemsLoadedPARTally", "itemsLoadedpartial", "itemsLoadedPartally", "itemsLoadippedPartally", "itemsLoadippedPartial", "itemsLoadedCopials", "itemsLoadedPartial", "itemsLoadippedpartally", "itemsLoadedPARTials", "itemsLoadedpartials"]}}
{"id1": "16851955", "id2": "88047", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"testTrainingBackprop": ["testTrainBACKpointer", "testTrainBACKprop", "testTrainBACKpressure", "testTrainBackprop", "testTrainingBackpointer", "testTrainingFrontdrop", "testTrainingBACKdrop", "testTrainingBackpressure", "testTrainingFrontpointer", "testTrainBackpressure", "testTrainingBackdrop", "testTrainBackpointer", "testTrainBackdrop", "testTrainingBACKprop", "testTrainBACKdrop", "testTrainingBACKpressure", "testTrainingFrontpressure", "testTrainingBACKpointer", "testTrainingFrontprop"], "temp": ["template", "test", "emp", "v", "fake", "base", "wrap", "cache", "clean", "save", "local", "output", "tmp", "zip", "current", "io", "model", "container", "cel", "path", "folder", "font", "input", "flat", "session", "out", "archive", "lock", "tem", "this", "pdf", "storage", "porary", "writer", "dat", "ex", "directory", "parent", "empty", "stable", "dest", "config", "pipe", "buffer", "mount", "form", "copy", "http", "data", "file", "Temp", "full", "txt", "f"], "layers": ["backs", "lobs", "liacks", "flasses", " libraries", "dlacks", "bayers", "lays", "gients", "players", "Lients", "lagers", "Lobs", "flanguages", " lients", "lores", "nlikes", "lacks", "languages", "placks", "gayers", "libraries", " lasses", "lowers", "slacks", " lacks", "licagers", "dlasks", "nlayers", " lasks", "slayers", "dlayers", "liibraries", "blayers", "slays", " lobs", "gobs", " lores", "Layers", " languages", " likes", "dlibraries", "planguages", "likes", "licayers", "licibraries", "dlanguages", "blanguages", " lowers", "nlagers", "lasks", " llements", "lasses", "bowers", "liores", "dlores", "licikes", " lagers", "blasses", "bays", "slowers", "bllements", "nlibraries", "liayers", "lients", "fllements", "flayers", "plasks", "llements", " lays"], "fann": ["fana", "xfanny", "fnn", "farn", "Fannon", "elfarn", "Fanny", "sfanny", "lann", "elfnn", "fain", "larn", "sfannon", "gnn", "gana", "Fann", "xfann", "fanny", "Fain", "xfannon", "sfain", "elfana", "fannon", "garn", "lana", "lnn", "xfain", "sfann", "elfann", "gann"], "trainer": ["Trayer", "stracker", "traainer", "Tracker", "tacer", "trarain", "Triner", "Trainer", "tacker", " tracker", "strayer", "striner", "racker", "Trrain", " train", "retacer", "tracker", "trayer", "retayer", " tracer", "stracer", "traacer", "retainer", "train", "tainer", "strainer", "Tracer", "trrain", "rain", "retiner", "rainer", "tracer", "triner", "strain", "racer", "traacker"], "desiredError": ["DesireError", "desciredFailure", "deservedError", "desiredEvent", "reservedSize", "desireSize", "designedEvent", "resiredEvent", "desciredProblem", "desiringFailure", "desirableSize", "deservedOrder", "desiredSize", "desiredOrder", "desireException", "reservedError", "designedSize", "desivedException", "desirableOrder", "desizedException", "descidedProblem", "designedOrder", "desirableError", "DesireException", "descirederror", "desizedError", "descidedError", "desizedSize", "deservedSize", "desireError", "DesiredSize", "resiredOrder", "deservedEvent", "descidederror", "desidedError", "desiredProblem", "reservedEvent", "desiredException", "desiringProblem", "desiringError", "reservedOrder", "DesiredException", "descidedFailure", "despectederror", "desiredFailure", "resiredSize", "desidedProblem", "despectedFailure", "desciredError", "desivedSize", "desirederror", "despectedProblem", "resiredError", "desivedError", "designedError", "desidederror", "desiringerror", "desirableEvent", "despectedError", "DesiredError", "DesireSize", "desidedFailure"], "mse": ["fSE", "Mte", "mce", "fge", "fmze", "gmse", " mze", "MSE", " mge", "mte", " mSE", "Mce", "fmte", " mce", "Mse", "fse", "fmse", "mSE", "gmce", "gmSE", "mge", "fmce", "Mge", "fce", "Mze", "mze", "gmge", " mte"]}}
{"id1": "11562173", "id2": "3801655", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["checkOutputSteam", "checkOutputStream", "checkIOstream", "checkInputstream", " checkInputChannel", "checkInputChannel", "checkOutputChannel", "checkIOSteam", " checkOutputChannel", " checkInputstream", "checkOutputstream", " checkOutputStream", "checkIOChannel", " checkOutputstream", " checkInputSteam", "checkIOStream", "checkInputSteam", "checkFileSteam", " checkOutputSteam", "checkFileChannel", "checkFilestream", "checkFileStream"], "in": ["ins", "din", "reader", "IN", "login", "bin", "io", "isin", "inc", "x", "ini", "index", "input", "ic", "In", "inner", "image", "c", "comp", "connection", "again", "inn", "p", "min", "plus", "is", "into", "data", "source", "up", "src", "con", "ack", "as"], "cmp": ["fp", "lc", "upp", "amp", "cache", "sup", "pixel", "com", "pre", "cb", "sort", "proc", "roc", "index", "omp", "conv", "cp", "c", "ci", "spec", "prefix", "comp", "cc", "asc", "np", "code", "prev", "cho", "cop", "cs", "co", "config", "diff", "loc", "clip", "p", "rc", "cup", "match", "op", "ch", "up", "mom", "coll", "pc", "cpp", "ctrl", "comment", "ctx", "mp"], "all": ["cl", "ann", "local", "allow", "ALL", "call", "valid", "not", "none", "partial", "am", "one", "default", "always", "total", "al", "auto", "asc", "All", "global", "a", "null", "both", "parent", "any", "best", "except", "list", "each", "alpha", "array", "p", "l", "match", "process", "and", "coll", "only", "full", "sum", "acl"], "stream": ["v", "test", "result", "cont", "client", "reader", "output", "port", "feed", "platform", "raw", "progress", "model", "input", "host", "string", "context", "this", "comp", "ream", "self", "Stream", "user", "transform", "null", "object", "per", "speed", "socket", "steam", "wrapper", "form", "stack", "track", "iterator", "document", "round", "source", "channel", "up", "pool", "instance", "coll", "src", "roll", "ack", "impl", "sw", "trans", "response", "temp"], "out": ["v", "result", "OUT", "outs", "project", "output", "bin", "exp", "io", "inc", "not", "x", "index", "name", "obj", "image", "c", "prefix", "this", "Out", "extra", "user", "b", "null", "again", "parent", "o", "list", "sync", "block", "outer", "array", "option", "p", "copy", "point", "other", "data", "up", "full", "part", "sum", "comment", "response"], "i": ["qi", "v", "lc", "k", "ai", "ti", "I", "e", "id", "io", "xi", "x", "ini", "index", "start", "ind", "u", "ui", "end", "li", "hi", "multi", "c", "ci", "si", "mi", "ii", "j", "type", "r", "info", "b", "n", "bi", "slice", "ri", "uri", "p", "strength", "key", "gi", "h", "ix", "abi", "it", "l", "oi", "di", "fi", "init", "d", "ji", "f", "pi"]}}
{"id1": "8062076", "id2": "5759961", "code1": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "code2": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"updateUser": ["updatePerson", "UpdateAccount", "UpdateRole", "UPDATERole", "UpdateUser", "updateRole", "UPDATEAccount", "changeUser", "changePerson", "updateAccount", "UpdatePerson", "changeAccount", "UPDATEPerson", "changeRole", "UPDATEUser"], "portalUserBean": ["portalUserBEam", "portalUserPeane", "portalFileBAN", "portalUserDeAN", "portalUserPeean", "portalGroupBeans", "portalUserPean", "portalUserEan", "portalGroupBEans", "portalUserBoin", "portalUserBeAN", "portalUserBEan", "portalUserEAN", "portalUserBane", "portalUserPlean", "portalUserBeane", "portalGroupBean", "portalUserBeam", "portalGroupBEAN", "portalUserPlane", "portalFileBane", "portalFileBin", "portalUserDeans", "portalFileBeAN", "portalClientBeane", "portalUserBoane", "portalUserDean", "portalUserBoan", "portalUserBann", "portalUserBEane", "portalUserBoam", "portalUserBeans", "portalClientBEans", "portalUserBans", "portalUserBin", "portalFileBeane", "portalUserBEann", "portalUserBEans", "portalUserDeane", "portalClientBEAN", "portalUserBEAN", "portalUserBegann", "portalUserBeean", "portalUserBegan", "portalUserBam", "portalClientBEan", "portalUserBoAN", "portalUserPlAN", "portalClientBean", "portalFileBean", "portalUserPeans", "portalUserPlan", "portalFileBan", "portalUserBeann", "portalFileBans", "portalUserBein", "portalUserPeAN", "portalFileBeean", "portalClientBeAN", "portalUserEans", "portalClientBeam", "portalUserBegAN", "portalUserEane", "portalGroupBeAN", "portalClientBEane", "portalUserEin", "portalUserBegans", "portalUserBan", "portalUserBoans", "portalGroupBEan", "portalFileBein", "portalClientBeans", "portalGroupBeann", "portalUserBAN", "portalFileBeans", "portalGroupBEann", "portalClientBEam"], "authSession": [" authsession", " authConn", "authConnection", "uthClient", " authConnection", "uthSession", "AuthClient", "AuthSession", "authClient", "Authsession", "uthConn", "AuthConn", "httpsession", "httpConnection", "authStream", "httpStream", "AuthStream", "AuthConnection", " authStream", "authsession", "authConn", " authClient", "httpSession", "uthsession"], "dbDyn": ["dbdYN", "dbBsyn", "dbSyn", "dbCodyn", "dbByr", "cbBien", "dbDoyan", "libDys", " dbBsyn", "dbDsyn", "bbDYN", "dbdyn", "DbPyr", "DbSyn", "dbIyan", "dbFyr", "dbCym", "dbNYN", "DbSyl", "cbDien", "dbCodyr", "dbFsyn", "dbCynam", "dbPyr", "DbDyl", "dbDoynam", " dbDoynam", "DbCYN", "dbDoyn", "dbDoyr", "cbDYN", "dbDoneYN", "dbDefym", "cbByn", "dbWYN", "dbDefys", "dbBSyn", "bbDyn", "dbBYN", "dbCYN", "dbBynam", "dbdgn", "dbIsyn", "DbDYN", "dbWyn", "dbDosyn", "dbFYN", "DbCyn", "dbFyn", "bbFyn", "dbCyn", "dbBien", "cbBYN", "cbBynam", "dbWsyn", " dbBynam", "dbCodSyn", "DbCynam", "dbDoneyn", " dbDoyan", " dbByr", "dbDSyn", "DbPSyn", "DbPyn", "DbDyr", "dbWSyn", "DbDahn", "dbCSyn", "dbSyl", "dbDefSyn", "dbByn", "dbPahn", "bbDSyn", "dbdynam", "dbFSyn", "dbdyl", "bbFSyn", "dbBahn", "dbDgn", "dbIynam", " dbDyan", "cbDynam", "dbDyl", "dbDynam", "libDSyn", "libDym", "dbIyn", "bbFsyn", "dbPyn", "dbDym", "libDyn", " dbDyr", "dbNyl", "dbDyr", "dbDien", "dbFynam", "dbDoneien", "DbDSyn", "dbdSyn", " dbDsyn", "dbSgn", "DbCSyn", "dbNyn", "dbNgn", "DbDyn", "dbDefyn", "dbPSyn", "cbDyn", "bbDsyn", " dbDosyn", "DbSgn", "dbDYN", "dbCys", "DbSYN", "bbFYN", " dbByn", "dbDahn", " dbDynam", "DbPahn", "dbSYN", "DbDynam", "dbDoneynam", " dbDoyn", "DbDgn", "dbDyan", "dbDys", "dbFyan", "dbCodahn"], "ps": ["jp", "posts", "ins", "pa", "ms", "eps", "pse", "PS", "pre", "ts", "proxy", "rs", "ils", "vs", "ws", "py", "ns", "res", "ks", "s", "ls", "lines", "this", "Ps", "pl", "fe", "where", "os", "pers", "PD", "pps", "hs", "als", "properties", "ras", "pe", "js", "cs", "ops", "cop", "ppa", "ups", "per", "css", "post", "ds", "aps", "fs", "p", "les", "pg", "ips", "http", "its", "ons", "pb", "ports", "qs", "pos", "pc", "pp", "details", "as", "sp", "ss", "pes", "bs", "mp", "gs", "pr", "po"], "sql": ["sys", "csv", "su", "fp", "url", "sol", "sv", "params", "description", "util", "job", "rel", "eps", "str", "dl", "ob", "id", "zip", "shell", "db", "log", "function", "nl", "SQL", "sl", "session", "string", "conn", "ls", "s", "seed", "ln", "pr", " SQL", "lock", "setup", "spec", "serial", "os", "sg", "ssl", "sq", "sb", "repl", "html", "ql", "printf", "ll", "join", "query", "sync", "general", "http", "l", "fn", "details", "statement", "sf", "comment", "select", "msg", "acl"], "idList": ["addressLIST", "idSet", "IdList", "IdTree", "userLIST", "dateList", "userSet", "idTree", "IdColl", "dateColl", "userList", " idColl", "IdSet", " idInfo", "dateInfo", "IdLIST", "userlist", "dateTree", "IdInfo", " idTree", "idlist", "idInfo", "addressList", "addresslist", "idLIST", "idColl", "addressSet", "Idlist"], "num": ["su", "sol", "result", "gen", "nb", "inc", "Num", "one", "nov", "um", "gru", "div", "index", "nom", "node", "nr", "nam", "uni", "umi", "multi", "off", "nn", "len", "no", "np", "hex", "dim", "mon", "miss", "numbered", "norm", "i", "count", "NUM", "number", "n", "nu", "mult", "oct", "loc", "ord", "begin", "lang", "sn", "du", "dom", "form", "mn", "non", "fn", "init", "pos", "coord", "loop", "con", "lim", "unit", "sum", "size", "zero", "uu", "temp"], "i1": ["I1", " i11", "I5", "i81", "I0", "ii11", "xi81", "ii4", "I81", " i81", "xi11", " i0", "ci0", "i0", "ii81", "i4", "i11", "xi4", " i4", "ii1", "i5", " i5", "ci5", "ci1", "xi1", "ci81"]}}
{"id1": "4593011", "id2": "19147281", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 1, "substitutes": {"loadDDL": ["LoadCDE", "loadDDE", "loadODL", "LoadDDLL", "loadSDLL", "loadCDML", "loadSDE", "loadODLL", "loadCDL", "loadODML", "LoadDDML", "loadSDML", "LoadDDE", "loadDDLL", "loadODE", "LoadDDL", "LoadCDL", "LoadCDLL", "LoadCDML", "loadSDL", "loadDDML", "loadCDLL", "loadCDE"], "stmt": ["stm", "constm", "Stmd", " stm", " stmn", "Stmp", " sttr", " stgr", "sttt", "Stm", "STtr", "Sttt", "rm", "estmt", "rdb", "rmt", "rmd", "tmt", "constmt", "esttt", "tmd", "STmp", "estmd", "strgr", "Stdb", "stmd", " stdb", "constmn", "Stmb", " sttt", "estm", "tdb", "Stmn", "estmp", "stmr", "STmb", "strmt", "stpr", "stmn", "STgr", "tm", "STpr", "sttr", "Stmr", " stpr", "STmr", "constdb", "stmp", "Stmt", "STmt", "strpr", "stgr", "strtr", "stmb", "estmr", "estmb", " stmd", "stdb"], "qry": ["quri", "qries", "equry", " qury", "Qries", "quries", "qurys", "qrys", "eqRY", "Qry", "qRY", " qrys", "quury", "qury", "qri", " qri", " qries", "quRY", "eqry", " qRY", "Qri", "Qrys", "eqrys"], "q": ["v", "k", " p", "e", "id", "requ", "request", " query", "queue", "c", "Q", " sq", "t", "sq", "i", "r", "dq", "ql", "b", "iq", "n", "query", "config", "qq", " req", "qu", "p", "key", "qa", "ch", "qs", "eq", "qt", "d", "req", "quant", "quest", "select", "f"]}}
{"id1": "19868933", "id2": "7545002", "code1": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "code2": "    public static String POST(String url, String[][] props) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        for (int i = 0; i < props.length; ++i) {\n            conn.addRequestProperty(props[i][0], props[i][1]);\n        }\n        conn.connect();\n        try {\n            return new String((byte[]) conn.getContent());\n        } finally {\n            conn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"copyFromFileToFileUsingNIO": ["copyFromFileToFileUsingnFile", "copyFromFileToFileWithNFile", "copyFromFileToFileWithFileChannel", "copyFromFileToFileUsingnIO", "copyFromFileToFileUsingNetio", "copyFromFileToFileUsingFileIO", "copyFromFileToFileUsingNio", "copyFromFileToFileWithFileio", "copyFromFileToFileUsingNetFile", "copyFromFileToFileWithNChannel", "copyFromFileToFileUsingNChannel", "copyFromFileToFileWithFileFile", "copyFromFileToFileUsingFileChannel", "copyFromFileToFileUsingnio", "copyFromFileToFileUsingFileio", "copyFromFileToFileWithNIO", "copyFromFileToFileUsingNFile", "copyFromFileToFileUsingnChannel", "copyFromFileToFileUsingFileFile", "copyFromFileToFileUsingNetIO", "copyFromFileToFileUsingNetChannel", "copyFromFileToFileWithNio", "copyFromFileToFileWithFileIO"], "inputFile": ["outputStream", "inputDir", "imagefile", " inputStream", "sourceStream", "InputDirectory", "InputDir", "imageFile", "InputFile", "inputStream", "sourceDir", " inputDirectory", " inputfile", "sourceFile", "outputfile", "imageStream", "sourceDirectory", "inputDirectory", " inputDir", "InputStream", "imageChannel", "inputfile"], "outputFile": ["OutputFile", "targetFiles", "outputStream", " outputStream", "targetFile", " outputDirectory", " outputfile", " outputFiles", "targetfile", "OutputStream", "inputStream", "targetPath", "inputPath", "OutputFiles", " outputPath", "outputFiles", "outputfile", "targetStream", "targetDirectory", "inputDirectory", "outputDirectory", "Outputfile", "outputPath"], "inputChannel": ["httpChan", "inputSocket", "Inputchannel", "outputStream", "outputCh", "InputListener", "outputChan", "inputChan", "parentChannel", " inputListener", "parentSocket", " inputStream", "outputchannel", "parentChan", " inputchannel", "InputChannel", " inputChan", "parentFile", "outputSocket", "InputFile", "inputStream", "inputchannel", "httpChannel", "InputCh", "inputListener", "httpSocket", "httpCh", "InputSocket", "InputChan", "outputListener", "parentStream", "inputCh", " inputSocket", "InputStream"], "outputChannel": ["OutputFile", "OutputChan", "outputStream", "outputChan", "inputChan", " outputStream", "OutputChannel", " outputConnection", "outChan", " outputChan", "outputConnection", "outStream", "OutputStream", "outputSocket", "inputConnection", "inputStream", "OutputSocket", "OutputConnection", "outSocket", " outputSocket", "outChannel"]}}
{"id1": "16378239", "id2": "19251426", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"byReference": ["orReference", "ofExternal", "ByExternal", "ByReference", "orref", "Byref", "ofReference", "toExternal", "ByLink", "toLink", "ofref", "toref", "toReference", "orExternal", "orLink", "ofLink"], "inputStream": ["outputString", "outputStream", "inputString", "inputSteam", "tempReader", " inputstream", "tempSteam", "inputFile", " inputString", "inSteam", "InputObject", "InputString", "InputFile", "outputSteam", "inStream", "inputObject", "Inputstream", " inputObject", "outputstream", "tempStream", "tempstream", "inputReader", "InputSteam", "inputstream", "outputObject", "InputReader", "inReader", "InputStream", "instream", "outputFile"], "tempFile": ["TempFiles", "fakePage", " tempStream", "tmpDir", "fakefile", "fakeF", " tempDir", "TempFile", "fakeDir", "tmpF", " tempContent", "tmpStream", " tempF", "tempDir", "tmpContent", "tempPage", "tmpFile", "tempContent", " tempFiles", "tmpPage", "Tempfile", "fakeFiles", " tempPage", "tempStream", "tempF", "tempFiles", "tempfile", "tmpfile", "fakeStream", "tmpFiles", " tempfile", "fakeFile", "TempContent"], "out": ["exec", "url", "result", "base", "OUT", "client", "outs", "output", "io", "path", "conn", "obj", "ext", "to", "image", "err", "write", "this", "Out", "plain", "extra", "writer", "connection", "a", "user", "null", "object", "again", "ex", "o", " in", "sync", "outer", "array", "resource", "flush", "copy", "in", "line", "data", "source", "file", "server", "pool", "init", "instance", "later", "part", "f", "temp"]}}
{"id1": "647224", "id2": "16142024", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"uploadFile": ["Uploadfile", "processFiles", "uploadDir", "processDir", "processFile", "UploadFile", " uploadDir", "UploadDir", "UploadFiles", " uploadFiles", "processfile", "uploadfile", "uploadFiles", " uploadfile"], "inputFile": ["targetFiles", " inputType", "inputLog", "sourceType", "initialFile", "targetFolder", "inputDir", " inputStream", "sourceStream", "targetDir", "Inputfile", "sourceFolder", " inputFiles", "sourcePage", " inputPage", "targetFilename", "InputDir", "inputPage", "initialStream", "targetfile", "sourceLog", "InputFile", "targetLog", "inputStream", "InputFiles", "InputFolder", "sourcefile", " inputfile", "targetPage", "sourceFile", "inputFiles", " inputFolder", "targetStream", "InputType", "inputFilename", " inputDir", " inputLog", " inputFilename", "inputType", "initialFolder", "inputFolder", "initialFilename", "InputStream", "inputfile"], "targetFile": ["targetName", "targetFiles", "outputDir", "outputName", "inputDir", " targetPlace", "targetDir", " targetLine", "TargetPath", " targetfile", " targetFiles", "Targetfile", "TargetFile", "targetfile", "externalfile", " targetDir", " targetPath", "sourcePath", "targetLine", "sourceDir", "targetPath", "inputPath", "sourceFile", "outputFiles", "externalPath", "externalName", "TargetLine", "TargetFiles", "inputPlace", "outputLine", "TargetDir", "externalFile", "TargetName", " targetName", "sourcePlace", "targetPlace", "outputPath"], "outputFile": ["OutputFile", " outputDir", "targetFiles", "outputDir", "outputStream", "outputFolder", "writeStream", " targetDirectory", "inputDir", "outFolder", " outputStream", "OutputFolder", " targetFiles", " outputDirectory", " outputfile", " outputFiles", "inputPage", "targetQueue", "outputUrl", "targetfile", "outputPage", "outFile", "OutputDir", "writeUrl", " targetQueue", "inputStream", "outDirectory", "targetPath", " outputPlace", "inputPath", "outputPlace", "inputFiles", " outputFolder", " outputPath", "currentFolder", "outputFiles", "outputfile", "writeFile", "targetDirectory", " outputPage", " outputUrl", "inputUrl", "outfile", "inputDirectory", "outPath", "currentPlace", "outPlace", "outputDirectory", "inputQueue", "currentFile", "outputQueue", "currentfile", "Outputfile", "writePage", "inputFolder", "inputfile", "outputPath"], "in": ["url", "ins", "din", "reader", "IN", "login", "bin", "id", "io", "inc", "isin", "sub", "ini", "input", "issue", "In", "s", "inner", "stream", "err", "read", "i", "r", "again", "rec", "pull", "diff", "nin", "win", "inn", "pin", "is", "lin", "data", "up", "cin", "init", "inside", "kin", "source", "rin", "pass", "con", "ac", "serv"], "out": ["sys", "ger", "net", "exec", "base", "error", "OUT", "console", "outs", "cache", "client", "output", "bin", "io", "inc", "one", "log", "conn", "state", "s", "cmd", "inner", "ext", "to", "lock", "err", "write", "off", "image", "this", "Out", "plain", "writer", "print", "report", "user", "r", "ex", "n", "again", "o", "println", "co", "sync", "table", "outer", "by", "point", "copy", "page", "data", "file", "up", "source", "dump", "inter"], "line": ["url", "lc", "base", "header", "error", "job", "e", "le", "log", "row", "string", "name", "Line", "lines", "word", "range", "lock", "write", "link", "code", "LINE", "type", "pe", "rule", "block", "sync", "buffer", "lf", "page", "lin", "data", "entry", "char", "inline", "file", "limit", "frame", "pass", "split", "unit", "ine", "part", "comment", "cell"], "bytes": ["classes", "outs", "groups", "Bytes", "eps", "cycles", "seconds", "steps", "zip", "ines", "es", "odes", "length", "values", "s", "lines", "ls", "binary", "len", "tes", "files", "bps", "os", "code", " lines", "ones", "words", "comments", "items", "i", "count", "rows", "number", "bits", "blocks", "les", "ips", "pages", " cycles", "units", "pos", "reads", "bs", "size", "codes"]}}
{"id1": "12380475", "id2": "7908169", "code1": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"transport": ["ransprocess", " transports", "protmission", "transmission", "ransport", " transprocess", "transpoint", "protprocess", "protports", "ransporter", " transmission", "ranspoint", "protpoint", " transporter", "transports", "transporter", "protport", "ransmission", " transpoint", "protporter", "transprocess", "ransports"], "file": ["fp", "url", "FILE", "base", "reader", "cache", "change", "project", "local", "handle", "e", "use", "io", "model", "db", "path", "folder", "log", "filename", "auto", "name", "out", "string", "stream", "queue", "image", "ile", "File", "type", "connection", "info", "class", "user", "route", "directory", "object", "parent", "handler", "socket", "service", "resource", "content", "document", "http", "single", "page", "data", "source", "channel", "dir", "server", "entry", "line", "full", "comment", "f"], "files": ["objects", "ins", "classes", "flows", "iles", "ions", "users", "ls", "s", "cells", "lines", "results", "sites", "items", "models", "images", "facts", "ups", "issues", "headers", "boxes", "events", "blocks", "fs", "views", "books", "Files", "pages", "ums", "phones", "dir", "thumbnails", "keys", "names", "bs", "balls", "pes", "f", "features"], "i": ["v", "k", "ip", "ai", "ti", "vi", "I", "e", "id", "io", "xi", "x", "ini", "index", "end", "u", "li", "ui", "hi", "multi", "c", "ci", "si", "mi", "ii", "m", "j", "info", "b", "n", "o", "slice", "ri", "uri", "p", "it", "key", "h", "abi", "col", "oi", "di", "ni", "d", "chi", "f", "pi"], "inChannel": ["InMessage", "inputChan", " inchannel", "inChan", "InStream", "InFile", " inFile", "InChannel", " inCh", "inFile", "inchannel", "outchannel", "outMessage", "outStream", "outFile", "inputStream", " inStream", "inCh", "inStream", " inMessage", "inMessage", " inChan", "InChan", "inputCh", "Inchannel", "InCh", "inputChannel"], "outChannel": ["Outchannel", " outConnection", "inChan", " outChan", "OutStream", "ioHandler", "outChan", "ioConnection", "inchannel", "outchannel", "outStream", "outConnection", "inHandler", "ioChan", "inStream", " outStream", "ioChannel", "inConnection", " outchannel", "OutChan", " outHandler", "OutChannel", "outHandler"]}}
{"id1": "9272325", "id2": "2465747", "code1": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 0, "substitutes": {"sendPost": ["postpost", "postPOST", "sendPOST", "dopost", "sendpost", "doPOST", "SendMethod", "sendMethod", "Sendpost", "doMethod", "doPost", "SendPOST", "postMethod", "postPost", "SendPost"], "reqUrl": ["requestLine", " reqRoute", "reqURL", "downloadEmail", "requUrl", "downloadUrl", "requestUr", "requestEmail", "downloadURL", "reqLine", "requLine", "requURL", "requUr", "requestRoute", "downloadLine", "requestURL", "requEmail", "reqEmail", "requestUrl", " reqURL", "reqRoute", "requRoute", "reqUr", " reqUr"], "parameters": ["paramsams", "paramsations", "pareters", "arameter", "parations", "paramams", "paramations", "paramseter", "paramsParameters", "mandeter", "parameter", "aramams", "mandeters", "mandParameters", "arameters", "paramseters", "pareter", "mandations", "parParameters", "paramParameters"], "urlConn": ["URLConnect", "urlConnect", "reqComm", "webConnection", " urlConnect", "obConnection", "buildConnector", "lconn", "returnConn", "httpExec", "elConnect", "webContainer", "buildConnection", "baseConnection", "blogConnection", "logConnect", "buildConn", "urlConnection", "blogContainer", "elCon", "returnConnect", "httpConn", "bbCon", "URLClose", "bbConnection", "logCon", "webCon", "urlReg", " urlConnection", "webconn", "httpSync", "userConn", "baseConn", "userConnect", " urlconn", "returnCon", "httpCon", " urlReg", "urlContainer", "urlExec", "returnConnection", "webConn", "userConnection", " urlContainer", "baseConnect", "lComm", "lConn", "bbConn", "obReg", "elConn", "httpConnect", "urlSync", "webSync", " urlSync", "urlComm", "URLConn", "blogConn", "webClose", "baseCon", "logConnection", " urlInfo", "urlCon", "urlConnector", "webExec", "httpConnector", "httpComm", "URLconn", "obConnect", " urlClose", "httpReg", "reqConnection", "bbConnector", " urlCon", "httpConnection", "httpconn", "urlconn", "reqConn", "logConn", "lConnection", "elConnection", "webConnect", "buildCon", "urlInfo", "httpInfo", "blogCon", "urlClose", " urlExec", "obConn", "reqconn", "userInfo"], "params": ["posts", "Param", "tmp", "URL", "tags", "Parameters", "_", "request", "Url", "res", "string", "s", "Par", "param", "lines", "prefix", "resources", "database", "bps", "properties", "options", "par", "body", "ps", "query", "config", "apps", "uri", "parts", "api", "array", "bytes", "http", "ams", "l", "data", "pages", "req", "json", "points", "names", "manager", "rules", "response", "settings"], "url": ["lc", "base", "job", "ob", "URL", "path", "log", "sl", "Url", "host", "Config", "string", "conn", "ls", "obj", "gl", "c", "orb", "layer", "ssl", "i", "r", "connection", "n", "ll", "www", "config", "loc", "ur", "lr", "uri", "api", "resource", "bel", "http", "l", " URL", "data", "page", "server", "source", "web", "rl", "blog", "f"], "b": ["v", "base", "bb", "ob", "gb", "e", "bin", "br", "bd", "nb", "emb", "db", "boot", "ba", "fb", "mb", "binary", "obj", "c", "bl", "buff", "a", "i", "r", "lb", "sb", "null", "buf", "body", "bar", "wb", "buffer", "ab", "bytes", "rb", "l", "data", "pb", "B", "bf", "bs", "f"]}}
{"id1": "539195", "id2": "13783549", "code1": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["csv", "change", "delete", "paste", "rm", "transfer", "php", "zip", "io", "load", "Copy", "put", "replace", "py", "cp", "write", " cp", "cop", "it", "get", "file", "download", "create", "split", "cat", "clone", "opy", "cmp"], "src": ["sys", "url", "sit", "img", "sup", "gb", "id", "sub", "cur", "path", "remote", "sl", "target", "filename", "string", "name", "s", "secure", "stream", "archive", "image", "upload", "ruby", "code", "sel", "ssl", "sb", "desc", "sin", "config", "loc", "sync", "slice", "inst", "uri", "resource", "rb", "rc", "href", "source", "sc", "file", "dist", "RC", "txt", "rs"], "dest": ["rest", "test", "prop", "delete", "output", "tmp", "comb", "replace", "folder", "default", "target", "filename", "flat", "end", "them", "Dest", "dat", "orig", "desc", "const", "text", "tern", "loc", "slice", "wb", "done", "du", "wd", "feat", "source", "data", "destroy", "dir", "dist", "d", " destination", "coord", "die", "later", "home", "opt", "txt", " Dest", "buff", "temp"], "ifp": [" ifpp", "dfb", "ppp", "upcp", "upp", " ifb", "ifpp", "ifo", "Iftp", "ifpa", "ifcp", "ipli", "ipltp", "ifb", "pppa", "IFo", "Ifi", "ibi", " ifo", "iplp", "dfpa", "ifi", " ifap", "IFpp", "ibpa", "IFp", "ibp", " ifcp", "iftp", "dfp", "ppap", "dfap", "ifap", "ibtp", "ppb", " ifpa", "uppp", "Ifp", "iplpa", "upo", "Ifpa", "IFcp"], "ofp": ["ippy", "ofy", "ippps", "OFps", " ofc", "Ofp", " ofy", "ippp", "OFp", "off", "ofi", "ofc", " ofps", " off", "ovc", "ippc", "Ofi", "ovi", "ovp", "OFc", "OFy", "Off", " ofi", "Ofc", "ovf", "ofps"], "fis": ["his", "hps", "fais", " fiss", "fus", "cfis", "flis", " fais", "fls", "fps", "cfi", " fbis", "infis", "cfais", "hus", " fi", " fps", "infiss", "ofos", "hs", "cfiss", "flps", "ofbis", "cfbis", " fus", "fbis", "fs", " fs", "fiss", "fi", "ofais", "cfos", "ofis", "infi", "infos", "flus"], "fos": ["foes", "fpos", "poes", "poses", "ifops", "bis", "Foses", " foses", "Fos", "Fis", "fios", " fops", "bpos", "Foes", "bos", "pis", "Fios", "bops", "bios", "foser", "ifis", "ifoser", " fpos", " fios", "Fpos", "fops", "foses", "pos", " foes", "boser", "ifos", " foser"], "b": ["v", "base", "xb", "ib", "bb", "ob", "gb", "e", "br", "nb", "emb", "bis", "db", "boot", "ba", "mb", "binary", "c", "bound", "buff", "sb", "i", "a", "lb", "r", "buf", "bi", "abb", "wb", "buffer", "ab", "eb", "p", "rb", "h", "l", "d", "B", "bf", "bs", "f"]}}
{"id1": "12128591", "id2": "5441579", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "label": 1, "substitutes": {"hash": [" fingerprint", "str", "parse", "check", "Hash", "log", "hex", "build", "code", "SHA", "component", "crypt", " hashes", "print", "text", "update", "pack", " hashing", " Hash", "add", "get", "copy", "h", "dump", "sum"], "data": ["address", "template", "result", "base", "cache", "str", "output", "DATA", "input", "string", "name", "s", "length", "memory", "image", "missing", "hex", "database", "format", "a", "info", "connection", "class", "dat", "text", "body", "pad", "padding", "buffer", "message", "media", "alpha", "api", "p", "bytes", "content", "in", "source", "style", "value", "response"], "digest": ["peder", "digit", "signEST", " digusher", "signest", "decests", "logast", "logenge", "mdast", "bigest", "generit", " digests", "pede", "Digenge", "digast", "logester", "bigger", "Digger", "digenge", "mdest", "digEST", "bigester", " digester", "generests", "digester", " digEST", "decit", "decest", "decester", "Dige", "digusher", "pedester", "digests", "bigusher", "Digusher", " digit", "pedest", "DigEST", " dige", "Diger", "Digester", "dige", "signester", "diger", "Digest", " diger", "digger", "logest", "Digast", "generester", "mdenge", " digger", "generest", "signusher", "mdester"]}}
{"id1": "1362", "id2": "8490710", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubbleOrder", "bubblesort", "bubblerSort", "ubblesort", "ubbleOrder", "ubblingOrder", "bubblingCompare", "bubblingSort", "ubbleCompare", "ubblingSort", "bubbleCompare", "bubblingsort", "ubblingsort", "bubblessort", "bubblingOrder", "bubblesOrder", "ubbleSort", "bubblersort", "ubblingCompare", "bubblerCompare", "bubblesSort", "bubblerOrder", "bubblesCompare"], "a": ["an", "ga", "aaa", "address", "result", "img", "ata", "aw", "sup", "aux", "e", "am", "ba", "index", "abs", "ama", "A", "something", "auto", "s", "u", "another", "c", "sa", "aj", "m", "all", "au", "at", "active", "b", "empty", "any", "o", "ans", "aa", "list", "ma", "alpha", "la", "ab", "ae", "array", "p", "apps", "ad", "access", "tta", "l", "na", "data", "oa", "work", "d", "ac", "area", "f", "ack", "as", "va"], "swapped": ["rewapping", "Swapped", "waps", "swaps", "waped", "Swoped", "wapping", "rewaped", "rewapped", " swaps", "rewoped", "flapping", " swap", "rewaps", "wapped", "flapped", "rewap", "floped", " swapping", "swapping", "Swapping", "wap", "flap", "swap", "Swap", "Swaped", "swoped", "swaped", " swaped"], "i": ["qi", "v", "k", "iv", "ip", "ai", "sup", "ti", "mini", "I", "e", "ami", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "start", "ind", "u", "ui", "li", "hi", "multi", "ci", "next", "anti", "uni", "si", "mi", "ii", "y", "m", "j", "adi", "ie", "info", "ori", "b", "ki", "bi", "ri", "uri", "api", "p", "key", "gi", "h", "ix", "it", "fi", "in", "oi", "l", "di", "init", "ni", "d", "f", "pi", "module"], "tmp": ["foo", "emp", "v", "stuff", " ff", "test", "xxx", "st", "amp", "sup", "bb", "opp", "yy", "pre", "nb", "tt", "vt", "x", "tc", "obj", "angle", "kk", "m", "t", "j", "ie", "prev", "b", "front", "tv", "dest", "pad", "qq", "alpha", "p", "mmm", "addr", "append", "pp", "area", "part", "txt", "f", "mp", "cmp", "temp"]}}
{"id1": "14865947", "id2": "13565787", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "label": 1, "substitutes": {"execute": ["exec", "complete", "test", "send", "call", "transfer", "invoke", "load", "command", "start", "action", "launch", "task", "message", "evaluate", "Submit", "ute", "submit", "process", "create", "loop", "open", "exit", "run", " executing"], "event": ["exec", "test", "v", "exc", "Event", "x", "ents", "te", "context", "ext", "image", "ec", "t", "ent", "g", "ex", "object", " EVENT", "vent", "message", "events", "other", " events", "ev", " Event", "ctx", "f"], "shell": ["exec", "sole", "sol", "cl", " Shell", "Shell", "console", "system", "lex", "window", "el", "site", "child", "model", "tools", "cel", "xml", "log", "nl", "environment", "sl", "session", "sql", "ui", "prof", "cmd", "lock", "bot", "lib", "build", "sb", "live", "bash", "null", "kernel", "ll", "gui", "o", "edit", "layout", "sync", "il", "mail", "search", "math", "cli", "l", "sh", "pool", "tty", "server", "help", "pty", "loop", "ml", "home", "dll", "hell", "tool", "cell"], "view": ["flow", "v", " overview", "url", "console", "window", "visual", "model", "container", "VIEW", "plugin", "row", "session", "screen", "ui", "View", "image", "lock", "widget", "sel", " layout", "show", "user", "object", "gui", "list", "layout", " preview", "tree", "display", "service", "views", "version", "iew", "page", "review", "l", "pool", "control", "summary", "web", "book", "f"], "rootFolder": ["rootDirectory", "mainOrg", " rootWindow", "shellWindow", "homeFolder", "parentDirectory", "RootOrg", "mainfolder", "homeCenter", "shellArea", "bottomFolder", "rootOrg", " rootDirectory", "rootCenter", "parentFlow", "rootWindow", " rootArea", "RootDirectory", "RootWindow", "rootFlow", "mainFile", "parentFile", "parentZip", "rootZip", "parentFolder", "RootFolder", " rootZip", "shellFolder", "bottomFlow", "RootZip", "rootArea", " rootfolder", "bottomDirectory", "RootArea", "rootDir", " rootFlow", "RootFile", "rootfolder", "shellDir", "bottomFile", "rootFile", "RootDir", " rootFile", " rootCenter", "mainFolder", " rootDir", "RootCenter", "homeDirectory", " rootOrg", "Rootfolder"], "dialog": ["logogg", "clogg", "protog", "dialogs", "dialogging", "challogue", "logogue", "challect", "diffogue", "logogs", "logog", "challogg", "clog", "challock", "clect", "protect", "diffog", "clogs", "dialect", "challog", "logOG", "dialDialog", "challDialog", "challogs", "clOG", "logDialog", "clogging", "logock", "protogging", "protogg", "challogging", "dialock", "dialOG", "challOG", "dialogue", "diffock", "dialogg", "diffDialog"], "password": ["picture", "hash", "encrypted", "address", "params", "account", "column", "token", "Password", "description", "sword", "command", "volume", "path", "wallet", "session", "patch", "pattern", "string", "language", "name", "cmd", "word", "prefix", "database", "auth", "words", "username", "mode", "crypt", "connection", "confirmed", "definition", "root", "text", "directory", "handler", "config", "diff", "pad", "padding", "message", "resource", "p", "wd", "key", "content", "pg", "phrase", "page", "mac", "data", "channel", "source", "PASS", "secret", "email", "device", "pass", "value", "sum", "size"], "md5": ["mand2", "dd5", "mg5", "MD50", "MD40", "MD512", "dd2", "dd50", "mg40", " mddown", "mddown", "mand5", "md512", "cmd4", "MD4", "MD2", "mg2", "md40", "mand512", " md512", "md2", "MDdown", "mand15", "MD15", " md2", "cmd5", "dd40", "cmd512", "mg50", "md15", "manddown", " md4", "md4", "MD5", "cmd2", "md50", " md15"], "md": ["MD", "hash", " Md", "mc", "sha", "dig", "ms", "metadata", "pm", "bd", "amd", "df", "mo", "meta", " cmd", "mb", "cmd", "M", "pkg", "sm", "mand", "m", "dd", "mode", "html", " dd", " mm", " digest", "sd", "od", "mg", " sd", "mm", "ma", "ad", "pd", " ma", "cd", "kg", "wd", "nd", "mac", "mod", "d", "mag", "nm", "bf", "dm", "sum", " MD", "mp", "msg"]}}
{"id1": "19849797", "id2": "17773263", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 0, "substitutes": {"copyFile": ["clonefile", "copyFiles", "transferfile", "copySource", "cloneFiles", "transferSource", " copySource", "transferFiles", " copyfile", "cloneSource", "transferFile", "copyfile", "cloneFile", " copyFiles"], "sourceFile": [" sourceDir", "ourceDirectory", "sourceUrl", "ourceUrl", "srcDir", "srcFile", " sourceFolder", "sourceFolder", "ourceFile", "SourceUrl", "srcfile", " sourcefile", "destfile", "SourceDirectory", "SourceFile", "ourcefile", "sourcefile", "sourceDirectory", "srcFolder", "destUrl", "Sourcefile", "SourceFolder", "destDirectory", "sourceDir", "SourceDir"], "destFile": ["destFiles", "targetFiles", "sourceFiles", "resultDir", "destLine", "DestFiles", " destfile", "destDir", "destPoint", "DestDirectory", "resultfile", "Destfile", "srcFile", "srcDir", "targetDir", "targetFile", "foreignFile", "srcfile", "foreignPath", "DestFile", "destPath", "targetfile", "DestPoint", "destfile", "targetLine", " destFiles", "targetPath", "foreignFiles", "resultFile", "DestDir", " destPoint", "foreignfile", " destDir", "srcDirectory", " destDirectory", "DestPath", "resultLine", "sourcePoint", "destDirectory", "srcFiles", "sourceDir", "srcLine"], "source": ["ource", "slave", "url", "result", "client", "reader", "cache", "status", "scope", "output", "site", "use", "id", "view", "current", "proxy", "scene", "index", "input", "target", "session", "start", "context", "core", "seed", "remote", "stream", "inner", "secure", "image", "Source", "this", "si", "storage", "component", "reference", "connection", "ie", "root", "route", "null", "object", "parent", "sin", "dest", "config", "slice", "table", "uri", "service", "resource", "api", "wrapper", "iter", "get", "from", "channel", "file", "server", "src", "unit", "size", "manager", "ce", "SOURCE"], "destination": ["participinate", "destinator", "generination", "Destinated", "dominated", "constinator", "identination", "distination", "construction", "distion", "participinator", "Destination", "domination", " destribution", "constribution", "domation", "Destribution", "Destruction", "destribution", " destinator", "destation", "Destation", "generruction", "destion", "identinator", "destinate", " destruction", "participinated", " destinated", " destation", "destinated", "participination", "distruction", "destruction", "dominator", "distinated", "distinator", "Destion", " destion", "Destinate", "constination", "generinator", "identinate", "generinated", "Destinator", "identinated"]}}
{"id1": "13122204", "id2": "3024992", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["UnzipModel", "unzipmodel", "unarchiveProject", "Unzipmodel", "unpatchmodel", "unarchivemodel", "unarchiveModel", "UnarchiveFile", "UnarchiveProject", "unpatchFile", "UnzipFile", "unpatchProject", "unzipFile", "unarchiveFile", "UnzipProject", "unzipProject", "unpackmodel", "UnarchiveModel", "unpackProject", "unpackModel", "unpackFile", "unpatchModel", "Unarchivemodel"], "filename": ["fp", "url", "FILE", "title", "fil", "kl", "model", "path", "folder", "utf", "nil", "location", "string", "name", "database", "files", "jet", "username", "SourceFile", "File", "directory", "loc", "fits", "uri", "fd", "l", "source", "fn", "file", "download", "src", "bf", "txt", "Filename", "f", "il", "module"], "tempdir": ["tmpdirectory", "Tempdirectory", " tempfolder", "tmpDir", " tempDir", "temdir", "TempDir", "temfolder", "tempDir", "temppath", "tmpfolder", "tempfolder", "temDir", "Tempdir", "tmpDIR", " tempdirectory", "TempDIR", "tmppath", " temppath", "Tempfolder", "tempDIR", "temdirectory", "tempdirectory", " tempDIR", "tmpdir", "tempath"], "dest": ["rest", "test", "result", "de", "cont", "st", "sup", "prop", "gen", "delete", "builder", "output", "transfer", "tmp", "zip", "exit", "comb", "proc", "folder", "log", "walk", "default", "export", "target", "flat", "session", "ui", "obj", "inner", "tar", "std", "Dest", "transform", "dat", "desc", "cdn", "handler", "loc", "walker", "nt", "sync", "wb", "done", "dc", "store", "di", "source", "file", "usr", "dist", "dir", "src", "die", "later", "home", "trans", "opt", "txt", " Dest", "temp"], "fis": ["filebis", " fiss", "flisa", "fid", "flis", "liss", "fliss", "fileisa", "fsisa", "fsbis", " fi", "fileis", "li", "lid", "fileid", "fsiss", " fid", "fsis", "filei", "lis", "fbis", "fiss", "fileiss", "fi", "flbis", "fisa"], "BUFFER": ["UPFF", " BUVER", "SAPER", "BUUCK", "BUFER", "BUFF", "CUVER", "TAPER", "BOFFER", "BOPER", "CUUCK", "SAUCK", "CUFFER", "TAVER", "UPFFER", " BUFER", " BUVEN", "CUVEN", "CUPER", " BUFIX", "BOFIX", "CUFF", "SAFFER", "TAFFER", "MAFIX", " BUFF", "MAPER", "BUPER", " BUUCK", "BUFIX", "UPVEN", "BUVEN", "MAFER", "MAFFER", "BOFER", "SAVER", " BUPER", "UPVER", "BUVER", "TAUCK"], "zis": ["zipis", " zists", " zbis", "zipisa", " zisa", "xiss", "diss", " zii", "zins", "Zas", "xis", " zos", "zin", "zii", "xi", "Zisa", " ziss", "zas", " zIS", "yis", "zipIS", "zipas", "zos", "zists", "Zins", "xii", "yin", " zin", "jos", "yIS", "jists", "zi", "Zis", "xos", "jis", "zipins", "dis", "zIS", "yisa", "xists", "zbis", "dbis", "zisa", " zas", "xbis", "dii", " zins", "ji", "zipin", " zi", "ziss"], "entry": ["de", "result", "lc", "reader", "enter", "e", "id", "zip", "feed", "inc", "ace", "ou", "valid", "cel", "je", "ge", "row", "name", "end", "li", "inner", "archive", "image", "next", "spec", "si", "or", "element", "ie", "info", "way", "pe", "ent", "connection", "Entry", "nt", "porter", "her", "pack", "la", "iterator", "jo", "rc", "line", "file", "ry", "se", "match", "source", "server", "ident", "ries", "cat", "part", "record", "ce", "module"], "count": ["base", "cache", "allow", "e", "use", "id", "feed", "current", "_", "Count", "log", "val", "index", "start", "length", "name", "max", "time", "end", "core", "ind", "c", "write", "len", "next", "code", "read", "type", "writer", "i", "counter", "b", "number", "list", "weight", "cond", "buffer", "iter", "add", "key", "line", "in", "file", "last", "low", "pos", "limit", "coll", "part", "sum", "size", "f"], "data": ["result", "base", "reader", "str", "id", "feed", "load", "raw", "DATA", "index", "input", "start", "length", "name", "image", "next", "write", "size", "len", "read", "format", "a", "info", "batch", "dat", "number", "body", "block", "message", "pack", "buffer", "media", "array", "bytes", "alpha", "content", "la", "shift", "pos", "d", "value", "record", "zero"], "fos": ["foes", "dfoes", "fOS", "dfoos", "afos", " foos", "xoes", "afOS", "bis", "xoos", "bOS", " fOS", "dfos", " fops", "afis", "bos", "dfops", "bops", "xos", "fops", " foes", "xops", "afops", "foos"]}}
{"id1": "9954926", "id2": "7872659", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"simulate": ["simure", "Simulate", "animure", "simulator", "imulation", "imulate", "Simulator", "simulation", "animulator", "animulate", "imulator", "Simure", "Simulation", "animulation", "imure"], "out": ["external", "error", "outs", "cache", "gen", "window", "tmp", "raw", "log", "session", "name", "conn", "plain", "writer", "report", "null", "post", "flush", "data", "server", "full", "group", "part", "client", "db", "string", "state", "word", "lock", "write", "prefix", "down", "Out", "user", "object", "o", "buffer", "key", "store", "in", "page", "cli", "pool", "dump", "comment", "exit", "net", "result", "base", "OUT", "w", "now", "io", "obj", "err", "lib", "info", "again", "parent", "list", "outer", "resource", "copy", "con", "temp", "sys", "flow", "output", "bin", "view", "exp", "pre", "ex", "co", "table", "point", "line", "up"], "file": ["fp", "url", "address", "FILE", "base", "cache", "output", "port", "feed", "path", "log", "filename", "name", "stream", "queue", "ile", "files", "fe", "File", "connection", "report", "pe", "b", "rule", "handler", "socket", "loader", "buffer", "message", "resource", "l", "line", "data", "in", "source", "page", "full", "collection", "unit", "book", "f", "le"], "obtainUserReputationRequest": ["obtainUserRepentionResponse", "obtainUserRepulationEntry", "obtainUserRepentionrequest", "obtainUserReputeResponse", "obtainUserComputeEntry", "obtainUserReputerequest", "obtainUserReputionGrant", "obtainUserRepigrationResponse", "obtainUserReputedResponse", "obtainUserRelutationGrant", "obtainUserRepigrationQuery", "obtainUserReputationEntry", "obtainUserAnnutationResponse", "obtainUserAnnutationQuery", "obtainUserReputationInfo", "obtainUserComputerequest", "obtainUserRepigrationrequest", "obtainUserReputionResponse", "obtainUserReputeRequest", "obtainUserRepentionGrant", "obtainUserRepigrationRequest", "obtainUserReputationrequest", "obtainUserAnnigrationQuery", "obtainUserRepositoryInfo", "obtainUserRelutationRequest", "obtainUserAnnigrationGrant", "obtainUserRelentionrequest", "obtainUserAnnutationRequest", "obtainUserRelutationResponse", "obtainUserReputeInfo", "obtainUserRepurationResponse", "obtainUserRelentionGrant", "obtainUserRepositoryRequest", "obtainUserAnnigrationRequest", "obtainUserRelentionResponse", "obtainUserComputationEntry", "obtainUserRelentionRequest", "obtainUserRepentionRequest", "obtainUserComputationInput", "obtainUserComputationRequest", "obtainUserComputeRequest", "obtainUserRepositoryrequest", "obtainUserRepurityInput", "obtainUserRepulationResponse", "obtainUserReputableResponse", "obtainUserReputeQuery", "obtainUserRepurationGrant", "obtainUserRepurationQuery", "obtainUserComputationInfo", "obtainUserComputationrequest", "obtainUserComputationResponse", "obtainUserReputablerequest", "obtainUserReputeEntry", "obtainUserAnnutationGrant", "obtainUserReputeGrant", "obtainUserRepurationRequest", "obtainUserComputeInfo", "obtainUserReputedrequest", "obtainUserReputedGrant", "obtainUserReputableRequest", "obtainUserReputionRequest", "obtainUserRepurityEntry", "obtainUserRepositoryResponse", "obtainUserRepurityRequest", "obtainUserRepigrationGrant", "obtainUserReputationInput", "obtainUserRelutationrequest", "obtainUserReputeInput", "obtainUserRepigrationInfo", "obtainUserReputationGrant", "obtainUserRepulationRequest", "obtainUserComputeInput", "obtainUserReputedRequest", "obtainUserRepurityResponse", "obtainUserRepulationInput", "obtainUserReputationQuery", "obtainUserReputionrequest", "obtainUserComputeResponse", "obtainUserAnnigrationResponse"], "obtainUserReputationResponse": ["obtainUserExputationRequest", "obtainUserRepurationResponse", "obtainUserRepurationRequest", "obtainUserReputationResp", "obtainUserRepositoryRequest", "obtainUserExpositoryRequest", "obtainUserReputeRequest", "obtainUserReputeResponse", "obtainUserRepositoryResponse", "obtainUserExputationResponse", "obtainUserExpositoryResponse", "obtainUserRepositoryResp", "obtainUserReputeResp", "obtainUserExputationResp", "obtainUserExpositoryResp", "obtainUserRepurationResp"], "rateUserRequest": ["issueCustomerForce", "rateUResponse", "rateMachineRequest", "ratedUserRequest", "ratedUserFunction", "issueCustomerQUEST", "RateFileResponse", "rateFileResult", "rateUCustomer", "gradeLineRequest", "ratedFileRequest", "rateUsageForce", "rateUsRequest", "gradeLineCustomer", "rateUsageResponse", "ratePostrequest", "ratedFileFunction", "rateFileQuery", "RateUserQUEST", "gradeUserRequest", "rateuserRequest", "rateCustomerRequest", "rateClientRequest", "rateUsageReturn", "rateLineQUEST", "rateUserQUEST", "rateLineQuery", "rateUsageQUEST", "rateHumanVersion", " rateuserQUEST", "rateUSERForce", "ratePostQUEST", "rateFileCommand", "rateUsForce", "ratePostRequest", "rateUsageGrant", "RateFileQUEST", "ratedUsageRequest", " rateuserRequest", "featureUserRequest", "rateUCommand", "rateUSERQUEST", " rateClientrequest", "rateUserVersion", " rateUserrequest", "rateLinerequest", "issueUserForce", "rateWordRequest", "rateServiceRequest", "rateUQuery", "rateFileFunction", " rateuserResponse", "rateUserReturn", "rateUError", "issueCustomerReturn", "rateUserCustomer", "rateApplicationUser", "rateClientGrant", "rateFilerequest", "rateUSERRequest", "rateLineResponse", "rateWordrequest", "rateUsageQuery", " rateApplicationRequest", "rateUsQUEST", "RateFilerequest", "ratedUsageForce", "ratedUsagerequest", "ratedUserForce", "featureMachineResult", "rateLineError", "rateMachineResult", " rateuserrequest", "rateApplicationQuery", "rateMachinerequest", " rateUserGrant", "rateUsageUser", "ratedFileQuery", "rateURequest", "rateuserQUEST", "rateUserGrant", "rateFileResponse", "ratedUsageQUEST", "ratePostResponse", "featureMachineRequest", "rateUFunction", "rateMachineVersion", "rateHumanrequest", "rateServiceQuery", " rateUserQuery", "RateUserrequest", "rateUserrequest", "rateFileVersion", "issueUserQUEST", "rateUserError", "rateUserUser", "rateUserQuery", "rateApplicationRequest", "featureUserResult", "rateUserCommand", "rateUsagerequest", "rateWordCustomer", "rateUsageRequest", "rateuserResponse", "ratedFileCommand", " rateApplicationResponse", "gradeLinerequest", "ratedUserQuery", "rateUserResult", "featureUserVersion", " rateClientGrant", " rateUserQUEST", "rateWordQuery", "RateUserRequest", "rateHumanResult", "rateCustomerQUEST", "rateHumanRequest", " rateClientRequest", "rateCustomerForce", "rateUsReturn", "rateWordError", "featureMachineVersion", "rateFileUser", "gradeUserCustomer", "rateUrequest", "ratedUserCommand", "featureMachinerequest", "rateServiceFunction", "issueUserRequest", "RateUserResponse", "ratedUserrequest", "ratedUsageQuery", "rateClientrequest", "rateUQUEST", "rateFileRequest", "rateUserFunction", "rateUSERrequest", "rateUserForce", "issueUserReturn", "featureUserrequest", "ratedUserQUEST", " rateApplicationQuery", "rateCustomerReturn", "rateServiceCommand", " rateUserUser", "rateLineRequest", "gradeUserError", "issueCustomerRequest", "gradeLineError", "RateFileRequest", "gradeUserrequest", " rateApplicationUser", "rateLineGrant", "rateUForce", "rateuserrequest", "rateLineCustomer", "rateApplicationResponse", "rateFileQUEST"], "rateUserResponse": ["rateUsersStatus", "rateUResponse", "rateTimeStatus", "rateUserReply", "rateFileResult", "RateTimeResp", "rateCustomStatus", " rateFileResult", " rateApplicationResp", " rateUReply", "RateUserStatus", "rateUResp", "rateTimeResponse", "rateCustomerRequest", " rateUResponse", " rateUserReply", "rateUresponse", "rateClientResp", "rateCustomResponse", "rateClientStatus", "rateUserResp", " rateFileResponse", "rateApplicationResp", "rateFileResp", " rateUserResp", "rateUsersResp", "rateUsersRequest", " rateApplicationData", "rateuserResult", "rateFileReply", "rateUserData", "RateUserResp", "rateUserCustomer", "rateUserReference", " rateUserresponse", "rateuserReference", "rateTimeCustomer", "rateUserStatus", "rateClientCustomer", "rateUserResource", "rateApplicationData", "rateuserReply", "rateUReply", "rateFileResponse", " rateUserResult", "rateCustomResp", " rateUResp", "rateuserStatus", "rateCustomerResponse", "rateCustomerData", "rateUserresponse", "rateuserResponse", " rateApplicationResponse", "rateUserResult", "rateFileStatus", "RateUserRequest", " rateUserData", " rateUserReference", "RateTimeResponse", "rateFileresponse", "rateuserResp", "rateuserresponse", "rateUsersResource", "RateTimeStatus", "rateApplicationReference", "rateuserData", "rateTimeResp", "rateCustomerResource", "RateUserResponse", "RateUserCustomer", " rateFileResp", "rateUsersResult", " rateUserStatus", " rateFileStatus", "rateUsersResponse", "RateTimeCustomer", " rateApplicationReference", "RateUserResource", "rateClientResponse", "rateCustomerReference", "rateCustomCustomer", "rateCustomerResp", "rateApplicationResponse", " rateUresponse"], "fis": [" fiss", "fris", " fIs", "bis", "sfris", "sfIs", "bIs", "FIs", "Fris", "bris", "biss", "fIs", "Fis", "Fiss", "sfiss", "fiss", " fris", "sfis"], "br": ["bc", "result", "reader", "str", "ob", "bp", "ber", "io", "arr", "brush", "ler", " tr", "res", "hr", "bridge", "fin", "cr", "err", "bro", "bl", "wr", "Br", "Reader", "bed", "r", "b", "browser", "buf", "body", "tr", "fr", "buffer", "lr", "rb", " fr", "dr", "BR", "ch", "gr", "ref", " bio", "sp", "sw", "bs", "pr"], "call": ["flow", "address", "url", "result", "cl", "voice", "cod", "str", "output", "e", "comment", "phone", "ell", "use", "load", "invoke", "throw", "check", "request", "xml", "input", "string", "name", "play", "Line", "contact", "c", "doc", "callback", "code", "type", "charge", "info", "Call", "cu", "user", "text", "body", "query", "co", "loc", "buffer", "message", "calling", "ck", "line", "data", "work", "sc", "push", "claim", "fax", "create", "roll", "cat", "called", "ack", "f", "response", "cell", "msg"]}}
{"id1": "647224", "id2": "2642914", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"uploadFile": ["Uploadfile", "processFiles", "uploadDir", "processDir", "processFile", "UploadFile", " uploadDir", "UploadDir", "UploadFiles", " uploadFiles", "processfile", "uploadfile", "uploadFiles", " uploadfile"], "inputFile": ["targetFiles", " inputType", "inputLog", "sourceType", "initialFile", "targetFolder", "inputDir", " inputStream", "sourceStream", "targetDir", "Inputfile", "sourceFolder", " inputFiles", "sourcePage", " inputPage", "targetFilename", "InputDir", "inputPage", "initialStream", "targetfile", "sourceLog", "InputFile", "targetLog", "inputStream", "InputFiles", "InputFolder", "sourcefile", " inputfile", "targetPage", "sourceFile", "inputFiles", " inputFolder", "targetStream", "InputType", "inputFilename", " inputDir", " inputLog", " inputFilename", "inputType", "initialFolder", "inputFolder", "initialFilename", "InputStream", "inputfile"], "targetFile": ["targetName", "targetFiles", "outputDir", "outputName", "inputDir", " targetPlace", "targetDir", " targetLine", "TargetPath", " targetfile", " targetFiles", "Targetfile", "TargetFile", "targetfile", "externalfile", " targetDir", " targetPath", "sourcePath", "targetLine", "sourceDir", "targetPath", "inputPath", "sourceFile", "outputFiles", "externalPath", "externalName", "TargetLine", "TargetFiles", "inputPlace", "outputLine", "TargetDir", "externalFile", "TargetName", " targetName", "sourcePlace", "targetPlace", "outputPath"], "outputFile": ["OutputFile", " outputDir", "targetFiles", "outputDir", "outputStream", "outputFolder", "writeStream", " targetDirectory", "inputDir", "outFolder", " outputStream", "OutputFolder", " targetFiles", " outputDirectory", " outputfile", " outputFiles", "inputPage", "targetQueue", "outputUrl", "targetfile", "outputPage", "outFile", "OutputDir", "writeUrl", " targetQueue", "inputStream", "outDirectory", "targetPath", " outputPlace", "inputPath", "outputPlace", "inputFiles", " outputFolder", " outputPath", "currentFolder", "outputFiles", "outputfile", "writeFile", "targetDirectory", " outputPage", " outputUrl", "inputUrl", "outfile", "inputDirectory", "outPath", "currentPlace", "outPlace", "outputDirectory", "inputQueue", "currentFile", "outputQueue", "currentfile", "Outputfile", "writePage", "inputFolder", "inputfile", "outputPath"], "in": ["url", "ins", "din", "reader", "IN", "login", "bin", "id", "io", "inc", "isin", "sub", "ini", "input", "issue", "In", "s", "inner", "stream", "err", "read", "i", "r", "again", "rec", "pull", "diff", "nin", "win", "inn", "pin", "is", "lin", "data", "up", "cin", "init", "inside", "kin", "source", "rin", "pass", "con", "ac", "serv"], "out": ["sys", "ger", "net", "exec", "base", "error", "OUT", "console", "outs", "cache", "client", "output", "bin", "io", "inc", "one", "log", "conn", "state", "s", "cmd", "inner", "ext", "to", "lock", "err", "write", "off", "image", "this", "Out", "plain", "writer", "print", "report", "user", "r", "ex", "n", "again", "o", "println", "co", "sync", "table", "outer", "by", "point", "copy", "page", "data", "file", "up", "source", "dump", "inter"], "line": ["url", "lc", "base", "header", "error", "job", "e", "le", "log", "row", "string", "name", "Line", "lines", "word", "range", "lock", "write", "link", "code", "LINE", "type", "pe", "rule", "block", "sync", "buffer", "lf", "page", "lin", "data", "entry", "char", "inline", "file", "limit", "frame", "pass", "split", "unit", "ine", "part", "comment", "cell"], "bytes": ["classes", "outs", "groups", "Bytes", "eps", "cycles", "seconds", "steps", "zip", "ines", "es", "odes", "length", "values", "s", "lines", "ls", "binary", "len", "tes", "files", "bps", "os", "code", " lines", "ones", "words", "comments", "items", "i", "count", "rows", "number", "bits", "blocks", "les", "ips", "pages", " cycles", "units", "pos", "reads", "bs", "size", "codes"]}}
{"id1": "7425022", "id2": "19251426", "code1": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"transferWSDL": ["transferSWSDDL", "transferWSDLS", "transferSWSDl", "transferWDDL", "transferWSDDL", "transferWsdL", "transferWsdLS", "transferWDDLS", "transferWDDl", "transferWDDDL", "transferWNDLS", "transferSWsdLS", "transferSWsdL", "transferWNDL", "transferWsdDL", "transferWNDDL", "transferWSDl", "transferWsdl", "transferWNDl", "transferSWsdl", "transferSWSDL", "transferSWsdDL", "transferSWSDLS"], "wsdlURL": ["wsslUrl", "wllURL", "wsdalPath", "wsdlFILE", "wssdPath", "wsdlURI", "wslUrl", "wdlPath", "wssdUrl", "wslPath", "wdlURL", "wsslURL", "wssdURL", "wdlUrl", "wsdalUrl", "wllFILE", "wllPath", "wsllPath", "wsdnFILE", "wslURL", "wsllUrl", "wsdalURL", "wllUrl", "wsdlUrl", "wsllURI", "wsslPath", "wsdnPath", "wsllFILE", "wssdFILE", "wdlFILE", "wsllURL", "wsdnURL", "wsdlPath", "wdlURI", "wsdnUrl", "wsslURI", "wsdalURI", "wslURI"], "userPassword": ["Userpassword", "userpassword", "useAuth", " userPass", "userAuth", "useData", "UserWord", "UserName", "usepassword", " userData", "UserAuth", "UserData", "userName", "USERpassword", "USERPassword", "usePassword", "userPass", " userAuth", " userpassword", "userData", " userName", " userWord", "UserPass", "usePass", "userWord", "UserPassword", "USERName", "USERWord"], "filePath": ["fileStr", "transferPath", " filepath", "transferLocation", "transferStr", "Filepath", "transferpath", "FileStr", " fileLocation", "FileLocation", "FilePath", "fileLocation", "filepath", " fileStr"], "endpoint": ["endPoint", "adPoint", "Endwall", "endwall", "adpoints", "adwall", " endpoints", " endPoint", "EndPoint", "Endpoint", "Endpoints", " endwall", "adpoint", "endpoints"], "conn": ["exec", "cm", "url", "cf", "mc", "client", "ca", "ann", "w", "Connect", "ob", "reg", "cb", "ws", "comm", "connect", "ns", "oss", "sql", "conv", "cp", "inner", "c", "ci", "adj", "auth", "org", "ct", "en", "ssl", "connection", "ec", "g", "Connection", "n", "enc", "loc", "co", "nt", "Con", "sync", "pub", "socket", "dc", "open", "p", "close", "h", "pg", "dn", "rc", "cli", "col", "fn", "ch", "cn", "dh", "init", "act", "coll", "pc", "con", "nc", "ac", "Conn", "oa", "part", "conf", "ctx", "impl"], "is": ["iv", "ib", "ois", "Is", "es", "hi", "si", "ios", "os", "ipp", "ie", "i", "irc", "ps", "ri", "fs", "p", "sc", "as", "rs", "rest", "has", "bis", "x", "res", "ir", "s", "ris", "iss", "or", "rx", "mes", "in", "src", "mis", "us", "im", "ais", "ins", "iet", "sr", "was", "ar", "io", "sec", "oc", "stream", "isl", "info", "js", "lis", "isc", "isi", "it", "isp", " IS", "rss", "ss", "ip", "ai", "iso", "IS", "ws", "ism", "index", "out", "est", "r", "ops", "any", "h", "its", "act", "serv", "il"], "isr": ["issp", "ISl", " isw", "isrs", "ssr", "issl", "issrs", "isrb", "ISw", "iscrb", "isl", "isw", "ssrs", "iscp", "issw", "ssp", "isp", "ssrb", " isp", "issrb", "ISp", "ISr", " isl", "iscrs", "issr", "iscr"], "sw": ["su", "wt", "wa", "im", "sv", "tw", "wrap", "aw", "w", "war", "was", "sem", "wl", "xml", "ws", "x", "sl", "hop", "cr", "wx", "stream", "hw", "hi", "rew", "ww", "rw", "sm", "wr", "sb", "r", "rx", "SW", "so", "eng", "ow", "ew", "wb", "nw", "wh", "pg", "wp", "iw", "sh", "sc", "wra", "rss", "sf", "wo", "response", "Sw"], "buf": ["vec", "uf", "bc", "Buffer", "base", "uc", "prop", "str", "bb", "bin", "br", "cv", "bd", "feed", "raw", "brace", "cur", "func", "fb", "cr", "seq", "err", "len", "bag", "box", "batch", "b", "rx", "text", "ha", "ff", "block", "pad", "wb", "buffer", "la", "bytes", "rb", "cas", "rc", "data", "pool", "shift", "bh", "char", "cb", "buff"], "read": ["k", "send", "reader", "w", "parse", "use", "feed", "load", "child", "raw", "old", "check", "skip", "default", "boot", "log", "reading", "index", "input", "connect", "start", "length", "end", "play", "max", "stream", "need", "write", "en", "i", "count", "ride", "wait", "g", "r", "text", "n", "find", "Read", "sync", "block", "READ", "ok", "buffer", " write", "iter", "add", "get", "copy", "in", "work", "sleep", "se", "data", "num", "reads", "pass", "open", "size", "select", "f", "run"], "outputDir": ["OutputFile", "OutputPath", "outputFolder", "outDir", "inputDir", "tmpDir", "outFolder", "tmpPath", "inputFile", "OutputFolder", " outputDirectory", "tmpFolder", "OutputDirectory", "outFile", "OutputDir", "outDirectory", "tmpDirectory", " outputFolder", " outputPath", "inputDirectory", " outputFile", "outputDirectory", "inputFolder", "outputFile", "outputPath"], "file": ["fp", "url", "FILE", "base", "local", "output", "feed", "zip", "db", "path", "folder", "log", "function", "filename", "name", "out", "stream", "lock", "ile", "files", "build", "File", "writer", "info", "b", "object", "directory", "parent", "handler", "future", "buffer", "message", "resource", "content", "store", "line", "data", "work", "letter", "dir", "up", "full", "unit", "f", "le"], "fos": ["FOS", " fOs", "fOS", "F\n", " faos", " fOS", "Fos", "t\n", "infOS", "f\n", "Faos", "infaos", " f\n", "fOs", "FOs", "infOs", "faos", "infos"]}}
{"id1": "620855", "id2": "22431487", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static String doPost(String URL, List<NameValuePair> params) {\n        try {\n            OauthUtil util = new OauthUtil();\n            URI uri = new URI(URL);\n            HttpClient httpclient = util.getNewHttpClient();\n            HttpPost postMethod = new HttpPost(uri);\n            StringBuffer paramString = new StringBuffer();\n            paramString.append(\"OAuth\");\n            for (int i = 0; i < params.size(); i++) {\n                paramString.append(\" \" + params.get(i).getName());\n                paramString.append(\"=\\\"\" + encodeUrl(params.get(i).getValue()) + \"\\\",\");\n            }\n            String xx = paramString.substring(0, paramString.length() - 1);\n            postMethod.addHeader(\"Authorization\", xx);\n            HttpResponse httpResponse = httpclient.execute(postMethod);\n            if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                String strResult = EntityUtils.toString(httpResponse.getEntity());\n                Log.i(\"DEBUG\", \"result: \" + strResult);\n                return strResult;\n            }\n        } catch (Exception e) {\n            Log.i(\"DEBUG\", e.toString());\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersionUpdate", " doVersionUpdate", " doversionCheck", "doversionScan", "doversionCheck", "doChangeCheck", "doChangecheck", " doversioncheck", "doChangeUpdate", "doversioncheck", "doVersioncheck", "doFeaturecheck", " doVersionScan", " doversionUpdate", "doversionUpdate", "doFeatureScan", "doVersionScan", "doFeatureCheck", " doversionScan", "doChangeScan", "doFeatureUpdate", " doVersioncheck"], "view": ["v", "cache", "vol", "window", "e", "port", "model", "div", "row", "session", "link", "sel", "box", "show", "query", "display", "form", "server", "fail", "value", "full", "group", "gu", "client", "use", "VIEW", "check", "input", "View", "lock", "event", "user", "object", "video", "block", "views", "vis", "by", "http", "page", "review", "pool", "comment", "can", "cell", "im", "base", "change", "el", "ou", "container", "screen", "body", "head", "config", "list", "index", "out", "ui", "image", "this", "widget", "self", "html", "see", "edit", "layout", "update", "ve", "up", "style", "manager"], "url": ["address", "base", "builder", "rel", "bb", "ob", "id", "zip", "URL", "path", "log", "sl", "Url", "host", "location", "string", "name", "ls", "gl", "stream", "bug", "length", "image", "hub", "link", "ssl", "b", "browser", "null", "ll", "www", "loc", "socket", "loader", "fr", "buffer", "uri", "ul", "resource", "http", "l", "source", "file", "server", "download", "email", "impl", "open", "web", "blog", "f"], "in": ["ins", "reader", "din", "IN", "login", "isin", "inc", "bis", "ini", "input", "out", "In", "binary", "s", "inner", "stream", "err", "doc", "m", "b", "again", "sin", "socket", "nin", "win", "buffer", "resource", "inn", "pin", "is", "cin", "lin", "data", "file", "source", "init", "rin", "con", "ac", "as"], "bin": ["bn", "gin", "reader", "din", "IN", "login", "bb", "nb", "vin", "spin", "ini", "input", "border", "out", "binary", "fin", "inner", "lock", "bot", "ruby", "lib", "oin", "ban", "b", "browser", "body", "sin", "socket", "loader", "win", "buffer", "inn", "pin", "abi", "arin", "cin", "lin", "is", "file", "init", "con", "record", "bi", "run"], "line": ["lc", "cl", "base", "ip", "job", "str", "parse", "el", "e", "id", "zip", "one", "log", "le", "val", "ge", "row", "nl", "sl", "string", "name", "end", "Line", "out", "lines", "range", "word", "write", "link", "code", "LINE", "look", "type", "pe", "definition", "b", "user", "text", "object", "block", "pin", "key", "jo", "lf", "lin", "data", "file", "page", "l", "entry", "inline", "up", "letter", "unit", "ine", "part", "comment", "cell"], "version": ["feature", "position", "v", "ver", "project", "beta", "id", "cover", "model", "plugin", "python", "patch", "host", "string", "name", "bug", "driver", "section", "image", "code", "format", "vision", "type", "release", "user", "Version", "null", "video", "latest", "pull", "install", "update", "support", "license", "date", "option", "vert", "versions", "server", "download", "VERSION", "secret", "device", "value", "dev", "unit", "author"], "build": ["uild", "ver", "job", "builder", "rel", "follow", "clean", "use", "feed", "load", "valid", "log", "boot", "make", "row", "patch", "hold", "Build", "bug", "lock", "image", "link", "lease", "info", "print", "release", "show", "tag", "built", "pull", "block", "install", "building", "update", "post", "mount", "how", "add", "get", "http", "work", "style", "help", "home", "unit", "run"]}}
{"id1": "15241397", "id2": "18696387", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", "handleGET", "didget", " doPut", "didGET", "handlePut", "doGET", "didGet", "handleget", " doget", "didPut", "doget", "doPut", "handleGet"], "request": ["complete", "url", "result", "client", "reader", "received", "QUEST", "xml", "input", "er", "context", "queue", "image", "event", "type", "connection", "method", "report", "info", "application", "user", "object", "query", "message", "uri", "buffer", "resource", "Request", "document", "http", "data", "server", "subject", "req", "instance", "initial", "web"], "response": ["result", "error", "esi", "client", "status", "output", "view", "site", "model", "Response", "function", "host", "session", "out", "generation", "queue", "image", "next", "results", "respond", "writer", "connection", "report", "application", "object", "body", "parent", "message", "resource", "version", "wave", "document", "other", "page", "data", "resp", "server", "pool", "full", "reply", "onse", "json", "collection"], "rewrittenQueryString": ["rewwrittenQueryStr", "rewrittenUrlString", "rewrittenRequestString", "rewrittenPageArray", "rewwrittenRequestString", "rewwrittenQueryString", "rewrittenQuestionText", "rewwrittenQueryArray", "rewrittenQuestionArray", "rewrittenqueryString", "rewwrittenRequestService", "rewrittenQueryStr", "rewwrittenQueryText", "rewwrittenQueryService", "rewrittenqueryService", "rewrittenQueryList", "rewrittenRequestLine", "rewrittenUrlText", "rewrittenRequestText", "rewwrittenQueryList", "rewrittenRequestArray", "rewrittenUrlService", "rewrittenRequestList", "rewrittenQueryLine", "rewrittenQuestionLine", "rewrittenqueryLine", "rewrittenQueryArray", "rewrittenQuestionString", "rewrittenRequestStr", "rewwrittenRequestText", "rewrittenQueryText", "rewrittenqueryText", "rewwrittenRequestArray", "rewrittenPageString", "rewrittenUrlLine", "rewrittenRequestService", "rewrittenQuestionStr", "rewwrittenQueryLine", "rewrittenPageList", "rewrittenqueryStr", "rewwrittenRequestLine", "rewwrittenRequestList", "rewwrittenRequestStr", "rewrittenPageLine", "rewrittenQuestionList", "rewrittenQueryService"], "rewrittenUrl": ["RewrittenJar", "RewwrittenText", "rerittenLanguage", "rewardedURL", "rewardedUr", "rewmatchedURL", "rewrapedURL", "rewwrittenServer", "rewwrittenURL", "rerittenUrl", "rewardedLanguage", "rewmatchedFile", "rewedUr", "rewilledUrl", "rewrapedFile", "RewwrittenServer", "rewilledJar", "rewcraftedLocation", "rewodedUrl", "rewardedFile", "RewrittenURL", "rewatchedUrl", "rewatchedURL", "RewrittenServer", "rewrittenInt", "Rewwrittenurl", "rewodedFile", "rewriteText", "RewwrittenUrl", "rewardedJar", "rewedurl", "rewcraftedURL", "rewcraftedUr", "rewwrittenUr", "rewrittenLocation", "RewrittenFile", "RewwrittenURL", "rewardedInt", "rewmatchedUrl", "rewrittenJar", "RewrittenText", "rerittenFile", "rewrapedUr", "rewrittenServer", "rewatchedServer", "RewwrittenJar", "rewardedLocation", "rewwrittenLanguage", "rewedFile", "RewrittenInt", "rewrittenFile", "rewedURL", "rewwrittenFile", "rewardedUrl", "RewrittenUr", "rewrittenUr", "rewriteServer", "rewatchedText", "rewrittenText", "RewwrittenInt", "rewodedLanguage", "RewwrittenLocation", "rewwrittenJar", "RewrittenUrl", "rewilledInt", "rewmatchedurl", "Rewrittenurl", "rewilledURL", "RewwrittenFile", "rewwrittenurl", "rewriteURL", "rerittenUr", "rewcraftedUrl", "rerittenURL", "RewrittenLocation", "rewwrittenUrl", "rewrittenURL", "rewrittenurl", "rewwrittenLocation", "rewrapedUrl", "rewrittenLanguage", "rewodedURL", "rewwrittenInt", "RewwrittenUr", "rewedUrl", "rewwrittenText", "rewriteUrl"], "httpURLConnection": ["httpSSLConn", " httpURConnect", " httpStreamCurrent", "webURLConnection", "HttpURLConnection", " httpUrlConn", " httpURLConn", "httpURIconnection", "httpWebConnection", "webSSLConnection", "httpURLContext", "httpURLConn", "httpWebConnect", "httpELConn", "httpURLService", " httpURLConnect", " httpURConn", "httpURLconnection", "httpURLClient", "webURLClient", "httpGEconnection", "httpURIConnection", " httpStreamConnection", "httpPathconnection", "httpGEConnect", "httpurlSession", " httpURLSession", "httpWebConn", "httpUrlconnection", "httpCLConn", "httpURLCode", "httpUrlConnection", "httpURConn", "httpELConnection", "httpURIConn", "httpChannelConnection", "apacheURLconnection", "httpURconnection", "httpUrlContext", "HttpURLService", "httpStreamconnection", "httpUrlConnect", "httpurlConnection", "webURLConn", "httpChannelConnect", "httpURLSession", "httpPathSession", "httpURConnection", "httpStreamConnection", "httpELConnect", "apacheGEConnect", " httpURLCurrent", "httpurlCurrent", "httpSSLClient", "webSSLConn", " httpURConnection", " httpStreamconnection", " httpURLconnection", "httpChannelconnection", "HttpURLconnection", "httpURIFlow", "webSSLClient", "httpURIContext", "httpPathCurrent", "apacheGEconnection", "httpStreamCurrent", "httpGEFlow", " httpStreamSession", "httpURLFlow", "httpCLCode", "apacheGEFlow", " httpURLCode", "httpurlConnect", "httpurlFlow", "apacheGEConnection", "webSSLContext", "httpGEConnection", " httpUrlCode", "apacheURLConnect", "HttpChannelConnection", "httpUrlService", "httpurlConn", "httpurlCode", "apacheURLFlow", "httpSSLContext", "httpURLCurrent", "httpUrlConn", "httpurlconnection", "httpURConnect", "httpURIClient", "httpUrlClient", "httpURService", "HttpChannelService", "httpPathConnection", "httpURIConnect", "httpSSLConnection", "webURLContext", " httpUrlConnection", "HttpURLConnect", "httpUrlCode", "httpCLConnection", "HttpChannelConnect", "HttpChannelconnection", "httpStreamSession", "httpChannelService", "httpURLConnect", "apacheURLConnection"], "header": ["hash", "feature", "pair", "result", "item", "master", "error", "column", "token", "ter", "metadata", "after", "cover", "default", "function", "index", "er", "string", "bridge", "driver", "queue", "section", "next", "character", "layer", "event", "component", "writer", "info", "reference", "definition", "player", "head", "rule", "handler", "Header", "back", "list", "block", "headers", "outer", "buffer", "message", "iter", "version", "date", "her", "attribute", "key", "document", "dr", "line", "consumer", "entry", "filter", "server", "channel", "data", "match", "member", "director", "field", "second", "group", "part", "comment", "author"], "value": ["v", "sv", "description", "now", "current", "valid", "child", "Value", "model", "default", "function", "val", "label", "string", "name", "values", "end", "language", "set", "expression", "format", "type", "VALUE", "info", "element", "object", "text", "parent", "hello", "message", "office", "media", "version", "option", "property", "attribute", "key", "content", "V", "gi", "get", "document", "entry", "data", "server", "letter", "password", "variable", "field", "json", "comment", "item"], "inputStream": ["pullStreamer", "pullSteam", "inputSteam", "outputStreamer", "pullStream", "resourcestream", "InputChannel", "resourceSteam", "outputChannel", "resourceStream", "resourceChannel", "outputSteam", "InputStreamer", "Inputstream", "outputstream", "InputSteam", "inputstream", "inputChannel", "inputStreamer", "pullstream", "InputStream"], "outputStream": ["OutputFile", " outputSteam", "inputSteam", "outputStreamer", "OutputChannel", "OutputSteam", "externalStream", "outputChannel", "OutputStream", "externalstream", "externalSteam", "responseSteam", "outputSteam", "OutputStreamer", "responseStream", "outputstream", "responseChannel", "externalStreamer", "Outputstream", "responseFile", " outputChannel", " outputFile", "inputstream", "inputStreamer", "outputFile"]}}
{"id1": "21232043", "id2": "1473212", "code1": "    @Override\n    public File call() throws IOException {\n        HttpURLConnection conn = null;\n        ReadableByteChannel fileDownloading = null;\n        FileChannel fileWriting = null;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            if (size == -1) {\n                size = conn.getContentLength();\n            }\n            fileDownloading = Channels.newChannel(conn.getInputStream());\n            fileWriting = new FileOutputStream(file).getChannel();\n            long left = size;\n            long chunkSize = BLOCK_SIZE;\n            for (long downloaded = 0; downloaded < size; left = size - downloaded) {\n                if (left < BLOCK_SIZE) {\n                    chunkSize = left;\n                }\n                fileWriting.transferFrom(fileDownloading, downloaded, chunkSize);\n                downloaded += chunkSize;\n                setProgress(downloaded);\n            }\n        } finally {\n            if (file != null) {\n                file.deleteOnExit();\n            }\n            if (conn != null) {\n                conn.disconnect();\n            }\n            if (fileDownloading != null) {\n                try {\n                    fileDownloading.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0441\u043a\u0430\u0447\u0438\u0432\u0430\u043d\u0438\u044f\", ioe);\n                }\n            }\n            if (fileWriting != null) {\n                try {\n                    fileWriting.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 \u0444\u0430\u0439\u043b\", ioe);\n                }\n            }\n        }\n        return file;\n    }\n", "code2": "    @Test\n    public void test_validate_geo_getEvents() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=geo.getevents&location=madrid&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"call": ["exec", " flush", "url", "send", " invoke", "output", "transfer", " method", "request", "connect", "start", " upload", "next", "write", "upload", " end", "Call", " complete", "Upload", "close", "copy", "work", "process", "execute", "download", " request", "open", "run"], "conn": ["net", "exec", "fp", "url", "cm", "cf", "client", "ca", "ai", "uc", "ann", "reg", "cb", "db", "log", "connect", "conv", "ls", "cp", "lock", "c", "ci", "cc", "rt", "ct", "ssl", "connection", "Connection", "n", "config", "enc", "sync", "socket", "nt", "loc", "loader", "co", "dc", "api", "p", "pg", "dn", "http", "rc", "cli", "col", "channel", "ch", "cn", "act", "init", "server", "coll", "con", "nc", "Conn", "open", "conf", "ctx", "f", "cmp", "po"], "fileDownloading": ["FileUploaduing", "fileFieldING", "filedownloadancing", "resourceDownloadging", "fileMonitording", " fileProcessting", "FileDownloading", "fileDownloadbing", "fileDownloadging", " fileDownloadting", "filePulling", "fileUploading", " fileProcessing", "fileFieldging", "fileMonitors", "fileProcessing", "fileUploadding", "fileUploads", " fileDownloadancing", "FileDownloaduing", "fileUploadING", "filedownloading", "fileDownloads", "FileDownloadbing", "fileFunding", "fileReviewING", "resourceDownloading", " fileProcessancing", "FileUploading", "fileProcesser", "fileUploadcing", "filePullging", "fileSpawning", "filedownloadging", "fileDownloadING", "fileSpawnancing", "fileFieldding", "fileFundting", "fileReviewbing", "fileProcessting", "fileDownloader", "FileUploadING", "fileSpawnging", "filedownloadING", " fileProcesser", "fileReviewuing", "fileMonitoring", "fileDownloadding", "FileDownloadING", "FileUploadbing", "fileFunder", " fileDownloadging", "fileDownloaduing", " fileDownloads", "fileMonitorcing", "fileUploaduing", "fileDownloadcing", "fileProcessancing", "fileFundancing", "filePullancing", "filedownloadding", "fileDownloadting", " fileDownloadcing", "filedownloadting", " fileDownloadING", "resourceDownloadancing", "filedownloader", "resourceDownloader", " fileDownloader", "fileReviewing", "fileFielding", "filePuller", " fileDownloadding", "fileDownloadancing", "fileUploadbing", "fileSpawner"], "fileWriting": ["resourceWriter", "FileWriting", "FileReading", " fileWrit", " fileWritten", "urlWriting", "resourceWriting", " fileSetting", " fileWriter", "fWriter", "mailWriter", "urlWriter", "fileWorking", "resourcewriting", "ioWorking", " filewriting", "placeWriter", "FileLoading", "FileWriter", "fileCreating", "iowriting", "FileCreating", "fileLoading", "ioWriting", "fileSetting", "urlLoading", " fileReading", "fWriting", "fileWriter", "fwriting", " fileCreating", "mailWriting", "placeSetting", "fCreating", "ioReading", "fileWritten", "fileWrit", "FileWritten", "resourceWrit", "fileReading", "placeWriting", " fileLoading", "mailWrit", "filewriting", " fileWorking", "FileSetting", "FileWorking", "mailwriting", "Filewriting", "placeWritten"], "size": ["address", "level", "cache", "clean", "mini", "Size", "length", "name", "string", "time", "offset", "max", "six", "si", "storage", "large", "code", "small", "count", "body", "empty", "SIZE", "sized", "speed", "loc", "sync", "uri", "timeout", "ize", "close", "scale", "content", "fee", "page", "data", "file", "low", "width", "password", "limit", "capacity", "unit", "sum", "zero"], "left": ["two", "position", "less", "cl", "loading", "needed", "own", "found", "right", "lo", "child", "available", "fl", "label", "auto", "length", "offset", "inner", "L", "missing", "led", "lower", "next", "failed", "pl", "limited", "small", "lost", "used", "empty", "sized", "little", "loc", "diff", "Left", "loader", "leave", "la", "loaded", "scale", "l", "held", "last", "shift", "low", "spread", "limit", "coll", "fail", "lim", "second", "ell", "le", "partial"], "chunkSize": ["chrawsize", "chacketSize", "chobLength", "coprawsize", "chumpize", "chacketsize", "chunkNum", "coprawSize", "ChunkSize", "chicaLen", "chumpSize", "chunkLen", "chicaSize", "copunksize", "coprawBreak", " chacketsize", "chumpLength", "crunkSize", "chunkssize", "ChunkLen", "coprawLength", "ChunkLength", "chunksLength", "crgroupsize", " chacketLength", "copunkBreak", "changeLength", "copunkLength", " chacketSize", " chunkNum", "chunksize", "chgroupsize", " chacketNum", "crgroupize", "crunkLength", "chicasize", "changesize", "chunksBreak", "changeSize", "chunksLen", "crunksize", "chacketLength", "chicaLength", "chobSize", "chgroupize", "chobsize", "chunkize", " chunkLength", "crunkize", " chunksize", "chunkBreak", "chrawLength", "chrawSize", "chunkLength", "changeBreak", "copunkSize", "chunksNum", "chacketNum", "chunksSize", "chobNum", "chrawBreak", "chumpsize", "crgroupSize", "crgroupLength", "chgroupSize", "Chunksize", "chgroupLength"], "downloaded": ["weightloaded", "upled", "downsloader", "defload", "ownloading", "ownload", " download", "downsloading", "ownled", "uploader", " downwritten", "downswritten", "Download", "defloading", "downled", "Downloaded", "downsloaded", "uploading", "upload", "Downloading", " downled", "Downloader", "downwritten", "uploaded", "weightwritten", "downloader", " downloader", "defloaded", "downsload", "weightled", "downsled", "weightload", "defloader", "Downled", " downloading", "download", "ownloader", "downloading", "ownloaded"]}}
{"id1": "9236363", "id2": "11377441", "code1": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"unJarStart": ["copyJarRest", "copyServerEnd", "syncServerPath", "copyjarStart", "copyjarEnd", "copyZipPath", "copyZipEnd", "copyJarStart", "copyZipRest", "copyServerPath", "copyJarPath", "copyjarRest", "syncJarEnd", "copyZipStart", "syncServerEnd", "copyServerRest", "syncJarRest", "syncJarPath", "copyjarPath", "syncServerStart", "copyJarEnd", "syncServerRest", "copyServerStart", "syncJarStart"], "jarPath": [" jarContent", "relEntry", "jarFile", "archiveDir", "relpath", "archivepath", "garContent", "badUrl", " jarName", "javaEntry", "jampath", "garText", "garpath", "badpath", "javaLog", "zippath", "zipPath", "jarpath", " jarText", "badPath", "jarCh", "garUrl", "narCh", "jarDir", "javaUrl", "jamLog", "garFile", "badLog", "zipEntry", "narpath", "garPath", "narName", "JarFile", "archiveLog", "javaName", "zipFile", "javaCh", "jarLog", "jarText", "narPath", "jarName", " jarDir", " jarUrl", "Jarpath", "javaFile", "javaPath", "jarUrl", " jarFile", "JarContent", " jarLog", "javaText", " jarpath", "JarPath", "JarCh", "relFile", "archivePath", "javapath", "jamPath", "jarContent", "JarName", "jamDir"], "jarEntryStart": ["tarentryStart", "jarImportFollow", " jarEntryFinish", "jarFilePart", "tarentryName", "jarAttemptPart", "jarImportEnd", " jarFileStart", "jarFileName", "jarAttemptEnd", "jarFileEnd", "tarEntrySource", " jarImportStart", "tarEntryStart", "jarEntryPart", "jarImportName", " jarFileName", "jarFileFollow", "jarEntryFollow", " jarFilePart", " jarEntryName", "jarPartEnd", "jarEntName", " jarEntrySource", "jarFileStart", " jarImportEnd", "jarentryStart", "jarentrySource", "tarEntryPart", "tarentryPart", "jarEntryEnd", "jarEntryFinish", "jarEntPart", "jarFileFinish", "jarImportFinish", "tarEntryName", "jarEntryName", "jarAttemptStart", " jarFileSource", "jarentryPart", "tarentrySource", "jarPartStart", " jarImportPart", "jarPartFinish", "jarEntSource", " jarFileFinish", " jarEntryFollow", "jarEntrySource", "jarAttemptFollow", " jarEntryEnd", "jarPartPart", "jarImportSource", "jarImportStart", " jarImportFollow", "jarFileSource", "jarImportPart", " jarEntryPart", " jarFileEnd", "jarentryName", "jarEntStart"], "path": ["test", "error", "cache", "right", "id", "log", "session", "pattern", "location", "name", "conn", "context", "method", "ph", "route", "directory", "th", "graph", "api", "mount", "p", "ion", "cookie", "data", "file", "ith", "ha", "prop", "left", "folder", "boot", "pointer", "patch", "string", "Path", "prefix", "object", "dest", "key", "template", "base", "system", "zip", "inner", "then", "code", "mode", "parent", "config", "loc", "uri", "resource", "it", "content", "source", "work", "dir", "home", "temp", "url", "PATH", "clean", "output", "request", "default", "host", "archive", "image", "next", "step", "type", "root", "text", "ath", "wd", "pass", "json", "ctx", "po"], "relPath": ["relpath", "relativepath", " relDir", "relativeDir", "relativePath", " relName", "relName", "Relpath", "relativeName", "RelName", " relPos", "RELName", "relativePos", "RelPath", "RELPath", "RELPos", "RelDir", " relpath", "relPos", "relDir", "RELpath"], "jar": ["ser", " module", "url", "drop", "cache", "magic", "car", "sr", "parse", "war", "com", "ar", "zip", " war", "ball", "xml", "folder", "space", "ler", "sl", " archive", "er", "plugin", "ge", "start", "log", "fire", "tab", "archive", "pkg", "tar", "bag", " tar", "keeper", "zone", "ssl", "java", " manifest", "bar", "browser", "gap", " java", " dir", "pipe", "per", "her", "pack", " capsule", "jo", " parser", "dr", "cookie", "sheet", "server", "dir", "spin", "rar", "mag", "sp", "open", "Jar", "module"], "entries": ["entrys", "Entursions", "enders", "quies", "entensions", "quents", "enties", "quries", "ientries", "endries", "entEntry", "Enties", "counters", "endrys", "entories", "countEntry", "adders", "entryEntry", "qulements", "addries", "entryers", "enters", "ientursions", "endories", "entryensions", "entryries", "entlements", "entursions", "ENTents", "antries", "Entlements", "Entrys", "Entry", "ientry", "ENTlements", "iters", "itrys", "ENTries", "antursions", "addEntry", "Entents", "countries", "itories", "Entories", "countensions", "ENTies", "antlements", "Entries", "entents", "ientlements", "itries", "addensions", "Enters", "antry"], "entry": ["oe", "address", "de", "be", "lie", "reader", "enter", "parse", "e", "zip", "cel", "je", "ler", "ge", "name", "obj", "mer", "or", "element", "ie", "r", "ent", " Entry", "Entry", "pack", "la", "resource", "add", "it", "key", "jo", "ry", "se", "server", "ries", "pie", "cat", "part", "ce", "module"], "jarEntry": ["jarFile", "archiveFile", "javaEntry", "celEntry", " jarElement", "javaImport", "javaRule", "carEntry", "javaElement", "celEnt", " jarentry", "serName", "jarRule", "celFile", "serEntry", "jobEntry", "javaEnt", "carElement", "archiveRule", "serElement", "jarentry", "jobImport", " jarEnt", "javaName", "serFile", "archiveElement", "jarName", " jarImport", "javaFile", "carPath", "javaPath", "jarImport", "javaentry", "carEnt", "jarEnt", "archiveEnt", "archiveName", "celRule", "jobPath", "archiveEntry", "jarElement", "jobentry"], "ze": ["zie", "z", "ja", "ipe", "e", "zip", "cel", "je", "sl", "kee", "ge", "te", "li", "zen", "zes", "fe", " je", "code", "ZE", "ide", "ie", "pe", "zer", "zo", "za", "zi", " ace", "jo", "xe", "se", "ke", "ne", "ine", "ce", "aze", "le", "zy", "be"], "bin": ["bn", "base", "bit", "login", "bb", "zip", "proxy", "isin", "bis", "vin", "spin", "log", "boot", "ini", "plugin", "index", "abin", "binary", "inner", "lock", "len", "bank", "bot", "bas", "lib", "zone", "info", "bar", "body", "sin", "win", "resource", "inn", "gi", "pin", "abi", "arin", "di", "in", "data", "file", "cin", "init", "kin", "bi"]}}
{"id1": "22977189", "id2": "23335922", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 0, "substitutes": {"in": ["url", "gin", "ins", "reader", "din", "IN", "re", "login", "bin", "id", "isin", "inc", "ini", "input", "er", "In", "inner", "ln", "image", "err", "c", "this", "read", "i", "r", "g", "b", "n", "again", "socket", "nin", "win", "inn", "min", "plus", "is", "source", "data", "up", "lin", "init", "inside", "cin", "pass", "con", "as", "f"], "out": ["error", "outs", "cache", "window", "app", "inc", "raw", "log", "conn", "name", "off", "plain", "at", "writer", "a", "query", "strip", "flush", "data", "file", "server", "part", "as", "f", "client", "s", "ext", "word", "prefix", "write", "Out", "user", "b", "object", "o", "block", "key", "page", "pool", "password", "comment", "OUT", "w", "call", "io", "obj", "inner", "err", "editor", "again", "parent", "list", "outer", "copy", "temp", "exec", "flow", "output", "bin", "default", "this", "self", "connection", "r", "ex", "n", "sync", "point", "up", "init"], "line": ["url", "cl", "lc", "header", "column", "str", "id", "feed", "log", "row", "sl", "string", "name", "end", "Line", "lines", "word", "lock", "c", "next", "link", "write", "character", "code", "LINE", "i", "pe", "text", "rule", "block", "message", "key", "content", "lf", "page", "lin", "data", "file", "l", "char", "letter", "style", "source", "inline", "entry", "pass", "value", "unit", "comment", "f", "cell"]}}
{"id1": "21363911", "id2": "3809087", "code1": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"testTransactions": ["testTacts", " testTransact", "testtransact", "testTransactionacts", "testTransact", " testtransacts", "testTransactionaction", "testtransactions", " testtransactions", " testtransaction", " testtransact", "testTactions", "testTaction", "testTransacts", "testTransactionact", "testTransactionactions", " testTransaction", "testTransaction", "testtransacts", "testtransaction", " testTransacts", "testTact"], "con": ["an", "exec", "cm", "cl", "ocon", "cf", "bc", "can", "ca", "client", "cache", "ver", "uc", "mc", "un", "ran", "com", "ain", "db", "log", "ctx", "x", "connect", "sql", "conn", "core", "conv", "cr", "c", "cc", "pl", "fac", "en", "custom", "ec", "connection", "crit", "ct", "const", "pen", "co", "fc", "sync", "enc", "Con", "pub", "win", "cond", "common", "close", "min", "condition", "CON", "rc", "col", "don", "act", "cn", "create", "contract", "pc", "coll", "ac", "cons", "ctrl", "conf", "xc", "run", "pr", "po"], "st": ["rest", "rd", "cl", "sw", "str", "ste", "sta", "put", "db", "tx", "St", "sl", "pt", "ks", "sts", "mt", "s", "cr", "est", "sth", "c", "set", "bl", "pl", "fe", "ist", "sa", "std", "t", "en", "ct", "sb", "r", "pe", "ut", "const", "co", "td", "ost", "sync", "inst", "fr", "sy", "sn", "la", "ck", "rc", "sh", "l", "sc", "se", "ld", "act", "d", "src", "pc", "ust", "ST", "sp", "ss", "pr"], "rs": ["maps", "sw", "ins", "ra", "mr", "sr", "str", "xs", "ges", "ts", "rr", "vs", "tx", "ws", "rors", "row", "yrs", "ns", "res", "ks", "pr", "s", "cr", "ls", "ris", "vers", "hr", "lines", " RS", "RS", "results", "changes", "rt", "hs", "pers", "errors", "ras", "r", "repl", "ys", "rows", "acks", "cs", "rx", "arms", "runs", "kr", "ans", "ps", "co", "ars", "ows", "ds", "Rs", "dr", "rc", "ums", "rys", "qs", "src", "rss", "details", "ros", "bs", "ss", "rl", "rd"]}}
{"id1": "15580610", "id2": "7149578", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"trainClassifier": ["trainclassification", "trainModelifier", "trainModelLoader", "trainModelification", " trainclassification", "trainTestify", " trainClassify", "trainTestLoader", "trainClassLoader", "trainClassification", " trainClassLoader", "trainClassify", " trainclassLoader", "trainTestification", "trainclassify", " trainClassification", "trainclassLoader", "trainModelify", "trainclassifier", "trainTestifier", " trainclassify", " trainclassifier"], "dir": ["md", "url", " directory", "base", "project", "output", "window", "Dir", "model", "db", "path", "folder", "div", "target", "filename", "name", "out", "domain", "doc", "database", "files", "lib", "build", "report", "class", "root", "directory", "object", "DIR", "config", "direction", "loc", "uri", "cd", "du", "wd", "fd", "di", "data", "file", "dist", "d", "group", "home", "env", "module"], "command": ["exec", "slave", "error", "sudo", "system", "project", "delete", "force", "which", "child", "model", "volume", "shell", "path", "request", "one", "function", "input", "pattern", "machine", "string", "sequence", "name", "language", "cmd", "word", "action", "archive", "domain", "image", "argument", "database", "this", "clear", "operation", "reason", "event", "menu", "connection", "history", "component", "root", "info", "directory", "program", "category", "config", "query", "message", "array", "attribute", "service", "media", "usage", "document", "cli", "move", "power", "help", "password", "file", "control", "and", "three", "script", "Command", "comment", "module"], "length": ["position", "level", "now", "left", "id", "prime", "zip", "creator", "distance", "sequence", "end", "max", "time", "range", "section", "angle", "word", "inner", "len", "character", "dim", "or", "type", "Length", "duration", "count", "ength", "class", "ph", "number", "shape", "body", "join", "both", "th", "head", "span", "slice", "loc", "padding", "depth", "how", "strength", "form", "l", "match", "last", "power", "letter", "width", "before", "style", "limit", "capacity", "square", "value", "full", "part", "sum", "size"], "process": ["exec", "result", "processor", "master", "share", "cess", "console", "system", "status", "call", "parse", "project", "output", "handle", "app", "use", "child", "proc", "worker", "path", "function", "session", "host", "python", "out", "machine", "thread", "cmd", "this", "component", "connection", "method", "pid", "class", "application", "user", "parent", "program", "task", "sync", "post", "display", "service", "p", "plus", "document", "file", "processing", "Process", "script", "group", "run"]}}
{"id1": "12128591", "id2": "15051083", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "label": 1, "substitutes": {"hash": [" fingerprint", "str", "parse", "check", "Hash", "log", "hex", "build", "code", "SHA", "component", "crypt", " hashes", "print", "text", "update", "pack", " hashing", " Hash", "add", "get", "copy", "h", "dump", "sum"], "data": ["address", "template", "result", "base", "cache", "str", "output", "DATA", "input", "string", "name", "s", "length", "memory", "image", "missing", "hex", "database", "format", "a", "info", "connection", "class", "dat", "text", "body", "pad", "padding", "buffer", "message", "media", "alpha", "api", "p", "bytes", "content", "in", "source", "style", "value", "response"], "digest": ["peder", "digit", "signEST", " digusher", "signest", "decests", "logast", "logenge", "mdast", "bigest", "generit", " digests", "pede", "Digenge", "digast", "logester", "bigger", "Digger", "digenge", "mdest", "digEST", "bigester", " digester", "generests", "digester", " digEST", "decit", "decest", "decester", "Dige", "digusher", "pedester", "digests", "bigusher", "Digusher", " digit", "pedest", "DigEST", " dige", "Diger", "Digester", "dige", "signester", "diger", "Digest", " diger", "digger", "logest", "Digast", "generester", "mdenge", " digger", "generest", "signusher", "mdester"]}}
{"id1": "7872659", "id2": "17996547", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieIndexPath", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndmovieindexfile", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndmovieIndexfile"], "completePath": ["completeHome", " completeRoot", " completeCorp", "execpath", "doneLoader", "successPath", " CompleteDir", "completeCh", " completepath", "CompletePath", "doneVol", "CompleteDir", "completeVol", " completePoint", "itePath", "flatPath", " completeDir", "donePath", "completeCorp", "iteMusic", "successCh", "execLoader", "completeFile", "iteCh", "correctPoint", " CompletePath", "completeMusic", "completeRoot", "donepath", "successMusic", "completepath", "completeLoader", "itepath", "completePoint", "progressLoader", "progresspath", "CompleteHome", " completeCh", "progressPath", " completeHome", "flatRoot", "execPath", "flatCorp", "progressVol", "completeDir", "correctPath", "flatPoint", " CompleteHome", "execVol", "correctCorp", " completeMusic", " completeFile", " CompleteFile", "correctRoot", "CompleteFile", "successpath"], "masterFile": ["masterFiles", " masterName", "MasterFilename", "MasterName", "cacheFiles", "masterName", "MasterPath", "cachePath", "masterPath", "MasterFiles", "configFilename", "mastersFile", " masterPath", "cacheFile", "masterFilename", "MasterFILE", "mastersPath", " masterFilename", "MasterFile", "configPath", "configFile", "mastersFILE", "cacheFILE", "masterFILE", "mastersFiles", "configName"], "CustRatingFileName": ["CustRatingClassPath", "CustIndexFilesVersion", "CustIndexFileName", "CustRatingFilesName", "CustRatingFilenameSize", "CustRatingFilenameName", "CustRateFileName", "CustRateFilenameDesc", "CustRatingFilesDesc", "CustRatingFileVersion", "CustRatingFileSize", "CustIndexFilesType", "CustRateFileSize", "CustIndexFilesName", "CustRatingFilenamePath", "CustRatingFullDesc", "CustRateFilenameName", "CustIndexFilesPath", "CustRateFileDesc", "CustRatingFullPath", "CustRatingLineVersion", "CustRatingClassVersion", "CustRatingFileDesc", "CustRatingLineName", "CustRatingClassName", "CustRatingFilePath", "CustRatingFilesSize", "CustRateFilePath", "CustRatingFullName", "CustRatingLineType", "CustRateFilenamePath", "CustRatingFileType", "CustRatingLinePath", "CustRatingFullSize", "CustIndexFileVersion", "CustRatingClassType", "CustIndexFileType", "CustRatingFilesPath", "CustIndexFilePath", "CustRatingFilenameDesc", "CustRatingFilesType", "CustRateFilenameSize", "CustRatingFilesVersion"], "MovieIndexFileName": ["MovieIndexPlaceFile", "MovieConfigFolderFile", "MovieIndexFileHandle", "MovieIndexClassSize", "MovieIndexFName", "MovieEditFilename", "MovieConfigFolderName", "MovieConfigFileHandle", "MovieConfigFileVersion", "MovieIndexFolderName", "MovieIndexFileVersion", "MovieIndexPlaceName", "MovieIndexClassName", "MovieIndexFSize", "MovieIndexFilesUrl", "MovieEditFname", "MovieIndexClassname", "MovieConfigFolderVersion", "MovieEditFSize", "MovieConfigFileName", "MovieEditFUrl", "MovieIndexClassUrl", "MovieConfigFileFile", "MovieIndexFILEVersion", "MovieIndexFilesname", "MovieIndexFileSize", "MovieIndexFolderHandle", "MovieIndexFilesSize", "MovieConfigFolderHandle", "MovieIndexFILEFile", "MovieIndexFname", "MovieEditFileName", "MovieIndexFolderVersion", "MovieEditFileSize", "MovieIndexFUrl", "MovieIndexFolderFile", "MovieIndexPlaceHandle", "MovieEditFName", "MovieIndexFileFile", "MovieIndexFileUrl", "MovieIndexFILEName", "MovieIndexFILEHandle", "MovieEditFileUrl", "MovieIndexPlaceVersion", "MovieIndexFilename", "MovieIndexFilesName"], "inFile": ["Infile", "inputF", "inputFile", "InFile", "InF", "incFile", "inF", "incC", "InSourceFile", "inputSourceFile", "incSourceFile", "outFile", "infile", "outC", "incfile", " inF", " infile", "outfile", " inSourceFile", "outSourceFile", "inSourceFile", "inputfile"], "inC": ["inB", "InB", "inputF", " inCL", "innerCI", "outCC", "inputFile", "InFile", "InF", "outB", "inF", " inCC", "inCL", "outFile", "outC", "inputC", "innerFile", "inputCC", " inF", "InCI", " inB", "InCC", "innerCC", "outF", "outCL", "InCL", "outCI", "inCC", "innerC", "inCI", "InC"], "outFile1": ["outputFileName", "outFName", "againCFirst", "againC3", "outputFileId", "outPlaceId", "outCFirst", "outF1", "outFileName", "outFile3", "againFile1", "outPathFirst", "outPath1", "outFiles1", "outPath2", "outFilesFirst", "outfile1", "outfileId", "outF2", "outPath3", "outFileFirst", "outPlace1", "outFiles3", "outputFile1", "againFile3", "outC3", "againC1", "outFiles2", "againFile2", "outfileName", "outPlaceName", "outFileId", "outputFile2", "outputfileName", "outputfileId", "outputfile2", "outPlace2", "outFId", "outfile2", "againC2", "againFileFirst", "outputfile1"], "outC1": ["newc1", "outC81", "outD1", "outCFirst", "outD8", "outF1", "outcFirst", "outFOne", "newC81", "outCFFirst", "outD81", "newc81", "newCFirst", "outF2", "outD2", "againB8", "againC8", "outCF81", "outCFOne", "newCOne", "outDOne", "outc1", "outB1", "againB1", "outBOne", "againCOne", "outcOne", "outB8", "newcOne", "newcFirst", "outB2", "againBOne", "outF8", "outc81", "outC8", "newC1", "againC2", "againB2", "outCOne", "outCF1", "outDFirst", "againC1"], "outFile2": ["outFile4", "outputfile5", "outFiles6", "outDirectory4", "outFile5", "againFile6", "againFile1", "outFilesTwo", "againLine1", "outDirectory2", "outFiles1", "outDirectory5", "againFileTwo", "outLineTwo", "outputFile4", "outFileTwo", "outputFile5", "outChannel2", "outChannel1", "outLine2", "outDirectoryTwo", "outChannel6", "againLine2", "outfile4", "outFiles2", "outputFileTwo", "againFile2", "outFiles5", "outLine6", "outputFile2", "outfile5", "outChannelTwo", "againLine6", "outputfile2", "outfileTwo", "outLine1", "outfile2", "outputfileTwo", "againLineTwo", "outFile6", "outFiles4", "outputfile4"], "outC2": ["outFile4", "outFTwo", "outCache1", "outCII", "outF1", "outCache2", "outFII", "outB4", "OutF1", "againC4", "outCache4", "outF2", "OutF2", "OutC1", "outFileTwo", "outCacheII", "outCTwo", "OutCII", "OutC2", "OutC4", "OutFII", "outB1", "againB1", "againCTwo", "againBTwo", "outBTwo", "outF4", "outB2", "outC4", "outFileII", "againC2", "againB2", "againB4", "OutF4", "againC1"], "fileSize": ["bufferMode", " fileMode", " fileAddress", " fileSIZE", "imageLength", "imageSize", " fileLength", "fileAddress", "bufferSize", "fileMode", "bufferLength", "FileLength", "resourceSize", "resourceSIZE", "FileSize", "FileSIZE", "FileAddress", "fileLength", "FileMode", "imageSIZE", "resourceAddress", "fileSIZE"], "totalNoDataRows": ["totalNoPageRues", "totalNoDataChOWS", "totalNoDataRrows", "totalNoPageRrows", "totalNoDataCues", "totalNoPageLOWS", "totalNoDataRues", "totalNoDataLues", "totalNoPageLrows", "totalNoDataCows", "totalNoPageLows", "totalNoDataChows", "totalNoDataLows", "totalNoDataCrows", "totalNoDataChues", "totalNoDataCOWS", "totalNoPageRows", "totalNoDataLrows", "totalNoPageROWS", "totalNoDataROWS", "totalNoDataLOWS", "totalNoDataChrows", "totalNoPageLues"], "mappedBuffer": ["mappedBuff", "mappingBuffer", "mappingFile", "mappingBuff", "mashedBuffer", "Mappedbuffer", "mippedBuff", "mappedbuffer", "MachedURL", "MappedBuff", "machedBuffer", "mappingStream", "MappingChannel", "mapedFile", "MappedStream", "mppedStream", "MachedChannel", "mappingbuffer", "mactedStream", "MappingFile", "mappedURL", "MachedBuff", "mippedURL", "mappedChannel", "MappingBuff", "Machedbuffer", "mippedStream", "mappedFile", "mapedStream", "mapedURL", "MappedBuffer", "machedURL", "MappingBuffer", "MachedBuffer", "machedFile", "MachedFile", "mashedFile", "mashedChannel", "machedStream", "mappedStream", "machedbuffer", "mapedBuff", "MappedFile", "mppedChannel", "mashedBuff", "machedChannel", "mactedBuff", "machedBuff", "mactedbuffer", "mippedBuffer", "mapedBuffer", "mactedBuffer", "MappedURL", "mappingChannel", "MachedStream", "mppedBuff", "mppedBuffer", "MappedChannel"], "startIndex": ["endPoint", "startindex", "startSection", "endInfo", "stopCode", "stopindex", "stopIndex", "StartInfo", "initindex", "useindex", "startRow", " startindex", "endRow", "endCode", "startInfo", "endSection", " startOffset", "startingPosition", "startingIndex", " startCode", "startingPoint", "endIndex", "initIndex", "StartOffset", " startPosition", "startCode", " startInfo", "startPoint", "startPosition", "StartPosition", "initOffset", "endindex", "useIndex", " startPoint", "stopRow", "usePosition", " startRow", "Startindex", " startSection", "startOffset", "StartIndex", "useInfo", "startingSection", "initInfo", "endPosition"], "count": ["first", "test", "cache", "follow", "call", "allow", "found", "id", "force", "current", "child", "old", "total", "Count", "index", "start", "length", "keep", "ind", "time", "more", "thread", "name", "max", "c", "order", "len", "self", "code", "all", "type", "i", "counter", "number", "find", "weight", "list", "depth", "close", "add", "key", "other", "col", "pool", "loop", "coll", "limit", "group", "part", "sum", "size"], "currentMovie": [" currentmovie", "currentFilm", "thismovie", "CurrentTheme", "currentmovie", "defaultMusic", "currentlyPicture", "CurrentMovie", "currentPicture", "parentMovie", "validMovie", "reportedMovie", "reportedFilm", "thisPicture", "thisMovie", "defaultFilm", "validTheme", "reportedImage", "reportedmovie", "defaultMovie", "validFilm", "CurrentFilm", "defaultImage", " currentMusic", "validmovie", "parentmovie", "currentTheme", "Currentmovie", " currentFilm", "thisFilm", "currentMusic", " currentPicture", " currentImage", "currentImage", "currentlyMovie", "reportedMusic", "parentPicture", "reportedPicture", "currentlyMusic", "parentFilm", "reportedTheme"], "movieName": ["Moviename", "filmName", "MovieName", " moviename", "camName", "filmNumber", " movieId", "voiceName", "movieInfo", "moneyName", "moneyFamily", "voicename", "moneyNumber", "voiceId", " movieFamily", "MovieFamily", "moviename", "MovieInfo", "filmname", "MovieId", "voiceInfo", "movieId", "movieNumber", "camFamily", "movieFamily", " movieInfo", "camname", "filmFamily", "MovieNumber"], "customer": ["Customer", "customor", "ustomeri", "mixer", "ustomers", "customER", "CustomER", "Customers", " customER", "mixER", "customers", " customers", " customeri", "ustomer", "mixor", "ustomER", "ustomor", "Customeri", "Customor", "customeri", "mixers"], "rating": ["score", "ring", "url", "feature", "error", "reader", "id", "rr", "string", "ranking", "range", "missing", "ruby", "rate", "type", "writer", "info", "r", "number", "rage", "rated", "Rating", "packing", "setting", "ing", "padding", "alpha", "attribute", "resource", "rolling", "rank", "http", "rc", "data", "RC", "value", "rates", "rice", "including", "reading", "comment", "radius", "writing"], "outBuf1": ["outFufCloud", "outKuf8", "outBafCloud", "outFuf1", "outBummerOne", "outFbuf01", "outBbuff8", "outBbufn", "outBbuf11", "outBaf1", "outBuf3", "outFuf91", "outBaft3", "outBbuff0", "outBuf91", "outBuff8", "outFufOne", "outBuf8", "outCuf0", "outBaf3", "outBuffCloud", "outBalth3", "outBbuf91", "outFbuf1", "outBiff91", "outBaftn", "outKufOne", "outBuf01", "outFafCloud", "outBbuf3", "outBuff3", "outBum91", "outBufOne", "outKbuffOne", "outDuff1", "outKbuff3", "outBufn", "outDuff3", "outKbuff1", "outKuf1", "outBuff1", "outDuf1", "outBaf8", "outFuf01", "outBaf0", "outBbufOne", "outBalth1", "outBaft11", "outCuf1", "outCufOne", "outFafOne", "outKbuf3", "outFbuf91", "outBbuf1", "outBuffOne", "outFbufOne", "outKuf3", "outBbuffOne", "outCuffOne", "outFaf1", "outDuff11", "outKbuff8", "outBbuf2", "outBumOne", "outBuff11", "outBuff2", "outBbuff3", "outBummerCloud", "outBuf0", "outBafOne", "outBbuff1", "outDuf11", "outBiff1", "outBbuf01", "outBiff01", "outBaft1", "outDuf3", "outDuffn", "outBiffOne", "outBuff0", "outKbuf1", "outKuf2", "outBum01", "outCuff1", "outCuff0", "outBummer1", "outDufn", "outBalth2", "outKbuf2", "outBufCloud", "outBuffn", "outBuf11", "outBum1"], "outBuf2": ["outBuf4", "outFbuf2", "outBbuffTwo", "outBuber8", "outFbufB", "outFuf1", "outBoffTwo", "outFuf20", "outBum20", "outBbuff8", "outBuber20", "outBait200", "outBbuff20", "outBbuffer4", "outBbuff0", "outBuff8", "outBuf20", "outFuf8", "outBuf8", "outBbufB", "outBufTwo", "outBum82", "outBuff4", "outWBuf200", "outFbuff20", "outBuffTwo", "outBufB", "outBbufTwo", "outWBuf8", "outFbuff4", "outWBuf2", "outWBbuff200", "outBuff12", "outBbuffer2", "outWBuff4", "outFbuff2", "outBbuff200", "outBuffB", "outBbuff4", "outBum8", "outBait2", "outBait4", "outBbuff82", "outBuber2", "outBuff1", "outFufTwo", "outBuf12", "outFbuf12", "outWBbuffTwo", "outFuf4", "outWBuff0", "outBbuf1", "outBoff8", "outFbuff1", "outBbuf4", "outWBuff8", "outBuber82", "outBait0", "outBbuf2", "outFbuf4", "outBuff2", "outBuf0", "outWBbuff8", "outBbuff1", "outBuf200", "outWBufTwo", "outBaitTwo", "outFbuff8", "outBoff200", "outFuf12", "outFuf82", "outBbuffer12", "outBuff0", "outBum2", "outBbuff2", "outFbuff82", "outBoff2", "outBbuf12", "outWBuf4", "outBuf82", "outFbuffTwo", "outBbufferB", "outFuf2", "outWBuf0", "outFufB", "outWBbuff2", "outBait8", "outWBuff2"], "endOfIndexFile": ["endOfImageFolder", "endOfDataFile", "endofindexTime", "endOfIndexFolder", "endofIndexFile", "endOfindexFile", "endOfImageFiles", "endOfDataDir", "endOfindexFiles", "endofIndexDir", "endofindexFolder", "endofLinkFiles", "endofindexFile", "endOfIndexfile", "end\n", "endOfindexTime", "ended\n", "endfile", "endOfIndexFiles", "endofindexFiles", "endedfile", "endOfIndexTime", "endOfLinkFile", "endOfIndexDir", "endOfLinkfile", " end\n", "endOfClientDir", " endfile", "endOfindexFolder", "endOfDataTime", "endOfClientFiles", "endOfClientTime", "endOfClientFile", "endofIndexFolder", "endOfindexfile", "endOfindexDir", "endOfLinkFiles", "endOfLinkDir", "Endfile", "End\n", "endOfImageTime", "endofLinkDir", "endofLinkTime", "endOfDatafile", "endOfImageFile", "endofLinkFile", "endOfLinkTime", "endofIndexFiles", "endofIndexTime"]}}
{"id1": "20232250", "id2": "942693", "code1": "    private InputStream sendRequest(SequenceI seq) throws UnsupportedEncodingException, IOException {\n        StringBuilder putBuf = new StringBuilder();\n        processOptions(putBuf);\n        putBuf.append(\"INPUT_SEQUENCE=\");\n        putBuf.append(URLEncoder.encode(\">\" + seq.getName() + \"\\n\", ENCODING));\n        putBuf.append(URLEncoder.encode(seq.getResidues(), ENCODING));\n        URL url = new URL(PRIMER_BLAST_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(putBuf.toString());\n        wr.flush();\n        wr.close();\n        apollo.util.IOUtil.informationDialog(\"Primer-BLAST request sent\");\n        return conn.getInputStream();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"sendRequest": ["getRequest", "getCommand", "getResponse", "processCommand", "sendCommand", "writeResponse", "sendResponse", "getrequest", "processRequest", "processResponse", "writeRequest", "processrequest", "writeCommand", "sendrequest", "writerequest"], "seq": ["vec", "flow", "test", "cl", "que", "job", "fast", "pse", "Sequ", "sem", "id", "ence", "ctx", "val", "q", "sequence", "ext", "struct", "queue", " sequence", "pkg", "spec", "prefix", "comp", "sequ", "sel", "sci", "sq", "blast", "batch", "contin", "query", "config", "slice", "iter", "p", "lic", "feat", "rez", "cli", "file", "eq", "ref", "req", "pos", "frame", "ctrl", "iq"], "IOException": ["TimeoutException", "IPError", "IOError", "TimeoutError", "IPException", "IPception", " IOception", " IOError", "Timeoutception", "IOception"], "putBuf": [" putBuff", " putWBbuf", "putGBump", "putWuf", "putWurb", " putBump", "fileSBuf", " putWBob", "printFob", "cutbault", "putWob", "putTuf", "putBob", "putGBuff", "putWBurb", "putFuc", "putWuff", "cutbump", "putTuch", "logBBault", "putFump", "putPluc", "putFob", "putTump", "putBaseuf", "putBoump", "putGBault", "putBsundle", " putWBurb", " putBob", "putFurb", "putBault", "putbault", "logBBuff", "cutBump", " putBuc", "putBsault", " putPluf", "putBsuf", "putBurb", " putBbuf", "logBBuf", "fileSBump", "putBuch", "putBaseault", "putBBundle", "cutBuff", "printBuf", "putFault", "printBob", "putBundle", "putbuff", "putBolf", "putBBbuf", "putWBbuf", "cutbuf", "fileBuch", "putPlump", "putTlf", " putPluc", "putBouch", "putBuff", "fileBuf", "putSBuch", "printBuff", "putWBuf", "putFbuf", "fileBlf", "putSBump", "putBBuff", "putBBob", " putWBuf", "printBbuf", "printFuff", "putGBundle", "putSBuf", "putBump", "cutbuff", "putWBob", "cutBuf", "putBlf", "putBouf", "putFuf", "putBaseump", "putbuf", "logBault", "putBuc", "fileBump", "putPluff", "putbump", "putBBault", "putBbuf", "putPluf", "putSBlf", "putBBuf", " putPluff", "logBundle", "putBsuff", "putFuff", " putBurb", "putWbuf", " putPlump", "logBuf", "putGBuf", "fileSBlf", "cutBault", "putBaseuff", "logBBundle", "printFuf", "logBuff", "fileSBuch", "putGBuc", "printFbuf"], "url": ["base", "client", "URL", "jar", "db", "log", "sl", "fl", "Url", "host", "string", "ls", "c", "ctrl", "org", "ssl", "connection", "r", "ll", "www", "socket", "ur", "fr", "uri", "lr", "resource", "http", "l", "source", "file", "channel", "server", "download", "coll", "impl", "open", "web", "rl", "blog", "f", "il"], "conn": ["exec", "fp", "cm", "lc", "mc", "client", "ann", "util", "io", "cur", "db", "ctx", "connect", "out", "conv", "cp", "cr", "c", "ci", "err", "rt", "org", "ct", "ssl", "connection", "r", "Connection", "n", "enc", "co", "loc", "nt", "socket", "nw", "sync", "wb", "dc", "p", "close", "rc", "l", "channel", "ch", "cn", "act", "addr", "fn", "coll", "pc", "con", "nc", "Conn", "open", "ctrl", "cb", "ait"], "wr": ["wt", "wa", "wk", "wire", "wrap", "w", "rh", "sr", "mr", "war", "wl", "raw", "rr", "spr", "ws", "nr", "wer", "raft", "hr", "wx", "rw", "wal", "writer", "Writer", "r", "kr", "rx", "Wr", "nw", "wb", "fr", "wh", "wm", "dr", "RW", "fw", " writer", "rss", "sw", "shr", "WR", " Wr"]}}
{"id1": "4629990", "id2": "11952735", "code1": "    private String logonToServer(FTPClient ftpClient, String ftpAddress, int noRetries) {\n        String remoteHomeDir = null;\n        noRetriesSoFar = 0;\n        while (true) {\n            try {\n                ftpClient.connect(ftpAddress, ftpPort);\n                int reply = ftpClient.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftpClient.disconnect();\n                    throw new IOException();\n                }\n                if (!ftpClient.login(user, password)) {\n                    throw new IOException();\n                }\n                remoteHomeDir = ftpClient.printWorkingDirectory();\n                msgEntry.setAppContext(\"logonToServer()\");\n                msgEntry.setMessageText(\"Logged into FTP server \" + ftpAddress + \":\" + ftpPort + \" as user \" + user);\n                logger.logProcess(msgEntry);\n                break;\n            } catch (IOException e) {\n                logoutAndDisconnect(ftpClient);\n                if (noRetriesSoFar++ < noRetries) {\n                    waitBetweenRetry();\n                    notifyAndStartWaitingFlag = false;\n                } else {\n                    notifyAndStartWaitingFlag = true;\n                    errEntry.setThrowable(e);\n                    errEntry.setAppContext(\"logonToServer()\");\n                    errEntry.setAppMessage(\"Unable to login after \" + (noRetriesSoFar - 1) + \" retries. Max Retries.\\n\" + \"Address:\" + ftpAddress + \"\\n\" + \"User:\" + user);\n                    errEntry.setSubjectSendEmail(\"Unable to login to \" + ftpAddress + \" after \" + (noRetriesSoFar - 1) + \" retries.\");\n                    logger.logError(errEntry);\n                    break;\n                }\n            }\n        }\n        return remoteHomeDir;\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 0, "substitutes": {"logonToServer": ["logonToGuest", "logOnFromRemote", "logOnFromClient", "logOnToRemote", "logOnToServer", "logOnFromServer", "logonTOClient", "logonFromServer", "logonTOGuest", "logOnToClient", "logonFromGuest", "logOnToGuest", "logonFromClient", "logonFromRemote", "logontoRemote", "logonTOServer", "logonTORemote", "logontoClient", "logOnFromGuest", "logonToRemote", "logontoServer", "logonToClient", "logontoGuest"], "ftpClient": ["ftcpAPI", "ftpaClient", "ctpPort", "ftbclient", "ftbConn", "ftcpPort", "ctcpConn", "ctcpConnect", "ctcpServer", "ftapclient", " ftpCloud", "ftpConnect", "ftpaCloud", "ftpaConn", "ftpcClient", "ftcpCenter", "ftprClient", " ftpclient", "ftpaServer", "ftpclient", " ftpaServer", " ftpaClient", "ftcpContext", "ftpiServer", "ftpcConnect", "ftpConn", "ftprPort", "ftpiClient", "ftpcServer", "ftpcPort", "ftcServer", " ftbCloud", "ftpcContext", " ftpPort", " ftpcServer", " ftpcClient", "ftpiAddress", "ftsPort", "ftcpClient", "ftcConnection", "ctpAPI", "ctpServer", "ftcClient", "ftcpConn", " ftpcContext", "ftpcAddress", "ftpaPort", "ftsClient", " ftpConn", "ftcpConnection", "ftpaCenter", "ftcpServer", "ctpConnect", "ftbPort", " ftpaclient", " ftpServer", "ftsServer", "ctcpAddress", "ctcpAPI", " ftpConnection", "ctpAddress", "ftpConnection", "ftpcclient", "ftpcConn", "ftbCloud", "ftnAddress", " ftpcConnection", "ctcpClient", "ftapCenter", "ftcContext", " ftpCenter", " ftpaCenter", "ftnServer", "ctcpPort", "ftpCloud", "ftbClient", "ftpContext", "ftpAPI", "ftcpConnect", "ftnClient", "ftapClient", "ftpcCloud", "ftsConnect", "ftnAPI", " ftpaPort", "ftapServer", "ctpConn", "ctpClient", "ftpServer", "ftpiAPI", "ftcpAddress", "ftcpclient", "ftprclient", "ftpcConnection", "ftpaAddress", " ftpContext", "ftpaclient", "ftpPort", " ftbConn", "ftpCenter", " ftbClient", " ftbclient"], "ftpAddress": ["ctpPort", "ftcpURL", "ftcpPort", " ftpaddress", "ftfAdd", "ftoAddress", "ftapPort", "ctoPort", "ftfEntry", " ftcpaddress", "ctpAdd", "ftoaddress", "ftfPort", "ftapAlias", "ctcpURL", "ftlAddress", "ftcpInterface", " ftcpAddress", "ftrInterface", "ftwpAddress", " ftcpPort", "ftportaddress", "ftnpAddress", " ftpPort", "ctcpaddress", "ctcpInterface", "ftlPort", "ctpaddress", "ftnpPort", "ftwpaddress", " ftcpAlias", "ctoAddress", "ftportPort", "ftfInterface", "ftportAlias", "fttpPort", "ctcpAdd", "ctcpAddress", "ctpInterface", "ftapaddress", "ftnpURL", "ctpAddress", "ctoaddress", "ftcpaddress", "ftpInterface", "ctpEntry", "ftpURL", "ftrPort", "ftrAdd", "ftpAdd", "ftladdress", "ctcpEntry", "ctcpPort", "ftcpAlias", "fttpURL", "ftfAddress", "ftpAlias", "ftwpPort", "ftpEntry", "ftapAddress", "ctpURL", "ftcpAddress", "ftnpaddress", "fttpEntry", "fttpaddress", "ftrAddress", "ftfaddress", "ftcpEntry", "ftcpAdd", "ftportAddress", "ftpPort", "ftpaddress", "fttpAddress", "ftoPort", " ftpAlias"], "noRetries": ["noretrying", "noEntrying", " noPatriers", " noRetrys", " noPatries", "noPatrys", "noTry", "noTrying", "noPatry", "noPatriers", "noTrys", "noExtrys", "noExtrying", "noretries", "noExtries", " noPatry", "noRetrying", "noEntries", "noTries", " noPatrying", " noRetriers", "noRetriers", "noPatries", " noPatrys", " noRetry", "noretrys", "noRetrys", "noRetry", "noretriers", "noEntrys", "noEntriers", " noRetrying", "noExtry", "noPatrying"], "remoteHomeDir": ["remoteHomePath", "RemoteRootPath", " remoteHomeFolder", "remoteHostPath", "RemoteHomeFile", "remoteWorkingPath", "remoteRootDir", " remotehomeFolder", "remoteHomeFolder", " remotehomeFile", "remotehomePath", "remoteHostDirectory", "remoteRootPath", "remotehomeFolder", "remoteRootDirectory", "remoteHostDir", "RemoteRootFile", "remoteHostFolder", " remoteHomeDirectory", "RemoteRootDirectory", "remoteRootFile", "remoteWorkingDir", " remotehomeDir", "RemoteHomeDirectory", "remoteHomeDirectory", "remotehomeFile", "remoteRootFolder", "RemoteRootDir", "RemoteHomeDir", "remotehomeDirectory", "remoteWorkingDirectory", "remoteHostFile", "RemoteHomePath", " remoteHomeFile", "remotehomeDir", " remotehomeDirectory", "remoteHomeFile", "remoteWorkingFile"], "noRetriesSoFar": ["noRetryingsoMuch", "noRetriesSOFurther", "noRetriesStillFurther", "noRetriesSofar", "noRetriessoFar", "noRetrySoFar", "noRetriesTooMuch", "noRetriesSoFurther", "noRetrySOfar", "noRetrysSOFar", "noRetrysSoFar", "noRetriesStillFar", "noRetrysSOfar", "noRetryingSoMuch", "noRetriessoMuch", "noRetriessofar", "noRetriessoFurther", "noRetryingsofar", "noRetrysSofar", "noRetrySOFar", "noRetriesSoMuch", "noRetrysSoFurther", "noRetriesSOMuch", "noRetriesSincefar", "noRetrySofar", "noRetriesTooFar", "noRetriesSOfar", "noRetrysSOFurther", "noRetryingSoFar", "noRetryingsoFar", "noRetryingSofar", "noRetriesSOFar", "noRetriesSinceFar", "noRetriesToofar", "noRetriesStillfar"], "reply": ["address", "result", "base", "error", "lie", "ping", "send", "status", "call", "answer", "comment", "feed", "request", "py", "state", "ret", "queue", "prefix", "link", "len", "bot", "next", "write", "code", "respond", "reason", "repl", "connection", "count", "info", "user", "report", "Reply", "sync", "ply", "message", "post", "service", "ix", "from", "rc", "dy", "resp", "server", " replies", " replied", "response"]}}
{"id1": "771802", "id2": "18114701", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"createOutputStream": [" createInputReader", "createInputFile", " createIOReader", "createInputSteam", " createOutputReader", " createIOFile", " createByteReader", "createOutputReader", "createInputStream", " createOutputSteam", " createByteFile", "createOutputFile", " createInputSteam", " createIOStream", " createOutputFile", "createInputReader", " createInputStream", " createByteStream", " createInputFile", "createOutputSteam", " createIOSteam", " createByteSteam"], "inFile": ["sourceFiles", "sourceStream", "inputFile", "incFile", "outStream", "infile", "insfile", "inputStream", "incfile", "sourcefile", "inStream", "insFile", "incStream", "sourceFile", "inputFiles", "incFiles", "insStream", "outfile", "inFiles", "outFiles", "insFiles", "inputfile"], "outFile": ["workingfile", "outDir", "inputDir", "workFile", "targetFile", "inputFile", "workTime", "workingStream", "targetfile", "outStream", "workfile", " outfile", "infile", "outDirectory", "inTime", "workDir", "inputTime", " outStream", " outDirectory", "targetStream", "targetDirectory", "outTime", "outfile", "workingFile", "inDir", "workingDirectory", "inputfile"], "k_blockSize": ["k_lockCount", "k_BlockLength", "k_BlockCode", "k_byteCode", "k_byteLength", "k_lineInfo", "k_BlockSize", "k_blockCount", "k_blocksSize", "k_byteLen", "k_bitSize", "k_lineCount", "k_blocksCount", "k_bitCount", "k_lockLength", "k_lockLen", "k_BlockCount", "k_blockLen", "k_byteSize", "k_blocksLen", "k_bitInfo", "k_blockInfo", "k_blockCode", "k_byteCount", "k_lockCode", "k_blocksLength", "k_lineSize", "k_lockSize", "k_byteInfo", "k_blockLength"], "byteCount": [" bytecount", "blockSum", "byteSize", "bytecount", "byteLength", "flushCount", " byteSize", "flushcount", "characterCount", "blockSize", "blockCount", "characterLength", "blockLength", "Bytecount", "ByteSize", "byteSum", "flushLength", "ByteCount", " byteLen", "byteLen", "characterSize", "ByteLength", "ByteSum", " byteSum", "ByteLen", "flushSize", "characterLen", " byteLength"], "buf": ["vec", "uf", "Buffer", "cap", "result", "base", "img", "exc", "tmp", "cv", "feed", "brace", "font", "ctx", "fb", "border", "seq", "cmd", "queue", "len", "alloc", "bag", "Buff", "batch", "b", "background", "loc", "config", "buffer", "la", "bytes", "rb", "flush", "cas", "fd", "feat", "rc", "ucc", "data", "append", "bh", "src", "bf", "cb", "buff"], "ofp": ["fort", "afc", "Ofnp", "afp", "OFl", "forc", "ofnp", "Oft", "oftp", "forp", "OFt", "Ofp", "OFp", "oft", "ofl", "afl", "ofc", "afnp", "fortp", "OFc", "OFnp", "Ofc", "Oftp", "Ofl", "OFtp"], "zos": ["osi", "outs", "kos", "core", "zon", "budget", "zes", "os", "modules", "ozo", "zyk", "los", "ossus", "cos", "jas", "inos", "robe", "ZI", "zik", "utils", "zy", "enos", "soon", "ls", "zen", "zona", "zn", "iframe", "zi", "css", "rons", "zag", "hz", "abi", "forge", "bes", "obb", "ros", "oS", "bitcoin", "zar", "ZA", "zh", "zip", "zers", "oda", "liquid", "tz", "zl", "webkit", "bos", "owicz", "js", "za", "lins", "oses", "zx", "nz", "rez", "gz", "lol", "dylib", "z", "zin", "ws", "uz", "ses", "cfg", "iffs", "zer", "ops", "zo", "fits", "zig", "ogl", "obs", "zb", "packs", "nox", "bs"], "osw": ["lsx", "osww", "ishell", "esow", "bwo", "ossww", "essw", "oshell", "esw", "lsws", "oswo", "esnow", "osssw", "lswo", " osow", "bx", "osnow", "bsws", "osow", "ossw", "bsw", "bws", "esfw", "osswd", "isy", "isnow", "isw", "ossnow", "ossd", "esd", "osy", "osshell", " osww", "osws", "esww", "isd", "esy", "lsw", "ossow", "eswd", "iswd", " osfw", "ossfw", "issw", "ossy", "bswo", "osfw", "eshell", "bsx", "osx", "osd", "oswd"], "bw": ["lbwh", "abW", "bbz", "bbw", "abw", "bW", "bbew", "bbwa", " bwh", " bws", "lwa", "lbw", "bwa", "Bws", "baw", "bbws", " bwa", "owa", "bx", "fbwd", "bwu", "ebwd", "bwd", "lx", "bsw", "Bwa", "bwh", "bz", "bws", "lbws", "ebw", "fsw", "fbwe", "lbwa", "Bew", "fbW", "fx", "fwh", "bwe", "lbr", " bwu", "Bw", "lw", "bbwu", "lbx", "ow", "owu", "lsw", "fr", "fwa", "lbsw", "abwe", "bew", " baw", "lbz", "ebwe", "fbw", "fw", "bbaw", " bz", " bew", "ebW", "oaw", "bbwh", "abwd"], "zot": ["jot", "zott", " zor", "jori", "Ziot", "azit", "zerot", "jit", "Zor", "zita", "azita", "zeros", " ziot", "azot", "zor", "jos", "azott", "zerott", "zerita", " zori", "aziot", "Zott", "zori", "Zot", "azor", "zerori", "ziot", "Zita", "Zit", "zerit"], "ifp": ["ipl", "ipc", "iff", " ifb", "Iff", " ifi", "IFi", "ifb", "Ifi", "IFf", " ifl", "IFb", "ifi", "ipp", " ifc", "IFp", "ifc", "ipb", "IFl", "Ifc", "IFc", "ifl", "Ifp", " iff"], "zis": ["zipis", "xib", " zits", " zisi", "zeis", "xis", "zip", "zeip", " zib", "jit", " zIS", "Zits", "Ziss", "jits", "zenIS", "xits", "zeits", "zenib", "xais", "zais", "jisi", "xisi", "zenais", "Zis", "jis", "zipiss", "zib", "zIS", "zipits", "zisi", "xIS", "zipip", "zenis", "zeiss", "Zip", "zits", "xit", " zais", "ziss"], "isr": ["IScr", "isrs", "risr", " issr", "issrs", "risrc", "isrc", "rispr", "isrb", "isscr", "ISsr", "irpr", "ISrs", "isssr", "irrb", "ispr", "ISrc", "ISrb", "ISpr", " isrs", "irrc", "risrb", "ISr", " iscr", "iscr", "issr", "irr"], "br": ["yr", "bc", "obl", "img", "mr", "sr", "str", "ob", "bp", " Br", "ibr", "ber", "HR", "arr", "div", "hr", "rib", "bsp", "obi", "bro", "err", "bl", "Br", "r", "b", "kr", "browser", "bar", "body", "tr", " dr", "fr", "lr", "ibl", "rb", " fr", " BR", "BR", "ch", "bh", "gr", "cro", "sp", "ctr", "rs", "shr", "ocr"], "zit": ["zenits", "zenitter", " zits", "zipit", "zipitter", "zenit", "zip", "zenith", "xi", "jita", " zip", "zipita", "jit", "zipith", "zeit", "jits", " zite", "zith", "jith", "zita", "zeits", "zIT", "zeIT", "zeith", "zipIT", "zitter", "jite", "zi", "xith", "xic", " zic", " zith", "zeitter", "zite", "jip", "zipits", "zipite", "jic", "zipip", "ji", "zits", "xit", "zic", "jIT", "zeita", " zi"]}}
{"id1": "13414771", "id2": "16719805", "code1": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 0, "substitutes": {"encriptPassword": [" desjectPassword", " desryptPass", " enjectSecret", " desryptpassword", " descodePass", " desryptPassword", " enjectpassword", " descriptSecret", " encriptPass", " descriptpassword", " descodePassword", " encriptpassword", " desryptSecret", " encriptSecret", " enjectPass", " enjectPassword", " desjectSecret", " desjectPass", " descodeSecret", " descodepassword", " desjectpassword", " descriptPassword", " descriptPass"], "passwd": ["failpassword", "Password", "asspassword", " passpassword", "Passw", "Passwd", "passw", " password", "Passwt", "assword", " passwt", "failword", "Passpassword", " passw", "password", "asswd", "failwt", "assw", "failwd", "passpassword", "passwt"], "md": ["mad", "MD", "mc", "dig", "ms", "sha", "gb", "metadata", "rm", "pm", "bd", "amd", "bm", "mo", "mb", "mt", "cmd", "hd", "sm", "mand", "m", "dd", "gd", "od", "mg", "mm", "ma", "ad", "pd", "cd", "kg", "wd", "nd", "mac", "mod", "hm", "di", "ld", "d", "mag", "nm", "vd", "dm", " MD", "mp"], "hash": ["shadow", "sha", "ash", "rh", "check", "Hash", "log", "index", "node", "string", "kh", "image", "hex", "build", "auth", "print", "html", "user", "count", "number", "object", "body", "hed", "her", "message", "array", "version", "key", "mac", "h", "copy", "sh", "password", "num", "oh", "value", "square", "sum", "f", "dig"]}}
{"id1": "14047629", "id2": "21308543", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 1, "substitutes": {"source": ["ource", "exec", "fp", "result", "processor", "reader", "status", "project", "parse", "transfer", "load", "proxy", "proc", "path", "request", "remote", "input", "session", "target", "out", "cp", "stream", "inner", "image", "Source", "comp", "info", "connection", "class", "text", "object", "parent", "config", "ources", "loader", "buffer", "service", "resource", "content", "document", "in", "file", "server", "src", "SOURCE"], "process": ["exec", "result", "processor", "master", "share", "cess", "console", "system", "job", "project", "call", "status", "output", "use", "port", "app", "command", "progress", "proc", "worker", "path", "index", "target", "python", "machine", "session", "node", "thread", "image", "method", "pid", "class", "object", "parent", "program", "task", "pipe", "press", "the", "post", "parser", "display", "resource", "p", "copy", "document", "file", "processing", "work", "loop", "Process", "script", "open", "run"], "processStdOut": ["processStdinOut", "processSTdinOUT", "processSTdOut", "processStdOutput", "processSTdinOut", "processStdOUT", "processStdinOUT", "processStDOUT", "processStDObj", "processStdinObj", "processSttObj", "processStDOut", "processStdObj", "processStDOutput", "processSttOutput", "processSTdinObj", "processSTdOUT", "processSttOut", "processSttOUT", "processSTdObj", "processSTdinOutput", "processSTdOutput", "processStdinOutput"], "processStdIn": ["processStdinOut", "processStrdIn", "processSttin", "processStsin", "processSttInput", "processStrdIns", "processStsIn", "processStbin", "processStbIns", "processSttIN", "processStdIN", "processStrdInput", "processStrtIn", "processStbIn", "processStdInput", "processStdin", "processSttIn", "processStsInput", "processStrdin", "processStsIns", "processStbIN", "processStrtIns", "processSttOut", "processStdinIn", "processStbOut", "processStrtInput", "processStbInput", "processStdinIN", "processStdIns", "processSttIns", "processStrtin", "processStdinin"]}}
{"id1": "7872659", "id2": "12306305", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieIndexPath", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndmovieindexfile", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndmovieIndexfile"], "completePath": ["completeHome", " completeRoot", " completeCorp", "execpath", "doneLoader", "successPath", " CompleteDir", "completeCh", " completepath", "CompletePath", "doneVol", "CompleteDir", "completeVol", " completePoint", "itePath", "flatPath", " completeDir", "donePath", "completeCorp", "iteMusic", "successCh", "execLoader", "completeFile", "iteCh", "correctPoint", " CompletePath", "completeMusic", "completeRoot", "donepath", "successMusic", "completepath", "completeLoader", "itepath", "completePoint", "progressLoader", "progresspath", "CompleteHome", " completeCh", "progressPath", " completeHome", "flatRoot", "execPath", "flatCorp", "progressVol", "completeDir", "correctPath", "flatPoint", " CompleteHome", "execVol", "correctCorp", " completeMusic", " completeFile", " CompleteFile", "correctRoot", "CompleteFile", "successpath"], "masterFile": ["masterFiles", " masterName", "MasterFilename", "MasterName", "cacheFiles", "masterName", "MasterPath", "cachePath", "masterPath", "MasterFiles", "configFilename", "mastersFile", " masterPath", "cacheFile", "masterFilename", "MasterFILE", "mastersPath", " masterFilename", "MasterFile", "configPath", "configFile", "mastersFILE", "cacheFILE", "masterFILE", "mastersFiles", "configName"], "CustRatingFileName": ["CustRatingClassPath", "CustIndexFilesVersion", "CustIndexFileName", "CustRatingFilesName", "CustRatingFilenameSize", "CustRatingFilenameName", "CustRateFileName", "CustRateFilenameDesc", "CustRatingFilesDesc", "CustRatingFileVersion", "CustRatingFileSize", "CustIndexFilesType", "CustRateFileSize", "CustIndexFilesName", "CustRatingFilenamePath", "CustRatingFullDesc", "CustRateFilenameName", "CustIndexFilesPath", "CustRateFileDesc", "CustRatingFullPath", "CustRatingLineVersion", "CustRatingClassVersion", "CustRatingFileDesc", "CustRatingLineName", "CustRatingClassName", "CustRatingFilePath", "CustRatingFilesSize", "CustRateFilePath", "CustRatingFullName", "CustRatingLineType", "CustRateFilenamePath", "CustRatingFileType", "CustRatingLinePath", "CustRatingFullSize", "CustIndexFileVersion", "CustRatingClassType", "CustIndexFileType", "CustRatingFilesPath", "CustIndexFilePath", "CustRatingFilenameDesc", "CustRatingFilesType", "CustRateFilenameSize", "CustRatingFilesVersion"], "MovieIndexFileName": ["MovieIndexPlaceFile", "MovieConfigFolderFile", "MovieIndexFileHandle", "MovieIndexClassSize", "MovieIndexFName", "MovieEditFilename", "MovieConfigFolderName", "MovieConfigFileHandle", "MovieConfigFileVersion", "MovieIndexFolderName", "MovieIndexFileVersion", "MovieIndexPlaceName", "MovieIndexClassName", "MovieIndexFSize", "MovieIndexFilesUrl", "MovieEditFname", "MovieIndexClassname", "MovieConfigFolderVersion", "MovieEditFSize", "MovieConfigFileName", "MovieEditFUrl", "MovieIndexClassUrl", "MovieConfigFileFile", "MovieIndexFILEVersion", "MovieIndexFilesname", "MovieIndexFileSize", "MovieIndexFolderHandle", "MovieIndexFilesSize", "MovieConfigFolderHandle", "MovieIndexFILEFile", "MovieIndexFname", "MovieEditFileName", "MovieIndexFolderVersion", "MovieEditFileSize", "MovieIndexFUrl", "MovieIndexFolderFile", "MovieIndexPlaceHandle", "MovieEditFName", "MovieIndexFileFile", "MovieIndexFileUrl", "MovieIndexFILEName", "MovieIndexFILEHandle", "MovieEditFileUrl", "MovieIndexPlaceVersion", "MovieIndexFilename", "MovieIndexFilesName"], "inFile": ["Infile", "inputF", "inputFile", "InFile", "InF", "incFile", "inF", "incC", "InSourceFile", "inputSourceFile", "incSourceFile", "outFile", "infile", "outC", "incfile", " inF", " infile", "outfile", " inSourceFile", "outSourceFile", "inSourceFile", "inputfile"], "inC": ["inB", "InB", "inputF", " inCL", "innerCI", "outCC", "inputFile", "InFile", "InF", "outB", "inF", " inCC", "inCL", "outFile", "outC", "inputC", "innerFile", "inputCC", " inF", "InCI", " inB", "InCC", "innerCC", "outF", "outCL", "InCL", "outCI", "inCC", "innerC", "inCI", "InC"], "outFile1": ["outputFileName", "outFName", "againCFirst", "againC3", "outputFileId", "outPlaceId", "outCFirst", "outF1", "outFileName", "outFile3", "againFile1", "outPathFirst", "outPath1", "outFiles1", "outPath2", "outFilesFirst", "outfile1", "outfileId", "outF2", "outPath3", "outFileFirst", "outPlace1", "outFiles3", "outputFile1", "againFile3", "outC3", "againC1", "outFiles2", "againFile2", "outfileName", "outPlaceName", "outFileId", "outputFile2", "outputfileName", "outputfileId", "outputfile2", "outPlace2", "outFId", "outfile2", "againC2", "againFileFirst", "outputfile1"], "outC1": ["newc1", "outC81", "outD1", "outCFirst", "outD8", "outF1", "outcFirst", "outFOne", "newC81", "outCFFirst", "outD81", "newc81", "newCFirst", "outF2", "outD2", "againB8", "againC8", "outCF81", "outCFOne", "newCOne", "outDOne", "outc1", "outB1", "againB1", "outBOne", "againCOne", "outcOne", "outB8", "newcOne", "newcFirst", "outB2", "againBOne", "outF8", "outc81", "outC8", "newC1", "againC2", "againB2", "outCOne", "outCF1", "outDFirst", "againC1"], "outFile2": ["outFile4", "outputfile5", "outFiles6", "outDirectory4", "outFile5", "againFile6", "againFile1", "outFilesTwo", "againLine1", "outDirectory2", "outFiles1", "outDirectory5", "againFileTwo", "outLineTwo", "outputFile4", "outFileTwo", "outputFile5", "outChannel2", "outChannel1", "outLine2", "outDirectoryTwo", "outChannel6", "againLine2", "outfile4", "outFiles2", "outputFileTwo", "againFile2", "outFiles5", "outLine6", "outputFile2", "outfile5", "outChannelTwo", "againLine6", "outputfile2", "outfileTwo", "outLine1", "outfile2", "outputfileTwo", "againLineTwo", "outFile6", "outFiles4", "outputfile4"], "outC2": ["outFile4", "outFTwo", "outCache1", "outCII", "outF1", "outCache2", "outFII", "outB4", "OutF1", "againC4", "outCache4", "outF2", "OutF2", "OutC1", "outFileTwo", "outCacheII", "outCTwo", "OutCII", "OutC2", "OutC4", "OutFII", "outB1", "againB1", "againCTwo", "againBTwo", "outBTwo", "outF4", "outB2", "outC4", "outFileII", "againC2", "againB2", "againB4", "OutF4", "againC1"], "fileSize": ["bufferMode", " fileMode", " fileAddress", " fileSIZE", "imageLength", "imageSize", " fileLength", "fileAddress", "bufferSize", "fileMode", "bufferLength", "FileLength", "resourceSize", "resourceSIZE", "FileSize", "FileSIZE", "FileAddress", "fileLength", "FileMode", "imageSIZE", "resourceAddress", "fileSIZE"], "totalNoDataRows": ["totalNoPageRues", "totalNoDataChOWS", "totalNoDataRrows", "totalNoPageRrows", "totalNoDataCues", "totalNoPageLOWS", "totalNoDataRues", "totalNoDataLues", "totalNoPageLrows", "totalNoDataCows", "totalNoPageLows", "totalNoDataChows", "totalNoDataLows", "totalNoDataCrows", "totalNoDataChues", "totalNoDataCOWS", "totalNoPageRows", "totalNoDataLrows", "totalNoPageROWS", "totalNoDataROWS", "totalNoDataLOWS", "totalNoDataChrows", "totalNoPageLues"], "mappedBuffer": ["mappedBuff", "mappingBuffer", "mappingFile", "mappingBuff", "mashedBuffer", "Mappedbuffer", "mippedBuff", "mappedbuffer", "MachedURL", "MappedBuff", "machedBuffer", "mappingStream", "MappingChannel", "mapedFile", "MappedStream", "mppedStream", "MachedChannel", "mappingbuffer", "mactedStream", "MappingFile", "mappedURL", "MachedBuff", "mippedURL", "mappedChannel", "MappingBuff", "Machedbuffer", "mippedStream", "mappedFile", "mapedStream", "mapedURL", "MappedBuffer", "machedURL", "MappingBuffer", "MachedBuffer", "machedFile", "MachedFile", "mashedFile", "mashedChannel", "machedStream", "mappedStream", "machedbuffer", "mapedBuff", "MappedFile", "mppedChannel", "mashedBuff", "machedChannel", "mactedBuff", "machedBuff", "mactedbuffer", "mippedBuffer", "mapedBuffer", "mactedBuffer", "MappedURL", "mappingChannel", "MachedStream", "mppedBuff", "mppedBuffer", "MappedChannel"], "startIndex": ["endPoint", "startindex", "startSection", "endInfo", "stopCode", "stopindex", "stopIndex", "StartInfo", "initindex", "useindex", "startRow", " startindex", "endRow", "endCode", "startInfo", "endSection", " startOffset", "startingPosition", "startingIndex", " startCode", "startingPoint", "endIndex", "initIndex", "StartOffset", " startPosition", "startCode", " startInfo", "startPoint", "startPosition", "StartPosition", "initOffset", "endindex", "useIndex", " startPoint", "stopRow", "usePosition", " startRow", "Startindex", " startSection", "startOffset", "StartIndex", "useInfo", "startingSection", "initInfo", "endPosition"], "count": ["first", "test", "cache", "follow", "call", "allow", "found", "id", "force", "current", "child", "old", "total", "Count", "index", "start", "length", "keep", "ind", "time", "more", "thread", "name", "max", "c", "order", "len", "self", "code", "all", "type", "i", "counter", "number", "find", "weight", "list", "depth", "close", "add", "key", "other", "col", "pool", "loop", "coll", "limit", "group", "part", "sum", "size"], "currentMovie": [" currentmovie", "currentFilm", "thismovie", "CurrentTheme", "currentmovie", "defaultMusic", "currentlyPicture", "CurrentMovie", "currentPicture", "parentMovie", "validMovie", "reportedMovie", "reportedFilm", "thisPicture", "thisMovie", "defaultFilm", "validTheme", "reportedImage", "reportedmovie", "defaultMovie", "validFilm", "CurrentFilm", "defaultImage", " currentMusic", "validmovie", "parentmovie", "currentTheme", "Currentmovie", " currentFilm", "thisFilm", "currentMusic", " currentPicture", " currentImage", "currentImage", "currentlyMovie", "reportedMusic", "parentPicture", "reportedPicture", "currentlyMusic", "parentFilm", "reportedTheme"], "movieName": ["Moviename", "filmName", "MovieName", " moviename", "camName", "filmNumber", " movieId", "voiceName", "movieInfo", "moneyName", "moneyFamily", "voicename", "moneyNumber", "voiceId", " movieFamily", "MovieFamily", "moviename", "MovieInfo", "filmname", "MovieId", "voiceInfo", "movieId", "movieNumber", "camFamily", "movieFamily", " movieInfo", "camname", "filmFamily", "MovieNumber"], "customer": ["Customer", "customor", "ustomeri", "mixer", "ustomers", "customER", "CustomER", "Customers", " customER", "mixER", "customers", " customers", " customeri", "ustomer", "mixor", "ustomER", "ustomor", "Customeri", "Customor", "customeri", "mixers"], "rating": ["score", "ring", "url", "feature", "error", "reader", "id", "rr", "string", "ranking", "range", "missing", "ruby", "rate", "type", "writer", "info", "r", "number", "rage", "rated", "Rating", "packing", "setting", "ing", "padding", "alpha", "attribute", "resource", "rolling", "rank", "http", "rc", "data", "RC", "value", "rates", "rice", "including", "reading", "comment", "radius", "writing"], "outBuf1": ["outFufCloud", "outKuf8", "outBafCloud", "outFuf1", "outBummerOne", "outFbuf01", "outBbuff8", "outBbufn", "outBbuf11", "outBaf1", "outBuf3", "outFuf91", "outBaft3", "outBbuff0", "outBuf91", "outBuff8", "outFufOne", "outBuf8", "outCuf0", "outBaf3", "outBuffCloud", "outBalth3", "outBbuf91", "outFbuf1", "outBiff91", "outBaftn", "outKufOne", "outBuf01", "outFafCloud", "outBbuf3", "outBuff3", "outBum91", "outBufOne", "outKbuffOne", "outDuff1", "outKbuff3", "outBufn", "outDuff3", "outKbuff1", "outKuf1", "outBuff1", "outDuf1", "outBaf8", "outFuf01", "outBaf0", "outBbufOne", "outBalth1", "outBaft11", "outCuf1", "outCufOne", "outFafOne", "outKbuf3", "outFbuf91", "outBbuf1", "outBuffOne", "outFbufOne", "outKuf3", "outBbuffOne", "outCuffOne", "outFaf1", "outDuff11", "outKbuff8", "outBbuf2", "outBumOne", "outBuff11", "outBuff2", "outBbuff3", "outBummerCloud", "outBuf0", "outBafOne", "outBbuff1", "outDuf11", "outBiff1", "outBbuf01", "outBiff01", "outBaft1", "outDuf3", "outDuffn", "outBiffOne", "outBuff0", "outKbuf1", "outKuf2", "outBum01", "outCuff1", "outCuff0", "outBummer1", "outDufn", "outBalth2", "outKbuf2", "outBufCloud", "outBuffn", "outBuf11", "outBum1"], "outBuf2": ["outBuf4", "outFbuf2", "outBbuffTwo", "outBuber8", "outFbufB", "outFuf1", "outBoffTwo", "outFuf20", "outBum20", "outBbuff8", "outBuber20", "outBait200", "outBbuff20", "outBbuffer4", "outBbuff0", "outBuff8", "outBuf20", "outFuf8", "outBuf8", "outBbufB", "outBufTwo", "outBum82", "outBuff4", "outWBuf200", "outFbuff20", "outBuffTwo", "outBufB", "outBbufTwo", "outWBuf8", "outFbuff4", "outWBuf2", "outWBbuff200", "outBuff12", "outBbuffer2", "outWBuff4", "outFbuff2", "outBbuff200", "outBuffB", "outBbuff4", "outBum8", "outBait2", "outBait4", "outBbuff82", "outBuber2", "outBuff1", "outFufTwo", "outBuf12", "outFbuf12", "outWBbuffTwo", "outFuf4", "outWBuff0", "outBbuf1", "outBoff8", "outFbuff1", "outBbuf4", "outWBuff8", "outBuber82", "outBait0", "outBbuf2", "outFbuf4", "outBuff2", "outBuf0", "outWBbuff8", "outBbuff1", "outBuf200", "outWBufTwo", "outBaitTwo", "outFbuff8", "outBoff200", "outFuf12", "outFuf82", "outBbuffer12", "outBuff0", "outBum2", "outBbuff2", "outFbuff82", "outBoff2", "outBbuf12", "outWBuf4", "outBuf82", "outFbuffTwo", "outBbufferB", "outFuf2", "outWBuf0", "outFufB", "outWBbuff2", "outBait8", "outWBuff2"], "endOfIndexFile": ["endOfImageFolder", "endOfDataFile", "endofindexTime", "endOfIndexFolder", "endofIndexFile", "endOfindexFile", "endOfImageFiles", "endOfDataDir", "endOfindexFiles", "endofIndexDir", "endofindexFolder", "endofLinkFiles", "endofindexFile", "endOfIndexfile", "end\n", "endOfindexTime", "ended\n", "endfile", "endOfIndexFiles", "endofindexFiles", "endedfile", "endOfIndexTime", "endOfLinkFile", "endOfIndexDir", "endOfLinkfile", " end\n", "endOfClientDir", " endfile", "endOfindexFolder", "endOfDataTime", "endOfClientFiles", "endOfClientTime", "endOfClientFile", "endofIndexFolder", "endOfindexfile", "endOfindexDir", "endOfLinkFiles", "endOfLinkDir", "Endfile", "End\n", "endOfImageTime", "endofLinkDir", "endofLinkTime", "endOfDatafile", "endOfImageFile", "endofLinkFile", "endOfLinkTime", "endofIndexFiles", "endofIndexTime"]}}
{"id1": "20939940", "id2": "23677128", "code1": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "code2": "\tpublic FTPClient sample3a(String ftpserver, int ftpport, String proxyserver, int proxyport, String username, String password) throws SocketException, IOException {\n\t\tFTPHTTPClient ftpClient = new FTPHTTPClient(proxyserver, proxyport);\n\t\tftpClient.connect(ftpserver, ftpport);\n\t\tftpClient.login(username, password);\n\t\treturn ftpClient;\n\t}\n", "label": 0, "substitutes": {"createJavaProject": ["createJavaConnector", "createjavaApplication", "createJSApplication", "createjavaFolder", "createRubyConnector", "createJavaApplication", "createRubyFolder", "createJSFolder", "createRubyApplication", "createRubyProject", "getJavaConnector", "createjavaProject", "createJSProject", "createJSConnector", "getjavaConnector", "getjavaFolder", "getJavaApplication", "getjavaApplication", "getJavaFolder", "getjavaProject", "createjavaConnector", "createJavaFolder", "getJavaProject"], "proj": ["projet", "prob", "perj", "perject", " probj", "propjet", "proz", "produjs", "roud", " proje", "prok", "PROz", "Projs", "propj", "profj", " prouj", "sujet", "perjp", "profjs", "produjo", " proJ", "projs", " projet", "suje", "profJ", "pejo", "Prok", "prejo", "PROJ", "PROj", "produjp", "propje", "prouj", "upj", "Prouj", "suuj", "parjet", "produJ", "projc", "promjp", "probj", "preuj", "Proaj", " prob", "Proj", "roujc", "prej", "Projc", " project", "produb", "suz", "prez", "produjet", "produj", " proz", "rouJ", "proJ", "roujs", "prod", "coJ", " projc", "promz", "coj", "suk", "ProJ", " projo", "sujo", "perjs", "project", " prok", "produuj", "conjc", "peJ", "profject", "PROjp", "pez", "parb", " projs", "projp", "produz", "rouj", "produjc", "Proz", "conj", "rouaj", "upjo", "promj", "proaj", " projp", "pejp", "cojo", "Projp", "conJ", " proaj", "cobj", "Prod", "perJ", "upJ", "conjp", "perz", "upbj", "proje", "propjo", " prod", "parjc", "Projo", "parj", "promjo", "suj", "pej", "projo"], "desc": ["de", "dec", "pro", "ca", "description", "sup", "dep", "str", "id", "sec", "sub", "div", "name", "out", "obj", "struct", "doc", "Desc", "asc", "neg", "info", "des", "def", "esc", "text", "attr", "Description", "rec", "config", "loc", "anc", "dc", "rc", "sc", "dist", "summary", "contract", "dev", "details", " description", "txt", "comment"], "javaProject": ["javaUnit", "JavaProject", "JavaFolder", " javaServer", "rubyApp", "javaPlugin", "javaFolder", "JavaModule", " javaApp", "nativePlugin", "pythonProject", " javaModule", "jaProject", "jarModule", "rubyUnit", "pythonModule", "rubyProject", "javaApp", "javaServer", "jarServer", "jaModule", "nativeApp", "nativeProject", "pythonFolder", "jaUnit", "JavaApp", "JavaUnit", "javaModule", " javaFolder", "nativeFolder", "JavaPlugin", "pythonServer", "jaFolder", "jarFolder", " javaPlugin", "rubyFolder", " javaUnit", "jarProject"], "srcFolder1": ["srcDirectory81", "srcfolder1", "srcfolder0", "srcLocation1", "srcDirectory2", "rcDirectory2", "srcfolderOne", "rcDirectory1", "srcFileOne", "srcFolderOne", "srcFolder0", "rcFolderOne", "srcPath2", "srcfolder81", "rcFolder0", "srcDirectoryOne", "srcLocation0", "srcfolder2", "rcFolder81", "srcPath0", "srcLocation2", "srcFile81", "srcDirectory0", "rcFolder2", "srcPath1", "srcPathOne", "srcFile1", "rcDirectory0", "srcDirectory1", "srcFolder81", "rcDirectoryOne", "rcFolder1", "rcDirectory81", "srcFile2"], "srcFolder2": ["srcfolder1", " srcfolder1", "srcDirectory2", "rcDirectory2", "rcDirectory5", "rcDirectory4", "srcArea4", " srcfolderTwo", "rcDirectory1", " srcFolderTwo", "srcArea2", "rcFolderTwo", "rcDirectoryTwo", " srcfolder2", "srcfolder2", "srcDirectory4", "rcFolder4", "rcFolder2", "rcFolder5", "srcFileTwo", "srcFolder5", "srcfolder5", "srcfolder4", "srcFile1", "srcArea1", "srcFolder4", "srcAreaTwo", "srcDirectoryTwo", " srcfolder4", "srcFolderTwo", "srcDirectory1", "srcFile5", "rcFolder1", "srcfolderTwo", "srcDirectory5", " srcFolder4", "srcFile2"], "classpathEntries": ["classnameEnrys", "classpathEnries", "classpathentrys", "classpathentrs", "classpathEntrys", "classpathAddries", "classpathEntryEntry", "classpathAddEntry", "classPathEntEntry", "classpathEntryry", "classpathentories", "classPathEntries", "classPathAddry", "classpathEntryries", "classpathAddry", "classpathEntEntry", "classpathEntryrys", "classpathEntryrs", "classnameEnories", "classpathEnrs", "classpathEntories", "classpathentry", "classpathentries", "classpathentEntry", "classPathEntry", "classnameEnries", "classpathEnrys", "classnameEnrs", "classPathEntrys", "classPathAddrys", "classnameEntories", "classpathAddrys", "classnameEntries", "classnameEntrys", "classnameEntrs", "classpathEntrs", "classpathEnories", "classpathEntryories", "classPathAddEntry", "classpathEntry", "classPathAddries"], "binFolder": ["winfolder", "winUrl", "resultLoop", "baseLoader", "baseFolder", "basefolder", "winDirectory", " binLoop", "baseDir", "resultUrl", "baseProject", "binLoop", "workFolder", "binaryLoop", "workfolder", "workDir", "winFolder", "workProject", "binaryFolder", "binDir", "binfolder", "binaryProject", "binaryDir", " binLoader", "binUrl", "binaryLoader", " binDirectory", "binaryUrl", "binDirectory", "binProject", "binaryDirectory", "resultfolder", " binUrl", "binaryfolder", " binfolder", "binLoader"], "testFolder": ["resultLoop", "mainfolder", "resultOrg", "testOrg", "mainDirectory", "testDirectory", "matchOrg", "resultDirectory", "matchPath", " testOrg", " testfolder", " testLoop", "testPath", " testPath", "resultPath", "resultfolder", "testLoop", "testfolder", "mainLoop", " testDirectory", "matchFolder", "mainFolder"], "resultFolder": ["returnFolder", "testLayer", "resultSection", "ResultPath", "messageFolder", "testingfolder", "testingFolder", "testSection", "testingLayer", "messagePath", "testingSection", "resultLayer", "returnDirectory", "messageLayer", "ResultLayer", "messageDirectory", "ResultFolder", " resultSection", "returnPath", "resultPath", "resultfolder", "ResultDirectory", "testfolder", " resultfolder", " resultLayer", "resultDirectory", "returnLayer"]}}
{"id1": "17724879", "id2": "22752444", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 1, "substitutes": {"getDigest": ["createDigests", "getSignest", "getdigest", "getSignHash", "getSignester", "getdigests", "getDigester", "createdigester", "getSignests", "getMDHash", "getDigHash", "getMDest", "getMDester", "createdigests", "getdigHash", "getMDests", "createdigest", "getDigests", "createDigHash", "createDigest", "createDigester", "getdigester", "createdigHash"], "attribute": ["feature", "address", "pair", "operation", "individual", "client", "audio", "metadata", "Attribute", "function", "plugin", "node", "name", "image", "set", "prefix", "argument", "character", "expression", "entity", "layer", "username", "event", "element", "component", "type", "reference", "connection", "class", "application", "definition", "object", "directory", "route", "attr", "config", "att", "message", "uri", "property", "resource", "api", "document", "data", "entry", "subject", "variable", "instance", "device", "ident", "value", "ribute", "manager"], "digestAlgorithm": ["digestAlg", "digESTAlgo", "digesterAlgo", "digestALgebra", "digestElger", "digESTAlger", "digesterAlgorithm", "digESTAlgorithm", "digestElgorithm", "digestAlgorith", "digestAlgo", "digestAlgebra", "digestElgo", "digESTAlg", "digestALgo", "digestalgebra", "digestalgorithm", "digesterAlgebra", "digestAlger", "digesterAlgorith", "digestalgorith", "digestalg", "digestALgorith", "digestalgo", "digestalger", "digestElg", "digestALgorithm"], "digest": [" digested", "Diguration", "signest", "labester", "bigest", "digtest", "bigger", "digEST", " digtest", " diguration", "diggest", "multipluration", "bigester", " digester", "dgest", "digester", "signger", "labEST", " digEST", "biggest", "longester", "multiplest", "diguration", "multiplester", "signgest", "DigEST", "multiplEST", "dest", "digested", "Digester", "longest", "labtest", "dger", "dester", "labest", "signester", "Digest", "digger", "Digested", "longEST", "Digtest", "longested"], "md": ["mad", "MD", "cm", "mc", "ms", "ng", "mr", "der", "own", "metadata", "app", "pm", "bd", "module", "rm", "amd", "my", "id", "cb", "db", "df", "mo", "um", "plugin", "mb", "meta", "mt", "ui", "cmd", "hd", "doc", "sm", "mi", "editor", "m", "dd", "arm", "sd", "od", "mm", "ma", "ad", "pd", "cd", "ds", "kg", "wd", "nd", "mac", "mn", "mod", "di", "ld", "mid", "d", "mag", "nm", "ml", "dm", "ht", "dev", "manager", " MD", "mp", "po"]}}
{"id1": "12066447", "id2": "9647576", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"truncate": ["autuncate", "trunator", "tratenate", "truncational", "trunational", "trrenational", "trunation", "truncation", "trrenator", "autuncator", "trunate", "autatenational", "tratenational", "autatenate", "trrenate", "autuncational", "truncator", "tratenation", "trrenation", "tratenator", "autatenator", "autuncation", "autatenation"], "file": ["fp", "url", "address", "FILE", "base", "cache", " File", "local", "e", "zip", "io", "current", "model", "db", "path", "folder", "log", "function", "one", "filename", "out", "name", "string", "binary", "stream", "archive", "time", "queue", "image", "ile", "this", "files", "or", "format", "File", "type", "info", "connection", "class", "object", "directory", "body", "parent", "handler", "per", "future", "uri", "resource", "it", "plus", "document", "get", "single", "page", "l", "data", "source", "http", "line", "full", "f"], "backupRoot": ["BackbackFile", "BackupDirectory", "backupsDir", "backdownroot", "backbackFile", "backUpRoot", "frontupRoot", "backbackRoot", "backbackHome", "BackupDir", "backureHome", "backureRoot", "backflowroot", "backupDir", "backbaseDirectory", "BackupFile", "BackdownPath", "BackbackRoot", "backdownRoot", "BackdownDirectory", "backbackroot", "Backbackroot", "backUpDir", "backflowFile", "Backdownroot", "backflowDir", "backbackDir", "backupsroot", "backdownDirectory", "backbaseRoot", "backbasePath", "backuproot", "backbackDirectory", "BackureDirectory", "backdownFile", "backupsRoot", "backupsFolder", "frontuproot", "BackureHome", "backUproot", "backdownFolder", "frontupDir", "BackupPath", "Backuproot", "backdownHome", "backdownDir", "backflowRoot", "frontdownroot", "backupHome", "frontdownDir", "BackureRoot", "BackupRoot", "backureDir", "frontdownFolder", "backupFolder", "BackupHome", "backupFile", "frontupFolder", "frontdownRoot", "BackdownRoot", "backbaseroot", "backureDirectory", "backUpFolder", "backupDirectory", "BackbackDir", "backdownPath", "backupsDirectory", "backupPath", "backupsPath", "BackureDir"], "df": ["flow", "fp", "md", "de", "cf", "xf", "da", "dl", "dp", "io", " def", "dict", "func", "db", "tf", "fb", "pdf", "CF", "raf", "fe", "format", "dd", "dq", "deb", "def", "fc", "fr", "ds", "fs", "dc", "pd", "af", "fd", "dt", "dn", "di", "data", "fn", "d", "bf", "dm", "sf", "f", "DF"], "date": ["complete", "url", " Date", "re", "updated", "str", "output", "use", "pre", "valid", "Date", "db", "created", "x", "log", "ge", "input", "out", "name", "string", "time", "bug", "day", "code", "year", "m", "format", "custom", "type", "j", "pe", "dat", "tag", "rule", "back", "D", "ale", "diff", "sync", "update", "message", "version", "dates", "min", "form", "fee", "dt", "age", "ate", "data", "work", "dose", "style", "stage", "d", "create", "modified", "value", "atom", "open", "days", "module"], "zipFile": ["sqlFile", "zipModel", "zipfile", "ZipFiles", "zipFiles", "sqlfile", " zipEntry", "ressfile", "ressFile", "Zipfile", "zEntry", "zFile", "zipEntry", "ressSection", "zipSection", " zipfile", "zModel", "ZipFile", "ZipEntry", "sqlSection", "zSection", "zFiles", "ressModel", "sqlModel", " zipFiles", "zfile"], "zos": ["dylib", "z", "address", "las", "osi", "outs", "zzy", "bitcoin", "zh", "ZA", "zar", "kos", "zip", "proxy", "chini", "ls", "liquid", "zon", "tz", "budget", "uz", "zen", "zes", "os", "ses", "zona", "zl", "webkit", "bos", "ssl", "hess", "zan", "dos", "iffs", "zn", "js", "ops", "asio", "zer", "zo", "ozo", "zi", "fits", "lins", "css", "her", "los", "zx", "nz", "zag", "rez", "cos", "inos", "forge", "jas", "zb", "gz", " sands", "cash", "robe", "zik", "bes", "eros", "han", "closure", "obb", "ros", "nox", "exit", "zero", "ils", "zy", "settings"], "fis": ["lias", "Fias", " fiss", "flris", "rafiss", "flids", "fris", "flis", "Fisp", "liss", " fias", "flias", "fliss", "bis", "infis", "Fris", "rafias", "infiss", " fisl", "fiz", "infils", "fisp", "fils", "biss", "Fis", "infits", "Fisl", "Fos", " fils", "fias", "fisl", "vils", " fits", "bos", "rafis", "Fiss", "fids", "bisl", "lis", "viz", "flisp", "fits", " fiz", "infiz", "infias", "vis", "fiss", "vits", "fos", " fos", "infids", " fris", " fisp", "lids", "rafris"], "entry": ["address", "z", "de", "lc", "reader", "e", "zip", "feed", "exp", "ace", "term", "cel", "row", "index", "ge", "auto", "obj", "offset", "ui", "archive", "image", "next", "si", "card", "extra", "or", "event", "element", "ie", "info", "r", " Entry", "so", "Entry", "zo", "per", "the", "her", "uri", "array", "add", "it", "key", "ion", "ry", "data", "style", "letter", "se", "record", "server", "and", "ries", "comment", "cell"], "buffer": ["Buffer", "address", "position", "result", "header", "uffer", "reader", "cache", "bb", "beta", "transfer", "feed", "FFER", "vector", "available", "row", "border", "length", "sequence", "binary", "seed", "memory", "queue", "layer", "writer", "reference", "batch", "b", "shape", "buf", "number", "null", "slice", "pad", "padding", "iter", "wave", "bytes", "flush", "page", "data", "channel", "server", "device", "comment", "buff"], "readed": ["inputED", "inputled", "readized", "textized", "texted", "textED", " Readed", " readered", "readned", "textended", "readable", "bootED", " ReadED", "booted", " readned", "inputed", "intended", "bootered", " readended", " Readered", "readED", " Readled", " Readable", " readED", "inputned", "readled", "readended", " Readned", "bootable", "intED", " readized", "readered", " readable", " readled", "intized", "inted"]}}
{"id1": "13024538", "id2": "6558022", "code1": "    public static String getHash(String uri) throws NoSuchAlgorithmException {\n        MessageDigest mDigest = MessageDigest.getInstance(\"MD5\");\n        mDigest.update(uri.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "label": 0, "substitutes": {"getHash": ["GetHash", "getHost", "toHeader", "toDig", "createHeader", "GetDig", "getDig", "createDig", "getHeader", "GetHeader", "toHost", "createHost", "createHash", "toHash", "GetHost"], "uri": ["address", "url", "base", "token", "str", "id", "io", "URL", "iri", "path", "filename", "string", "name", "ui", " URI", "uni", " ur", "prefix", "image", "database", "storage", "format", "text", "directory", "ri", "message", "attribute", "p", "bytes", "URI", "abi", "cli", "data", "source", "file", "num", "theme", "origin", "f", "pi"], "mDigest": ["mDigger", "mdigester", "mMixe", "mDige", "mMixester", "mDe", "MDigee", "mdigested", "MDit", "mDee", "mDigee", "mdigest", "mHashested", "mHashest", "mIntegee", "MDger", "mMixest", "mIntegest", "mdige", "mdigit", "MDested", "MDee", "mDester", "mDit", "MDigit", "mDigested", "MDe", "MDigester", "MDest", "mDest", "mDigit", "mDger", "MDige", "mDested", "mMixested", "mIntegester", "MDester", "mHashester", "mIntegit", "mdigee", "MDigger", "MDigest", "MDigested", "mMixger", "mDigester", "mHashger"], "d": ["v", "md", "da", "dl", "e", "dict", "db", "x", "s", "ded", "c", "dx", "m", "dd", "t", "dos", "g", "dat", "b", "n", "sd", "D", "did", "ds", "ad", "dc", "done", "p", "h", "fd", "dt", "dn", "di", "l", "data", "dh", "ld", "f", "dig"], "hash": ["shadow", "v", "url", "result", "address", "header", "sha", "base", "ash", "cache", "str", "output", "throw", "use", "raw", "db", "Hash", "total", "log", "string", "length", "out", "memory", "image", "hex", "ashes", "ruby", "build", "format", "print", "html", "user", "b", "he", "ha", "block", "her", "message", "buffer", "array", "key", "h", "copy", "sh", "data", "shift", "pool", "style", "loop", "dump", "square", "sum", "f", "response", "temp"], "i": ["qi", "v", "z", "k", "ai", "ti", "vi", "I", "e", "id", "io", "xi", "x", "index", "start", "end", "u", "li", "ui", "hi", "multi", "c", "ci", "si", "phi", "ii", "m", "t", "j", "a", "r", "info", "b", "n", "o", "bi", "slice", "block", "zi", "ri", "p", "it", "ix", "gi", "fi", "l", "oi", "di", "chi", "ji", "mu", "f", "pi"]}}
{"id1": "20751378", "id2": "1133123", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "label": 0, "substitutes": {"hashPassword": ["cryptpassword", "signpassword", "hashWord", " hashWord", "signPass", "signPassword", "cryptWord", "cryptPassword", "signWord", "hashpassword", " hashpassword", "cryptPass", "hashPass", " hashPass"], "password": ["address", "encrypted", "sha", "token", "Password", "cache", "w", "description", "sword", "security", "command", "path", "input", "python", "pattern", "string", "name", "seed", "word", "prefix", "database", "plain", "code", "auth", "words", " Password", "username", "crypt", "user", "number", "text", "pad", "padding", "message", "p", "key", "wd", "content", " passwords", "mac", "phrase", "data", "PASS", "secret", "pass"], "hash": ["address", "sha", "error", "ash", "cache", "id", "log", "alt", "length", "format", "tag", "message", "mac", "mod", "value", "ssh", "ha", "msg", "put", "check", "string", "memory", "pkg", "hex", "auth", "user", "number", "hed", "her", "key", "math", "match", "pool", "dump", "proof", "result", "uild", "base", "rh", "call", "handle", "kh", "ashes", "ruby", "code", "history", "height", "copy", "search", "work", "secret", "oh", "sum", "dig", "url", "security", "replace", "Hash", "gh", "index", "host", "build", "html", "root", "text", "bolt", "update", "array", "version", "h", "phrase", "sh", "addr", "style", "square", "json"], "md": ["mad", "MD", "mc", "sha", "ms", "der", "gb", "metadata", "pm", "bd", "amd", "am", "df", "meta", "mb", "mt", "cmd", "hd", "sm", "mand", "m", "dd", "Cmd", "gd", "sd", "km", "od", "mg", "grad", "mm", "ma", "ME", "pd", "kg", "wd", "nd", "mac", "mod", "hm", "xd", "dh", "d", "mag", "nm", "vd", "dm", "f", " MD", "dig"]}}
{"id1": "19113613", "id2": "14317425", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copy": ["share", "change", "delete", "save", "paste", "rm", "transfer", "zip", "Copy", "load", "put", "replace", "cp", "archive", "write", "upload", "Cop", " cp", "type", "cop", "sync", "update", "clip", "p", "get", "process", "move", "download", "create", "split", "ssh", "cat", "clone", "opy"], "in": ["url", "base", "ins", "thin", "reader", "din", "IN", "client", "token", "project", "login", "bin", "id", "inc", "old", "plugin", "ini", "input", "ic", "index", "In", "name", "on", "inner", "image", "c", "this", "a", "i", "connection", "n", "again", "sin", "config", "diff", "win", "update", "inn", "min", "pin", "get", "cin", "work", "lin", "init", "data", "inside", "kin", "part", "as", "f"], "out": ["exec", "net", "external", "v", "base", "OUT", "client", "outs", "cache", "project", "call", "output", "bin", "app", "io", "inc", "path", "goal", "x", "outside", "one", "remote", "input", "conn", "ext", "obj", "dot", "name", "image", "c", "err", "off", "no", "this", "Out", "self", "at", "connection", "root", "b", "ex", "n", "object", "again", "o", "parent", "null", "block", "with", "outer", "option", "resource", "version", "p", "point", "user", "other", "page", "vert", "line", "up", "init", "work", "group", "part"], "source": ["ource", "position", "url", "feature", "base", "project", "status", "scope", "view", "site", "use", "force", "id", "proxy", "family", "internal", "alt", "name", "secure", "Source", "prefix", "missing", "username", "format", "component", "type", "reference", "pe", "class", "route", "parent", "sin", "dest", "direction", "uri", "service", "resource", "attribute", "iter", "from", "subject", "secret", "src", "origin", "unit", "size", "ce", "SOURCE"], "target": ["template", "address", "url", "master", "base", "token", "alias", "arget", "project", "output", "site", "force", "current", "wrong", "path", "goal", "alt", "pattern", "host", "name", "top", "tail", "prefix", "next", "format", "Target", "component", "reference", "root", "route", "null", "parent", "dest", "direction", "config", "service", "resource", "detail", "point", "src", "about", "value", "cat", "origin", "home"], "files": ["objects", "ins", "classes", "groups", "assets", "flows", "tools", "docs", "iles", "children", "ions", "users", "filename", "s", "sections", "cells", "lines", "ls", "jobs", "resources", "results", "items", "models", "images", "plugins", "apps", "blocks", "fs", "links", "Files", "obs", "pages", "data", "ports", "keys", "names", "f", "features"], "file": ["fp", "url", "FILE", "base", " File", "local", "el", "e", "id", "feed", "current", "load", "child", "path", "folder", "function", "filename", "name", "string", "binary", "ile", "fe", "lib", "entity", "layer", "File", "live", "b", "object", "directory", "parent", "per", "future", "uri", "resource", "it", "single", "l", "line", "entry", "data", "dir", "page", "letter", "part", "unit", "f", "item", "le"], "inCh": ["outCH", "inChan", "INCh", " inch", "outChan", "InChannel", "inCH", "outch", "INChan", "INChannel", "Inch", "inChannel", "InCH", " inChan", " inChannel", "InChan", " inCH", "InCh", "INCH", "inch", "outChannel"], "outCh": ["outCH", "outputCh", "outputChan", "inChan", "OutCh", "OutCH", " outCH", "outChan", "outch", "inCH", "outputCH", " outChannel", " outch", "inChannel", "Outch", "OutChan", "OutChannel", "inch", "outChannel", "outputch"]}}
{"id1": "1798720", "id2": "19251426", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"save": ["change", "apply", "transfer", "load", "make", "archive", "setup", "upload", "build", "release", "report", "transform", "Save", "install", "update", "pack", "copy", "store", "data", "process", "move", "stage", "saving", "create", "dump", "open", "clone"], "packageName": ["modulePath", " packagePart", "moduleName", "sourcename", "pluginName", "moduleInfo", "directoryPath", " packagePath", "packagePart", " packagename", "sourceName", "packageInfo", "packagename", "directoryname", "sourcePath", "directoryName", " packageNames", "PackagePath", "PackageName", "directoryInfo", "packageNames", "directoryDir", "directoryPart", "pluginDir", "pluginPart", "PackageDir", "directoryNames", "pluginPath", "packagePath", " packageInfo", "moduleDir", "PackageNames", "sourceDir", "PackageInfo"], "fileContents": ["getContents", "getNames", "FileContent", "imageNames", " fileHours", "imageParts", " fileContent", "ileContents", "fileSources", " fileTextures", "FileContents", "ileNames", "fileContent", "ileTextures", " fileSources", "imageContents", "FileSources", "fileParts", "fileHours", "imageHours", "fileTextures", "FileTextures", "ileSources", "FileNames", "FileHours", "getParts", "getContent", "FileParts", " fileParts"], "fileNames": ["fileTypes", "FileTypes", "fNumbers", "pagenames", "viewTypes", "pageNames", "filenames", "playName", "FileName", "fullContents", "FileContents", "fTypes", "pageTypes", "playContents", "logNames", " fileName", "fName", "logName", "fullNames", "fNames", " filenames", "logTypes", "fullTypes", "fullName", "logContents", "viewnames", "FileNames", "viewNames", "playNames", " fileTypes", "fileNumbers", "fileName", "FileNumbers", " fileNumbers"], "dirBase": ["directoryBased", "packageRoot", "folderBase", "directoryBase", "DirDir", "modulebase", " dirbase", "Dirbase", "dirRoot", "DirKit", " dirRoot", "dirBased", "directoryKit", "moduleBased", "packageBase", " dirPath", "directorybase", "dirbase", "dirDir", "dirPath", "packagebase", "DirBase", "directoryDir", "folderBased", "DirRoot", "moduleKit", "folderbase", "DirPath", "packagePath", "moduleDir", "folderDir", "dirKit", "moduleBase"], "packageDir": ["modulePath", "folderBase", "directoryFolder", " packagePath", "directoryPath", "directoryUrl", "PackageDirectory", "folderPath", "packageDirectory", "packageFolder", "parentFile", "directoryFile", "parentDir", "packageBase", "PackageFile", "PackagePath", "directoryDirectory", " packageBase", "directoryDir", "packageUrl", " packageUrl", "PackageDir", " packageFile", "packagePath", "packageLib", " packageFolder", "folderLib", "moduleDir", "moduleLib", "parentUrl", " packageDirectory", "folderDir", "parentFolder", "packageFile", " packageLib", "moduleBase"], "created": ["result", "controlled", "edited", "required", "established", "needed", "formed", "updated", "left", "found", "activated", "path", "creator", "paid", "Created", "true", "released", "creation", " Created", "made", "aaaa", "generated", "failed", "added", "confirmed", "used", "null", "icated", "produced", "existent", "loaded", "raised", "founded", "owned", " existed", "create", "were", "successful", "worked", "authorized", "called", "ed"], "currentPath": ["newPath", "CurrentDirectory", "newpath", "currentLocation", "CurrentPath", "currentPage", "newLocation", "CurrentRoot", " currentLocation", "CurrentPage", " currentRoot", "currentlypath", "Currentpath", "currentlyDirectory", " currentPage", "currentDirectory", "currentRoot", "currentlyPath", " currentpath", "currentlyPage", "newRoot", "CurrentLocation", " currentDirectory", "currentpath"], "i": ["qi", "v", "z", "k", "ip", "ai", "ti", "I", "e", "id", "io", "current", "iu", "xi", "x", "ini", "index", "eni", "start", "name", "ui", "li", "u", "hi", "inner", "s", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "j", "ie", "info", "ori", "b", "n", "bi", "zi", "slice", "isi", "ri", "uri", "p", "gi", "ix", "it", "h", "fi", "key", "di", "oi", "me", "init", "d", "yi", "ji", "part", "mu", "f", "pi"], "file": ["fp", "base", "place", "feed", "io", "child", "path", "folder", "log", "filename", "out", "name", "s", "play", "ile", "files", "fe", "or", "File", "pe", "b", "rule", "per", "il", "ul", "uri", "resource", "http", "l", "source", "work", "up", "dir", "entry", "letter", "data", "full", "unit", "book", "f", "le"], "fos": ["foes", "ufos", " fosh", "Fou", "vops", "flou", "flis", " fis", "voes", "fou", "flops", " fob", "Fops", "Fosh", "Fos", "ofosh", "Fis", "ofos", " fo", "flosh", "cfob", " fops", "ufob", "fios", "Foes", "Fios", "fosh", "vios", "ufoes", "ufo", "fis", "cfo", " fios", "vos", "ofou", "fo", "cfoes", "cfos", "fops", "flos", " foes", "ofops", "fob"], "fileSrc": ["fileDrs", "fileDrec", "fileSsrc", "fileSrec", "fileAsrec", "FileSrc", "fileAsource", "fileNRC", " fileSrs", "fileDrc", "fileSrs", "fileAsRC", " fileDRC", "fileAssrc", " fileSsrc", "FileSource", "FileDRC", "fileSource", "FileDrec", " fileDsrc", " fileDrs", "fileAsrc", "fileSRC", "fileAsrs", "FileSRC", "fileNrs", "fileDource", " fileSRC", "fileNsrc", "fileDRC", "fileNrc", "FileDrc", "FileSrec", "FileDource", " fileDrc", "fileDsrc"], "fileDst": ["fileDsc", "FileSsc", "FileFst", "fileSsrc", "fileEnsc", "FileSrc", "fileSst", "fileFST", "fileDrc", "fileEnST", "fileNsc", "FileDST", "FileDsc", "fileSST", "fileFst", "FileFST", "fileDaysc", "fileDayrc", "FileDst", "fileFrc", "FileFsc", "fileDST", "fileNst", "FileFrc", "fileNsrc", "fileNrc", "FileDrc", "FileSst", "fileEnrc", "FileDsrc", "FileSsrc", "fileSsc", "fileFsc", "fileDayst", "fileDaysrc", "fileEnst", "fileDsrc"], "reader": ["audio", "builder", "re", "e", "right", "io", "rr", "worker", "rer", "ler", "row", "er", "stream", "driver", "inner", "editor", "read", "Reader", "keeper", "or", "layer", "r", "report", "rx", "handler", "oder", "per", "loader", "ner", "ri", "parser", "iter", "buffer", "rc", "data", "entry", "ro", "ry", "server", "rar", "director", "reading", "book", "author"], "writer": ["ger", "wa", "written", "wire", "master", "maker", "writ", "builder", "w", "output", "e", "war", "worker", "ws", "ler", "er", "out", "inner", "driver", "word", "write", "rw", "widget", "wr", "editor", "words", "element", "Writer", "riter", "r", "connection", "player", "o", "with", "handler", "per", "walker", "socket", "loader", "outer", "parser", "buffer", "message", "office", "wrapper", "key", "document", "writers", "data", "entry", "server", "width", "sheet", "work", "value", "later", "book", "author", "writing"], "line": ["url", "lc", "header", "error", "column", "job", "str", "id", "feed", "model", "log", "le", "ge", "row", "string", "name", "end", "Line", "response", "lines", "word", "cr", "write", "link", "character", "code", "LINE", "look", "type", "connection", "definition", "text", "object", "rule", "block", "sync", "cle", "message", "buffer", "key", "jo", "lf", "page", "data", "lin", "entry", "source", "l", "letter", "char", "style", "inline", "pass", "part", "unit", "comment", "item", "cell", "stroke"]}}
{"id1": "22410173", "id2": "1986417", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    @Override\n    public void export(final Library lib) throws PluginException {\n        try {\n            new Thread(new Runnable() {\n\n                public void run() {\n                    formatter.format(lib, writer);\n                    writer.flush();\n                    writer.close();\n                }\n            }).start();\n            ftp.connect(host);\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                ftp.disconnect();\n                throw new PluginException(\"Unable to connect to FTP\");\n            }\n            ftp.login(user, pass);\n            ftp.pasv();\n            ftp.changeWorkingDirectory(dir);\n            ftp.storeFile(file, inStream);\n            ftp.logout();\n        } catch (SocketException e) {\n            throw new PluginException(e);\n        } catch (IOException e) {\n            throw new PluginException(e);\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "source": ["ource", "url", "base", "ins", "reader", "site", "use", "id", "path", "internal", "input", "target", "start", "name", "stream", "inner", "image", "Source", "down", "ie", "connection", "route", "parent", "sin", "slice", "ources", "iter", "resource", "from", "copy", "file", "up", "src", "unit", "size", "SOURCE"], "dest": ["test", "de", "thin", "img", "project", "delete", "output", "bin", "transfer", "comb", "tmp", "path", "folder", "target", "flat", "name", "true", "this", "down", "connection", "Dest", "desc", "orig", "wb", "done", "destroy", "file", "dist", " destination", "src", "die", "later", "home", "exit", "temp"], "in": ["url", "gin", "ins", "din", "reader", "IN", "client", "re", "login", "bin", "id", "inc", "ini", "plugin", "input", "start", "In", "s", "conn", "inner", "name", "lock", "err", "c", "image", "this", "m", "a", "i", "r", "info", "ie", "b", "again", "n", "pull", "socket", "nin", "win", "inn", "resource", "min", "pin", "by", "cin", "data", "file", "up", "inside", "init", "work", "src", "con", "as", "f"], "out": ["exec", "net", "url", "img", "OUT", "client", "outs", "w", "call", "output", "bin", "id", "ou", "io", "inc", "not", "exp", "log", "index", "conn", "ext", "obj", "name", "inner", "to", "write", "c", "off", "err", "no", "Out", "plain", "this", "self", "lib", "extra", "at", "writer", "connection", "i", "ex", "n", "again", "o", "with", "parent", "socket", "sync", "outer", "option", "timeout", "pool", "file", "up", "init", "password", "channel", "data", "vert", "our", "cat", "temp"]}}
{"id1": "17580775", "id2": "16572931", "code1": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 0, "substitutes": {"runInternal": ["doImpl", "doSync", "runImpl", "processInternal", "processExternal", " runSync", "doInternal", "processSync", "doExternal", "processImpl", " runImpl", "runExternal", " runExternal", "runSync"], "connection": ["error", "cache", "port", "log", "engine", "session", "location", "context", "section", "character", "operation", "directory", "graph", "message", "option", "document", "ion", "server", "connected", "client", "description", "use", "environment", "function", "remote", "creator", "machine", "c", "database", "event", "component", "object", "timeout", "wrapper", "password", "statement", "relation", "position", "lc", "reader", "current", "command", "container", "volume", "connect", "inner", "driver", "entity", "layer", "communication", "body", "config", "loc", "socket", "resource", "condition", "source", "channel", "con", "builder", "proxy", "request", "default", "index", "image", "expression", "Connection", "application", "handler", "service", "version", "translation", "entry", "collection"], "visited": ["VISited", "viewed", "invitted", "viewited", "VISalled", "viewITED", "visITED", "Visalled", "invITED", "visalled", "Visitted", "invalled", "VISitted", "VISITED", "Vised", "viewitted", "invited", "Visited", "vised", "visitted", "VISed", "VisITED"], "startTimeStamp": ["startLineStng", "startTimeStamps", "startTimeestamp", "startTimeStamped", "startTimeestng", "startTimeStng", "startTimeEstamped", "startTimeEstng", "startLineEstng", "startTimestng", "startLineEstamps", "startTimestamps", "startTimeestamped", "startLineStamped", "startTimeEstamps", "startTimestamped", "startTimeestamps", "startLineStamp", "startLineEstamp", "startLineStamps", "startLineEstamped", "startTimeEstamp", "startTimestamp"], "delayedProgress": ["elayedProgress", "delivedStatus", "eladedProgress", "delivedContent", "elayedContent", "delivedComplete", "deladedStatus", "delayedComplete", "delivedProgress", "delayedContent", "deliverStatus", "deliverContent", "eladedStatus", "deladedContent", "eladedContent", "delayedStatus", "elayedStatus", "elayedComplete", "deladedProgress", "deladedComplete", "deliverComplete", "deliverProgress", "eladedComplete"], "conn": ["exec", "lc", "cf", "mc", "client", "uc", "ann", "io", "db", "ctx", "comm", "connect", "conv", "cp", "ls", "obj", "c", "ci", "cc", "ct", "ssl", " con", "Connection", "n", "config", "loc", "att", "nt", "enc", "sync", "co", "ad", "dc", "h", "http", "rc", "l", "cli", "channel", "ch", "cn", "act", "con", "nc", "Conn", "open", "cb", "connected", "cmp"], "fileName": ["contentname", "FileKey", "urlArea", "fileArea", "imagename", " filePath", "contentName", "FileName", "filename", "contentPath", " fileSpace", " fileArea", "urlName", "imageName", "urlKey", "FilePath", "fileKey", "contentSpace", "urlPath", " filename", "imagePath", "filePath", "FileArea", "fileSpace", " fileKey", "imageSpace"], "disp": ["interpatch", "broadpart", "detpp", "detp", "prop", "Dispp", "dispart", "defp", "defpend", "schep", "interpp", "schepe", "dispatch", " dispr", "dispr", "Dispr", " dispose", "propose", "broadp", "Dispose", "dispp", "dispend", "disap", "disP", "defps", "detpatch", "Dispe", "DisP", "detP", "Dispatch", "schepatch", "scheap", "disps", "interP", "interpe", "propr", "interp", "dispe", "Disap", "defpart", " dispe", "broadps", "interap", "dispose", "broadpend", "Dispart", "Disp", "Dispend", "prope", "Disps"], "p": ["v", "jp", "ping", "ip", "pa", "pat", "tp", "ap", "e", "bp", "lp", "pre", "after", "P", "index", "vp", "patch", "q", "end", "pr", "c", "rep", "pl", "np", "y", "m", "t", "j", "at", "i", "r", "pe", "g", "b", "n", "o", "loc", "api", "point", "h", "l", "col", "op", "pos", "d", "pp", "part", "sp", "f", "pi", "po"], "response": ["complete", "reset", "prot", "result", "error", "received", "description", "status", "output", "site", "found", "id", "feed", "model", "Response", "path", "request", "function", "index", "pointer", "image", "next", "success", "respond", "code", "en", "body", "ception", "message", "uri", "timeout", "version", "api", "resource", "respons", "http", "page", "data", "resp", "server", "successful", "value", "reply", "json", "collection", "radius"], "contentType": ["ContentType", "ContentInfo", "documentTyp", "documentType", "contentInfo", "contentName", " contentLength", " contentInfo", "documentName", "ContentTyp", "contentTyp", "messageType", "ContentLen", " contentName", "messageLen", "ContentLength", " contentTyp", "documentLength", "ContentName", "contentLength", "messageInfo", "messageLength"], "contentEncoding": ["loadEnasing", "contentEnryption", "contentencocol", "ContentEncoder", "contentencoding", "loadEnoding", "contentLocaring", "loadEncryption", "contentEncaring", "contentEnasing", "contentEncoder", "contentEncocol", "loadEncasing", "contentLocasing", "contentencReading", "contentencoder", "ContentEncoding", "ContentDecocol", "contentDecoding", "contentEoder", "contentEncReading", "contentDecReading", "contentEncryption", "contentCryption", "contentCasing", "contentDecoder", "ContentEncocol", "contentEncasing", "loadEnaring", "loadEncaring", "loadEncoding", "contentEnaring", "ContentEncReading", "loadEnryption", "contentEReading", "contentCaring", "contentLocryption", "contentLocoding", "contentEoding", "ContentDecReading", "ContentDecoding", "contentCoding", "ContentDecoder", "contentEocol", "contentEnoding", "contentDecocol"], "contentLen": ["contentSl", "Contentlen", "resourceLength", " contentSl", "contentlen", " contentlen", " contentLength", " contentSize", "resourcelen", "ContentLen", "ContentSl", "ContentLength", "resourceSize", "activitySize", "resourceLen", "activitySl", "activityLen", "contentLength", "contentSize", "ContentSize", "activityLength"], "is": ["us", "net", "im", "ip", "are", "un", "ot", "not", "IS", "out", "ync", "isl", "iss", "ios", "os", "ys", "ub", "ig", "isc", "version", "igh", "it", "isp", "ion", "ss", "can", "mis"], "url": ["address", "client", "status", "str", "feed", "URL", "path", "log", "sl", "Url", "host", "location", "context", "string", "image", "link", "org", "layer", "username", "ssl", "html", "user", "text", "config", "socket", "buffer", "uri", "service", "resource", "document", "http", "page", "source", "server", "file", "channel", "email", "download", "json"], "loadNext": ["loadingPrevious", "checkPrevious", "loadsPrevious", "loadsLast", "loadPrevious", "checkLast", "loadingLast", "checkNext", "checkFirst", "loadLast", "loadsNext", "loadFirst", "loadingFirst", "loadsFirst", "loadingNext"], "itemsLoadedPartially": ["itemsLoadedPartials", "itemsLoadedCopally", "itemsLoadippedPartials", "itemsLoadedpartally", "itemsLoadedPARTially", "itemsLoadedpartially", "itemsLoadedCopial", "itemsLoadippedPartially", "itemsLoadippedpartially", "itemsLoadedCopially", "itemsLoadippedpartial", "itemsLoadedPARTial", "itemsLoadippedpartials", "itemsLoadedPARTally", "itemsLoadedpartial", "itemsLoadedPartally", "itemsLoadippedPartally", "itemsLoadippedPartial", "itemsLoadedCopials", "itemsLoadedPartial", "itemsLoadippedpartally", "itemsLoadedPARTials", "itemsLoadedpartials"]}}
{"id1": "19549489", "id2": "3266833", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "label": 1, "substitutes": {"copy": [" copying", "delete", "paste", "transfer", "zip", "io", "Copy", " copied", "Transfer", "write", "upload", "Cop", "all", "cop", "sync", "p", " transfer", " copies", "source", "move", "file", "download", "create", " move", "split", " Copy", "clone"], "sourceFile": ["sourceFiles", "resourceFile", "searchFilename", "resourcefile", " sourceFiles", " sourceFILE", "resourceDirectory", "servicefile", "sourceFILE", "resourceFiles", "sourceFilename", " sourceDirectory", "SourceDirectory", " sourcefile", "siteFiles", "SourceFile", "searchfile", "sourcefile", "siteDirectory", "serviceFiles", "serviceFilename", "SourceFILE", "sourceDirectory", "serviceFile", " sourceFilename", "Sourcefile", "searchFiles", "siteFILE", "siteFile", "SourceFiles", "searchFile"], "destinationFile": ["destinatorImage", "destinationImage", "destinatedImage", "destinatedFiles", "destinatorDir", "DestinationDir", "destinationFiles", "DestinationFiles", "destinatedFile", "distinatedFiles", "DestinationFile", "distinationImage", "destationFiles", "destationfile", "destinatorFile", "distinatedFile", "distinatedDirectory", "distinationDirectory", "destinationDir", "destinatedDir", "destationDir", "destinatorFiles", "destationImage", "DestinatorDir", "distinatedImage", "destinatedfile", "destationDirectory", "destationFile", "distinationFiles", "destinatedDirectory", "destinatorDirectory", "destinationfile", "DestinatorFiles", "distinationFile", "destinationDirectory", "DestinatorFile", "destinatorfile", "Destinatorfile", "Destinationfile"], "sourceFileChannel": ["sourceFilesChannel", "sourceLibraryChan", " sourceFilesService", "targetFileChan", "sourceDirchannel", "sourceLineSocket", "sourceDirChan", "targetLibrarySocket", "sourceFileSocket", "sourceFileContext", "sourceFileClient", "ourceStreamChannel", "sourceStreamContext", "sourceFunctionConnection", " sourceFilesConnection", "targetLibraryChan", " sourceFileContext", "sourceDirectorySocket", "sourceFunctionService", " sourceFileService", "targetFileClient", "sourceFileConnection", "sourceDirectoryChan", "sourceLibraryChannel", "sourceStreamConnection", " sourceFilesChannel", "sourceLinechannel", "sourceLibraryClient", "sourceFilesContext", "sourceFileStream", "targetLibraryChannel", "sourceStreamStream", "sourceFunctionChannel", "ourceStreamStream", "ourceFileChannel", "sourceLineChannel", "sourceStreamService", "targetFileSocket", "ourceFileChan", "sourceFilesService", "sourceFileChan", "sourceStreamchannel", "sourceStreamChan", "sourceFilesConnection", "targetLibraryClient", "sourceDirectoryClient", "targetFileChannel", "sourceDirStream", "ourceFilechannel", " sourceFilesContext", "sourceLineClient", "ourceStreamChan", "sourceLineChan", "sourceStreamChannel", "sourceLineStream", "sourceFunctionContext", "sourceFilechannel", "sourceDirChannel", "sourceDirectoryChannel", "ourceStreamchannel", "sourceFileService", " sourceFileConnection", "sourceLibrarySocket", "ourceFileStream"], "destinationFileChannel": ["destinationFilesConnection", "destinatorFileConnection", "destinationFilesChannel", "destinationLineHandler", "destinationIOCache", "destinationFilesHandler", "destinationFileService", "destinationDirectoryChannel", "destinationLineChan", "destinationLineClient", "destinationDirectoryClient", "destinationIOClient", "destinationFilesService", "destinatorFileCache", "destinationDirectoryChan", "destinatorFileHandler", "destinatorFilesHandler", "destinationDirectoryConnection", "destinationFilesChan", "destinatorFilesChan", "destinationFileClient", "destinationLineConnection", "destinationIOChannel", "destinationFilesCache", "destinatorFileChan", "destinationDirectoryHandler", "destinationLineChannel", "destinationDirectoryService", "destinatorFileClient", "destinatorFilesConnection", "destinationIOService", "destinatorFilesService", "destinationLineService", "destinationFileConnection", "destinatorFileService", "destinatorFilesChannel", "destinationFileChan", "destinationFileCache", "destinatorFileChannel", "destinationFileHandler", "destinatorFilesCache", "destinationFilesClient", "destinationDirectoryCache", "destinatorFilesClient"]}}
{"id1": "1485383", "id2": "4417943", "code1": "    private void runGetAppListing() {\n        DataStorage.clearAppListings();\n        GenericUrl url = new GoogleUrl(EnterpriseMarketplaceUrl.generateAppListingUrl() + DataStorage.getVendorProfile().vendorId);\n        AppListingList appListingList;\n        try {\n            HttpRequest request = requestFactory.buildGetRequest(url);\n            request.addParser(jsonHttpParser);\n            request.readTimeout = readTimeout;\n            HttpResponse response = request.execute();\n            appListingList = response.parseAs(AppListingList.class);\n            if (appListingList != null && appListingList.appListings != null) {\n                operationStatus = true;\n                DataStorage.setAppListings(appListingList.appListings);\n            }\n            response.getContent().close();\n        } catch (IOException e) {\n            AppsMarketplacePluginLog.logError(e);\n        }\n    }\n", "code2": "    public void test() {\n        try {\n            String query = \"* <http://xmlns.com/foaf/0.1/workplaceHomepage> <http://www.deri.ie/>\" + \"* <http://xmlns.com/foaf/0.1/knows> *\";\n            String url = \"http://sindice.com/api/v2/search?qt=advanced&q=\" + URLEncoder.encode(query, \"utf-8\") + \"&qt=advanced\";\n            URL urlObj = new URL(url);\n            URLConnection con = urlObj.openConnection();\n            if (con != null) {\n                Model model = ModelFactory.createDefaultModel();\n                model.read(con.getInputStream(), null);\n            }\n            System.out.println(url);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"runGetAppListing": ["runGetApplicationlistling", "runGetAppSupportling", "runGetApplicationListings", "runGetApplicationlistings", "runGetAppSupportings", "runGetAppSearchings", "runGetAppSupportInfo", "runGetAppListings", "runGetApplistling", "runGetAppSearchInfo", "runGetAppListInfo", "runGetApplicationListing", "runGetApplicationListling", "runGetApplicationlisting", "runGetApplistings", "runGetAppSearching", "runGetAppListling", "runGetApplicationlistInfo", "runGetApplistInfo", "runGetApplicationListInfo", "runGetAppSupporting", "runGetAppSearchling", "runGetApplisting"], "url": ["address", "result", "base", "client", "builder", "re", "e", "feed", "URL", "proxy", "path", "Url", "host", "location", "string", "image", "build", "ssl", "i", "connection", "b", "route", "config", "buffer", "uri", "service", "api", "resource", "http", "href", "l", "page", "data", "server", "channel", "source", "file", "download", "json", "f"], "appListingList": ["appListillingList", "appListningResult", "appListitinglist", "appPoolingGroup", "appListningList", "appListiningGroup", "appLingMap", "appListINGEx", "appStINGL", "appListINGLayer", "appListingsMap", "appListingLibrary", "appLeningList", "appListINGList", "appListeningEx", "appLingInfo", "appListingEx", "applistingList", "applistningResult", "applistningData", "appPoolininglist", "appListdingEx", "appListingingGroup", "appListdingL", "appHoldingLibrary", "appLingList", "appListitingList", "appListitingData", "appListingMap", "appListingResult", "appListingsL", "appListgingMap", "appPooliningGroup", "appListinglist", "applistningList", "appStingEx", "appListdingLayer", "appListningEx", "appHoldingingList", "appListingLayer", "appListinginglist", "appListillingLibrary", "appHoldinginglist", "appStingLayer", "appListdingList", "appListgingEx", "appHoldinglist", "appLeningEx", "applistingResult", "appListingsData", "appListeningList", "appListitingEx", "appListingInfo", "appPooliningList", "appListingL", "appListitingLibrary", "appListeningMap", "appStINGList", "appListitingType", "appListingType", "appListingGroup", "appListininglist", "appStINGLayer", "appListingsResult", "appHoldingType", "appListningGroup", "appListingingLibrary", "appListingsLayer", "appListingsList", "appListgingInfo", "applistningEx", "appListingData", "appListninglist", "appPoolingList", "appListingsEx", "appListeningInfo", "appListitingResult", "appPoolinglist", "appListiningList", "appListingingList", "appListningData", "appHoldingList", "appHoldingingLibrary", "applistingData", "appStingL", "appStINGEx", "appListingsInfo", "appLeningInfo", "applistingEx", "appListillingType", "appListingingType", "appListgingList", "appStingList", "appLeningMap", "appLingEx", "appHoldingingType", "appListINGL", "appListillinglist"], "request": ["complete", "address", "result", "client", "job", "builder", "project", "call", "re", "parse", "e", "use", "transfer", "proxy", "child", "command", "xml", "remote", "input", "q", "queue", "next", "callback", "build", "rate", "writer", "r", "method", "report", "application", "user", "object", "query", "have", "hello", "post", "buffer", "uri", "service", "resource", "message", "get", "Request", "condition", "http", "page", "server", "push", "req", "create", "trip", "json"], "readTimeout": ["readerTimeout", " readTime", " readSocket", "readtimeout", "writetimeout", "writeSocket", "readerAttempt", "readTime", "readingAttempt", "writeAttempt", "readertimeout", "readingSocket", "writeTime", " readtimeout", "readingtimeout", "readAttempt", "readerTime", "readSocket", "readingTimeout", "writeTimeout", "readingTime"], "response": ["result", "error", "client", "received", "status", "re", "output", "e", "site", "feed", "Response", "res", "generation", "stream", "image", "next", "success", "respond", "writer", "connection", "report", "application", "object", "body", "message", "array", "api", "resource", "version", "wave", "document", "http", "page", "data", "resp", "server", "full", "reply", "json", "onse"]}}
{"id1": "7044153", "id2": "9081749", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendExceptionAsHost", "sendExceptionWithService", "sendExceptiontoserver", "sendExceptiontoService", "sendExceptionWithServer", "sendErrortoHost", "sendExceptionAsServer", "sendErrorToserver", "sendExceptionWithHost", "sendExceptionToserver", "sendErrortoServer", "sendExceptionToHost", "sendExceptiontoServer", "sendErrorToServer", "sendErrortoserver", "sendErrorToService", "sendErrortoService", "sendExceptionAsserver", "sendExceptiontoHost", "sendExceptionWithserver", "sendExceptionToService", "sendErrorToHost", "sendExceptionAsService"], "server": ["ser", "test", "address", "base", "ip", "header", "client", "port", "proxy", "Server", "db", " host", "host", "domain", "prefix", "ssl", "root", "null", "service", "erver", "http", "addr", "email", "json", "serv", "conf"], "ex": ["exec", "su", "rex", "cl", "base", "error", "exc", "pex", "status", "re", "str", "lex", "aux", "throw", "e", "exp", "ace", "none", "Exception", "EX", "tx", "x", "log", "nex", "export", "res", "Ex", "ext", "obj", "Exc", "err", "hex", "ax", "event", "def", "class", "ception", "example", "except", "acer", " exc", "sex", "fail", "con", "full", "rupt", "exit", "temp"], "config": ["address", "base", "client", "console", "app", "Configuration", "proc", "log", "Config", "ext", "cmd", "bug", "cfg", "connection", "options", "text", "Conf", "etc", "service", "rc", "file", "json", "conf", "cb", "settings"], "prob": ["proj", "probs", " probs", "peb", "Proj", "Probs", "Prob", "Probe", " proj", "pebe", "probe", " probe", "pebs", "pej"], "dataSB": ["codeRB", "codeEB", "workPB", "errorSB", "eventSB", "DataHL", "controlSB", "DataLB", "workBB", "uiEl", " dataEl", "execLB", "fileLB", "cacheBL", "eventLB", "fileSB", "loadSB", " dataHL", "pBs", "dataSL", "codeLB", "fullLB", "offSB", " dataMB", "errorPB", "cacheSB", "ifSL", "execBL", "defaultLB", "pSB", " dataRB", "cachesb", "strSB", "postLB", "postSB", " dataBB", "dataHL", "defaultBB", "fullBB", "offSL", "contentOB", "nosb", "datasb", "errorOB", "cacheLB", "codeMB", "codeFB", "controlBL", "ifsb", "innersb", " dataLB", "ifLB", "fullBL", "responseBB", "codeHL", "errorEB", "defaultSB", "responseSB", "datLB", "offBB", "execsb", "dataMB", "psb", "postSL", "DataSB", "dataBL", "Datasb", "datOB", "dataEB", " dataBL", " dataSL", "DataBL", "ifSB", "offsb", " dataFB", "dataRB", "defaultsb", "DataMB", "contentLB", " datasb", "innerSL", "execBB", "dataLB", "filesb", "contentsb", "noLB", "errorBB", "uiSB", "innerSB", "fullSB", "dataPB", "strSL", "workSB", "noSB", "responseLB", "innerLB", " dataEB", "codeBs", "workSL", "dataFB", "fileSL", "dataOB", "DataRB", "loadLB", "strsb", "codeBB", "errorSL", "loadsb", "dataEl", "errorsb", "postsb", "uiLB", "offLB", "dataBB", " dataOB", "eventSL", " dataPB", "controlsb", "DataOB", "datSB", "codesb", "controlBB", "datBB", "contentSB", "noSL", "DataSL", "DataBB", "dataBs", "execSB", "loadBB", "pLB", "codeEl", "controlLB", "errorLB", " dataBs", "codeSB", "DataFB", "strLB", "eventBB", "responseBL"], "trace": ["race", "shadow", " debug", "test", "atter", "result", "flow", "address", "error", " traced", "cache", "bean", "e", " traces", "ace", "cover", "xml", "log", "tx", "string", "out", "profile", "bug", "err", "ray", "t", "ptr", "type", "info", "report", "r", "ctr", "span", " tracing", "tr", "strip", "message", "debug", "buffer", "array", "scale", "track", "stack", "data", "tri", "trip", "details", "runner", "trans", "fake", "temp"]}}
{"id1": "12349563", "id2": "9096314", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"resourceExists": [" resourceCompits", " resourceexits", " fileExists", " fileexistence", " resourceExistence", " fileexes", " resourceCompists", " fileexits", " resourceAbsits", " resourceAbses", " fileexists", " fileExits", " resourceexistence", " resourceExes", " resourceexists", " resourceExits", " fileExistence", " fileExes", " resourceCompistence", " resourceCompes", " resourceAbsists", " resourceAbsistence", " resourceexes"], "location": ["address", "position", "base", "description", "LOC", "local", "provided", "region", "path", "folder", "remote", "node", "filename", "length", "name", "string", "target", "language", "host", "pointer", "image", "layer", "operation", "type", "reference", "connection", "info", "route", "shape", "object", "directory", "loc", "layout", "message", "uri", "resource", "content", "point", "href", "data", "source", "file", "server", "Location", "area", "collection", "home", "localhost", "response"], "url": ["address", "base", "zip", "io", "URL", "path", "sl", "fl", "Url", "host", "string", "obj", "image", "c", "lib", "build", "ssl", "i", "r", "connection", "user", "b", "ll", "www", "config", "loc", "uri", "api", "resource", "http", "l", "page", "source", "file", "server", "impl", "open", "web", "blog", "f"], "cxn": ["Cxn", "cxxn", "cexn", "crexcon", "cdscon", "cdsg", "crexp", " cxp", " cxg", " crexp", " cxcon", "cuxns", " crexg", "cxxp", "cxp", "cxxne", "cexp", "cuxn", "crexn", " crexn", "cxcon", "cxne", "Cxp", "cxxns", "Cuxp", "cexg", "cexns", "cxg", "Cuxne", "Cxne", " crexcon", "Cuxn", "Cxns", "cexne", "cuxp", "cuxne", "cdsn", "cexcon", "Cuxns", "cxns", "cdsp", "crexg"], "is": ["us", "im", "ais", "ip", "ms", "ai", "does", "ois", "ob", "app", "iso", "was", "ar", "id", "isa", "has", "IS", "bis", "x", "Is", "es", "oss", "abs", "out", "ir", "s", "ui", "stream", "ris", "cms", "next", "isl", "ios", "iss", "os", "nis", "or", "ori", "i", "info", "js", "lis", "internet", "isc", "isi", "uri", "fs", "api", "close", "it", "get", "iris", "its", "http", "in", "cos", "ens", "init", "src", "as", "web", "bs"], "byteBuffer": ["bitBuffer", "bitBuff", "byteLength", "byteBB", "ByteBuff", "bitLength", " byteBuff", "ByteBB", "bitBB", " byteBB", "ByteBuffer", "byteBuff", "bitArray", " byteArray", "ByteLength", "ByteArray", "byteArray", " byteLength"]}}
{"id1": "5759961", "id2": "16063533", "code1": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "code2": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "label": 1, "substitutes": {"saveUser": ["SaveUser", "SavePerson", "savePerson", " savePerson", "saveuser", "saveAccount", "submitAccount", "submitUser", "submitPerson", "SaveAccount", " saveuser", "Saveuser", " saveAccount", "submituser"], "user": ["result", "base", "account", "ver", "job", "clean", "project", "e", "use", "force", "app", "valid", "model", "replace", "db", "one", "request", "log", "User", "student", "users", "plugin", "creator", "name", "string", "profile", "bug", "word", "this", "facebook", "self", "book", "editor", "or", "username", "you", "used", "class", "object", "parent", "rule", "query", "per", "config", "service", "resource", "person", "content", "me", "usr", "data", "up", "entry", "USER", "password", "style", "tool", "full", "group", "home", "uid", "team", "record", "blog", "author", "module"], "digest": ["digit", "signEST", "signest", "mdEST", "genest", "bigest", "genge", "mdit", "Digge", " digge", "mdest", "digEST", "Digert", "bigester", " digester", "digester", "digert", "digge", " digEST", "mdge", "DigEST", "bigge", " digert", "genit", "Diger", "Digester", "signester", "diger", "Digest", " diger", "signer", "biger", "Digit", "genEST", "bigert"], "hash": ["url", "base", "sha", "ash", "cache", "id", "current", "db", "check", "Hash", "total", "index", "string", "max", "memory", "image", "hex", "build", "code", "count", "html", "fill", "number", "empty", "query", "block", "her", "message", "array", "update", "version", "depth", "key", "mac", "math", "search", "h", "match", "password", "num", "full", "sum"], "bigInt": ["hashInt", "Bigint", "largeInteger", "bigint", "hashUrl", "BigInt", "hugeInteger", "hugeint", "BigInteger", "hashint", "largeint", "bigInteger", "bigString", "bigUrl", " bigUrl", "largeInt", " bigInteger", "hugeInt", "largeString", "hugeUrl", "BigString", " bigint", "hashInteger", " bigString"], "hashtext": ["hashword", "sumText", "sumfeed", "ashstring", " hashword", " hashText", " hashstring", "ashText", " hashpath", "sumtext", "ashpath", " hashTEXT", "hashText", "ashfeed", "sumTEXT", "ashtext", "sumstring", "hashTEXT", "hashfeed", "Hashstring", "Hashpath", "HashTEXT", "hashstring", "HashText", "Hashword", "ashTEXT", "hashpath", "ashword", "sumword", "Hashfeed", "Hashtext"]}}
{"id1": "5760649", "id2": "21092340", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "label": 1, "substitutes": {"createFile": ["CreateContent", "createContent", "CreateFolder", "saveFile", "createFolder", " createFolder", "saveContent", "createResource", "saveFolder", "saveResource", " createResource", " createContent", "CreateResource", "CreateFile"], "src": ["fp", "url", "sit", "img", "gb", "load", "proc", "path", "sl", "input", "string", "name", "s", "obj", "stream", "secure", "Source", "resources", "upload", "ruby", "files", "sel", "username", "SourceFile", "ssl", "sb", "r", "buf", "dest", "loc", "slice", "uri", "rob", "resource", "rb", "content", "rc", "href", "source", "data", "file", "fn", "sc", "rss", "txt", "cb"], "filename": ["fp", "url", "rl", "FILE", "title", "sf", "dll", "output", "metadata", "ame", "fil", "which", "ames", "ename", "path", "utf", "nil", "location", "name", "string", "length", "s", "prefix", "files", "username", "SourceFile", "route", "directory", "loader", "wb", "uri", "resource", "feat", "l", "source", "fn", "file", "txt", "Filename", "f", "acl"], "fis": [" fIS", " fiss", "fais", "fris", "cfis", "sfos", " fais", " fbs", "fIS", "sfris", "cfais", "Fris", "cfIS", "Fos", "Fbs", "Fis", "fbs", "Fiss", "sfiss", "FIS", "fiss", "cfos", "cfris", "cfbs", "Fais", " fris", "sfis"], "fos": ["FOS", "affbos", "sfos", "fOS", "foras", "sfops", "Fops", "bbos", "bis", "forOS", "sfios", " fOS", " fas", "foros", "Fos", "foris", "Fbos", "Fis", "fas", "fios", " fops", "affis", "bos", "affios", "Fios", "affos", "bios", " fios", "Fas", "fbos", "fops", "sfis"]}}
{"id1": "16804988", "id2": "20310134", "code1": "    public void init() {\n        String filename = getParameter(\"filename\");\n        if (filename == null) {\n            Error(\"Illegal filename\");\n            return;\n        }\n        Dimension dim = DEFAULT_SIZE;\n        try {\n            int w = Integer.parseInt(getParameter(\"width\"));\n            int h = Integer.parseInt(getParameter(\"height\"));\n            dim = new Dimension(w, h);\n        } catch (Exception e) {\n        }\n        InputStream in;\n        try {\n            File ff = new File(filename);\n            in = new FileInputStream(ff);\n        } catch (Exception ignore) {\n            try {\n                URL url = new URL(filename);\n                in = url.openStream();\n            } catch (Exception e) {\n                Error(\"Graph viewer: Failed to open: \" + filename + \"\\n\" + e);\n                return;\n            }\n        }\n        getContentPane().add(getWindow(in));\n        resize(dim);\n        repaint();\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"init": [" startup", "parse", "activate", "load", " Init", "start", " initialized", "image", "setup", "build", "format", "launch", "construct", "info", "Init", "show", "config", "layout", "Initialized", "update", " initialization", "ize", "close", "it", "create", "draw", "initial"], "filename": ["fp", "params", "title", "jpg", "dll", "metadata", "kl", "fil", "which", "ename", "path", "utf", "folder", "nil", "location", "string", "name", "length", "binary", "word", "doi", "prefix", "upload", "database", "files", "journal", "username", "SourceFile", "ssl", "ppa", "directory", "n", "online", "config", "loc", "loader", "uri", "license", "kn", "content", "Filename", "fd", "phrase", "l", "txt", "fn", "file", "fax", "password", "download", "sf", "size", "f", "il"], "dim": ["im", "cm", "thin", "img", "imm", "wid", "Dim", "marg", "project", "gm", "sam", "ims", "div", "val", "index", "py", "fm", "ext", "param", "image", "multi", "spec", "dem", "si", "mi", "m", "format", "info", "g", "dat", "shape", " reim", "span", "iframe", "config", "slice", "diff", "grad", "du", "p", "scale", "min", "dom", "fi", "mod", "grid", "dr", "di", "wm", "width", "dist", "d", "num", "dimension", "dm", "lim", "part", " Dim", "size", "fac"], "w": ["wt", "v", "z", "wa", "k", "e", "x", "q", "u", "s", "max", "hw", "c", "rw", "y", "m", "en", "t", "a", "i", "r", "b", "n", "o", "ow", "weight", "ew", "win", "wh", "height", "p", "wd", "l", "W", "width", "fw", "d", "sw", "f"], "h": ["H", "v", "z", "k", "rh", "e", "x", "gh", "q", "hr", "s", "u", "kh", "hd", "uh", "c", "hs", "y", "t", "en", "j", "ph", "b", "n", "th", "o", "height", "p", "hm", "sh", "l", "bh", "d", "ih", "ah", "oh", "ht", "f", "ha"], "in": ["fp", "serv", "gin", "cf", "ins", "cl", "reader", "din", "IN", "login", "el", "bin", "id", "io", "inc", "ini", "fb", "input", "out", "In", "conn", "stream", "err", "fe", "ax", "lib", "read", "ssl", "i", "r", "connection", "b", "n", "again", "fc", "socket", "nin", "win", "inn", "resource", "min", "pin", "is", "l", "data", "source", "file", "cgi", "kin", "src", "ac", "amin", "impl", "as", "f", "fac"], "ff": ["uf", "fp", "cf", "iff", "xff", "ouf", "bb", "feed", "ulp", "ffe", "df", "ctx", "fb", "fl", "fff", "aff", "fe", "ef", "buff", "fx", "library", "buf", "eff", "back", "fc", "FF", "fed", "af", "fd", "lf", "file", "bf", "pp", "sf", "cb", "f", "cmp"], "url": ["fp", "base", "ob", "e", "feed", "io", "URL", "zip", "path", "sl", "fl", "Url", "fb", "string", "ls", "stream", "image", "ssl", "connection", "b", "ll", "www", "fr", "uri", "resource", "http", "l", "source", "file", "web", "server", "download", "src", "open", "sf", "f"]}}
{"id1": "18374478", "id2": "481364", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "label": 0, "substitutes": {"updateUser": ["updateRole", "addWord", " updateMember", "deleteuser", " updateRole", " updateuser", "editUser", "editUsers", "deleteMember", "updatedUser", "updatedWord", "updateduser", "UpdatePassword", "updatePassword", "createUser", "updateWord", "UpdateMember", "editRole", "updateuser", " updateAccount", " updateWord", "UpdateRole", "deletePassword", "createRole", "adduser", "updateAccount", "UpdateUsers", "editAccount", "deleteRole", "updateMember", "addUsers", "deleteWord", "UpdateUser", "updatedUsers", "updateUsers", " updatePassword", "addUser", "Updateuser", "UpdateWord", "createAccount", "deleteUser", "createUsers", " updateUsers", "deleteUsers"], "user": ["result", "ver", "client", "account", "job", "system", "project", "str", "view", "site", "use", "app", "current", "model", "log", "User", "row", "users", "session", "plugin", "name", "creator", "profile", "string", "contact", "bug", "this", "character", "self", "auth", "username", "you", "custom", "connection", "used", "null", "object", "parent", "rule", "config", "author", "per", "update", "message", "post", "resource", "person", "p", "version", "content", "page", "me", "data", "pool", "match", "ro", "USER", "server", "member", "instance", "full", "group", "record", "manager", "response", "module"], "conn": ["exec", "cm", "url", "mc", "client", "ca", "ann", "cache", "util", "uc", "ob", "el", "ou", "reg", "cb", "db", "log", "pt", "connect", "sql", "host", "core", "cr", "cp", "oss", "sth", "lock", "c", "cc", "ci", "org", "ct", "ec", "connection", "Connection", "n", "config", "enc", "loc", "nt", "co", "pub", "sync", "cond", "socket", "dc", "api", "close", "pg", "h", "rc", "col", "cli", "pool", "cn", "ch", "act", "server", "coll", "pc", "con", "nc", "ac", "cat", "Conn", "serv", "part", "conf", "ctx", "ha", "pr"], "autoCommit": ["automaticCommend", "autoCitting", "autoDebite", " autoCommite", "autoCited", "automaticDebIT", "autoRebits", "autoCommits", "autoCommited", "autoDebit", "autoDebmit", " autoComits", " autoCommited", "automaticDebend", "autoCommIT", "autoBlend", "autoComit", "autoComits", " autoDebit", "autoDebitting", "automaticDebmit", "autoBlmit", " autoCommits", " autoDebmit", "autoCmit", "autoRebit", " autoDebited", " autoDebitting", "autoComIT", "automaticCommIT", "automaticDebit", "autoAbitting", "autoBlit", "autoRebite", "autoCommend", "autoCit", " autoCommmit", "autoComite", "autoDebited", "autoAbmit", "autoDebend", "autoCommitting", "autoAbit", "autoAbited", "autoDebits", "automaticCommit", "automaticCommmit", " autoComite", "autoBlIT", "autoCommmit", "autoCommite", "autoDebIT", "autoComend", " autoCommitting", " autoComit"], "deleteRoles": ["deleteRsoles", "destroyRols", "deleteSlole", "deleteLoles", "deleteDoots", "destroyNoots", "deleteGrils", "insertRoases", "deleteLodes", "destroyNols", "deleteDules", "deleteDils", "delLoles", "delLole", "deleteRules", "deleteDases", "deleteRooles", "deleteDole", "deleteNoots", "deleteCases", "deleteSlases", "insertRooles", "deleteDols", "destroyRoots", "insertRoules", "insertRole", "delRoles", "deleteGroles", "deleteRils", "deleteRodes", "deleteRsules", "delLases", "destroyNils", "destroyRils", "insertRases", "deleteRoole", "deleteRoules", "delRole", "deleteRoots", "delRodes", "deleteRsases", "delRases", "deleteLole", "deleteNils", "deleteGrols", "destroyNoles", "deleteRsole", "deleteRole", "deleteRases", "deleteSloles", "deleteNols", "deleteRoases", "deleteRols", "insertRoole", "deleteCodes", "destroyRoles", "deleteCole", "deleteSlodes", "deleteDoles", "deleteGroots", "insertRules", "deleteNoles", "deleteLases", "delLodes", "deleteColes"], "insertRoles": ["updateLols", "insertLoots", "copyRules", "insertGoots", "updateRoles", "insertRsles", "insertRows", "insertLles", "insertLules", "copyRoles", "insertRsules", "insertRodes", " insertShole", "updateLoles", "insertSules", "copyGows", "copyGules", "insertRsoles", "updateRules", " insertRules", " insertSholes", " insertRodes", "insertSodes", "deleteRanges", "insertSloots", "copyRows", " insertRole", "insertRsanges", "insertRsodes", "insertLoles", "insertRoots", "copyGoots", "insertRols", "updateRols", "insertSlanges", "insertSole", "copyGoles", "insertSoles", " insertShules", "copyRoots", "insertRles", "updateLules", "insertSholes", "insertRanges", "insertLols", "insertShole", "insertRules", "insertGules", "insertShules", "insertLows", "deleteSlanges", "deleteSloots", "insertRsoots", "updateRles", "insertRsows", " insertShodes", "insertRole", "deleteRodes", "insertSloles", "insertGoles", "insertSlodes", "deleteRoots", "updateLles", "deleteSloles", "insertRsols", "deleteSlodes", "insertGows", "insertShodes"], "role": ["shadow", "slave", "de", "base", "error", "alias", "force", "Role", "relation", "one", "rol", "function", "row", "val", "label", "string", "profile", "range", "to", "link", "or", "username", "zone", "type", "repl", "route", "tag", "rule", "guard", "service", "resource", "key", "l", "entry", "roller", "ro", "member", "ole", "group", "rl", "tool", "le", "module"]}}
{"id1": "18570190", "id2": "14231545", "code1": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 0, "substitutes": {"getProcess": ["createJob", "createprocess", "updateResource", "createResource", "getResource", "createProcess", "showJob", "showProcess", "updateJob", "showprocess", "updateProcess", "getprocess", "updateprocess", "showResource", "getJob"], "processId": ["processID", "taskID", "processorID", "Processid", "processorId", "processorid", "processName", "ProcessId", "taskId", " processName", "processid", "taskName", " processID", " processid", "ProcessName", "ProcessID"], "req": ["exec", "fp", "url", "Resp", "app", "cb", "requ", "sub", "proc", "rr", "request", "res", "q", "conn", "obj", "err", "rep", "rt", "imp", "require", "sq", "info", "r", "rx", "desc", "query", "qq", "ok", "fr", "resource", "get", "Request", "http", "op", "gr", "ref", "json", "quest", "serv", "ctx", "f", "response", "pr"], "resp": ["exec", "jp", "result", "esi", "error", "exc", "client", "Resp", "status", "rh", "rel", "re", "bb", "e", "inv", "feed", "proc", "Response", "rr", "request", "res", "conn", "obj", "soc", "rep", "err", "imp", "respond", "report", "html", "body", "par", "rec", "enc", "fc", "fr", "api", "eb", "http", "lf", "page", "entry", "server", "ev", "ref", "coll", "pp", "reply", "json", "rss", "sp", "serv", "esp", "ctx", "f", "response", "rev"], "xmlable": [" xmlsafe", "textabe", "xmlables", "phpabe", "wireparable", "playachable", "xmlsafe", "textables", "playabe", "textachable", " textabe", "phpparable", " xmlabe", " textable", "wireability", "phpble", "wireble", "xmlparable", "textable", "phpability", " xmlparable", "playables", "phpachable", " adaptable", " adaptabe", "phpable", "xmlabe", "xmlachable", "xmlability", " adaptsafe", "wireable", "phpables", " xmlble", " textsafe", " xmlability", " textble", "xmlble", "playable", " adaptble"], "p": ["jp", "fp", "v", "ping", "pa", "tp", "ap", "e", "bp", "lp", "port", " ap", " subp", "P", "vp", "er", "pointer", "cp", "c", "pkg", "t", "j", "a", "i", "pid", "g", "n", "object", "parent", "o", "ps", " pi", " disp", "ing", "parser", "api", "l", "pb", "pc", "pp", "part", "f", "pi"]}}
{"id1": "21010945", "id2": "15971794", "code1": "    private static List runITQLQuery(String itqlQuery) throws Exception {\n        String escapedItqlQuery = URLEncoder.encode(itqlQuery, \"UTF-8\");\n        String url = \"http://\" + Config.getProperty(\"FEDORA_SOAP_HOST\") + \":\" + Config.getProperty(\"FEDORA_SOAP_ACCESS_PORT\") + \"/fedora/risearch?type=tuples\" + \"&lang=iTQL\" + \"&format=CSV\" + \"&distinct=on\" + \"&stream=on\" + \"&query=\" + escapedItqlQuery;\n        logger.debug(\"url for risearch query: \" + url);\n        URL urlObject = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) urlObject.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        logger.debug(\"response code: \" + con.getResponseCode());\n        if (con.getResponseCode() != 200 && con.getResponseCode() != 302) {\n            throw new FedoraAccessException(\"Could not access the risearch service at url: \" + url);\n        }\n        ArrayList arrayList = new ArrayList();\n        String inputLine;\n        int counter = 0;\n        while ((inputLine = br.readLine()) != null) {\n            logger.debug(\"reading line:\" + inputLine);\n            if (inputLine.indexOf(\"<html>\") >= 0) {\n                logger.error(\"problem quering the relationship\");\n                throw new Exception(\"Problem querying relationships; probably a bad ITQL query:\" + itqlQuery);\n            }\n            if (counter >= 1 && inputLine.indexOf(\"/\") >= 0 && inputLine.trim().length() > 0) {\n                logger.debug(\"adding line:\" + inputLine);\n                inputLine = inputLine.substring(inputLine.indexOf(\"/\") + 1);\n                arrayList.add(inputLine);\n                logger.debug(\"found relationship to item: \" + inputLine);\n            }\n            counter++;\n        }\n        br.close();\n        logger.debug(\"num relationships found: \" + arrayList.size());\n        return arrayList;\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"runITQLQuery": ["runItqlString", "runItqlRequest", "runITqlQuery", "runITQquery", "runITSQLRequest", "runItqlQuery", "runItQLRequest", "runITqlquery", "runITQLquery", "runITQString", "runITSQLQuery", "runITqlString", "runITQLRequest", "runITQRequest", "runITSQLString", "runITQQuery", "runItQLString", "runITSQLquery", "runITQLString", "runItqlquery", "runItQLquery", "runITqlRequest", "runItQLQuery"], "itqlQuery": ["itQLquery", "itqlRequest", "itSQLQu", "pitSQLquery", "ItsqlStatement", "itsqlStatement", "pitSQLString", "itQLString", "ItsqlCommand", "itwlCommand", "itqlQu", "itqlquery", "itqlCommand", "ItqlStatement", "pitSQLQuery", "ItsqlString", "itsqlString", "itQLQu", "itsqlquery", "pitqlQu", "itQLCommand", "ItqlRequest", "itsqlQu", "itQLStatement", "itQLQuery", "itsqlQuery", "pitqlQuery", "itwlquery", "itwlRequest", "itQLRequest", "ItsqlRequest", "itSQLQuery", "ItqlString", "Itqlquery", "pitqlString", "itsqlCommand", "itSQLStatement", "itqlString", "pitSQLQu", "ItqlCommand", "itsqlRequest", "pitqlquery", "itSQLString", "ItsqlQuery", "Itsqlquery", "itqlStatement", "ItqlQuery", "itwlQuery", "itSQLquery"], "escapedItqlQuery": ["escapedItQLQu", "escapedItQLString", "escapedItqlString", "escapedITqlQuery", "escapeditQLRequest", "escapedItqquery", "escapedItqlRequest", "escapeditqlRequest", "escapedItqQu", "escapedItQLquery", "escapedItQLRequest", "escapedITsqlquery", "escapedItsqlquery", "escapeditqlQuery", "escapedItqlQu", "escapeditqlquery", "escapedItqString", "escapedItsqlString", "escapedItQLQuery", "escapedITsqlRequest", "escapeditqlString", "escapedITsqlQu", "escapedITqlquery", "escapeditQLquery", "escapedITsqlQuery", "escapedITqlRequest", "escapedItsqlQuery", "escapedITqlQu", "escapeditQLString", "escapeditQLQuery", "escapedItqQuery", "escapedItsqlRequest", "escapedItqlquery", "escapedItsqlQu", "escapedItqRequest"], "url": ["address", "lc", "base", "el", "id", "feed", "URL", "path", "xml", "request", "sl", "Url", "host", "location", "string", "name", "obj", "pattern", "q", "image", "large", "build", "org", "ssl", "connection", "method", "html", "route", "rule", "ll", "www", "config", "loc", "ur", "buffer", "uri", "service", "resource", "lr", "http", "href", " URL", "l", "page", "file", "server", "email", "download", "coll", "impl", "rl", "f", "response"], "urlObject": ["httpNumber", "Urlobject", " urlobject", "httpURL", " urlNumber", "UrlURL", "UrlObj", "urlOb", " urlURL", " urlObj", "httpObj", "urlobject", "UrlOb", "httpObject", "URLobject", "urlURL", "URLObject", " urlOb", "UrlNumber", "UrlObject", "urlObj", "URLOb", "urlNumber"], "con": ["exec", "bc", "cm", "cf", "cl", "ocon", "syn", "can", "uc", "bn", "client", "dec", "ver", "Connect", "un", "ran", "inc", "sub", "func", "connect", "res", "conn", "acon", "cr", "obj", "conv", "core", "inner", "c", "ctrl", "ct", "en", "ec", "connection", "Connection", " connection", "enc", "fc", "co", "Con", "close", "min", "non", "http", " CON", "rc", "CON", "ch", "cn", " conn", "coll", "pc", "nc", "Conn", "open", "cons", "conf", "xc", "part", "fac"], "br": ["bc", "result", "cm", "reader", "ver", "mr", "sr", "str", "ob", "output", "io", "arr", "er", "res", "conn", "obj", "cr", "stream", "hr", "bridge", "fin", "bro", "err", "bl", "Br", "Reader", "r", "b", "bar", "buf", "browser", "grab", "tr", "fr", "buffer", "lr", "p", "rb", "form", "http", "dr", "rc", "BR", "data", "ch", "bh", "gr", " reader", "cro", "fore", "runner", "ctr", "response", "fac"], "arrayList": ["elementChain", " arrayChain", "areaGroup", " arrayArray", "elementArray", " arrayGroup", "areaArray", " arrayClient", "areaTree", "elementList", "inputGroup", "inputArray", "arrayClient", "areaClient", "inputList", "areaList", "arrayGroup", "inputClient", "areaChain", "arrayTree", "arrayChain", "elementTree", " arrayTree", "arrayArray"], "inputLine": ["currentline", "inputDir", "rawLine", "interfaceFile", "inL", "interfaceline", "imageline", "rawPage", "outputPage", "inputLetter", "InputLetter", " inputL", "rawBlock", "outputLine", " inputList", "currentFile", "imageL", "inputLin", "outputline", "qaLine", "uploadLin", "inputFile", "currentL", "imageLINE", " inputPage", "issueLine", "qaFile", "InputString", "imageList", "qaL", "currentBlock", "inputList", "workLine", "InputLine", "inLine", " inputline", " inputLu", "currentLine", "interfaceLu", "inputLu", "inputString", "InputBlock", "inputLINE", "imageLin", "workFile", "InputL", "issueBlock", "outputLin", " inputLin", " inputLetter", " inputString", "interfaceLine", "InputDir", "inFile", "uploadLine", "inputPage", "uploadPage", "inputL", "InputLu", " inputLINE", "rawLin", "uploadline", "inline", "issueLINE", "InputPage", " inputBlock", "inputBlock", " inputFile", "currentString", "qaLetter", "issueList", "workline", "InputFile", "rawline", "Inputline", "rawL", "inputline", "imageLine", " inputDir", "imageDir", "imageBlock"], "counter": ["race", "result", "processor", "lc", "ver", "ter", "cache", "controller", "cover", "child", "cur", "default", "function", "nr", "index", "repeat", "pattern", "name", "time", "offset", "inner", "rew", "c", "step", "trace", "code", "sum", "type", "i", "count", "info", "ctr", "number", "center", "parent", "handler", "stop", "loader", "outer", "Counter", "key", "stack", "page", "continue", "entry", "server", "loop", "instance", "num", "field", "second", "currency", "ctrl", "inter", "cre", "cmp"]}}
{"id1": "5683576", "id2": "7891509", "code1": "    public String shorten(String url) {\n        List<NameValuePair> qparams = new ArrayList<NameValuePair>();\n        qparams.add(new BasicNameValuePair(\"version\", \"2.0.1\"));\n        qparams.add(new BasicNameValuePair(\"longUrl\", url));\n        if (login != null) {\n            qparams.add(new BasicNameValuePair(\"login\", login));\n            qparams.add(new BasicNameValuePair(\"apiKey\", apiKey));\n            qparams.add(new BasicNameValuePair(\"history\", \"1\"));\n        }\n        try {\n            BasicHttpParams params = new BasicHttpParams();\n            DefaultHttpClient httpclient = new DefaultHttpClient(params);\n            URI uri = URIUtils.createURI(\"http\", \"api.j.mp\", -1, \"/shorten\", URLEncodedUtils.format(qparams, \"UTF-8\"), null);\n            HttpGet httpget = new HttpGet(uri);\n            if (logger.isDebugEnabled()) logger.debug(\"HttpGet.uri={}\", httpget.getURI());\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                InputStream instream = entity.getContent();\n                JsonFactory f = new JsonFactory();\n                JsonParser jp = f.createJsonParser(instream);\n                JmpShortenResponse responseObj = new JmpShortenResponse();\n                for (; ; ) {\n                    JsonToken token = jp.nextToken();\n                    String fieldname = jp.getCurrentName();\n                    if (logger.isDebugEnabled()) logger.debug(\"Token={}, currentName={}\", token, fieldname);\n                    if (token == JsonToken.START_OBJECT) {\n                        continue;\n                    }\n                    if (token == JsonToken.END_OBJECT) {\n                        break;\n                    }\n                    if (\"errorCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorCode(jp.getIntValue());\n                    } else if (\"errorMessage\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorMessage(jp.getText());\n                    } else if (\"statusCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setStatusCode(jp.getText());\n                    } else if (\"results\".equals(fieldname)) {\n                        Map<String, ShortenedUrl> results = parseResults(jp);\n                        responseObj.setResults(results);\n                    } else {\n                        throw new IllegalStateException(\"Unrecognized field '\" + fieldname + \"'!\");\n                    }\n                }\n                Map<String, ShortenedUrl> results = responseObj.getResults();\n                if (results == null) {\n                    return null;\n                }\n                ShortenedUrl shortened = results.get(url);\n                if (shortened == null) {\n                    return null;\n                }\n                if (logger.isDebugEnabled()) logger.debug(\"JmpShortenResponse: {}\", responseObj);\n                if (\"OK\".equals(responseObj.getStatusCode())) {\n                    return shortened.getShortUrl();\n                }\n                if (logger.isWarnEnabled()) logger.warn(\"JmpShortenResponse: {}\", responseObj);\n            }\n        } catch (IOException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        } catch (URISyntaxException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        }\n        return null;\n    }\n", "code2": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"shorten": ["Shorten", "shortener", "shortening", "offening", " Shortend", "shortend", "Shortend", " Shortening", "Shortening", "offend", "offen", " Shorten", "Shortener", " Shortener", "offener"], "url": ["address", "base", "account", "login", "str", "id", "URL", "term", " resource", "path", "request", "sl", "Url", "host", "location", " webpage", "string", "ls", "language", "name", "username", "info", "method", "route", "text", "www", "config", "service", "api", "resource", "version", "key", "http", "l", "page", "source", "data", "server", "file", "email", "secret", "json"], "qparams": [" qtypes", "kparams", "kresults", "Qtypes", "questproperties", "reqproperties", "qutags", "reqtags", "kams", "Qplugins", "qvals", "sqchanges", "questplugins", "reqparams", "qutypes", "quproperties", "qParameters", " qams", "sqresults", "sqtags", " qchanges", "Qnames", "qtproperties", " qParameters", "quannels", "questapi", "Qapi", "qtypes", "kchanges", "qtParameters", "Qdetails", "quparams", " qproperties", " qdetails", "Qparams", "sqoptions", "qresults", "sqams", "reqmac", "sqmac", " qannels", "qoptions", "questdetails", "qquery", "qtquery", "qnames", " qoptions", "qchanges", "quapi", "questannels", "qannels", "Qvals", " qmac", "qams", " qnames", " qapi", "questparams", "qtparams", " qresults", " qtags", " qquery", "questvals", "qunames", "qdetails", "qmac", "qproperties", "qplugins", "qtags", "Qproperties", " qplugins", " qvals", "qapi", "reqoptions", "Qtags", "reqParameters", "reqquery", "sqparams"], "params": ["services", "posts", "base", "pro", "radius", "lp", "apter", "Parameters", "py", "s", "param", " parameters", "properties", "ssl", "afi", "i", "ras", "options", "ps", "config", "per", "plugins", "mm", "license", "api", "p", "http", "phrase", "ams", "server", "qs", "password", "secret", "instance", "json", "details", "ctx", "rules", "cmp", "pi", "settings"], "httpclient": [" httpapi", "httppublic", "webconn", "httpconnection", "httpapi", " httppublic", "webconnection", " httpconnection", "webClient", "htmlconnection", "webapi", " httpcli", "httpconn", "phpclient", "httpClient", " httpconn", "phppublic", "httpcli", "phpapi", " httpClient", "phpClient", "htmlconn", "webclient", "webpublic", "htmlcli", "webcli", "htmlclient"], "uri": ["qi", "address", "base", "client", "URL", "iri", "proxy", "path", "request", "environment", "plugin", "location", "u", "ui", " URI", "range", "ilo", "doi", "uni", " ur", "database", "mi", "adi", "i", "connection", "route", "directory", "direction", "ri", "ur", "service", "api", "resource", "gi", "URI", "document", "http", "href", "cli", "server", "universal", "pi"], "httpget": ["httpsshow", "httplike", "httpstart", "harfind", " httpshow", "httget", " httplike", "ttpsend", "ttpshow", "ttpGet", " httpfind", "httpssend", " httpGet", "urlget", "httpshow", "httpsGet", "httpquery", "harGet", " httpsend", "httpfind", "httstart", " httpstart", "httpsend", "htmllike", "ttpget", "urlGet", "httpGet", " httpquery", "harget", "urlstart", "urlquery", "htmlget", "htmlfind", "htmlGet", "harlike", "httpsget", "httquery", "httGet"], "response": ["result", "received", "status", "output", "feed", "Response", "request", "environment", "generation", "next", "respond", "connection", "application", "object", "body", "message", "service", "resource", "api", "document", "page", "data", "resp", "server", "entry", "successful", "value", "full", "reply", "json", "collection", "onse", "relation"], "entity": ["result", "error", "el", "e", "output", "iso", "metadata", "model", "xml", "environment", "issue", "node", "eni", "obj", "ilo", "image", "company", "event", "element", "component", "info", "connection", "ent", "object", "body", "message", "api", "resource", "p", "person", "em", "content", "document", "get", "translation", "Entity", "page", "data", "article", "file", "server", "email", "coll", "value", "json", "collection", "po"], "instream": ["innstream", "Infile", "inputstruct", "Invideo", "Instring", " invideo", " instring", "Instream", "innstring", "outstream", "instruct", " instruct", "outStream", "invideo", "infile", "inputStream", " inStream", "inStream", "innvideo", "innfile", "outstruct", " infile", "outfile", "inputstream", "instring", "inputfile"], "f": ["fp", "v", "cf", "w", "e", "feed", "fab", "tf", "rf", "df", "fb", "fm", "aff", "c", "fe", "m", "t", "j", "fx", "i", "info", "F", "fc", "fr", "fs", "api", "inf", "p", "h", "fd", "l", "d", "bf", "framework", "full", "json", "fing", "sf", "fac"], "jp": ["fp", "bj", "prot", "uj", "pa", "ja", "tp", "JP", "bp", "lp", "zip", "jc", "jar", "kj", "git", "je", "py", "ppo", "vp", "fm", "hp", "obj", "cp", "jing", "rup", "pkg", "orb", "aja", "bot", "np", "adj", "keeper", "j", "java", "ijk", "gp", "js", "appy", "dj", "jen", "api", "p", "jo", "dt", "jl", "data", "pb", "qt", "pai", "ji", "pp", "json", "txt", "jj", "mp"], "responseObj": ["respondObj", "responseInfo", "ResponseOb", "Responseobj", "respInfo", " responseExt", "serverObject", " responseObject", "responseObject", "respondObject", "serverOb", "respondExt", "responseOb", " responseOb", "respondInfo", "responseExt", "responseobj", "ResponseObj", "ResponseObject", "respExt", " responseInfo", "serverobj", " responseobj", "respObj", "respObject", "serverObj"], "token": ["complete", "wt", "template", "header", "KEN", "after", "oken", "current", "sign", "valid", "operator", "Token", "node", "pattern", "start", "name", "string", "note", "seed", "session", "generation", "action", "language", "next", "prefix", "bot", "character", "or", "format", "event", "type", "element", "info", "notice", "active", "cho", "writer", "object", "tag", "rule", "tick", "aa", "ok", "parser", "tree", "date", "api", "iter", "p", "option", "key", "document", "cookie", "in", "data", "fn", "channel", "init", "qt", "variable", "field", "random", "json", "atom", "open", "po"], "fieldname": ["handname", " fieldalias", "Fieldnan", "FieldName", "handame", "groupn", "columname", "fieldnan", "columnnan", "ieldname", "managern", "handnan", "groupName", "columnName", "groupname", "ieldalias", "groupalias", "Fieldname", "handName", "fieldvalue", "managervalue", "ieldName", " fieldn", "groupvalue", "ieldvalue", " fieldName", "managerName", "fieldn", "columnname", "fieldalias", "managername", "fieldName", " fieldvalue", "Fieldame", "fieldame"]}}
{"id1": "8150996", "id2": "13063241", "code1": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "in": ["url", "base", "ins", "reader", "din", "IN", "cache", "bin", "id", "io", "inc", "ini", "input", "In", "name", "inner", "image", "c", "or", "m", "a", "i", "r", "b", "again", "sin", "inn", "min", "it", "cin", "lin", "source", "file", "data", "init", "src", "part", "f"], "out": ["exec", "base", "OUT", "outs", "cache", "project", "output", "exp", "io", "one", "x", "conn", "s", "ext", "dot", "name", "to", "lock", "write", "prefix", "off", "err", "doc", "Out", "plain", "lib", "at", "writer", "user", "b", "ex", "null", "again", "object", "o", "p", "point", "line", "data", "cos", "file", "server", "pos", "part"], "is": ["us", "im", "ais", "osi", "ins", "ip", "ai", "ms", "ib", "ois", "ob", "iso", "isa", "ar", "are", "was", "io", "id", "has", "IS", "app", "isin", "Is", "ini", "es", "oss", "ic", "abs", "ir", "s", "ui", "eni", "ci", "isl", "err", "si", "ios", "iss", "nis", "like", "or", "ori", "i", "info", "ie", "js", "cs", "ops", "loc", "isi", "ri", "ics", "uri", "fs", "get", "its", "iris", "http", "cos", "ens", "init", "as", "bs", "mis"], "os": ["sys", "us", "mos", "OS", "osi", "Os", "nos", "ois", "ot", "aos", "io", "bis", "vs", "boot", "es", "oss", "ks", "ns", "ls", "oes", "ios", "or", "bos", "ori", "oos", "dos", "des", "js", "ops", "ose", "so", "o", "ans", "ows", "fits", "oses", "los", "fs", "ols", "opens", "obs", "cos", "op", "ens", "pos", "ros", "as", "ss", "ol", "bs", "ors", "oS"], "buffer": ["Buffer", "position", "address", "result", "header", "uffer", "reader", "cache", "bin", "transfer", "FFER", "feed", "fb", "input", "border", "length", "sequence", "binary", "seed", "queue", "read", "layer", "reference", "batch", "b", "null", "buf", "block", "padding", "iter", "resource", "wave", "bytes", "flush", "data", "source", "split", "size", "buff"], "len": ["lc", "dl", "el", "id", "Len", "val", "fl", "start", "length", "li", "fin", "offset", "ln", "err", "bl", "en", "ie", "count", "n", "nt", " length", "iter", "min", "bytes", "fd", "lf", "line", "data", "lin", "l", "fn", "pos", "num", "limit", "f", "part", "size", " Len", "le", " el"], "ok": ["md", "k", "result", "error", "clean", "allow", "yes", "found", "id", "valid", "load", "ready", "check", "log", "always", "boot", "val", "bool", "auto", "hack", "bug", "ak", "lock", "err", "c", "oks", "pl", "OK", "self", "code", "or", "o", " cool", "sync", "good", "work", "op", "req", "coll", "fail", "full", "Ok", "ack", "ko", "cb", "f"]}}
{"id1": "10361370", "id2": "10547671", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 0, "substitutes": {"hash": ["shadow", "header", "sha", "ash", "cache", "ashing", "sign", "check", "Hash", "index", "hex", "build", "render", "crypt", "html", "fill", "block", "update", "version", "key", "h", "match", "dh", "password", "dump", "sum", "comment"], "saltBefore": ["sertBefore", "singALTAbove", "sintHead", "sALTStart", "isaltFrom", "sALTAbove", "isaltHead", "isaultStart", "singaltBefore", "seedAfter", "sALTBefore", "singALTBefore", "seedAbove", "singaltAbove", "isaultFrom", "sintFrom", "saltAbove", "singaltStart", "saultFrom", "sertAbove", "isaltBefore", "sultBefore", "singALTStart", "saultStart", "sALTAfter", "singaltAfter", "isaultBefore", "sultHead", "sertStart", "saltFrom", "isaltStart", "seedBefore", "sultFrom", "isaultHead", "sintBefore", "seedStart", "saultHead", "singALTAfter", "saltStart", "saultBefore", "sertAfter", "sultStart", "sintStart", "saltHead"], "content": ["address", "url", "header", "cont", "cache", "str", "output", "raw", "model", "xml", "music", "creator", "input", "filename", "pattern", "string", "sequence", "length", "stream", "word", "section", "image", "size", "character", "expression", "entity", "code", "format", "method", "text", "body", "object", "parent", "message", "buffer", "media", "resource", "version", "Content", "document", "data", "source", "password", "script", "value", "json", "comment", "temp"], "saltAfter": ["saltedAround", "sertBefore", "saltedEnd", "singaltBefore", "saltafter", "sALTBefore", "sintExtra", "sintAfter", "saltAround", "singALTAround", "sertAround", "singALTBefore", "saultAfter", "saltEnd", "saultExtra", " saltafter", "singaltEnd", " sALTAfter", "sALTEnd", " sALTExtra", "saltedAfter", "sALTAfter", " sALTBefore", "singaltAfter", "sertEnd", "sintafter", "sALTAround", "sALTExtra", "singALTEnd", "sintBefore", "saltExtra", "singALTAfter", "saltedBefore", "saultBefore", "saultafter", " saltExtra", " sALTafter", "sertAfter", "singaltAround", "sALTafter"], "repeatedHashingCount": ["repeatedHashCounter", "repeatedHumpingType", "repeatedHatingLength", "repeatedHashesNumber", "repeatedHumpingcount", "repeatedHashesCount", "repeatedHashingLength", "repeatedChashesNumber", "repeatedHashesCode", "repeatedShashingCounter", "repeatedChashesType", "repeatedChashingcount", "repeatedHashingType", "repeatedShashingCode", "repeatedHashedCount", "repeatedChashingCount", "repeatedHashCount", "repeatedChashescount", "repeatedHashingcount", "repeatedShashingLength", "repeatedHashingCode", "repeatedHashCode", "repeatedShashCode", "repeatedHashesType", "repeatedHashesCounter", "repeatedHashescount", "repeatedShashCounter", "repeatedHashedType", "repeatedHashingNumber", "repeatedChashingType", "repeatedHatingCount", "repeatedShashingCount", "repeatedShashLength", "repeatedHashingCounter", "repeatedHumpingNumber", "repeatedHatingCode", "repeatedHatingCounter", "repeatedChashingNumber", "repeatedHashedcount", "repeatedHashLength", "repeatedShashCount", "repeatedChashesCount", "repeatedHashedNumber", "repeatedHumpingCount", "repeatedHashesLength"], "digest": ["digator", " digested", " Digator", "hashest", "signEST", " Diger", " digusher", "loger", "signest", "hexString", " Digester", " digests", "DigString", "mixest", "validester", "logester", "Digger", "ngest", "Digator", "finest", "digEST", "validest", "mixested", "signger", "diggest", "digString", " digester", "Diggest", "digester", " diggest", "ngested", " digEST", "hexested", "generests", " digator", "ngester", "mixester", "digusher", "digests", "Digests", "finested", "validested", "loggest", "Digusher", "nger", "digested", "DigEST", "mixusher", "hexest", "Diger", "Digester", "hexests", "hashested", "finester", "signester", "diger", "hashString", "Digest", " diger", "digger", "Digested", "finests", "logest", "generester", " digger", "generested", "signested", "generest", "hashests", "valider", " Digest"], "digestLength": ["digestsType", " digesterType", "digesterType", "digestsLen", " digesterlength", "digestType", "digestingLength", "DigesterLen", "DigestLen", "digestingLen", "digestsLength", "digestedLen", "digestinglength", "DigestLength", "digesterLen", " digestlength", " digesterLength", "digestingType", "digesterLength", "digestedLength", "digestedlength", " digestType", "Digesterlength", "DigesterLength", "Digestlength", "digestlength", "digestslength", " digestLen", "digesterlength", " digesterLen", "digestLen"], "i": ["qi", "v", "lc", "k", "ai", "ti", "I", "e", "ami", "id", "io", "iu", "xi", "x", "ini", "index", "start", "length", "u", "li", "s", "ui", "multi", "ci", "c", "anti", "si", "phi", "ii", "t", "j", "count", "info", "b", "n", "o", "bi", "slice", "zi", "ri", "uri", "api", "p", "gi", "h", "fi", "di", "oi", "l", "d", "wei", "chi", "mu", "f", "pi"]}}
{"id1": "19549489", "id2": "21125261", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" copying", "delete", "paste", "transfer", "zip", "io", "Copy", " copied", "Transfer", "write", "upload", "Cop", "all", "cop", "sync", "p", " transfer", " copies", "source", "move", "file", "download", "create", " move", "split", " Copy", "clone"], "sourceFile": ["sourceFiles", "resourceFile", "searchFilename", "resourcefile", " sourceFiles", " sourceFILE", "resourceDirectory", "servicefile", "sourceFILE", "resourceFiles", "sourceFilename", " sourceDirectory", "SourceDirectory", " sourcefile", "siteFiles", "SourceFile", "searchfile", "sourcefile", "siteDirectory", "serviceFiles", "serviceFilename", "SourceFILE", "sourceDirectory", "serviceFile", " sourceFilename", "Sourcefile", "searchFiles", "siteFILE", "siteFile", "SourceFiles", "searchFile"], "destinationFile": ["destinatorImage", "destinationImage", "destinatedImage", "destinatedFiles", "destinatorDir", "DestinationDir", "destinationFiles", "DestinationFiles", "destinatedFile", "distinatedFiles", "DestinationFile", "distinationImage", "destationFiles", "destationfile", "destinatorFile", "distinatedFile", "distinatedDirectory", "distinationDirectory", "destinationDir", "destinatedDir", "destationDir", "destinatorFiles", "destationImage", "DestinatorDir", "distinatedImage", "destinatedfile", "destationDirectory", "destationFile", "distinationFiles", "destinatedDirectory", "destinatorDirectory", "destinationfile", "DestinatorFiles", "distinationFile", "destinationDirectory", "DestinatorFile", "destinatorfile", "Destinatorfile", "Destinationfile"], "sourceFileChannel": ["sourceFilesChannel", "sourceLibraryChan", " sourceFilesService", "targetFileChan", "sourceDirchannel", "sourceLineSocket", "sourceDirChan", "targetLibrarySocket", "sourceFileSocket", "sourceFileContext", "sourceFileClient", "ourceStreamChannel", "sourceStreamContext", "sourceFunctionConnection", " sourceFilesConnection", "targetLibraryChan", " sourceFileContext", "sourceDirectorySocket", "sourceFunctionService", " sourceFileService", "targetFileClient", "sourceFileConnection", "sourceDirectoryChan", "sourceLibraryChannel", "sourceStreamConnection", " sourceFilesChannel", "sourceLinechannel", "sourceLibraryClient", "sourceFilesContext", "sourceFileStream", "targetLibraryChannel", "sourceStreamStream", "sourceFunctionChannel", "ourceStreamStream", "ourceFileChannel", "sourceLineChannel", "sourceStreamService", "targetFileSocket", "ourceFileChan", "sourceFilesService", "sourceFileChan", "sourceStreamchannel", "sourceStreamChan", "sourceFilesConnection", "targetLibraryClient", "sourceDirectoryClient", "targetFileChannel", "sourceDirStream", "ourceFilechannel", " sourceFilesContext", "sourceLineClient", "ourceStreamChan", "sourceLineChan", "sourceStreamChannel", "sourceLineStream", "sourceFunctionContext", "sourceFilechannel", "sourceDirChannel", "sourceDirectoryChannel", "ourceStreamchannel", "sourceFileService", " sourceFileConnection", "sourceLibrarySocket", "ourceFileStream"], "destinationFileChannel": ["destinationFilesConnection", "destinatorFileConnection", "destinationFilesChannel", "destinationLineHandler", "destinationIOCache", "destinationFilesHandler", "destinationFileService", "destinationDirectoryChannel", "destinationLineChan", "destinationLineClient", "destinationDirectoryClient", "destinationIOClient", "destinationFilesService", "destinatorFileCache", "destinationDirectoryChan", "destinatorFileHandler", "destinatorFilesHandler", "destinationDirectoryConnection", "destinationFilesChan", "destinatorFilesChan", "destinationFileClient", "destinationLineConnection", "destinationIOChannel", "destinationFilesCache", "destinatorFileChan", "destinationDirectoryHandler", "destinationLineChannel", "destinationDirectoryService", "destinatorFileClient", "destinatorFilesConnection", "destinationIOService", "destinatorFilesService", "destinationLineService", "destinationFileConnection", "destinatorFileService", "destinatorFilesChannel", "destinationFileChan", "destinationFileCache", "destinatorFileChannel", "destinationFileHandler", "destinatorFilesCache", "destinationFilesClient", "destinationDirectoryCache", "destinatorFilesClient"]}}
{"id1": "22801734", "id2": "4016687", "code1": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        String sFTP = \"ftp.miservidor.com\";\n        String sUser = \"usuario\";\n        String sPassword = \"password\";\n        try {\n            System.out.println(\"Conectandose a \" + sFTP);\n            client.connect(sFTP);\n            boolean login = client.login(sUser, sPassword);\n            if (login) {\n                System.out.println(\"Login correcto\");\n                boolean logout = client.logout();\n                if (logout) {\n                    System.out.println(\"Logout del servidor FTP\");\n                }\n            } else {\n                System.out.println(\"Error en el login.\");\n            }\n            System.out.println(\"Desconectando.\");\n            client.disconnect();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"setup": ["test", "clean", "prep", "parse", "load", "Setup", "software", "boot", "strap", "set", "upload", "build", "construct", "info", "handler", "config", "install", "ize", "copy", " Setup", "up", "process", "init", "download", "figure", "exit", "run"], "path": ["address", "url", "base", "PATH", "cache", "alias", "platform", "zip", "folder", "host", "filename", "location", "string", "name", "context", "pointer", "Path", "archive", "pattern", "image", "prefix", "code", "format", "root", "route", "directory", "dest", "loc", "loader", "uri", "ath", "resource", "content", "source", "data", "file", "dir", "home", "temp"], "jarFile": ["jaDir", "jafile", "zipF", " jarF", "jaPlace", "jaFile", "JarDir", "rarBody", "zipPath", "zipfile", "zipDir", "jarF", "jarPath", "zipLibrary", "jarBody", "JarLibrary", "rarFile", "javaPlace", " jarBody", " jarPath", " jarLibrary", "jarDir", " jarfile", "JarFile", "jarLibrary", "zipFile", "JarF", " jarDir", "javafile", "javaFile", "Jarfile", "javaDir", "rarfile", "jarfile", "zipBody", "rarPath", "jarPlace", " jarPlace"], "f": ["v", "fp", "cf", "base", "url", "cache", "w", "e", "feed", "io", "folder", "x", "df", "tf", "fb", "rf", "flat", "fm", "s", "c", "fe", "files", "fa", "m", "t", "i", "r", "g", "b", "o", "F", "fc", "fr", "fs", "p", "h", "fd", "fi", "af", "l", "lf", "file", "dir", "fw", "d", "bf", "framework", "full", "sf"], "parent": ["test", "url", "base", "ip", "pa", "paren", "cache", "port", "child", "folder", "function", "host", "target", "location", "parents", "name", "offset", "to", "image", "prefix", "type", "root", "directory", "loc", "css", "resource", "p", "point", "line", "source", "pool", "file", "dir", "and", "Parent", "home", "part", "ctx", "fat", "cmp", "acl"], "buf": ["Buffer", "uf", "bc", "cap", "v", "header", "img", "exc", "bb", "gb", "ob", "bin", "tmp", "br", "cv", "bd", "bp", "func", "fb", "seq", "queue", "len", "bag", "batch", "lb", "Buff", "b", "config", "loc", "pad", "padding", "wb", "buffer", "ab", "la", "bytes", "rb", "fd", "data", "pool", "bh", "src", "bf", "lim", "abc", "cb", "buff", "bu"], "zipinputstream": ["zipimportsource", "zipinfcontrol", "zinputthread", "archiveInputstream", "zipInputstream", "archiveinputsample", "zipviewchannel", "fileoutputsource", "fileInputproblem", "zinputchannel", "fileoutputStream", "fileinputsteam", "zipviewstream", "zipinputthread", "zipinputchannel", "forceinputStream", "zipoutputsource", "zipoutputstream", "zipInputsource", "zipInputchannel", "zipoutputchannel", "zipentryStream", "fileoutputsteam", "zInputcontrol", "zipimportStream", "zipstreamStream", "zipoutputproblem", "archiveInputStream", "zipstreamsteam", "zipoutputsample", "zipinputsource", "zInputStream", "zipoutputsteam", "zipinputStream", "forceinputstream", "forceentryStream", "archiveinputstream", "zipinputsample", "zInputchannel", "zipinfStream", "zipimportstream", "zipbitStream", "zInputstream", "zipentrysteam", "zipInputproblem", "fileinputsource", "forceentrystream", "archiveinputStream", "zipbatchproblem", "fileinputproblem", "zipInputsteam", "forceinputsteam", "zipinputsteam", "zinputStream", "zipInputsample", "zipentrystream", "zipviewStream", "zinputcontrol", "zipbitthread", "zipoutputcontrol", "zipimportsample", "fileinputstream", "zipInputStream", "archiveInputsample", "zipinfstream", "zipoutputthread", "zipstreamstream", "forceentrysteam", "zInputthread", "fileinputStream", "zipoutputStream", "zipinputcontrol", "fileInputStream", "zipbatchStream", "zipinputproblem", "zipbitstream", "zipInputthread", "zinputstream", "zipbatchstream", "zipInputcontrol", "fileInputstream"], "zipentry": ["lockelement", "zipenter", "seaEntry", "zipelement", "Zipconnection", "Zipentry", "zipconnection", " zipconnection", "filearchive", "Zipenter", "ziparchive", "feedentry", "ceentry", "seaelement", "zoneentry", " zipEntry", "ceenter", "zoneapi", " ziparchive", "zarchive", "zEntry", "zipreader", "zipEntry", "zipapi", "cereader", "feedconnection", " zipenter", "ceEntry", "seaentry", "zipinner", "seaenter", "fileentry", " zipinner", " zipapi", "Ziparchive", "lockEntry", "installelement", "ZipEntry", "lockentry", " zipelement", "installinner", "Zipreader", "zoneEntry", "Zipapi", "installentry", "Zipelement", "feedEntry", "feedarchive", "fileelement", "zonereader", "lockenter", "zentry", "fileEntry", "zreader", "Zipinner", "installEntry", " zipreader"], "entryName": ["nextname", "fieldPart", "fieldname", " entryType", "imageEl", " entryPath", "EntryType", "nextPath", "imagename", "Entryname", "resourcePart", "nextEl", "fieldPath", "entryPath", "resourceType", "EntryPart", " entryname", " entryPart", "imageName", "entryPart", "entryEl", " entryEl", "nextName", "imagePath", "entryname", "fieldName", "EntryEl", "EntryPath", "resourceName", "EntryName", "resourceEl", "entryType"], "n": ["an", "v", "z", "k", "ng", "w", "N", "left", "e", "un", "nb", "x", "nl", "nr", "ns", "name", "s", "nor", "u", "ln", "c", "no", "len", "nn", "y", "m", "all", "t", "en", "j", "i", "r", "g", "b", "number", "nu", "o", "nt", "ner", "sn", "p", "h", "dn", "l", "na", "in", "pos", "num", "d", "ne", "nc"], "fileoutputstream": ["fileoutputtrack", "fileoutputuser", "filetextform", "filedownloaduser", "fileOutputtrack", "fileinformationview", "resourceoutputview", "zipOutputStream", "zipinputpool", "fileinputstream", "zipOutputtrack", "resourceoutputstream", "filetextStream", "fileinputfile", "fileinputmess", "fileconnectionStream", "zipOutputmess", "filetextpool", "fileconnectionuser", "fileinformationStream", "fileoutputform", "fileupdatestream", "fileoutStream", "fileOutputmess", "resourceOutputstream", "fileOutputuser", "fileoutputStream", "resourceOutputStream", "zipoutputtrack", "fileoutform", "fileoutstream", "resourceOutputfile", "fileinputpool", "zipOutputstream", "filetextstream", "fileoutputfile", "fileinformationfile", "fileupdatemess", "filedownloadstream", "fileinputStream", "zipoutputStream", "fileinputform", "zipoutputmess", "fileOutputstream", "fileOutputStream", "fileoutputpool", "filedownloadtrack", "fileconnectionstream", "fileinputview", "zipinputStream", "filedownloadStream", "fileoutpool", "fileoutputmess", "zipinputform", "fileOutputview", "resourceoutputStream", "fileinformationstream", "fileupdateStream", "zipoutputuser", "fileOutputfile", "resourceoutputfile", "fileconnectiontrack", "zipoutputstream", "zipOutputuser", "fileoutputview", "zipoutputpool", "resourceOutputview", "zipoutputform"], "newFile": ["newDir", "largeLine", "nextEntry", "oldLine", "updateDir", " newPlace", "baseFolder", " newEntry", "basefile", " newFolder", "newLine", "NewPlace", "newChild", "nextfile", "updateLine", " newDir", "NewDir", "newEntry", "updatePlace", "NewFile", "updateFile", "largeFolder", " newfile", "nextFolder", " newChild", "oldFolder", "largeFile", "baseFile", "oldFile", "oldChild", "newfile", "newPlace", "newFolder", "nextFile", "largeChild", "baseEntry", "NewLine", " newLine"], "arch": ["ure", "url", "error", "ver", "art", "app", "id", "platform", "dict", "ar", "ace", "model", "family", "ress", "boot", "itect", "host", "patch", "ext", "archive", "hard", "Arch", "code", "auth", "build", "chart", "archs", "type", "release", "arc", "aug", "library", "cast", "arm", "tag", "back", "anc", "oct", "install", "inst", "ARCH", "var", "array", "version", "mount", "mac", " architecture", "rc", "work", "addr", "ch", "act", "urn", "ror", "brand", "ith", "cat", "ask"], "key": ["pair", "k", "base", "client", "prop", "str", "id", "nice", "country", "x", "val", "KEY", "name", "string", "word", "section", "link", "character", "lease", "type", "ie", "connection", "rule", "Property", "option", "attribute", "service", "search", "Key", "col", "data", "char", "entry", "letter", "style", "secret", "keys", "field", "variable", "value", "part", "item"], "property": ["feature", "address", "position", "description", "prop", "model", "term", "function", "filename", "string", "language", "profile", "name", "section", "lock", "prefix", "argument", "character", "expression", "properties", "operation", "lease", "type", "username", "info", "ie", "class", "number", "object", "Property", "integer", "option", "attribute", "resource", "p", "service", "translation", "data", "style", "variable", "contract", "field", "value", "unit", "part", "item", "module"], "x64": [" x68", "xp68", "rx32", "xx224", "rx224", "ux59", "x58", "x224", "rx64", "xx48", "rx48", "rex64", "xx64", "rex32", "x48", "ex32", " x59", "ux58", "x59", "x32", "wx64", " x32", "xp58", "xp32", "rex68", " x58", "ex224", "wx59", "x68", "ex48", "xx32", "wx58", "xp64", "ux64", "rex58", "ex64"]}}
{"id1": "10218878", "id2": "23510383", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 1, "substitutes": {"DecodeMapFile": ["DecodeDatafile", "DecodeFilefile", "DecoderFileFiles", "DecodeDataFile", "DecodemapFiles", "DecodemapFile", "DecodeMapfile", "Decodemapfile", "DecodeFileFiles", "DecoderMapFiles", "DecodeDataFiles", "DecoderMapFile", "DecoderFileFile", "DecodeMapFiles", "DecodeFileFile", "DecoderFilefile", "DecoderMapfile"], "mapFile": ["addressFile", "MapUrl", "batchFile", "batchUrl", "loadFull", "addressFull", "mapFull", "apperUrl", "MapFile", "addressfile", "mapfile", "addressTable", "mapLog", "mapUrl", "mapTable", "batchLog", "apperFile", "fileTable", "loadTable", "filefile", "fileFull", "loadFile", "MapLog", "loadfile", "apperLog", "fileFile"], "outputFile": ["responsefile", "OutputFile", " outputDir", "outputDir", "outputStream", "outputFolder", "inputDir", " outputStream", "inputFile", "OutputFolder", " outputfile", "responseFiles", " outputFiles", "OutputStream", "OutputDir", "OutputFiles", "inputFiles", "responseStream", " outputFolder", "outputFiles", "outputfile", "responseFile", "Outputfile", "inputFolder"], "magicKey": ["magicSecret", "magicLink", " magicLetter", "Magickey", " magicKEY", "MagicK", " magicChar", "magickey", "magicKEY", " magickey", "MagicKey", "cacheChar", "specialKey", "techKey", " specialKey", " specialK", " specialLetter", "specialChar", "cacheSecret", "cachekey", "specialSecret", "prefixKey", "prefixKEY", "magicChar", "techKEY", " specialkey", "cacheKey", " magicLink", "specialkey", "prefixLink", "MagicLetter", " magicK", "magicK", " magicSecret", "techLink", "techkey", "magicLetter", "prefixkey"], "buffer": ["Buffer", "address", "position", "result", "url", "base", "header", "uffer", "reader", "token", "cache", "bb", "transfer", "FFER", "feed", "pause", "row", "input", "length", "seed", "binary", "offset", "memory", "queue", "code", "read", "layer", "writer", "reference", "batch", "count", "b", "shape", "buf", "bar", "null", "slice", "pad", "array", "iter", "message", "wave", "document", "stack", "data", "source", "variable", "comment", "buff"], "nread": ["enread", "pRead", " nreads", "nfind", "nwrite", "pwrite", "Nload", "Nfind", " nRead", "nRead", "Nreads", "NRead", "neread", "enfind", "enwrite", "enRead", "Nreader", "pload", "nload", "nreader", "neRead", " nfind", "Nwrite", "Nread", "nereader", "newrite", "enreads", " nload", "nreads", " nreader", " nwrite", "pread"], "map": ["flow", "cm", "address", "pair", "master", "header", "client", "cache", "parse", "ap", "app", "use", "pre", "transfer", "cover", "one", "make", "index", "input", "maps", "out", "core", "apper", "bridge", "stream", "image", "lock", "write", "code", "m", "layer", "over", "config", "per", "block", "list", "pad", "pack", "media", "resource", "message", "wave", "MAP", "key", "copy", "data", "work", "file", "pool", "source", "create", "group", "open", "module"], "output": ["external", "address", "oper", "flow", "error", "console", "cache", "exit", "ou", "put", "sort", "model", "log", "function", "pot", "Output", "export", "target", "input", "out", "core", "ilo", "queue", "image", "write", "run", "operation", "layer", "global", "reference", "connection", "application", "number", "object", "o", "config", "outer", "update", "office", "resource", "document", "other", "page", "data", "file", "utils", "unit", "web", "control", "response", "cut", "module"], "i": ["qi", "v", "z", "ip", "ai", "ti", "I", "uli", "e", "id", "io", "xi", "x", "ini", "length", "u", "li", "ui", "multi", "ci", "c", "si", "phi", "ii", "m", "j", "t", "a", "info", "b", "o", "bi", "slice", "zi", "ri", "uri", "p", "it", "gi", "di", "oi", "in", "l", "ji", "mu", "f", "pi"]}}
{"id1": "397240", "id2": "9257487", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static boolean downloadFile(String from, String to, ProgressMonitor pm) {\n        try {\n            FileOutputStream out = new FileOutputStream(to);\n            URL url = new URL(from);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int read = 0;\n            while ((read = in.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n                if (pm != null) pm.addToProgress(read);\n            }\n            out.close();\n            in.close();\n        } catch (Exception e) {\n            Installer.getInstance().getLogger().log(StringUtils.getStackTrace(e));\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndRewwrite", "readandRewrite", "readandrewrites", "readAndSwrites", "readAndrewrite", "readAndRebrite", "readandRewwrite", "readAndrewwrite", "readAndRebrites", "readandrewwrite", "readandrewrap", "readAndSwwrite", "readandRewrap", "readandRewrites", "readAndrewrap", "readAndRewrites", "readAndrewrites", "readAndRebrap", "readAndRewrap", "readAndSwrap", "readandrewrite", "readAndSwrite", "readAndRebwrite"], "inFile": ["oldFilename", "InFiles", "Infile", "oldFiles", "loginFilename", "inputFile", "InFile", "InSourceFile", "loginFile", "infile", "oldfile", "inputFiles", "oldFile", " infile", "inputFilename", " inFilename", "loginfile", "outfile", "loginFiles", "inFilename", " inSourceFile", "outSourceFile", "inFiles", "outFiles", "outFilename", "inSourceFile", " inFiles", "inputfile"], "outFile": ["newDir", "thisfile", "outDir", "processPlace", "OutStream", "thisFILE", "OutDir", "outFILE", "newFile", "offFile", "offFILE", "thisFilename", "outputFILE", "outStream", "outputFilename", "offFilename", " outfile", "exfile", "offPlace", "processFILE", "outputPlace", "thisFile", "processFilename", " outStream", " outDir", "outputfile", "newfile", "newStream", "exFilename", "outfile", "exFILE", "outPlace", "OutFile", "processFile", "exFile", "Outfile", "outFilename", "outputFile"], "iis": ["Iis", "iiris", " iiss", "iiIs", "ciIs", "ciIS", "ciis", "Iiss", "Iais", "iniiss", "iniIs", "iiss", "iniris", "ciais", "iiiss", " iIS", "iniIS", " iais", "iIS", " iIs", "iiIS", "iIs", " iris", "iris", "ciiss", "iniis", "iiis", "IIS", "ciris", "iais"], "dcmParser": [" dcrPlugin", "dmParser", " dcmHelper", " dcmarser", "fcmHandler", "dpmPlugin", "dcrPar", "fpmParser", "dCMReader", "dcmLoader", " dcmPlugin", "dpmLanguage", "dkmParser", "fpmparser", "dcmHelper", " dpmLanguage", "dmcParser", "dbmPolicy", "dcrReader", "dmcPar", " dpmParser", "dmissionReader", "dCMHandler", " dcmparser", "dmissionPlugin", "dmPlugin", "dmmparser", "dCMParser", "dpmHandler", "dbmHelper", "dpmReader", "dpmInstallation", " dcrLoader", "dbmPlugin", " dpmarser", "dmmLoader", "dhemJar", "dmoduleparser", "DcmReader", " dcrParser", " dpmJar", "dcmPolicy", "DcmInstallation", "dhemInstallation", "dmcJar", " dpmPolicy", "dpmparser", " dpmHelper", "dmissionLanguage", "dcmPar", " dpmparser", "dcmReader", "dpmPar", "fpmHandler", "dmodulePlugin", "dkmPlugin", "dbmParser", "dcmparser", " dcmPar", "dkmPolicy", "dmoduleParser", "dcrPlugin", "fcmParser", "dCMPlugin", "dmoduleJar", "dmcarser", "dcmPlugin", "dmoduleReader", " dcmPolicy", "DcmJar", "dcrParser", " dpmPlugin", "dCMLoader", " dcrReader", "DcmParser", " dcmLanguage", "dpmJar", "dmissionParser", "dhemParser", "dcmarser", " dcmJar", "dcmInstallation", "dpmParser", "dCMparser", "dmmPlugin", "dcrLoader", "dcrarser", "fpmReader", " dpmPar", "dcrJar", "dpmLoader", " dpmLoader", "dmLoader", "dmmParser", " dpmReader", "dcmJar", "fcmReader", "dhemReader", "dkmHelper", "fcmparser", "dpmarser", "dpmHelper", "dpmPolicy", " dcmLoader", "dcmHandler", "dcmLanguage", "dmReader", " dcmReader"], "ds": ["sys", "services", "da", "Os", "ins", "Ds", "ays", "eps", "xs", "ts", "ils", "db", "vs", "tx", "ws", "nas", "ads", "df", "session", "ns", "ks", "asi", "ls", "s", "conn", "iss", "os", "dd", "Db", "gd", "des", "ys", "dat", "js", "cs", "vals", "drivers", "cdn", "ps", "sync", "pd", "dc", "parts", "uds", "ants", "dt", "dr", "di", "dds", "data", "is", "ld", "qs", "amps", "DS", "d", "src", "icks", "details", "utils", "points", "ss", "bs", "ros", "tes", "rs", "gs", "ras"], "pdReader": ["pcRead", "pcLoader", "dsreader", "hdWriter", "xdReader", "xdRead", "hdRunner", "hdStream", "pcWriter", "hdRead", "ddStream", "dsLoader", "pbRunner", "pcReader", "dsReader", "dsRead", "hdreader", "pbLoader", "hdLoader", "ddRunner", "pdLoader", "pbStream", "pdStream", "pdreader", "pdRunner", "dsWriter", "pbReader", "hdReader", "xdreader", "pdRead", "xdWriter", "ddReader", "ddLoader"], "out": ["external", "outs", "cache", "gen", "inc", "model", "session", "conn", "name", "doc", "ssl", "writer", "at", "null", "with", "data", "file", "full", "group", "part", "as", "client", "child", "term", "db", "dot", "s", "ext", "word", "to", "lock", "write", "down", "Out", "user", "object", "o", "her", "key", "store", "page", "in", "cli", "password", "device", "later", "net", "result", "base", "OUT", "w", "login", "io", "auto", "obj", "inner", "err", "lib", "code", "layer", "again", "parent", "over", "oder", "list", "outer", "copy", "director", "temp", "exec", "flow", "sys", "url", "img", "builder", "output", "exp", "default", "image", "order", "connection", "ex", " in", "co", "sync", "diff", "array", "point", "line", "up", "pass", "dev", "manager"], "dcmEncParam": ["dcmElType", "dcmEnParam", "dcmEstType", "dcmEstPar", "dcmDecPart", "dcmDecParameter", "dcmArchParameter", "dcmEnArg", "dcmEncArg", "dcmElPar", "dcmEncParameter", "dcmDecType", "dcmSecType", "dcmEncPart", "dcmDecParam", "dcmEnType", "dcmSecPart", "dcmEncType", "dcmArchParam", "dcmSecPar", "dcmEnPart", "dcmSecParam", "dcmDecArg", "dcmEnPar", "dcmEstParam", "dcmElParameter", "dcmElParam", "dcmEstParameter", "dcmDecPar", "dcmEnParameter", "dcmArchArg", "dcmEncPar"], "pdWriter": ["PDWrite", "dpWrite", "hdWriter", "htReader", "ddWrite", "dpReader", "pdWriting", "dsOutput", "dsReader", "dpWriter", "hdWrite", "PDWriter", "dpWriting", "PDReader", "htWriting", "dsWriter", "hdReader", "htWrite", "htWriter", "PDWriting", "ddWriter", "ddOutput", "hdOutput", "pdOutput", "dsWrite", "ddReader", "pdWrite"]}}
{"id1": "8000624", "id2": "18570190", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"CopyTo": [" copyTo", "CopyFrom", "copyTo", " copyto", " transferTo", "CopyFile", " copyFile", "copyFrom", "copyFile", " transferFile", "Copyto", " copyFrom", " transferFrom", "copyto", " transferto"], "dest": ["rest", "test", "cont", "img", "sup", "w", "delete", "output", "bin", "tmp", "exit", "comb", "path", "folder", "target", "filename", "flat", "name", "obj", "write", "them", "Dest", "class", "transform", "orig", "object", "desc", "wb", "table", "done", "content", "source", "data", "file", "destroy", "dist", " destination", "src", "die", "later", "opt", "txt", " Dest", "temp"], "in": ["gin", "ins", "thin", "reader", "din", "IN", "re", "login", "bin", "id", "isin", "inc", "vin", "x", "ini", "input", "issue", "In", "s", "conn", "inner", "ln", "image", "fa", "ax", "lib", "m", "i", "r", "connection", "b", "n", "again", "sin", "pull", "nin", "win", "inn", "wave", "pin", "plus", "h", "l", "lin", "source", "cin", "up", "init", "inside", "kin", "rin", "pass", "con", "ac", "as", "f"], "out": ["net", "exec", "external", "url", "OUT", "client", "outs", "cache", "w", "call", "output", "bin", "app", "ou", "io", "inc", "not", "one", "x", "outside", "target", "conn", "name", "ext", "inner", "image", "err", "no", "off", "this", "Out", "lib", "or", "writer", "i", "user", "b", "ex", "n", "again", "object", "o", "socket", "sync", "nin", "outer", "timeout", "plus", "pin", "copy", "other", "data", "vert", "up", "file", "our", "part", "temp"], "c": ["v", "cm", "cl", "lc", "cf", "bc", "cy", "exc", "uc", "ca", "e", "C", "x", "ic", "pointer", "oc", "cr", "u", "ci", "cc", "code", "m", "ct", "ec", "t", "i", "r", "arc", "cu", "ce", "n", "xc", "esc", "o", "config", "fc", "enc", "buffer", "dc", "p", "content", "rc", "col", "l", "char", "ch", "sc", "d", "pc", "ac", "abc", "comment", "cb", "f"]}}
{"id1": "16550855", "id2": "812803", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"readPage": ["getFile", "openFile", "findPages", "getPages", "openPage", "openPages", "findpage", "readPages", "readFile", "findFile", "readpage", "getpage", "findPage", "openpage", "getPage"], "ignoreComments": ["includeComments", "ignoreTags", " ignorecomments", "usecomments", "oreComment", "includeTags", "oreQuotes", "ignoreQuotes", "includeComment", "ignoreComment", "useTags", "orecomments", "oreTags", " ignoreComment", "useComments", " ignoreTags", "includecomments", "useQuotes", "oreComments", " ignoreQuotes", "ignorecomments"], "in": ["url", "gin", "ins", "reader", "din", "IN", "token", "client", "re", "login", "bin", "e", "id", "isin", "inc", "ini", "index", "input", "out", "In", "s", "on", "inner", "stream", "image", "c", "err", "m", "t", "ssl", "i", "r", "connection", "user", "b", "again", "rec", "socket", "loader", "nin", "win", "buffer", "inn", "version", "min", "it", "h", "http", "into", "is", "data", "source", "lin", "file", "init", "kin", "inside", "con", "as", "f"], "inputLine": [" inputText", "ifline", "requestLine", " inputCo", " inputRow", "requestline", "pullLine", "requestCo", "InputLook", "ifLook", " inputName", "InputText", "InputL", "rawLine", "installline", "incL", "ifCo", "InputCell", " inputPage", "commentCell", "inputRow", "incline", "imageline", "requestRow", "inputPage", " inputCell", "inputL", "commentLine", "inputLink", "commentPage", "pullLink", "imageLook", "rawline", "inputName", " inputLink", "Inputline", "inputCell", "commentline", "InputName", "rawL", "installLine", "inputline", "rawText", "requestLook", "installL", "imageLine", "ifLine", "requestLink", " inputL", "InputLine", "rawLink", "InputLink", " inputline", "incLook", "inputText", "incLine", "inputLook", "inputCo", "pullline", "InputPage", "pullRow", "installLook", " inputLook", "imageL", "rawName"], "html": ["template", "strong", "url", "result", "base", "header", "img", "wrap", "amp", "title", "flash", "str", "output", "war", "view", "tt", "high", "htm", "xml", "tml", "tf", "gh", "flat", "ui", "bsp", "hard", "doc", "link", "plain", "format", "live", "show", "js", "text", "body", "attr", "www", "css", "embed", "message", "api", "detail", "content", "h", "links", "http", "page", "data", "article", "source", "inline", "hot", "HTML", "summary", "bf", "dump", "ht", "json", "details", "home", "part", "atom", "web", "rss", "blog", "f", "msg", "temp"]}}
{"id1": "12146394", "id2": "13946197", "code1": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "code2": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "label": 1, "substitutes": {"md5Crypt": ["md5crypt", "md6crypt", "md2Key", "MD5Hash", "MD5Key", "md4Crypt", "md5Hash", "MD2crypt", "md6Hash", "md2Crypt", "md4Key", "MD2Hash", "md4Hash", "md2Hash", "MD5Crypt", "md4crypt", "md6Crypt", "MD5crypt", "md6Key", "md2crypt", "MD2Crypt", "md5Key", "MD2Key"], "key": ["air", "hash", "pair", "cy", "cache", "blow", "id", "row", "core", "seed", "name", "length", "ssl", "empty", "message", "date", "fee", "cookie", "data", "server", "value", "full", "size", "token", "magic", "my", "transfer", "use", "x", "KEY", "input", "string", "state", "word", "lock", "cer", "user", "number", "rule", "char", "password", "proof", "carry", "kid", "k", "base", "call", "scope", "zip", "ace", "cert", "money", "kh", "no", "code", "y", "m", "go", "parent", "list", "copy", "source", "shift", "ke", "secret", "ask", "temp", "here", "wire", "ip", "sign", "none", "kw", "time", "ee", "image", "order", "this", "self", "year", "type", "element", "connection", "root", "text", "any", "trust", "sync", "service", "version", "point", "Key", "phrase", "other", "power", "ch", "req", "ce", "material"], "salt": ["seskey", "southart", "sol", "SALT", "Sodium", "skey", "sesort", "svalt", "sesul", "sval", "asalt", "southodium", "southift", "sesart", " sol", " sALT", "ssol", "svALT", "sort", "sodium", "osift", " sart", "ssalt", "ssALT", "sesol", "ssass", "sul", "southalt", "svort", "sass", "ssecret", "osALT", "Ssecret", "assecret", "southALT", "sesal", "asALT", " skey", "osul", "asal", "Sal", "sesass", " sass", "osalt", "sALT", "sart", "sift", "Salt", "sesift", "southsecret", " sift", " ssecret", " sodium", "sal", "sesalt", "sesALT", "sessecret"], "_md": ["_mand", " _amd", "_mg", "\u00a0dm", "copykey", "_m", " _m", "\u00a0mode", " _cmd", "localcmd", " _key", "_dm", "__cmd", "Newdm", "copycmd", " _db", "copymd", "_MD", "\u00a0md", "\u00a0mand", " _dm", "localmg", "\u00a0nm", "Newcmd", "Newamd", "\u00a0m", "__md", "_amd", "copydm", " _nm", "__amd", "localmd", "_db", "__dm", "\u00a0cmd", "_nm", " _MD", "_mode", "_mb", "_key", "_cmd", "Newmd", "localmb"], "md2": ["md5", "md02", "hdTwo", " md62", "MD3", " md5", " mdTwo", " md32", "amd02", "amd4", "md32", "amd32", "cmd1", "cmd4", "MD62", "MD4", "MD2", "md62", "amd62", "cmd2", " md1", "amdTwo", "hd62", "cmd62", "MD1", "mdTwo", "cmd5", "hd2", "md1", "amd2", " md02", "hd32", " md4", "md4", "MD5", "cmd3", "cmd02"], "abyFinal": ["babyfinal", "BabyFinish", "aberFinal", "butFinal", "abyLast", "babyLast", "BabyFull", "abyfinal", "babyResult", "babyTotal", "BabyLast", "amySpecial", "sayFinal", "amySuccess", "abySpecial", "abiesResult", "abyInitial", "rayFinal", "babyFinal", "aberInitial", "abeFinal", "andyfinal", "andyLast", "abiesSuccess", "abyTotal", "butLast", "aberTotal", "abeFull", "sayInitial", "amyFinal", "andyFinal", "abeFinish", "abyFull", "babyInitial", "abySuccess", "abiesFinal", "andyInitial", "abiesFinish", "abeLast", "babySuccess", "babySpecial", "rayInitial", "abyResult", "abyFinish", "rayLast", "BabyFinal", "amyResult", "amyInitial", "abiesFull", "butInitial", "aberfinal", "abiesLast", "Babyfinal", "saySpecial", "andyTotal"], "n": ["net", "v", "z", "k", "syn", "yn", "ng", "N", "br", "un", "nan", "nb", "not", "none", "x", "node", "ns", "conn", "name", "nor", "on", "byn", "c", "no", "len", "nn", "pn", "adj", "np", "y", "m", "all", "t", "en", "a", "r", "g", "b", "nu", "span", "number", "o", "nt", "nw", "ner", "sn", "gn", "inn", "p", "min", "dn", "mn", "non", "l", "na", "cn", "fn", "don", "ni", "num", "d", "ne", "ny", "nc", "network", "f"], "j": ["qi", "jp", "J", "z", "k", "bj", "v", "uj", "ja", "I", "io", "jc", "xi", "x", "index", "q", "ind", "u", "li", "section", "c", "ci", "si", "ij", "adj", "aj", "y", "ii", "ie", "b", "js", "o", "dj", "fr", "p", "l", "jl", "di", "ni", "d", "num", "yi", "ne", "ji", "jj"], "i": ["qi", "ai", "ani", "ti", "mini", "I", "e", "io", "iu", "xi", "ini", "index", "eni", "ui", "li", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "ie", "ali", "o", "ki", "zi", "ri", "p", "gi", "fi", "di", "oi", "ni", "yi", "chi", "ji", "gu", "mu", "bi", "pi"], "sbPasswd": ["sbSecretwd", "cbParw", "sbFailwd", "sfPasswd", "sbCrw", "sbPassWD", "bbParwd", "cbParwd", "sfSecretword", "sfPassword", "sbParword", "sbSecretword", "sbFailw", "sfSecretwd", "bbParw", "cbPassphrase", "sbParw", "sbPassw", "sbCrwords", "bbPassw", "cbParword", "sbFailword", "rbCrword", "rbPasswd", "sbCrWD", "rbPassword", "rbPassWD", "rbCrw", "bbParword", "rbCrwd", "sbPassword", "rbCrWD", "bbPasswd", "sbCrrc", "sbSecretw", "sbPassphrase", "sfSecretwords", "sbParwd", "sbCrwd", "sbPassrc", "cbPassword", "bbParrc", "bbPassword", "rbPassw", "cbParphrase", "sbParrc", "sbFailphrase", "sfPasswords", "sbParWD", "bbPassrc", "sfSecretw", "sfPassw", "sbParwords", "sbCrword", "sbSecretwords", "cbPassw", "sbParphrase", "sbPasswords", "cbPasswd"], "md3": ["amd15", "ms03", "mag23", "amd23", "mag512", "MD3", " md53", "mag15", "amd512", "cmd1", " md23", "amdthird", " md03", "md512", "mdthree", "ms3", "mand23", "MD53", "MD2", "mand512", "cmd2", " md1", "md23", "mand15", "msthree", "MD1", "md1", "cmd23", "md03", "amd03", "md15", "md53", "MD23", "mag3", "mand3", "msthird", " mdthree", "amdthree", "mdthird", "amd3", "cmd53", "cmd3", " mdthird"]}}
{"id1": "9647576", "id2": "21489105", "code1": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 0, "substitutes": {"Reserve": ["Rolve", "Resolve", " Resolve", "Rerve", "Send", "Rend", "Resend", "Rerves", "Serve", "Reserves", " Resend", "Serves", "Solve", " Reserves"], "stbookings": ["stbookies", "ssbooksings", "stbooksifications", "ssbookalls", "stbooksalls", "ssbookifications", "ssbooksalls", "stBookifications", "stbookalls", "stBookies", "stbookifications", "ssbooksifications", "stbooksies", "stbooksings", "stauthories", "ssbookies", "stauthorifications", "stauthoralls", "ssbookings", "stBookalls", "stBookings", "stauthorings", "ssbooksies"], "stchartwl": ["STconfigwl", "stplotml", "stchartml", "stplotls", "STchartwl", "stchartowl", "stchartls", "stplotwl", "stconfigls", "st_ls", "st_wl", "STchartls", "stconfigowl", "STconfigowl", "STchartowl", "stplotowl", "st_ml", "stconfigml", "stconfigwl", "STconfigls", "STchartml", "st_owl", "STconfigml"], "sp": ["jp", "ip", "arp", "amp", "tp", "sf", "scope", "str", "ap", "bp", "pace", "spr", "xml", "space", "sl", "session", "name", "profile", "bsp", "pl", "si", "yp", "sg", "rap", "ipp", "type", "sk", "Sp", "html", "span", "text", " Sp", "ps", "ig", "inst", "service", "p", " sc", "isp", "page", "source", "op", "sc", "sil", "email", "osp", " esp", "script", "pp", "spe", "SP", "esp", "spl", "ss", "mp", "pr", " SP"], "userbooksql": ["userlocksQL", "userreadskel", " useraveskel", "usersbooksearch", "userbooksil", "otherbookql", "otherbooksqs", "userbooksearch", "usersbookQL", " useraveskl", "userbookQL", "userbooksprintf", "usersbookql", "userbookskel", "userbanksil", "userbookssql", "userbookskl", "userlocksprintf", "userordersqs", "otherbooksql", " userbookskel", "userordersQL", "otherbookssql", "userreadsQL", "userbookql", "usersbookearch", "userreadsil", "userbooksQL", "otherbooksQL", "usersbooksql", "usersbooksprintf", "userreadsql", "useravesql", "userreadsearch", "userpagesQL", "userreadskl", "otherbookQL", " userbookskl", " userbooksil", "userbookearch", "userlocksearch", "userordersql", "usersbookprintf", "userbanksql", "userbankskel", "userreadsprintf", "userpagesqs", " useravesil", "useraveskel", "useraveskl", "userpagesql", "userpagessql", "userlocksql", "userbookprintf", "usersbooksQL", "userorderssql", "userbankskl", "userbooksqs", "useravesil", "userbookqs", " useravesql", "otherbookqs"], "agentbooksql": ["userbooksil", "agentbooksil", "agentstylesql", "agentstylesil", "agentstylesqu", "agentstylessql", "agentbooksci", "userbookssql", "userbooksli", "userpagesli", "agentBookssql", "agentbookQL", "agentpagesci", "agentbooksli", "agentpagesQL", "agentgroupsli", "agentgroupsQL", "agentbooksQL", "agentgroupssql", "agentpluginsci", "userbooksQL", "agentpagesli", "agentpluginsQL", "userpagesQL", "agentBooksqu", "userbooksqu", "agentbooksqu", "agentgroupsql", "agentBooksil", "agentpagesql", "userbooksci", "agentBooksql", "agentpagessql", "agentbookssql", "userpagesql", "userpagessql", "userpagesci", "agentbookli", "agentpluginssql", "agentbookql", "agentpluginsql"], "bookingid": ["bookingurl", "bookingsinfo", "bookillingid", "bookinginfo", "bookINGurl", "bookillingurl", "bookingname", "bookillinginfo", "bookingsname", "booksingsname", "bookINGname", "booksingsid", "booksinginfo", "booksingurl", "bookINGid", "booksingsinfo", "bookillingname", "booksingname", "bookINGinfo", "bookingsurl", "booksingid", "booksingsurl", "bookingsid"], "currentcoach": ["currentlypoach", "currentloache", " currentcoache", " currentcoac", " currentpoach", "currentpoaching", "currentCOach", "currentchoase", "currentloach", "currentgoaching", "currentlycoach", "currentgoac", "currentcoached", "currentnoache", "currentcoaching", "currentlycoache", " currentpoac", "currentnoach", " currentloache", "currentlypoaching", " currentcoase", "currentpoache", "currentboach", "currentcoache", "currentpoached", "currentgoach", "currentpoac", "currentCOase", "currentpoach", "currentgoache", "currentlypoac", "currentcoam", "currentboache", "currentchoach", "currentpoase", "currentloached", "currentpoam", " currentpoase", "currentlycoac", "currentpoah", " currentcoam", " currentloach", "currentcoase", "currentcoah", " currentpoam", "currentboached", "currentlypoache", "currentCOac", "currentnoac", "currentchoam", "currentboah", "currentchoac", " currentloached", "currentloah", " currentcoah", "currentnoaching", "currentcoac", "currentlycoaching", " currentcoached", " currentloah", "currentCOam"], "currentseat": ["currentlyslave", "Currentseason", " currentcourse", "currentticket", "currentslave", "Currentseat", "Currentcourse", "activecourse", " currentslave", " currentsex", "currentlysex", "activeticket", "activecomponent", "Currentsex", "currentlyseason", "currentseason", "Currentslave", "currentlyseat", "Currentticket", "currentsex", "Currentcomponent", "currentcourse", "activeseat", "currentcomponent", " currentcomponent", " currentticket", " currentseason"], "tickpos": ["ickpointer", "hellopointer", "hellopos", " tickPOS", "stickpos", "ickposition", "ickPOS", " tickPos", "ickPos", "ickpo", "trialPos", "tickpose", "helloposition", "crosspos", "trialPOS", "helloPOS", "tickposition", "crossPos", " tickpo", "crosspo", " tickposition", "helloPos", "trialpose", "ickerPos", "ickerpos", "ickpose", "ickerpointer", " tickpose", "tickpointer", "stickPos", "ickerposition", "trialpos", "tickPOS", "ickpos", "stickposition", "tickpo", "tickPos"], "chartavailupdsql": ["chartavailupdatesql", "chartavailumpdssql", "chartavailumpssqs", "chartavailupdssql", "chartavailupcsql", "chartavailupdatesqs", "chartavailupcssql", "chartavailupcsqs", "chartavailumpdsql", "chartavailupssqs", "chartavailupsssql", "chartavailumpssql", "chartavailupdsqs", "chartavailupssql", "chartavailumpdsqs", "chartavailupdatessql", "chartavailumpsssql"]}}
{"id1": "5551393", "id2": "11305840", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "label": 0, "substitutes": {"getMD5": ["getSHA4", " getM512", " getM4", "getMD4", "getSHA256", "getmd5", "getSHA5", "getM256", "getSHA512", "getM5", "getM4", "getmd512", " getMD512", "getmd4", "getMD256", "getM512", " getMD4", " getMD256", "getMD512", " getM5", " getM256", "getmd256"], "source": ["ource", "template", "address", "url", "result", "base", "output", "security", "proxy", "SOURCE", "input", "target", "start", "string", "seed", "name", "length", "secure", "Source", "sm", "code", "info", "text", "object", "dest", "config", "slice", "message", "buffer", "service", "resource", "bytes", "content", "data", "file", "style", "src", "unit", "size", "expected", "temp"], "tmp": ["foo", "emp", "test", "result", "stuff", "fp", "params", "cache", "output", "metadata", "zip", "current", "tt", "vt", "default", "py", "meta", "obj", "binary", "storage", "code", "sb", "html", "b", "buf", "body", "ignore", "dest", "buffer", "var", "array", "rb", "copy", "data", "vm", "src", "nm", "Temp", "bf", "part", "cpp", "txt", "cb", "mp", "cmp", "temp"], "md": ["mad", "MD", "cm", "mc", "ms", "rm", "pm", "bd", "zip", "amd", "mo", "meta", "mb", "mt", "ind", "oda", "cmd", "hd", "mi", "rpm", "mand", "editor", "m", "dd", "gd", "sd", "od", "mg", "mm", "ma", "ad", "pd", "cd", "mmm", "wd", "nd", "mac", "mn", "mod", "di", "ld", "d", "mag", "nm", "vd", "dm", "bf", "mu", " MD", "mp"]}}
{"id1": "6304373", "id2": "22752444", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrTemplateplates", "uploadOrDeleteMediaOrTemFiles", "uploadOrDeleteMediaOrtempl", "uploadOrDeleteMediaOrtemFiles", "uploadOrDeleteMediaOrTemplatepl", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrTemplateporary", "uploadOrDeleteMediaOrtemporary", "uploadOrDeleteMediaOrtemplates", "uploadOrDeleteMediaOrTemplateFiles", "uploadOrDeleteMediaOrMemplates", "uploadOrDeleteMediaOrMemporary", "uploadOrDeleteMediaOrMemFiles", "uploadOrDeleteMediaOrMempl", "uploadOrDeleteMediaOrTemporary"], "action": ["activation", "flow", "test", "url", "error", "change", "status", "call", "flash", "now", "view", "site", "controller", "ACTION", "environment", "function", "plugin", "name", "state", "effect", "section", "lock", "next", "step", "operation", "format", "event", "type", "ction", "element", "active", "method", "Action", "what", "parent", "actions", "service", "version", "resource", "api", "commit", "act", "style", "activity", "part", "item", "module"], "object": ["address", "url", "objects", "system", "project", "now", "current", "not", "none", "model", "environment", "function", "request", "target", "node", "host", "string", "auto", "obj", "thread", "ject", "image", "lock", "oid", "self", "zone", "event", "element", "mode", "class", "number", "directory", "parent", "o", "edit", "office", "service", "resource", "version", "document", "article", "subject", "letter", "email", "instance", "full", "group", "part", "module"], "numElements": ["numelement", "numeodes", "numElem", " numelem", " numElem", "numelements", "numEodes", " numelements", " numEodes", " numelement", " numeodes", "numGeodes", "numelem", "numEllem", "numEllement", "numEllements", "numGelem", "numElodes", "numGelements", "numGelement"], "req": ["base", "params", "util", "builder", "mr", "use", "load", "verb", "xml", "log", "res", "obj", "err", "next", "r", "report", "g", "html", "parent", "update", "usr", "resp", "ro", "gr", "conf", "ctx", "msg", "module"], "session": ["test", "result", "Session", "client", "system", "cache", "token", "flash", "scope", "local", "site", "use", "ESSION", "security", "container", "request", "ctx", "context", "state", "thread", "image", "lock", "sa", "event", "global", "connection", "browser", "service", "resource", "person", "document", "h", "http", "subject", "shared", "instance", "ession", "sp", "manager", "response", "temp"], "ftp": ["FTP", " ftcp", "FTc", "ftcp", "FTcp", " ftc", "ttp", "ttP", " ftP", "ttc", "ftP", "ttcp", "ftc", "FTp"], "user": ["hash", "url", "result", "base", "error", "account", "ver", "system", "client", "project", "view", "e", "use", "comment", "current", "db", "path", "log", "User", "creator", "users", "er", "name", "string", "profile", "ee", "state", "bug", "lock", "image", "this", "facebook", "self", "auth", "username", "custom", "type", "info", "used", "connection", "class", "browser", "html", "rule", "parent", "config", "per", "usa", "post", "mail", "person", "admin", "by", "other", "page", "data", "usr", "USER", "match", "member", "shared", "pass", "full", "group", "home", "record", "author", "module"], "links": ["url", "posts", "base", "groups", "flash", "linked", "ids", "members", "log", "styles", "lines", "image", "link", "results", "items", "menu", "mails", "html", "images", "headers", "Link", "actions", "tree", "pages", "email", "Links", "details", "mail"], "folders": ["filages", "handries", "filors", "filers", "anchries", "handors", "anchors", "foldages", "handers", "anchages", "anchers", "handages", "foldries", "foldors", "filries"], "folder": ["picture", "two", "address", "url", "level", "project", "enter", "scope", "sample", "region", "id", "zip", "volume", "command", "path", "plugin", "flat", "filename", "location", "archive", "upload", "database", "editor", "zone", "layer", "fold", "element", "menu", "connection", "directory", "ignore", "slice", "layout", "future", "division", "uri", "license", "resource", "Folder", "document", "source", "dir", "email", "append", "device", "letter", "network", "area", "home", "theme"], "server": ["ser", "slave", "address", "url", "master", "client", "account", "reader", "system", "token", "status", "enter", "site", "port", "Server", "engine", "remote", "host", "filename", "location", "string", "seed", "node", "inner", "database", "username", "ssl", "type", "connection", "directory", "socket", "outer", "uri", "service", "resource", "version", "erver", "scale", "page", "peer", "source", "email", "device", "value", "network", "localhost", "manager"], "login": ["picture", "url", "sudo", "account", "status", "site", "Login", "skin", "shell", "path", "log", "plugin", "users", "filename", "machine", "name", "string", "profile", "bridge", "lock", "database", "blank", "auth", "journal", "username", "ssl", "info", "connection", "config", "layout", "socket", "service", "resource", "access", "pin", "cookie", "consumer", "email", "secret", "pass", "network", "group", "label", "blog", "mail", "basic"], "password": ["picture", "slave", "sudo", "account", "column", "token", "Password", "alias", "sword", "security", "volume", "worker", "plugin", "mask", "filename", "pattern", "name", "language", "profile", "string", "word", "database", "auth", "username", "connection", "directory", "ass", "padding", "strip", "division", "timeout", " passwords", "access", "phrase", "cookie", "PASS", "secret", "email", "device", "pass", "photo", "manager", "basic"], "fileTransferFolder": ["fileTransferServer", "fileImportServer", "mediaUploadFolder", "fileTransferPath", "mediaUploadDirectory", "FileUploadFolder", "mediaTransferfolder", "mediaTransferServer", "fileImportFolder", "fileUploadfolder", "mediaTransferFolder", "fileTransferTheme", "fileTransferfolder", "fileAccessfolder", "mediaTransferDirectory", "fileUploadFolder", "FileUploadfolder", "FileTransferFolder", "fileAccessPath", "fileTransferDirectory", "FileTransferPath", "fileAccessFolder", "mediaUploadfolder", "FileTransferTheme", "fileTransformPath", "fileUploadPath", "fileAccessTheme", "fileImportfolder", "FileUploadPath", "fileImportDirectory", "mediaUploadServer", "fileUploadServer", "FileUploadTheme", "fileTransformTheme", "fileUploadTheme", "fileUploadDirectory", "fileTransformfolder", "fileTransformFolder", "FileTransferfolder"], "liveFolder": ["livefolder", "liveDirectory", "LiveLocation", "LiveFolder", "PreviewDirectory", "liveLocation", "LiveDirectory", " livefolder", " liveDirectory", "Livefolder", " liveLocation", "Previewfolder", "PreviewLocation", "PreviewFolder"], "servers": ["servvers", "serations", " serServer", "servls", "Servers", "servations", "servServer", "serls", " serations", "serServer", "Serations", "Serls", "SerServer", " serls"], "message": ["address", "url", "header", "Message", " messages", "error", "mess", "description", "status", "flash", "path", "request", "log", "string", "response", "image", "element", "menu", "application", "body", "update", "buffer", "array", "resource", "content", "document", "page", "email", "member", "summary", "details", "manager", "mail", "msg", "module"]}}
{"id1": "16079868", "id2": "350482", "code1": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"readIntoList": ["readIntonMap", "readIntoLog", "readTextoMap", "readInttoList", "readIntoMap", "readTextoList", "readInttoLog", "readTextoLog", "readIntonLog", "readIntonList", "readInttoMap"], "url": ["address", "base", "job", "feed", "io", "URL", "path", "remote", "input", "Url", "host", "location", "string", "name", "sl", "gl", "stream", "image", "link", "org", "ssl", "connection", "user", "object", "rule", "config", "buffer", "uri", "service", "resource", "date", "http", "l", "source", "file", "server", "data", "email", "channel", "rl"], "list": ["map", "test", "result", "client", "cache", "status", "view", "dict", "load", "index", "out", "name", "li", "lists", "obj", "queue", "this", "self", "code", "we", "all", "LIST", "menu", "info", "batch", "show", "user", "object", "parent", "join", "see", "listed", "table", "tree", "array", "detail", "get", "l", "data", "pool", "server", "nav", "member", "coll", "json", "group", "part", "record", "temp"], "in": ["gin", "ins", "reader", "din", "IN", "client", "token", "login", "re", "bin", "io", "inc", "raw", "ini", "input", "er", "out", "In", "inner", "stream", "image", "c", "err", "read", "m", "ssl", "a", "i", "r", "b", "again", "rec", "loader", "nin", "fr", "buffer", "iter", "inn", "min", "h", "is", "l", "data", "lin", "file", "source", "con", "as", "f"], "inputLine": [" inputFile", " inputText", "requestLine", "ifline", "outputString", "requestline", "ifName", "inputString", "InputBlock", "commandFile", "requestText", " inputName", "commandName", "InputText", "InputL", " inputStream", " inputLin", "inputFile", "commandLine", "issueLine", " inputString", "argumentBlock", "inputL", "issueline", "InputString", "InputFile", "commandItem", "issueLin", "outputL", "inputName", "inputStream", "Inputline", "InputName", "inputLin", "commandline", "argumentL", "inputline", "InputItem", "argumentLine", "requestL", "ifLine", " inputL", " inputItem", "ifLin", "InputLine", "inputItem", "outputText", "outputline", " inputline", "outputLine", "inputText", "argumentStream", "commandText", "InputStream", "issueName", "commandBlock", "outputFile", " inputBlock", "inputBlock"], "commandNameBegin": [" commandLineBegin", "commandPathBeginning", "commandLineCreate", " commandNameBeginning", "commandNamebegin", "commandParamBeginning", " commandTimeBegin", "CommandNameEnd", "commandLineBeginning", "commandTimeCreate", " commandLineEnd", "commandTimeBeginning", "commandStringBegin", "commandStringEnd", "CommandNamebegin", "commandLengthCreate", " commandNamebegin", "CommandNameBeginning", "commandNameCreate", "commandPathbegin", "commandLineEnd", "commandLengthBegin", "commandStringbegin", " commandNameCreate", " commandTimeBeginning", "commandParamEnd", " commandLinebegin", "commandTimeEnd", "commandLineBegin", "commandNameBeginning", " commandStringBeginning", "commandTimeBegin", "commandParambegin", "CommandLineBeginning", "commandPathEnd", "commandLengthBeginning", "commandLengthEnd", "commandLinebegin", " commandTimeCreate", "CommandLinebegin", "CommandLineEnd", "commandParamBegin", "CommandNameBegin", " commandStringbegin", "commandTimebegin", " commandStringBegin", "CommandLineBegin", " commandStringEnd", " commandTimeEnd", " commandLineBeginning", "commandPathBegin", "commandStringBeginning"], "commandNameEnd": [" commandLineBegin", "commandLineStart", "commandParamend", "operationParamStart", "commandPathBegin", "commandParamEND", "commandLineend", "commandPathend", " commandNameStart", "commandParamStart", " commandLineEnd", " commandLineStart", " commandNameEND", "commandTimeend", "commandNameend", "operationNameEnd", "commandPathStart", "commandLineEnd", "commandnameend", "commandLineEND", "operationNameend", "commandTimeEND", "operationNameBegin", "commandParamEnd", "commandTimeEnd", "commandLineBegin", "commandTimeBegin", "commandTimeStart", "operationParamBegin", "operationNameStart", " commandTimeEND", "commandPathEnd", "operationParamend", " commandLineend", "commandParamBegin", "commandnameEnd", "commandPathEND", "commandNameEND", "commandnameEND", " commandTimeend", " commandTimeEnd", "commandNameStart", "operationParamEnd", " commandNameend", " commandLineEND"], "item": ["result", "base", "ip", "client", "job", "builder", "el", "site", "app", "or", "xml", "owner", "plugin", "er", "hop", "name", "li", "ui", "response", "obj", "action", "image", "next", "link", "order", "si", "Item", "layer", "extra", "event", "items", "menu", "i", "element", "info", "user", "bar", "object", "parent", "handler", "edit", "update", "iter", "service", "api", "option", "admin", "p", "it", "add", "other", "page", "data", "entry", "up", "server", "article", "channel", "source", "instance", "area", "group", "atom", "part", "json", "manager", "temp"], "e": ["oe", "v", "esi", "error", "exc", " event", "Event", "change", "re", "edge", "force", " pe", "ise", "one", "x", "ea", "es", "er", "te", "u", "ee", "c", "err", "this", "E", "fe", "ze", "or", "event", "t", "a", "ie", "en", "ec", "i", "pe", "ce", "ite", "ception", "o", "handler", "ae", "p", "ve", "l", "me", "ev", "se", "ke", "d", "ne", " ev", "ed", "f", "le"]}}
{"id1": "11562173", "id2": "8069594", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["checkOutputSteam", "checkOutputStream", "checkIOstream", "checkInputstream", " checkInputChannel", "checkInputChannel", "checkOutputChannel", "checkIOSteam", " checkOutputChannel", " checkInputstream", "checkOutputstream", " checkOutputStream", "checkIOChannel", " checkOutputstream", " checkInputSteam", "checkIOStream", "checkInputSteam", "checkFileSteam", " checkOutputSteam", "checkFileChannel", "checkFilestream", "checkFileStream"], "in": ["ins", "din", "reader", "IN", "login", "bin", "io", "isin", "inc", "x", "ini", "index", "input", "ic", "In", "inner", "image", "c", "comp", "connection", "again", "inn", "p", "min", "plus", "is", "into", "data", "source", "up", "src", "con", "ack", "as"], "cmp": ["fp", "lc", "upp", "amp", "cache", "sup", "pixel", "com", "pre", "cb", "sort", "proc", "roc", "index", "omp", "conv", "cp", "c", "ci", "spec", "prefix", "comp", "cc", "asc", "np", "code", "prev", "cho", "cop", "cs", "co", "config", "diff", "loc", "clip", "p", "rc", "cup", "match", "op", "ch", "up", "mom", "coll", "pc", "cpp", "ctrl", "comment", "ctx", "mp"], "all": ["cl", "ann", "local", "allow", "ALL", "call", "valid", "not", "none", "partial", "am", "one", "default", "always", "total", "al", "auto", "asc", "All", "global", "a", "null", "both", "parent", "any", "best", "except", "list", "each", "alpha", "array", "p", "l", "match", "process", "and", "coll", "only", "full", "sum", "acl"], "stream": ["v", "test", "result", "cont", "client", "reader", "output", "port", "feed", "platform", "raw", "progress", "model", "input", "host", "string", "context", "this", "comp", "ream", "self", "Stream", "user", "transform", "null", "object", "per", "speed", "socket", "steam", "wrapper", "form", "stack", "track", "iterator", "document", "round", "source", "channel", "up", "pool", "instance", "coll", "src", "roll", "ack", "impl", "sw", "trans", "response", "temp"], "out": ["v", "result", "OUT", "outs", "project", "output", "bin", "exp", "io", "inc", "not", "x", "index", "name", "obj", "image", "c", "prefix", "this", "Out", "extra", "user", "b", "null", "again", "parent", "o", "list", "sync", "block", "outer", "array", "option", "p", "copy", "point", "other", "data", "up", "full", "part", "sum", "comment", "response"], "i": ["qi", "v", "lc", "k", "ai", "ti", "I", "e", "id", "io", "xi", "x", "ini", "index", "start", "ind", "u", "ui", "end", "li", "hi", "multi", "c", "ci", "si", "mi", "ii", "j", "type", "r", "info", "b", "n", "bi", "slice", "ri", "uri", "p", "strength", "key", "gi", "h", "ix", "abi", "it", "l", "oi", "di", "fi", "init", "d", "ji", "f", "pi"]}}
{"id1": "10383721", "id2": "3187685", "code1": "    @SuppressWarnings(\"unchecked\")\n    private ReaderFeed processEntrys(String urlStr, String currentFlag) throws UnsupportedEncodingException, IOException, JDOMException {\n        String key = \"processEntrys@\" + urlStr + \"_\" + currentFlag;\n        if (cache.containsKey(key)) {\n            return (ReaderFeed) cache.get(key);\n        }\n        List<Post> postList = new ArrayList<Post>();\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Cookie\", \"SID=\" + sid);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n        SAXBuilder builder = new SAXBuilder(false);\n        Document doc = builder.build(reader);\n        Element root = doc.getRootElement();\n        Namespace grNamespace = root.getNamespace(\"gr\");\n        Namespace namespace = root.getNamespace();\n        String newflag = root.getChildText(\"continuation\", grNamespace);\n        String title = root.getChildText(\"title\", namespace);\n        String subTitle = root.getChildText(\"subtitle\", namespace);\n        List<Element> entryList = root.getChildren(\"entry\", namespace);\n        DateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n        for (Element e : entryList) {\n            Post post = new Post();\n            post.setTitle(e.getChildText(\"title\", namespace));\n            try {\n                post.setDate(sdf.parse(e.getChildText(\"published\", namespace)));\n            } catch (ParseException e1) {\n            }\n            post.setUrl(e.getChild(\"link\", namespace).getAttributeValue(\"href\"));\n            post.setSauthor(e.getChild(\"author\", namespace).getChildText(\"name\", namespace));\n            String content = e.getChildText(\"content\", namespace);\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"description\", namespace);\n            }\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"summary\", namespace);\n            }\n            post.setContent(content);\n            postList.add(post);\n        }\n        ReaderFeed readerFeed = new ReaderFeed();\n        readerFeed.setTitle(title);\n        readerFeed.setSubTitle(subTitle);\n        readerFeed.setFlag(newflag);\n        readerFeed.setPostList(postList);\n        cache.put(key, readerFeed);\n        return readerFeed;\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"processEntrys": ["processDistrys", "processENTrings", "processENTrys", "processEllrings", "runENTrings", "runEntrings", "runEntriers", "processEntris", "processEntrings", "processENTris", "processDistriers", "processENTriers", "processEllris", "runEntris", "runENTrys", "processEntriers", "processEllriers", "runENTris", "processEllrys", "runEntrys", "runENTriers", "processDistris", "processDistrings"], "urlStr": ["fileStr", "URLStr", "filestr", "httpStr", "UrlStr", "urlSTR", "resourceString", "Urlstr", "UrlSTR", "urlstr", " urlString", "uriStr", "URLString", "urlString", "httpSTR", " urlSt", "uriString", "resourcestr", "uriSt", "URLSt", "resourceStr", " urlstr", "urlSt", "uriSTR", "httpString", "resourceSTR", "fileSTR", "httpstr", " urlSTR", "URLSTR"], "currentFlag": ["CurrentText", " currentField", " currentBit", "CurrentTag", "currentField", "reportedText", "Currentflag", "reportedFlag", "CurrentFlag", "reportedBit", "activeflag", "currentFLAG", "reportedField", "activeFlag", "nextFlag", "activeTag", "currentTag", " currentText", "nextflag", "nextFLAG", "nextTag", "activeFLAG", "CurrentField", "currentText", "currentBit", "CurrentFLAG", "currentflag", "CurrentBit"], "key": ["hash", "k", "here", "base", "kid", "cache", "str", "scope", "id", "exp", "sign", "ace", "path", "check", "function", "KEY", "name", "string", "seed", "section", "lock", "prefix", "step", "or", "lease", "type", "ie", "method", "text", "parent", "rule", "empty", "query", "list", "message", "service", "search", "fee", "Key", "mac", "point", "entry", "data", "ry", "match", "secret", "keys", "field", "fix", "roy", "value", "full", "ey", "part", "msg"], "postList": ["PostList", "POSTList", "PostGroup", "POSTCollection", "postGroup", "POSTGroup", "postlist", " postlist", "POSTlist", " postCollection", " postGroup", "postCollection", "PostCollection", "Postlist"], "url": ["address", "base", "client", "cache", "feed", "URL", "proxy", "path", "log", "sl", "Url", "host", "location", "conn", "string", "image", "link", "build", "org", "ssl", "text", "www", "loc", "socket", "ur", "uri", "service", "resource", "http", "l", "page", "data", "server", "file", "entry", "channel", "director", "web"], "connection": ["position", "client", "connected", "io", "URL", "proxy", "function", "remote", "creator", "connect", "machine", "conn", "out", "to", "section", "c", "database", "character", "communication", "writer", "Connection", "b", "application", "object", "directory", "number", "body", "handler", "config", "socket", " Connection", "uri", "resource", "version", "wrapper", "condition", "document", "http", "l", "channel", "server", "password", "director", "con", "collection", "open", "response", "relation"], "reader": ["client", "feed", "io", "xml", "ler", "row", "er", "input", "stream", "driver", "editor", "read", "Reader", "writer", "r", "body", "handler", "oder", "per", "loader", "parser", "buffer", "iter", "resource", "document", "entry", "data", "file", "server", "channel", "reading", "f"], "builder": ["result", "base", "client", "bean", "db", "xml", "default", "row", "creator", "er", "bridge", "driver", "bug", "image", "builders", "database", "build", "editor", "keeper", "or", "writer", "info", "r", "b", "Builder", "config", "building", "loader", "parser", "buffer", "wrapper", "document", "http", "entry", "runner", "manager"], "doc": ["ger", "md", "base", "project", "gen", "str", "app", "git", "db", "xml", "docs", "df", "div", "node", "context", "bug", "build", "lib", "Doc", "writer", "info", "r", "html", "text", "body", "graph", "parser", "tree", "dc", "resource", "document", "doctor", "dr", "data", "file", "dir", "d", "coll", "open", "f"], "root": ["Root", "error", "leaf", "right", "path", "xml", "div", "name", "section", "writer", "box", "null", "front", "empty", "query", "document", "data", "article", "server", "author", "child", "db", "remote", "ree", "creator", "string", "bot", "component", "user", "rec", "back", "loader", "tree", "parser", "http", "page", "comment", "zero", "result", "project", "roots", "scope", "cover", "valid", "container", "top", "inner", "rt", "parent", "body", "head", "outer", "nav", "director", "rss", "home", "first", "sys", "master", "ver", "default", "owner", "node", "rew", "rup", "archive", "element", "r", "html", "n", "entry", "record", "manager"], "grNamespace": ["grMemberspaces", "grNamescape", "grNamespaces", "grNamespe", "grnamespe", "GrNamespe", "grnamespaces", "Grnamescape", "grnamescape", "grnamesche", "grMemberspaced", "GrNamescape", "Grnamespe", "GrNamesche", "GrNamespaces", "GrNamespace", "grNamespaced", "Grnamespaces", "grnamespace", "Grnamespace", "grnamespaced", "GrNamespaced", "grMembersche", "grMemberspace", "grNamesche"], "namespace": ["namesace", "membersace", "Namesception", " namesace", "xml", "namecape", "memberspace", "membersternal", " namesception", "Namesase", " Namespaced", " namespec", "kespaced", " namespaces", "Namesace", "namespect", " namescore", "namepaces", " namespect", "namespaced", "New", "feed", "kespace", "s", "Namespaces", "Namesternal", "Namespaced", "Namespace", "namesspace", "namescape", "http", " Namespace", " namespaced", "inasspace", "namescore", "memberscape", "inasternal", "nameternal", "kesase", "inasace", "_", "namesternal", "namespaces", "technspace", "memberscore", " namescape", "namepace", " Namespaces", "Namesspace", "inaspace", "namesception", " namesspace", "nameception", "namesase", "Namespect", " Namespec", "workspaces", " namesternal", "technpace", "Namescore", "this", "memberspaces", "workspect", " namesase", "Namescape", "membersspace", "add", "Namespec", "namespec", "worksception", "workspace"], "newflag": [" newFlag", "newstyle", "nextFlag", "lnflag", "newStatus", "nextflag", "lnFlag", " newStatus", "newFlag", "lnstyle", " newstyle", "nextstyle", "lnStatus", "nextStatus"], "title": ["template", "header", "description", "term", "filename", "name", "itles", "itle", "Title", "format", "type", "html", "text", "body", "message", "license", "resource", "version", "Content", "subject", "published", "summary", "details", "label", "author"], "subTitle": ["SubDescription", "ubtitle", "Subtitle", " subtitle", "subDescription", "SubName", " subName", "ubDescription", "subName", "SubTitle", " subDescription", "ubName", "ubTitle", "subtitle"], "entryList": ["ziplist", "elementChain", "entryChain", " entryQueue", "postL", "entrylist", "elementlist", " entryChain", "elementList", " entrylist", " entryLIST", "tryQueue", "entryLIST", "entryQueue", "zipList", "postLIST", " entryL", "entryL", "tryChain", "tryList", "elementQueue", "trylist", "postlist", "zipLIST", "zipL"], "sdf": ["ssfd", " scf", "psdf", "scf", "ascf", "sdd", "psde", "asde", "rsdd", "Sde", "ssdd", "Sfd", "ssde", "rsde", "ssdf", "rsdf", " sdd", " sde", "sde", "pscf", "Sdd", "asdd", "asdf", "sfd", "rsfd", "Sdf", "psdd"], "e": ["oe", "de", "esi", "ed", " event", "ele", "enter", "el", "edge", "pse", " pe", " ie", "Element", "one", "je", "ge", "er", "node", "ea", "te", "end", "ee", "event", "c", "E", " E", "entity", "y", "m", "t", "element", "ie", " me", "r", "en", "ec", "j", "ce", "n", "i", "eu", "o", "ae", "ente", "eb", "p", "ve", "me", "l", "entry", " element", " entity", "se", "line", "d", "ne", "ze", "f", "le", "be"], "post": ["posts", "result", "system", "project", "pod", "tax", "maybe", "feed", "pre", "valid", "child", "load", "check", "one", "default", "cross", "row", "index", "node", "patch", "archive", "set", "next", "upload", "link", "read", "user", "text", "head", "object", "edit", "list", "install", "ost", "the", "p", "add", "form", "copy", "get", "wp", "mod", "page", "entry", "article", "push", "op", "Post", "style", "server", "create", "record", "draw", "POST", "pass", "posted", "home", "part", "comment", "author"], "content": ["template", "header", "description", "status", "output", "path", "name", "language", "archive", "image", "code", "comments", "text", "body", "draft", "message", "media", "version", "resource", "Content", "page", "source", "data", "file", "summary", "value", "script", "size"]}}
{"id1": "22441244", "id2": "7296597", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public void create() {\n        Connection conn = OrmHandler.getInstance().getSession().getConnection(this);\n        Statement stat = null;\n        StringBuilder sql = new StringBuilder(256);\n        try {\n            getRenderer().printCreateDatabase(this, sql);\n            conn = createConnection();\n            stat = conn.createStatement();\n            stat.executeUpdate(sql.toString());\n            conn.commit();\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.info(sql.toString());\n            }\n        } catch (Throwable e) {\n            if (conn != null) {\n                try {\n                    conn.rollback();\n                } catch (SQLException ex) {\n                    LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n                }\n            }\n            throw new IllegalArgumentException(\"Statement error:\\n\" + sql, e);\n        } finally {\n            try {\n                close(conn, stat, null, true);\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"send": ["exec", "address", "delete", "parse", "transfer", "export", "Send", "start", "end", "write", "set", "build", "text", "post", "message", "add", "get", "from", "submit", "append", "execute", "create", "reply", "sent", "open", "mail"], "hsession": ["hessions", "HSSession", "hhort", "HSession", "hessession", "hSession", "openssession", "hesession", "opensess", "opensort", "HSessions", "hmessions", "hmession", "hhessions", "hession", "hssession", "hhSession", "hhession", "hhsession", "hsess", "hhess", "hsSession", "hmsession", "hesort", "hesess", "opensession", "opensessions", "hsessions", "opensSession", "hmSession", "HSsession", "hsort"], "session": ["Session", "client", "cache", "project", "site", "port", "security", "proxy", "chat", "sl", "host", "context", "state", "response", "event", "connection", "class", "application", "parent", "essions", "message", "resource", "document", "server", "ession", "manager", "mail"], "repositoryName": ["repoitoryEmail", "reposessionNAME", "repoositoryAddress", "reposicationFamily", "reposicationAddress", "repoositoryEmail", "repositoryPath", "reposicationEmail", "repoositoryPath", "reposessionName", "reposositoryPath", "repoitoryName", "reposositoryFamily", "repoitoryAddress", "repoitoryPath", "reposessionPath", "reposicleFamily", "repoitoryFamily", "repositoryNAME", "repositiveEmail", "repoositoryNAME", "reposositoryName", "repositoryFamily", "reposicationName", "repoitoryNAME", "reposositoryEmail", "reposessionEmail", "reposositoryNAME", "repositoryEmail", "reposicleAddress", "repositiveNAME", "reposicleEmail", "repositivePath", "repositiveName", "repositoryAddress", "repoositoryFamily", "repoositoryName", "reposicleName", "reposositoryAddress"], "ideIdint": ["ideAuthInt", "ideInint", "ideIdn", "ideTimeout", "ideTimeint", "ideNamenumber", "ideAuthn", "ideInn", "ideInfoInt", "ideIdints", "IDEIdout", "ideInfonumber", "IDEidInt", "ideInfoout", "ideNameInt", "ideAuthints", "ideidInt", "ideNameint", "ideAuthint", "ideInints", "IDEidint", "IDEidn", "ideInInt", "ideidints", "IDEIdInt", "ideidn", "IDENameout", "ideIdInt", "IDEIdints", "ideidint", "IDEidints", "IDENamenumber", "ideIdnumber", "ideTimenumber", "IDENameInt", "ideIdout", "IDEIdint", "ideTimeInt", "ideNameout", "IDEIdnumber", "IDEIdn", "ideInfoint", "IDENameint"], "to": ["template", "address", "client", "account", "token", "title", "phone", "site", "po", "sub", "TO", "target", "location", "name", "contact", "top", "response", "prefix", "company", "options", "To", "with", "mobile", "message", "office", "uri", "by", "from", "tel", "source", "summary", "about", "reply", "mail", "settings"], "cc": ["address", "lc", "cl", "cf", "client", "ca", "uc", "account", "phone", "tc", "contact", "cr", "c", "ci", "company", "card", "code", "ct", "ec", "cca", "cs", "cus", "dc", "from", "ck", "rc", "sc", "cn", "password", "nc", "ac", "CC", "comment", "cb", "ce"], "bcc": ["bce", "abck", "bc", " brc", "abcc", "fck", "bbc", " bck", "abce", "bck", " bce", "brc", "bbrc", "fcc", "bbcc", "fc", "frc", "pck", "pcc", "pce", "pc", " bc", "abc", "bbck"], "subject": ["template", "header", "description", "title", "phone", "sub", "request", "filename", "host", "state", "response", "ject", "prefix", "username", "format", "reason", "method", "object", "head", "message", "uri", "mail", "content", "reply", "Subject", "comment", "author"], "body": ["template", "url", "header", "base", "description", "left", "pod", "view", "foot", "Body", "zip", "shell", "function", "money", "name", "string", "length", "inner", "lock", "bound", "plain", "code", "normal", "reason", "connection", "html", "text", "object", "empty", "message", "tree", "media", "resource", "how", "wrapper", "content", "line", "source", "data", "style", "secret", "summary", "password", "pass", "part", "comment", "response"], "attachments": ["Attachents", "messments", "messings", "Attachments", "attachings", "embedents", "attachents", "messents", "embedment", "Attachment", "embedments", "Attachings", "messment", "embedings"], "isHtml": ["isWhhtml", " isWhive", "isChive", "isCail", "isChtml", "isHahtml", " isHttp", "isHaail", " isHhtml", "isHail", "isHatml", "isHhtml", "isChttp", "isCive", "isWhtml", " isWhtml", "isPhhtml", " isHail", "isChail", "isHttp", "isPhtml", "isChhtml", " isChtml", " isWhhtml", "isPhttp", "isHattp", " isHive", "isPhail", "isWhail", "isHive", " isChhtml", " isChail", "isCtml", "isWhive", " isChttp", " isWhail"], "charset": ["chacksET", "charspace", "cheansetter", "charsetter", "chasheset", "chearsetting", "charsete", "chasesetting", "chearsetter", "chansET", "chaseset", "chashesetter", "Charset", "chacksete", "chARSeting", "chARSete", "chansete", "chaseting", "chasets", "chearsete", "chasetting", "chaset", "chARSET", "chansetter", "cheanspace", "CharsET", "chansetting", "chaseseting", "Charsetting", "chasesET", "charsetting", "cheanset", "chanspace", "charsets", "chARSets", "chaspace", "chARSet", "chasetter", "Charseting", "charsET", "chasET", "cheansET", "chearspace", "chearset", "Charsets", "chacksetting", "charseting", "cheansete", "chashesET", "chanset", "chashespace", "chearsET", "cheansetting", "chARSetting", "chackset"], "headers": ["header", " messages", " emails", "ers", "params", "types", "groups", "classes", "status", " recipients", "metadata", "authors", "users", " cookies", "lines", "files", "comments", "strings", "properties", "errors", "mails", "options", "content", "names", "writers", "settings"], "priority": ["template", "level", "title", "status", " recipients", "phone", "security", "length", "language", "state", "queue", " title", "prefix", " severity", "code", "comments", "reason", "mode", "class", "quote", "lang", "date", "secret", "theme", "reply", "comment", "author"], "email": ["external", "template", "address", "url", "result", "oe", "base", "test", "account", "gmail", "enter", "lex", "el", "output", "view", "e", "zip", "pm", "model", "xml", "default", "engine", "export", "auto", "name", "note", "contact", "ext", "core", "ilo", "business", "entity", "generic", "username", "event", "element", "en", "info", "ssl", "html", "print", "text", "object", "online", "example", "install", "update", "message", "mail", "office", "service", "em", "document", "line", "international", "data", "article", "letter", "server", "password", "fax", "create", "Email", "liner", "response"], "user": ["ip", "account", "client", "token", "e", "use", "id", "model", "User", "creator", "users", "er", "name", "string", "plugin", "profile", "friend", "character", "username", "type", "info", "connection", "role", "object", "unknown", "mobile", "person", "resource", "me", "consumer", "data", "USER", "member", "uid", "people", "author"], "identity": ["entityifier", "identonymous", "IDENTITY", "authorifier", "entityity", "identiciary", "idITY", "publiciciary", "identifier", "identITY", "identities", "IDENTity", "idifier", "installonymous", "IDENTities", "personITY", "authorITY", "electricity", "installentity", "ethniciciary", "authentifier", "installITY", "idity", "ethnicication", "electricITY", "authorities", "IdentITY", "ethnicITY", "Idententity", "entityization", "authentity", "Identities", "installity", "authentITY", "idententity", "personentity", "personity", "Identity", "authorentity", "idication", "identication", "authorication", "publicentity", "publicity", "IDENTentity", "entityonymous", "personifier", "publicITY", "idization", "ethnicentity", "idonymous", "electriconymous", "authentication", "ethnicifier", "authoriciary", "authentonymous", "ethnicity", "electricentity", "authority", "identization", "authentization", "authoronymous"], "_returnPath": ["_successId", "_relationId", "_resultTo", "_backName", "_returnName", "_backUrl", " _backTo", " _returnPart", "_backPath", "_returnNode", "_inputMid", "_returnPart", " _backHalf", "_correctPath", "_replyPath", "_relationText", "_returnUrl", "_backPart", " _backUrl", "_displayUrl", "_correctDirectory", "_returnpath", "_displayPath", "_resultName", "_relationDirectory", "_returnText", "_displayPart", "_responsepath", "_correctId", "_displayMid", "_relationPath", "_addpath", "_returnType", "_successDirectory", "_replyNode", "_replyPart", " _returnHalf", " _backPart", "_responseType", "_returnHalf", "_correctText", "_returnMid", "_backType", "_resultPath", "_resultHalf", "_inputNode", "_addType", "_successPath", "_backpath", "_inputPath", " _returnTo", " _returnName", "_replyUrl", "_replyMid", "_successText", "_returnTo", "_displayNode", "_responsePath", " _backName", "_inputUrl", "_backHalf", "_backTo", "_returnId", " _returnUrl", " _backPath", "_returnDirectory", "_addPath"], "_from": ["workwho", " _for", "_with", " _with", "_for", "blockerror", "existingowner", "_who", "blockfrom", "workfrom", " _who", " _source", "workto", "placefor", " _error", "existingfrom", "existingto", " _owner", "_source", "placefrom", "_error", "_owner", "worksource", "_From", "blockto", "placeowner", "existingfor", " _From", "blockFrom", "placeto"], "_replyTo": ["_replyAddress", "_reasonTo", "_respondPoint", "_addTo", "_reasonTO", "_replyUrl", "_respondAddress", "_closeTO", "_reasonFrom", "_replyTO", "_respondTO", " _returnFrom", "_returnAddress", "_returnTo", "_closeOf", "_commentTO", " _replyUrl", "_addFrom", "_respondUrl", "_addPoint", "_returnOf", " _returnUrl", "_commentTo", "_reasonUrl", "_commentFrom", " _replyFrom", "_returnTO", "_returnUrl", "_returnFrom", "_replyFrom", "_closeFrom", " _replyTO", " _returnTo", "_returnPoint", "_commentOf", "_respondTo", "_closeTo", "_replyPoint", "_replyOf", "_addAddress", "_respondFrom", " _returnTO"], "_to": ["Jto", " _target", "Jfrom", " _about", "Jabout", "_target", "_about", "Jtarget"], "_cc": ["_ce", " _ce", " _cd", "_cd", "_cf", " _cf"], "_bcc": [" _bc", " _abc", " _abce", " _abcs", "_abcs", "_abc", "_rbcc", " _abcc", "_bce", "_bc", " _bce", "_abce", "_abcc", "_sbc", "_rbce", "_sbcs", "_bcs", "_sbce", " _bcs", "_sbcc", "_rbc", "_rbcs"]}}
{"id1": "14688886", "id2": "16142024", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 0, "substitutes": {"populateResources": ["popureResources", "compureResources", "populateResource", "popractRelations", "compureResource", "populateRelations", "poputeResource", "poputeResources", "compulateResources", "compulateFiles", "popureRelations", "compureRelations", "popureResource", "poputeRelations", "compureFiles", "popureFiles", "poputeFiles", "popractResources", "compulateResource", "popractFiles", "popractResource", "compulateRelations", "populateFiles"], "templates": ["Temures", "template", "promplate", "prometers", "templateples", "templateplates", "tempplate", "typlates", "templ", "filures", "Template", "stemps", "temures", " templ", "filens", "Temens", "promplates", "tompl", "prompl", "typlate", "stemples", "templateps", "filpl", "temppl", "typs", "Temples", " temens", "Temeters", "tempplates", " temures", "tomplate", "stempl", "temens", "Temps", "typl", "Templates", "temeters", "tometers", "temps", "templatepl", "temples", "stemplates", "Templ", "tomplates", "filplates", "tempps"], "url": ["template", "address", "base", "job", "ob", "el", "e", "feed", "URL", "path", "xml", "sl", "fl", "Url", "filename", "location", "string", "name", "host", "pattern", "image", "link", "pl", "ssl", "connection", "r", "html", "route", "object", "config", "buffer", "uri", "service", "resource", "http", "href", " URL", "page", "source", "file", "l", "data", "entry", "email", "server", "channel", "download", "f", "il"], "fileName": ["FileKey", " filePart", "folderPath", "filename", " fileTime", "fileTime", " fileDir", " fileSystem", "FileString", "filePart", "fKey", "objectname", "resourcename", "fileFull", "fileString", "folderPart", " fileDirectory", "sourceInfo", "filePath", "objectName", "stringType", "Filename", "filenameString", "FileType", " fileLength", "folderName", "filenameType", "resourcePart", "sourceName", "FILESystem", "FILESync", "fName", " fileString", "modelName", "filenameFull", "fileInfo", "modelname", "fname", "objectSync", "stringDirectory", "objectTime", "foldername", "fDir", "sourcename", "filenameLength", "fileLocation", "FileDir", "modelLocation", "FILEname", " fileSync", " fileFull", "FILEName", " fileInfo", "sourceString", "FileDirectory", "fileType", "sourceLength", "resourcePath", "modelSystem", " filename", " fileType", "FileFull", "fileLength", " fileKey", "FILELocation", " filePath", "fileDir", "FileName", "stringName", "filenamename", "FILETime", "filenameName", "fileDirectory", "fileKey", "fileSync", "fileSystem", "FileInfo", "resourceName", " fileLocation"], "templateResource": ["tempRole", " templateType", "tempResource", "templateType", "copyresource", "xmlResource", "templateContainer", "eventresource", "templateUrl", "templateContent", "translationContainer", "templateRing", "plateContainer", "eventReader", "layoutRing", "layoutContent", "layoutResource", "copyUrl", "tempFile", "copyResource", "templateFile", "layoutContainer", " templateRole", "plateContent", "privateResource", "templateReader", "templateresource", "translationResource", "plateResource", "privateReader", "templateRole", "copyReader", "tempType", "translationRing", "xmlFile", "eventResource", " templateFile", "plateRing", "xmlRole", "privateresource", "privateUrl", "eventUrl", "translationContent", "xmlType"], "is": ["serv", "im", "ais", "ip", "ib", "iso", "ar", "isa", "io", "app", "has", "was", "IS", "bis", "Is", "abs", "ir", "out", "s", "cms", "ris", "isl", "ios", "iss", "os", "nis", "ori", "r", "irc", "lis", "isc", "isi", "ri", "uri", "api", "it", "iris", "its", "in", "src", "rss", "as"], "strBuff": ["brBuff", "StrBuffer", "rText", "stringGrab", "Strbuff", "strbuff", "stringBuff", "arrBuff", " strGrab", "strPref", "arrBuffer", "rbuff", "StrPref", " strText", "strBuffer", " strTab", "StrTab", " strFlow", "StrBuff", "rBuff", "brGrab", "brBuffer", "strTab", "strGrab", "strFlow", "rBuffer", "strText", " strbuff", "stringFlow", "arrTab", "stringBuffer", " strBuffer", " strPref", "arrPref", "StrText", "brFlow"], "br": ["yr", "bc", "result", "reader", "mr", "sr", "ber", "io", "arr", "brush", "nr", "div", "er", "res", "cr", "hr", "stream", "bro", "orb", "err", "bl", "Br", "Reader", "ori", "r", "b", "browser", "text", "buf", "bar", "tr", "fr", "rb", "dr", "BR", "data", "gr", " reader", "sp", "ctr", "cb"], "str": ["lc", "cl", "st", "sr", "arr", "sec", "cur", "sl", "er", "div", "string", "name", "cr", "hr", "err", "spec", "wr", "Str", "or", "type", "t", "r", "kr", "text", "tr", "STR", "enc", "star", "oct", "fr", "iter", "p", "key", "dr", "line", "stri", "data", "char", "sc", "style", "coll", "sp", "strike", "f", "pr"], "images": ["picture", "photos", "services", "objects", "ins", "png", "ages", "classes", "groups", "types", "assets", "xs", "rooms", "people", "tags", "holes", "shows", "flows", "letters", "videos", "Images", "ions", "ims", "users", "styles", "gif", "image", "jobs", "resources", "sites", "files", "words", "stars", "models", "lights", "ups", "plugins", "pieces", "boxes", "events", "bands", "media", "views", "frames", "games", "opens", "dates", "apps", "ips", "icons", "pages", "tests", "versions", "thumbnails", "quarters", "gallery", "agents", "inches", "scripts", "features"], "i": ["v", "I", "e", "app", "id", "iu", "xi", "xml", "li", "hi", "si", "mi", "format", "ie", "p", "yi", "chi", "gu", "f", "phi", "ti", "x", "Url", "u", "s", "uni", "b", "key", "http", "in", "di", "cli", "bi", "lc", "io", "_", "ini", "eni", "multi", "ij", "ii", "y", "info", "config", "slice", "uri", "it", "ji", "mu", "pi", "qi", "z", "ip", "ai", "index", "ind", "ui", "image", "ci", "this", "j", "html", "n", "diff", "add", "gi", "fi", "ni", "d"], "img": ["map", "v", "im", "png", "ani", "ng", "jpg", "tmp", "app", "exp", "arr", "sl", "input", "fb", "ext", "li", "aut", "hr", "aff", "gif", "image", "bl", "fig", "imp", "lib", "m", "small", "norm", "ie", "info", "gd", "bg", "ff", "iframe", "config", "att", "inst", "icon", "p", "data", "file", "ch", "tif", "fw", "src", "gallery", "abc", "cb", "f"], "imgProperty": ["bgPro", "cacheProperty", " imgProp", "cacheProp", "imgImage", "bgProperty", " imgPro", "bgProp", "cachePro", "imgProp", "imgPro", " imgImage", "cacheImage", "bgImage"]}}
{"id1": "2113444", "id2": "6188784", "code1": "    private VelocityEngine newVelocityEngine() {\n        VelocityEngine velocityEngine = null;\n        InputStream is = null;\n        try {\n            URL url = ClassPathUtils.getResource(VELOCITY_PROPS_FILE);\n            is = url.openStream();\n            Properties props = new Properties();\n            props.load(is);\n            velocityEngine = new VelocityEngine(props);\n            velocityEngine.init();\n        } catch (Exception e) {\n            throw new RuntimeException(\"can not find velocity props file, file=\" + VELOCITY_PROPS_FILE, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n        return velocityEngine;\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"newVelocityEngine": ["newVelocityInstance", "newVelysicsServer", "newvelocityServer", "newVelysicsInstance", "newVelysicsEngine", "newVelantomServer", "newVelocityDriver", "newVelocityServer", "newVelysicsDriver", "newvelantomDriver", "newvelocityEngine", "newvelantomInstance", "newVelisionInstance", "newVelisionServer", "newVelantomEngine", "newVelantomInstance", "newvelocityDriver", "newVelantomDriver", "newVelisionDriver", "newvelantomServer", "newvelantomEngine", "newVelisionEngine", "newvelocityInstance"], "velocityEngine": ["explosityModule", "velisionCase", "collisionImpl", "explocityEngine", "velocolServer", "velocolController", "velantomServer", "velosityServer", " velisionController", "collisionEngine", "explosityServer", "velotionModel", "veloModel", "velvelCore", " velocityController", "velisionImpl", "velisionServer", "velocityImpl", "velocityCase", "veloDriver", "explocityModule", "veloEngine", " velisionEngine", "VelocityModel", "collocityImpl", "VelocityEngine", " velisionCore", "VeloDriver", "velvelImpl", "velvelCase", "velocityNode", "velosityController", "collocityEngine", "velocityServer", "explocityNode", "veloService", "velocityModule", "velosityCase", "velosityModule", "velityDriver", "velotionService", "velocityController", "collisionServer", "velityEngine", "VelocityDriver", "velvelServer", "collocityServer", "velosityEngine", "explosityEngine", "velotionEngine", "velocityDriver", "velosityCore", "velocolEngine", "velvelNode", " velisionCase", "velvelModule", "velvelController", "velityModel", " velocityCore", "VeloService", "velocityService", "velantomModule", "velisionController", "velocityModel", "velocityCore", "VeloEngine", "VeloModel", "velocolImpl", "explosityNode", "collocityController", "collisionController", "velisionCore", "velosityNode", "velantomEngine", "velisionEngine", "velvelEngine", "VelocityService", "velityService", "velotionDriver", "explocityServer", "velantomNode", " velocityCase"], "is": ["us", "address", "ais", "im", "ip", "ai", "ib", "ois", "does", "iso", "ar", "was", "io", "isa", "id", "has", "IS", "bis", "Is", "es", "res", "out", "abs", "ui", "state", "stream", "s", "ris", "err", "isl", "si", "ios", "iss", "os", "nis", "or", "ie", "i", "info", "ori", "lis", "ps", "il", "isc", "isi", "uri", "iter", "resource", "api", "close", "fs", "it", "get", "its", "iris", "http", "in", "init", "src", "as", "mis"], "url": ["address", "base", "str", "e", "id", "feed", "io", "URL", "path", "xml", "sl", "Url", "host", "location", "string", "stream", "image", "ssl", "i", "r", "b", "config", "loc", "loader", "ur", "uri", "service", "resource", "api", "http", "l", "page", "source", "file", "server", "data", "src", "f", "il"], "props": ["propfs", "probs", "prob", "propperties", "prfs", "Prods", "profs", " properties", "promds", "crofs", "propPS", "protb", "protfs", " proPS", "protperties", "preds", "crops", "propps", "promcs", "Procs", "Props", "properties", " probs", "promps", "Probs", "procs", "propbs", "prperties", "proPS", "prb", "preps", "crods", "croperties", "protps", "preperties", " profs", "propb", "propcs", " procs", "ProPS", "prombs", "prefs", " prods", "prods", "prps"]}}
{"id1": "4223002", "id2": "3330944", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "label": 0, "substitutes": {"getPasswordMD5": ["getpasswordMD5", "getPasswordMAC256", "getpasswordMD256", "getPasswordMac1", "getpasswordSHA512", "getPasswordMD512", "getPasswordSHA1", "getpasswordMD1", "getPasswordMD1", "getPasswordMac256", "getPasswordMAC5", "getPasswordSHA5", "getpasswordSHA256", "getPasswordMD256", "getPasswordMAC512", "getPasswordMac5", "getPasswordMAC1", "getPasswordSHA256", "getPasswordSHA512", "getpasswordSHA1", "getpasswordMD512", "getPasswordMac512", "getpasswordSHA5"], "algorithm": ["omalphabet", "gem", "omalgo", "Algo", "Algorithm", "Alphabet", "Algebra", " algo", "omalgorithm", "Alger", "alignment", "fgorith", "fgo", "geger", "alest", "algo", "Alrator", "geest", "Alm", "aggo", "fgorithm", "Algorith", " algorith", "aggorithm", "alm", " alrator", "fgebra", "agrator", "Alest", " alm", "algorith", " alger", "agignment", "omalgorith", "calgebra", " alignment", "calgorith", "calgo", "alphabet", "alger", "Alignment", "algebra", " alest", "gegorithm", "alrator", " alphabet", "calgorithm"], "messageDigest": ["messagedigest", "messageDest", " messageDigester", "messageDester", "messageModEST", "phraseDigested", "MessageModested", " messageDigEST", "messagedigester", "messageDEST", " messagedigest", "messageMDester", " messagedigester", "messageDigString", "MessageDigest", "phrasedigester", "messageDigested", "MessageDigEST", "messageModester", "MessageModest", "messageModested", "phraseDigest", "messageMDEST", "phraseDigester", "phrasedigested", " messagedigString", " messageDigString", "messageMDString", "messageModString", "messageMDest", "messagedigEST", "messageModest", "messageDested", "phraseDigEST", "messagedigString", "MessageDigester", "MessageModEST", "MessageModester", "MessageDigested", "messageDigEST", "phrasedigest", " messagedigEST", "messagedigested", "phrasedigEST", "messageDigester"], "hexString": [" hexstring", "hexArray", "hexstring", "hashFunction", " hexStr", "byteStream", "textArray", "hexStr", "textString", "shortstring", "shortArray", " hexStream", "hexBuffer", "checkString", "hashBuffer", "byteString", "textBuffer", "shortBuffer", "hexStream", "checkStr", "hexLine", " hexBuffer", "checkFunction", " hexArray", " hexLine", "textStream", "hashString", "hashStr", "hexFunction", "shortString", "checkBuffer", "textLine", "byteArray", " hexFunction", "byteLine", "textstring"], "i": ["v", "ai", "ti", "I", "e", "id", "io", "volume", "xi", "x", "index", "end", "u", "li", "s", "ui", "hi", "multi", "c", "ci", "si", "mi", "phi", "ii", "m", "t", "type", "a", "r", "j", "info", "b", "n", "o", "bi", "slice", "zi", "ri", "uri", "p", "key", "gi", "h", "ix", "abi", "fi", "in", "l", "oi", "di", "d", "chi", "mu", "f", "pi"]}}
{"id1": "19687456", "id2": "21656668", "code1": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testReadPerMemberSixSmall": [" testReadPerMemberSixSquare", " testReadPermemberSixSquare", " testReadPerMemberFoursmall", " testReadPermembersixsmall", " testReadPerMembersixSmall", " testReadPerMemberFourSquare", " testReadPermemberSixsmall", " testReadPermembersixSquare", " testReadPerMemberSixsmall", " testReadPermembersixSmall", " testReadPerMembersixSquare", " testReadPerMemberFourSmall", " testReadPerMembersixsmall", " testReadPermemberSixSmall"], "gzin": ["gzinn", "zins", "cigIN", "gzarin", "zigIN", "ziginn", "zigin", "zIn", "zigwith", "ezinas", "gzinas", "gzdin", "syncdin", "cgiin", "zdin", "syncout", "zlwith", "gcIn", "zznin", "cginin", "gzIN", "znin", "gtin", "wxin", "cfginn", "zipout", "zzinn", "gcout", "gtini", "zlinn", "zlIn", "gtout", "cfgin", "qqIn", "gcIN", "qqout", "cigin", "gcin", "zipin", "gtnin", "ssldin", "cgiIN", "zigdin", "zlin", "zini", "sslin", "zzout", "zzin", "sslIN", "cfgwith", "ezIN", "zout", "wxIN", "qqdin", "qqin", "qqIN", "zIN", "gzout", "ziparin", "zipIN", "zigIn", "gznin", "zin", "sslinn", "gzwith", "zzinas", "gzins", "cigout", "wxout", "cigarin", "eznin", "syncins", "zzIN", "ezin", "zzdin", "cgiinas", "gzIn", "syncin", "qqins", "gzini", "zzini", "cfgIn", "wxarin"], "i": ["v", "ip", "ai", "ti", "mini", "I", "e", "io", "iu", "xi", "index", "ui", "li", "u", "hi", "multi", "ci", "c", "si", "phi", "ii", "m", "j", "ie", "count", "info", "b", "n", "o", "bi", "zi", "uri", "api", "p", "gi", "h", "fi", "di", "oi", "ni", "d", "chi", "ji", "mu", "f", "pi"], "count2": [" count1", "Count1", "name2", "count4", "count5", "countTwo", "Count2", " count4", "Count02", "CountTwo", "name1", "name5", " count02", "sum1", "sum4", "sum2", "count02", "count1", " countTwo", "Count4", "Count5", " count5", "name02", "sumTwo"], "count3": [" count1", "err15", "size3", "cache83", "sum15", "err5", "err1", "size83", "count5", " count15", "sum3", "cache3", "size2", "count83", "err3", " count83", "sum5", "sum1", "size303", "count303", "cache303", " count303", "count1", "count15", "cache2", " count5"], "countEnd": ["lenBegin", "refend", "refEnd", "CountEND", "sizeEND", "Countend", "lenend", "lenEnd", "lenEND", " countend", "sizeStart", "sizeend", "countEND", "CountEnd", " countBegin", "refEND", "refStart", "CountStart", "countBegin", " countEND", "CountBegin", "countend", "countStart", "sizeEnd"]}}
{"id1": "2022160", "id2": "19739421", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"write": ["exec", "flow", "written", "writ", "send", "Write", "call", "w", "lex", "output", "cycle", "feed", "put", "wrote", "export", "connect", "out", "play", "end", "writing", "next", "set", "code", "read", "writer", "pipe", "sync", "update", "service", "close", "add", "kill", "flush", "copy", "store", "data", "process", "append", "create", "dump", "open", "size", "run"], "byteBuffers": ["ByteBuffERS", "byteBuffERS", "bytesPackers", "byteBufferlers", "byteCornered", "byteBufferers", "bytebufflers", "byteBuffererers", "bytebuffizers", "doubleHeadERS", "byteOrdresses", "byteOrdERS", " byteOrderers", " byteOffERS", "bytebuffered", "byteHeadings", "byteDefelines", "byteInteginals", "byteCornERS", "wordBufferers", "byteAkizers", "ByteBufferers", "ByteBuffers", "ByteOrderers", "byteInfERS", "byteInfers", "byteBuilders", "byteBuildERS", "byteBuffares", "byteBuffresses", "bytesBuffers", "bytebuffings", "bytesAkizers", "bytesBuffelines", "byteHeadERS", "byteAkors", "bytebufferers", "byteBuffered", "bytesPackerers", "doubleBuffings", "connectionBuffERS", "bytesPackapers", " byteBuffinals", " byteBuffeners", "ByteOrders", "bytebuffeners", "bytesBuffatters", "byteWritors", " byteOffers", "bytesBuffERS", "bytebuffests", " byteOrdlers", "byteCompers", "bytesCornatters", "bytePackERS", "byteCornatters", "byteInferers", "connectionBuffeners", "byteBufferERS", "bytebuffiners", "bytesBuffests", "byteBufferelines", "bytebuffers", " byteBuffters", "bytesBuffizers", "byteBuffiners", "byteBufferatters", "byteOrders", "byteDefERS", "bytesPackERS", "connectionBufferers", " byteCompares", " byteOrders", "byteCornares", "connectionbufferers", "bytebuffors", "wordBuffers", " byteBuffares", "ByteOrdERS", " byteOrdiners", "byteInfatters", "bytebuffelines", "byteBuffinals", "bytebuffatters", " byteOrdeners", "doubleHeadered", "byteBuffelines", "byteOffors", "byteOrdiners", "doubleBuffered", "doubleHeaders", "byteChERS", "byteBufflers", "byteWritlers", " byteOrdinals", "bytesDefatters", " byteComplers", "byteIntegeners", "bytebuffresses", "byteComplers", " byteBuffiners", " byteCompERS", "byteWritelines", "bytebuffERS", "byteWritizers", "byteCompERS", "byteDefatters", "bytesCornered", "bytesDefers", " byteBuffors", " byteOffors", "byteDefers", "byteWriters", "bytebuffters", "byteBuffests", "bytesAkors", "bytePackerers", "byteBuffters", " byteBufflers", "bytesDefelines", "byteOrdlers", "bytesCornests", "connectionbuffeners", "byteCornests", "wordBuffERS", "connectionBuffers", "byteIntegelines", "doubleBuffers", "byteChings", "bytesBufferers", "byteOffters", "byteBuildatters", "byteOffers", "byteOrdapers", " byteOffters", "byteChers", "bytesDefERS", "byteHeadered", "byteOrdeners", "bytesAkers", " byteOrdERS", "bytePackers", "byteCorners", "byteIntegERS", "byteAkelines", "doubleBuffERS", "bytesAkelines", "byteOrderers", "bytePackapers", "doubleHeadings", "bytesCorners", "byteIntegatters", "byteBuffatters", " byteBufferers", "ByteBufflers", "byteAkers", " byteCompers", "byteBuffereners", "byteBuffeners", "bytesBuffered", "byteBuffings", "byteWriterers", "byteIntegers", "byteOrdinals", "bytebuffinals", "byteChered", "byteBuffors", " byteBuffERS", "ByteBuffresses", "bytesBuffors", "connectionbuffERS", "byteOffERS", "byteCompares", "ByteOrdresses", "byteBuffizers", "byteBuffapers", "byteWritiners", "byteCornlers", "connectionbuffers", "byteBufferapers", "byteBuilderers", "byteHeaders", "wordBuffatters", "bytesBuffapers"], "m_initialOutBuffer": ["m_finalInBuff", "m_finaloutChannel", "m_originaloutFile", "m_InitialOutputBuffer", "m_initialInHeader", "m_initialInLayer", "m_finalOutCache", "m_initialoutCache", "m_initialOutMessage", "m_initialClientBuff", "m_InitialOutHeader", "m_initialShortCache", "m_originalOutLine", "m_initialOutFile", "m_InitialOutBuffer", "m_initialOutputMessage", "m_initialOutputBuffer", "m_InitialOutputLayer", "m_initialOutAddress", "m_initialShortFile", "m_finalInMessage", "m_initialOutHeader", "m_initialOutputChannel", "m_initialInLine", "m_initialSocketHeader", "m_originaloutBuffer", "m_finalOutBuffer", "m_initialShortBuffer", "m_initialOutChannel", "m_initialSocketFile", "m_initialAuthBuffer", "m_initialInBuff", "m_initialInBuffer", "m_initialOutputFile", "m_initialNewBuff", "m_originalOutBuffer", "m_initialoutChannel", "m_initialOutLayer", "m_finalInLine", "m_finaloutFile", "m_initialNewFile", "m_originaloutAddress", "m_initialInAddress", "m_initialOutBuff", "m_finalInCache", "m_initialoutLine", "m_initialClientBuffer", "m_initialNewMessage", "m_finalOutLine", "m_initialAuthLine", "m_initialAuthAddress", "m_initialoutBuffer", "m_finalOutBuff", "m_InitialOutputHeader", "m_initialShortChannel", "m_initialInCache", "m_initialClientLine", "m_initialOutputBuff", "m_finalInBuffer", "m_initialInMessage", "m_finaloutBuff", "m_initialInFile", "m_InitialOutLayer", "m_initialClientFile", "m_initialoutAddress", "m_initialOutputLayer", "m_InitialOutFile", "m_initialOutputHeader", "m_initialSocketBuffer", "m_originalOutFile", "m_originaloutLine", "m_initialNewBuffer", "m_finalOutMessage", "m_initialoutBuff", "m_finalOutFile", "m_originalOutAddress", "m_finalInChannel", "m_InitialOutputFile", "m_initialoutFile", "m_initialOutCache", "m_initialSocketLayer", "m_finalInFile", "m_initialOutLine", "m_finalOutChannel", "m_initialInChannel", "m_initialAuthFile", "m_finaloutBuffer"], "buffer": ["address", "bc", "uffer", "cache", "window", "port", "cur", "engine", "row", "fb", "queue", "writer", "null", "message", "flush", "document", "data", "file", "server", "limit", "f", "buff", "Buffer", "header", "client", "console", "transfer", "feed", "er", "input", "string", "bridge", "read", "event", "object", "back", "block", "loader", "timeout", "page", "pool", "comment", "cell", "template", "base", "reader", "FFER", "holder", "binary", "layer", "buf", "config", "slice", "resource", "wave", "stack", "copy", "source", "channel", "temp", "url", "builder", "re", "view", "output", "shell", "worker", "callback", "batch", "table", "iter", "array", "phrase", "response", "ker"], "buffers": ["ufors", "bufaches", "transformler", "affaches", "ufers", "transformERS", "bufers", "phators", "buffered", " buffages", "buffERS", "buffors", "buffators", "bufERS", "phresses", "phages", "ufering", "affors", "buffering", " buffERS", "bufferers", " buffered", "bufered", "Buffers", "affers", "phers", "bufresses", "affering", "Bufferers", " bufferers", "Buffars", "bufars", "Buffered", " buffars", " buffler", "buferers", "transformering", "buffler", "bufors", "bufler", "transformers", "bufages", " buffering", " buffators", "buffaches", "buffages", " buffresses", "bufering", "ufaches", "buffars", "buffresses", "bufators"], "result": ["complete", "test", "url", "error", "ver", "cache", "grade", "status", "re", "sr", "flash", "view", "output", "use", "comment", "valid", "Result", "request", "default", "function", "val", "row", "session", "er", "res", "out", "true", "inner", "ret", "winner", "driver", "err", "success", "results", "acc", "card", "rate", "or", "event", "info", "r", "report", "user", "future", "diff", "message", "date", "resource", "search", "rc", "consumer", "cup", "data", "match", "up", "successful", "json", "runner", "manager", "f", "response"], "encrypted": ["packed", "reader", "cache", "flash", "selected", "transfer", "available", "internal", "binary", "stream", "inner", "image", "extra", "layer", "text", "interrupted", "body", "config", "pad", "padding", "loader", " data", "flush", "source", "channel", "entry", "secret", "temp"]}}
{"id1": "18374478", "id2": "19747399", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    @Before\n    public void setUp() throws Exception {\n        connectionDigestHandler = new ConnectionDigestHandlerDefaultImpl();\n        URL url = null;\n        try {\n            url = new URL(\"http://dev2dev.bea.com.cn/bbs/servlet/D2DServlet/download/64104-35000-204984-2890/webwork2guide.pdf\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        }\n        try {\n            uc = url.openConnection();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"updateUser": ["updateRole", "addWord", " updateMember", "deleteuser", " updateRole", " updateuser", "editUser", "editUsers", "deleteMember", "updatedUser", "updatedWord", "updateduser", "UpdatePassword", "updatePassword", "createUser", "updateWord", "UpdateMember", "editRole", "updateuser", " updateAccount", " updateWord", "UpdateRole", "deletePassword", "createRole", "adduser", "updateAccount", "UpdateUsers", "editAccount", "deleteRole", "updateMember", "addUsers", "deleteWord", "UpdateUser", "updatedUsers", "updateUsers", " updatePassword", "addUser", "Updateuser", "UpdateWord", "createAccount", "deleteUser", "createUsers", " updateUsers", "deleteUsers"], "user": ["result", "ver", "client", "account", "job", "system", "project", "str", "view", "site", "use", "app", "current", "model", "log", "User", "row", "users", "session", "plugin", "name", "creator", "profile", "string", "contact", "bug", "this", "character", "self", "auth", "username", "you", "custom", "connection", "used", "null", "object", "parent", "rule", "config", "author", "per", "update", "message", "post", "resource", "person", "p", "version", "content", "page", "me", "data", "pool", "match", "ro", "USER", "server", "member", "instance", "full", "group", "record", "manager", "response", "module"], "conn": ["exec", "cm", "url", "mc", "client", "ca", "ann", "cache", "util", "uc", "ob", "el", "ou", "reg", "cb", "db", "log", "pt", "connect", "sql", "host", "core", "cr", "cp", "oss", "sth", "lock", "c", "cc", "ci", "org", "ct", "ec", "connection", "Connection", "n", "config", "enc", "loc", "nt", "co", "pub", "sync", "cond", "socket", "dc", "api", "close", "pg", "h", "rc", "col", "cli", "pool", "cn", "ch", "act", "server", "coll", "pc", "con", "nc", "ac", "cat", "Conn", "serv", "part", "conf", "ctx", "ha", "pr"], "autoCommit": ["automaticCommend", "autoCitting", "autoDebite", " autoCommite", "autoCited", "automaticDebIT", "autoRebits", "autoCommits", "autoCommited", "autoDebit", "autoDebmit", " autoComits", " autoCommited", "automaticDebend", "autoCommIT", "autoBlend", "autoComit", "autoComits", " autoDebit", "autoDebitting", "automaticDebmit", "autoBlmit", " autoCommits", " autoDebmit", "autoCmit", "autoRebit", " autoDebited", " autoDebitting", "autoComIT", "automaticCommIT", "automaticDebit", "autoAbitting", "autoBlit", "autoRebite", "autoCommend", "autoCit", " autoCommmit", "autoComite", "autoDebited", "autoAbmit", "autoDebend", "autoCommitting", "autoAbit", "autoAbited", "autoDebits", "automaticCommit", "automaticCommmit", " autoComite", "autoBlIT", "autoCommmit", "autoCommite", "autoDebIT", "autoComend", " autoCommitting", " autoComit"], "deleteRoles": ["deleteRsoles", "destroyRols", "deleteSlole", "deleteLoles", "deleteDoots", "destroyNoots", "deleteGrils", "insertRoases", "deleteLodes", "destroyNols", "deleteDules", "deleteDils", "delLoles", "delLole", "deleteRules", "deleteDases", "deleteRooles", "deleteDole", "deleteNoots", "deleteCases", "deleteSlases", "insertRooles", "deleteDols", "destroyRoots", "insertRoules", "insertRole", "delRoles", "deleteGroles", "deleteRils", "deleteRodes", "deleteRsules", "delLases", "destroyNils", "destroyRils", "insertRases", "deleteRoole", "deleteRoules", "delRole", "deleteRoots", "delRodes", "deleteRsases", "delRases", "deleteLole", "deleteNils", "deleteGrols", "destroyNoles", "deleteRsole", "deleteRole", "deleteRases", "deleteSloles", "deleteNols", "deleteRoases", "deleteRols", "insertRoole", "deleteCodes", "destroyRoles", "deleteCole", "deleteSlodes", "deleteDoles", "deleteGroots", "insertRules", "deleteNoles", "deleteLases", "delLodes", "deleteColes"], "insertRoles": ["updateLols", "insertLoots", "copyRules", "insertGoots", "updateRoles", "insertRsles", "insertRows", "insertLles", "insertLules", "copyRoles", "insertRsules", "insertRodes", " insertShole", "updateLoles", "insertSules", "copyGows", "copyGules", "insertRsoles", "updateRules", " insertRules", " insertSholes", " insertRodes", "insertSodes", "deleteRanges", "insertSloots", "copyRows", " insertRole", "insertRsanges", "insertRsodes", "insertLoles", "insertRoots", "copyGoots", "insertRols", "updateRols", "insertSlanges", "insertSole", "copyGoles", "insertSoles", " insertShules", "copyRoots", "insertRles", "updateLules", "insertSholes", "insertRanges", "insertLols", "insertShole", "insertRules", "insertGules", "insertShules", "insertLows", "deleteSlanges", "deleteSloots", "insertRsoots", "updateRles", "insertRsows", " insertShodes", "insertRole", "deleteRodes", "insertSloles", "insertGoles", "insertSlodes", "deleteRoots", "updateLles", "deleteSloles", "insertRsols", "deleteSlodes", "insertGows", "insertShodes"], "role": ["shadow", "slave", "de", "base", "error", "alias", "force", "Role", "relation", "one", "rol", "function", "row", "val", "label", "string", "profile", "range", "to", "link", "or", "username", "zone", "type", "repl", "route", "tag", "rule", "guard", "service", "resource", "key", "l", "entry", "roller", "ro", "member", "ole", "group", "rl", "tool", "le", "module"]}}
{"id1": "18891988", "id2": "9261777", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["GetString", "GetFilename", "downloadFile", "loadFile", "loadfile", "downloadfile", "getfile", "getFilename", "Getfile", "getString", "loadString", "downloadFilename", "GetFile", "downloadString", "loadFilename"], "serviceName": ["ServiceName", "projectType", " servicePath", "ServicePath", "Servicename", " serviceType", " servicename", "packagename", "servicePath", "ServiceType", "projectUrl", " serviceUrl", "servicename", "projectPath", "ServiceUrl", "packagePath", "serviceType", "packageName", "serviceUrl", "packageUrl", "projectName"], "wsdlLocation": ["wllFolder", "wssdFolder", "awsdlLocation", "wddlLocation", "awslDirectory", "wsllFolder", "wssdAddress", "wsDLUrl", "wslLocation", "wslpDirectory", "wslUrl", "wsllAddress", "wdlAddress", "wslFile", "awslFile", "wsslFolder", "wdlFile", "wddlFile", "wdlFolder", "wllFile", "wslpLocation", "awsdlDirectory", "awslUrl", "wslDirectory", "awsdlFile", "wslFolder", "wsdlDirectory", "wddlFolder", "wsllLocation", "wsDLFile", "wsslLocation", "wsdlFolder", "wsDLLocation", "awsdlUrl", "wsllUrl", "wsslFile", "wllLocation", "wssdLocation", "wddlDirectory", "wsdlFile", "wsdlUrl", "wsslAddress", "wsdlAddress", "wsllFile", "wdlDirectory", "wslpFolder", "wdlLocation", "wssdFile", "wslpFile", "wllAddress", "awslLocation", "wsDLDirectory", "wsllDirectory"], "endpoint": ["endPoint", "endination", "enPoint", " endaddress", "Endword", "endpointer", " endocol", " endPoint", " endpo", "EndPoint", "Endination", "Endpoint", "ENDpoint", "enpointer", "endsword", "startaddress", "endpo", "startpointer", "Endpoints", "startPoint", " endword", "ENDpoints", "endword", "enaddress", "enination", "endsocol", "startpoint", "enpoint", "ENDPoint", " endpointer", "endspo", "endaddress", "Endocol", "endspoint", "endocol", "enpoints", "endpoints", "ENDination", "Endpo"], "fileLocation": ["FILEUrl", " fileURI", "FileURI", " fileUrl", "fileURI", " fileDirectory", "FILEDirectory", "fileUrl", "fileDirectory", "FileDirectory", "FILELocation", "FileLocation", "FileUrl", "FILEURI"], "tempDir": [" temporaryPath", "TempDirectory", " tempVer", "tmpDir", " tempDirectory", "tmpPath", "TempPath", " tempdir", " tempPath", "TempDir", "tmpDirectory", "tempdir", "Tempdir", "tempDirectory", "tmpVer", " temporaryVer", " temporaryDir", "tempVer", "tempPath", "tmpdir", " temporaryDirectory"], "url": ["address", "base", "client", "el", "io", "URL", "path", "log", "fl", "sl", "Url", "host", "string", "conn", "ls", "contact", "stream", "image", "ssl", "connection", "ll", "www", "config", "pull", "socket", "ur", "ul", "uri", "service", "http", "l", "source", "file", "server", "channel", "download", "coll", "open", "web", "f"], "WSDLFile": ["WDDlBase", "WSDLLFile", "WINDELPath", "WDDLFolder", "WDDLFile", "WDDlFile", "WDDLBase", "WSDDLFile", "WSDlPath", "WSDLfile", "WSDlBase", "WSDLLFiles", "WDDlFolder", "WDDLfile", "WSDLSourceFile", "WSDDLFolder", "WDDlPath", "WSDLFiles", "WSDLLFolder", "WSDLLSourceFile", "WDDlfile", "WSDELFolder", "WINDLFile", "WSDlFolder", "WSDLPath", "WINDELFiles", "WSDlfile", "WDDLPath", "WSDDLBase", "WSDELFile", "WSDLLBase", "WINDELFolder", "WSDDLfile", "WSDDLFiles", "WSDDLPath", "WINDELFile", "WSDLLfile", "WSDlFile", "WSDELFiles", "WSDlSourceFile", "WSDDLSourceFile", "WINDLFolder", "WSDLLPath", "WSDLBase", "WDDlSourceFile", "WDDLSourceFile", "WSDLFolder", "WSDELPath", "WINDLFiles", "WINDLPath"], "tmpWSDLFile": ["tmpWDDELUrl", "tmpWSDDLLocation", "tmpWSDELFile", "tmpWSDDLFiles", "tmpWSDLLocation", "tmpWDDELFile", "tmpWDDlFile", "tmpWSDLFiles", "tmpWSDlFolder", "tmpWSDLLFolder", "tmpWDDLFile", "tmpWSDELFiles", "tmpWSDlLocation", "tmpWDDLLocation", "tmpWSDlFiles", "tmpWSDlFile", "tmpWDDlFolder", "tmpWDDLUrl", "tmpWSDlUrl", "tmpWSDLLFile", "tmpWSDLFolder", "tmpWDDELLocation", "tmpWSDELFolder", "tmpWSDELUrl", "tmpWDDlFiles", "tmpWSDLLUrl", "tmpWSDLUrl", "tmpWDDlUrl", "tmpWDDELFiles", "tmpWSDDLFile", "tmpWDDLFiles", "tmpWSDLLFiles", "tmpWDDLFolder", "tmpWSDDLUrl", "tmpWSDELLocation"], "inputFile": ["outputDir", " inputFactory", "InputFactory", "inputDir", " inputStream", "Inputfile", " inputFiles", " inputBuffer", "tempBuffer", " inputPage", "tempPlace", "requestfile", "InputDir", "inFile", " inputBase", "inputPage", "InputFile", "inputFactory", "tempUrl", "infile", "inputStream", "tempFactory", "tempPage", "tempFile", "tempBase", "InputUrl", "InputFiles", " inputfile", " inputUrl", "InputPlace", "inputFiles", " inputPlace", "outputFiles", "outputfile", "requestStream", "InputBuffer", "requestFiles", "inputPlace", "inputUrl", "inputBase", " inputDir", "requestFile", "inDir", "tempfile", "InputBase", "inputBuffer", "InputPage", "inPage", "InputStream", "outputFile", "inputfile"], "tmpFile": ["TempFiles", " tmpFiles", "TempDirectory", " tmpDirectory", "uploadStream", "tempDocument", "uploadFile", "TempFile", "inputDocument", "tmpStream", "inputStream", "tempPage", "tempFile", "tmpDirectory", "tmpPage", "tempDirectory", "inputFiles", "tempStream", "TempPage", "tempFiles", "tmpFiles", "uploadDocument", " tmpPage", "uploadFiles"], "in": ["gin", "ins", "din", "reader", "IN", "client", "login", "bin", "id", "inc", "input", "In", "conn", "on", "inner", "image", "c", "lock", "m", "ssl", "connection", "r", "again", "socket", "win", "inn", "p", "pin", "is", "l", "data", "source", "file", "up", "lin", "init", "impl", "f"], "out": ["net", "error", "OUT", "client", "outs", "IN", "cache", "output", "bin", "io", "inc", "log", "input", "conn", "conv", "on", "inner", "In", "name", "to", "image", "err", "c", "Out", "writer", "connection", "again", "parent", "o", "co", "socket", "sync", "outer", "timeout", "copy", "line", "source", "channel", "file", "up", "ch", "server", "group", "part", "conf", "can"], "con": ["bc", "cm", "gin", "ins", "thin", "uc", "client", "IN", "un", "ran", "com", "inc", "connect", "conn", "conv", "inner", "c", "plain", "en", "ssl", "connection", "rec", "co", "fc", "socket", "sync", "Con", "win", "close", "CON", "rc", "channel", "ch", "cn", "kin", "nc", "Conn", "open", "ctrl", "conf", "can"], "fileLength": ["Filelength", " fileSize", "FileWidth", "channelWidth", "contentLen", " fileLen", "channelLen", "fileWidth", "FileLength", "filelength", "fileLen", " filelength", "contentlength", " fileWidth", "FileSize", "channelSize", "fileSize", "contentLength", "channelLength", "contentSize", "FileLen"], "channelIn": ["ChannelOut", "characterIN", "connectionOut", "Channelin", "characterin", "resourceIN", "connectionIn", "ChannelIN", " channelIN", "channelConn", "connectionConn", "resourcein", " channelConn", "characterOut", "resourceIn", "ChannelConn", "resourceOut", "ChannelIn", "connectionin", "channelIN", " channelin", "channelin", "characterIn"], "channelOut": ["chanOUT", "ChannelOut", "connectionOutput", "connectionOut", "ChannelOutput", "ChannelOutside", " channelOutput", "connectionIn", "channelOutside", "channelout", "connectionOutside", "connectionout", "channelOutput", "channelOUT", "ChannelOUT", "canIn", "canOUT", "ChannelIn", " channelout", "canOut", "chanOut", "canOutside", "chanOutside", "chanIn", "chanout", "Channelout"], "tmpDocument": ["tmpDoc", "tmFile", "tmNode", "newContent", " tmpDoc", "mpDoc", "tmpNode", "newFile", "tempDoc", " tmpContent", "tempdocument", "tempDocument", " tmpNode", "mpDocument", "tmpContent", "tempFile", "newDocument", "tmpdocument", "tempContent", "mpFile", "tmDocument", " tmpdocument", "newdocument", "mpNode", "tempNode", "tmdocument"], "nl1": ["dl1", "arlone", "dl0", "NL11", "kl1", "ln1", "klFirst", "nl5", "ln6", "arlFirst", "ln2", "klone", "arl5", "nl6", "nn11", "NL6", "NL0", "nn6", "nl11", "jl1", "nl0", "jlone", "jl5", "dl2", "kl5", "nn2", "nn0", "nl2", "nlFirst", "NL2", "nlone", "nn1", "ln11", "jlFirst", "NL1", "arl1"], "i": ["qi", "v", "z", "ip", "ai", "ti", "I", "uli", "e", "id", "io", "iu", "xi", "ini", "index", "eni", "ui", "li", "u", "hi", "multi", "ci", "si", "mi", "phi", "ii", "m", "y", "j", "ie", "info", "b", "n", "o", "slice", "ri", "uri", "p", "ix", "gi", "fi", "it", "abi", "di", "oi", "l", "ni", "d", "chi", "yi", "ji", "f", "part", "mu", "bi", "pi"], "node1": ["package91", "Node91", "packageOne", "NodeOne", "packageone", "Node0", "shape1", " node91", "node2", "layer91", "layer1", "n0", "layerOne", "n1", "n2", "node0", "nOne", "Node1", "package1", "layer2", "shapeone", "nodeOne", " nodeone", " node0", "nodeone", "shapeOne", "node91", "shape91", " nodeOne", " node2", "Node2"], "tmpOut": [" tmpOUT", "txtOut", "vmOUT", "ptyOut", " tmpWriter", "tempOUT", "tempWriter", "txtOutput", "tempIn", "ptyIn", "tempOut", "tmpWriter", "vmOut", "tempFile", "ptyOutput", "cacheFile", "tempout", "tmpOUT", "tempOutput", "txtout", "cacheOut", "txtWriter", "cacheOUT", "vmIn", "ptyout", "tmpout", " tmpIn", "cacheIn", "tmpIn", " tmpout", "tmpOutput", " tmpOutput", "vmout"], "retVal": ["valRet", "valval", "retObj", "retval", " retval", "retRet", "RETval", "RETObj", " retObj", " retRet", "valObj", "valVal", "RETVal", "RETRet"]}}
{"id1": "812803", "id2": "5725177", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    @Override\n    protected <T> T execute(final HttpMethod method, final String url, Parameters parameters, final Handler<T> handler) throws FoursquareException {\n        HttpURLConnection connection = null;\n        try {\n            switch(method) {\n                case GET:\n                    connection = openConnection(url.concat(\"?\").concat(formEncode(parameters)));\n                    connection.setRequestMethod(\"GET\");\n                    connection.connect();\n                    break;\n                case POST:\n                    connection = openConnection(url);\n                    connection.setRequestMethod(\"POST\");\n                    connection.setDoOutput(true);\n                    connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                    connection.connect();\n                    final OutputStream out = connection.getOutputStream();\n                    out.write(formEncode(parameters).getBytes());\n                    out.flush();\n                    out.close();\n                    break;\n            }\n            final int statusCode = connection.getResponseCode();\n            if (statusCode / 100 != 2) {\n                final Error error = parseBody(connection.getErrorStream(), new ErrorHandler());\n                if (error == null) throw new FoursquareException(connection.getResponseMessage()); else if (\"error\".equals(error.getType())) throw new FoursquareException(error.getMessage()); else if (\"unauthorized\".equals(error.getType())) throw new AuthenticationException(error.getMessage()); else if (\"ratelimited\".equals(error.getType())) throw new RateLimitingException(error.getMessage()); else throw new FoursquareException(connection.getResponseMessage());\n            }\n            return parseBody(connection.getInputStream(), handler);\n        } catch (final IOException e) {\n            throw new FoursquareException(e);\n        } catch (final ParserConfigurationException e) {\n            throw new FoursquareException(e);\n        } catch (final SAXException e) {\n            throw new FoursquareException(e);\n        } finally {\n            if (connection != null) connection.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["CONception", " deconversion", "Converted", "oconversion", "subversion", "CONverted", "unception", "subverting", "CONvert", "subverted", "unvert", "unverted", "Conception", "CONverting", " deconverting", "oconverted", "Conversion", "Converting", "CONversion", "oconvert", " deconverted", "conception", "converting", "subvert", "oconverting", "Convert", "conversion", "converted", "unversion", " deconvert"], "src": ["sys", "ource", "fp", "url", "sit", "prot", "st", "img", "reader", "gb", "tmp", "load", "cb", "proc", "scene", "path", "input", "filename", "string", "name", "obj", "s", "stream", "secure", "sth", "Source", "spec", "upload", "storage", "sel", "code", "username", "SourceFile", "ssl", "sb", "component", "Dest", "supp", "buf", "video", "sin", "attr", "back", "config", "loc", "slice", "inst", "sn", "uri", "resource", "rb", "feat", "rc", "href", "source", "fn", "sc", "file", "download", "ref", "RC", "gz", "dist", "req", "stage", "impl", "cpp", "rl", "ctx", "cmp"], "dest": ["disk", "test", "cont", "img", "bin", "tmp", "path", "target", "obj", "lib", "std", " dst", "Dest", "class", "dat", "orig", "null", "dc", "di", "source", "fn", "dir", "dist", " destination", "home", "txt", "temp"], "in": ["ins", "din", "reader", "IN", "login", "bin", "isin", "inc", "io", "ini", "val", "input", "In", "stream", "err", "doc", "inas", "t", "a", "i", "r", "ex", "n", "ps", "win", "inn", "inf", "pin", "is", "data", "source", "up", "file", "d", "pass", "as", "f"], "p": ["fp", "jp", "v", "pa", "tp", "bp", "e", "lp", "pre", "pm", "P", "py", "pr", "s", "cp", "c", "np", "m", "t", "j", "i", "r", "pe", "g", "b", "cop", "o", "ps", "per", "parser", "pd", "pg", "h", "wp", "l", "op", "pb", "d", "pc", "pp", "sp", "part", "f", "pi", "po"], "ds": ["posts", " DS", "eps", "dp", "ths", "vs", "els", "os", " ps", "dat", "ps", " sd", "pd", "uds", "data", "qs", "utils", "points", "rs", "services", "da", "groups", "db", "docs", "s", "ls", "hs", "words", "ys", "models", "cs", "ans", "di", "ld", "cons", "gs", "ins", "xs", "ges", "ts", "nas", "ks", "sts", "ded", "lines", "vals", "js", "ups", "plugins", "dates", "ants", "dds", "ss", "scripts", "tests", "ils", "ads", "sys", "Ds", "ays", "dl", "lp", "tools", "df", "ns", "styles", "dd", "gd", "des", "dos", "sync", " props", "dc", "parts", "dt", "obs", "dist", "amps", "d", "DS", "icks", "dm", "ipes", "bs"], "format": ["template", "atter", "url", "fp", "magic", "model", "path", "function", "plugin", "host", "pattern", "filename", "string", "nat", "language", "struct", "name", "prefix", "spec", "t", "type", "at", "Format", "class", "tag", "handler", "config", "layout", "sche", "table", "parser", "api", "version", "scale", "form", "feat", "fd", "data", "source", "file", "filter", "letter", "ant", "fn", "style", "act", "frame", "unit", "part", "record", "f"], "hasPixelData": ["hasByteData", "showsPixelDATA", "hasPictureSize", "haspixelSize", " hasPixelSize", " hasPixeldata", "showsByteData", "showsByteStyle", "showsBytedata", "showsPixeldata", "hasPixelSize", "hasPicturedata", "showsPixelStyle", "hasByteSize", "hasPixelDATA", "hasPictureData", "hasPixeldata", "hasByteStyle", "haspixelData", "showsByteDATA", "haspixeldata", "hasPixelStyle", "hasBytedata", "showsPixelData", "hasByteDATA"], "inflate": ["inflace", "invenATE", "Inflation", "inFlate", "inflating", "infolode", "insvenate", "inFlation", "insvenATE", "invenode", "insvenating", "inflated", "Inflated", "inadequode", "inadequate", "inffation", "invenate", "insflate", "inflATE", "Inflate", "infloated", "inFlated", "infface", "InFlate", "insflATE", "Inflace", "InFlace", "inadequATE", "insflating", "inFlace", "infloate", "InFlation", "infloation", "insvenode", "inflode", "infolATE", "infloace", "inffate", "infolate", "inflation", "invenating", "inadequating", "InFlated", "insflode", "infolating", "inffated"], "pxlen": ["mxlen", "pxsize", "mxdata", "fxlen", "pgLen", "mxcount", "pgl", "fxden", "pxdata", "fxl", "axlon", "pxl", "pxlength", "pxlon", "pnglength", "xpsize", "pplen", "mxsize", "txlon", "axln", "pclin", "camlen", "pxLen", "camdata", "fxLen", "pxden", "pglen", "pxcount", "pxpos", "fxpos", "pclen", "txlen", "pxln", "pxlin", "campos", "txln", "fxdata", "pclon", "camln", "txlin", "xplen", "xplength", "fxln", "axlin", "ppden", "mxlength", "ppl", "pgden", "pnglen", "ppLen", "pngsize", "mxpos", "pngcount", "axlen", "xpcount", "mxln", "pcln"], "out": ["sys", "v", "error", "OUT", "outs", "cache", "gen", "re", "output", "io", "log", "session", "conn", "obj", "state", "lock", "err", "Out", "step", "lib", "user", "again", "parent", "co", "query", "list", "pad", "post", "copy", "point", "store", "cli", "line", "work", "up", "server", "page", "dump", "group", "inter"]}}
{"id1": "22338097", "id2": "1235538", "code1": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 1, "substitutes": {"createMD5": ["createmd5", " createMD2", "createmd256", "createSHA256", " createMD512", "createMAC512", "createmd512", " createSHA512", "createSHA2", "createMD2", "createSHA5", "createSHA512", " createSHA2", " createSHA5", "createMAC256", "createMAC5", " createMD256", " createSHA256", "createMD256", "createmd2", "createMAC2", "createMD512"], "pwd": [" pWD", " ppassword", " pwm", " pw", "Pw", "PWD", "hWD", "cw", "cwd", "Pwd", "Pwm", "hw", "pWD", "pw", "Ppassword", "hwd", "hwm", "ppassword", "cWD", "pwm", "cpassword"], "md": ["MD", "cm", "de", "mc", "dig", "metadata", "rm", "tmp", "pm", "bd", "amd", "am", "df", "mo", "meta", "mk", "mb", "py", "um", "mt", "ind", "cmd", "hd", "pkg", "mand", "m", "dd", "gd", "od", "mg", "mm", "ad", "cd", "wd", "mac", "hm", "mod", "di", "d", "mag", "bf", "vd", "dm", " MD", "mp", "po"], "pd": ["sv", "da", "tp", "pat", "dl", "dp", "lp", "bd", "pm", "py", "ped", "ppo", "cp", "hd", "np", "PD", "std", "dd", "pid", "pe", "gd", "ppa", "sd", "ps", "od", "td", "pins", "ds", "cd", "p", "wd", "pg", "fd", "wp", "pb", "xd", "ld", "d", "pc", "vd", "pp", "pi", "po"], "app": ["cmp", "test", "bc", "cap", "ip", "amp", "cache", "apply", "bb", "ap", "allow", "arr", "container", "db", "ask", "py", "fb", "host", "keep", "string", "s", "fac", "acc", "buff", "sb", "html", "ape", "application", "b", "g", "aa", "pad", "APP", "apps", "pack", "array", "api", "ab", "p", "App", "buffer", "form", "mac", "page", "data", "append", "ch", "instance", "ac", "pp", "sp", "ang", "conf", "ce", "mp", "cell", "msg"], "i": ["qi", "v", "z", "ip", "ai", "ti", "I", "uli", "e", "id", "io", "xi", "x", "ini", "index", "end", "u", "li", "ui", "s", "hi", "inner", "multi", "c", "ci", "si", "ii", "t", "j", "ori", "info", "b", "n", "o", "zi", "bi", "slice", "ri", "uri", "p", "key", "gi", "ix", "fi", "abi", "l", "oi", "data", "di", "ni", "d", "chi", "ji", "mu", "f", "pi"], "s2": ["p182", "p3", "passtwo", "pass2", "sl2", " s3", "sl182", "dstwo", "s12", "pass12", "stwo", "pass1", "p12", "s182", " s12", "p1", "sestwo", "p2", "s1", "ses6", "ds2", " s182", "sl1", "ses2", " s1", "s6", " s6", "ds6", " salt", "salt", "ptwo", "palt", " stwo", "s3"]}}
{"id1": "2168610", "id2": "23620712", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"update": ["complete", "address", "position", "result", "error", "Update", "send", "grade", "change", "save", "updated", "delete", "status", "apply", "use", "view", "id", "current", "load", "inc", "put", "family", "replace", "check", "index", "patch", "name", "end", "state", "bug", "range", "lock", "set", "write", "database", "where", "handle", "build", "event", "ite", "connection", "fill", "text", "config", "edit", "diff", "future", "pull", "sync", "message", "date", "resource", "version", "timeout", "add", "UPDATE", "get", "insert", "http", "up", "width", "create", "instance", "value", "draw", "unit", "open", "response", "run"], "o": ["oe", "k", "ob", "e", "ou", "none", "one", "oo", "mo", "ao", "ono", "conn", "obj", "c", "oid", "bo", "os", "m", "or", "t", "connection", "n", "object", "so", "online", "co", "od", "office", " object", "p", " O", "ion", "oi", "O", "oa", "f", "po"], "contact": ["campaign", "cmp", "address", "lc", "result", "account", "client", "lead", "project", "call", "phone", "feed", "relation", "ace", "model", "check", "connect", "cc", "character", "company", "choice", " Contact", "event", "communication", "charge", "connection", "report", "info", "object", "front", "config", "co", "sync", "concept", "Contact", "office", "date", "conference", "content", "form", "point", "cart", "match", "entry", "act", "work", "email", "fax", "contract", "coll", "collection", "product", "control", "f", "cell"], "pst": ["wpst", "lpST", "epcr", "Psc", "psl", " put", "Pste", "preste", "post", "Pdd", "spst", "Psts", "psts", "psp", "sput", "prsl", "lptd", " pct", "lpsts", "pdd", " pste", "put", "epst", "wpcr", "prect", " psp", "pssl", "pstd", "lpcr", "prtd", "prsta", "Pst", "pste", "Pcr", "PST", "opst", "prsts", "prost", "prest", "pssts", "prsp", "wpsh", "prste", "epST", "opste", "psst", " psl", "spct", "spste", "pct", "lpst", "psta", "prdd", "psc", " post", "preut", " pdd", "psh", "Pct", "prsc", "pST", " pST", " ptd", "prST", " psh", "opsts", " psts", " psta", "prcr", "Psp", "pcr", "wptd", "ptd", "opct", "prst", "epsts", "lpsta", " pcr", " psc", "Post", "lpsh", "prct"]}}
{"id1": "10795866", "id2": "7499186", "code1": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"upload": ["url", "clean", "save", "delete", "output", "view", "transfer", "zip", "load", "stream", "image", " Upload", "info", "report", "transform", "post", "Upload", " thumbnail", "process", "up", "download", "create", "dump", "full", " transform", "open", "paste", "run"], "destDir": ["DestDIR", "srcdir", "destdir", "srcDIR", "destFile", "DestDirectory", "srcDir", "distDIR", "srcFile", "Destdir", "destDIR", "DestFile", "destPath", "srcPath", "distDir", "DestDir", " destPath", "distdir", "DestPath", "srcDirectory", " destDirectory", "distFile", "destDirectory", " destdir"], "fos": ["foo", "Fo", " foss", "fdios", "nos", "FOS", " fis", "poses", "fOS", "sfOS", "sfos", "lo", "Foses", "foss", " faos", " fOS", " foses", "Fos", "no", " fo", "fios", "nows", "lOS", "foows", "sfis", "Fios", "lis", "fooss", "fis", "foser", "fdos", "los", "sfo", "paos", " fios", "Foser", "fo", "fdOS", "foses", "pos", "noss", "faos", "fows", "Faos", "fdoser", " fows", " foser", "foos", "po"]}}
{"id1": "9805906", "id2": "8216539", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"dump": ["ump", "save", "transfer", "Dir", "zip", "load", "db", "df", " dumps", "export", "out", "ln", " dumping", "files", " dumped", "all", "info", "println", "diff", "update", "flush", "copy", "store", "data", "dir", "download", "f"], "source": ["ource", "slave", "address", "base", "view", "site", "use", "current", "scene", "series", "remote", "input", "start", "core", "string", "s", "stream", "Source", "this", "connection", "parent", "sin", "slice", "ources", "uri", "service", "resource", "iter", "from", "http", "file", "server", "se", "src", "unit", "SOURCE"], "target": ["template", "address", "result", "base", "master", "alias", "arget", "project", "follow", "output", "port", "platform", "force", "replace", "path", "goal", "pointer", "host", "out", "top", "effect", "to", "next", "database", "large", "Target", "connection", "root", "enemy", "null", "object", "parent", "dest", "table", "office", "resource", "it", "file", "src", "settings"], "is": ["us", "im", "ais", "ip", "ins", "ai", "ois", "iso", "isa", "was", "io", "has", "IS", "bis", "ws", "Is", "es", "oss", "abs", "ui", "s", "ris", "ls", "isl", "iss", "ios", "ses", "nis", "or", "bos", "ori", "i", "info", "cs", "ops", "lis", "ps", "isi", "ics", "oses", "opens", "iris", "gets", "obs", "in", "ists", "its", "ens", "as", "bs", "mis"], "os": ["us", "ais", "OS", "osi", "Os", "nos", "outs", "io", "aos", "vs", "boot", "es", "ies", "oss", "ks", "ues", "s", "oes", "ios", "or", "bos", "ori", "i", "oos", "acs", "dos", "cs", "ops", "ose", "o", "ps", "ows", "oses", "ds", "los", "fs", "ols", "its", "ips", "obs", "cos", "oa", "ens", "pos", "ros", "as", "ss", "bs"], "done": ["complete", "foo", "defined", "de", "doing", "odo", "started", "yes", "after", "current", "nice", "progress", "ready", "got", "none", "one", "enabled", "always", "finished", "made", "next", " Done", "dirty", "checked", "confirmed", "running", "gone", "empty", "did", "dad", "future", "disabled", "loaded", " finished", "once", "data", "last", "due", "die", "later", "part", "Done", "expected"]}}
{"id1": "16232202", "id2": "20210699", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"doPost": [" doSend", "doingPOST", "doPOST", " doPut", " doPOST", "didPOST", "doingPut", "didPost", "doingPost", "didPut", "doSend", "doPut", "didSend", "doingSend"], "request": ["complete", "external", "url", "result", "error", "reader", "client", "save", "project", "re", "enter", "parse", "view", "e", "QUEST", "use", "current", "load", "child", "xml", "rf", "remote", "input", "session", "er", "q", "context", "row", "state", "queue", "image", "order", "next", "upload", "self", "rate", "event", "type", "you", "info", "method", "report", "user", "application", "route", "object", "parent", "join", "query", "list", "press", "hello", "post", "message", "resource", "condition", "Request", "get", "submit", "store", "page", "data", "server", "subject", "req", "instance", "create", "register", "initial", "web", "select"], "response": ["complete", "su", "wa", "result", "de", "esi", "error", "status", "re", "output", "view", "site", "exit", "feed", "e", "model", "Response", "shell", "environment", "fire", "index", "session", "res", "image", "next", "respond", "we", "en", "writer", "forward", "report", "application", "object", "parent", "ception", "body", "query", " Response", "message", "ae", "service", "resource", "api", "tree", "uri", "document", "http", "page", "resp", "server", "subject", "pool", "reply", "onse", "serv", "web"], "cu": ["hu", "su", "lc", "cf", "tu", "mc", "cy", "uc", "ca", "ue", "uci", "CI", "U", "ou", "chu", "cul", "cur", "tc", "ku", "cci", "u", "ui", "aca", "CU", "uni", "ci", "c", "asu", "cc", "lu", "cca", "nu", "eu", "cum", "co", "loc", "usa", "cus", "ru", "ul", "CA", "du", "uu", "Cu", "UC", "ucc", "agu", "cin", "cli", "vc", "rc", "VC", "coll", "ac", "gu", "xc", "ce"], "ud": ["su", "us", "uf", "tu", "udi", "da", "uc", "ue", "util", "ada", "gb", "uli", "ou", "chu", "db", "um", "df", "wik", "ku", "u", "ui", "li", "bug", "ci", "asu", "upload", "uv", "storage", "UD", "auth", "lu", "dd", "au", "uda", "user", "ut", "ub", "eu", "ug", "od", "usa", "cus", "pub", "ru", "ur", "pd", "du", "uri", "ad", "uds", "ck", "rc", "stri", "cli", "usr", "vd", "uid", "utils", "usc", "gu", "uu"], "returnTo": ["accessTo", "replyFrom", "accessFrom", "outputTO", "exitTo", "ReturnTo", "accessTO", "ReturnFrom", "Returnto", "exitto", "outputFrom", "ReturnTO", "outputTo", "returnTO", "outputto", "replyTo", "exitTO", "returnFrom", "backto", "backTo", "exitFrom", "replyto", "backFrom", "backTO", "accessto", "replyTO", "returnto"], "password": ["address", "encrypted", "sha", "pa", "account", "params", "token", "Password", "login", "sword", "wallet", "mask", "patch", "name", "string", "word", "code", "auth", "username", "crypt", "confirmed", "user", "null", "ass", "diff", "pad", "padding", "message", "wd", "key", "mac", "pg", "phrase", "data", "PASS", "email", "secret", "sum"], "md": ["mad", "MD", " Md", "mc", "sha", "ms", "rm", "bd", "amd", "db", "am", "df", "mo", "meta", "mb", "mt", "cmd", "hd", "sm", "rpm", "mand", "m", "dd", "od", "mg", "diff", "mm", "ma", "dc", "cd", "managed", "wd", "mac", "mn", "mp", "pg", "d", "mag", "vd", "dm", "f", " MD", "dig"], "hash": ["url", "base", "sha", "ash", "cache", "rh", "raw", "db", "Hash", "total", "row", "dot", "kh", "no", "hex", "code", "auth", "confirmed", "user", "number", "tag", "hed", "ass", "block", "diff", "her", "array", "version", "key", "mac", "h", "sh", "char", "secret", "ref", "sum", "dig"], "pass": ["pa", "mess", "gen", "login", "id", "sign", " def", "db", "ask", "sl", "row", "string", "conn", " login", "auth", " secret", "sum", "r", "def", "user", "text", "az", "ass", "diff", "strip", "wd", "key", " passed", " Pass", "mac", "phrase", "PASS", " auth", "act", "push", "secret", "pos", "ref", "fail", " mess", "ss", " mac", "conf", "Pass"], "vis": ["su", "wa", "lit", "ip", "stat", "status", "ravis", "view", "id", "exp", "sign", "circ", "VIS", "skip", "cross", "design", "host", "nat", "keep", "name", "state", "mit", "rib", "c", "virt", "acc", "miss", "type", "travel", "class", "ex", "vid", "san", "shape", "mis", "see", "vest", "att", "press", "dc", "access", "lab", "feat", "na", "vert", "qa", "act", "style", "nav", "secret", "Vis", "visible", "coll", "tri", "spot", "ref", "nic", "gu", "fac"]}}
