{"code": "\"\"\"Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  \"\"\"\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, C=None, **ignore):\n      P = map(int, infile.next().split())\n      return locals()\n  \n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      R, C, M = P\n      MM = M\n  \n      F = np.array([['.'] * C] * R)\n      while M > 0:\n          if R >= C and M >= C and R > 2:\n              M -= C\n              R -= 1\n              F[R] = '*'\n          elif C > R  and M >= R and C > 2:\n              M -= R\n              C -= 1\n              F[:, C] = '*'\n          elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):\n              if M < C - 1:\n                  R -= 1\n                  F[R, C - M:C] = '*'\n              elif M < R - 1:\n                  C -= 1\n                  F[R - M:R, C] = '*'\n              elif M == C - 1:\n                  R -= 1\n                  F[R, C - M + 1:C] = '*'\n                  F[R - 1, C - 1] = '*'\n              else:\n                  C -= 1\n                  F[R - M + 1:R, C] = '*'\n                  F[R - 1, C - 1] = '*'\n              M = 0\n          elif M == R * C - 1:\n              F[:, :] = '*'\n              M = 0\n          else:\n              return 'Case #%s:\n%s\n' % (testcase, 'Impossible')\n  \n      F[0, 0] = 'c'\n      assert (F == '*').sum() == MM\n      return 'Case #%s:\n%s\n' % (testcase, '\n'.join(''.join(f.tolist()) for f in F))\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n", "substitutes": {"infile": ["INfiles", "Infile", "INfilename", "Infilename", "infiles", "inputile", "inifile", " infilename", "inifiles", "INpath", "infilename", " inile", "outstream", "inputstream", "Infiles", "outfilename", "inputfiles", " inpath", "inpath", "outpath", "inputfile", "Inile", "inifilename", "inistream", "instream", "outfile", " infiles", "inputfilename", "outfiles", "INfile", "inile"], "testcase": [" testinstance", "testinstance", "testingline", " testline", "Testline", "testCase", "Testcase", " testCase", "testingCase", "Testcases", "testcases", "testinginstance", "TestCase", "testline", "Testinstance", "testingcase", "testingcases", " testcases"], "C": ["NC", "Y", "SC", "Cor", "CNN", "AC", "Cs", "VC", "DC", "CM", "CR", "FC", "Cl", "U", "r", "E", "H", "Size", "G", "CE", "Channel", "W", "CA", "K", "X", "c", "Co", "Sc", " c", "CV", "CC", "Q", "Rec", "CS", "B", "Cu", "Ca", "D", "CI", "GC", "CP", "Ch", "O", "p", "CL", "CH", "EC", "MC", "Mc", "CU", "Count", "CN", "Code", "Any", "A", "L", "V"], "P": ["PS", "Y", "PI", "PM", "PT", "PR", "PN", "U", "E", "H", "G", "W", "K", "X", "PE", "PO", "Q", "B", "D", "SP", "O", "p", "PA", "TP", "PD", "PF", "PC", "NP", "A", "PP", "L", "V", "IP"], "N": ["Y", "NS", "n", "PN", "U", "E", "Num", "G", "H", "W", "K", "NT", "Q", "Ns", "B", "D", "O", "Z", "p", "A", "L", "V"], "I": ["Y", "PI", "J", "SI", "II", "E", "H", "MI", "K", "Is", "Si", "i", "IT", "Q", "B", "IN", "CI", "IJ", "Pi", "O", "LI", "IL", "AI", "V", "IO", "U", "IP"], "T": ["Y", "TN", "t", "TS", "U", "E", "H", "G", "W", "K", "X", "Q", "B", "D", "O", "TT", "Z", "AT", "A", "L", "V"], "S": ["PS", "Y", "SC", "NS", "SA", "SI", "SE", "U", "Sa", "G", "SR", "SL", "s", "Si", "SS", "Sl", "Q", "SN", "SO", "SP", "O", "SH", "A", "V", "SU"], "R": ["UR", "A", "Rh", "Y", "TR", "GR", "Rs", "Range", "RE", "MR", "J", "Cl", "CR", "RH", "DC", "RT", "Re", "Reader", "r", "U", "E", "G", "H", "SR", "RM", "W", "RO", "RF", "Right", "X", "Gr", "c", "K", "Co", "ER", "Q", "DR", "RS", "BR", "Br", "B", "Run", "RP", "AR", "D", "RC", "RG", "Ra", "Ch", "LR", "RN", "RL", "CL", "Group", "RR", "NR", "Line", "WR", " r", "L", "V", "RA"], "M": ["Y", "MD", "PM", "FM", "MS", "MR", "MO", "J", "CM", "Re", "U", "MT", "r", "E", "SM", "G", "H", "MI", "MX", "RM", "W", "DM", "AM", "K", "X", "MP", "NM", "MW", "Q", "TM", "OM", "B", "IN", "MF", "AR", "D", "MB", "LM", "m", "cm", "O", "MA", "CL", "MN", "CH", "Mi", "Me", "Mor", "MC", "Mc", "OR", "IM", "A", "L", "V"], "MM": ["MAX", "CNN", "FM", "FC", "NN", "mm", "MI", "RM", "W", "RF", "X", "MP", "GF", "CC", "max", "MF", "DD", "MB", "D", "cm", "MA", "MC", "Mc", "_"], "F": ["Point", "Y", "FW", "FD", "FO", "FH", "Result", "FM", "TF", "Full", "FC", "CF", "FG", "FP", "WF", "U", "E", "H", "G", "FE", "W", "K", "X", "Test", "File", "Conf", "GF", "Function", "Q", "API", "B", "DF", "MF", "L", "D", "Frame", "O", "Fe", "FT", "Z", "FR", "EF", "FB", "FF", "AF", "Base", "PF", "ELF", "A", "Fs", "V", "FA"], "f": ["x", "fn", "all", "j", "v", "e", "fr", "l", "t", "n", "tf", "fa", "w", "field", "c", "fe", "self", "i", "h", "info", "fit", "conf", "file", "cf", "fi", "m", "b", "fs", "p", "fb", "df", "d", "z", "diff", " fe", "k", "form", "sf"]}}
{"code": "\"\"\"Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  \"\"\"\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, C=None, **ignore):\n      N = int(infile.next())\n      I = [map(int, infile.next().split()) for i in range(4)]\n      T = int(infile.next())\n      S = [map(int, infile.next().split()) for i in range(4)]\n      return locals()\n  \n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      res = set(I[N-1]) & set(S[T-1])\n      if len(res) == 1:\n          res = res.pop()\n      elif len(res) > 1:\n          res = 'Bad magician!'\n      else:\n          res = 'Volunteer cheated!'\n      return 'Case #%s: %s\n' % (testcase, res)\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n", "substitutes": {"infile": ["INfiles", "Infile", "outmodel", "incomplete", "Infilename", "INfilename", "incfiles", "infiles", " inFile", " inf", "Instream", " infilename", "infilename", "insfolder", "ninfilename", "Infiles", "insFile", "incf", "inf", "incfolder", "INcomplete", "INstream", "incFile", "insfile", "incfilename", "ninfile", "INFile", "ninstream", "inmodel", "outf", "incmodel", " infolder", "incstream", "inccomplete", " inmodel", "inFile", "outfile", "instream", "ninFile", " infiles", "outfiles", " instream", "InFile", "incfile", "INfile", "insfilename", " incomplete", "infolder", "INfolder"], "testcase": [" testtype", "testphase", "testclass", " testbase", " testline", "valcases", "Testphase", "testCase", "validclass", "Testcase", " testCase", " testclass", "valphase", "Testcases", "validtype", "testcases", "driverline", " testphase", "valcase", "drivercase", "TestCase", "testline", "outbase", " testcases", "valCase", "outcase", "driverclass", "Testbase", "outCase", "drivertype", "testbase", "validcase", "validline", "testtype"], "C": ["SC", "Cs", "VC", "Cl", "CM", "CR", "CF", "Con", "E", "G", "W", "CA", "K", "X", "c", "R", "CV", "CC", "CS", "Cu", "B", "Ca", "D", "F", "CI", "GC", "CG", "O", "CT", "CL", "EC", "MC", "V", "Case", "Cache", "CN", "M", "L", "U"], "N": ["Y", " n", "NS", "n", "NB", "J", "U", "E", "Num", "H", "G", "NI", "OS", "X", "R", "NT", "Q", "Ns", "B", "D", "F", "O", "RN", "Ni", "Len", "No", "MN", "Ne", "CN", "M", "A", "NA", "L", "V"], "I": ["Y", "PI", "SI", "KI", "TI", "U", "II", "E", "HI", "H", "G", "NI", "MI", "Fi", "W", "IX", "X", "DI", "Si", "R", "API", "B", "IN", "Xi", "CI", "F", "D", "RI", "Pi", "O", "LI", "IL", "IM", "IU", "IO", "M", "Info", "A", "L", "V", "IP"], "i": ["x", "id", "j", "ii", "e", "v", "im", "ip", "l", "ind", "xi", "iu", "li", "it", "o", "c", "ti", "gi", "qi", "si", "ci", "il", "iq", "ai", "b", "p", "pi", "int", "di", "k", "f", "ui"], "T": ["Y", "Total", "Ts", "OUT", "ET", "TN", "PT", "TH", "TF", "DT", "TS", "U", "Length", "E", "G", "Size", "H", "W", "X", "M", "LT", "Time", "R", "TX", "Test", "NT", "Tu", "B", "TA", "D", "F", "WT", "Type", "To", "TO", "TG", "O", "CT", "TT", "Z", "CL", "TPS", "UT", "TB", "Ti", "L", "V"], "S": ["PS", "Y", "SC", "AS", "NS", "SA", "SI", "TS", "SE", "U", "Sa", "G", "SR", "Ps", "SL", "s", "Si", "R", "SS", "Sl", "SN", "RS", "CS", "B", "SO", "SP", "F", "SU", "O", "LS", "SH", "M", "A", "L", "V", "IS"], "P": ["Y", "PI", "PT", "J", "Path", "PN", "U", "E", "G", "H", "W", "Ps", "K", "X", "R", "Q", "B", "D", "F", "Type", "O", "p", "NP", "M", "A", "L", "V", "IP"], "res": ["ps", "remote", "mr", "rr", "err", "rss", "Rs", "cs", "result", "ras", "Result", "our", "key", "RE", "resh", "core", "right", "pres", "r", "os", "repl", "rh", "rec", "cr", "RES", "rez", "rm", "s", "ms", "R", "rel", "reed", "rev", "ress", "resources", "rap", "msg", "reason", "ret", "RS", "reg", "rest", "rus", "req", "vers", "rs", "resolution", "reset", "relations", "details", "results", "response", "rep", "Results", "resource", "rem", "Res", "ros", "error", "obj", "vals", "re", "content", "case", "pr", "pre", "resp"], "common": ["x", "Common", "valid", "other", "specific", "local", "lc", "final", "complete", " Common", "body", "rec", "standard", "record", "known", "regular", "c", "normal", "set", "special", "info", "TC", "name", "total", "tc", "general", "F", "custom", "con", "m", "norm", "extra", "new", "resource", "util", "data", "central", "f", "loc", "temp", "ctx", "shared", "test"], "t": ["x", "e", "l", "n", "ind", "time", "tf", "r", "o", "tt", "g", "c", "normal", "s", "type", "nt", "total", "tc", "y", "out", "tim", "m", "tr", "tp", "p", "b", "d", "tm", "latest", "int", "a", "ts", "f", "temp", "test"]}}
{"code": " def solve():\n      h, w, m = map(int, raw_input().split())\n      if h == 1:\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\n      elif w == 1:\n          for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\n              print c\n      elif h * w - m == 1:\n          print 'c' + '*' * (w - 1)\n          for _ in xrange(h-1):\n              print '*' * w\n      else:\n          m = h * w - m\n          for i in xrange(h-1):\n              for j in xrange(w-1):\n                  t = (i + 2) * 2 + (j + 2) * 2 - 4\n                  r = (i + 2) * (j + 2)\n                  if t <= m <= r:\n                      a = [['*'] * w for _ in xrange(h)]\n                      for k in xrange(i+2):\n                          a[k][0] = '.'\n                          a[k][1] = '.'\n                      for k in xrange(j+2):\n                          a[0][k] = '.'\n                          a[1][k] = '.'\n                      for y, x in product(range(2, i+2), range(2, j+2)):\n                          if y == 1 and x == 1:\n                              continue\n                          if t >= m:\n                              break\n                          a[y][x] = '.'\n                          t += 1\n                      a[0][0] = 'c'\n                      for s in a:\n                          print ''.join(s)\n                      return\n          print 'Impossible'\n  for t in xrange(int(raw_input())):\n      print \"Case #%d:\" % (t + 1)\n      solve()\n", "substitutes": {"h": ["v", "e", "l", "ah", "n", "q", "time", "hs", "rh", "H", "o", "g", "sh", "hi", "ih", "hm", "u", "ph", "oh", "b", "p", "d", "ch", "z", "bh", "wa", "f", "th", "ht"], "w": ["v", "e", "aw", "l", "n", "hw", "q", "wan", "o", "W", "width", "g", "wl", "wt", "ww", "sh", "sw", "wave", "wal", "ws", "ow", "max", "win", "we", "wd", "wh", "u", "wb", "b", "p", "d", "kw", "z", "wall", "wa", "ew", "wx", "work", "f", "word"], "m": ["am", "ym", "v", "e", "mr", "mu", "l", "mi", "n", "q", "mm", "o", "W", "g", "om", "hm", "range", "u", "cm", "mc", "b", "p", "sm", "d", "z", "tm", "md", "f", "ma", "M", "mo"], "c": ["all", "e", "nc", "unc", "cs", "code", "l", "dc", "n", "lc", "cu", "col", "co", "cr", "div", "g", "cf", "mac", "cm", "mc", "b", "p", "C", "d", "ch", "z", "fc", "ct", "cc", "f", "ac"], "_": ["all", "l", "of", "p", "block", "__", "f"], "i": ["id", "ui", "ii", "v", "e", "im", "ip", "l", "n", "q", "xi", "yi", "iu", "it", "li", "o", "ie", "hi", "ih", "si", "I", "iw", "ni", "ci", "ini", "u", "ai", "b", "p", "d", "z", "pi", "int", "f", "io"], "j": ["ji", "v", "e", "ii", "im", "l", "n", "q", "J", "jj", "li", "jc", "o", "js", "g", "sh", "jp", "jl", "py", "jo", "u", "b", "p", "jet", "d", "z", "ja", "ij", "f"], "t": ["tu", "v", "e", "T", "l", "n", "q", "time", "trial", "mt", "it", "lit", "o", "tt", "at", "offset", " T", "g", "tick", "pt", "type", "nt", "total", "ta", "ot", "dt", "u", "tr", "b", "p", "d", "z", "int", "ct", "ts", "f", "temp", "test"], "r": ["v", "e", "l", "br", "n", "q", "right", "rt", "o", "g", "R", "ar", "nr", "sr", "range", "u", "rs", "tr", "b", "p", "d", "z", " R", "re", "f", "er"], "a": ["za", "am", "e", "v", "la", "sa", "l", "array", "n", "code", "ga", "area", "ca", "ha", "fa", "ae", "o", "at", "sta", "aaa", "ar", "aa", "alpha", "au", "ad", "ana", "ta", "an", "u", "ata", "b", "p", "d", "z", "ab", "auto", "f", "ma", "ac", "A", "ba", "va"], "k": ["id", "e", "key", "ik", "ky", "ko", "n", "km", "q", "ok", "kk", "ki", "ck", "ak", "o", "g", "K", "ku", "kn", "ke", "sk", "u", "b", "p", "ch", "kw", "z", "d", "work", "f", "ka", "ks"], "y": ["Y", "ym", "v", "sy", "e", "yr", "yt", "xy", "n", "ny", "q", "vy", "yd", "ay", "yi", "o", "yy", "yn", "ya", "yl", "py", "my", "yx", "u", "zy", "p", "ch", "d", "z", "ey", "ye", "dy", "cy", "yo", "oy"], "x": ["rx", "xe", "e", "v", "xx", "px", "xb", "index", "l", "n", "xy", "tx", "wy", "q", "xi", "xxx", "o", "X", "ex", "ww", "ya", "xp", "xc", "xt", "yx", "u", "dx", "p", "d", "z", "ix", "ax", "dy", "mx", "wx", "xs"], "s": ["e", "v", "sa", "st", "string", "l", "n", "o", "sections", "sets", "space", "g", "services", "series", "storage", "params", "parts", "sb", "ses", "si", "strings", "ss", "str", "S", "b", "p", "span", "d", "ch", "states", "z", "new", "f", "ks"]}}
{"code": "def solve():\n      r1 = int(raw_input())\n      a1 = [map(int, raw_input().split()) for i in xrange(4)]\n      r2 = int(raw_input())\n      a2 = [map(int, raw_input().split()) for i in xrange(4)]\n      ans = -1\n      for i in xrange(1, 17):\n          if i in a1[r1-1] and i in a2[r2-1]:\n              if ans != -1:\n                  return \"Bad magician!\"\n              ans = i\n      if ans == -1:\n          return \"Volunteer cheated!\"\n      return ans\n  for t in xrange(int(raw_input())):\n      print \"Case #%d:\" % (t + 1), solve()\n", "substitutes": {"r1": ["rrOne", "a31", "aOne", "r31", "rg31", " r31", "rg2", "rOne", "rg3", " r3", " rOne", "a3", "rr1", "rr3", "r3", "rg1"], "a1": ["alpha3", " a8", "pone", "alphaone", "alpha8", "aone", "p2", "a11", "p3", "r8", "sa1", "sa2", "alpha2", "saone", "a3", "r11", "alpha11", "a8", " a11", "sa3", "p1", "alpha1"], "i": ["x", "id", "j", "ii", "e", "v", "bi", "multi", "im", "ip", "l", "n", "ind", "ei", "xi", "anti", "r", "iu", "li", "it", "at", "inter", "g", "c", "ti", "ir", "ie", "ar", "s", "chi", " pi", "si", "ih", "ati", "I", "iw", " I", "ni", "ci", "ini", "iq", "u", "m", "ic", "ai", "p", "d", "z", "pi", "int", "a", "f", "io"], "r2": [" r02", "r02", "ar2", " r4", "rbot", "r4", "rc2", "rtbot", "v02", "artwo", "ar8", "rc02", "rt2", "v2", "r8", "vtwo", "rtwo", "vbot", "rc8", "rt02", "rttwo", "ar02", "ar4", "arbot", " r8", "rc4"], "a2": ["A6", "a6", "atwo", "A2", " a6", "Atwo", "A4", "an6", "an5", "alpha4", "alpha2", " a5", "an4", "an2", "a4", "A5", "antwo", " a4", "a5", "alphatwo"], "ans": ["id", "ons", "ents", "ends", "ants", "cons", "ines", "anc", "ana", "can", "anes", "ant", "span", "false", "les", "case", "ANS", "ks", "A", "olds", "ns", "ann", "ees", "atan", "ars", "os", "annels", "amps", " scans", "ays", "rules", "anges", "a", "ones", "scan", "ores", "anned", "ens", "all", "aus", "ds", "cs", "AN", "man", "na", "lan", "s", "anks", "an", "idents", "ats", "faces", "ions", "ams", "x", "ace", "aces", "An", "arts", "ases", "ins", "ane", "anas", "ss", " means", "ed", "ations", "aned"], "t": ["x", "id", "j", "v", "e", "T", "l", "n", "q", "r", "w", "o", "at", "g", "c", "s", "h", "type", "ar", "pt", "ta", "y", "an", "art", "u", "m", "b", "p", "d", "z", "int", "a", "ts", "f", "test"]}}
{"code": " \n  def makeBoardR(b):\n  \tnumR, numC, numMines, filledR, filledC = b\n  \tq = numMines / numR\n  \tr = numMines % numR\n  \n  \tif q <= numC-2 and r == 0:\n  \t\tboard = [\"*\"*(filledC + numC) for x in range (filledR)]\n  \t\tboard.append( \"*\"*(filledC+q)+\".\"*(numC-q) )\n  \t\tboard.append( \"*\"*(filledC+q)+\".\"*(numC-q-1)+\"c\" )\n  \t\toutput = \"\n\".join(board)\n  \telif numMines == numR * numC - 1:\n  \t\tboard = [\"*\"*(filledC + numC) for x in range (filledR+1)]\n  \t\tboard.append( \"*\"*(filledC+numC-1)+\"c\" )\n  \t\toutput = \"\n\".join(board)\n  \telse:\n  \t\toutput = \"Impossible\"\n  \n  \treturn output\n  \n  def makeBoardC(b):\n  \tnumR, numC, numMines, filledR, filledC = b\n  \tq = numMines / numC\n  \tr = numMines % numC\n  \n  \tif q <= numR-2 and r == 0:\n  \t\tboard = [\"*\"*(filledC+numC) for x in range(filledR+q)]\n  \t\tfor x in range( numR-1-q ):\n  \t\t\tboard.append( \"*\"*filledC + \"..\" )\n  \t\tboard.append( \"*\"*filledC + \".c\" )\n  \t\toutput = \"\n\".join(board)\n  \telif numMines == numR * numC - 1:\n  \t\tboard = [\"*\"*(filledC+numC) for x in range(filledR+numR-1)]\n  \t\tboard.append( \"*\"*(filledC+numC-1) + \"c\" )\n  \t\toutput = \"\n\".join(board)\n  \telse:\n  \t\toutput = \"Impossible\"\n  \treturn output\n  \n  def makeBoard(b):\n  \tnumR, numC, numMines, filledR, filledC = b\n  \tq = numMines / (numC-2)\n  \tr = numMines % (numC-2)\n  \n  \tboard = [\"*\"*(numC+filledC) for x in range(filledR)]\n  \tfor x in range(q):\n  \t\tboard.append( \"*\"*(numC-2+filledC)+\"..\" )\n  \tboard.append( \"*\"*(r+filledC)+\".\"*(numC-r) )\n  \tfor x in range(numR-q-2):\n  \t\tboard.append( \"*\"*filledC+\".\"*numC )\n  \tboard.append( \"*\"*filledC + \".\"*(numC-1) + \"c\" )\n  \treturn \"\n\".join(board)\n  \n  def makeBoard0(b):\n  \tnumR,numC,numMines,filledR,filledC = b\n  \tboard = [\"*\"*(numC+filledC) for x in range(filledR)]\n  \tfor x in range(numR-1):\n  \t\tboard.append( \"*\"*(filledC)+\".\"*numC )\n  \tboard.append( \"*\"*(filledC) + \".\"*(numC-1) + \"c\" )\n  \treturn \"\n\".join(board)\n  \n  f = open( sys.argv[1] )\n  f.readline()\n  \n  numCase = 1\n  l = f.readline()\n  while l != \"\":\n  \tnumR, numC, numMines = [int(x) for x in l.split()]\n  \n  \tboards = deque()\n  \tif numR == 1:\n  \t\tif numC == 1 and numMines == 0:\n  \t\t\toutput = \"c\"\n  \t\telif numC == 1 and numMines > 0:\n  \t\t\toutput = \"Impossible\"\n  \t\telse:\n  \t\t\toutput = \"*\"*numMines + \".\"*(numC-numMines-1) + \"c\"\n  \telif numC == 1:\n  \t\toutput = \"\n\".join(\"*\"*numMines + \".\"*(numR-numMines-1) + \"c\")\n  \telse:\n  \t\tboards.append( (numR,numC,numMines,0,0) )\n  \t\toutput = \"Impossible\"\n  \n  \twhile output == \"Impossible\" and len(boards) > 0:\n  \t\tb = boards.popleft()\n  \t\tnumR,numC,numMines,filledR,filledC = b\n  \t\tif numMines == 0:\n  \t\t\toutput = makeBoard0(b)\n  \t\t\tbreak\n  \n  \t\tif numMines >= numC and numR > 2:\n  \t\t\tboards.append( (numR-1,numC,numMines-numC,filledR+1,filledC) )\n  \t\tif numMines >= numR and numC > 2:\n  \t\t\tboards.append( (numR,numC-1,numMines-numR,filledR,filledC+1) )\n  \n  \t\tif numMines <= (numR-2)*(numC-2):\n  \t\t\toutput = makeBoard(b)\n  \n  \t\tif numR == 2:\n  \t\t\toutput = makeBoardR(b)\n  \n  \t\tif numC == 2:\n  \t\t\toutput = makeBoardC(b)\n  \t\t\n  \tprint \"Case #\"+str(numCase)+\":\n\"+output\n  \tl = f.readline()\n  \tnumCase += 1\n", "substitutes": {"b": ["bp", "j", "cb", "v", "http", "book", "object", "root", "t", "bl", "n", "br", "home", "bas", "bc", "nb", "this", "ob", "o", "body", "bf", "amb", "c", "bd", "h", "i", "lab", "bar", "bs", "pb", "bb", "sb", "mb", "abs", "y", "B", "app", "rb", "bub", "base", "ib", "m", "lb", "pa", "bis", "wb", "p", "lib", "boot", "d", "fb", "ab", "gb", "obj", "a", "back", "k", "hub", "db"], "numR": ["sumM", "umN", "NUMR", "numRec", "NumN", "umr", "widthM", "nR", " numN", "sumC", "numD", "nbr", "umRs", "nbC", " numL", "NUMP", " numD", " numP", "nbR", "sumr", " numr", "NumRec", "numP", "NumM", "nomRec", "nomM", "nL", "NumD", "monC", "numr", "NUMM", " numX", "nP", "widthr", "monM", "numM", "numL", "monR", "nomC", "sumN", "umR", "NumR", "NumP", "nM", "NumC", " numRec", "nomR", "nbRs", "NUMX", "widthC", "monL", "NumRs", "widthR", "sumR", "monP", "nomD", "nomL", "numRs", "numX", "nr", "umM", "monX", "numN", "umL", "nC", "sumL", " numM", " numRs", "umC", "NumL"], "numC": ["umE", "nc", "umN", "NUMR", "numberR", "NUMC", "multiC", "numberC", "NumN", "domc", "domC", "NUMN", "nomc", "nR", "normS", " numN", "sumC", "numD", "homC", "nomU", "homc", "numCC", "umc", "numberCM", " numL", " numD", " numP", "namC", "numCor", "namc", "numP", " numc", "domCs", "numU", " numE", "NumT", "NumM", "NumCS", "sumCs", "nuCS", " numCor", "nuP", "nL", "umic", "NumD", "nCS", "multiP", "multic", "homR", " numT", "numCM", "umiCM", "NUMM", "multiL", "nP", "NumCor", "numberD", "normR", "nE", "numCS", "normC", "namR", "nD", "numM", "numL", "sumE", "numberN", "numberCs", "NumU", "NUMD", "Numc", "numE", "nomC", "NUMc", "umR", "NumR", "numberCor", "sumc", "NumP", "NumC", "numberCC", "numCs", "numT", "domE", "nuN", "namS", "nT", "umiR", "multiD", "numberc", "domCC", "normc", "sumCM", "sumR", "NUMT", "umiC", "umD", "nN", "umCC", "nomD", "NUML", " numU", "numS", "numc", "numN", "umL", "umS", "nC", "namN", " numM", "NumE", "umC", "domR", "NumL", "multiT", "nuC"], "numMines": ["numGines", " numNines", "numCodes", "homMinations", "numMsins", "numCiners", " numMiners", "umiDemines", "numLine", "umiDemarks", "numLined", "numDines", "nbmines", "numPiddles", "numMains", "umiMiners", "numNiques", "NumCides", "homMizes", "numDemine", "numCides", " numTines", "numMides", "numCines", " numGains", " numMinks", "numNines", " numMides", " numNins", "numCModes", "homCizes", "nummains", " numTakes", "NumMides", "umiMine", "numGakes", "numMsines", "numPanes", "numTined", "numMins", "nMined", "numGimes", "numNinks", " numNiques", "numPines", "numGined", "nGined", "nGines", "nbMizes", "nbmizes", "nbMines", "numNides", "numPiners", "nbmined", "numCakes", "numRodes", "numCine", " numGinks", "numDemarks", "numDiddles", " numGined", "numMiners", "numGinks", "numRizes", "numDipes", "homCines", " numMiques", "numMizes", " numMined", " numGines", "nummined", "nMines", "numCizes", "numMiddles", "nbMians", "numGizes", " numTains", "numMachiddles", "numNains", " numManes", "umiMarks", "numMined", "numTiques", " numGiners", " numPipes", "numCMines", "nummimes", " numGimes", "numTakes", "numLakes", "numCians", "numNins", "numMimes", "NumCines", "umiMines", "numManes", " numNakes", "homCodes", "numRinations", "numMsiques", " numTined", " numMiddles", "numGians", "umiDeminers", " numMains", " numMimes", "numGides", "numDizes", "numTins", "nMine", "numPine", " numPines", "nGine", "numDeminers", "NumMines", "numDemines", "numDined", "numMarks", "numCMizes", "numGains", "numMachines", "numRines", "homMines", "numCMinations", "nummians", "nGains", "NumMakes", "numMachanes", "numParks", "numCains", "numMine", "NumMains", "numLines", "numMinations", "numPipes", "numMinks", "numMiques", " numMakes", "numLains", "numMakes", "nbmians", "numModes", "numCined", "numMsakes", " numGides", "nummizes", "nummines", " numGizes", " numMizes", "umiDemine", "numTines", "numDimes", " numMins", "homModes", "homCinations", "numGiners", " numMipes", "numMachipes", "nMains", "numTains", "numGine", "numCinations", "numNined", "numminers", "nbMined", "NumCakes", "numDanes", "NumCains", " numPanes", " numPiddles", "numNakes", "numMians", "numMipes"], "filledR": ["finishedRun", "signedLine", "printedRs", "selectedQ", "printedLine", "printedJ", "loadedRR", "finishedD", "publishedRun", "loadedRs", "selectedR", "loadedQ", "filledr", "drawnC", "printedRun", "finishedJ", "finishedGr", "signedR", "printedRe", " filledD", " filledQ", "playedAt", "drawnR", "loadedr", "filledRun", "finishedRR", "filledRe", "filledAt", "numP", "publishedJ", "selectedRs", "finishedP", "printedGr", "selectedr", "loadedR", " filledL", "printedC", "loadedDR", "filledQ", "filledRR", "filledL", "selectedC", "selectedDR", "filledP", "finishedK", " filledRR", "filledD", "loadedL", "finishedR", "printedP", "finishedr", "playedRR", "filledGr", "printedR", "drawnDR", "finishedC", "finishedRe", "signedr", "signedRe", " filledr", "loadedAt", "publishedGr", "filledK", "filledLine", "playedR", "publishedR", "loadedC", "filledDR", "printedr", "filledRs", "playedL", "loadedD", " filledAt", "numK", "filledJ", "selectedL", "finishedLine", "printedK"], "filledC": ["focusedB", "filledCS", "filledNC", "filledB", "foundR", "loadedNC", "filledCs", "filledCl", "packedc", "drawnC", "filledE", "paintedR", "filledMC", " filledN", "paintedM", "filledCustom", "foundC", "loadedM", " filledCI", "builtCL", "paintedS", "loadedB", "loadedCh", "shownCI", "drawnR", " filledE", "packedSc", "filledFrom", "focusedCl", "filledCode", "paintedC", "paintedFrom", "loadedCAR", "filledS", "hedC", "filledCL", "loadedCM", "foundCS", "loadedCs", "loadedCustom", "loadedR", "loadedSc", "packedR", "illedCAR", "paintedSc", "printedC", "placedR", "hedR", "illedR", "paintedCL", "hedCode", "numCode", "hedc", "keptC", "paintedCs", "filledCT", "ippedS", "paintedc", "loadedS", "paintedCM", "paintedCS", "illedN", "ippedC", "filledD", "loadedFrom", " filledCM", "filledCh", " filledCustom", "wonCL", "paintedCl", " filledCA", "numE", "keptR", "ippedR", " filledCl", "loadedCT", "loadedN", "filledCA", " filledCAR", "wonS", "wonR", "printedR", "filledc", "keptCode", "shownR", "packedC", "builtC", "illedC", "printedD", "focusedC", " filledS", "keptc", "drawnNC", "filledN", "printedB", "paintedCA", " filledCh", "filledCAR", "builtS", " filledNC", " filledCT", "placedC", " filledFrom", "shownMC", " filledM", "shownC", "placedc", "loadedC", "ippedCT", " filledMC", " filledc", "placedCs", "wonC", "filledCI", "illedCh", "focusedD", "packedE", "numc", "focusedR", "loadedCS", "filledM", "loadedD", "loadedMC", "focusedCA", "drawnCustom", "filledCM", "builtR", "loadedc", "filledSc", "loadedCI"], "q": ["requ", "id", "ail", "qq", "v", "am", "j", "query", "charge", "t", "n", "count", "ce", "ill", "quant", "qual", "w", "ak", "ck", "que", "quality", "g", "one", "c", "eq", "h", "sq", "qi", "sh", "i", "s", "dq", "needed", "kg", "depth", "Q", "y", "qt", "ue", "max", "qa", "row", "ur", "load", "qs", "qu", "iq", "m", "u", "req", "ai", "p", "ch", "d", "z", "ix", "int", "back", "k", "cl", "ac", "quest"], "r": ["v", "e", "rr", "pc", "err", "rf", "ru", "t", "n", "rd", "right", "rt", "w", "rh", "asc", "order", "o", "cr", "g", "c", "s", "h", "i", "R", "ar", "kr", "ir", "nr", "rc", "y", "sr", "range", "pr", "ur", "m", "u", "rb", "rs", "tr", "p", "d", "z", "rg", "arr", "k", "re", "er"], "board": ["game", "hold", "poll", "model", "ck", "feed", "image", "coll", "detail", "boarding", "cell", "case", "video", "layer", "bug", "deck", "object", "que", "round", "stroke", "list", "bit", "road", "loop", "clean", "function", "pool", "panel", "block", "back", "error", "cart", "ui", "word", "flow", "uc", "lane", "che", "code", " clipboard", "control", "ward", "ban", "progress", "stone", "wheel", "input", "view", "court", "lay", "phone", "device", "layout", "cross", "box", "screen", "client", "comment", "menu", " dashboard", "ack", "draw", "home", "bo", "cache", "holder", "post", "channel", "flo", "Board", "batch", " row", "craft", "sync", "row", "lock", " game", "pod", "document", "hole", "wall", "player", "work", "node", "bank", "design"], "x": ["rx", "id", "xe", "xx", "v", "index", "code", "t", "xy", "n", "xi", "na", "fx", "w", "col", "co", "g", "X", "ex", "xes", "ux", "h", "bit", "xp", "val", "y", "max", "yl", "xc", "qu", "my", "xt", "yx", "m", "p", "xf", "nex", "ix", "z", "ax", "full", "ct", "wx", "k", "sex", "_", "work", "ctx", "cl", "lex"], "output": ["run", "come", "complete", "target", "benefit", "image", "PUT", "ut", "ort", "position", "unit", "application", "detail", "console", "current", "ilo", "display", "don", "respond", "pre", "layer", "object", "net", "ou", "round", "outer", "config", "job", "out", "function", "response", "resource", "export", "number", "word", "operation", "flow", "external", "product", "result", "control", "Output", "edit", "module", "production", "update", "section", "progress", "future", "input", "dt", "pot", "write", "dot", "component", "version", "summary", "cut", "cache", "put", "fore", "toc", "environment", "struct", "generation", "document", "debug", "lib", "exit", "page", "design"]}}
{"code": " \n  if __name__ == \"__main__\":\n  \tf = open( sys.argv[1] )\n  \tint(f.readline())\n  \t\t\n  \tnum = 1\n  \tl = f.readline()\n  \twhile l != \"\":\n  \t\trow1 = int(l)\n  \t\trows = [ f.readline() for x in range(4) ]\n  \t\trow1 = [int(x) for x in rows[row1-1].split()]\n  \n  \t\trow2 = int(f.readline())\n  \t\trows = [f.readline() for x in range(4)]\n  \t\trow2 = [int(x) for x in rows[row2-1].split()]\n  \n  \t\tresult = set(row1) & set(row2)\n  \t\tif len(result) == 1:\n  \t\t\toutput = str(result.pop())\n  \t\telif len(result) > 1:\n  \t\t\toutput = \"Bad magician!\"\n  \t\telse:\n  \t\t\toutput = \"Volunteer cheated!\"\n  \n  \t\tprint \"Case #\"+str(num)+\": \"+output\n  \t\tnum += 1\n  \t\tl = f.readline()\n  \t\t\n", "substitutes": {"f": ["e", "v", "fr", "ff", "fast", "http", "rf", "t", "n", "fo", "tf", "af", "r", "w", "fd", "fx", "feed", "o", "folder", "bf", "g", "c", "s", "h", "i", "inf", "file", "y", "fw", "fen", "F", "handler", "fm", "of", "fp", "m", "u", "function", "lf", "found", "b", "p", "fs", "fb", "d", "df", "z", "fc", "full", "iter", "form", "api", "sf"], "num": ["dom", "fn", "id", "am", " n", "index", "multi", "np", "no", "n", "final", " number", "nb", " nu", "un", "Num", "du", "umi", "coord", "status", "col", "thread", "uni", "div", "c", "dim", "i", "sum", "counter", "name", "loop", "msg", "size", "unit", "row", "nom", "con", "u", "nn", "m", "norm", "nu", "d", "um", "NUM", "uno", " NUM", "note", "nm", "form", "node", "number", "mon", "temp", "union", "test"], "l": ["v", "dl", "e", "la", "t", "n", "lc", "dL", "r", "li", "url", "nl", "el", "col", "o", "lr", "ll", "g", "lo", "wl", "c", "s", "len", "i", "fl", "y", "ul", "lv", "left", "rl", "lp", "il", "u", "m", "lb", "ln", "b", "p", "ls", "line", "ol", "lines", "kl", "lin", "cl", "loc", "sl", "L"], "row1": [" rowone", "line71", "row4", "ow4", "ow3", "ow5", "raw1", "rowsone", "cell2", "rowOne", "row71", "cell5", "line3", "Row2", "rows4", "ow2", "rows1", "rawone", " rowOne", "cell4", "lineOne", "rowone", "owOne", "ow71", " row71", "Row3", "raw3", "Row1", "row3", "cell1", "ow1", "rows5", "rows3", "line1", " row3", "row5", "rows2"], "rows": ["all", "blocks", "rown", "olds", "groups", "holes", "planes", "multi", "array", "ends", "features", "reads", "fields", "feed", "sections", "orders", "files", "locks", "rooms", "opens", "s", "ips", "ows", "xes", "users", "heads", "raw", "values", "rings", "row", "balls", "cells", "strings", "runs", "breaks", "ss", "forms", "relations", "rs", "items", "works", "flows", "results", "rules", "reports", "lines", "anges", "errors", "es", "frames", "ions", "pages", "tracks", "views", "ks", "shows"], "x": ["rx", "id", "xe", "xx", "v", "e", "xb", "index", "code", "t", "xy", "n", "time", "xi", "r", "w", "ross", "col", "on", "oint", "X", "c", "ex", "ux", "i", "h", "xes", "xp", "ya", "row", "y", "xa", "max", "out", "ci", "xc", "xt", "u", "ph", "m", "plex", "b", "xf", "p", "d", "z", "ix", "ax", "int", "ct", "wx", "sex", "k", "xs", "work", "loc", "_", "lex", "word"], "row2": ["blocksecond", "cellTwo", "row62", "row4", "viewTwo", "pagetwo", "lineTwo", " rowtwo", "viewsecond", "key2", "cell2", "rowTwo", "rowsecond", "keysecond", " row62", " rowTwo", "line2", "blockTwo", "owTwo", "keytwo", "ow2", "row0", "line0", "block4", " rowsecond", " row0", "ow62", "block2", "view2", "page2", " row4", "rowtwo", "line62", "blocktwo", "pagesecond", "cell0", "key4", "pageTwo", "viewtwo"], "result": ["valid", "feature", "root", "err", "res", "Result", "array", "report", "default", "ner", "score", "success", "model", "final", "table", "server", "json", "r", "status", "order", "answer", "term", "group", "record", "match", "dict", "value", "list", "section", "sum", "row", "ret", "desc", "range", "current", "source", "search", "df", "page", "results", "response", "diff", "entry", "line", "new", "error", "runner", "rate", "comment", "case", "data", "pair", "db", "test"], "output": ["double", "version", "summary", "string", "cut", "log", "n", "success", "run", "text", "Output", "four", "put", "format", "o", "value", "production", "outer", "byte", "file", "unit", "job", "out", "input", "console", "message", "current", "null", "expression", "generation", "write", "ln", "document", "debug", "display", "response", "new", "resource", "length", "line", "next", "example", "export", "number", "exit", "page", "operation"]}}
{"code": "t = int(raw_input())\n  \n  for case in range(t):\n  \tprint 'Case #'+str(case+1)+':'\n  \tr, c, m = raw_input().split()\n  \tr = int(r)\n  \tc = int(c)\n  \tm = int(m)\n  \n  \tif m==0:\n  \t\tprint 'c' + ('.'*(c-1))\n  \t\tfor i in range(r-1):\n  \t\t\tprint '.'*c\n  \telif r == 1:\n  \t\tprint 'c'+('.'*(c-m-1))+('*'*(m))\n  \telif c == 1:\n  \t\tprint 'c'\n  \t\tfor i in range(r-m-1):\n  \t\t\tprint '.'\n  \t\tfor i in range(m):\n  \t\t\tprint '*'\n  \telif r == 2:\n  \t\tif m%2==0 and c>2 and m<r*c-2:\n  \t\t\tprint 'c'+('.'*(c-m/2-1))+('*'*(m/2))\n  \t\t\tprint ('.'*(c-m/2))+('*'*(m/2))\n  \t\telif m == r*c - 1:\n  \t\t\tprint 'c'+('*'*(c-1))\n  \t\t\tprint '*'*c\n  \t\telse:\n  \t\t\tprint 'Impossible'\n  \telif c == 2:\n  \t\tif m%2==0 and r>2 and m<r*c-2:\n  \t\t\tprint 'c.'\n  \t\t\tfor i in range(r-m/2-1):\n  \t\t\t\tprint '..'\n  \t\t\tfor i in range(m/2):\n  \t\t\t\tprint '**'\n  \t\telif m == r*c - 1:\n  \t\t\tprint 'c*'\n  \t\t\tfor i in range(r-1):\n  \t\t\t\tprint '**'\n  \t\telse:\n  \t\t\tprint 'Impossible'\n  \telif c == 3 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\telif m == 4:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 5:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\telif m == 6:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 3 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\telif m == 4:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 5:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 6:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 3 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 4:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\telif m == 5:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 6:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 7:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 8:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 9:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 12:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 4 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 6:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 4 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\telif m == 3:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\telif m == 6:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 7:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\telif m == 8:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 11:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 12:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 15:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 4 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\telif m == 3:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 6:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 7:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 8:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 10:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 11:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 12:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 15:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 16:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 17:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 5 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '...**'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 7:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\telif m == 8:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 9:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telif c == 5 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '..***'\n  \t\telif m == 7:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 8:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 9:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 10:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 11:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 15:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 16:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 17:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telif c == 5 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 7:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 8:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 9:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '*****'\n  \t\telif m == 10:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 11:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 13:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 14:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 15:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 16:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 17:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 20:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 21:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 22:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 23:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 24:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telse:\n  \t\tprint 'Impossible'\n  \n", "substitutes": {"t": ["x", "e", "v", "T", "l", "n", "time", "trial", "q", "w", "it", "o", "tt", "at", "s", "type", "h", "y", "start", "dt", "u", "tz", "b", "p", "d", "z", "tm", "ts", "f", "port", "test"], "case": ["instance", "x", "id", "code", "end", "slice", "count", "time", "trial", "ace", "text", "rice", "table", "ce", "me", "match", "ice", "type", "section", "name", "use", "size", "position", "race", "app", "line", "length", "Case", "ase", "cases", "number", "loc", "test"], "r": ["x", "j", "mr", "e", "v", "rr", "fr", "err", "yr", "l", "ru", "n", "br", "ter", "q", "w", "rh", "o", "rec", "g", "cr", "s", "ir", "R", "ar", "h", "nr", "rc", "y", "sr", "range", "pr", "ur", "hr", "u", "rb", "rs", "tr", "b", "p", "d", "z", "k", "re", "f", "er"], "c": ["x", "v", "e", "pc", "uc", "cat", "cs", "l", "code", "n", "dc", "cin", "lc", "q", "oc", "ca", "ce", "count", "w", "cu", "col", "o", "rec", "ec", "co", "cr", "g", "s", "h", "sc", "ar", "rc", "y", "cf", "ur", "ci", "xc", "con", "cm", "u", "ic", "mc", "b", "p", "C", "d", "ch", "z", "ct", "a", "cc", "cy", "k", "cp", "cl", "f", "re", "ac"], "m": ["x", "mu", "j", "mr", "v", "e", "am", "ym", "im", "l", "mi", "n", "lc", "man", "mm", "w", "o", "g", "me", "module", "ms", "s", "h", "ar", "bm", "rm", "om", "gm", "mod", "y", "hm", "range", "an", "ur", "arm", "fm", "machine", "cm", "u", "mon", "mc", "b", "p", "sm", "d", "um", "z", "tm", "pm", "a", "md", "dm", "k", "em", "re", "f", "er", "M", "mo"], "i": ["ji", "x", "id", "ui", "j", "ii", "v", "e", "bi", "ri", "ip", "l", "phi", "ei", "xi", "yi", "iu", "li", "it", "o", "ti", "ie", "h", "qi", "chi", "si", "oi", "I", "iw", "ci", "u", "ib", "ic", "ai", "b", "p", "pi", "int", "iv", "di", "f", "io"]}}
{"code": "t = int(raw_input())\n  \n  for case in range(t):\n  \tr1 = int(raw_input())\n  \tc1 = []\n  \tfor j in range(4):\n  \t\tc1.append([int(i) for i in raw_input().split()])\n  \n  \tr2 = int(raw_input())\n  \tc2 = []\n  \tfor j in range(4):\n  \t\tc2.append([int(i) for i in raw_input().split()])\n  \n  \tnum = -1\n  \tpossibles = 0\n  \tfor j in c1[r1-1]:\n  \t\tif c2[r2-1].count(j) == 1:\n  \t\t\tnum = j\n  \t\t\tpossibles += 1\n  \n  \tif possibles > 1:\n  \t\tprint 'Case #'+str(case+1)+': Bad magician!'\n  \telif possibles == 0:\n  \t\tprint 'Case #'+str(case+1)+': Volunteer cheated!'\n  \telse:\n  \t\tprint 'Case #'+str(case+1)+': '+str(num)\n", "substitutes": {"t": ["x", "v", "e", "T", "n", "time", "trial", "q", "r", "w", "it", "tt", "g", "c", "ti", "type", "h", "s", "total", "y", "ta", "start", "dt", "m", "tp", "p", "d", "z", "tm", "f", "times", "test"], "case": ["instance", "id", "part", "v", "uc", "bi", "key", "string", "ip", "code", "sec", "end", "time", "q", "trial", "ce", "bc", "rice", "li", "du", "shape", "space", "path", "match", "ice", "c", "mode", "ti", "gi", "h", "qi", "section", "type", "ie", "pe", "connection", "seq", "name", "loop", "size", "position", "config", "race", "job", "sequence", "jo", "ai", "b", "z", "choice", "line", "length", "division", "a", "ct", "Case", "ase", "cases", "k", "cell", "test"], "r1": ["c8", "R3", "rc2", "rc1", "r0", "r8", "x8", "c3", " r3", "x1", "x2", "rc8", "r3", " r0", "R2", "c0", "R1", "R0"], "c1": ["C31", "r31", "Cn", " cup", "rc2", "Cup", "rc1", "r0", "rc3", "rc0", " c3", "C0", "C1", "cn", "c3", " c31", " cn", "rup", "c31", "cup", "r3", "C2", "c0", "rn", " c0"], "j": ["ji", "x", "v", "im", "l", "dj", "end", "n", "ind", "q", "J", "jj", "jit", "r", "un", "o", "js", "g", "c", "h", "ie", "oj", "jp", "jam", "kj", "y", "jl", "job", "u", "m", "b", "p", "d", "ch", "aj", "z", "new", "note", "int", "ja", "jing", "a", "ij", "obj", "k", "cell", "_", "f", "number", "uj"], "i": ["ji", "x", "id", "ii", "e", "v", "bi", "ri", "index", "im", "ip", "l", "n", "ind", "q", "xi", "jit", "yi", "iu", "li", "r", "it", "o", "on", "c", "ti", "ie", "qi", "si", "I", "ori", "ni", "ci", "u", "m", "ai", "b", "p", "d", "z", "ix", "pi", "int", "k", "zi", "f", "io", "ia", "ui"], "r2": ["R4", "RTwo", " r4", "u22", "r4", " rTwo", "rrTwo", "u2", " rsecond", "rsecond", "v2", "rr4", " r22", "vsecond", "rr1", "r22", "R2", "R1", "v22", "rTwo", "usecond", "rr2"], "c2": ["c8", "r4", "c4", "ftwo", "c62", "p6", "p2", "c6", "v2", "r6", "r8", "C1", "C4", "v1", "rtwo", "ctwo", "f1", "r62", "Ctwo", "f4", " c8", " cTwo", "p8", "v62", "C2", " c6", "p1", " c62", "rTwo", "cTwo", "f2", "vTwo"], "num": ["x", "id", "part", "index", "no", "n", "count", "ind", "success", "nb", "lim", "Num", "coord", "col", "umi", "uni", "sn", "c", "len", "dim", "en", "sum", "om", "loop", "unit", "max", "nom", "hom", "split", "ni", "con", "m", "u", "mon", "sim", "b", "p", "nu", "span", "norm", "NUM", "um", "pos", "note", "int", "k", "number", "loc"], "possibles": ["Passibles", "possible", "pOSSibl", "Possibl", "pensibles", "positibl", "POSSibilities", "Passibilities", "positibilities", "POSSible", "pOSSibilities", "possibilities", "pOSSibles", "POSSibl", "pOSSibility", "pensibly", "passibility", "posibly", "powersibles", "posibilities", "Passible", "pOSSibly", "possibility", "positible", "Passibility", "posibles", "powersibilities", "possibly", "pensibility", "Possibilities", "possibl", "POSSibly", "passibilities", "POSSibility", "Possible", "POSSibles", "Passibly", "Possibles", "pensibilities", "passibl", "passible", "Possibility", "positibles", "pOSSible", "Possibly", "Passibl", "passibly", "passibles", "posibility", "powersibility", "powersibly"]}}
{"code": "def make_string(R, C, M):\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\n      grid[-1][-1] = 'c'\n      t = M\n      for i in xrange(R):\n          for j in xrange(C):\n              if M:\n                  if forbidden(R, C, t, i, j):\n                      continue\n                  grid[i][j] = '*'\n                  M -= 1\n              else:\n                  break\n      s = ''\n      if M:\n          return 'Impossible'\n      for r in grid:\n          s += ''.join(r)+'\n'\n      return s[:-1]\n  \n  def forbidden(R, C, M, i, j):\n      a = M / C\n      b = M % C\n      if (R*C - M == 1):\n          return False\n  \n      if i >= (R-2) and j >= (C-2):\n          return True\n  \n      if i >= (R-2) and b:\n          if b % 2:\n              return True\n          if j < b/2:\n              return False\n          else:\n              return True\n      return False\n          \n  \n  f = open('Csmall.in', 'r')\n  g = open('outputC.txt', 'w')\n  \n  data = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in f]\n  T = int(data.pop(0)[0])\n  for i, case in enumerate(data):\n      R, C, M = case[0], case[1], case[2]\n      num_cells = R*C\n      if (R-1) == 0 or (C-1) == 0:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1,s))\n          continue\n      else:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1, s))\n          \n  \n  f.close()\n  g.close()\n", "substitutes": {"R": ["Rh", "N", "Y", "Rule", "GR", "Rs", "Range", "P", "MR", "J", "Cl", "CR", "RH", "Re", "JR", "E", "G", "H", "SR", "RM", "W", "RO", "Right", "X", "c", "Co", "K", "Q", "RS", "BR", "Br", "I", "B", "Run", "D", "F", "Ro", "RC", "RG", "Ra", "Ch", "O", "RN", "S", "Group", "RR", "V", "Res", "NR", "KR", "WR", "A", "Role", "L", "U", "RA"], "C": ["N", "Cor", "Y", "NC", "SC", "CNN", "AC", "Cs", "P", "VC", "DC", "CM", "CR", "CF", "Con", "E", "H", "G", "CE", "W", "CA", " c", "X", "c", "Co", "Sc", "JC", "K", "YC", "CV", "CC", "Q", "CW", "Cu", "B", "I", "CS", "D", "CI", "Cr", "F", "Ch", "CT", "O", "S", "CL", "Z", "EC", "MC", "V", "Case", "CU", "Count", "CN", "Code", "A", "L", "U"], "M": ["N", "Y", "MD", " m", "FM", "P", "MS", "MR", "Man", "MO", "J", "CM", "MT", "E", "SM", "G", "H", "MI", "RM", "W", "DM", "AM", "K", "X", "c", "Mo", "Q", "I", "B", "BM", "MF", "D", "F", "MB", "LM", "MM", "m", "cm", "O", "S", "Mi", "Z", "MN", "MA", "CL", "Me", "ME", "Mor", "MC", "V", "IM", "A", "L", "U"], "grid": ["Grid", "x", "id", "gui", " Grid", "draw", "multi", "rule", "code", "array", "play", "model", "q", "gr", "ace", "complex", "w", "edge", "et", "db", "G", "ward", "module", "div", "ice", "c", "list", "row", "unit", "reg", "range", "sequence", "ode", "m", "str", "sim", "frame", "ata", "layout", "cube", "block", "chain", "graph", "arr", "cell", "age", "law", "mat", "house", "test"], "j": ["ji", "x", "v", "ii", "bi", "im", "je", "l", "n", "ind", "q", "J", "jj", "xi", "li", "w", "it", "jc", "o", "js", "c", "ie", "oj", "jp", "jam", "y", "jl", "si", "vi", "job", "ni", "adj", "m", "u", "ib", "p", "d", "aj", "z", "ab", "bj", "ja", "ij", "k", "uj"], "i": ["id", "v", "ri", "bi", "P", "ti", "ir", "chi", "gi", "hi", "iw", "eni", "ni", "m", "l", "n", "slice", "ei", "li", "ie", "info", "num", "CI", "my", "ai", "p", "ix", "ij", "di", "zi", "ui", "ii", "index", "multi", "ip", "mi", "ind", "xi", "yi", "iu", "it", "type", "qi", "esi", "y", "vi", "I", "ori", "uri", "inner", "ci", "ini", "iq", "u", "ib", "LI", "d", "pi", "ji", "x", "part", "key", "o", "c", "si", "z", "int", "mini", "io", "ia"], "t": ["x", "A", "Y", "v", "l", "n", "w", "it", "o", "tt", "at", " c", "c", "ti", "h", "type", "y", "TM", "tmp", "I", "out", "F", "m", "u", "p", "d", "z", "tm", "int", "temp"], "s": ["v", "sys", "south", "ains", "sec", "ends", "spec", "sets", "sb", "ures", "size", "unit", "gs", "ances", "m", "uses", "span", "xs", "ches", "sq", "seconds", "ps", "comments", "ns", "l", "n", "su", "site", "sym", "os", "words", "self", "set", "ips", "sh", "codes", "conf", "name", "abs", "cells", "out", "single", "rows", "sim", "session", "p", " lines", "lines", "ts", "ments", "ings", "blocks", "ds", " statements", "ops", "space", "js", "ing", "type", "ows", "section", "y", "py", "u", "rs", "d", "states", "sg", "ls", "ions", "x", "string", "ries", "side", "aces", " S", "w", "status", "sample", "o", "c", "sum", "ses", "sync", "si", "second", "ss", "steps", "S", "ed", "z", "es", "sf"], "r": ["Rh", "all", "v", "res", "result", "l", "array", "ner", "n", "gr", " ir", "run", "right", "q", "w", "it", "rh", "cr", " c", "c", "h", "section", "arc", "range", " d", " arc", "m", "rb", "str", "rs", "p", "d", "arr", "mat"], "a": ["A", "am", "sa", "ga", "area", "ca", "na", "ae", "o", "c", "aa", "alpha", "si", "y", "an", "ci", "m", "ai", "p", "aj", "ab", "mA", "ma", "ac", "ia", "ba"], "b": ["x", "v", "bi", "l", "n", "nb", "w", "o", "bf", "c", "h", "bs", "bb", "sb", "mb", "y", "B", "eb", "m", "u", "ib", "lb", "rb", "base", "wb", "p", "d", "z", "bh", "ab", "k", "A", "ba", "be"], "f": ["x", "fold", "flow", "v", "fr", "rf", "l", "n", "fo", "q", "tf", "fa", "af", "w", "fd", "feed", "o", "bf", "c", "fe", "h", "info", "conf", "file", "fen", "fw", "cf", " F", "F", "fi", "fm", "fp", "m", "u", "frame", "p", "fs", "xf", "d", "fb", "z", "fc", "form", "io", "ef", "sf"], "g": ["gg", "x", "game", "v", "err", "l", "ga", "q", "gen", "w", "gu", "G", "group", "cfg", "bg", "c", "h", "gi", "ge", "conf", "gm", "file", "gh", "y", "reg", "gs", "gz", "fm", "m", "u", "og", "go", "gp", "p", "d", "sg", "vg", "ig", "graph"], "data": ["x", "blocks", "v", "key", "index", "result", "code", "array", "change", "default", "slice", "Data", "shift", "w", "o", "dat", "body", "DATA", "c", "series", "list", "info", "values", "size", "row", "input", "load", "sequence", "rows", "u", "ata", "p", "d", "results", "response", "diff", "new", "lines", "error", "map", "next", "test"], "e": ["x", "za", "ea", "ze", "code", "n", "ei", "ite", "ce", "ace", "E", "el", "ae", "o", "ec", "te", "one", "ice", "fe", "ge", "ie", "pe", "eg", "en", "ele", "element", " E", "ke", "eb", "p", "ade", "d", "ed", "page", "ee", "ev", "entry", "es", "ef", "se"], "line": ["v", "string", "l", "code", "n", "ine", "li", "et", "el", "c", "ge", "len", "en", "file", "row", "m", "str", "frame", "p", "d", "block", "lines", "lin", "link", "Line", "cell", "cl", "de", "band", "page"], "T": ["Y", "N", "P", "trial", "time", "E", "H", "shape", "X", "type", "unit", "I", "B", "D", "F", "O", "S", "Z", "z", "trace", "number", "A", "V", "test"], "case": ["instance", "bug", "part", "key", "result", "code", "change", "default", "slice", "trial", "ace", "ce", "catch", "event", "shape", "space", "path", "match", "ice", "one", "c", "type", "pe", "section", "name", "switch", "call", "do", "block", "ride", "choice", "entry", "force", "Case", "error", "ase", "ide", "cell", "example", "pair", "record", "test"], "num_cells": ["num_cell", " num_rows", " num_cell", "num_lines", " num_lines", "num_rows"]}}
{"code": "f = open('A.in', 'r')\n  g = open('outputA.txt', 'w')\n  data = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in f]\n  T = data[0][0]\n  c = 0\n  for i in xrange(1, T*10 + 1, 10):\n      c += 1\n      choice1 = data[i][0]\n      choice2 = data[i+5][0]\n      grid1, grid2 = [], []\n      for j in xrange(1,5):\n          grid1.append(data[i+j])\n  \n      for j in xrange(6, 10):\n          grid2.append(data[i+j])\n  \n      s1 = set(grid1[choice1-1])\n      s2 = set(grid2[choice2-1])\n  \n      s = s1 & s2\n      if len(s) == 1:\n          g.write(\"Case #%i: %i\n\" %(c, s.pop()))\n      elif not s:\n          g.write(\"Case #%i: Volunteer cheated!\n\" %(c))\n      else:\n          g.write(\"Case #%i: Bad magician!\n\" %(c))\n  \n  f.close()\n  g.close()\n      \n", "substitutes": {"f": ["x", "fold", "flow", "v", "rf", "l", "t", "n", "fo", "tf", "fa", "r", "w", "fd", "feed", "o", "bf", "fe", "h", "info", "fit", "fl", "file", "fw", "F", "fi", "fp", "m", "u", "lf", "frame", "b", "fs", "p", "fb", "df", "d", "z", "a", "form", "sf"], "g": ["gg", "x", "game", "gui", "v", "gc", "l", "t", "n", "ga", "gen", "r", "w", "gu", "erg", "G", "o", "group", "bg", "cfg", "h", "eg", "ge", "gm", "mg", "agg", "msg", "gh", "ag", "gs", "out", "gz", "m", "u", "og", "go", "b", "p", "d", "vg", "sg", "ig", "gb", "rg"], "data": ["x", "key", "index", "string", "result", "code", "array", "t", "n", "change", "slice", "grade", "model", "output", "table", "Data", "cache", "w", "sample", "dat", "space", "group", "match", "DATA", "series", "list", "window", "batch", "info", "values", "ad", "file", "row", "config", "zip", "start", "split", "input", "style", "current", "m", "ata", "frame", "call", "p", "pick", "d", "results", "pos", "block", "response", "int", "a", "next", "content", "case", "temp", "video", "test"], "e": ["x", "all", "ze", "je", "l", "t", "code", "n", "ei", "ace", "r", "E", "it", "el", "o", "ae", "ec", "te", "fe", "ge", "ie", "en", "element", " E", "y", "I", "energy", "iq", "m", "u", "b", "p", "d", "z", "ee", "ev", "a", "k", "se"], "line": ["all", "v", "object", "string", "code", "l", "log", "n", "run", "r", "li", "o", "co", "lo", "len", "h", "en", "name", "file", "row", "buffer", "I", "source", "m", "lf", "frame", " lines", "d", "block", "entry", "lines", "obj", "int", "lin", "Line", "cell", "k", "L", "page"], "T": ["N", "Y", "Total", "t", "P", "n", "J", "E", "H", "W", "K", "X", "R", "total", "Q", "I", "B", "D", "F", "O", "S", "Z", "C", "z", "length", "M", "A", "L", "V"], "c": ["x", "v", "nc", "cs", "l", "t", "code", "n", "dc", "count", "q", "lc", "ce", "r", "w", "cu", "col", "o", "ec", "cr", "h", "y", "cf", "ci", "m", "u", "ic", "mc", "b", "p", "C", "d", "z", "a", "ct", "cy", "k", "case", "loc"], "i": ["x", "id", "v", "ii", "index", "l", "t", "n", "ind", "ei", "q", "J", "yi", "li", "iu", "r", "it", "ti", "ie", "h", "qi", "info", "y", "si", "I", "eni", "ni", "ci", "ini", "u", "m", "ai", "b", "p", "d", "z", "int", "a", "mini", "di", "k", "io", "ui"], "choice1": ["sequence2", "sequence1", "example1", "exampleOne", "choiceOne", "Choice2", "Choice1", "case2", "Choice3", "choice3", "example2", "change2", "changeOne", "sequenceOne", "caseOne", "ChoiceOne", "change1", "sequence3", " choice3", " choiceOne", "case1"], "choice2": ["choice02", "sequence2", " choice_", "sequence02", "changetwo", "grid_", "codetwo", "code02", "line2", "gridb", "change2", "choicetwo", "line_", "choice_", "choiceb", "code2", "sequencetwo", "line1", "change02", "lineb", " choiceb"], "grid1": ["row1", "grid0", "range2", "house0", "range0", "grid01", " grid5", "choice0", "row2", "group5", " grid01", "choice4", "grid3", "cell3", "group3", "house1", "grid4", "house2", "rowOne", "group1", "lineone", "grid5", " grid3", "cell5", "line2", "group01", "range1", " gridone", "cell01", " gridOne", "lineOne", "range4", "house4", "gridOne", "rowone", "cell1", "line1", "gridone"], "grid2": ["Grid2", "Grid3", "gridtwo", "choice02", "grouptwo", " grid5", "house02", "Grid5", "Gridtwo", "group5", "grid3", "group3", "house1", "group2", "house2", "group1", " grid3", "grid5", "choice3", "grid02", "Grid1", " gridtwo", "house3", "group02"], "j": ["ji", "x", "id", "v", "im", "l", "br", "n", "end", "t", "ind", "q", "J", "r", "li", "el", "o", "js", "ie", "h", "jp", "y", "ci", "u", "b", "p", "ch", "d", "z", "k"], "s1": ["s81", "S1", "si81", "ds2", "ds01", "g2", "gfirst", "dsfirst", "g01", "si1", "ds1", "sOne", "sifirst", "siOne", "si01", " s81", "g1", "sfirst", "S81", "SOne", "s01", " sOne", "si2"], "s2": ["grid52", " s8", "s10", "es5", "s02", "es82", "ss2", " s52", "es2", "sa8", "sa2", "grid5", "s5", "ss8", " s10", "ss10", "ss02", "grid82", "es52", "sa10", "s82", " s5", "s8", " s82", " s02", "sa02", "s52"], "s": ["ps", "comments", "blocks", "v", "ns", "groups", "ds", "cs", "l", "south", "n", "slice", "sort", "ops", "sym", "os", "settings", "o", "sections", "sets", "js", "words", "services", "set", "ows", "ins", "parts", "sb", "ws", "ses", "size", "tests", "si", "sync", "sites", "y", "gs", "qs", "strings", "ss", "ids", "rows", "m", "u", "S", "b", "p", "events", "d", "states", "ls", "new", "a", "es", "ssl"]}}
{"code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          R, C, M = map(int, f.readline().split())\n  \n          print \"Case #%d:\" % (_T+1)\n  \n          left = R * C - M\n  \n          if R == 1:\n              s = 'c'\n              s += '.' * (left - 1)\n              s += '*' * M\n              print s\n              continue\n          if C == 1:\n              print 'c'\n              for i in xrange(left - 1):\n                  print '.'\n              for i in xrange(M):\n                  print '*'\n              continue\n  \n          if left == 1:\n              print 'c' + '*' * (C-1)\n              for i in xrange(R-1):\n                  print '*' * C\n              continue\n  \n          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\n              print \"Impossible\"\n              continue\n          if R == 2:\n              assert left not in (2, 3, 5, 7)\n              assert left >= 4\n              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\n              print '.' + '.' * (left/2 - 1) + '*' * (M/2)\n              continue\n          if C == 2:\n              assert left >= 4\n              assert left not in (2, 3, 5, 7)\n              print 'c.'\n              left -= 2\n              R -= 1\n              while left:\n                  print '..'\n                  left -= 2\n                  R -= 1\n              assert R >= 0\n              while R:\n                  print '**'\n                  R -= 1\n              continue\n  \n          assert R >= 3\n          assert C >= 3\n  \n          if left == 4:\n              print 'c.' + '*' * (C-2)\n              print '..' + '*' * (C-2)\n              for i in xrange(R-2):\n                  print '*' * C\n              continue\n  \n          if left in (2, 3, 5, 7):\n              print \"Impossible\"\n              continue\n  \n          assert left >= 6\n  \n          cols = max(3, (left + R-1) // R)\n  \n          if left % cols == 1:\n              assert left >= 10\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols + 1:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left == cols + 1\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\n              print '.' * (2) + '*' * (C - 2)\n              R -= 2\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n          else:\n              assert left >= 6\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left >= 2\n              print '.' * (left) + '*' * (C - left)\n              R -= 1\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n  \n          1/0\n", "substitutes": {"f": ["x", "e", "v", "fr", "rf", "l", "t", "n", "fo", "tf", "fa", "af", "r", "w", "fd", "feed", "o", "bf", "g", "c", "h", "inf", "file", "fw", "fen", "F", "fi", "fp", "m", "u", "fed", "b", "p", "fs", "fb", "df", "fc", "full", "form", "sf"], "fn": ["nc", "unc", "rf", "fat", "n", "dn", "utf", "output", "fa", "filename", "bn", "fd", "format", "fin", "func", "ll", "path", "bf", "wl", "sn", "conn", "wt", "len", "kn", "name", "fl", "file", "fen", "txt", "syn", "F", "fi", "fil", "fm", "wn", "fp", "function", "ln", "FN", "fs", "fb", "lib", "fc", "feat", "full", "sf", "fun"], "T": ["TR", "N", "Y", "Total", "TN", "t", "P", "n", "Tw", "TH", "DT", "TS", "E", "G", "W", "K", "X", "Time", "TX", "TW", "NT", "Q", "I", "D", "F", "WT", "O", "S", "TT", "Z", "length", "TB", "A", "L", "V"], "_T": ["_F", " _M", "_t", "_M", " _N", "_N", " _t"], "R": ["Rh", "TR", "N", "Y", "GR", "Rs", "Range", "P", "All", "RE", "ro", "J", "right", "CR", "RH", "RT", "Re", "r", " r", "E", "G", "H", "SR", "RM", "W", "RO", "RF", "Right", "X", "K", "c", "RW", "Q", "DR", "RS", "I", "B", "RP", "AR", "D", "F", "RC", "RG", "O", "RN", "RL", "S", "RR", "Left", "V", "NR", "Line", "A", "L", "U", "RA"], "C": ["N", "Y", "SC", "CNN", "Cs", "P", "DC", "CM", "CR", "CF", "r", "E", "G", "CE", "H", "W", "COR", "RO", "CA", "K", "X", "c", "Co", "Sc", "Right", "CO", "CC", "Q", "I", "B", "Cu", "D", "F", "Cr", "RC", "O", "S", "EC", "Left", "V", "CU", "A", "L", "U"], "M": ["N", "Y", "MD", "P", "MS", "MR", "J", "CM", "U", "MT", "r", "E", "G", "H", "RM", "W", "DM", "K", "X", "NM", "Q", "TM", "I", "B", "MF", "D", "F", "LM", "MM", "m", "O", "S", "MA", "Z", "MN", "Mor", "MC", "Left", "OR", "A", "L", "V"], "left": ["root", "err", "NL", "ignore", "st", "P", "log", "PL", "low", "Cl", "CR", "col", "lr", "old", "cle", "len", "CO", "size", "le", "LM", "m", "cm", "RL", "roll", "partial", "length", "ax", "cell", "case", "none", "L", "j", "SC", "lt", "l", "bl", "no", "n", "lc", "r", "li", "net", "offset", "RO", "lo", "X", "top", "value", "byn", "list", "center", "self", "one", "LC", "CC", "ul", "out", "rows", "LR", "found", "function", "str", "p", "full", "error", "a", "ct", "LE", "plus", "all", "ST", "lower", "index", "required", "control", "output", " L", "Control", "just", "ell", "it", "two", "ctrl", "LL", "fl", "static", "I", "B", "inner", "reset", "Z", "d", "last", "leave", "pos", "line", "ion", "outside", "small", "used", "data", "x", "N", "min", "e", "key", "pl", "sp", "end", "ro", "right", "text", "nl", "this", "label", "o", "path", "co", "Right", "c", "wrong", "bottom", "internal", "shell", "file", "row", "cont", "F", "column", "null", "CL", "Left", "FL", "cl", "loc", "ALL"], "s": ["comments", "e", "us", "ns", "string", "cs", "l", "t", "south", "n", "right", "ans", "su", "r", "w", "sym", "secondary", "o", "sets", "square", "g", "c", "center", "ins", "h", "sum", "sb", "ws", "ses", "si", "y", "out", "strings", "ss", "m", "sign", "str", "S", "b", "p", "span", "d", "sg", "ed", "ls", "small", "lines", "a", "es", "ings", "ions", "sf"], "i": ["x", "id", "j", "ii", "e", "v", "im", "ip", "l", "n", "ei", "ind", "xi", "li", "iu", "r", "it", "o", "g", "c", "ti", "ie", "si", "I", "iw", " I", "IJ", "ci", "il", "m", "u", "ai", "p", "z", "pi", "int", "di", "io"], "cols": ["columnabs", " colspan", "colspan", "Colrows", "Colabs", "Cols", " colrows", "cold", "Cold", " cold", "COLspan", "COLn", "colrows", "columnn", "columnd", "Coln", "COLrows", "columns", "COLs", "colabs", " colabs", "Colspan", "coln", " coln"]}}
{"code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          a1 = int(f.readline())\n          l1 = [map(int, f.readline().split()) for _ in xrange(4)]\n          a2 = int(f.readline())\n          l2 = [map(int, f.readline().split()) for _ in xrange(4)]\n  \n          poss = list(set(l1[a1-1]) & set(l2[a2-1]))\n  \n          print \"Case #%d:\" % (_T + 1),\n          if len(poss) == 0:\n              print \"Volunteer cheated!\"\n          elif len(poss) == 1:\n              print poss[0]\n          else:\n              print \"Bad magician!\"\n", "substitutes": {"f": ["e", "fr", "v", "fast", "rf", "l", "t", "fo", "tf", "fa", "af", "r", "w", "fd", "feed", "o", "folder", "bf", "g", "c", "fe", "s", "i", "info", "conf", "inf", "file", "fw", "fen", "cf", "F", "fi", "handler", "of", "fp", "m", "b", "p", "fs", "fb", "df", "d", "z", "buff", "fc", "full", "form", "sf"], "fn": ["unc", "fat", "n", "dn", "utf", "output", "filename", "bn", "fd", "format", "oln", "fin", "o", "func", "ll", "path", "wl", "bf", "sn", "c", "len", "kn", "thin", "name", "fl", "file", "fw", "fen", "txt", "syn", "F", "fi", "fil", "method", "fm", "fp", "source", "function", "lf", "ln", "typ", "p", "FN", "fb", "fc", "feat", "full", "loc", "sf", "fun"], "T": ["N", "Y", "TN", "t", "P", "TS", "E", "G", "W", "K", "X", "Time", "R", "Q", "I", "B", "D", "F", "O", "S", "TT", "Z", "C", "length", "number", "M", "A", "L", "V"], "_T": ["_C", " _NT", "_Time", "_D", " _Time", " _N", "_N", "_NT", " _D", "_H", " _H", " _C"], "a1": ["alpha3", "A1", "A2", "A3", " a9", "A4", "alpha4", "alpha2", " a3", "a3", "a9", "a4", "l9", "A9", "l3", "l4", "alpha1"], "l1": ["ar2", "L_", "Lone", "l_", "aone", "ar1", "l8", "p2", "ar8", "el2", "lOne", "elOne", "arOne", "el1", "pOne", " lone", "a_", "lone", "el8", " l_", "p8", "L1", "p1", "L2"], "_": ["x", "all", "ip", "n", "un", "place", "ing", "len", "val", "out", "of", "non", "p", "line", "a", "al", "k", "ac"], "a2": ["r02", "atwo", "da8", "a02", " a8", "area02", "aII", "A2", "A4", "rII", "area2", "laII", "r2", "da82", "da4", "rtwo", "a82", "la02", "areaII", "a8", "a4", "la2", "A82", " a4", "A8", "latwo", "areatwo", " a82", "da2"], "l2": ["a0", " l4", "p2", " l0", "p3", " l3", "b0", "a3", "b4", "l0", "a4", "p4", "p0", "l3", "b2", "l4", "p1", "b1"], "poss": ["pott", "peOSS", " pOSS", "boss", "lposs", " poses", "boses", " pott", "apose", "pOSS", "peoss", "litch", "spore", " pore", "pitch", " pours", "lours", "pours", "peours", "apOSS", "peitch", "lpose", "POSS", "Pob", "lOSS", "lposes", "pose", "lpOSS", "bott", "pore", "aposs", "apob", "loss", "spott", "sposs", "pob", "Poss", "Poses", " pose", "poses", "bore", "sposes", " pitch", " pob", "Pose"]}}
{"code": " \n  \n  TEST_CASES = [\n      (\"\"\"5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \"\"\",\"\"\"Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  c......\n  .......\n  .......\n  ....***\n  Case #5:\n  c........*\n  .........*\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  \"\"\"),\n      (\"\"\"3\n  5 4 3\n  5 3 8\n  5 5 14\n  \"\"\",\"\"\"Case #1:\n  c...\n  ....\n  ....\n  ...*\n  ..**\n  Case #2:\n  Impossible\n  Case #3:\n  c...*\n  ....*\n  ...**\n  *****\n  *****\n  \"\"\")\n  ]\n  \n  IMPOSSIBLE = \"Impossible\"\n  \n  \"\"\"\n  S is number of safe squares = (R*C) - M\n  If S == 1 then always possible:\n      Assume click in top left, all else mines\n  Special cases (R or C is small):\n  If R == 1 or C == 1 then always possible:\n      Assume click in top left and all safe squares in a line\n  Else if R == 2 or C == 2 then possible iff S % 2 == 0:\n      Assume click in top left and all safe squares are in a 2 * X line\n  Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\n     OR if S % 2 == 0 \n  \"\"\"\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          input_line = [int(x) for x in input_reader.readline().split()]\n          input_values = {\"case\": case_idx,\n                          \"R\": input_line[0],\n                          \"C\": input_line[1],\n                          \"M\": input_line[2]}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      case = kwargs['case']\n      rows = kwargs['R']\n      cols = kwargs['C']\n      mines = kwargs['M']\n      safe_squares = ((rows * cols) - mines)\n      print >> output_writer, \"Case #%d:\" % case\n      row_string = \"{:*<%ds}\" % cols\n      impossible = False\n      if safe_squares == 1:\n          print >> output_writer, row_string.format(\"c\")\n          for row in range(1, rows):\n              print >> output_writer, row_string.format(\"\")\n      elif rows == 1:\n          safe_string = \"c\" + (\".\" * (safe_squares - 1))\n          print >> output_writer, row_string.format(safe_string)\n      elif cols == 1:\n          for row in range(rows):\n              cell = \"\"\n              if row == 0:\n                  cell = \"c\"\n              elif row < safe_squares:\n                  cell = \".\"\n              print >> output_writer, row_string.format(cell)\n      elif safe_squares == 2:\n          impossible = True\n      elif rows == 2:\n          safe_cols, remainder = divmod(safe_squares, 2)\n          if remainder == 1:\n              impossible = True\n          else:\n              safe_string = \".\" * (safe_cols - 1)\n              print >> output_writer, row_string.format(\"c%s\" % safe_string)\n              print >> output_writer, row_string.format(\".%s\" % safe_string)\n      elif cols == 2:\n          safe_rows, remainder = divmod(safe_squares, 2)\n          if remainder == 1:\n              impossible = True\n          else:\n              for row in range(rows):\n                  cells = \"\"\n                  if row == 0:\n                      cells = \"c.\"\n                  elif row < safe_rows:\n                      cells = \"..\"\n                  print >> output_writer, row_string.format(cells)\n      else:\n          safe_rows, remainder = divmod(safe_squares, cols)\n          if remainder == 1 and cols == 3 and safe_rows == 2:\n              impossible = True\n          elif safe_rows > 1:\n              if remainder == 1 and safe_rows == 2:\n                  mid_safe = \".\" * (cols-2)\n                  for row in range(rows):\n                      cell_one = \".\"\n                      mid_cells = mid_safe\n                      last_cell = \".\"\n                      if row == 0:\n                          cell_one = \"c\"\n                      elif safe_rows == 0:\n                          cell_one = \".\"\n                          mid_cells = \".\" * (remainder + 1)\n                      elif safe_rows < 0:\n                          cell_one = \"\"\n                          mid_cells = \"\"\n                      if safe_rows < 3:\n                          last_cell = \"\"\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              elif remainder == 1:\n                  mid_safe = \".\" * (cols-2)\n                  for row in range(rows):\n                      cell_one = \".\"\n                      mid_cells = mid_safe\n                      last_cell = \".\"\n                      if row == 0:\n                          cell_one = \"c\"\n                      elif safe_rows == 0:\n                          cell_one = \".\"\n                          mid_cells = \".\" * remainder\n                      elif safe_rows < 0:\n                          cell_one = \"\"\n                          mid_cells = \"\"\n                      if safe_rows < 2:\n                          last_cell = \"\"\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              else:\n                  full_safe = \".\" * cols\n                  for row in range(rows):\n                      cells = full_safe\n                      if row == 0:\n                          cells = \"c\" + (\".\" * (cols - 1))\n                      elif row == safe_rows:\n                          cells = \".\" * remainder\n                      elif row > safe_rows:\n                          cells = \"\"\n                      print >> output_writer, row_string.format(cells)\n          else:\n              safe_cols, remainder = divmod(safe_squares, 2)\n              if remainder == 1 and safe_cols < 4:\n                  impossible = True\n              elif remainder == 0:\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\n                  for row in range(2, rows):\n                      print >> output_writer, row_string.format(\"\")\n              else:\n                  safe_cols -= 1\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\n                  print >> output_writer, row_string.format(\"...\")\n                  for row in range(3, rows):\n                      print >> output_writer, row_string.format(\"\")\n      if impossible:\n          print >> output_writer, IMPOSSIBLE\n  \n  def solve_inputs(input_reader, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n              print problem_output\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n", "substitutes": {"TEST_CASES": ["TEST_CLATCHes", "TEST_CLASES", "TEST_CESTE", "TEST_CLASes", "TEST_CACES", "TEST_CESTS", "TEST_CATCHES", "TEST_CLASS", "TEST_CLATCHE", "TEST_CASS", "TEST_CLATCHES", "TEST_CATCHes", "TEST_CLATCHS", "TEST_CATCHE", "TEST_CASE", "TEST_CESTES", "TEST_CACS", "TEST_CATCHS", "TEST_CESTes", "TEST_CACE", "TEST_CACes", "TEST_CASes", "TEST_CLASE"], "IMPOSSIBLE": ["IMPOOSSIVE", "IMPUSIBLE", "IMPOSSible", "IMPOOSSBILITY", "IMPUSIVE", "IMPOUSIVE", "IMPOUSIBLE", "IMPENSIVE", "IMPOSSIVE", "IMPUSBILITY", "IMPOOSSible", "IMPONSible", "IMPOUSible", "IMPUSible", "IMPONSBILITY", "IMPONSIBLE", "IMPENSIBLE", "IMPONSIVE", "IMPENSBILITY", "IMPOOSSIBLE", "IMPOUSBILITY", "IMPENSible", "IMPOSSBILITY"], "input_reader": ["input_builder", "input_stream", "controlFileeditor", "case_resource", "controlFileslice", "inputFileeditor", "case_stream", "inputFilewriter", "inputingreader", "controlFilewriter", "inputingwriter", "input_writer", "controlFilereader", "inputingresource", " input_writer", "input_slice", "inputFileslice", "case_reader", "inputFilereader", "inputingstream", "control_editor", " input_source", " input_builder", "control_reader", "input_editor", "control_writer", "input_resource", "control_slice", "case_writer", "input_source"], "case_count": [" case_number", "case__count", "case__size", "case__number", "case_start", " case_limit", "case_number", "case_size", "case__limit", " case_start", "case_limit", " case_size"], "case_idx": ["casexidsx", "case_indexx", "case_idexs", "case_county", "case_countindex", "casexidxs", "case_Idy", "case_indexxs", "case_iden", "case_idindex", "casexidsn", "case_idsy", "case_indx", "casexidn", "casexcountindex", "case_idn", "case_idz", "casexidsz", "case_Idz", "case_idsz", "case_idxs", "case_Idct", "case_Idxs", "case_indz", "case_idct", "case_Idindex", "case_indn", "casexidx", "casexcountx", "case_idy", "casexidsy", "casexcountxs", "case_idxx", "case_indexxx", "case_Idx", "case_countx", "case_idect", "case_idsn", "casexidy", "case_idsct", "case_indy", "casexcounty", "case_countxs", "casexidz", "case_idsx", "case_countxx", "casexidindex", "case_Idn", "case_idsxs", "case_indexy", "case_idex"], "input_line": ["inputIPline", "inputFtry", "input2line", "inputIPaxis", "case_number", "image_status", "audio_line", "input_liner", "inputFaxis", "input2number", "inputmingaxis", "inputIPtry", "input_number", "image_liner", "input2lines", "output_lines", "audio_try", "image_line", "input2values", "input_look", "inputIPliner", "audioIPliner", "audioIPtry", "audioIPaxis", "inputmingliner", "output_liner", "inputmingtry", "inputmingline", "inputacstatus", "audio_liner", "input_status", "case_lines", "inputaclook", "inputacline", "output_line", "input_try", "inputFline", "audio_axis", "input_lines", "case_values", "input_sample", "inputacliner", "output_sample", "inputFliner", "input_axis", "audioIPline", "image_look", "case_line"], "x": ["rx", "xxxxxxxx", "id", "xx", "v", "e", "xe", "px", "index", "xb", "xy", "n", " xx", "xi", "xxxx", "fx", "xxx", "X", "ex", "i", "pe", "ww", "xp", "val", "y", " ex", "xc", "dx", "p", "xf", " ax", " v", "z", "ix", "ax", "wx", " X", " cx", " y"], "input_values": ["case_vals", "output_values", "output_vals", "output_errors", "input_rows", "output_types", "case_values", "input_value", "input_vals", "case_value", "input_errors", "input_types", "case_rows"], "output_writer": ["output64writers", "input_writer", "Output\n", "put\n", "input_writers", "outputpubparser", "outputpubengine", "output_reader", "outputappwriter", "outputingdriver", "output64reader", "output_driver", "output_engine", " output_parser", "output64riter", " output_reader", "outputingwriters", "input_riter", "output_writers", " output\n", "outputpubreader", "outputingeditor", "outputpubwriter", "input_data", "output_data", "outputingwriter", " output_riter", "input_editor", " output_engine", "output\n", "output64writer", "outputappengine", "outputappreader", "output_editor", "output_riter", "outputappparser", "output_parser", "input_driver"], "case": ["instance", "key", "charge", "code", "patch", "array", "result", "address", "trial", "count", "ace", "table", "ce", "catch", "time", "day", "shape", "space", "path", "match", "ice", "mode", "type", "pe", "section", "cd", "name", "position", "ci", "sequence", "base", "function", "cause", "line", "length", "division", "client", "error", "Case", "ase", "cases", "pair", "test"], "rows": ["blocks", "olds", "groups", "holes", "planes", "headers", "points", "models", "ries", "OWS", "features", "reads", "fields", "cats", "keys", "orders", "checks", "rooms", "classes", "ows", "ins", "users", "heads", "rings", "values", "tests", "ids", "runs", "breaks", "forms", "steps", "rs", "items", "ays", "flows", "types", "events", "results", "length", "ros", "errors", "lines", "frames", "cases", "xs", "pages", "faces", "times", "views", "ks", "jobs", "ches", "months", "dates"], "cols": ["columni", "widthals", "Colals", "widthts", "column_", " colts", "columnals", "velns", "Cols", " coli", "Coli", "cold", "columnes", "length_", "lengthsd", "veles", "columnsd", "colts", "colsd", "veli", "contract_", "contractd", "columnns", "columnd", "columnts", "columns", " coles", "coli", "colals", "lengths", "lengthd", " colals", "col_", "widthes", "Coles", "coles", "widths", "vels", "colns", "contracts", "contractsd", " colns"], "mines": ["minss", "colions", "Minions", "minions", "minsizes", "minsor", "mins", "Mins", " mins", "Minizes", " minor", "minses", " minions", " minizes", "minor", "Mines", "color", "minizes", "coles", "colizes"], "safe_squares": ["safe_squared", "safe_quared", "safe_quares", "safe_aquapes", "safe_sqakes", "safe_quars", "safe_sqared", "safe_aquares", "safe_aquarations", "safe_sqares", "safe_sqarations", "safe_Squars", "safe_sqapes", "safe_Squakes", "safe_Squares", "safe_quapes", "safe_quarations", "safe_squakes", "safe_quakes", "safe_Squared", "safe_squarations", "safe_sqars", "safe_squars", "safe_aquars", "safe_squapes"], "row_string": ["row_source", " row_strings", "row64strings", "row_array", "cell_reference", "row_reference", "row_writer", "safe_writer", "rowpstring", "row_setting", "cell_string", "rowgnumber", "row64setting", "cell_str", "rowingstrings", "rowpstrings", "row_str", "rowgsection", "rowingtext", "row64string", "rowingstring", "cell_text", " row_array", " row_source", "row_number", "row64text", "row_section", "safe_section", "rowingsetting", "cell_strings", "rowpsource", "rowgstring", "cell_setting", "row_text", "row_strings", "safe_number", "rowgwriter", "rowparray"], "impossible": [" impacted", " impure", "possible", "impossibility", "impure", "pure", "Impossibility", "Impacted", "possibility", " impossibility", "Impure", "Impossible", "pacted", "impacted"], "row": ["layer", "instance", "Row", "rown", "key", "object", "index", "user", "array", "ro", "slice", "low", "model", "month", "r", "w", "feed", "col", "offset", "group", "round", "record", "value", "batch", "raw", "mod", "ow", "num", "skip", "range", "column", "ver", "roll", "block", "df", "length", "diff", "entry", "auto", "error", "rect", "k", "port", "page", "test"], "safe_string": ["safety_ring", "safexring", "safety_space", "protected_strings", "safexspace", "safe___string", "safe_space", "safety___string", "safexstring", "safety_letter", "safexletter", "safety___space", "safe_ring", "safe_strings", "safe_letter", "safety___letter", "protected_String", "safe_String", "safe___ring", "safe___space", "safety_string", "safe___letter", "safety___ring", "protected_string", "protected_ring"], "cell": ["double", "flow", "parent", "child", "slice", "conference", "count", "text", "pixel", "cache", "field", "ell", "label", "col", "group", "cel", "co", "square", "c", "window", "section", "element", "name", "unit", "range", "column", "phone", "call", "line", "auto", "entry", "year", "client", "form", "node", "wrapper", "Cell", "char"]}}
{"code": " \n  \n  TEST_CASES = [\n      (\"\"\"3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \"\"\",\"\"\"Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  \"\"\"),\n      (\"\"\"1\n  1\n  15 9 16 5\n  6 10 1 3\n  2 4 12 11\n  13 14 8 7\n  1\n  5 10 9 6\n  12 15 1 11\n  14 16 4 2\n  13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\n  \"\"\")\n  ]\n  \n  BAD_MAGIC = \"Bad magician!\"\n  CHEATING = \"Volunteer cheated!\"\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          rows = []\n          for loop_idx in (1,2):\n              row_idx = int(input_reader.readline())\n              for idx in (1,2,3,4):\n                  if idx == row_idx:\n                      rows.append(set(input_reader.readline().rstrip(\"\n\").split(\" \")))\n                  else:\n                      input_reader.readline()\n          input_values = {\"rows\":rows,\n                          \"case\":case_idx}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      rows = kwargs['rows']\n      case = kwargs['case']\n      intersect = rows[0].intersection(rows[1])\n      if not intersect:\n          msg = CHEATING\n      elif len(intersect) == 1:\n          msg = intersect.pop()\n      else:\n          msg = BAD_MAGIC\n      print >>output_writer, \"Case #%d: %s\" % (case, msg)\n  \n  def solve_inputs(input_reader, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      \"\"\"\n      Check the sample input and output match.\n      \"\"\"\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n          print problem_output\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n", "substitutes": {"TEST_CASES": ["TEST_SCATCHES", "TEST_SCATCHes", "TEST_CASEes", "TEST_CACIONS", "TEST_CACES", "TEST_CATCHIONS", "TEST_CATCHES", "TEST_SCASIONS", "TEST_SCASS", "TEST_CASS", "TEST_CASIONS", "TEST_SCATCHS", "TEST_CATCHes", "TEST_CACS", "TEST_CATCHS", "TEST_CASEES", "TEST_SCATCHIONS", "TEST_SCASes", "TEST_CACes", "TEST_CASes", "TEST_CASEIONS", "TEST_SCASES"], "BAD_MAGIC": ["BAD_TOPIC", "BAD_STATICS", "BAD_TOPICK", "BADJMAGENT", "BADLEMAGIC", "BADLEMAGIT", "BAD_GERICS", "BAD_GENIC", "BAD_MAGICK", "BADLEMAGICS", "BAD_LOGICS", "BADLEMAGICK", "BADJMAGICK", "BADJMAGICS", "BAD_MAGIT", "BAD_GENENT", "BAD_LOGIC", "BAD_LOGENT", "BADLETOPIT", "BAD_TOPICS", "BADLETOPICS", "BAD_MAGENT", "BAD_GERICK", "BADJLOGENT", "BAD_STATIT", "BAD_GENICK", "BAD_LOGICK", "BAD_MAGICS", "BAD_LOGIT", "BAD_GENICS", "BAD_STATICK", "BAD_GERIC", "BAD_GERENT", "BAD_TOPIT", "BADJMAGIC", "BAD_STATIC", "BADLETOPIC", "BADLETOPICK", "BADJLOGIC", "BADJLOGICS", "BADJLOGICK"], "CHEATING": ["CHFEATE", " CHPEATING", "CHEATER", "CHFEATING", " CHPEating", "ECHEating", "CHEATE", "CHEEATING", "CHEEating", " CHEATE", "ECHEATED", "CHEEATE", " CHPEATE", "CHMEATING", "CHPEATED", "CHEEATER", "CHPEating", "CHFEATED", "ECHPEATING", " CHEating", "ECHPEATED", "CHMEating", " CHEATED", "CHMEATED", "ECHPEATER", "CHEATED", "CHPEATER", "CHEEATED", "ECHEATER", "CHFEating", "CHPEATE", "ECHEATING", " CHPEATED", "CHPEATING", "CHMEATER", "ECHPEating", "CHEating"], "input_reader": ["active_editor", " input_parser", "inputFileenter", "inputFiledriver", "input_worker", "inputingreader", "output_stream", "input_writer", "inputFileparser", "inputfilestream", "textFileparser", "jsonFilereader", "output_server", "activeingeditor", "output_reader", "json_server", "active_reader", "output_object", "json_writer", "inputfdriver", "inputFwriter", "active_writer", "inputFilewriter", "inputfobject", "inputFobject", "inputingwriter", "inputfwriter", "inputFileserver", "text_writer", "inputFserver", "inputfreader", "text_parser", "input_iter", "input_enter", "input_stream", "inputFreader", "json_reader", "inputfilereader", "text_reader", "inputfserver", "inputFilereader", "jsonFilewriter", "activeingreader", "input_server", "jsonFileserver", "jsonFiledriver", "input_editor", "output_worker", "input_object", "active_iter", "textFilereader", "json_driver", "inputfilewriter", "textFilewriter", "input_parser", "activeingiter", "textFileenter", "text_enter", " input_writer", "inputfileworker", " input_inner", "inputingeditor", "inputingiter", "input_driver", "activeingwriter", "input_inner"], "case_count": ["casefnum", "case_level", "case__group", "casefcount", "casefid", "case__count", "result64area", "result64sum", "caseflevel", "result64group", "result_group", "result64count", "case__sum", "result_sum", "line_num", "case_sum", "line_id", "line_level", "case_num", "line_count", "result_count", "case_id", "case_group", "result_area", "case64count", "case__area", "case64group", "case64sum", "case_area", "case64area"], "case_idx": ["case_initx", "case_endz", "case_pidxf", "case_initxes", "case_idxe", "case_idX", "case_indx", "case_endx", "case_endy", "case_idz", "case_inxf", "case_Idz", "case_idxc", "case_pidz", "case_idxs", "case_idsz", "case_Idxs", "case_initz", "case_inz", "case_Idxf", "case_indz", "case_idxf", "case_indxe", "case_endxe", "case_Idxc", "case_pidxs", "case_idy", "case_idsxc", "case_idsX", "case_Idx", "case_initxs", "case_indy", "case_pidx", "case_inx", "case_idxes", "case_idsx", "case_Idxes", "case_IdX", "case_inxs"], "rows": ["blocks", "rown", "olds", "groups", "holes", "headers", "planes", "array", "models", "OWS", "docs", "reads", "fields", "keys", "feed", "orders", "locks", "posts", "ks", "files", "rooms", "opens", "ows", "users", "rings", "values", "raw", "tests", "row", "loads", "cells", "ids", "runs", "vers", "rs", "relations", "items", "ays", "flows", "types", "events", "details", "results", "days", "rules", "ros", "reports", "lines", "errors", "frames", "cases", "pages", "boxes", "data", "uds", "views", "projects", "shows", "times", "ches", "months"], "loop_idx": ["case_idsxf", "case_idsc", "case_idsf", "case_idc", "case_idxf", "case_midx", "case_countc", "case_idf", "case_countx", "case_midxf", "case_midc", "case_idsx", "case_countf", "case_countxf", "case_midf"], "row_idx": ["row_idsxes", "row_idsi", "row___intxs", "row___intx", "row_idex", "row___idd", "row___idx", "row_idxs", "row___idex", "row_intd", "row_partex", "row_inti", "row___intd", "row_intxs", "row_keyx", "row_inty", "row_keyxs", "row_idxes", "row_keyex", "row_idd", "row_idy", "row_idi", "row_intxes", "row_intx", "row_intex", "row___intex", "row_idsy", "row_partx", "row_partxs", "row_idsx", "row_partd", "row_keyd", "row___idxs"], "idx": ["Idx", " idxc", "idz", "Idxs", "end_", "Idz", "idxs", "countx", "endx", "Idxc", " idxx", " idxs", "count_", "endxy", "idxy", "countxy", " idz", "endxx", "id_", "idez", " idxy", " id_", "idex", "idxc", "idexs", "idxx", "idexc", "countxx"], "input_values": ["inputMkeys", "input_keys", " input_ids", "input_rows", "inputsvs", "input_vs", "inputMvalues", "inputsvals", "input_value", "inputsvalue", "input_vals", " input_vals", "inputMrows", "Input_rows", "Input_value", "Input_vals", "Input_values", "Input_vs", "Input_keys", " input_vs", "input_ids", "inputsvalues", "inputMvalue"], "output_writer": ["output___reader", "outputfreader", "output___writers", "current_reader", "outputfeditor", " output_writers", "current_writer", "input_writer", " output_entry", "current_writers", "input_writers", "output_server", "outputfentry", "output_entry", " output_reader", "output_reader", "output_editor", "outputfwriters", "output___server", "input_editor", "current_server", "output_writers", "output___writer", "outputfwriter"], "case": ["instance", "nce", "bug", "sea", "hyp", "uc", "key", "rule", "patch", "code", "slice", "address", "count", "trial", "ace", "ce", "catch", "ca", "chance", "order", "shape", "path", "match", "ice", "type", "pe", "section", "exc", "name", "row", "ci", "base", "cm", "call", "block", "line", "client", "force", "Case", "ase", "cases", "cell", "cp", "test"], "intersect": ["Intersect", "interconnect", "crossrupt", "interrupt", "corsections", "oversection", "intercept", "interct", " interect", "consect", "iterrupt", "Intercept", "interract", " interract", "itersect", "interect", " intersection", "Intersections", "conrupt", "intersection", "intersections", "crossconnect", " interct", "Interconnect", "itersection", "oversect", "crosssect", "conconnect", "consection", "corsection", "Interract", "concept", "corct", "overract", "itercept", "Interct", "Interrupt", "Interect", "overect", "corsect", "Intersection", "crosssection", " intersections"], "msg": ["bug", "warn", "warning", "err", "log", "html", "mt", "gen", "sym", "fg", "Message", "mn", "g", "lang", "cfg", "bg", "ms", "module", "arg", "exc", "comm", "mag", "title", "cmd", "reason", "ag", "message", "fm", "m", "cm", "og", "str", "req", "ext", "sim", "mess", "debug", "sg", "nm", "error", "md", "mid", "Msg", "notice", "dm", "doc", "comment", "cy"]}}
{"code": "__author__ = 'Jeffrey'\n  \n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-small-attempt0.in\"\n  \n  outFileName = inFileName[: -2] + \"out\"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          L.append([int(i) for i in f.readline().split()])\n  \n      return T, L\n  \n  \n  def calculateOneClick(R, C, M):\n      size = R * C\n      if R == 1 or C == 1 and M < size:\n          return generateWinBoardBaseCase(R, C, M)\n      elif size - M == 1:\n          return generateWinBoardBaseCase(R, C, M)\n      elif size - M >= 4:\n          return generateWinBoard(R, C, M)\n      return \"Impossible\"\n  \n  def generateWinBoard(R,C,M):\n      emptySpace = R * C - M - 4\n      out = \"c\"\n      if C > 1:\n          out += \".\"\n          for i in range(2,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      if R > 1:\n          out += '\n'\n          out += \".\"\n          if C > 1:\n              out += \".\"\n          for i in range(2,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      for r in range(2,R):\n          out += '\n'\n          for c in range(C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      return out\n  \n  def generateWinBoardBaseCase(R,C,M):\n      emptySpace = R * C - M - 1\n      out = \"c\"\n      if C > 1:\n          for c in range(1,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      for r in range(1,R):\n          out += '\n'\n          for c in range(C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      return out\n  \n  \n  def playGame(T, L):\n      for i in range(T):\n          result = calculateOneClick(L[i][0], L[i][1], L[i][2])\n          yield \"Case #\" + str(i + 1) + \":\n\" + str(result)\n  \n  \n  if __name__ == \"__main__\":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      print(T)\n      print(L)\n  \n      oF = open(outFileName, \"wb\")\n      for out in playGame(T, L):\n          print(out)\n          oF.write(bytes(out + \"\n\", 'utf-8'))\n      oF.close()\n", "substitutes": {"__author__": ["__creator___", "__creator__", "__version__", "__version___", "__author___", " __creator__", " __author___", "__authors__", "__authors___", " __creator___"], "inFileName": ["inPlacePath", "inLineName", "outClassNames", "inFilesUrl", "inPlaceLine", "inStreamNames", "inStreamName", "inPlaceName", "inFilePath", " inDirHandle", "outClassUrl", "inLineLine", "inFilesNames", "inClassUrl", "inStreamUrl", "inFileLine", "inPlaceHandle", "inDirName", "inLinePath", "outFileNames", "inFileNames", "inDirLine", " inDirPath", "inLineHandle", "inFileHandle", "inClassPath", "inDirPath", " inFileLine", " inDirLine", "inFilesPath", "inStreamPath", "inClassName", "outClassName", "inDirHandle", "inFilesName", "outFilePath", "outClassPath", "outFileUrl", " inFileHandle", " inFilePath", "inFileUrl", " inDirName", "inClassNames"], "outFileName": ["outputDirFile", "outputDirName", "outDirSize", "outDirectoryName", "outFullName", "outFileFile", "outDirectoryFile", "outputFileSize", "outputDirPath", "outFullSize", "outFullPath", "outputFileFile", "outDirectoryPath", "outDirectorySize", "outFileSize", "outputFileName", "outFullFile", "outDirName", "outDirPath", "outputDirSize", "outDirFile", "outFilePath", "outputFilePath"], "f": ["x", "e", "fr", "v", "http", "rf", "l", "t", "fo", "fa", "af", "stream", "w", "fd", "feed", "bf", "g", "fe", "h", "conf", "inf", "fl", "file", "arf", "input", "F", "fi", "fp", "m", "b", "p", "fs", "xf", "df", "d", "fb", "z", "fc", "a", "k", "form", "aff"], "T": ["N", "Y", "Ts", "Int", "t", "P", "PT", "Port", "DT", "TS", "TI", "RT", "U", "Length", "E", "H", "G", "W", "K", "X", "LT", "Time", "TX", "NT", "Q", "Tu", "I", "B", "TA", "D", "F", "WT", "O", "CT", "TG", "S", "TT", "Z", "Len", "GT", "int", "TB", "A", "V", "IP"], "L": ["N", "NL", "EL", "l", "P", "LA", "TL", "dL", "J", "We", "E", "H", "G", "DL", "BL", "LU", "W", "VL", "K", "LT", "SL", "LL", "LB", "Q", "LC", "ML", "I", "B", "D", "F", "LM", "LR", "LI", "LP", "IL", "S", "O", "Z", "RL", "LS", "CL", "XL", "FL", " l", "Line", "LE", "V", "Lu"], "i": ["x", "id", "j", "ui", "ii", "e", "v", "index", "ip", "l", "t", "n", "ind", "q", "ei", "lc", "xi", "li", "iu", "it", "o", "g", "ti", "ie", "gi", "h", "ar", "ir", "si", "I", "iw", "input", "ci", "il", "iq", "u", "m", "ic", "ai", "b", "p", "d", "z", "pi", "int", "a", "di", "k", "cl", "io"], "R": ["Rh", "TR", "N", "Y", "GR", "Rs", "Range", "P", "RE", "MR", "Cl", "J", "CR", "RH", "Re", "RT", "JR", "E", "Rec", "G", "H", "SR", "RM", "W", "RO", "K", "X", "Right", "Gr", "RW", "ER", "Q", "DR", "RS", "BR", "I", "B", "Run", "RP", "AR", "D", "F", "Ro", "RG", "RC", "Ra", "O", "LR", "S", "RR", "V", "Res", "NR", "OR", "KR", "WR", "A", "Role", "U", "RA"], "C": ["N", "Y", "NC", "SC", "CNN", "Rs", "Cs", "P", "Com", "VC", "Context", "DC", "CM", "CR", "Or", "Cl", "CF", "U", "Con", "E", "CE", "Size", "H", "G", "Channel", "W", "CA", "K", "X", "YC", "Sc", "Co", "There", "CV", "CC", "Q", "CS", "Cu", "B", "I", "From", "CI", "D", "F", "Ch", "O", "CT", "S", "CL", "Custom", "EC", "MC", "You", "V", "Case", "Count", "CU", "WC", "Code", "A", "Cr"], "M": ["N", "Y", "MD", "FM", "P", "MS", "Man", "J", "CM", "Ms", "VM", "Min", "MT", "E", "G", "H", "Size", "RM", "W", "DM", "Mode", "AM", "K", "X", "NM", "Mo", "Q", "I", "B", "MF", "D", "F", "MB", "LM", "MM", "Mon", "m", "O", "S", "Z", "MN", "CL", "MC", "V", "Mc", "IM", "A", "U"], "size": ["N", "Y", "n", "sec", "core", "member", "ize", "w", "G", "Size", "shape", "W", "empty", "sn", "mode", "sh", "sc", "sum", "position", "max", "si", "SIZE", "large", "six", "cm", "m", "S", "capacity", "z", "length", "small", "scale", "mini", "cl", "content", "loc", "sized", "number", "case"], "emptySpace": ["noneSp", "emptyRoom", "fullSpace", "emptyPlace", "noneSand", "emptySand", "errorSp", "errorPlace", "emptySp", "originalSp", "exclusiveSpace", "nonePlace", " emptyLine", "missingSp", "emptySpread", "execSpace", "EmptyService", "execSp", "openSpace", "filledShipping", " emptyService", "originalspace", "nicCase", "openSp", " emptySp", "errorSand", "equalSp", "activeSp", "fullSp", "EmptySand", "equalSpace", "originalLine", "brokenCase", "emptyService", "brokenSpace", "filledSpace", "EmptySpace", "brokenSp", "activespace", "missingSpace", "emptyspace", "execSpread", "originalSpace", "openRoom", "EmptySp", "brokenSpread", "fullShipping", "EmptyRoom", "EmptyPlace", "missingShipping", "errorSpace", "emptyCase", "exclusiveSp", " emptySample", "emptyShipping", "execPlace", "EmptyCase", "nicPlace", "openLine", "EmptyLine", "EmptyShipping", "EmptySpread", "filledSp", " emptyspace", " emptyRoom", "Emptyspace", "equalService", "emptyLine", "activeSpace", "noneSpace", "emptySample", " emptyShipping", "brokenPlace", "fullLine", "exclusiveLine", "nicSp", "nicSpace", "exclusiveSample", "EmptySample"], "out": ["parent", "script", "err", "t", "ref", "match", "window", "Out", "qa", "call", "obj", "pre", "timeout", "no", "n", "url", "at", "list", "ex", "bit", "name", "again", "function", "pool", "ext", "p", "block", "diff", "new", "response", "full", "error", "flat", "number", "point", "bin", "word", "token", "all", "OUT", "external", "multi", "outs", "query", "user", "output", "up", "temp", "it", "init", "raw", "static", "d", "line", "client", "doc", "data", "part", "version", "key", "string", "end", "trial", "cache", "post", "w", "copy", "channel", "this", "o", "co", "conn", "sum", "cmd", "file", "null", "lib", "z", "int", "option", "goal", "io", "off", "exp", "page"], "r": ["j", "v", "rr", "err", "yr", "ru", "br", "ro", "q", "right", "cr", "ir", "h", "ar", "kr", "nr", "rc", "sr", "range", "ur", "m", "rb", "u", "rs", "b", "p", "ra", "rg", "re", "k", "er", "rn"], "c": ["x", "e", "pc", "nc", "v", "cat", "cs", "l", "code", "n", "lc", "oc", "q", "ce", "w", "cu", "col", "ec", "cr", "g", "cd", "arc", "y", "cf", "ci", "u", "cm", "ic", "m", "b", "p", "z", "ct", "cc", "cy", "cl", "k", "ac"], "result": ["err", "res", "Result", "default", "score", "card", "success", "trial", "final", "output", "text", "url", "match", "dict", "list", "ret", "source", "cost", "RET", "results", "response", "diff", "entry", "new", "back", "data", "page"]}}
{"code": "__author__ = 'Jeffrey'\n  \n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.in\"\n  outFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.out\"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          picks = []\n          cards = []\n          for j in range(2):\n              picks.append( int(f.readline()))\n              tempL = []\n              for k in range(4):\n                  tempL.append( [int(j) for j in f.readline().split()])\n              cards.append(tempL)\n          L.append((picks, cards))\n  \n      return T, L\n  \n  \n  def performTrick(picks, cards):\n      matchFound = False\n      matchedCard = None\n      for card in cards[0][picks[0] - 1]:\n          possibleMatch = card in cards[1][picks[1] - 1]\n          if possibleMatch and matchFound:\n              return \"Bad magician!\"\n          elif possibleMatch:\n              matchFound = True\n              matchedCard = card\n      if matchFound:\n          return matchedCard\n      else:\n          return \"Volunteer cheated!\"\n  \n  \n  def playGame(T,L):\n      for i in range(T):\n          result = performTrick(L[i][0], L[i][1])\n          yield \"Case #\" + str(i + 1) + \": \" + str(result)\n  \n  \n  if __name__==\"__main__\":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      oF = open(outFileName, \"wb\")\n      for out in playGame(T, L):\n          oF.write(bytes(out + \"\n\",'utf-8'))\n      oF.close()\n", "substitutes": {"__author__": ["__creator__", "__Author__", " __version__", "__version____", " __version____", "__version__", "__Author____", " __author____", "__author____", "__creator____"], "inFileName": ["inModuleNames", "diffFileN", "configFilenameNames", "inModulename", "inModuleType", "configFilenameType", "inPathName", "inFilenameNames", "configFilenameName", "configFileType", "inDirectoryN", "inModuleName", "infilename", "inFilenameType", "inFilenameN", "configFileName", "inFileN", "infileNames", "diffFilenameName", "inDirectoryDie", "inFilename", "inPathDie", "inFileNames", "inPathN", "diffFilenameDie", "inDirectoryName", "infileName", "inFileType", "configFilenamename", "diffFileDie", "diffFileName", "configFilename", "diffFilenameN", "inFilenameName", "inFilenamename", "inFileDie", "configFileNames", "inFilenameDie", "infileType"], "outFileName": ["exFileNum", "exFilenameNum", "outFunctionName", "outFileFile", "outDirNum", "outFilenameName", "OutDirName", "outFunctionname", "exFilePath", "OutFileName", "OutFileFile", "outFilenamePath", "outfileName", "exFileName", "outFileNum", "outfilePath", "exFilenameName", "outFilenameFile", "outDirName", "outDirEnd", "outDirPath", "outfileEnd", "outFunctionPath", "outfileNum", "outDirname", "OutDirFile", "outFilenameEnd", "OutFilePath", "outDirFile", "outFilePath", "exFileEnd", "outFilename", "outFileEnd", "exFilenamePath", "outFilenameNum", "OutDirPath", "outFunctionFile", "exFilenameEnd", "outFilenamename", "OutDirname", "OutFilename"], "f": ["x", "fn", "e", "fr", "v", "ff", "rf", "l", "t", "n", "fo", "fa", "stream", "w", "fd", "feed", "files", "path", "g", "fe", "c", "self", "conf", "inf", "fl", "file", "fen", "fw", "F", "fi", "handler", "of", "fp", "m", "found", "lf", "b", "p", "fs", "xf", "df", "d", "fb", "z", "buff", "fc", "form", "io", "sf"], "T": ["N", "Y", "Total", "Ts", "t", "P", "TL", "TIME", "PT", "TH", "TF", "Input", "DT", "TS", "TI", "Length", "E", "Temp", "G", "H", "W", "K", "X", "LT", "Time", "R", "Test", "TW", "NT", "Q", "Tu", "I", "B", "TA", "D", "F", "WT", "O", "CT", "TG", "S", "TT", "Z", "C", "V", "Part", "UT", "TB", "M", "A", "Two", "U"], "L": ["Long", "N", "NL", "EL", "l", "P", "LA", "PL", "lc", "dL", "TL", "J", "E", "G", "BL", "DL", "ll", "W", "K", "X", "VL", "LT", "SL", "LL", "R", "LC", "LB", "List", "ML", "I", "B", "left", "D", "F", "letters", "LM", "O", "lf", "Card", "LR", "LI", "Len", "Z", "CL", "LS", "C", "IL", "LP", "XL", "Left", "line", "lines", "FL", " l", "Line", "cl", "Li", "M", "A", "Lo", "V", "Lu"], "i": ["ji", "x", "ui", "ii", "v", "e", "bi", "ri", "ik", "index", "ip", "l", "multi", "n", "t", "phi", "ind", "ei", "xi", "yi", "li", "iu", "it", "o", "init", "uni", "c", "ti", "ie", "qi", "gi", "ir", "chi", "name", "y", "si", "oi", "I", "iw", "eni", "start", "uri", "ni", "ci", "ini", "iq", "u", "ib", "bis", "ai", "p", "pi", "int", "a", "di", "zi", "io"], "picks": ["Pick", "licked", "tips", "prickets", "cickers", "prarks", "hicks", "vickers", "sicks", "parks", "sickets", "spips", "nicks", "spicks", "vics", " parks", "pices", " pickets", "pics", " pics", "tick", "sarks", "spickers", "Picked", " pushes", "Pips", "Pickers", " picking", "vices", "pricks", "pushes", "nics", "lickers", "cicks", "cick", "nicking", " pickers", " pips", "licks", "lics", "Picks", "spicking", "pick", "hickers", "hicked", "pickers", "sushes", "lick", "lices", "cics", "picked", "picking", "spics", "nickers", "vicks", "cips", "tickers", "spices", "hick", "pips", "ticks", "prushes", "pickets"], "cards": ["comments", "members", "bands", "lists", "groups", "phones", "holes", "outs", "l", "videos", "lc", "games", "liners", "limits", "cas", "fields", "cats", "friends", "ventures", "players", "cycles", "files", "clips", "checks", "words", " Cards", "Contents", "cons", "services", "caps", "codes", "books", "cuts", "balls", "lv", "cf", "left", "styles", "cells", "quarters", "letters", "strings", "breaks", "photos", "Card", "ards", "packs", "layout", "sticks", "events", "apes", "pieces", "rules", "ls", "names", "lights", "lines", "charges", "cases", "icks", "cl", "cell", "stars", "Lu"], "j": ["ji", "x", "v", "ii", " n", "index", "ip", "l", "dj", "n", "code", "J", "jj", "xi", "li", "r", "it", "jc", "js", "g", " c", "c", " jo", "ie", "oj", "jp", "jam", "kj", "jl", "y", "left", "job", "m", "u", "b", "p", "ch", "d", "aj", "z", "line", "int", "ja", "ij", " l", "a", " dj", "cell", "point", "uj"], "tempL": ["newl", " tempUL", "tmpL", "teml", "tempN", "TempI", "tempCL", "testL", "newO", "testUL", "testCL", "temI", " tempN", " tempI", "TempN", "testN", " templ", "Templ", "tempO", "newB", "tmpN", "tempB", "temN", "tmpUL", " tempB", "tempI", "templ", "tempUL", "TempL", "temL", " tempCL", "tmpCL", "temB", " tempO", "temO", "newL"], "k": ["ji", " n", "ik", "ky", "km", "q", "J", "ak", "kk", "ki", "o", "g", "c", "h", "ke", "jack", "kj", "y", "ci", "jo", "ai", "b", "d", "z", "ja", "ijk", "ka"], "matchFound": ["matchFind", "resultMade", "resultFound", "searchMade", "Matchfound", " matchfound", "cardfound", "cardFound", "searchFound", "MatchFind", "searchFind", " matchFind", "resultFind", "casefound", "matchMade", "MatchFound", "matchfound", "caseFound", " matchMade", "cardFind"], "matchedCard": ["successfulCard", "protectedCase", "checkedCard", "matchedCase", "atchedCard", " unmatchedCard", "matchedcard", "checkedcard", "affectedCase", " matchedcard", "matchedGame", "successfulGame", "protectedcard", "affectedCode", " unmatchedCase", "successfulcard", "protectedCard", " matchedCode", "matchedCode", " unmatchedCode", " matchedGame", "checkedGame", "atchedcard", " matchedCase", "affectedCard", "atchedCase"], "card": ["game", "id", "bug", "cat", "draw", "string", "index", "code", "default", "play", "character", "pixel", "catch", "cas", "event", "coord", "board", "match", "c", "list", "coll", "Match", "pattern", "letter", "cf", "style", "custom", "ard", "null", "Card", "cand", "cross", "check", "back", "comment", "cell", "contact", "case", "number", "point", "cart", "char", "word"], "possibleMatch": ["PossibilityMat", "possibleCapture", "possiblyMatch", "PossibleSearch", "pableMatch", "spossibleCase", "possibilitySearch", "permanentCapture", "PossibilityMatch", "possibleCase", "PossibilityCapture", "possibilityCase", "possiblyMat", "spossibleMatch", "possibilityMatch", "PossibleMat", "PossibleCapture", "possiblyCase", "PossibilitySearch", "Possiblematch", "possibilitymatch", "spossibilityCase", "Possibilitymatch", "spossibleCapture", "possiblySearch", "possiblyCapture", "possibilityMat", "permanentMatch", "possiblematch", "spossibilityCapture", "permanentCase", "possibleSearch", "PossibleMatch", "possiblymatch", "possibilityCapture", "possibleMat", "pableCapture", "pableMat", "spossibilityMatch"], "result": ["successful", "valid", "err", "res", "string", "Result", "grade", "our", "ner", "compl", "success", "default", "output", "text", "complete", "event", "json", "r", "status", "answer", "match", "value", "dict", "sum", "val", "rc", "ret", "desc", "message", "results", "response", "diff", "error", "comment", "case", "data", "test"], "iF": ["ff", "iFs", " iFM", "oiMF", "iFS", "yiMF", "pFM", "xiF", " iMF", "fFM", "IFS", "oiFS", "pW", "iGF", " iW", "pF", "iMF", "oiGF", "oiFs", "xiFS", "yiFs", "pf", "xiFs", "xif", "IFs", "yiGF", "iFM", "IF", "oiF", "oif", " iGF", " iFs", "yiF", "If", "iW", "fW", "fF"], "oF": ["eEF", "koF", "koV", "OF", "iV", "doV", "oEF", "oGF", "lM", " oB", "koO", " oEF", "iB", "Of", " oM", "eM", "oB", "oO", " oO", "iGF", "lELF", "doB", "lEF", "of", " oGF", "lF", "oELF", "OO", "oM", "oV", "OV", " of", "eELF", "eF", "kof", " oV", " oELF", "doGF", "doF"], "out": ["prefix", "game", "all", "v", "OUT", "err", "draw", "outs", "get", "output", "table", "Output", "text", "it", "net", "this", "match", "c", "set", "ex", "Out", "update", " output", "s", "template", "sum", "buffer", "tmp", "you", "again", "IN", "of", "source", "m", "b", "yout", "In", "new", "int", "obj", "example", "io", "data", "temp", "word"]}}
{"code": " \n  \n  def print_basic_board(no_mine, r, c):\n      printed_c = False\n      for row in range(0, r):\n          line = []\n          for column in range(0, c):\n              if printed_c:\n                  if no_mine > 0:\n                      line.append(\".\")\n                      no_mine -= 1\n                  else:\n                      line.append(\"*\")\n              else:\n                  line.append(\"c\")\n                  no_mine -= 1\n                  printed_c = True\n          print \"\".join(line)\n  \n  \n  def print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c):\n      printed_c = False\n      for row in range(0, r):\n          line = []\n          for column in range(0, c):\n              if printed_c:\n                  if row < no_mine_row and column < no_mine_column:\n                      line.append(\".\")\n                  elif rest_no_mine_for_column > 0 and column == no_mine_column:\n                      line.append(\".\")\n                      rest_no_mine_for_column -= 1\n                  elif rest_no_mine_for_row > 0 and row == no_mine_row:\n                      line.append(\".\")\n                      rest_no_mine_for_row -= 1\n                  else:\n                      line.append(\"*\")\n              else:\n                  line.append(\"c\")\n                  printed_c = True\n          print \"\".join(line)\n  \n  \n  def solve_case(r, c, m, case_number):\n      print \"Case #%d:\" % case_number\n      no_mine = r * c - m\n      if r < 2 or c < 2 or no_mine == 1:\n          print_basic_board(no_mine, r, c)\n      else:\n          no_mine_row_max = int(math.ceil(float(no_mine) / 2))\n          if no_mine_row_max > r:\n              no_mine_row_max = r\n          for no_mine_column in range(2, int(math.ceil(float(no_mine) / 2)) + 1):\n              if no_mine_column > c:\n                  break\n              for no_mine_row in range(2, no_mine_row_max + 1):\n                  rest_no_mine = no_mine - (no_mine_column * no_mine_row)\n                  if rest_no_mine < 0:\n                      continue\n                  if rest_no_mine == 1:\n                      continue\n  \n                  if rest_no_mine == 0:\n                      print_board(no_mine_row, no_mine_column, 0, 0, r, c)\n                      return\n                  if rest_no_mine <= no_mine_row and no_mine_column < c:\n                      print_board(no_mine_row, no_mine_column, 0, rest_no_mine, r, c)\n                      return\n                  if rest_no_mine <= no_mine_column and no_mine_row < r:\n                      print_board(no_mine_row, no_mine_column, rest_no_mine, 0, r, c)\n                      return\n  \n                  if rest_no_mine > 3 and no_mine_column < c and no_mine_row < r:\n                      for rest_no_mine_for_row in range(2, no_mine_column):\n                          rest_no_mine_for_column = rest_no_mine - rest_no_mine_for_row\n                          if rest_no_mine_for_column < no_mine_row:\n                              print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c)\n                              return\n  \n          print \"Impossible\"\n  \n  r_file = sys.stdin\n  \n  if len(sys.argv) > 1:\n      r_file = open(sys.argv[1], 'r')\n  \n  total_cases = r_file.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      values = map(int, r_file.readline().split(' '))\n      solve_case(values[0], values[1], values[2], case_number)\n  \n", "substitutes": {"no_mine": ["remote_wine", "noFcare", "no__charge", "nice_mine", "no__select", "remote_mine", "no_care", "no_vale", "No_mining", "so_grave", "no__pine", "remote67brown", "noAselect", "niceFdownload", "no__mining", "no_write", "remote_brown", "noAmine", "no_grade", "remote67wine", "nice_care", "noAmining", " no_select", " no_grade", " no_min", "no_powder", "no__min", "niceFmine", "no67powder", "noFdownload", "so_charge", "no_wine", "No_pine", "no_brown", "no67wine", " no_powder", "noApine", "remote67mine", "No_min", "no__grave", "no67mine", "no_grave", "noFmine", " no_wine", "no_message", "niceFcare", "no_select", "remote67powder", "niceFmining", "nice_mining", "no67brown", "no_charge", "non_vale", " no_pine", "non_mine", "no_mining", "non_mining", "nice_download", "no_pine", "no_min", "so_min", "remote_powder", " no_message", " no_mining", " no_write", "no_download", "non_grade", "no__mine", "No_mine", "so_mine", "noFmining"], "r": ["x", "j", "mr", "e", "fr", "v", "err", "rr", "ru", "l", "br", "n", "ro", "t", "rd", "q", "right", "w", "dr", "o", "lr", "g", "cr", "s", "ir", "i", "R", "ar", "h", "kr", "nr", "rc", "nor", "sr", "range", "pr", "ur", "hr", "rb", "u", "rs", "b", "p", "ra", "d", "rg", "a", "re", "k", "f", "er"], "c": ["x", "e", "v", "nc", "uc", "pc", "cs", "l", "t", "dc", "n", "lc", "q", "ca", "ce", "w", "cu", "col", "rec", "ec", "co", "cr", "g", "s", "h", "i", "rc", "cn", "y", "cf", "ci", "con", "cm", "u", "mc", "b", "p", "C", "ch", "d", "z", "cc", "cy", "cl", "cp", "k", "f", "ac"], "printed_c": ["printedptk", "printed_case", "printed_e", "printed_uc", "printedJcase", "printedJc", "printedJct", "printed_ct", "printedptlc", "printed_pc", "printedThem", "led_f", "printedlyc", "printedJcu", " printed_lc", "printed_line", "printedLogf", "printedTheline", "printed67c", "picked67c", "printed67r", "printedptc", "printedJcp", " printed_m", " printed_r", "printed67rec", "printed_f", "printed_ec", "printedThec", "printed67pc", "picked_rec", "printedThee", "printedptline", "printed_k", "printed67m", "picked_c", "printed_lc", "picked67ct", "printedlyct", "printedThek", "picked67rec", "printed67cu", "printedThelc", "picked_cu", "led_case", " printed_cn", "printed_rec", "printedTher", "printed67ec", "printed_m", "printedLogcase", "worked_ec", "led_c", "printed_cn", "printed_r", "printedJrec", "worked_c", "printed_cp", "printedlyrec", "printedLogcp", "printed_cu", "led_cp", "worked_e", "picked_ct", "worked_pc", "printedLogc", "printed67ct", " printed_uc", "printedJf", " printed_line", "printed67e", " printed_k", "picked67cu", " printed_e", "printedlycu"], "row": ["layer", "Row", "rown", "key", "index", "user", "array", "ro", "slice", "run", "right", "month", "channel", "container", "col", "order", "offset", "group", "round", "ref", "cr", "collection", "value", "batch", "rew", "raw", "reader", "rc", "ow", "max", "num", "range", "rows", "ry", "tr", "roll", "block", "page", "ride", "arrow", "length", "year", "entry", "error", "rect", "cell", "re", "rank", "record"], "line": ["inline", "stage", "log", "engine", "model", "ge", "cle", "limit", "unit", "le", "source", "call", "plan", "auto", "note", "chain", "cell", "none", "LINE", "db", "layer", "object", "rule", "l", "lc", "gen", "member", "site", "li", "lo", "one", "mode", "list", "name", "use", "band", "plugin", "message", "block", "lines", "word", "user", "lane", "code", "ine", "day", "server", "el", "body", "group", "item", "style", "grid", "do", "ne", "comment", "record", "e", "liner", "key", "side", "pin", "nl", "status", "sync", "file", "lock", "base", "entry", "lin", "link", "Line", "cl", "sl", "live", "page"], "column": ["attribute", "Row", "index", "sec", "character", "minute", "lc", "day", "right", "four", "member", "const", "channel", "field", "container", "col", "offset", "width", "group", "path", "header", "collection", "value", "maximum", "section", "word", "coll", "initial", "position", "unit", "left", "method", "long", "current", "cm", "block", "arrow", "length", "year", "entry", "ct", "cell", "number", "weight", "Column", "page"], "no_mine_row": ["no_mine67column", "no_mine_col", "no_mine67roll", "no_mine_entry", "no_mine67col", "no_mining_rows", "no_mine_rows", "no_mine_rot", "no_mining_column", "no_mine_roll", "no_mine64column", "no_mine64row", "no_mine64rows", "no_mining_cell", "no_mining_entry", "no_mining_row", "no_mining_roll", "no_mine64rot", "no_mine67row", "no_mining_col", "no_mine_cell", "no_mining_rot"], "no_mine_column": ["no_mining_connection", "match", "no_mine___column", "no_mining_row", "no_minescol", "none", "no_mine_current", "no_mine_section", "config", "no_minesrow", "no_mining_cell", "no_mine_connection", "_", "all", "no_mine_col", "no_mining_current", "index", "no_mine_position", "no_mineetrow", "count", "s", "no_minescolumn", "no_mine_cell", "pos", "no_mining_section", "no_mine___row", "no_minessection", "no_mineetcolumn", "end", "no_mining_position", "no_mining_column", "no_mine_index", "no_mining_index", "no_mining_col", "no_mine___col", "no_mineetcurrent", "no_mine___position", "no_mineetposition"], "rest_no_mine_for_row": ["rest_no_mine_for__column", "rest_no_mine_for_rows", "rest_no_mine_for__col", "rest_no_mine_for__row", "rest_no_mine_foracentry", "rest_no_mine_foraccol", "rest_no_mine_foracrow", "rest_no_mine_for_col", "rest_no_mine_for__rows", "rest_no_mine_foracrows", "rest_no_mine_for_entry"], "rest_no_mine_for_column": ["rest_no_mine_in_column", "rest_no_mine_for__column", "rest_no_mine_in__col", "rest_no_mine_in_col", "rest_no_mine_in__page", "rest_no_mine_in__row", "rest_no_mine_in_page", "rest_no_mine_forallrow", "rest_no_mine_forallcolumn", "rest_no_mine_for__col", "rest_no_mine_forallcol", "rest_no_mine_for_cell", "rest_no_mine_in_row", "rest_no_mine_for__row", "rest_no_mine_for__page", "rest_no_mine_for_col", "rest_no_mine_for_page", "rest_no_mine_forallpage", "rest_no_mine_for_entry", "rest_no_mine_in__column"], "m": ["x", "mr", "v", "e", "min", "mi", "t", "l", "n", "man", "w", "o", "g", "cr", "s", "h", "i", "mod", "y", "range", "meta", "cm", "u", "mc", "b", "p", "d", "ch", "um", "z", "re", "f", "M", "mat"], "case_number": ["resultblocktype", "case_type", "case_Number", "result_description", "caseblockNumber", "resultblockNumber", "caseidNumber", "resultblockdescription", "caseiddescription", " case_category", " case_num", "caseblockcategory", "resultblocknumber", "result_number", "result_Number", "case_description", " case_group", "case_category", "caseidnumber", "casenumcategory", "caseblocktype", "caseblocknumber", "caseblocknum", "casenumnumber", "caseblockgroup", "casenumgroup", "casenumnum", "caseidtype", "case_num", "caseblockdescription", "case_group", "result_type"], "no_mine_row_max": ["no_mine_row_last", "no_mine_row_col", "no_mine_row_min", "no_mine_column_last", "no_mine_rowpax", "no_mine_rowvmax", "no_mine_row_size", "no_mine_rows_col", "no_mine_rows_max", "no_mine_rowvsize", "no_mine_rows_size", "no_mine_column_min", "no_mine_rows_min", "no_mine_row_ax", "no_mine_column_max", "no_mine_rowvmin", "no_mine_rowpmax", "no_mine_rowpmin", "no_mine_rows_ax"], "rest_no_mine": ["rest_not_mine", "rest_notvelmine", "rest_no_mining", "rest_notvelweight", "rest_not_mining", "rest_novelweight", "rest_notvelmining", "rest_no_mate", "rest_not_mate", "rest_novelmate", "rest_notvelmate", "rest_no_weight", "rest_novelmine", "rest_not_weight", "rest_novelmining"]}}
{"code": " \n  def solve_case(answers, arrangements_of_cards, case_number):\n      first_candidates = arrangements_of_cards[0][answers[0] - 1]\n      second_candidates = arrangements_of_cards[1][answers[1] - 1]\n      answer = set(first_candidates) & set(second_candidates)\n      length_of_answer = len(answer)\n      if length_of_answer > 1:\n          print \"Case #%d: Bad magician!\" % case_number\n      elif length_of_answer < 1:\n          print \"Case #%d: Volunteer cheated!\" % case_number\n      else:\n          print \"Case #%d: %d\" % (case_number, answer.pop())\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n      r = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      answers = []\n      arrangements_of_cards = []\n      answers.append(int(r.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[0].append(map(int, r.readline().split(' ')))\n      answers.append(int(r.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[1].append(map(int, r.readline().split(' ')))\n      solve_case(answers, arrangements_of_cards, case_number)\n", "substitutes": {"answers": ["annwors", "ansitments", "oldswers", "partwsers", "answchers", "ansquests", "answaements", "answnests", "partwers", "inwments", "ansgors", "answordeners", "answerers", "ansguerers", "ansswests", "answeers", "ansguERS", "ansglers", "answinaters", "answordsers", "ansangments", "inoutments", "answinments", "ansgings", "oldwards", "answeors", "anngulers", "partwserers", "answordschers", "ansuests", "answERS", "ansguers", "answeings", "answserers", "answaerers", "answiners", "anworder", "answnements", "inwers", "asswers", "ansiweners", "inwaders", "answinchers", "partwatters", "answordaters", "answinests", "answaests", "ansuments", "asswinchers", "answaERS", "ansiwaters", "annwlers", "ansuers", "answsers", "ansouters", "oldwements", "partwERS", "answeners", "annguers", "answnments", "answings", "answineners", "anweners", "ansitaders", "answaders", "answsatters", "ansangters", "oldswests", "oldwests", "partwsERS", "ansswards", "answors", "answners", "anwer", "ansquers", "ansoutters", "asswer", "answatters", "ansoutaders", "answards", "annguors", "oldswards", "answinerers", "inoutaders", "ansiwers", "answorderers", "anwaters", "anwordaters", "ansiters", "ansquements", "ansgers", "partwerers", "ansgulers", "oldwers", "ansguors", "annguings", "answorders", "answinements", "answaatters", "partwsatters", "answements", "ansswements", "asswchers", "ansguings", "answordchers", "annwers", "oldswements", "ansitters", "answordserers", "answaers", "asswiner", "inoutters", "inouters", "ansiwer", "answordser", "answaters", "inwters", "answaards", "answters", "answments", "answiner", "ansoutments", "anwordeners", "anworders", "ansangers", "answorder", "ansguatters", "ansuements", "answests", "asswerers", "ansangaders", "annwings", "answlers", "asswiners", "answelers", "answsERS", "asswinerers", "anwers", "ansquards", "ansswers"], "arrangements_of_cards": ["arrangements_of_games", "arrangements_of2pieces", "arrangements_of_card", "arrangements_of2card", "arrangements_of_files", "arrangements_of_fields", "arrangements_of2games", "arrangements_of_cells", "arrangements_of_cases", "arrangements_of___cards", "arrangements_of__games", "arrangements_of_pieces", "arrangements_of_lines", "arrangements_of___files", "arrangements_of__bags", "arrangements_of__cards", "arrangements_of__cases", "arrangements_of_balls", "arrangements_of___cases", "arrangements_of___cells", "arrangements_of_bags", "arrangements_of2cards", "arrangements_of_books"], "case_number": ["case_zero", "case_body", "caseqnumber", "Case_reason", " case_num", "chance_body", "case24body", "case_code", "case54number", "example64code", "case___string", "case24num", "case_size", "case___number", "chance_number", "case___description", "example_zero", "chance_type", "case_reason", "case_position", " case_position", "case54numbered", "case64code", "case64language", "case_notation", "case_num", "case64number", "case_type", "case24number", " case_no", "case_numbered", "example_language", "Case_numbered", "case_no", "caseqcode", "example64number", "example_number", " case_string", "case___zero", " case_notation", "example64zero", "case___code", "example_code", " case_size", "case64zero", "example64language", "case___language", " case_type", "case54reason", "Case_number", "case_language", "case_string", "caseqzero", "caseqlanguage", "Case_num", "case_description", "case54num", "case24type", "case___no", " case_description", "chance_num"], "first_candidates": ["first_guidates", "first_Candases", "first_pointidates", "first_pointites", "first_pointidate", "first_guids", "first_Candids", "first_chareters", "first_charids", "first_candids", "first_charidate", "first_candeters", "first_pointeters", "first_charites", "first_candases", "first_guidate", "first_guases", "first_candidate", "first_Candeters", "first_charidates", "first_Candites", "first_charases", "first_Candidate", "first_candites", "first_Candidates"], "second_candidates": ["second_anchidate", "second_inters", "second_centidates", "second_centidate", "second_anchidates", "second_argers", "second\u00b7centares", "second_Candares", "second\u00b7candares", "second_candares", "second_candidate", "second_Canders", "second_intidate", "second\u00b7centers", "second_intents", "second_anchents", "second_intidates", "second_argidate", "second\u00b7candidates", "second_anchers", "second_canders", "second\u00b7centidate", "second\u00b7centidates", "second\u00b7candidate", "second_argares", "second_Candidate", "second_Candents", "second\u00b7canders", "second_centares", "second_Candidates", "second_argidates", "second_candents", "second_centers"], "answer": ["average", "string", "result", "array", "score", "grade", "conference", "username", "address", "area", "output", "distance", "cache", "reply", "edge", "field", "issue", "image", "settings", "order", "match", "Answer", "audio", "name", "size", "duration", "cover", "swers", "message", "evidence", "memory", "assembly", "document", "music", "question", "answered", "results", "response", "length", "error", "archive", "support", "gallery", "comment", "argument", "data", "number", "example", "equality", "video", "word"], "length_of_answer": ["length_of_support", "length_of67support", "length_of___issue", "length_of___number", "length_of_question", "length_of___answer", "length_of_issue", "length_of_Answer", "length_of67question", "length_of___question", "length_of_number", "length_of67video", "length_of_video", "length_of67answer"], "r": ["rx", "mr", "e", "fr", "rr", "err", "res", "result", "ru", "t", "l", "br", "ro", "rd", "gr", "right", "rt", "w", "dr", "rh", "cr", "g", "c", "s", "ir", "kr", "R", "ar", "h", "nr", "reader", "wr", "rc", "parser", "sr", "rl", "pr", "hr", "m", "rb", "str", "rs", "tr", "rw", "b", "p", "d", "rg", "rar", "f", "er"], "total_cases": ["total00tests", "total_tests", "totalaldevices", "total_devices", "max_tests", "total00classes", "max_classes", "totalallines", "max_cases", " total_lines", "total_classes", "totalalcases", " total_tests", "total_lines", "total00lines", "total00cases", " total_devices", "totalaltests", "max_lines"], "row": ["bug", "Row", "rown", "key", "user", "no", "ro", "run", "right", "month", "col", "order", "inter", "group", "round", "ward", "match", "rew", "value", "by", "ow", "max", "win", "num", "range", "column", "rows", "ver", "block", "arrow", "diff", "entry", "line", "error", "cell", "f", "page"]}}
{"code": " \n  \n  DX = (-1, -1, -1, 0, 1, 1, 1, 0)\n  DY = (-1, 0, 1, 1, 1, 0, -1, -1)\n  \n  \n  def compute(R, C, M):\n      if M == 0:\n          return empty(R, C)\n      free = R * C - M\n      if free == 1:\n          return single_free(R, C)\n      if R == 1:\n          return single_row(C, M)\n      if C == 1:\n          return single_column(R, M)\n      if R == 2:\n          return two_rows(C, M)\n      if C == 2:\n          return two_columns(R, M)\n      if free in (2,3,5,7):\n          return \"\nImpossible\"\n      return at_least_three(R, C, M)\n  \n  \n  def make_board(R, C, default='.'):\n      return [[default for j in xrange(C)] for i in xrange(R)]\n  \n  \n  def to_string(board):\n      s = \"\"\n      for i in xrange(len(board)):\n          s += '\n' + ''.join(board[i])\n      return s\n  \n          \n  def empty(R, C):\n      board = make_board(R, C)\n      board[0][0] = 'c'\n      return to_string(board)\n  \n  \n  def single_free(R, C):\n      board = make_board(R, C, default='*')\n      board[0][0] = 'c'\n      return to_string(board)\n  \n  \n  def single_row(C, M):\n      board = make_board(1, C)\n      board[0][0] = 'c'\n      for i in xrange(M):\n          board[0][C - 1 - i] = '*'\n      return to_string(board)\n  \n  \n  def single_column(R, M):\n      board = make_board(R, 1)\n      board[0][0] = 'c'\n      for i in xrange(M):\n          board[R - 1 - i][0] = '*'\n      return to_string(board)\n  \n  \n  def two_rows(C, M):\n      if M % 2 != 0:\n          return \"\nImpossible\"\n      if 2 * C - M < 4:\n          return \"\nImpossible\"\n      board = make_board(2, C)\n      for i in xrange(M / 2):\n          board[0][C - 1 - i] = '*'\n          board[1][C - 1 - i] = '*'\n      board[0][0] = 'c'\n      return to_string(board)\n  \n  \n  def two_columns(R, M):\n      if M % 2 != 0:\n          return \"\nImpossible\"\n      if 2 * R - M < 4:\n          return \"\nImpossible\"\n      board = make_board(R, 2)\n      for i in xrange(M / 2):\n          board[R - 1 - i][0] = '*'\n          board[R - 1 - i][1] = '*'\n      board[0][0] = 'c'\n      return to_string(board)\n  \n  \n  def finalize(R, C, M, board):\n      mines = 0\n      for i in xrange(R):\n          for j in xrange(C):\n              if board[i][j] == '0':\n                  continue\n              empty = False\n              for d in xrange(8):\n                  if i + DX[d] < 0 or i + DX[d] >= R or j + DY[d] < 0 or j + DY[d] >= C:\n                      continue\n                  if board[i + DX[d]][j + DY[d]] == '0':\n                      empty = True\n                      break\n              if empty:\n                  board[i][j] = '.'\n              else:\n                  board[i][j] = '*'\n                  mines += 1\n      for i in xrange(R):\n          for j in xrange(C):\n              if board[i][j] == '0':\n                  board[i][j] = '.'\n      board[0][0] = 'c'\n      if mines != M:\n          sys.stderr.write(\"mines:%s expected:%s\n\" % (mines, M))\n      return to_string(board)\n  \n  \n  def at_least_three(R, C, M):\n      board = make_board(R, C)\n      board[0][0] = '0'\n      free = R * C - M\n      count = 4\n      if count == free:\n          return finalize(R, C, M, board)\n      board[0][1] = '0'\n      count += 2\n      if count == free:\n          return finalize(R, C, M, board)\n      board[1][0] = '0'\n      count += 2\n      if count == free:\n          return finalize(R, C, M, board)\n      for j in xrange(2, C - 1):\n          if count + 2 > free:\n              break\n          board[0][j] = '0'\n          count += 2\n      for i in xrange(2, R - 1):\n          if count + 2 > free:\n              break\n          board[i][0] = '0'\n          count += 2\n      for i in xrange(1, R - 1):\n          for j in xrange(1, C - 1):\n              if count == free:\n                  return finalize(R, C, M, board)\n              board[i][j] = '0'\n              count += 1\n      sys.stderr.write(\"empty board?\n\")\n      return finalize(board)\n  \n  \n  def parse():\n      R, C, M = map(int, sys.stdin.readline().strip().split())\n      return R, C, M\n  \n  \n  if __name__ == \"__main__\":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          sys.stderr.write(\"case:%s\n\" % (i + 1))\n          data = parse()\n          result = compute(*data)\n          print \"Case #%d: %s\" % (i + 1, result)\n", "substitutes": {"DX": ["IE", "DE", "MD", "ONE", "TH", "DT", "DC", "CD", "MX", "DL", "DOM", "DI", "DS", "DA", "DR", "ID", "DD", "D", "XP", "CT", "WD", "UX", "XL", "XY", "YD", "IV", "EX", "IP"], "DY": ["DXY", "Dy", " DXY", "dYY", "dy", "dXY", " Dy", " DYY", "PY", "dY", "Py", "DYY", "PYY", "PXY"], "R": ["Range", "P", "Cl", "CR", "E", "G", "SR", "RM", "Br", "RP", "RG", "Ra", "O", "RL", "A", "L", "Y", "GR", "J", "Order", "RH", "r", "RO", "RF", "X", "CC", "D", "IR", "LR", "OR", "V", "Rs", "All", "RE", "JR", "H", "I", "B", "RA", "Rh", "N", "MR", "Reader", "Re", "W", "K", "Right", "c", "RW", "ER", "Q", "DR", "RS", "BR", "Model", "Run", "F", "RC", "RN", "S", "CL", "RR", "Res", "NR", "KR", "WR", "AR", "U"], "C": ["N", "Y", "Cor", "SC", "CNN", "AC", "P", "VC", "CAR", "DC", "CM", "Cl", "CR", "r", "E", "G", "H", "CE", "Size", "W", "CA", "K", "X", "c", " c", "YC", "CV", "CO", "CC", "Q", "CS", "I", "B", "Cu", "CW", "D", "F", "CI", "Cr", "Ch", "O", "CT", "S", "CL", "EC", "MC", "V", "CU", "Count", "CN", "WC", "A", "L", "U"], "M": ["P", "Man", "VM", "E", "G", "RM", "AM", "MB", "LM", "MM", "m", "O", "MC", "A", "L", "Y", "J", "r", "MI", "X", "CC", "num", "D", "OR", "IM", "_", "V", "all", "MD", "All", "H", "MX", "DM", "NM", "OM", "I", "B", "MF", "Z", "MN", "Me", "N", "MS", "end", "MR", "DC", "CM", "W", "g", "K", "Q", "F", "S", "CL", "U"], "free": ["random", "x", "FREE", "all", "valid", "e", "min", "Free", "no", "MS", "n", "MR", "right", "complete", "Re", "E", "only", "FE", "allow", " unused", "fe", "c", "len", "MW", "float", "use", "max", "fre", "left", "F", "NO", "con", "m", "function", "O", "null", " Free", "void", "fee", "ME", "FR", "um", "true", "error", "OR", "used", "none", "de", "f", "UN"], "default": ["x", "id", "DE", "parent", "index", "Default", "no", "dc", "slice", "n", "FAULT", "member", "enter", "label", "func", "standard", "description", "value", "self", "c", "float", "name", "arc", "initial", "desc", "switch", "second", "D", "custom", " defaults", "current", "null", "void", "str", "p", "df", "arrow", "new", "length", "option", "case", "de", "none", "data", "f", "example", "common", "design"], "j": ["ji", "bi", "ri", "je", "ei", "jac", "xi", "co", "g", "ice", "abi", "ti", "gi", "iii", "gh", "ni", "fi", "ci", "ib", "go", "ai", "pi", "ij", "ct", "di", "ac", "ui"], "i": ["x", "id", "ii", "v", "e", "bi", "multi", "ip", "l", "mi", "n", "slice", "phi", "ind", "ei", "xi", "yi", "li", "iu", "r", "it", "col", "o", "g", "one", "c", "value", "ti", "ie", "ir", "qi", "gi", "h", "si", "y", "I", "iw", "ci", "ini", "u", "m", "ai", "b", "p", "z", "pi", "int", "a", "iv", "di", "k", "f", "io", "ui"], "board": ["game", "model", "feed", "image", "square", "coll", "head", "way", "go", "plan", "boarding", "note", "ide", "cell", "case", "video", "bug", "deck", "object", "card", "lc", "core", "que", "stroke", "list", "bit", "join", "loop", "buffer", "config", "clean", "custom", "function", "pool", "p", "block", "check", "back", "form", "cart", " boards", "word", "flow", "uc", "index", "code", "che", "lane", " clipboard", "control", "table", "body", "group", "ward", "ban", "bar", "view", "long", "lay", "frame", "layout", "cross", "line", "client", "foot", "comment", "land", "menu", "e", "ack", "draw", "string", "child", "bo", "post", "channel", "o", "co", "flo", "Board", "c", " row", "sync", "row", "switch", "sequence", " game", "base", "hole", "builder", "boards", "entry", "player", "node", "off", "bank", "design"], "s": ["css", "comments", "e", "sup", "ns", "us", "summary", "l", "t", "n", "options", "su", "sym", "copy", "spec", "settings", "o", "words", "ing", "g", "c", "h", "sc", "conf", "sb", "ws", "sync", "si", "strings", "ss", "m", "u", "S", "b", "p", "sg", "ed", "lines", "es", "f", "se"], "empty": ["missing", "e", "open", "everything", "final", "ace", "complete", "channel", "ec", "square", "equal", "space", "private", "c", "zero", "element", "white", "initial", "size", "unknown", "clean", "clear", "null", "esc", "last", "new", "full", "error", "une", "Empty", "blank", "none", "export", "union"]}}
{"code": " \n  \n  def compute(r1, m1, r2, m2):\n      valid1 = set(m1[r1 - 1])\n      valid2 = set(m2[r2 - 1])\n      valid = valid1 & valid2\n      if len(valid) == 0:\n          return 'Volunteer cheated!'\n      if len(valid) > 1:\n          return 'Bad magician!'\n      return valid.pop()\n  \n  \n  def parse_single():\n      r = int(sys.stdin.readline().strip())\n      m = []\n      for i in xrange(4):\n          m.append(map(int, sys.stdin.readline().strip().split()))\n      return r, m\n  \n  def parse():\n      r1, m1 = parse_single()\n      r2, m2 = parse_single()\n      return r1, m1, r2, m2\n  \n  \n  if __name__ == \"__main__\":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          data = parse()\n          result = compute(*data)\n          print \"Case #%d: %s\" % (i + 1, result)\n", "substitutes": {"r1": ["Rone", "rankone", "crOne", "er2", "sr3", "rone", "rank01", "sr1", " rone", "cr1", "ROne", "rOne", "er3", "sr01", " r01", "cr2", "R01", " rOne", "rank1", " r3", "mone", "mOne", "er1", "rank2", "r3", "er01", "R2", "sr2", "R1", "crone", "r01"], "m1": ["Mone", "v0", "pone", " mone", "M1", "M3", "M0", "rone", "arm1", "p2", "arm2", "c100", "p3", "v2", "cone", "r0", "v1", "m3", "m0", "mone", "M2", "c1", "armone", "m100", "r3", "v3", "c2", "p1", "arm100", "r100"], "r2": ["R4", "m5", "rgtwo", "m92", "rrtwo", " r5", " r4", " rb", "er2", "rg5", "dr5", "r5", "r4", "cr1", "dr2", "rr5", " rtwo", "rg2", " r62", "r0", "cr2", "rtwo", "drtwo", "mb", "r62", "mtwo", "r92", " r92", "dr1", "m0", "rb", "er5", "Rb", "ertwo", "er1", "cr92", " r0", "m4", "R2", "rr62", "R1", "cr0", "rg62", "rr2"], "m2": ["v0", "r14", "umtwo", "mall", "M4", "M1", "v14", " m14", "rall", "r4", "um1", "v2", "vall", "r0", " moe", "moe", "rtwo", "v1", "fmTwo", "Mtwo", "um4", "mtwo", "roe", "um2", " m0", "m0", "M2", "fm2", "mTwo", "m4", "fmoe", "m14", " mall", " mTwo", "fm1", "rTwo"], "valid1": ["valid3", "validOne", "valid01", "rone", "validone", "variOne", "varione", "rOne", " valid01", " valid3", "vari1", "val3", "vari3", "r3", "valone", " validone", "val1", "valOne", "val01", "r01"], "valid2": ["m5", "author1", "author182", "valid3", "valid182", "m182", "val62", "r5", "m62", "valid5", " valid182", "m3", "r62", "author2", " valid3", "author3", "val5", "valid62", "val1", "val2"], "valid": ["missing", "all", "id", "eval", "open", "multi", "required", "index", "generic", "multiple", "Valid", "complete", "compatible", " invalid", "vari", "post", "status", "body", "old", "empty", "match", "regular", "normal", "value", "list", "update", "active", "val", "total", "static", "fail", "split", "num", "viol", "single", "long", "running", "current", "null", "failed", "non", "broken", "diff", "new", " validation", "full", "check", "error", "same", "iter", "good", "form", "central", "visible", "f", "testing", "test"], "r": ["x", "id", "mr", "v", "rr", "err", "rf", "im", "ru", "br", "n", "ro", "rd", "q", "right", "lr", "g", "cr", "rm", "c", "ir", "R", "ar", "h", "nr", "rc", "reg", "sr", "rl", "ur", "hr", "rb", "u", "rs", "rad", "b", "p", "d", "rg", "re", "k", "er"], "m": ["x", "mu", "am", "mr", "v", "e", "multi", "l", "t", "mi", "n", "mm", "o", "wm", "g", "me", "rm", "c", "ms", "bm", "mult", "om", "gm", "y", "hm", "fm", "cm", "u", "mc", "b", "p", "sm", "d", "tm", "nm", "a", "dm", "f", "M", "imm"], "i": ["x", "id", "j", "ui", "ii", "e", "v", "ri", "bi", "index", "multi", "ip", "l", "n", "phi", "ind", "q", "xi", "li", "iu", "gu", "uni", "abi", "c", "ti", "gi", "qi", "h", "chi", "si", "ih", "I", "start", "eni", "uri", "ci", "u", "bis", "ai", "b", "p", "d", "z", "pi", "int", "a", "mini", "di", "zi", "f", "io"], "T": ["TR", "N", "Y", "TN", "t", "P", "TH", "TS", "E", "G", "H", "W", "K", "X", "Time", "R", "Q", "I", "B", "D", "F", "O", "S", "TT", "Z", "C", "V", "TB", "M", "A", "L", "U"], "data": ["x", "v", "res", "multi", "array", "n", "options", "args", "Data", "sample", "o", "dat", "body", "DATA", "series", "list", "params", "raw", "actions", "config", "input", "rows", "test", "ata", "p", "d", "results", "response", "new", "a", "arr", "media", "database", "record", "dates"], "result": ["err", "res", "Result", "grade", "report", "array", "success", "final", "output", "text", "complete", "json", "status", "match", "dict", "value", "date", "attr", "val", "total", "msg", "ret", "tmp", "message", "str", "ver", "df", "results", "response", "diff", "obj", "error", "rate", "rect", "comment", "arr", "record", "test"]}}
{"code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def flip( grid ):\n      return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\n  \n  def grow( R, C, M ):\n      grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\n      b = R*C - M\n      if C > R:\n          R, C, grid = C, R, flip( grid )\n          flipped = True\n      else:\n          flipped = False\n      if b < 2*C:\n          if b == 1:\n              grid[ 0 ][ 0 ] = 'c'\n          elif b == 3 and C >= 3:\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\n          elif b % 2:\n              return\n          else:\n              grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 0 ][ 0 ] = 'c'\n      else:\n          r = 0\n          while b >= C:\n              grid[ r ] = bytearray( C*[ '.' ] )\n              b -= C\n              r += 1\n          if b:\n              if b >= 2:\n                  grid[ r ][ : b ] = b*'.'\n              elif C > 2 and r > 2:\n                  grid[ r - 1 ][ -1 ] = '*'\n                  grid[ r ][ : 2 ] = '..'\n              else:\n                  return\n          grid[ 0 ][ 0 ] = 'c'\n      return flip( grid ) if flipped else grid\n      \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 )\n      R, C, M = read_integers()\n      grid = grow( R, C, M )\n      print '\n'.join( str( row ) for row in grid ) if grid else 'Impossible'\n", "substitutes": {"x": ["rx", "xxxxxxxx", "xe", "xx", "e", "v", "index", "px", " i", "xb", "l", "n", "xy", " xx", "xi", "xxxx", "w", "col", "xxx", "X", "ex", "i", "xp", "byte", "val", "y", "xa", "xc", "dx", "p", "xf", "xd", "d", "z", "ix", "wx", "xs", " X", "f", " y"], "grid": ["id", "feature", "remote", "hold", "get", "model", "final", "complex", "gu", "G", "feed", "square", " module", "div", "unit", "lat", "range", "gap", "m", "df", "chain", "wire", "cell", "ico", "case", "house", "db", "Grid", "layer", "bug", "mu", "gui", "rule", "array", "slice", "ga", "card", "RH", "sky", "site", "edge", "format", "mode", "connection", "set", "list", "zip", "num", "cells", "tree", "cube", "block", "new", "scale", "back", "next", "flat", "rank", "export", "cart", " Grid", "multi", "query", "parse", "code", "report", "q", "table", "server", "shift", "order", "group", "init", "module", "update", "max", "input", "u", "frame", "device", "layout", "plot", "d", "last", "line", "heat", "client", "mid", "graph", "f", "data", "network", "hub", "record", "draw", "move", "default", "grade", "play", "ace", "DC", "cache", "tile", "news", "g", "c", "grain", "dim", "fit", "file", "reg", "page", "entry", "IF", "int", "node", "GA", "temp", "mat", "U"], "row": ["layer", "flow", "id", "Row", "key", "index", "sel", "query", "user", "array", "ro", "model", "run", "month", "w", "post", "feed", "col", "order", "group", "round", "week", "c", "value", "batch", "sc", "word", "raw", "name", "rc", "mod", "ow", "max", "num", "range", "height", "rows", "cm", "tr", "ver", "page", "block", "length", "arrow", "entry", "cell", "node", "number", "rank", "record"], "column": ["attribute", "component", "variable", "index", "slice", "character", "model", "day", "pixel", "month", "channel", "col", "offset", "group", "value", "c", "dim", "section", "dimension", "position", "letter", "unit", "cycle", "item", "y", "rows", "block", "length", "arrow", "entry", "line", "axis", "ct", "year", "cell", "umn", "number", "Column", "word"], "R": ["Grid", "Rh", "N", "Y", "Row", "GR", "Rs", "P", "RH", "CR", "E", "G", "H", "SR", "RM", "W", "RO", "RF", "K", "X", "c", "Q", "DR", "RS", "I", "B", "D", "F", "LR", "S", "RR", "V", "Res", "WR", "A", "L", "U", "RA"], "C": ["P", "CR", "E", "CE", "G", "YC", "Cu", "Ra", "Ch", "O", "EC", "MC", "CU", "A", "L", "Grid", "Y", "lc", "CF", " c", "cr", "X", "Co", "Sc", "sc", "CC", "D", "CI", "p", "_", "ac", "V", "NC", "Rs", "Cs", "H", "ar", "I", "B", "ci", "Z", "d", "Count", "Cr", "N", "e", "DC", "CM", "U", "W", "CA", "K", "c", "Q", "F", "RC", "CT", "Max", "S", "CL", "cy", "cl", "CN", "Con"], "M": ["N", "Y", "MD", "P", "MS", "MQ", "MR", "Man", "J", "CM", "Ms", "U", "E", "G", "MI", "MX", "H", "RM", "W", "DM", "K", "X", "NM", "MU", "Mo", "Q", "I", "B", "MF", "D", "F", "MB", "LM", "MM", "m", "O", "S", "Me", "Z", "MN", "ME", "MC", "L", "V"], "b": ["bp", "part", "bug", "j", "v", "e", "http", "big", "l", "bot", "n", "bl", "bas", "bc", "nb", "bt", "w", "ob", "o", "body", "bf", "g", "c", "bd", "h", "i", "type", "s", "bs", "bb", "sb", " B", "y", "B", "range", "eb", "m", "base", "rb", "u", "ib", "lb", "wb", "p", "null", "fb", "d", "z", "ab", "block", "a", "k", "BB", "f", "number", "ac", "ba", "be", "db"], "flipped": [" flipper", "Flipper", "slipper", "Flided", "floped", "slip", "Flipped", "Flipping", "flided", " flipping", "flipping", " flided", "flipper", " floped", "slided", "flip", "slipped", "Floped", "fluipping", " flip", "fluoped", "slipping", "fluipped", "Flip", "fluip"], "r": ["all", "j", "e", "v", "rr", "err", "fr", "yr", "Rs", "br", "l", "n", "ro", "ru", "rd", "right", "w", "rt", "dr", "rh", "o", "cr", "g", "c", "h", "i", "ar", "nr", "rc", "sr", "B", "rl", "range", "pr", "ur", "m", "rb", "u", "rs", "tr", "p", "d", "z", "a", "k", "re", "f", "er"], "T": [" N", "N", "Y", "Total", "P", "DT", "TS", "Length", "E", "G", "H", "W", "X", "NT", "Q", "I", "B", "TA", "D", "F", "WT", "O", "CT", "S", "TT", "Z", "TB", "L", "V"], "t": ["v", "e", "st", "l", "n", "ind", "trial", "time", "text", "tt", "ut", "c", "pt", "tw", "i", "nt", "tc", "total", "y", "ret", "qt", "tmp", "txt", "ot", "num", "ta", "out", "dt", "m", "u", "tr", "tz", "p", "tp", "d", "int", "ct", "ts", "f", "temp", "test"]}}
{"code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def read_string():\n      return read_line().strip()\n  \n  def read_strings():\n      return read_line().split()\n  \n  def input_string_stack():\n      data = []\n      for line in sys.stdin.readlines():\n          data.extend( line.split() )\n      data.reverse()\n      return data\n  \n  def input_integer_stack():\n      return [ int( x ) for x in read_string_stack() ]\n  \n  class memoized( object ):\n     def __init__( self, function ):\n        self.function = function\n        self.cache = {}\n     def __call__( self, *arguments ):\n        try:\n           return self.cache[ arguments ]\n        except KeyError:\n           value = self.function( *arguments )\n           self.cache[ arguments ] = value\n           return value\n  \n  T = read_integer()\n  for t in range( T ):\n      row = read_integer()\n      candidates = set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n      row = read_integer()\n      candidates &= set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n      print 'Case #%i:' % ( t + 1 ), candidates.pop() if len( candidates ) == 1 else 'Bad magician!' if len( candidates ) > 1 else 'Volunteer cheated!'\n", "substitutes": {"x": ["id", "xe", "xx", "v", "e", "xb", "string", "code", "l", "xy", "n", "get", "xi", "xxxx", "w", "xxx", "width", "g", "X", "c", "ex", "i", "h", "xp", "exec", "name", "y", "num", "out", "input", "ci", "xc", "m", "u", "b", "p", "xf", "d", "z", "ix", "ax", "int", "ct", "wx", "xs", "k", "_", "number", "f", "ctx"], "data": ["variable", "all", "la", "object", "string", "result", "code", "array", "default", "n", "args", "output", "text", "Data", "format", "this", "feed", "dat", "body", "space", "DATA", "dict", "type", "list", "update", "i", "values", "reader", "name", "buffer", "config", "split", "input", "message", "sequence", "source", "str", "write", "p", "d", "results", "response", "entry", "new", "lines", "a", "next", "content", "media", "database"], "line": ["inline", "object", "string", "code", " inline", "l", "log", "ine", "text", "body", "header", "LINE", "byte", "name", "reader", "file", "unit", "buffer", " Line", "item", "out", "style", "message", "source", "str", "frame", " lines", "d", "block", "entry", "lines", "obj", "lin", "Line", "cell", "point", "lined", "word"], "self": ["parent", "http", "per", "private", "master", "ws", "app", "proxy", "call", "now", "k", "resp", "shared", "instance", "layer", "object", "l", "writer", "one", "connection", "reader", "p", "response", "full", "error", "plus", "ctx", "Self", "all", "user", "other", "q", "server", "event", "public", "module", "ng", "context", "host", "method", "pos", "client", "f", "worker", "part", "e", "home", "w", "this", "o", "me", "g", "c", "h", "load", "results", "work", "node", "github"], "function": ["instance", "service", "fn", "parent", "feature", "object", "string", "code", "array", "run", "package", "closure", "func", "program", "family", "module", "functional", "connection", "action", "binary", "section", "element", "python", "name", "Function", " Function", "unit", "file", "context", "operator", "command", "interface", "handler", "method", "expression", "document", "call", "library", "role", "full", "resource", "system", "callback", "form", "f", "node", "number", "wrapper", "word", "operation", "fun"], "cache": ["parent", "object", "key", "parse", "code", "array", "engine", "model", "table", "store", "image", "body", "module", "storage", "list", "c", "binary", "use", "cycle", "buffer", "config", "cookie", "memory", "hash", "can", "base", "write", "proxy", "call", "debug", "lib", "chain", "client", "ache", "cell", "Cache", "api", "wrapper", "tag"], "value": ["instance", "variable", "valid", "version", "Value", "v", "parent", "key", "object", "string", "VALUE", "result", "default", "array", "end", "output", "w", "this", "one", "type", "list", "element", "values", "val", "unit", "max", "reg", " Value", "num", "range", "message", "current", "test", "document", "p", "response", "length", "entry", "resource", "a", "content", "number", "reference"], "arguments": [" argargs", "paramument", "parameters", "argsument", "paramuration", "argencies", " argument", "calleters", "argsates", " argeters", " arguration", "arguration", "calluments", "argseters", "axuments", "paramargs", " argates", "parargs", "argsls", "axencies", "argeters", "agument", "argsuration", "axument", "argargs", "paramls", "argsuments", "callument", "paramuments", "ageters", "axeters", "argls", "argates", "aguments", "argument", "paruments", "agencies", "argsargs", "parument", "callencies", " argls", "parates"], "T": [" N", "Y", "N", " P", "Row", "TN", "P", "n", "time", "table", "Length", "w", "E", "G", "W", "X", "Time", "type", "R", " TT", "total", "Q", " C", "I", "B", "D", "F", "O", "S", "TT", "C", "length", "V", " R", "M", "L", "port", "U"], "t": ["j", "v", "e", "l", "n", "time", "tf", "table", "text", "trial", "w", "tl", "col", "tt", "thread", "c", "window", "type", "i", "h", "total", "tc", "y", "ta", "start", "dt", "rows", "m", "u", "the", "tz", "p", "z", "length", "int", "k", "f", "temp", "tower", "test"], "row": ["id", "Row", "key", "ro", "end", "q", "day", "month", "post", "w", "r", "col", "where", "order", "offset", "tt", "round", "X", "c", "batch", "type", "R", "head", "tc", "y", "num", "out", "column", "rows", "tri", "tr", "p", "roll", "block", "pos", "length", "scale", "rot", "k", "cell", "f", "off", "port", "test"], "candidates": ["Candates", "Candores", "argations", "colplates", " Candiders", "argidates", "catoters", "argidate", "prediders", " Candidates", "Candests", "colates", "predices", " candidate", "Candles", "predals", " candles", "Candidates", "Candplates", "Candals", "catidates", "candators", "candidate", " Candidate", "predidate", " Candles", "candals", "argplates", " Candices", "candplates", "candations", "colidates", "Candations", "candests", "colidate", "catates", " Candores", "candoters", "candates", "candles", " candals", "constators", "predidates", "candiders", "colations", "constices", "coloters", "predests", "catidate", "Candidate", "constidates", " candores", "candices", "Candoters", " candests", "constiders", "candores", " Candators", "predators"], "index": ["instance", "id", "version", "valid", "open", "insert", "default", "end", "character", "ind", "where", "match", "word", "name", "position", "find", "connect", "num", "point", "out", "range", "long", "access", "call", "block", "length", "diff", "int", "weight", "loc", "level", "inc"]}}
{"code": "def Trivial(R,C,char):\n      for i in range(R):\n          Ans = '';\n          for j in range(C):\n              if (i==j==0):\n                  Ans += 'c';\n              else:\n                  Ans += char;\n          print Ans;\n  \n  \n  def Draw1(R,C,Blank):\n      Ans = \"c\";\n      for i in range(Blank-1):\n          Ans += '.';\n      for i in range(R*C-Blank):\n          Ans += '*';\n      if (R == 1):\n          print Ans;        \n          return;\n      if (C == 1):\n          for i in range(len(Ans)):\n              print Ans[i];\n  \n  def Draw2(R,C,Blank):\n      if (Blank%2 != 0) or (Blank == 2):\n          print \"Impossible\";\n          return;\n      Row1 = '.'*(Blank/2) + '*'*(Mine/2);\n      Row0 = 'c' + Row1[1:];\n      if R==2:\n          print Row0;\n          print Row1;\n      else:\n          for i in range(len(Row0)):\n              print Row0[i]+Row1[i];\n      return;\n  \n  \n  def Generate(R, C, Blank):\n      TODO = Blank;\n      Spaces = [0]*R;\n      if TODO <= 2*C:\n          if TODO%2 == 0:\n              Spaces[0] = TODO/2;\n              Spaces[1] = TODO-Spaces[0];\n          else:\n              if (TODO == 7):\n                  Spaces[0] = 3;\n                  Spaces[1] = 2;\n                  Spaces[2] = 2;\n              else:\n                  Spaces[0] = (TODO-3)/2;\n                  Spaces[1] = (TODO-3)/2;\n                  Spaces[2] = 3;\n      else:\n          row = 0;\n          if (TODO >= 2*C+2):\n              Spaces[0] = C;\n              Spaces[1] = C;\n              TODO -= 2*C;\n              row = 2;\n              \n          while TODO > C+1:\n              if (TODO == 2*C+1) and (C != 3):\n                  Spaces[row] = C-1;\n                  Spaces[row+1] = C-1;\n                  Spaces[row+2] = 3;\n                  TODO = 0;\n              else:\n                  Spaces[row] = C;\n                  TODO -= C;\n                  row += 1;\n          if (TODO == C+1):\n              Spaces[row] += C-1;\n              Spaces[row+1] = 2;\n              TODO = 0;\n          Spaces[row] += TODO;\n  \n      for r in range(R):\n          Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);\n          if r == 0:\n              Ans = 'c'+Ans[1:];\n          print Ans;\n  \n  \n  def Solve(R, C, M):\n      Blank = R*C-M;\n      if Blank == 0:\n          print \"Impossible\";\n          return;\n  \n      if (Blank == 1):\n          Trivial(R,C,'*');\n          return\n      if (Blank == R*C):\n          Trivial(R,C,'.');\n          return\n  \n      if (R == 1) or (C == 1):\n            Draw1(R,C,Blank);\n            return\n  \n      if (R-2)*(C-2) == 0:\n          Draw2(R,C,Blank);\n          return\n  \n      if Blank in [2,3,5,7]:\n          print \"Impossible\";\n          return;\n      \n      if (R >= 3) and (C >= 3):\n          Generate(R, C, Blank);\n  \n      return;\n  \n  \n  T = int(raw_input());\n  for q in range(T):\n      [Row,Col,Mine] = map(int, raw_input().split());\n  \n      Blanks = Row*Col - Mine;\n      \n      print \"Case #%d:\" % (q+1)\n      Solve(Row, Col, Mine);\n      \n          \n", "substitutes": {"R": ["Rh", "N", "Y", "Rule", "Rs", "Range", "P", "J", "Cl", "CR", "RH", "Re", "JR", "E", "H", "G", "SR", "RM", "W", "Roman", "RO", "Rank", "Right", "X", "K", "Co", "RF", "RW", "Q", "RS", "BR", "Br", "I", "B", "Run", "RP", "D", "F", "RC", "RG", "Ra", "IR", "O", "RN", "RL", "LR", "S", "RR", "V", "Res", "NR", "A", "L", "U", "RA"], "C": ["N", "Y", "NC", "SC", "UC", "CNN", "Cs", "P", "VC", "DC", "CM", "CR", "Cl", "Con", "E", "G", "H", "CE", "W", " c", "CA", "X", "c", "K", "YC", "JC", "Co", "Sc", "CV", "CC", "Q", "CS", "CW", "B", "KC", "I", "Cu", "D", "CI", "F", "Ca", "Ch", "GC", "O", "S", "CL", "Custom", "EC", "V", "Case", "CU", "Count", "Cache", "A", "L", "U"], "char": ["escape", "short", "v", "e", "uc", "string", "character", "text", "ctr", "CHAR", "c", "Char", "CC", "ci", "Ch", "u", "void", "CCC", "str", "esc", "ch", "cur", "int", "Character", "cell", "car", "f"], "i": ["x", "id", "ii", "v", "e", "ri", "bi", "index", "ip", "l", "code", "n", "ei", "xi", "yi", "li", "iu", "it", "col", "o", "g", "c", "ti", "ie", "gi", "chi", "h", "qi", "si", "ih", "y", "vi", "I", "start", "iw", "uri", "ni", "ci", "ini", "u", "m", "ai", "b", "p", "d", "z", "ix", "pi", "int", "a", "di", "k", "f", "io", "ia", "ui"], "Ans": ["Bonrors", "As", "ANches", "Navs", "Bonts", "Pathks", " Anths", "Aks", "ANsi", "Annlines", "PathS", "Anks", "ANf", "Anths", "Sync", "Anneges", "Synb", " Anlines", "ANts", "Af", "Bonns", "Paths", "NavS", "Acc", "ANS", "Navths", "Analyths", "Acns", "Connectsi", "Elln", "Anb", "AnS", "ConnectS", "Anches", "Bons", "annS", "Syns", " Anows", " Anws", "Analyn", "AnnS", "Annelines", " Ansi", "EllS", "ANs", "ANcs", "AnalyS", " Ants", "ANc", "annths", " AnS", "Annes", "annges", "Acb", "Samsi", "Synns", "Acs", " Anks", " Anns", "Connectows", "Anc", "Analys", " Ancs", "Anrors", "Annets", "AnneS", "Connects", "SamS", "Enrors", "Annesi", "ANlines", "Ants", "Anws", "Pathlines", " Ann", "Enlines", "annks", "Anns", "AS", "Ensi", "Ellths", "Ells", "Sams", "ANws", "Annec", "Ann", "Anlines", "Ancs", " Anc", "Ansi", "Navges", "Annws", "Anows", "Anges", "Anneches", "ANks", "Enches", "Enns", "Annecs", "Ens", "anns", "Anneths", "annf", " Anb", "Ents", "Samows", "Anf", " Anrors"], "j": ["ji", "v", "e", "ii", "je", "code", "l", "n", "ind", "ei", "J", "jac", "jj", "jc", "o", "js", "co", "g", "c", " ii", "gi", "iy", "oj", "jp", "jl", "oi", "y", "\u0438", "si", "I", "ci", "jo", "m", "ai", "b", "p", "ch", "z", "ix", "pos", "bj", "ij", "ja", "k", "ia"], "Blank": ["blisk", "Blink", " Blash", "Clash", "Blan", "BLank", " BlANK", " blanks", "Flanking", " Blisk", " blamp", " blank", "blamp", "BLan", "blink", "blash", "BLace", "Clank", " Blamp", "BLanking", "BLanks", " Blanking", "Brace", "blane", "Clan", " Blane", "Brunk", " blink", " blANK", "Blamp", "FlANK", "BlANK", "blace", " blace", "Clanks", "Plan", "blanks", "Flane", "Flank", "BrANK", "blunk", "blan", " Blan", "Blunk", "Clace", "blANK", "Blisk", "Plink", "Planks", "Flan", "Blash", "Blace", "blanking", " blanking", "BLunk", "Brank", "Blanking", " Blace", "Blane", "BLANK", "BLisk", "PlANK", "Planking", "blank", "Place", "Plank"], "Row1": ["row1", "row2", "Line0", "rowOne", "Row2", "row0", "Cell3", "Cell2", "Cell0", "RowOne", "LineOne", "Line2", "Line3", "Cell1", " Row2", "CellOne", "Row3", "row3", "Line1", " RowOne"], "Row0": ["Line00", "row1", "Ro1", "row4", " Row8", "Ro0", "Column8", " Row50", "row2", "Ro00", "Line0", "Row4", "row8", "Row8", "Column0", "Column4", "Ro50", "Row2", "Line50", "Row50", "row0", "Cell2", "Cell0", "Line2", "Cell1", " Row2", "Column1", " Row00", "Line1", "Row00", " Row4"], "TODO": ["TOTALOD", "TOVY", "tOKO", "NPDPO", "TMDT", "TODDO", "TOKO", "TodOO", "TOVBo", " TPDo", "NTodO", "TWODMo", "TLLO", "TODBo", "TOVO", "TNDC", "GODOD", "TOCo", "NODDo", "GODO", " TOVY", "TDDO", "TODY", "TPDO", "tODO", "TWodMo", "TADOS", "TOKOO", " TOVO", "TOKDo", "POKDo", "POKO", "TOVOL", "TWodO", "TODo", "NODo", "TOTALMo", " TODBo", "TNDDo", "TodMo", "TODH", "TMDOO", "GODOE", "TWodOS", "TLLPO", "TPDo", "TodOs", "TOTALDo", "NTODDo", "TEDo", "TodOS", "VTODO", "TodE", "TPDPO", "TodDo", " TODT", "TOKU", "TOCH", "NODO", " TOVBo", "TLLDo", "GodO", "NTODEO", " TPDT", "tODo", "TOVDO", "TECBo", "TodO", "NPDO", "TOKON", "TADO", "TPDOA", "TODOS", "GodOD", "PODDo", "tOKDO", "TOYO", "PODON", "FODOA", "tPDO", "tOKEO", "TDDDO", "NTODC", "TOYo", "NPDDo", "TWODOS", "VTodOS", "TPDOO", "TODU", "TLLo", "TEDO", "FOKOA", "FODO", " TODOO", "TodY", "TWodOs", "TodOK", "TOYEO", "TOYU", "TADMo", "TOKOA", "VTodE", "TOTALOS", " TPDOL", "GODEO", "tPDOO", "FOKO", "TODOs", "TOTALOs", "FOKOO", "TADOs", "TOTALE", "TODDo", "TOO", "TECOK", "FODOO", "TODC", "TEDDo", "tPDo", "TPDOL", "TODE", "VTODOD", "TODOO", "TOKOE", "TOOE", "VTODE", "TWODOs", " TOVOK", "VTodO", "TOKOS", " TODY", "TODON", "NTodC", "TOYOA", "TECY", "TODPO", "TOKEO", "TOYDO", "TODOA", "TodU", "TOKDO", "GodOE", "NTodDo", "tODH", "NPDo", "Todo", "TEDPO", " TODOK", "TOTALON", "TODOD", "NTODO", "TDDOL", "TOCO", "TODOK", "POKON", "TOCOO", "TOYOO", "TOVOO", "FODo", "TOKOD", "TECO", "TOTALo", "TODOE", "TodH", " TPDOO", "TNDO", " TODDO", "TOKE", "TOVOK", "TMDo", "tODEO", "TDDOO", "tPDH", "VTODOS", "POKo", "TodDO", "VTodOD", "FOKo", "TPDH", "PODO", "TPDDo", "TPDT", "TodOE", "tODU", "GodEO", " TODOL", "NTodEO", "TOOD", "TOCT", "TOKC", "tODOO", "TOEO", "TodEO", "TOKo", "TODEO", " TODo", "TODMo", "TPDDO", "TODT", "TOTALO", "TodON", "TNDEO", "TODOL", " TPDO", "TWODO", "tOKU", "NODPO", " TPDDO", "PODo", "TMDO", "TodC", "TodBo", "tODDO", "TodOD"], "Spaces": ["Places", " Spacements", "Spices", "Spaced", "Slays", "Plaches", "SPaces", "Placing", "spapes", "spaches", "spaced", "Parpaces", " Spays", "SPaches", "SPapes", "Plapes", "spacing", "Spacing", "Spfaces", "Prans", "Praces", "SPans", "Prefacing", "Spans", "SPaced", "SPays", "Plans", "Slacing", "SPfaces", "Slans", "Preffaces", "Praches", "spays", "Spabs", " Spices", "spaces", "Prefabs", " Sppaces", "Pracing", "spfaces", " Spfaces", "Plfaces", "SPices", "Sppaces", "SPacing", "spans", "Slaces", " Spans", "Spays", " Spaced", "Paraced", "Paraces", "Placements", "Plices", "Spapes", " Spacing", "Paracing", "Spaches", "Prefaces", "Slaches", " Spabs", " Spapes", "Spacements", " Spaches", "spacements", "sppaces", "spices", "Slacements", "SPabs", "SPacements"], "row": ["step", "flow", "x", "bug", "min", "key", "index", "low", "count", "month", "post", "channel", "container", "feed", "col", "order", "where", "offset", "o", "group", "record", "c", "value", "h", "head", "raw", "mod", "position", "ow", "y", "max", "num", "range", "column", "height", "rows", "tr", "p", "block", "line", "length", "entry", "scale", "error", "cell", "port", "page"], "Mine": ["Diamond", "crop", "Circ", "Repeat", "Roman", "cr", "CV", "Cut", "CC", "Continue", "Rec", "Cr", "CCC", "White", "Max", "RGB", "line", "Case", "repeat", "Line", "cell", "Block", "case", "Sample", "Fill"]}}
{"code": "T = int(raw_input());\n  for q in range(T):\n      R1 = int(raw_input());\n      Data1 = [];\n      for i in range(4):\n          Data1.append( map(int, raw_input().split()) );\n          \n      R2 = int(raw_input());\n      Data2 = [];\n      for i in range(4):\n          Data2.append( map(int, raw_input().split()) );\n  \n      Ans = [];\n      for entry in Data1[R1-1]:\n          if entry in Data2[R2-1]:\n              Ans.append(entry);\n  \n      print \"Case #%d:\" % (q+1),;\n  \n      if len(Ans) == 0:\n          print \"Volunteer cheated!\";\n      if len(Ans) == 1:\n          print Ans[0];\n      if len(Ans) > 1:\n          print \"Bad magician!\"\n          \n", "substitutes": {"T": ["Y", "N", "TN", "t", "P", "J", "E", "G", "H", "W", "K", "X", "Time", "R", "NT", "Q", "I", "B", "D", "F", "Type", "O", "S", "Z", "C", "V", "M", "L", "U"], "q": ["requ", "x", "j", "qq", "v", "ii", "e", "query", "charge", "t", "n", "ind", "quant", "r", "w", "o", "g", "c", "h", "quest", "ar", "dq", "Q", "y", "row", "qt", "qa", "I", "qs", "qu", "iq", "u", "p", "question", "d", "z", "int", "k", "_", "f", "sq"], "R1": ["R5", "Q2", "P3", "r1", "r5", "R3", " R0", "Rank1", "Q1", "Rank2", "Rank3", "r0", "r2", "Q0", " R5", "P2", "P1", "Q5", "r3", "R0"], "Data1": ["Sample6", "Array2", "Data3", " DataOne", " Dataron", "DATA6", "Dataron", " Data6", "DataOne", "DATA1", "Sample1", "Sample3", "DATAron", "dataOne", "SampleOne", "DATAOne", " Data3", "data1", "data3", "Arrayron", "Data6", "Array1", "Sample2", "DATA2"], "i": ["x", "id", "j", "ui", "ii", "v", "ip", "l", "xi", "li", "iu", "r", "it", "o", "c", "ie", "qi", "chi", "si", "y", "I", "ci", "ai", "b", "p", "pi", "int", "a", "k", "f", "io"], "R2": ["r02", "r1", "RA1", "RA62", "RA72", "R02", "R62", " R72", "r2", "N2", "RA2", "r62", "P2", "P1", " R62", "P02", "R72", "N1", "r72", "N02"], "Data2": ["R4", "DataAPI", " DataAPI", "Size62", "DATA62", "Size2", "data5", "SizeL", "R62", " Datatwo", "Na2", "DATA4", "Data62", " Data4", "data2", "Size4", "DATAtwo", "Data5", "DATAL", "NaAPI", "DATAAPI", "Na1", "Natwo", "DATA1", "DATA5", "data4", "RL", "Data4", "DataL", "data1", "Datatwo", " Data5", "DATA2"], "Ans": ["ANa", "ANo", "annlines", "Anns", "Annp", "ANp", " Ano", "ANc", "ANws", "Ana", "ANches", "Annions", "Anywords", "Anyd", "ANls", "Anno", "Anyg", "ANd", "Ano", " Anions", "And", "Anls", "Ends", " Ang", "Anlines", "Anp", "Ands", "Eno", " Anwords", " Anp", " Anc", "Ang", "Annns", "Annws", "annds", " And", "ANg", "Anys", " Anns", "Anc", " Anls", "Annls", " Ands", " Anches", "ANds", "ANwords", "anna", "ANns", " Ana", "Anches", "ANions", "Annches", "Enns", " Anws", "Ens", "anns", " Anlines", "ANlines", "Annc", "Anws", "Annds", "ANs", "Anwords", "Anions"], "entry": ["ence", "par", "x", "parent", "id", "j", "e", "ent", "chapter", "insert", "cat", "index", "array", "chart", "no", "ind", "trial", "ries", "rue", "enter", "du", "Entry", "feed", "rance", "it", "inter", " entries", "match", "vid", "c", "ie", "way", "name", "pie", "nt", "letter", "rival", "ue", "row", "three", "vec", "inner", "ident", "rant", "tri", "deep", "z", "RY", "diff", "line", "division", "int", "ient", "error", "idy", "comment", "next", "cell", "archive", "data", "number"]}}
{"code": " \n  \n  \n  def show_board(board):\n      for row in board:\n          print ''.join(row)\n  \n  \n  N = int(sys.stdin.readline())\n  \n  for T in range(1, N+1):\n      (R, C, M) = map(int, sys.stdin.readline().split(' '))\n      E = R*C-M # empty\n      possible, reverse, need_adjust, column_base = (False, False, False, False)\n      if C > R:\n          (R, C) = (C, R)\n          reverse = True\n  \n      W = 0\n      lastRow = 0\n      if E == 0:\n          pass\n      elif E == 1 or M == 0:\n          W = C\n          possible = True\n      elif C == 1:\n          W = 1\n          if E > 0:\n              possible = True\n      elif C == 2:\n          W = 2\n          lastRow = int(E / 2) + 1   # 1 base\n          if E % 2 == 0 and E >= 4:\n              possible = True\n      elif C >= 3:\n          for w in range(2, C+1):\n              lastRow = int(E / w) + 1   # 1 base\n              if lastRow > R: continue\n              lastRowNum = E % w\n              \n              if lastRow == 2 and lastRowNum == 0:\n                  pass\n              elif lastRow == 2:   # lastRow == 1 => impossible\n                  if lastRowNum == 0:\n                      W = w\n                      possible = True\n                      break\n              elif lastRow >= 3:\n                  if lastRowNum >= 2 or lastRowNum == 0:\n                      W = w\n                      possible = True\n                      break\n                  elif C >= 4 and lastRowNum == 1 and R >= 3:\n                      W = w\n                      possible = True\n                      need_adjust = True\n                      break\n          if not possible:\n              for w in range(2, R+1):\n                  lastRow = int(E / w) + 1   # 1 base\n                  if lastRow > R: continue\n                  lastRowNum = E % w\n                  if lastRow == 2 and lastRowNum == 0:\n                      pass\n                  elif lastRow == 2:   # lastRow == 1 => impossible\n                      if lastRowNum == 0:\n                          W = w\n                          possible = True\n                          column_base = True\n                          break\n                  elif lastRow >= 3:\n                      if lastRowNum >= 2 or lastRowNum == 0:\n                          W = w\n                          possible = True\n                          column_base = True\n                          break\n                      elif C >= 4 and lastRowNum == 1 and R >= 3:\n                          W = w\n                          possible = True\n                          need_adjust = True\n                          column_base = True\n                          break\n                                  \n      if not possible:\n          if reverse:\n              R, C = (C, R)        \n          ans = 'Impossible %sx%s M=%s' % (R, C, M)\n          print 'Case #%(T)s: %(ans)s' % locals()\n          continue\n  \n      board = [['*'] * C for i in range(R)]\n      for i in range(E):\n          if not column_base:\n              c = i % W\n              r = i / W\n          else:\n              r = i % W\n              c = i / W            \n          board[r][c] = '.'\n      if need_adjust:\n          board[lastRow-1][1], board[lastRow-2][-1] = board[lastRow-2][-1], board[lastRow-1][1]\n      if reverse:\n          board = map(list, zip(*board))\n          R, C = (C, R)\n  \n      clicked = False\n      for r in range(R):\n          if clicked: break\n          for c in range(C):\n              cell = board[r][c]\n              if cell != '.': continue\n              if E == 1:\n                  board[r][c] = 'c'\n                  clicked = True\n                  break\n              \n              if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue\n              if r >= 1              and board[r-1][c]   == '*': continue\n              if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue\n              if             c >= 1  and board[r][c-1]   == '*': continue\n              if             c < C-1 and board[r][c+1]   == '*': continue\n              if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue\n              if r < R-1             and board[r+1][c]   == '*': continue\n              if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue\n              board[r][c] = 'c'\n              clicked = True\n              break\n  \n      ans = 'Possible' if possible else 'Impossible'\n      print 'Case #%(T)s:' % locals()\n      show_board(board)\n", "substitutes": {"board": ["flow", "deck", "object", "code", "array", "ro", "card", "table", "stream", "channel", "feed", "col", "flo", "Board", "list", "coll", "reader", "buffer", "input", "sequence", "rows", "frame", "hole", "layout", "block", "line", "boards", "entry", "comment", "form", "data", "word"], "row": ["x", "flow", "Row", "rown", "e", "insert", "result", "ro", "table", " Row", " rows", "post", "channel", "feed", "col", "round", "record", "section", "raw", "loop", "ow", "item", "buffer", "view", "rows", " x", "frame", "queue", "block", "line", "entry", "rect", "comment", "form", "work", "data", " line", "port", "word"], "N": ["Y", "NC", " n", "NS", "P", "n", "J", "NN", "U", "G", "H", "Size", "K", "X", "NT", "Ns", "B", "D", "F", "NO", "O", "S", "Z", "No", "Ne", "NR", "Node", "A", "L", "V"], "T": ["Y", "v", "t", "P", " L", "G", "col", "X", "tw", "RW", "Q", "y", "CW", "I", "B", "D", "F", " t", "O", "S", "Z", "p", "d", "k", "L", "U"], "R": ["Rh", "TR", "Y", "Row", "Rs", "P", "RE", "MR", "J", "CR", "RH", "RT", "JR", "G", "H", "SR", "RM", "RO", "K", "X", "Right", "RW", "Q", "DR", "RS", "I", "B", "RP", "D", "F", "RC", "RG", "O", "S", "Z", "RR", "V", "NR", "OR", "WR", "A", "L", "U", "RA"], "C": ["Y", "NC", "Cor", "SC", "CNN", "All", "P", "VC", "DC", "CM", "CR", "CF", "We", "CE", "H", "G", "CA", "K", "X", "Co", "CV", "CC", "Q", "CW", "Cu", "B", "I", "D", "CI", "F", "Ch", "O", "S", "CL", "Z", "EC", "V", "CU", "Count", "CN", "A", "L", "U"], "M": ["Y", "P", "MS", "MR", "CM", "U", "G", "MI", "H", "RM", "DM", "K", "X", "NM", "Q", "CC", "CW", "I", "B", "MF", "D", "F", "LM", "m", "O", "Z", "MN", "ME", "MC", "L", "V"], "E": ["AE", "IE", "Y", "e", "End", "OU", "Element", "Es", "UE", "P", "All", "DC", "Order", "EE", "CR", "SE", "U", "Entry", "CE", "G", "H", "ES", "OE", "K", "X", "PE", "El", "Edge", "EA", "Q", "Ed", "B", "I", "D", "F", "O", "Me", "CL", "NE", "EF", "EC", "EU", "Ge", "Ex", "Line", "EO", "L", "V", " e"], "possible": ["apossibly", "appossibly", "wpossibility", "npausible", "permanent", "spressed", "ppossible", "Pausible", "pbable", "possibility", "lpausible", "appossibility", "Permanent", "psossibility", "psossible", "pcossibly", "pcossibility", "vpossible", "spix", "pike", " pbable", "copossibly", "npacial", "pcossible", "pacted", "cpausible", "spossibly", "apitch", " npacial", "lpossibility", "ifossibly", "npossibility", "ppossibility", "ifossibility", "npossibly", "pacial", "hossibly", "psausible", "spossible", "sporable", "apausible", "npitch", "ifix", " possibility", "apossibility", " pential", "wpausible", "cpossibly", "vporable", "Pike", "appossible", "lporable", " possibly", "pitch", "wpossibly", "hossibility", "porable", "ipossibility", "wpossible", "apacted", "pential", "hossible", "vpossibly", "cpossibility", "lpossibly", " pacial", "pix", "ipike", "Possibility", "npbable", "lpential", "cpossible", "pressed", "Pix", "pausible", "spitch", "ipossibly", "ifossible", "lpossible", "spausible", "ppressed", "ppausible", " pausible", "npossible", "hermanent", "possibly", " npossibly", "Pacted", "pcermanent", "ipossible", " npossible", "Possible", "spossibility", "Pential", "copossible", "copacted", "copossibility", "apossible", " npossibility", "Possibly", "appike", "psressed", "Pbable", "vpossibility"], "reverse": ["original", " inverse", "both", "Rev", "Forward", " reversal", "forward", "history", "vert", "END", "change", "P", "end", "control", "sort", "pull", "right", "Both", "complete", "shift", "order", "edit", "rec", "regular", "X", "replace", "correct", "RW", "Desc", "rev", "total", "CC", "position", "cycle", "Rec", "CW", "native", "B", "I", "F", "view", " revers", "prev", "relative", "rows", "effect", " reversed", "S", "Z", "No", " Reverse", " forward", "force", "scale", "cc", "direction", "V", " D"], "need_adjust": ["need_adjusted", "know___scale", "need___adjust", "need___change", "need_scale", "know_scale", "know___change", "know_adjust", "need_change", "need__adjusted", "know_change", " need_adjusted", "need__change", "need___scale", "know_adjusted", "need_adapt", "needpchange", "need_add", "need___adjusted", " need_add", "needpscale", "know___adjust", "needpadjusted", "know___adjusted", "need__adjust", "needpadjust", " need_adapt", "need__scale"], "column_base": ["columnsbase", "column_weight", "column_based", "cell_weight", "columnroffset", "columnrbase", " column_adjust", "cell64count", "columnsnormal", "cell_bottom", "cell64base", "columnradjust", "row_based", "column_pad", "row_base", "column_offset", "column64weight", "cell64bottom", "column_adjust", "columnrbased", "column_extra", "cell_base", "column64base", " column_normal", "row_offset", " column_pad", "row_adjust", " column_extra", "column64bottom", " column_based", "column64count", "cell64weight", "column_normal", "columnspad", "column_bottom", "columnsextra", "column_count", "cell_count"], "W": ["Y", "Weight", "P", "DC", "VW", "Write", "U", "We", "G", "H", "K", "X", "WA", "Ws", "RW", "Word", "Q", "CW", "Wh", "B", "WE", "F", "D", "WS", "O", "WB", "S", "DW", "SW", "WP", "NW", "Writer", "WC", "WR", "L", "V", "GW"], "lastRow": ["LastPost", "recentMicro", "firstPage", "recentCell", "Lastrow", " lastLine", "LastMicro", " lastPost", "recentRow", "latestPost", "LastYe", "lastPage", " lastMonth", " lastCo", "variableRow", "LastLine", "recentCo", "lastYe", " lastWeek", "lastMonth", "lastCo", " lastOW", "firstrow", "nextMicro", "eachCell", "latestRow", "nextMonth", "eachRow", "finalRow", "lastMicro", "lastOW", "worstCell", "LastCell", "worstHour", "eachRoll", "latestWeek", "nextPage", "finalHour", "lastrow", "nextCell", "finalMicro", "LastRow", "firstCell", " lastrow", "firstLine", "worstrow", "firstRow", "eachSe", "variableCell", "nextrow", "latestMicro", "nextSe", "lastRoll", "variableOW", "latestCo", "nextOW", "recentMonth", "lastHour", "lastWeek", "nextLine", "latestCell", "recentYe", " lastRoll", " lastMicro", "lastCell", "lastPost", "nextHour", "nextWeek", "lastLine", " lastPage", "nextRow", "finalCell", "latestMonth", "variablerow", " lastCell", " lastSe", "finalrow", "worstRow", "nextRoll", "lastSe", "finalYe"], "w": ["x", "all", "v", "e", "aw", "l", "t", "n", "hw", "q", "how", "We", "U", "col", "o", "width", "g", "rew", "h", "wt", "tw", "ww", "sw", "TW", "raw", "wp", "ws", "wal", "way", "ow", "y", "max", "CW", "fw", "we", "iw", "wn", "wd", "wh", "can", "u", "m", "rw", "wb", "b", "p", "d", "kw", "z", "new", "wa", "ew", "wx", "nw", "k", "L", "word"], "lastRowNum": ["lastTotalNum", "lastColumnnum", "lastSectionNum", "lastCellNUM", "lastRowNUM", "lastRawNumber", "nextRowNum", "lastRowDesc", "lastRollDim", "lastPageMor", "nextCellNumber", " lastCellLen", "lastWeekNum", "lastPolyChan", "lastOWNum", "emptyRowNum", "lastCellSum", "LastRowNumber", "lastRawMin", "lastLinenum", "emptyrowNumber", "lastRowName", " lastRowLen", "lastCellName", "lastCellNumber", "lastrowSum", "lastRowMin", "nextRowMin", "firstCellnum", "nextCellSum", "lastFootLen", "lastRawName", "lastCellEm", "firstCellNumber", "emptyRowEm", "nextCellDesc", "lastSectionNUM", "lastOWnum", "lastCellnum", "LastRowChan", " lastCellNUM", "lastCellDim", "lastLineNumber", "emptyrowNUM", "lastLineNUM", "lastColumnNumber", "lastRowEm", "LastCellNumber", "lastRowNumber", "LastLineNum", "LastCellnum", "lastRowTon", "LastLineSum", "lastLineTon", "firstRownum", "lastCellLen", " lastRowNUM", "lastCellNum", "lastWeeknum", "lastRollNum", "firstRowNumber", "lastPageNumber", "nextRowSum", "lastTotalDesc", "lastRollnum", "LastLinenum", "lastColumnNum", "firstRowName", "lastPolyNum", "lastSectionEm", "lastRowMor", "lastLineMin", "lastRawNum", "firstRowMor", "emptyRowNumber", "LastRowDim", "firstRowNum", "firstCellName", "lastWeekTon", "lastPagenum", "nextRowDesc", "lastrowNum", "lastColumnEm", "lastrowName", "lastrowNumber", "lastLineNum", "LastRowEm", "lastTotalSum", "emptyrowEm", "LastRownum", "LastCellEm", "LastCellDim", "lastRowLen", "lastBlockMor", "lastRowChan", "firstCellMor", "LastRowSum", "lastSectionNumber", "LastRowNum", "emptyRowNUM", "lastRollNumber", " lastCellNum", "lastFootNum", "lastRawnum", "lastCellDesc", "lastCellMin", "firstCellNum", "LastLineNumber", "lastWeekNumber", "lastPolyNumber", "emptyrowNum", "lastRownum", "lastrownum", "lastColumnSum", "firstCellMin", "lastPageNum", "LastCellChan", "lastBlockNumber", "lastOWDesc", " lastCellNumber", " lastRowNumber", "lastFootNUM", "lastOWSum", "nextRowNumber", "nextCellNum", "lastLineSum", "lastBlockNum", "lastCellTon", "lastCellMor", "lastLineLen", "firstRowMin", "nextCellnum", "lastRowSum", "firstCellTon", "lastBlocknum", "lastrowNUM", "LastCellSum", "nextRownum", "LastCellNum", "nextCellMin", "lastCellChan", "firstRowTon", "lastColumnMin", "lastFootNumber", "lastTotalnum", "lastrowDim", "lastPolynum", "lastRowDim", "lastrowEm"]}}
{"code": " \n  \n  N = int(sys.stdin.readline())\n  \n  for T in range(1, N+1):\n      first_ans = int(sys.stdin.readline())\n      first_grid = []\n      for i in range(4):\n          row = [int(v) for v in sys.stdin.readline().split(' ')]\n          first_grid.append(row)\n      first_list = set(first_grid[first_ans-1])\n      \n      second_ans = int(sys.stdin.readline())\n      second_grid = []\n      for i in range(4):\n          row = [int(v) for v in sys.stdin.readline().split(' ')]\n          second_grid.append(row)\n      second_list = set(second_grid[second_ans-1])\n  \n      intersection = first_list.intersection(second_list)\n  \n      if len(intersection) == 1:\n          ans = intersection.pop()\n      elif len(intersection) == 0:\n          ans = 'Volunteer cheated!'\n      else:\n          ans = 'Bad magician!'\n  \n      print 'Case #%(T)s: %(ans)s' % locals()\n", "substitutes": {"N": ["NC", "Y", " n", "NS", "TN", "P", "n", "Num", "G", "H", "NI", "K", "X", "NM", "R", "NT", "Ns", "I", "B", "D", "F", "O", "RN", "Ni", "S", "Z", "C", "NE", "Ne", "NR", "M", "NA", "L", "V"], "T": ["j", "ii", "e", "code", "t", "ei", "time", "ind", "w", "o", "abi", "ti", "h", "unit", "vi", "\u0438", "I", " I", "u", "O", "p", "d", "k", "_", "f", "page"], "first_ans": ["first_an", "first_ANS", "first_ars", " first_an", " first_ANS", "first_ann", "second_ars", "second_ann", " first_ann", "second_an"], "first_grid": ["last_list", "last_group", "last_row", " first_range", "last_grid", " first_multi", "first_multi", "first_row", "first_group", "first_range"], "i": ["x", "id", "j", "ii", "e", "ip", "l", "ind", "yi", "iu", "r", "it", "o", "c", "ti", "ie", "h", "ar", "I", "ci", "il", "ai", "b", "p", "pi", "int", "a", "iv", "k", "f", "io"], "row": ["flow", "x", "bug", "Row", "key", "ip", "ko", "array", "child", "slice", "low", "ro", "up", "server", "ha", "month", "r", "channel", "field", "container", "feed", "col", "order", "du", "board", "group", "ward", "stroke", "one", "week", "value", "batch", "section", "element", "head", "zero", "reader", "sync", "ow", "zip", "range", "column", "view", "rows", "dd", "grid", "cube", "block", "line", "entry", "check", "error", "cell", "node", "seed", "off", "port"], "v": ["x", "j", "e", "volt", "vs", "vv", "l", "t", "vert", "n", "end", "q", "w", "ve", "o", "g", "vid", "c", "value", "h", "s", "conv", "en", "nv", "val", "y", "vi", "lv", "m", "u", "ver", "sv", "b", "p", "vol", "d", "av", "z", "ev", "iv", "k", "f", "ov", "var", "va", "V"], "first_list": ["last_list", "first_part", "first_layer", "first_lc", "last_chain", "last_grid", " first_lc", " first_layer", "first_chain", "last_part"], "second_ans": ["secondPsan", " second_ann", "two_ans", "two_san", "secondPans", " second_lan", "second_ann", "second_nas", "second_san", " second_nas", "second_an", "secondPann", "secondPan", "two_an", "second_lan", "two_ann"], "second_grid": ["second_row", "two_list", "two_row", "two_grid", "second_line", "second_card", "second_cell", "second__range", "two_card", "two_cell", "secondscard", "second_cart", "second__card", "two_range", "secondsrange", "secondsgrid", "two_cart", "two_line", "second_range", "second__list", "second__grid", "secondslist"], "second_list": ["second_lc", "second_layer", "secondary_list", " second_lc", "secondary_List", "second_List", "secondary_layer", "second_chain", " second_chain"], "intersection": ["interestablishment", "presection", "Interection", "oversection", "intsect", "coleave", "interion", "innersect", " interrelation", " intersector", "presect", " interion", "partsection", " intersect", "subsector", "presections", "partection", "overchange", "Intersector", "overleave", "intersect", "subsect", "intsector", "interchange", "intsection", " interestablishment", "Intersections", "intersections", "Interion", "cosect", "presector", "interection", "innersection", "oversect", "innerchange", "preion", "interleave", "intersector", "intestablishment", "interrelation", "subection", "prerelation", "cochange", "Intersection", "partsect", "cosection", "Interestablishment", "Interrelation", "partsector", "subsection", "Intersect", "innerleave", " intersections"], "ans": ["ams", "ens", "cus", "aus", "ann", "ents", "ns", "cs", "anne", "ds", "AN", "atan", "na", "ars", "aning", "os", "mean", "lan", "leans", "ants", "ins", "amps", "ane", "nas", "anas", "anc", "anus", "ana", "an", "sk", "can", "anes", "ant", "ats", "ads", " means", "anon", "ani", "aned", "ania", "san", "nan", "ANS", "ean", "ks"]}}
{"code": " \n  def solve(W, H, M):\n    board = [['*' for x in xrange(H)] for x in xrange(W)]\n    board[0][0] = 'c'\n    \n    S = [((H*W)-1, board, 0, 0, set())]\n    H -= 1\n    W -= 1\n    while len(S) > 0:\n      state = S.pop()\n      mines = state[0]\n      board = deepcopy(state[1])\n      x = state[2]\n      y = state[3]\n      visited = deepcopy(state[4])\n      visited.add((x, y))\n      \n      if mines == M:\n        s = ''\n        for row in board:\n          s += ''.join(row)\n          s += '\n'\n        return s\n      \n      elif mines > M:\n        if x > 0 and board[x-1][y] == '*':\n          board[x-1][y] = '.'\n          mines -= 1\n        \n        if x < W and board[x+1][y] == '*':\n          board[x+1][y] = '.'\n          mines -= 1\n        \n        if y > 0 and board[x][y-1] == '*':\n          board[x][y-1] = '.'\n          mines -= 1\n        \n        if y < H and board[x][y+1] == '*':\n          board[x][y+1] = '.'\n          mines -= 1\n        \n        if x > 0 and y > 0 and board[x-1][y-1] == '*':\n          board[x-1][y-1] = '.'\n          mines -= 1\n        \n        if x > 0 and y < H and board[x-1][y+1] == '*':\n          board[x-1][y+1] = '.'\n          mines -= 1\n        \n        if x < W and y > 0 and board[x+1][y-1] == '*':\n          board[x+1][y-1] = '.'\n          mines -= 1\n        \n        if x < W and y < H and board[x+1][y+1] == '*':\n          board[x+1][y+1] = '.'\n          mines -= 1\n        \n        if x > 0 and not (x-1, y) in visited:\n          S.append((mines, board, x-1, y, visited))\n        \n        if x < W and not (x+1, y) in visited:\n          S.append((mines, board, x+1, y, visited))\n        \n        if y > 0 and not (x, y-1) in visited:\n          S.append((mines, board, x, y-1, visited))\n        \n        if y < H and not (x, y+1) in visited:\n          S.append((mines, board, x, y+1, visited))\n        \n        if x > 0 and y > 0 and not (x-1, y-1) in visited:\n          S.append((mines, board, x-1, y-1, visited))\n        \n        if x > 0 and y < H and not (x-1, y+1) in visited:\n          S.append((mines, board, x-1, y+1, visited))\n        \n        if x < W and y > 0 and not (x+1, y-1) in visited:\n          S.append((mines, board, x+1, y-1, visited))\n        \n        if x < W and y < H and not (x+1, y+1) in visited:\n          S.append((mines, board, x+1, y+1, visited))\n    return 'Impossible'\n  \n  T = int(raw_input())\n  for t in range(T):\n    W, H, M = map(int, raw_input().split())\n    print 'Case #%i:\n%s' % (t+1, solve(W, H, M).strip())\n", "substitutes": {"W": ["Y", "N", "FW", "P", "DC", "J", "Work", "VW", "w", "We", "E", "G", "K", "X", "WA", "Gr", "R", "MW", "Web", "Sl", "Q", "WH", "CW", "Wh", "B", "WN", "D", "F", "WE", "WM", "Ch", "WS", "WB", "Z", "C", "V", "SW", "WP", "SH", "WR", "WC", "A", "L", "U", "GW", "Sw"], "H": ["Rh", "Y", "N", "NH", "Th", "EH", "FH", "P", "HS", "TH", "J", "Cl", "RH", "Work", "U", "w", "Ph", "E", "G", "HI", "HC", "K", "X", "HH", "Gr", "He", "h", "Time", "R", "OH", "HD", "Sl", "Che", "Q", "WH", "Kh", "DH", "B", "Wh", "MH", "D", "F", "Ch", "O", "Z", "HA", "HM", "C", "CH", "Ha", "PH", "Hum", "SH", " h", "Hy", "Sh", "L", "V", "HY", "Sw"], "M": ["N", "Y", "P", "MS", "J", "CM", "U", "E", "SM", "G", "MX", "DM", "K", "X", "NM", "R", "Q", "I", "B", "MH", "D", "F", "MB", "LM", "MM", "m", "O", "Z", "MN", "C", "A", "L", "V"], "board": ["game", "book", "model", "run", "stream", "feed", "image", "square", "coll", "head", "way", "boarding", "case", "A", "video", "bug", "SC", "deck", "object", "rule", "down", "array", "slice", "card", "que", "stroke", "one", "list", "sc", "join", "loop", "oo", "door", "clean", "panel", "block", "boy", "check", "back", "form", "point", "cart", "word", "flow", "all", "index", "lane", "che", "code", "control", "table", "body", "group", "ward", "bar", "section", "wheel", "input", "view", "lay", "frame", "b", "Z", "layout", "line", "client", "foot", "comment", "land", "room", "f", "menu", "ack", "draw", "ko", "chart", "home", "bo", "post", "w", "channel", "o", "flo", "Board", "Q", "lock", "sequence", "null", "document", "hole", "builder", "wall", "boards", "entry", "player", "work", "node", "bank", "U", "design"], "x": ["id", "v", "area", " xx", "image", "ux", "size", "position", "lat", "win", "xc", "m", "yx", "ph", "gy", "ax", " X", "sex", "content", "k", "xs", "rx", "j", "l", "no", "xy", "n", "time", "wy", "zx", "r", "xxx", "oint", "one", "X", "xml", "ice", "ex", "xp", "name", "left", "height", "my", "xt", "xf", "p", "ix", "wa", "full", "a", "ct", "check", "ctx", "point", "com", "index", "px", "ip", "code", "q", "www", "xi", "event", "any", "ady", "el", "on", "type", "pe", "ya", "python", "host", "view", "yl", "ci", "u", "dx", "b", "cross", "d", "pos", "line", "f", "xe", "xx", "e", "key", "tx", "ox", "fx", "w", "o", "width", "g", "c", "h", "i", "ty", "ic", "z", "ey", "int", "dy", "cy", "wx", "work", "lex"], "S": ["N", "ST", "Y", "SC", "NS", "south", "P", "SA", "SE", "U", "OS", "SL", "Si", "R", "SS", "sb", "OSS", "B", "D", "F", "WS", "O", "Z", "STATE", "C", "states", "State", "SH", "Set", "A", "L", "V", "SU"], "state": ["step", "parent", "j", "part", "e", "key", "object", "rule", "slice", "area", "model", "run", "core", "address", "store", "r", "post", "order", "shape", "body", "space", "image", "g", "match", "dict", "private", "set", "list", "section", "head", "scope", "sync", "position", "size", "config", "start", "range", "style", "message", "shadow", "stat", "session", "p", "STATE", "states", "block", "pos", "line", "resource", "back", "scale", "State", "comment", "k", "player", "case", "node", "data", "point", "work", "port", "se"], "mines": ["minores", "minenses", "minsises", "maines", " minues", "minsES", "minodes", " minores", "minsues", "minsutes", "minses", "Minutes", "menES", "minees", "minsenses", "MINions", "minises", "Minies", "menss", " minenses", "Minues", " minees", "MINES", "Minions", "Minenses", " minunes", "mainions", "menes", "minues", "mainences", " miners", "eminunes", "eminees", "Minees", "minsies", "MINues", "emininates", "minss", "eminues", "minsores", "Minences", "mainutes", "minsions", " minions", "Mininates", "Mines", " minodes", " minss", " minES", "mininates", "minsodes", "minES", "MinES", "minsss", " minences", "minsences", "Miners", "minunes", "mainies", "minions", " minises", "Minores", "menences", "MINes", " mininates", "emines", "Minunes", "minsers", "minies", "miners", "minutes", "Minodes", "eminions", "Minises", "MINences", "minences"], "y": ["id", "v", "sy", "area", "iny", "vy", "ies", "ay", "yah", "yn", "en", "m", "yx", "ity", "gy", "hy", "Y", "ym", "j", "ky", "ys", "n", "xy", "wy", "sky", "yd", "ish", "ie", "oo", "ot", "out", "height", "my", "ry", "zy", "p", "fy", "ix", "ye", "a", "hot", "yt", "q", " Y", "yi", "any", "ady", "el", "type", "hop", "ya", "iy", "ery", "yl", "py", "u", "yes", "b", "d", "ch", "oy", "ly", "f", "e", "key", "yr", "ny", "yan", "w", "o", "yy", "c", "h", "i", "ley", "file", "ty", "z", "ey", "year", "dy", "cy", "isy", "yo"], "visited": ["visitors", "minited", " vised", "versored", "versed", "deniting", "visored", "dened", " visiting", "VISited", "minITED", "visiting", "mined", " visitors", "VISed", "VISITED", "denited", "vised", "VISored", "denitors", "visITED", "Visited", "Vised", "Visiting", "Visitors", "minored", "versited", "versITED"], "s": ["e", "us", "ns", "string", "l", "south", "n", " ss", "r", "w", "sym", "settings", "o", "ing", "g", "its", "c", "series", "i", "h", "sb", "ses", "si", "single", "ss", " parts", "rows", "b", "p", "session", "sv", "d", "states", "sg", "ed", "a", "es", "ings", "f", "ions", "sl", "se"], "row": ["instance", "flow", "Row", "key", "insert", "index", "string", "sel", "result", "slice", "ro", "up", "server", "month", "r", "feed", "ross", "col", "round", "ward", "week", "section", "raw", "loop", "port", "range", "view", "rows", "frame", "hole", "cube", "block", "ride", "arrow", "line", "entry", "rect", "cell", "rank", "node", "scan", "page"]}}
{"code": "T = int(raw_input())\n  for i in range(T):\n    index = int(raw_input())\n    X = []\n    for j in range(4):\n      X.append(map(int, raw_input().split()))\n    x1 = X[index-1]\n    index = int(raw_input())\n    X = []\n    for j in range(4):\n      X.append(map(int, raw_input().split()))\n    x2 = X[index-1]\n    ans = set(x1).intersection(set(x2))\n    if len(ans) == 0:\n      print 'Case #%i: Volunteer cheated!' % (i+1)\n    elif len(ans) == 1:\n      print 'Case #%i: %i' % (i+1, ans.pop())\n    else:\n      print 'Case #%i: Bad magician!' % (i+1)\n", "substitutes": {"T": ["x", "N", "Y", "Total", "TN", "t", "P", "Index", "time", "TI", "Length", "H", "G", "K", "Time", "R", "TW", "Q", "I", "B", "D", "F", "CI", "O", "S", "TT", "Z", "C", "length", "M", "A", "L", "V"], "i": ["ji", "x", "id", "ii", "e", "key", "ik", "im", "ip", "multi", "t", "n", "slice", "cli", "ind", "l", "phi", "xi", "yi", "li", "iu", "it", "uni", "c", "ti", "gi", "ie", "qi", "type", "chi", "dim", "y", "si", "I", "iw", "eni", "uri", "ci", "ini", "u", "ib", "m", "ai", "p", "z", "ix", "pi", "int", "ij", "axis", "mini", "di", "zi", "k", "f", "ui"], "index": ["x", "id", "key", "PI", "Index", "slice", "end", "ind", "EX", "sort", "tail", "site", "it", "shape", "edit", "thread", "xxx", "offset", "degree", "match", "value", "connection", "date", "type", "list", "section", "tick", "element", "action", "FIX", "name", "alpha", "position", "I", "num", "start", "ID", "point", "CI", "column", "IND", "null", "search", "span", "pos", "ix", "length", "diff", "int", "condition", "iter", "weight", "number", "loc", "temp", "inc", "test"], "X": ["Stack", "x", "Y", "N", "Do", "Int", "POST", "P", "Index", "Single", "Input", "Work", "FC", "E", "H", "G", "Content", "MX", "Cross", "XX", "W", "ENS", "JSON", "K", "IX", "Time", "Front", "XXX", "Test", "FIX", "Q", "XT", "Array", "List", "ML", "D", "F", "Box", "XP", "WS", "CT", "OX", "Current", "Z", "CL", "C", "XL", "V", "FF", "ZX", "Case", "Event", "Ex", "HTTP", "M", "A", "L", "EX", "U", "IP"], "j": ["ji", "x", "je", "l", "t", "n", "ind", "get", "J", "q", "jj", "r", "it", "g", "c", "ie", "jp", "jl", "y", "b", "p", "d", "z", "int", "ct", "k", "_", "f"], "x1": ["xFirst", "X5", "x5", "X2", "view5", "p2", "XOne", " xOne", " xFirst", "X1", "X0", "view1", "XFirst", "pOne", "x0", "view2", "xOne", " x5", "p0", "p1", "viewFirst", " x0"], "x2": ["x4", "cross02", "X2", "X4", "x02", "v2", "vtwo", "X1", "X02", "v1", " x4", "xtwo", "index1", "cross2", "Xtwo", " x02", "cross1", "index2", "cross4", "indextwo"], "ans": ["ens", "x", "ams", "part", "cus", "ns", "ann", "ons", "aus", "cs", "anne", "ras", "oss", "AN", "atan", "Ann", "cas", "na", "ars", "aning", "An", "os", "lan", "who", "ants", "ins", "amps", "anas", "antis", "nas", "gan", "annot", "anc", "anus", "ana", "an", "can", "meaning", "cross", "anon", "ani", "ls", "aned", "names", "aos", "san", "a", "es", "cases", "ANS", "A"]}}
{"code": " \n  def all_grids(R,C,M, lp=0,placed=0):\n      rem = R*C-lp\n      if M-placed >= rem:\n          if M-placed > rem:\n              return None\n          \n          res = set()\n          for i in range(lp, R*C):\n              res.add(i)\n          return [res]\n          \n      if placed == M:\n          return [set()]\n  \n      res = []\n      for i in range(lp, R*C):\n          sub_sol = all_grids(R,C,M,i+1, placed+1)\n          if sub_sol is None:\n              continue\n              \n          for s in sub_sol:\n              s.add(i)\n              res.append(s)\n      return res\n  \n  def adj(R,C,i):\n      \n      res = []\n      left_edge = i % C == 0\n      top_edge = i // C == 0\n      right_edge = (i+1) % C == 0\n      bottom_edge = i // C == R-1\n      \n      if not left_edge:\n          res.append(i-1)\n          if not top_edge:\n              res.append(i-1-C)\n          if not bottom_edge:\n              res.append(i+C-1)\n              \n      if not right_edge:\n          res.append(i+1)\n          if not top_edge:\n              res.append(i+1-C)\n          if not bottom_edge:\n              res.append(i+1+C)\n              \n      if not bottom_edge:\n          res.append(i+C)\n      if not top_edge:\n          res.append(i-C)\n      return res\n          \n      \n      \n      \n  def solution(R,C,g):\n      M = R*C\n      res = []\n      num_zeroes = 0\n      for i in range(M):\n          if i in g:\n              res.append('x')\n              continue\n          x = 0\n          for a in adj(R,C,i):\n              if a in g:\n                  x += 1\n          if x == 0:\n              num_zeroes += 1\n          res.append(x)\n          \n      for i in range(M):\n          if i in g:\n              continue\n          r = res[i]\n          if r == 0 and num_zeroes == 1:\n              continue\n          connected = False\n          for a in adj(R,C,i):\n              if res[a] == 0:\n                  connected = True\n                  break\n          if not connected:\n              return None\n      \n      return res.index(0)\n  \n  def transcribe(R,C, g, sol):\n      res = []\n      for i in range(R):\n          r = []\n          for j in range(C):\n              x = i*C+j\n              if x in g:\n                  r.append('*')\n              elif x == sol:\n                  r.append('c')\n              else:\n                  r.append('.')\n          res.append(r)\n      return res\n  \n  def printed_sol(transcript):\n      if transcript is None:\n          return \"Impossible\"\n      else:\n          return \"\n\".join(\"\".join(row) for row in transcript)\n  \n  def solve(R,C,M):\n      if M == R*C-1:\n          g = []\n          for i in range(R*C-1):\n              g.append(i)\n          return transcribe(R,C, g, R*C-1)\n      \n      for g in all_grids(R,C,M):\n          sol = solution(R,C,g)\n          if sol is None:\n              continue\n          return transcribe(R,C, g, sol)\n      return None\n              \n      \n  def output_grid(R,C,g):\n      for i in range(R):\n          for j in range(C):\n              if i*C+j not in g:\n                  sys.stdout.write(\".\")\n              else:\n                  sys.stdout.write(\"*\")\n          sys.stdout.write(\"\n\")\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1,T+1):\n          R,C,M = map(int, raw_input().split())\n          print \"Case #%d:\" % i\n          print printed_sol(solve(R,C,M))\n", "substitutes": {"R": ["Rh", "A", "N", "Rule", "TR", "GR", "Rs", "Range", "P", "RE", "MR", "Cl", "J", "CR", "RH", "Re", "Rec", "JR", "E", "RIP", "H", "G", "SR", "Rob", "RM", "W", "RO", "Right", "X", "K", "RW", "ER", "Q", "DR", "RS", "BR", "Br", "I", "B", "Run", "RP", "AR", "D", "F", "RC", "RG", "IR", "Ra", "LR", "RN", "RL", "S", "RR", "V", "Res", "NR", "KR", "WR", "L", "U", "RA"], "C": ["N", "Y", "NC", "SC", "CNN", "Cs", "P", "VC", "DC", "CM", "CR", "Cl", "FC", "CF", "Con", "E", "G", "CE", "H", "Size", "W", "YC", "K", "X", "c", "CA", "Sc", "JC", "Central", "CV", "CC", "ERC", "Q", "CS", "Cu", "B", "I", "KC", "CI", "D", "F", "Ch", "CP", "GC", "O", "CT", "S", "CL", "EC", "MC", "V", "CU", "Count", "CN", "WC", "A", "L", "U"], "M": ["N", "Y", "MD", "PM", "FM", "P", "MR", "MO", "J", "CM", "man", "Multi", "MT", "mm", "E", "G", "MX", "H", "RM", "W", "DM", "X", "MP", "NM", "REM", "Q", "ML", "I", "B", "OM", "MF", "D", "F", "MB", "LM", "JM", "MM", "EM", "m", "cm", "O", "Mi", "S", "p", "MN", "MA", "MC", "V", "IM", "A", "L", "U"], "lp": ["layer", "bp", "dl", "pl", "l", "np", "P", "lc", "LI", "li", "mm", "lr", "len", "mp", "lv", "pp", "RP", "lvl", "PP", "CP", "LM", "fp", "m", "base", "cm", "pa", "lb", "LP", "lf", "p", "b", "LR", "pm", "pit", "ls", "Mp", "cp", "loc", "pre", "L"], "placed": ["aid", "matched", "mr", "pg", "numbered", "paid", "pl", "controlled", "l", "powered", "ordered", "sp", "named", "occupied", "PL", "mi", "LI", "P", "no", "aced", "holder", "shaped", "li", "mm", "owned", "ld", "mounted", "place", "fe", "claimed", "replace", "len", "section", "packed", "Position", "seq", "represented", "position", "reg", "places", "left", "B", "led", "m", "marked", "found", "lb", "pa", "pool", "b", "p", "LP", "cm", "pm", "selected", "ed", "pos", "arent", "filled", "used", "assembled", "added", "loc", "central", "pre", "shared"], "rem": ["ps", "remove", "remote", "original", "min", "im", "sp", "Rem", "mem", "pres", "cache", "repl", "kept", "mm", "place", "ref", "me", "rm", "master", "xp", "prem", "REM", "jp", "ret", "reg", "rest", "prev", "m", "cm", "pop", "pa", " Rem", "exp", "pm", "recent", "rep", "cl", "re", "pre", "resp"], "res": ["remote", "ons", "err", "gr", "args", "yrs", "pres", " results", "ios", "RES", "rez", "bs", "seq", "ress", "ws", "rc", "nos", "breaks", "powers", "obj", "cases", "resp", "maps", "ps", "css", "rx", "ns", "ras", "Result", "models", "changes", "os", "rys", "ES", "resources", "rest", "cells", "pers", "qs", "ids", "rows", "p", "details", "works", "rules", "response", "lines", "vals", "re", "blocks", "mr", "rss", "Rs", "cs", "result", "eps", "features", "js", "rel", "max", "sr", "rus", "runs", "rs", "relations", "Results", "ros", "errors", "resh", "ries", "right", "rh", "rates", "ms", "ins", "params", "rev", "ret", "reg", "RS", "req", "resolution", "S", "results", "Res", "es", " Res", "arr", "loc", "exp", "ris"], "i": ["id", "v", "ri", "bi", "err", "cli", "t", "image", "ios", "ti", "gi", "ir", "chi", "sci", "hi", "position", "oi", "iw", "eni", "ni", "m", "iter", "api", "im", "l", "n", "slice", "ei", "lc", "anti", "li", "ie", "info", "ai", "p", "ix", "isi", "di", "zi", "ui", "ii", "aci", "index", "multi", "ip", "mi", "phi", "ind", "xi", "yi", "iu", "it", "qi", "y", "I", "ori", "uri", "ci", "ini", "iq", "u", "b", "pi", "ami", "f", "ji", "e", "o", "c", "si", "ic", " bi", "z", "int", "mini", "io", "ia"], "sub_sol": ["Sub_Sol", " sub_ol", "subpuboln", "sub_oln", "subregsol", "subpubol", " sub_rel", " sub_oln", "subjoln", "subjol", "sub_ol", "subjrel", "subregSol", "Sub_sol", "sub_sl", " sub_Sol", "subregsl", "subjsql", "subpubrel", "subjsol", "Sub_sql", "subpubsol", "subjSol", " sub_sl", "sub_Sol", "sub_sql", "sub_rel", "subregol"], "s": ["ps", "e", "sys", "ns", "cs", "sp", "l", "n", "sec", "se", "su", "os", "spec", "ages", "settings", "o", "sets", "c", "sc", "ses", "ws", "sites", "sb", "si", "sr", "cells", "ss", "m", "search", "resolution", "S", "sim", "p", "details", "fs", "d", "sg", "states", "results", "ls", "sub", "es", "ions", "sf", "sl", "sq"], "left_edge": ["left_line", "full_ee", "left_ee", "left_side", "full_side", "right_side", "full_end", "right_line", "left_end", "full_edge"], "top_edge": ["top\u00b7distance", "bottom_size", "top_size", "bottom_line", "middle\u00b7distance", "middle\u00b7edge", "topingge", "topingend", "topingedge", "top\u00b7line", "top_ge", " top_end", "top_end", "root_edge", "middle\u00b7line", "root_gate", " top_element", "top\u00b7edge", "middle_edge", "top_element", "top_distance", "top_gate", "top\u00b7ide", "middle\u00b7ide", "topingelement", "top_event", "root_hop", "root_ge", "top_ide", "middle_ide", "middle_line", " top_ge", "top_hop", "middle_distance", "bottom_event", "top_line"], "right_edge": ["right_pe", "down_Edge", "right_age", "down_edge", "right_Edge", "right__edge", "right__tie", "right\u00b7edge", "right\u00b7pe", "right_end", "right_tie", "right_enter", "right\u00b7end", "right__Edge", "down_age", "top_end", "right\u00b7enter", "top_enter", "down_tie", "top_pe", "right__age"], "bottom_edge": ["bottom_grade", "top_error", "bottom_link", "bottom_end", "wrong_layer", "bottom_line", " bottom_grade", "top_ense", "front_degree", "wrong_anne", " bottom_enter", "front_line", "bottom_degree", "front_route", "top_end", "bottom_route", "wrong_link", "wrong\u00b7edge", "bottom\u00b7anne", "bottom_anne", "wrong\u00b7link", "bottom\u00b7layer", "bottom_ense", "bottom_error", "bottom\u00b7edge", "bottom\u00b7link", "wrong_edge", "wrong\u00b7anne", "bottom_enter", "front_edge", " bottom_end", "wrong\u00b7layer", "bottom_layer"], "g": ["gg", "game", "v", "e", "groups", "gc", " G", "l", "n", "play", "ga", "q", "gr", "gen", "gre", "Gs", "w", "gu", "erg", "G", "group", "bg", "cfg", "c", "ge", "gi", "h", "eg", "GV", "gm", "mg", "GF", "msg", "gl", "gh", "reg", "gs", "GC", "gp", "m", "CG", "go", "mc", "ic", "b", "p", "LG", "Group", "d", "sg", "ch", "ig", "gb", "rg", "GS", "k", "cl", "f", "GG"], "num_zeroes": ["num_zoos", "num_zerops", "num_zoops", "num_zzoes", "num_zzops", "num_zonops", "num_erops", "num_zzoom", "num_eros", "num_zereros", "num_zonos", "num_zoms", "num_zoes", "num_zops", "num_zooom", "num_zoom", "num_eroms", "num_zoeros", "num_zonoes", "num_zeroms", "num_zooms", "num_zzos", "num_eroes", "num_zoneros", "num_zeros", "num_zos", "num_zeroom", "num_zooes"], "x": ["rx", "rex", "xx", "e", "v", "id", "xe", "index", "px", "xxxxxxxx", "xb", "t", "xy", "tx", "xi", "w", "xxxx", "xxx", "width", "X", "c", "xml", "ex", "xes", "h", "xp", "y", "xa", "xc", "xt", "m", "u", "yx", "dx", "p", "xf", "cross", "z", "ix", "ax", "int", "wx", "xs", "work", "f", "exp"], "a": ["A", "all", "e", "ea", "la", "err", "sa", "result", "br", "t", "n", "ga", "area", "ca", "ha", "xi", "na", "w", "ae", "o", "aaa", "c", "aa", "ar", "ya", "active", "alpha", "ad", "ana", "y", "ta", "an", "m", "u", "ai", "b", "p", "ra", "d", "z", "wa", "int", "ja", "f", "ma", "ac", "ia", "ba"], "r": ["e", "v", "err", "l", "br", "array", "n", "t", "w", "o", "c", "h", "ar", "attr", "nr", "y", "sr", "pr", "ur", "m", "u", "rs", "b", "p", "d", "z", "k", "re", "f", "er"], "connected": ["valid", "opened", "open", "Connect", "br", "controlled", "no", "charged", "ordered", "finished", "run", " disconnected", "complex", "sect", "red", "rational", "compatible", "hidden", "tested", "on", "ended", "path", "public", "rounded", "conn", "connection", "normal", "h", "sc", "active", "linked", "supported", "thin", "rev", "tun", "online", "rupt", "wired", "reg", "connect", "visible", "con", "function", "closed", "loaded", "selected", "ed", "broken", "shown", "graph", "established", "fitted", "f", "loc", "bound", "central"], "sol": ["poly", "min", "groups", "GR", " G", "gr", "model", "q", "gn", "Sol", "col", "group", "cr", "Gr", "gi", "sql", "gm", "GF", "gl", "reg", "gs", "grid", "sg", "ls", "ol", "mol", "graph", "GS"]}}
{"code": "def solve(c1, g1, c2, g2):\n      row_1 = g1[c1-1]\n      row_2 = g2[c2-1]\n      inter = set(row_1) & set(row_2)\n      if len(inter) == 0:\n          return \"Volunteer cheated!\"\n      if len(inter) > 1:\n          return \"Bad magician!\"\n      return str(inter.pop())\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1,T+1):\n          c1 = int(raw_input())\n          g1 = []\n          for j in range(4):\n              g1.append(map(int, raw_input().split()))\n          c2 = int(raw_input())\n          g2 = []\n          for j in range(4):\n              g2.append(map(int, raw_input().split()))\n          print \"Case #%d: %s\" % (i, solve(c1,g1,c2,g2)) \n          \n      \n", "substitutes": {"c1": [" c_", "g_", "pfirst", "cOne", "col1", "c_", "dc2", "c4", " c01", "p2", "lc1", "lc2", "dc4", "lc4", "gfirst", "cu1", "cu01", "cfirst", "cu_", "g01", " cOne", "g4", "pOne", "colOne", "g0", " c0", "colfirst", "c01", "lc0", "gOne", "lcOne", "col2", "c0", "p1", "cu2", "dc1"], "g1": ["ig61", "gup", "ge1", "cOne", "p81", " gart", " gone", "G1", " g81", "ig2", "ig9", " g9", "gd", "ga1", "ga2", "p2", " gup", "gone", "pd", "geOne", "G61", "gen1", "c81", "cone", " gOne", "c12", " g3", "cd", "g12", "G2", "c3", " g61", "g3", "gen12", "g61", "ge2", "ig1", "gaone", "gart", "geup", "cup", "g81", "gaart", " g12", "gOne", "G9", "g9", "gen3", "p1", " gd", "cart", "gen2"], "c2": ["c72", "dctwo", "dcTwo", "t2", "t62", "gSecond", "dc5", " c72", "itwo", "dc2", "c4", "e2", "c62", "i2", "arcSecond", "e5", "arc4", "arctwo", "e72", "iTwo", " c5", "C1", "C4", "arc1", "c5", "g4", "ctwo", "cSecond", "Ctwo", "t5", " cTwo", "arc2", "i5", " ctwo", "C2", "gtwo", " c62", "t72", "CSecond", "e62", "cTwo"], "g2": [" gall", "gen4", "G1", "gall", " g0", "gaall", " g82", "ga1", "c4", "ga2", "G82", "G0", " g4", "genTwo", "g002", " gTwo", "c82", "c002", " g3", " g02", "g02", "c5", "g4", "G2", "G4", "ga3", "gen5", "ga4", "g3", "ga02", " g5", "g82", "call", "g0", "g5", " g002", "G02", "G002", "G3", "c0", "gTwo", "gen2", "cTwo"], "row_1": [" row_one", " row_first", "row___first", "row_one", "feed___1", "rowA1", "rowAfirst", "row___inf", "feed___4", "rowA4", "row_4", "feed_4", "feed_inf", "feed_1", "feed_first", "row___1", "row___4", "row_inf", "feed___first", "row_first", "rowAinf", "feed___inf"], "row_2": [" row_two", "row_0", "col_0", "row_two", "row_22", "col_1", " row_g", "col_22", "row_g", "col_2"], "inter": ["step", "double", "part", "feature", "fr", " Inter", "sel", "patch", "ter", "ner", "ace", "up", "pin", "mer", "edge", "international", "el", "square", "match", "ir", "pointer", "ar", "filter", "section", "outer", "angle", "si", "INTER", "over", "ser", "inner", "interface", "Inter", "intel", "con", "tri", "ext", "ver", "inc", "air", "diff", "entry", "chain", "int", "quad", "cor", "inch", "iter", "car", "inters", "pair", "er", "pre", "char", "intern"], "T": ["N", "Y", "TN", "t", "P", "time", "TS", "TI", "U", "E", "G", "H", "W", "X", "Time", "R", "Q", "I", "B", "D", "F", "WT", "O", "S", "Z", "C", "length", "Ti", "M", "A", "L", "V"], "i": ["ji", "x", "ii", "v", "e", "ri", "index", "ip", "t", "n", "phi", "ind", "J", "xi", "li", "iu", "it", "g", "c", "ti", "gi", "chi", "qi", "y", "si", "I", "uri", "ci", "u", "b", "p", "d", "z", "pi", "int", "a", "di", "f", "io"], "j": ["ji", "x", "id", "v", "im", "l", "t", "n", "dj", "ind", "q", "J", "jj", "r", "it", "js", "g", "ge", "jp", "jl", "row", "job", "b", "p", "d", "z", "int", "ja", "ij", "k", "_", "f", "uj"]}}
{"code": " \n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def map(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tprint Bombs\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t\tif Bombs == 0:\n  \t\t\t\tbreak\n  \t\t\t\n  \t\t\tif lastSkip:\n  \t\t\t\tm[i][j] = 'f'\n  \t\t\t\tcontinue\n  \t\t\t\n  \t\t\tif R - i == 2 or C - j == 2:\n  \t\t\t\tif Bombs == 1:\n  \t\t\t\t\tm[i][j] = 'f'\n  \t\t\t\t\tlastSkip = True\n  \t\t\t\t\tcontinue\n  \t\t\t\n  \t\t\t\t\n  \t\t\tm[i][j] = '*'\n  \t\t\tBombs -= 1\n  \t\t\tlastSkip = False\n  \t\tlastSkip = False\n  \t\t\t\t\n  \t\n  \t\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  \t\t\n  def imprimir(m):\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  def map2(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \t\n  \tii = 0\n  \tjj = 0\n  \twhile Bombs > 0:\n  \t\tfor j in xrange(jj, C):\n  \t\t\tif Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\n  \t\t\t\tm[ii][j] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tcontinue\n  \t\t\n  \t\t\n  \t\tfor i in xrange(ii+1, R):\n  \t\t\tif Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\n  \t\t\t\tm[i][jj] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tif Bombs > 0:\n  \t\t\t\t\tprint \"Impossible\"\n  \t\t\t\t\treturn\n  \t\t\t\tcontinue\n  \t\tjj += 1\n  \t\tii += 1\n  \timprimir(m)\n  \t\n  \t\t\t\t\n  \t\n  \t\n  \n  \t\t\n  def main(R, C, M):\n  \tvazios = R * C - M\n  \n  \tif R == 1 or C == 1 or vazios == 1 or vazios >= 4:\n  \t\tmap2(R, C, M)\n  \telse:\n  \t\tprint \"Impossible\"\n  \n  \treturn \"\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor i in xrange(tCase):\t\n  \t\t\n  \t\tR, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d:\" % (i + 1)\n  \t\tmain(R, C, M)\n", "substitutes": {"tCase": ["TPath", "tPath", "tfPath", "Tcases", "ttcase", "tcase", "ttName", "tfcases", "ttPath", "tfcase", "ttCase", "TName", "tName", " tPath", "tfCase", "tfName", " tcases", "TCase", "tcases", "Tcase", " tcase"], "R": ["Rh", "TR", "N", "Y", "T", "GR", "Rs", "Range", "All", "P", "RE", "J", "Cl", "RH", "CR", "Re", "r", "U", " r", "E", "JR", "G", "H", "SR", "RIP", "RM", "W", "RO", "Right", "X", "Sc", "K", "Par", "RW", "ER", "Q", "DR", "RS", "BR", "Br", "I", "B", "Run", "Rec", "AR", "D", "F", "RP", "RG", "Ra", "IR", "O", "RN", "LR", "RL", "S", "CL", "RR", "Res", "NR", "Line", "Block", "KR", "WR", "M", "A", "Role", "L", "Region", "V", "RA"], "C": ["N", "Y", "SC", "T", "CNN", "AC", "Cs", "P", "VC", "DC", "CM", "CR", "J", "Cl", "CF", "U", "E", "H", "G", "Size", "CE", "W", "YC", "CA", "K", "Sc", "X", "JC", "CV", "CC", "Q", "CW", "I", "B", "Cu", "Ca", "CS", "D", "CI", "F", "Cr", "KC", "Ch", "GC", "O", "S", "CL", "EC", "MC", "CU", "RFC", "CN", "Code", "M", "A", "L", "V"], "Bombs": ["Bashes", "Balballs", "GBategories", "Blocks", "bandals", "Balombies", "Bambers", "Ubballs", "Bunks", "GBumbs", "Bomb", "BWumbs", "Businessategories", "Fomb", " Bomas", " Bbusters", "Bootowers", " Besses", "FBballs", "Bootombs", "bosion", "OBumbs", "Subunks", "BBombies", " Bumbs", "bombie", "Bresses", "BBacteria", "Businessiers", "Blockandals", "Balosion", "Ubambers", " Bauts", " Borers", "BWaos", "Baos", "Phomers", "Baches", "MBombs", "BFomes", " Bballs", "Louts", "Blockombs", "Bomas", " Bouts", "Borders", "SBorers", " Bounces", "Bategories", "besses", "Besses", "Bouts", "Bootorders", "Bballs", "Ubombs", "Lambers", "bomb", "UBresses", " Baches", "PBombs", "Blategories", "Ambones", "FBashes", "Subandals", "bomes", "Fambers", " Bones", " Baos", "SBombs", "bambers", "MBombies", "UBashes", "MBambers", "Blombies", "SBandals", "Bumbs", "GBambers", "Bauts", "bbusters", "Brees", "PBowers", "BFaches", "Blockauts", "Subombs", "PBorders", "Biers", "PBlocks", "bounces", "Basm", "BBasm", "baos", "brees", "Phombs", "Balashes", "Bomes", "Blouts", "bballs", " Basm", "Phauts", "Businessombs", "MBumbs", "blocks", "Bandals", "Blacteria", "bones", "Bounces", "BBombs", "bowers", " Bunks", " Borders", "FBresses", "BFesses", "BFombs", "Bombie", "Ubauts", "Lumbs", "bumbs", "BFauts", "bombs", "Bliers", "Bombies", "Baombie", "OBambers", "Blombs", "borders", "Buffomers", "Burches", "Baounces", "Ambbusters", "Ambombs", "Bootlocks", "FBombs", "Balombs", "Balouts", "Borers", "Blockosion", "Buffombs", "Baombs", "UBballs", "BFomers", "Forders", "bauts", "Barees", "Bosion", "Lombs", "Buffurches", "Buffauts", "Balandals", "bomas", "OBombies", " Bombie", "Balacteria", "Balauts", "Fombs", "BFurches", "Businessombies", "BWomb", "BWombs", " Bomes", "UBombs", "basm", "Bacteria", "Bomers", "Suborers", "BBouts", "Bones", "GBombs", "bouts", "Phurches", "Bbusters", " Bambers", "baches", "Ambomas", "SBunks", "BBaos", "Bowers", "BBomb", "Balresses", "GBiers", "GBombies", " Bandals", " Bomb", "OBombs", " Brees"], "m": ["mu", "ym", "mr", "v", "e", "am", "im", "l", "mi", "t", "n", "man", "r", "w", "mm", "o", "wm", "g", "semble", "bm", "ms", "module", "h", "s", "rm", "vm", "om", "gm", "y", "hm", "ml", "message", "fm", "machine", "cm", "u", "mc", " M", "b", "p", "sm", "d", "pm", "um", "z", "a", "md", "lin", "mini", "dm", "mos", "em", "form", "f", "ma", "M", "media", "mo"], "x": ["rx", "rex", "v", "xx", "e", "xxxxxxxx", "id", "index", "rax", "code", "l", "t", "n", "tx", "xy", "q", "xi", "event", "fx", "w", "r", "xxxx", "xxx", "on", "co", "X", "h", "ux", "xes", "ex", "xp", "ww", "y", "xc", "xt", "u", "ph", "b", "p", "xf", "cross", "z", "ix", "nex", "ax", "vent", "full", "a", "sex", "xs", "_", "work", "f", "ctx", "XX", "k", "lex", "word"], "lastSkip": [" lastJump", "nextJump", "latestSkip", "lastCopy", "LastHop", "latestCopy", "lastDiff", " LastDiff", "latestHop", "lastJump", "nextskip", "LastCopy", "latestskip", " lastHop", " lastskip", " lastCopy", "LastSkip", "nextCopy", "firstJump", "LastJump", "firstSkip", " lastDiff", " LastCopy", "firstCopy", "nextSkip", "lastHop", "firstskip", " Lastskip", "Lastskip", "lastskip", " LastSkip", "LastDiff"], "i": ["ji", "id", "v", "e", "bi", "ri", "multi", "im", "ip", "l", "mi", "n", "ei", "q", "xi", "yi", "iu", "r", "li", "it", "o", "g", "ti", "ie", "gi", "h", "ir", "qi", "ili", "y", "vi", "si", "I", "eni", "ori", "ni", "ci", "fi", "ini", "u", "ic", "ai", "b", "p", "d", "ani", "z", "ix", "pi", "int", "ij", "a", "iv", "di", "f", "io", "ui"], "j": ["ji", "v", "e", "im", "je", "l", "n", "dj", "ind", "q", "J", "java", "xi", "jit", "r", "w", "li", "jc", "o", "js", "g", "ir", "h", "ie", "oj", "jp", "y", "jl", "job", "ci", "adj", "jo", "u", "b", "p", "jet", "ch", "d", "aj", "z", "ix", "note", "ja", "ij", "a", "k", "f", "uj"], "line": ["liner", "inline", "nc", "ze", "string", "l", "code", "change", "n", "ner", "log", "lc", "ine", "end", "ite", "no", "course", "lace", "store", "li", "nl", "o", "co", "lo", "set", "eline", "lining", "word", "online", "ync", "sync", "cycle", "ino", "lock", "le", "range", "ode", "long", "cm", "mc", "call", "block", "lines", "chain", "lin", "link", "Line", "cell", "cl", "main", "case", "point", "lined", "page"], "c": ["e", "pc", "nc", "unc", "uc", "cat", "cs", "l", "code", "dc", "n", "lc", "ce", "cache", "r", "w", "cu", "ec", "co", "cr", "g", "h", "sc", "cd", "cycle", "out", "ci", "xc", "cm", "mc", "b", "p", "d", "z", "fc", "a", "cc", "cy", "cl", "k", "case", "f", "ac"], "ii": ["ji", "bi", "ri", "ind", "ei", "xi", "li", "II", "iu", "ari", "jc", "uni", "ice", "abi", "ie", "qi", "gi", "sci", "iii", "info", "inf", "jp", "vi", "si", "jl", "ih", "qa", "ski", "iw", "ni", "ci", "fi", "ini", "ai", "ani", "z", "ix", "pi", "ij", "iv", "mini", "di", "zi", "ui"], "jj": ["ji", "Jump", "xx", "ri", "dj", "q", "J", "java", "JJ", "jit", "li", "II", "ki", "JR", "jc", "mm", "III", "ZZ", "yy", "JC", "qi", "gi", "ww", "iii", "Ja", "jump", "bb", "jp", "rc", "CC", "kj", "jl", "gh", "qa", "iw", "ni", "ci", "IJ", "jo", "nn", "NJ", "ai", "aj", "ix", "pi", "aq", "ij", "ja", "cc", "di", "uj"], "vazios": ["vzios", "Vzenos", "Vazio", "vazlos", "vazio", "vzenos", " vazicals", " vaudios", "baudlos", "vasiol", "vazeiol", "vazits", "vazicals", "baudiol", " vaudio", "Vazenos", "vaxios", "vzits", "baudios", "vazeio", "vaslos", "vaudicals", "vazicho", "vaxicho", "vasios", "vachio", "vazeits", "vazixels", "vaudiol", "vzicals", "vaziol", "vzio", "vaudlos", "vaudicho", "bazlos", "vachits", " vaudicho", "vaudios", " vazicho", "Vzits", "Vzio", "bazixels", "vaudixels", "vazelos", "vachenos", "Vzios", " vazio", "baziol", "vazeenos", "vzicho", "baudixels", "vazenos", "vaxicals", " vaudicals", "vachios", "vaudio", "Vazits", "vasixels", "vazeios", "bazios", "vaxio", "vazeixels", "Vazios"]}}
{"code": " \n  \n  \n  class Test(unittest.TestCase):\n  \tdef test_1(self):\n  \t\tself.assertEqual(main(5, 2, 2, [2,1]), 12)\n  \tdef test_2(self):\n  \t\tself.assertEqual(main(5,2,2,[1,2]), 12)\n  \tdef test_3(self):\n  \t\tself.assertEqual(main(3,3,4,[4,1,3,5]), 39)\n  \tdef test_4(self):\n  \t\tself.assertEqual(main(5,2,4,[5, 1, 1, 5]), 51)\n  \n  \n  tCase = int(sys.stdin.readline())\n  \n  def main(A, B, AList, BList):\n  \tresp = 0\n  \tA = A - 1\n  \tB = B - 1\n  \tAlist = AList[A*4:A*4+4]\n  \tBList = BList[B*4:B*4+4]\n  \tcont = 0\n  \tfor aa in Alist:\n  \t\tif aa in BList:\n  \t\t\tresp = aa\n  \t\t\tcont += 1\n  \t\t\n  \tif cont == 1:\n  \t\treturn resp\n  \telif cont == 0:\n  \t\treturn \"Volunteer cheated!\"\n  \telse:\n  \t\treturn \"Bad magician!\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor i in xrange(tCase):\t\n  \t\t\n  \t\tA = [int(x) for x in sys.stdin.readline().split(' ')][0]\n  \t\tNList = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tB = [int(x) for x in sys.stdin.readline().split(' ')][0]\n  \t\tBList = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d: %s\" % (i + 1, main(A, B, NList, BList))\n", "substitutes": {"self": ["worker", "parent", "instance", "e", "utils", "ns", "object", "us", "err", "http", "user", "l", "other", "q", "writer", "server", "cache", "driver", "w", "this", "func", "g", "public", "connection", "Self", "h", "python", "ng", "context", "parser", "app", "host", "py", "full", "client", "now", "k", "cl", "work", "plus", "er", "case", "node", "f", "ctx", "test"], "tCase": ["xTest", "dtcase", " tMode", "testCode", "tcase", "dtTest", "testCase", "dtCase", "TMode", "TCode", "tCode", "xCase", "xcase", " tCode", "tTest", "tMode", "testMode", "TCase", "testcase", "Tcase", " tcase", "TTest"], "A": ["N", "Y", "Ab", "Wa", "T", "AC", "As", "P", "LA", "Ma", "SA", "This", "An", "E", "G", "H", "AU", "W", "CA", "K", "X", "Alpha", "R", "IA", "AA", "Ar", "EA", "API", "I", "Ca", "AR", "D", "F", "Ac", "O", "S", "MA", "HA", "PA", "Am", "C", "AP", "At", "AI", "Z", "V", "a", "mA", "AF", "OA", "Na", "AAA", "M", "GA", "NA", "L", "U"], "B": ["N", "Y", "Ab", "QB", "Be", "T", "Other", "P", "NB", "J", "Both", "BC", "U", "E", "G", " b", "H", "BF", "W", "OB", "K", "X", "BER", "R", "DB", "Q", "LB", "I", "BM", "AR", "D", "F", "BE", "WB", "O", "S", "b", "BI", "C", "IB", "Bs", "BB", "M", "Two", "L", "V"], "AList": ["ALelist", "Palist", "ALists", "ULelist", "ALLists", "Alisted", "ASist", "ULIST", "ALLelist", "Palists", "UListed", "ALLIST", "AListed", "Alists", "Palelist", "ASIST", "AlIST", "ASisted", "UList", "ASists", "ALList", "ALIST", "ULists", "PalIST"], "BList": [" BContent", "LStr", " Blist", "bBase", " BData", "BInfo", "Llist", "BSt", "OStr", "LArray", "RList", "RSt", " BLine", "OBList", "LContent", "YString", "RQueue", "LCode", " BCode", "blist", "BLine", "DString", "VCount", "LData", "BData", "Blist", "OBCode", "NQueue", "BBase", "DList", " BArray", "OContent", "DData", "BContent", "YData", "YList", "BQueue", "BCount", "BCode", "RCount", " BCount", "OLine", "bList", "OBlist", " BStr", " BBase", "LLine", "NSt", "DInfo", "YInfo", "LList", "ACount", " BSt", "OList", "BString", "bCode", "VList", "OBBase", "DArray", " BString", "BStr", " BInfo", "Vlist", " BQueue", "NCount", "DCode", "BArray"], "resp": ["Ret", "par", "Rep", "part", "all", "err", "res", "result", "compl", "report", "count", "cond", "esp", "comp", "na", "r", "REP", "rh", "col", "rec", "ref", "Resp", "RES", "conn", "respons", "coll", "rel", "seq", "nt", "ret", "Rec", "rest", "cmp", "prev", "null", "req", "Response", "p", "CONT", "pos", "response", "rep", "true", "arr", "content", "_", "respond"], "Alist": ["ALists", " ALList", "Allist", "AlList", "Blists", "Blist", "Alisted", "ALlist", "AIST", "AListed", "Alists", " AListed", "BlIST", "AlIST", "Aisted", "Aist", "Alllist", "Allists", "ALList", "ALIST", "Bllist", " ALIST", "AllIST"], "cont": ["requ", "dest", "nc", "ignore", "compl", "code", "lc", "count", "text", "ctr", "comp", "sect", "complete", "catch", "nat", "const", "contin", "path", "conn", "c", "keep", "mult", "progress", "toc", "inf", "nt", "CC", "att", "desc", "lat", " CONT", "rest", "ci", "current", "xt", "cm", "acc", "req", "ext", "Cont", "CONT", "diff", "ont", "contract", "feat", "int", "ct", " Cont", "cc", "dist", "entry", "cur", "content", "common", "inc"], "aa": ["adr", "par", "ea", "uc", "la", "asha", "sa", "aw", "ah", "dc", "ga", "oc", "ca", "ha", "na", "af", "ari", "aaa", "ae", "abc", "c", "aska", "bb", "alpha", "au", "AA", "ana", "xa", "qa", "aaaa", "null", "acc", "ai", "da", "df", "ee", "aea", "doc", "a", "cc", "arr", "account", "ma", "Na", "ac", "ia", "ba", "va", "inc"], "i": ["ait", "opt", "instance", "id", "j", "ii", "code", "ei", "ind", "text", "xi", "gu", "c", " iP", "ti", "ie", "gi", "y", "I", "iw", "num", "ci", "p", "z", "ix", "io"], "x": ["v", "rax", "t", "get", "ux", "en", "xc", "m", "ax", "xs", "sex", "rx", "l", "n", "xy", "xxxx", "X", "xml", "ex", "xp", "num", "xt", "ext", "p", "ix", "vent", "full", "ct", "a", "plus", "ctx", "word", "index", "px", "code", "q", "www", "xi", "na", "event", "any", "ady", "on", "abc", "cgi", "sw", "python", "y", "ci", "u", "plex", "dx", "b", "cross", "d", "mx", "f", "e", "xx", "tx", "fx", "w", "expl", "g", "c", "h", "xes", "ww", "ty", "php", "z", "int", "es", "wx", "work", "lex", "exp"], "NList": [" NData", "NLi", " NSet", "IChain", "NSet", "ZColl", " NZ", " NLoop", "ELoop", " Nlist", "NPercent", "Blist", "Nlist", "ZLIST", "CNList", " NCont", "VChain", "CNLi", "YZ", "ZZ", "NInt", "VList", " NPercent", "ICont", "JList", "YColl", "NZ", "NLoop", "BInt", "IPercent", "NData", "BLi", " NInt", "JSet", "NLIST", " NLIST", "CNInt", "IList", "ESet", "CNlist", "EData", "EList", "VPercent", " NColl", " NLi", "VCont", "NCont", "JData", " NChain", "ZList", "YList", "JLoop", "NChain", "NColl", "YLIST"]}}
{"code": " \n  def debug(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}:\n{}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  def answer_cells(f, X, cells):\n      out = \"Case #{}:\".format(X)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n      for row in cells:\n          out = \"\".join(row)\n          f.write(out)\n          f.write(\"\n\")\n          print(out)\n  \n  def main(inf, outf):\n      T, = read(inf)\n      for casenmbr in range(1, T + 1):\n          R, C, M = read(inf)\n  \n          if M == 0:\n              cells = [['.'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          empty = R * C - M\n  \n          if empty == 1:\n              cells = [['*'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          if R == 1 or C == 1:\n              cells = [['.'] * C for i in range(R)]\n              m = 0\n              for r in range(R):\n                  for c in range(C):\n                      cells[r][c] = '*'\n                      m += 1\n                      if m == M:\n                          break\n                  else:\n                      continue\n                  break\n              cells[-1][-1] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          if empty in (2, 3, 5, 7):\n              answer(outf, casenmbr, \"Impossible\")\n              continue\n  \n          if (R == 2 or C == 2) and empty % 2:\n              answer(outf, casenmbr, \"Impossible\")\n              continue\n  \n          cells = [['*'] * C for i in range(R)]\n  \n  \n          cells[0][0] = 'c'\n          empty -= 1\n          cc = 1\n          rr = 1\n          while empty > 0:\n              if cc < C:\n                  for r in range(rr):\n                      if empty == 2 and r == rr - 1:\n                          break\n                      cells[r][cc] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  cc += 1\n              if rr < R and empty > 0:\n                  for c in range(cc):\n                      if empty == 2 and c == cc - 1:\n                          break\n                      cells[rr][c] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  rr += 1            \n  \n          answer_cells(outf, casenmbr, cells)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n", "substitutes": {"v": ["x", "j", "e", "ii", "volt", "vs", "vv", "l", "vd", "n", "vert", "q", "w", "ven", "ve", "o", "ll", "g", "h", "conv", "nv", "fl", "vi", "y", "lv", "tv", "vp", "uv", "cv", "u", "vor", "ver", "sv", "b", "p", "d", "av", "ch", "z", "vt", "ev", "iv", "k", "ov", "V"], "f": ["x", "part", "e", "fr", "ff", "uf", "rf", "l", "n", "fo", "q", "tf", "fer", "af", "stream", "fx", "w", "fd", "feed", "o", "ref", "path", "g", "bf", "fe", "self", "h", "info", "fit", "s", "conf", "fl", "file", "fw", "fen", "cf", "F", "of", "fm", "fp", "free", "u", "function", "str", "lf", "b", "p", "fs", "xf", "df", "d", "fb", "z", "line", "buff", "fc", "full", "ft", "fac", "form", "sf", "page"], "t": ["tu", "x", "prot", "j", "e", "st", "l", "n", "end", "tf", "table", "text", "mt", "w", "et", "it", "o", "tt", "at", "te", "g", "ut", "pt", "type", "h", "wt", "s", "en", "ta", "y", "ret", "dt", "u", "b", "p", "tp", "d", "ed", "z", "int", "a", "ts", "k", "test"], "X": ["x", "Y", "N", "Text", "P", "H", "G", "XX", "Cross", "W", "XM", "K", "IX", "Sc", "PE", "xml", "Class", "XXX", "TX", "File", "Q", "I", "ID", "D", "F", "XP", " x", "Fe", "S", "UX", "Z", "CL", "String", "XL", "V", "XY", "FF", "Case", "ZX", "Ex", "Cell", "A", "L", "U"], "ans": ["x", "ns", "ann", "cs", "AN", "args", "ace", "features", "Ann", "na", "cas", "An", "ou", "aux", "ants", "cons", "lang", "s", "ins", "anc", "au", "ana", "an", "ci", "con", "ant", "ats", "ai", "S", "plan", "span", "a", "Case", "nan", "ANS", "A", "aff"], "out": ["id", "err", "log", "cin", "filename", "col", "image", "Out", "cn", "tmp", "call", "question", "obj", "bug", "cat", "no", "n", "url", "at", "gin", "ex", "outer", "name", "again", "job", "expression", "password", "ext", "new", "full", "flat", "bin", "word", "prefix", "token", "OUT", "external", "outs", "user", "code", "output", "temp", "init", "update", "input", "inner", "exp", "b", "line", "doc", "plain", "comment", "part", "version", "key", "string", "trial", "cache", "w", "copy", "this", "o", "conn", "article", "msg", "cmd", "sync", "lock", "null", "extra", "int", "option", "wx", "work", "io", "off", "script"], "cells": ["fields", "cats", "players", "col", "settings", "sections", "checks", "cel", "breakers", "ells", " cell", "coll", "sites", "tests", " cases", "plugins", "forms", "events", "types", "cases", "cell", "xs", "content", "chains", "ks", "ches", "comments", "groups", "phones", "apses", "l", "models", "keys", "words", "xml", "codes", "parts", "values", " Cells", "qs", "rows", "items", "xf", "details", "rules", "sheets", "lines", "charges", "flat", "csv", "blocks", "holes", "ces", "cs", "outs", "code", "Cs", "apps", "games", "features", "ell", "files", "classes", "ences", "ci", "letters", "ch", "states", "ls", "reports", "errors", "ples", "frames", "ions", "Cell", "months", "x", "points", "cache", "modules", "orders", "co", "rooms", "books", "objects", "cards", "fs", "pages"], "row": ["bug", "Row", "rown", "ack", "insert", "cs", "pl", "result", "array", "ner", "ro", "q", "w", "ell", "feed", "col", "rec", "board", "co", "list", "sc", "pe", "raw", "fl", "rc", "ow", "uu", "cf", "column", "con", "rows", "tr", "roll", "line", "entry", "arr", "cell", "case", "Cell"], "inf": ["bug", "qq", "tif", "fast", "pl", "ind", "tf", "fin", "feed", "expl", "inter", "init", "xml", "fe", "ins", "info", "cgi", "pattern", "conf", "thin", "img", "fen", "cont", "txt", "inn", "php", "input", "con", "ini", "z", "buff", "small", "cl", "flat", "iter", "Inf", "aff", "inc"], "outf": ["Outf", "infs", "OUTc", "keyfs", "againfe", "upfe", "outfo", "outfen", "listfs", "keyfe", "outputfen", "OUTf", "reqfore", "outc", "againfield", "outfs", "reqfen", "outputfs", "upfs", "connc", "listfore", "Outfs", "cleanf", "OUTfield", "outv", "againc", "Outfile", "againfen", "infile", "againv", "cleanfen", "keyv", "keyf", "OUTfe", "Outfe", "outfe", "againfo", "againfs", "againfore", "OUTfs", "OUTfile", "outfile", "cleanfo", "upf", "connf", "listfen", "reqfs", "againf", "connfen", "cleanfs", "connfe", "outfield", "OUTv", "OUTfen", "listf", "infe", "outputfo", "outfore", "reqf", "upfield", "outputf"], "T": ["N", "Y", "Total", "TN", "P", "TS", "E", "H", "G", "W", "Time", "TC", "Q", "I", "B", "D", "F", "WT", "O", "CT", "S", "TT", "Z", "V", "A", "L", "U"], "casenmbr": ["caseenmbl", "casenymber", "caseenmstr", "casenfbl", "caseenrmbr", "casenmbre", "casennmbre", "casenfmbr", "casenrmstr", "casennmbro", "casencmbr", "casensenmbre", "casencmbl", "casenfmbre", "casenmBR", "casenymgr", "casenymtr", "casenymbr", "casensenmbro", "casenseymber", "caseenmbre", "casensenmbr", "casenmbro", "casensembl", "caseenrmbre", "casenfmBR", "casenrmbro", "casenmbl", "casenseymbre", "casenmmbre", "casenftr", "casencmBR", "caseengmgr", "casengmgr", "casensember", "casensembro", "casennmbr", "casenmmbr", "caseenrmbro", "casensenmBR", "casenseymtr", "caseengmbr", "casenymstr", "casennmber", "casenvbre", "casensenmber", "caseengmstr", "casenfmber", "casengmbr", "casenmmbro", "casenmmBR", "caseenrmbl", "casencmbre", "casensembre", "casennmBR", "casensemBR", "casenmber", "casenrmbl", "casenfbre", "casenfbro", "casenymbre", "casenymbro", "casenvbro", "casennmbl", "casensembr", "casenrmbr", "casencmber", "casensemtr", "casenrmgr", "casenseymbl", "casengmstr", "casenvbr", "casenfbr", "caseenmgr", "casenymbl", "casenmgr", "casenrmbre", "caseengmbro", "casenmstr", "caseenmbro", "casenmtr", "casenseymbr", "caseenmbr", "casengmbro", "casennmtr", "casenvBR"], "R": ["A", "Rh", "N", "Y", "GR", "Rs", "Range", "P", "MR", "RH", "CR", "RT", "Re", "E", "G", "H", "SR", "RM", "W", "RO", "Right", "ER", "Q", "RS", "BR", "Br", "B", "RP", "AR", "D", "F", "RC", "RG", "Ra", "O", "RN", "RL", "S", "RR", "V", "NR", "KR", "L", "Region", "U", "RA"], "C": ["N", "Y", "NC", "CNN", "AC", "P", "VC", "DC", "CM", "CR", "U", "Con", "E", "G", "CE", "H", "W", "COR", "CA", "Co", "Sc", "K", "YC", "CO", "Q", "CC", "I", "B", "KC", "Cu", "D", "F", "Ch", "O", "S", "CL", "Custom", "EC", "MC", "CU", "Cache", "A", "L", "V"], "M": ["Y", "N", "P", "MQ", "MR", "J", "CM", "CR", "MT", "E", "G", "H", "RM", "W", "K", "Mo", "Q", "CC", "I", "B", "MF", "D", "F", "O", "S", "Z", "MC", "V", "A", "L", "U"], "i": ["id", "ui", "ii", "e", "ri", "bi", "l", "phi", "ei", "xi", "li", "iu", "it", "o", "g", "ie", "qi", "I", "ci", "il", "fi", "ini", "u", "ib", "ic", "ai", "b", "p", "pi", "int", "a", "iv", "di", "zi", "io", "ia"], "empty": ["original", "all", "missing", "valid", "e", "ent", "open", "err", "default", "ace", "ce", "bc", "complete", "E", "Size", "body", "space", "ec", "frac", "div", "enc", "toc", "white", "ACE", "fl", "size", "ul", "aut", "Error", "left", "Fl", "oo", " Empty", "NO", "sequence", "breaks", "null", "str", "Z", "ME", "broken", "last", "false", "full", "ol", "error", "Empty", "NULL", "cell", "ANY", "blank", "none", "ac", "never", "test"], "m": ["x", "mu", "ym", "mr", "e", "am", "im", "l", "mi", "n", "man", "mm", "o", "me", "bm", "ms", "rm", "h", "om", "gm", "y", "range", "fm", "cm", "u", "mc", "b", "p", "sm", "d", "z", "tm", "nm", "md", "mini", "dm", "em"], "r": ["j", "e", "fr", "err", "yr", "br", "ru", "l", "n", "ro", "q", "w", "lr", "cr", "ir", "ar", "rc", "sr", "range", "ur", "u", "rs", "tr", "b", "p", "d", "rg", "re", "k", "er", "rn"], "c": ["x", "e", "cat", "l", "code", "n", "lc", "q", "ce", "cu", "col", "co", "cr", "g", "s", "h", "arc", "rc", "cn", "y", "ci", "cm", "u", "mc", "b", "p", "d", "z", "fc", "a", "cl", "k", "ac"]}}
{"code": " \n  def debug(v):\n      pass #print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}: {}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  \n  \n  def main(inf, outf):\n      T, = read(inf)\n      for X in range(1, T + 1):\n          row1, = read(inf)\n          cards1 = tuple(read(inf) for i in range(4))\n          row2, = read(inf)\n          cards2 = tuple(read(inf) for i in range(4))\n  \n          kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\n  \n          if kouho:\n              if len(kouho) == 1:\n                  ans = kouho.pop()\n              else:\n                  ans = \"Bad magician!\"\n          else:\n              ans = \"Volunteer cheated!\"\n  \n          answer(outf, X, ans)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n", "substitutes": {"v": ["x", "j", "e", "vs", "vv", "l", "vd", "n", "end", "vu", "q", "w", "ve", "it", "ou", "g", "ut", "c", " V", "s", "h", "nv", "vi", "y", "lv", "tv", "F", "uv", "u", "m", "sv", "p", "d", "av", "z", "vt", "iv", "k", "V", "test"], "f": ["x", "fn", "e", "fr", "ff", "rf", "uf", "l", "n", "log", "fo", "tf", "af", "stream", "r", "w", "fd", "feed", "o", "path", "bf", "g", "c", "fe", "self", "h", "info", "fl", "file", "fen", "fw", "F", "fi", "fm", "fp", "u", "m", "function", "fed", "b", "fs", "p", "fb", "df", "d", "z", "fc", "a", "form", "io", "sf"], "t": ["x", "all", "j", "e", "l", "n", "tf", "task", "r", "w", "rt", "it", "this", "o", "tt", "at", "g", "ut", " it", "c", "s", "h", "pt", "type", "en", "y", "ta", "dt", "m", "u", "b", "p", "tp", "d", "ed", "z", "int", "a", "ts", "test"], "X": ["x", "Y", "N", "P", "n", "J", "E", "H", "XX", "G", "W", "XM", "Col", "K", "Co", "Out", "XXX", "R", "TX", "Test", "Q", "XT", "row", "I", "B", "ID", "F", "XP", " x", "O", "OX", "S", "UX", "Z", "CL", "C", "XL", "V", "ZX", "Case", "Ex", "_", "xs", "M", "A", "L", "U"], "ans": ["aid", "cus", "ons", "ents", "As", "args", "cas", "ENS", "ants", "nas", "annot", "anc", "ana", "can", "anes", "ant", "plan", "aos", "nan", "cases", "ANS", "XX", "A", "ns", "ann", "ras", "atan", "ars", "aning", "os", "aux", "amps", "ai", "ays", "ani", "ania", "ano", "ean", "han", "ens", "aus", "AN", "eps", "ANN", "na", "lan", "leans", "ain", "NA", "s", "an", "ats", "AT", "ls", "ams", "x", "AS", "CNN", "Ann", "aces", "An", "ins", "ane", "anas", "params", "gan", "au", "S", "anon", "aned", "san", "Na", "anan"], "out": ["prefix", "OUT", "external", "err", "key", "string", "outs", "result", "code", "n", "output", "text", "w", "o", "answer", "at", "cfg", "init", "arg", "Out", "outer", "written", "raw", "name", "cmd", "msg", "again", "str", "write", "ext", "call", "line", "new", "note", "obj", "a", "error", "int", "plain", "comment", "main", "data", "word"], "inf": ["id", "fact", "cli", "log", "fo", "feed", " INF", "ref", "thin", "limit", "inn", "arf", "iter", "example", "instance", "bug", "tif", "fast", "rf", "af", "format", "inter", "frac", "xml", "info", "img", "config", "zip", "xt", " Inf", "zin", "xf", "form", "plus", "aff", "orig", "qq", "fr", "index", "include", "ind", "ine", "www", " expl", "zz", " infinite", "it", "init", "cgi", "fen", "txt", "mind", "inst", "input", "inner", "ini", "ln", "irc", "small", "Inf", "inc", "pl", "tf", "w", "fin", "expl", "fe", "lab", "file", "php", "elf", "limited", "z", "int", "lin", "temp", "exp", "ipl"], "outf": ["Outf", " outc", "infs", "inl", "OUTl", "OUTc", "imagefile", "outere", "outerfer", "outc", "OUTf", "outl", "ine", " outfer", "outfs", " outv", " outl", "outerl", "imagef", "outputfe", "oute", "outputl", "imagev", " outfile", "outv", " outfe", " oute", " outfs", "inv", "OUTfe", "outfe", "Outl", "Outfe", "imagefs", "outfile", "outputfile", "infer", "Outc", "outfer", "outerf", "infe", "infile", "outputf"], "T": ["Y", "N", "TN", "P", "n", "TF", "time", "TS", "H", "W", "Time", "R", "NT", "Q", "I", "B", "D", "F", "WT", "O", "S", "TT", "Z", "C", "length", "V", "M", "A", "L", "U"], "row1": ["col01", "ro1", "row01", "col1", " row01", "ro2", "Row2", "row0", "rows1", " row0", "Row1", "Row0", "rows0", "col2", "ro01", "rows2"], "cards1": ["cuts1", "cutsFirst", "cardsone", "cutsone", " cards0", " cardsOne", "card0", "cardsOne", " cardsFirst", "cardsX", "pieces0", " cardsX", "pieces2", "cardone", "card1", "cardOne", "cutsOne", "pieces1", "cardFirst", "cardsFirst", "card2", "piecesX", " cardsone", "cardX", "cards0"], "i": ["x", "id", "j", "ii", "e", "im", "ip", "l", "n", "ind", "xi", "yi", "iu", "r", "it", "c", "s", "gi", "ir", "ar", "I", "ci", "m", "u", "ai", "p", "pi", "int", "k"], "row2": ["group32", "blocksecond", "Rowsecond", "Row02", "cardTwo", "block02", "rowTwo", "group2", "rowsecond", " row32", "groupsecond", "cardsecond", " rowTwo", "Row2", " rowsecond", "groupTwo", "block2", "row32", " row02", "card2", "row02", "card32"], "cards2": [" cardstwo", "cardtwo", "aystwo", "balls2", "card0", "cards0", "ballstwo", "cards4", "cards62", "ards2", "ays62", "balls0", "ards62", "card1", "rows1", "ays4", "ards4", "cardstwo", "rowstwo", " cards4", "rows0", "card2", "balls1", "ardstwo", " cards62", "rows2", "ays2"], "kouho": [" kouso", "skounbo", "kovfo", "skoufo", "kkeefo", "skouho", " kouko", "skouko", " kouno", " kauso", "khouollo", "kauho", "kougko", "kauko", " koufo", "kaufo", "kounollo", "skaupo", " kauko", "koupo", " kouo", "skoubo", "kouo", " kounfo", "kaupo", "kyouo", "kancelso", "kancelko", "kkeeho", "kougfo", "kouollo", "skounfo", "kounbo", "kovho", "kkeeko", "skauho", "krouso", "kauso", "kougbo", "khoufo", "kouso", "kouko", "kouno", "kounfo", "skounho", "kyouollo", "koufo", "kounpo", "kancelho", "skounko", "kovpo", " kounollo", "kyouho", "kougho", "krouko", " kouollo", "kounko", "khouho", "skaufo", "kyoufo", " kauho", " kounho", "krouho", "koubo", "skoupo", "kounho", "kkeebo", "khouo"], "infname": ["insize", "confname", "confpath", "Infame", "Infname", " infnamed", "tfpath", " infsize", "Infnames", " infpath", "infpath", " infName", "Infsize", "inname", "infnames", " infame", "infsize", "confName", "InfName", "innames", " infnames", "inpath", "tfname", "Infpath", "infnamed", "infName", "tfName", "tfnamed", "confame", "innamed", "infame", "inName"], "outfname": ["outfn", "infilen", "outcfsize", "outcName", "outcfName", "outfnm", "outcfname", "outfsize", "infilename", "outfullName", "outcname", "outcsize", "outcfnm", "outfullname", "infsize", "outfilesize", "outfileName", "outfilename", "infnm", "outfName", "outfilenm", "infileName", "infName", "outfilen", "outcnm", "infilenm", "infn", "infilesize", "outfulln"]}}
{"code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n  \n          R, C, M = [int(x) for x in f.readline().split()]\n          free_spots = R * C - M - 1\n  \n          if M == 0:\n              answer = [[\".\" for x in range(C)] for y in range(R)]\n              answer[0][0] = \"c\"\n          elif R == 1:\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\n          elif C == 1:\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\n              answer = zip(*answer[::-1])\n          elif free_spots >= 3: # and M % R >= 2:\n              answer = [[\"*\" for x in range(C)] for y in range(R)]\n              answer[0][0] = \"c\"\n              answer[0][1] = \".\"\n              answer[1][1] = \".\"\n              answer[1][0] = \".\"\n              free_spots -= 3\n              tr, br, c = 0, 1, 2\n              if c >= C:\n                  tr, br, c = 2, 3, 0\n              for _i in range(free_spots):\n                  if answer[tr][c] == \"*\":\n                      answer[tr][c] = \".\"\n                  elif answer[br][c] == \"*\":\n                      answer[br][c] = \".\"\n                      if c < C-1:\n                          c+=1\n                      else:\n                          tr, br = tr + 2, br + 2\n                          c = 0\n                          if br == R:\n                              br, tr = br-1, tr-1\n                  \n          else:\n              answer = [\"Impossible\",]\n  \n          \n          \n          print (\"Case #\" + str(_t+1) + \":\")\n          for _i in answer:\n              print \"\".join(_i)\n      \n  \n", "substitutes": {"f": ["e", "v", "fr", "ff", "l", "n", "fo", "tf", "af", "stream", "r", "w", "fd", "feed", "o", "bf", "g", "path", "fe", "s", "i", "h", "info", "proc", "file", "fen", "cf", "F", "fi", "handler", "fp", "u", "fed", "b", "p", "fs", "fb", "df", "d", "z", "fc", "a", "form", "io", "sf"], "fn": ["nc", "unc", "l", "fat", "n", "dn", "output", "tn", "fa", "filename", "bn", "r", "fd", "format", "o", "func", "ll", "path", "bf", "wl", "sn", "kn", "name", "fl", "nt", "file", "fen", "txt", "cf", "syn", "F", "fi", "fm", "method", "fp", "function", "ln", "b", "FN", "fs", "fb", "p", "fc", "feat", "full", "form", "fun"], "t": ["v", "e", "T", "l", "n", "tf", "table", "r", "o", "tt", "at", " T", "ti", "type", "i", "wt", "h", "nt", "qt", "tmp", "F", "dt", "tz", "b", "p", "tp", "z", "tm", "int", "ts", "temp"], "_t": ["_b", "_p", "_tip", " _ti", " _b", " _T", "_T", "_test", "_ti"], "R": ["Rh", "TR", "Y", "N", "T", "GR", "Rs", "Range", "P", "RE", "MR", "J", "RH", "CR", "RT", "r", "E", "G", "H", "SR", "RM", "W", "RO", "K", "X", "ER", "Q", "RS", "BR", "I", "B", "D", "F", "RC", "Cr", "S", "Z", "RR", "V", "A", "L", "U", "RA"], "C": ["Y", "N", "NC", "T", "CNN", "P", "ASC", "VC", "CAR", "DC", "CM", "CR", "Cl", "CF", "r", "E", "G", "H", "W", "YC", "K", "X", "CA", "CV", "Q", "CC", "I", "B", "Cu", "D", "F", "CI", "Ch", "CCC", "O", "CT", "S", "Z", "Custom", "CL", "EC", "MC", "V", "CU", "A", "L", "U"], "M": ["Y", "N", "T", "P", "MS", "MR", "MO", "J", "CM", "U", "MT", "r", "E", "G", "H", "MX", "RM", "W", "DM", "AM", "K", "X", "Mo", "Q", "I", "B", "MF", "D", "F", "LM", "MM", "O", "S", "Z", "MC", "A", "L", "V"], "x": ["opt", "rx", "id", "ym", "e", "v", "xx", "index", "xb", "l", "code", "n", "xy", "tx", "ys", "q", "text", "xi", "r", "w", "xxx", "g", "X", "ex", "h", "i", "ux", "yn", "xp", "xes", "python", "inf", "ync", "num", "input", "xc", "xt", "u", "yx", "b", "p", "xf", "cross", "z", "vent", "ax", "full", "wx", "xs", " X", "_", " cx", "work", "k", "lex", "test"], "free_spots": ["free_shot", "free_fops", "free_instarts", "free_SPowers", "free_pots", "free_pota", "free_shans", "free_pot", "free_pasts", "free_splockets", "free_quOTS", "free_spaceots", "free_posaces", "free_paces", "free_spasts", "free_pOTS", "free_instores", "free_SPots", "free_showers", "free_spores", "free_spot", "free_spaces", "free_pores", "free_SPot", "free_fots", "free_Spops", "free_shots", "free_quots", "free_spOTS", "free_instOTS", "free_spops", "free_splots", "free_SpOTS", "free_splops", "free_spans", "free_fot", "free_SPans", "free_splOTS", "free_splot", "free_pockets", "free_posot", "free_splaces", "free_parts", "free_spota", "free_pops", "free_Spots", "free_fasts", "free_splota", "free_spaceOTS", "free_spockets", "free_Spasts", "free_spaceockets", "free_spowers", "free_Spans", "free_sparts", "free_posota", "free_Spowers", "free_posots", "free_quarts", "free_quores", "free_instots", "free_spaceops", "free_Spot"], "answer": ["average", "v", "err", "area", "activity", "complete", " solution", "episode", "reply", "field", "office", "settings", "ae", "term", " answers", "description", "request", "audio", "en", "size", "eni", "swers", "energy", "current", "search", "question", "ee", "content", "example", "video", "attribute", "object", "array", "time", "r", "edge", "format", "round", "ice", "value", "message", "analysis", "urn", "expression", "fee", "response", "new", "fix", "error", "support", "archive", "next", "form", "eden", "number", "word", "result", "address", "information", "output", "ell", "issue", "order", "update", "section", "offer", "python", "cover", "knowledge", "answered", "une", "comment", "equ", "data", "record", "reference", "version", "e", "vote", " Answer", "string", "grade", "score", " explanation", "ace", "cache", "replace", "correct", "after", "article", "Answer", "install", "evidence", "memory", "document", "acket", "results", "z", "entry", "option", "account", "page"], "y": ["Y", "ym", "sy", "yr", "yt", "ys", "n", "q", "yp", "yd", "yi", "ay", "yu", "yy", "yn", "ya", "yl", "py", "my", "p", "gy", "z", "ey", "ye", "dy", "yo", "cy", "oy"], "m": ["mu", "ym", "v", "e", "im", "l", "mi", "n", "man", "r", "mm", "w", "o", "mn", "g", "ms", "h", "i", "om", "ml", "an", "cm", "u", "mc", "b", "p", "pm", "um", "z", "ma"], "tr": ["TR", "Tr", "j", "fr", "uc", "tab", "yr", "ru", "ptr", "bl", "gr", "table", "text", "ctr", "r", " r", "dr", " sr", " TR", "col", "tra", "cr", "div", " Tr", " cr", "h", "kr", "sc", "pt", "wr", "rc", "tc", "row", "BR", "ul", "sr", "cf", "Br", " cur", "track", "ur", "hr", "current", "usr", "cm", "str", "tri", " dr", "ch", "aj", "td", "cur", "arr", "car", "trace", "pr"], "br": ["TR", "j", "mr", "v", "fr", "Tr", "err", "rr", "yr", "bl", "ru", "n", "gr", "oc", "vr", "text", "bc", "r", "w", "rt", "dr", "col", "el", "SR", "ref", "off", "co", "cr", "div", "pt", "h", "i", "kr", "ar", "bar", "arc", "DR", "BR", "Br", "cf", "sr", "ur", "hr", "current", "str", "ver", "b", "p", "ch", "av", "z", "aj", "line", "ab", "cur", "arr", "er", "loc", "pr", "pre", "Cr"], "c": ["e", "v", "nc", "uc", "pc", "unc", "cs", "l", "n", "code", "dc", "count", "lc", "q", "ca", "ce", "oc", "cache", "r", "w", "cu", "col", "o", "ec", "g", "cr", "s", "h", "i", "sc", "coll", "arc", "rc", "cn", "circle", "cf", "ci", "u", "cm", "mc", "vc", "b", "p", "d", "ch", "z", "fc", "cur", "ct", "a", "cc", "cy", "k", "cl", "ac"], "_i": ["_r", " i", " _I", " _ti", " _pi", "_o", " _v", " _o", " pi", "_ip", "_v", " I", "_I", " _ip", "  i", "_pi", "_ti", " _r"]}}
{"code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n          X = int(f.readline())\n          cardsX = [[int(y) for y in f.readline().split()] for x in range(4)]\n          row = cardsX[X-1]\n          Y = int(f.readline())\n          cardsY = [[int(y) for y in f.readline().split()] for x in range(4)]\n          column = cardsY[Y-1]\n          card = [x for x in row if x in column]\n          if len(card) > 1:\n              answer = \"Bad magician!\"\n          elif len(card) == 0:\n              answer = \"Volunteer cheated!\"\n          else:\n              answer = str(card[0])\n          print (\"Case #\" + str(_t+1) + \": \" + answer)\n      \n  \n", "substitutes": {"f": ["e", "fr", "v", "fast", "rf", "l", "n", "fo", "tf", "fer", "fa", "af", "stream", "r", "w", "fd", "fx", "feed", "o", "folder", "bf", "g", "c", "fe", "i", "h", "info", "conf", "inf", "fl", "file", "fw", "fen", "cf", "F", "of", "fp", "u", "m", "lf", "b", "p", "fs", "fb", "df", "d", "z", "line", "buff", "fc", "form", "io", "sf"], "fn": ["unc", "n", "dn", "utf", "output", "fa", "filename", "fd", "format", "o", "func", "ll", "path", "wl", "bf", "sn", "c", "len", "kn", "name", "fl", "file", "fw", "fen", "txt", "syn", "fi", "fil", "method", "fm", "fp", "wn", "source", "function", "lf", "ln", "FN", "p", "fs", "fb", "lib", "fc", "feat", "nm", "full", "loc", "sf", "fun"], "t": ["v", "e", "T", "index", "l", "n", "time", "w", "it", "col", "tt", " T", "c", "s", "type", "i", "h", "pt", "tw", "total", "start", "out", "dt", "m", "b", "p", "d", "z", "length", "int", "ts", "temp", "test"], "_t": ["_n", "_trial", "ift", " _f", "ify", " _y", "_y", "iff", "_v", " _n", "_f", "ifn"], "X": ["N", "Row", "T", "Width", "P", "time", "DC", "U", "E", "H", "W", "Col", "K", "Time", "R", "XXX", "TX", "Q", "D", "F", "O", "TT", "Z", "C", "XL", "length", "XY", "FF", "XX", "ID", "L", "Column", "V", "IP"], "cardsX": ["cardY", "cardsF", "cardC", " cardsx", "cardsC", " cardsXL", " cardsC", "ballsXL", "cardsXL", "linesX", "linesY", "cardXL", "linesx", "cardsx", "cardF", "ballsC", "cardx", "linesF", "ballsX", " cardsF", "cardX"], "y": ["j", "ym", "v", "sy", "e", "sys", "yt", "ky", "ys", "n", "ny", "wy", "q", "vy", "yd", "yi", "ay", "w", "col", "o", "yu", "yy", "c", "s", "type", "i", "h", "yn", "ya", "kit", "ot", "yl", "py", "u", "b", "p", "d", "gy", "z", "ey", "ye", "int", "dy", "yo", "isy", "oy", "k"], "x": ["id", "rx", "xe", "xx", "v", "key", "index", "im", "xb", "px", "l", "code", "n", "tx", "time", "day", "xi", "ox", "ay", "w", "ady", "el", "col", "ross", "on", "oint", "co", "c", "ice", "ex", "h", "i", "ww", "xp", "max", "xa", "num", "yl", "xc", "ci", "xt", "u", "yx", "m", "p", "xf", "cross", "d", "z", "ix", "ax", "int", "ct", "sex", "wx", "_", "word"], "row": ["flow", "Row", "rown", "key", "ack", "index", "patch", "array", "xy", "slice", "ro", "model", "month", "ug", "feed", "col", "order", "offset", "group", "ward", "window", "type", "section", "ow", "range", "view", "rows", "grid", "page", "block", "roll", "ride", "line", "year", "entry", "arrow", "rid", "rot", "cell", "record"], "Y": ["N", "Row", "Value", "T", "P", "J", "vy", "U", "E", "G", "col", "H", "Size", "Col", "W", "Q", "ID", "B", "L", "D", "F", "Type", "S", "Z", "C", "YY", "Day", "year", "XY", "cy", "oy", "A", "Year", "Column", "V", "IP"], "cardsY": ["fieldsF", "cardY", "cardsF", "fieldsY", "cardsPy", "ardsY", "featuresF", " cardsN", "featuresX", "featuresY", " cardsPy", "cardy", "cardN", "fieldsX", "cardF", "cardPy", "featuresy", "cardsN", "ardsPy", "cardsy", "ardsN", "ardsX", "fieldsy", "cardX"], "column": ["key", "index", "category", "slice", "character", "channel", "field", "col", "offset", "group", "width", "header", "collection", "value", "section", "word", "pattern", "letter", "position", "unit", "cycle", "left", "sequence", "grid", "span", "block", "line", "year", "entry", "COL", "axis", "arrow", "int", "ct", "condition", "cell", "number", "Column", "page"], "card": ["bug", "valid", "id", "crit", "draw", "string", "parse", "compl", "array", "carry", "dc", "code", "character", "day", "text", "ce", "event", "post", "field", "ck", "shape", "folder", "match", "c", "center", "list", "request", "arc", "letter", "cont", "cf", "cards", "cmp", "message", "view", "ard", "cm", "Card", "question", "cube", "line", "entry", "note", "check", "fix", "comment", "condition", "cell", "contact", "content", "case", "data", "node", "car", "cart", "char", "word"], "answer": ["average", "err", "aim", " Answer", "string", "ze", "result", "default", "array", "username", "area", "address", "output", "su", "episode", "reply", "ell", "field", "issue", "format", "avoid", "ae", " answers", "description", "value", "Answer", "update", "offer", "name", "reason", "say", "eni", "cover", "knowledge", "evidence", "message", "pole", "question", "vale", "answered", "agree", "response", "option", "error", "fix", "archive", "comment", "next", "blank", "account", "respond", "equ", "example", "word", "test"]}}
{"code": " \n  '''\n  Input\n  The first line of the input gives the number of test cases, T. T lines follow. \n  Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).\n  \n  Output\n  For each test case, output a line containing \"Case #x:\", where x is the test case number. \n  On the following R lines, output the board configuration with C characters per line, \n  using '.' to represent an empty cell, '*' to represent a cell that contains a mine, \n  and 'c' to represent the clicked cell. If there is no possible configuration, \n  then instead of the grid, output a line with \"Impossible\" instead. \n  If there are multiple possible configurations, output any one of them.\n  \n  Limits\n  0 <= M < R * C.\n  \n  Small dataset\n  1 <= T <= 230.\n  1 <= R, C <= 5.\n  \n  Large dataset\n  1 <= T <= 140.\n  1 <= R, C <= 50.\n  \n  Sample\n  ---Input \n  5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \n  ---Output \n  Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  ......*\n  .c....*\n  .......\n  ..*....\n  Case #5:\n  **********\n  **********\n  **********\n  ****....**\n  ***.....**\n  ***.c...**\n  ***....***\n  **********\n  **********\n  **********\n  \n  \n  '''\n  \n  \n  f = open(sys.argv[1])\n  def input(): return f.readline().strip();\n  \n  def genBoards(R, C, M):\n      for mines in combinations( product(range(R), range(C)), M):\n          board = [ ['.'] * C + [''] for _ in range(R) ]\n          for row, col in mines:\n              board[row][col] = '*'\n          yield board + [[''] * (C+1)]\n      pass\n  \n  def oneClickSolution(R, C, M):\n      for bd in genBoards(R, C, M):\n          minTile = 10\n          for r in range(R):\n              for c in range(C):\n                  if bd[r][c] == '.':\n                      n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))\n                      bd[r][c] = `n`\n                      if n <= minTile:\n                          minTile = n\n                          minR, minC = r, c\n          if minTile < 10:\n              queue = [ (minR, minC) ]\n              nOpen = 0\n              while queue:\n                  r,c = queue.pop()\n                  if bd[r][c] == '0':\n                      for i in -1,0,1:\n                          for j in -1,0,1:\n                              if i or j: # we don't add the one we popped back\n                                  queue.append( (r+i, c+j) )\n                  if bd[r][c] not in '.*':\n                      bd[r][c] = '.'\n                      nOpen += 1\n              if M + nOpen == R*C:\n                  bd[minR][minC] = 'c'\n                  return '\n'.join( ''.join(row[:-1]) for row in bd[:-1] )\n  \n      return 'Impossible'\n  \n  \n  clk = clock()\n  \n  for caseNo in xrange(1, int(input())+1):\n      R, C, M = map(int, input().split())\n      print >>sys.stderr, caseNo, R, C, M #, oneClickSolution(R, C, M)<>'Impossible'\n      print 'Case #%d:' % caseNo  \n      print oneClickSolution(R, C, M)\n      \n  print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\n  \n", "substitutes": {"f": ["fn", "v", "fr", "e", "ff", "rf", "l", "t", "fa", "w", "fd", "feed", "o", "g", "fe", "s", "h", "conf", "file", " F", "F", "fi", "fp", "m", "lf", "b", "p", "fs", "fb", "df", "d", "z", "fc", "sf"], "R": ["Rh", "N", "Y", "T", "Rs", "Range", "P", "RE", "MR", "J", "CR", "RH", "RT", "Re", "JR", "E", "G", "H", "SR", "RM", "W", "RO", "K", "X", "Right", "Test", "RW", "Four", "Q", "DR", "RS", "BR", "Br", "I", "B", "AR", "D", "F", "Cr", "RG", "RC", "Ro", "Ra", "O", "RN", "S", "AT", "RR", "V", "NR", "A", "L", "U", "RA"], "C": ["N", "NC", "Y", "SC", "T", "CNN", "AC", "Chain", "The", "Cs", "P", "VC", "DC", "CM", "CR", "Cl", "course", "E", "G", "H", "CE", "Size", "W", "YC", "CA", "X", "Three", "K", "JC", "Sc", "CV", "CC", "size", "CS", "I", "Cu", "Ca", "B", "KC", "D", "CI", "F", "Cr", "custom", "RC", "Ch", "six", "CCC", "O", "CT", "CP", "S", "Custom", "CL", "EC", "MC", "V", "Case", "CU", "case", "CN", "A", "L", "U"], "M": [" N", "N", "Y", "T", " m", "FM", "P", "MS", "MOD", "multiple", "MR", "MO", "CM", "VM", "MT", "E", "G", "H", "MI", "MX", "RM", "W", "DM", "AM", "X", "NM", "Q", "ARM", "TM", "Matrix", "I", "B", "OM", "MF", "Model", "D", "F", "MB", "LM", "MM", "m", "O", "S", "MA", "MN", "ME", "MC", "V", "IM", "A", "L", "U"], "mines": ["Minese", "Mined", "Minions", "minions", "minxes", "mixions", "minsed", "mixest", "minsES", "minese", "minses", "minsions", " minxes", "mined", "Mines", "minsxes", "minsese", "minest", "Minest", "minsest", " minES", "Minxes", " mined", "mixese", "mixes", "minES", "MinES"], "board": ["flow", "game", "bug", "pad", "deck", "book", "ack", "draw", "lane", "chart", "play", "card", "control", "core", "student", "table", "bo", "bc", "course", "stream", "channel", "feed", "o", "square", "round", "stroke", "flo", "Board", "ward", "bar", "coll", "audio", "loop", "ad", "anks", "out", "console", "sequence", "custom", "rows", "phone", "hole", "panel", "layout", "p", "box", "block", "screen", "boarding", "line", "boards", "entry", "cc", "room", "player", "form", "case", "cell", "cart", "bank", "word"], "_": ["x", "ip", "code", "oc", "g", "val", "out", "p", "block", "cc", "k", "ac"], "row": ["flow", "x", "bug", "id", "Row", "ack", "index", "ro", "w", "feed", "order", "o", "ward", "round", "co", "bar", "sc", "coll", "rc", "ow", "num", "range", "rows", "tr", "ver", "roll", "block", "box", "line", "entry", "cell", "k", "case", "rank"], "col": ["x", "ail", "cat", "l", "ind", "count", "act", "Col", "ref", "co", "flo", "div", "cr", "coll", "fl", "y", "unit", "num", "column", "yl", "il", "p", "box", "ch", "pos", "COL", "chain", "ct", "cell", "k", "loc", "ac", "pr"], "bd": ["cb", "pad", "ud", "deck", "bi", "bow", "bot", "bl", "dc", "vd", "zb", "bc", "bo", "gd", "nb", "kk", "fd", "ande", "ck", "ld", "cdn", "pd", "bf", "bm", "cd", "bind", "bs", "BD", "bb", "sb", "ad", "dan", "nd", "bid", " kb", "dd", "sd", "wb", "b", "d", " dock", "ed", "td", "hd", "gb", "md", "ide", "de", "bin", "ba", "db"], "minTile": ["MINWidth", "allimize", "cutWidth", "cutES", "allES", "partialBlocks", "allBlocks", "partialWidth", "MINBlocks", "MINES", "partialES", "cutimize", "MINimize", "partialimize", "allWidth", "cutBlocks"], "r": ["x", "id", "v", "e", "br", "l", "ru", "ro", "q", "run", "right", "w", "rh", "cr", "ir", "h", "kr", "nr", "rc", "sr", "range", "ur", "m", "rb", "u", "rs", "b", "p", "rg", "chain", "rect", "k", "re", "er", "rn"], "c": ["x", "e", "v", "nc", "cs", "l", "t", "code", "dc", "lc", "q", "DC", "ca", "w", "cu", "o", "rec", "g", "h", "cd", "rc", "CC", "cn", "y", "config", "cf", "ci", "m", "cm", "u", "b", "p", "d", "ch", "z", "a", "ct", "cc", "cl", "k", "content", "case", "ac"], "n": [" N", "N", "e", "ns", "nc", "np", "l", "t", "count", "nb", "w", "net", "o", "g", "s", "sum", "num", "u", "b", "p", "nu", "d", "z", "ne", "nan", "k"], "i": ["ji", "x", "id", "ii", "v", "e", "ri", "ip", "l", "ind", "xi", "li", "iu", "it", "h", "chi", "gi", "y", "I", "ci", "il", "u", "m", "ai", "b", "p", "d", "z", "pi", "int", "ij", "a", "isin", "di", "k", "io", "ui"], "j": ["ji", "v", "ii", "e", "l", "q", "J", "jj", "li", "o", "js", "g", "h", "jp", "kj", "y", "jl", "u", "b", "p", "ch", "d", "z", "ij", "k"]}}
{"code": " \n  '''\n  ---Input \n  3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \n  ---Output \n  Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  '''\n  \n  \n  \n  \n  \n  f = open(sys.argv[1])\n  def input(): return f.readline().strip();\n  \n         \n  \n  \n  for caseNo in xrange(1, int(input())+1):\n      row_no = int(input())\n      for i in 1,2,3,4:\n          row = input()\n          if i == row_no:\n              nums = set(row.split())\n              \n      row_no = int(input())\n      for i in 1,2,3,4:\n          row = input()\n          if i == row_no:\n              nums &= set(row.split())\n  \n      if not nums:\n          res = 'Volunteer cheated!'\n      elif len(nums) > 1:\n          res = 'Bad magician!'        \n      else:\n          res = nums.pop()\n      print 'Case #%d:' % caseNo, res\n      \n  \n", "substitutes": {"f": ["x", "e", "v", "ff", "rf", "l", "t", "fo", "tf", "fa", "af", "r", "w", "fd", "feed", "ref", "bf", "c", "s", "h", "info", "file", "raf", "input", "F", "handler", "fp", "m", "lf", "b", "p", "fs", "fb", "df", "d", "a", "io", "ef"], "caseNo": ["caseno", "blockNo", "bugName", "CaseNum", "Caseno", " caseCode", "blockNO", "caseNum", "classNum", "blockNum", " caseno", "bugCode", "className", "caseCode", "CaseNo", "CaseNO", "bugNum", "classNo", " caseNum", "blockno", "bugNo", " caseNO", "caseName", "caseNO", " caseName", "classCode"], "row_no": ["cell_do", "row__start", "rowPnum", " row_n", "row2do", "row_num", "rows_len", "row_n", "cell_no", "row_len", "row2lo", "row__No", "row64no", " row_start", "rowPnumber", "row__n", "row2no", "rows_num", "row_number", " row_No", "row_start", "cell_lo", "row_part", "row64num", "row__part", "cell_part", "rowPno", "row__do", "row__no", "row2part", "rows_number", "row__lo", "row64len", "row_lo", "row64number", "rows_no", "row_do", "row_No", "rowPlen"], "i": ["x", "id", "j", "e", "ii", "v", "ri", "ip", "l", "n", "ind", "xi", "li", "iu", "r", "it", "col", "o", "c", "ti", "ie", "s", "info", "qi", "si", "y", "I", "iw", "ori", "uri", "ni", "ci", "ini", "iq", "m", "u", "ic", "ai", "p", "d", "z", "pi", "int", "a", "di", "k", "io", "ia", "ui"], "row": ["bug", "id", "Row", "rr", "key", "uc", "sel", "query", "ip", "result", "array", "ack", "ro", "server", "ok", "month", "r", "pub", "feed", "col", "where", "order", "group", "ward", "sc", "ows", "word", "sum", "raw", "reader", "way", "rc", "ow", "uu", "we", "range", "input", "view", "rows", "ry", "tr", "grid", "frame", "block", "box", "line", "entry", "cur", "error", "cell", "re", "data", "rank", "page"], "nums": ["nanums", "numbers", "nanoms", "coms", "numer", "cames", "cumbers", "rnumbers", "pums", "neum", "Names", "Nodes", "cum", " noms", "neumer", "Num", "nems", " nodes", "Numbers", " nems", "noms", "pems", "cums", "rnoms", "Numes", "pubs", "neums", "nodes", "nanems", "nanumes", "rnums", "numes", " nubs", "pumbers", "num", " names", "Numer", "nanubs", "Noms", "nanames", " numes", "rnames", "nubs", "nanodes", " numbers", "names", "cumer", "neumbers", "Nums", "nanumbers"], "res": ["sys", "rr", "err", "rss", "result", "ras", "our", "report", "changes", "gr", "right", "pres", "r", "col", "rec", "func", "RES", "rez", "ms", "rel", "rev", "ress", "msg", "rc", "ret", "reg", "rest", "rus", "req", "str", "rs", "resolution", "reset", "grid", "details", "results", "response", "rep", "rem", "Res", "error", "re", "resp"]}}
{"code": "t = int(input())\n  \n  VIDE = 0\n  MINE = 1\n  CURSEUR = 2\n  \n  def test_position(arr, lignes, cols, y, x):\n      def voisinage_libre(arr, y, x):\n          if y > 0:\n              if x > 0 and arr[y-1][x-1] == MINE:\n                  return False\n              if arr[y-1][x] == MINE:\n                  return False\n              if x < cols - 1 and arr[y-1][x+1] == MINE:\n                  return False\n  \n          if x > 0 and arr[y][x-1] == MINE:\n              return False\n          if x < cols - 1 and arr[y][x+1] == MINE:\n              return False\n  \n          if y < lignes - 1:\n              if x > 0 and arr[y+1][x-1] == MINE:\n                  return False\n              if arr[y+1][x] == MINE:\n                  return False\n              if x < cols - 1 and arr[y+1][x+1] == MINE:\n                  return False\n  \n          return True\n  \n      def remplissage_rec(arr, y, x):\n          if x < 0 or y < 0 or x >= cols or y >= lignes:\n              return\n          elif arr[y][x] == CURSEUR:\n              return\n  \n          arr[y][x] = CURSEUR\n          if voisinage_libre(arr, y, x):\n              remplissage_rec(arr, y-1, x-1)\n              remplissage_rec(arr, y-1, x)\n              remplissage_rec(arr, y-1, x+1)\n              remplissage_rec(arr, y, x-1)\n              remplissage_rec(arr, y, x+1)\n              remplissage_rec(arr, y+1, x-1)\n              remplissage_rec(arr, y+1, x)\n              remplissage_rec(arr, y+1, x+1)\n  \n      if arr[y][x] != VIDE:\n          return False\n  \n      arr2 = [ [ arr[i][j] for j in range(0, cols) ] for i in range(0, lignes) ]\n  \n      remplissage_rec(arr2, y, x)\n  \n      for i in range(0, lignes):\n          for j in range(0, cols):\n              if arr2[i][j] == VIDE:\n                  return False\n      return True\n  \n  def dfs(arr, lignes, cols, mines, y, x):\n      cases_restantes = (cols - x) + ((lignes - y) * cols)\n  \n      if cases_restantes < mines:\n          return None\n      elif mines <= 0:\n          for i in range(0, lignes):\n              for j in range(0, cols):\n                  if test_position(arr, lignes, cols, i, j):\n                      return (i, j)\n      elif x >= cols:\n          return dfs(arr, lignes, cols, mines, y+1, 0)\n      elif y >= lignes:\n          return None\n      else:\n          res = dfs(arr, lignes, cols, mines, y, x+1)\n          if res != None:\n              return res\n  \n          arr[y][x] = MINE\n          res = dfs(arr, lignes, cols, mines-1, y, x+1)\n          if res != None:\n              return res\n  \n          arr[y][x] = VIDE\n          return None\n  \n  for i in range(0, t):\n      ligne  = input().split(\" \")\n      lignes = int(ligne[0])\n      cols   = int(ligne[1])\n      mines  = int(ligne[2])\n  \n      arr = [ [VIDE] * cols for _ in range(0, lignes) ]\n  \n      res = dfs(arr, lignes, cols, mines, 0, 0)\n  \n      print (\"Case #\"+str(i+1)+\":\")\n  \n      if res == None:\n          print (\"Impossible\")\n      else:\n          (y, x) = res\n  \n          for i in range(0, lignes):\n              for j in range(0, cols):\n                  if i == y and j == x:\n                      print('c', end='')\n                  elif arr[i][j] == VIDE:\n                      print('.', end='')\n                  else:\n                      print('*', end='')\n  \n              print('', end='\n')\n", "substitutes": {"t": ["all", "T", "n", "table", "w", "it", "o", " T", "g", "c", "ti", "type", "bit", "total", "ta", "num", "xt", "m", "u", "ext", "b", "tp", "p", "d", "a", "ts", "f"], "VIDE": ["VPEA", "VIDEA", "VENe", " VIDe", "VENE", "VPe", "VIDF", "VISe", "VISE", "VIDe", " VIDENCE", "VENEA", "VDF", "VDEA", "VPE", "VDe", " VIDEA", "VPF", "VENF", "VDE", "VISENCE", "VENENCE", "VISEA", "VIDENCE"], "MINE": ["Fine", " Mine", "Nine", "mine", "UNined", "FMining", "Mined", "HINE", "UNining", "mISC", "HISC", "MAining", "Nina", "REMined", "FMined", " Minite", "Hine", "MME", "REMine", "Mina", "VINE", "mINE", "UNINE", " Mina", " Mining", "MKE", "Hining", "Mining", "MAINE", " Mined", "Vine", "FMINE", " MME", "MISC", "JINE", "mined", "REMINE", "NINE", "FMine", "Vined", "Pine", "FKE", "Hined", "NKE", "Nining", "FINE", "VME", "MAined", "Pined", "Jine", "FISC", "Nined", "Fined", "Fining", "PINE", "Pining", "MAine", "Mine", "REMME", "JKE", "Pinite", "Minite", " MKE", "Vining", "Jining", "FMKE", "UNine", "Vina", "Vinite"], "CURSEUR": ["CURSur", "CURseVER", "CURRseIR", "CURTEURR", "CURSECVER", "CURSIARCH", "CURSURR", "CURRseVER", "CURTEUR", "CURseur", "CURSEURR", "CURSIur", "CRCSEur", "CURRSEVER", "CURSECUR", "CRCSEARCH", "CURSECIR", "CRCSEUR", "CRCseUL", "CURSEIR", "CURRseURR", "CURSARCH", "CURRseUR", "CURRseur", "CURSECur", "CURRSEUL", "CURSEur", "CURSEUL", "CURRseUL", "CURSIUR", "CURRSEur", "CURSEARCH", "CURSIVER", "CURTEur", "CURRSEUR", "CURSIIR", "CURseIR", "CURSUL", "CURRSEIR", "CURSIUL", "CURTEUL", "CRCseur", "CURSUR", "CURseARCH", "CURseUR", "CRCSEUL", "CURRSEURR", "CRCseUR", "CURseURR", "CRCseARCH", "CURSEVER", "CURseUL"], "arr": ["err", "gr", "ay", "dr", "arp", "align", "div", "ir", "coll", "arc", "lat", "app", "ab", "rep", "feat", "obj", "mk", "par", "ray", "ann", "cat", "array", "bl", "aug", "r", "aaa", "dat", "frac", "xml", "list", "aa", "bb", "Ar", "att", "img", "abs", "az", "str", "ext", "arrow", "archive", "car", "fr", "rr", "arb", "ind", "el", "order", "abc", "dict", "bar", "ar", "enc", "adv", "war", "inst", "art", "hr", "rb", "acc", "rs", "tr", "plot", "aj", "air", "data", "var", "adr", "yr", "br", "cache", "yy", "batch", "attr", "arch", "au", "arm", "req", "av", "z", "int", "work", "test"], "lignes": ["lignses", "lignumes", "lignings", "ligns", "lIGNumes", " lignings", "eligningses", "eligns", " ligninges", "lignions", "Ligns", "Lignuses", "lignmentuses", "ligningues", " ligningues", "elignses", "elignings", "lIGNines", "Lignments", "lucs", "eligningions", "lIGNues", "elignions", " ligningines", "lgnions", "lignmentumes", "Lignumes", "lignmentines", "linalses", " lucses", "lignments", "lignines", "lignues", "linalues", "elignes", "lignmentions", "Lignmentes", " ligns", " lignines", "linales", "lucues", "lances", "lancses", "lancues", "ligningions", " lucues", "luces", "lgnes", "ligningines", "lancs", "lignmentues", "lignmentses", " lucs", " lignses", " lignues", "lucses", "Lignes", " luces", "lignmentes", "eligninges", "lIGNs", "ligningses", "lignuses", "ligninguses", "ligningumes", "Lignmentuses", "lIGNuses", "Lignmentumes", "lgns", "linals", "lgnses", "lIGNes", "ligninges"], "cols": ["columnabs", "colss", "colless", "Colals", " colless", "velless", " colss", "colsi", "Colabs", "llss", " colts", "lls", "Cols", "columnlines", " colses", "cold", "COLes", "columnes", "Cold", " colops", " cold", "velts", "lld", "columnsi", "COLn", "COLns", "Colses", "columnn", "Colops", "Colss", "lles", "llops", "columnts", "columnless", "Coln", "columns", " coles", "colals", "llses", "COLs", "colops", "Colns", " colals", "colabs", "colses", "velsi", " colabs", " colns", "Coles", "coles", "llals", "coln", "collines", "vels", "colns", " collines", " coln", "Collines", "colts", " colsi"], "y": ["id", "sy", "sys", "vy", "ay", "yah", "yn", "arty", "m", "gy", "auto", "idy", "hy", "Y", "ym", "ky", "ys", "xy", "n", "wy", "sky", "yd", "yu", "ie", "say", "out", "my", "ry", "zy", "p", "fy", "ix", "ye", "yt", "yi", "any", "ady", "asy", "type", "bar", "ya", "iy", "python", "ery", "yl", "py", "u", "yes", "b", "ch", "acy", "uy", "oy", "f", "e", "key", "yr", "ny", "yan", "o", "yang", "yy", "c", "by", "h", "ty", "base", "z", "ey", "year", "dy", "cy", "yo", "isy"], "x": ["id", "v", "ay", "image", "en", "alpha", "size", "xc", "m", "yx", "gy", "ax", "xs", "sex", "content", "k", "hy", "rx", "Y", "im", "l", "no", "n", "xy", "time", "r", "xxx", "at", "one", "X", "xml", "ex", "bit", "xp", "name", "high", "xa", "large", "my", "xt", "ext", "p", "xf", "ix", "full", "ye", "a", "ct", "wa", "index", "px", "code", "q", "day", "xi", "event", "na", "any", "ady", "el", "shape", "s", "type", "pe", "ya", "python", "host", "yl", "view", "long", "u", "yes", "b", "dx", "cross", "d", "f", "data", "xe", "xx", "e", "key", "tx", "fx", "w", "width", "g", "c", "by", "h", "xes", "php", "z", "ey", "int", "dy", "wx", "work", "lex", "page"], "arr2": ["arr0", "str3", "array0", "array4", " arr0", "array2", " arr3", "str1", "array1", "array3", " arr4", " arr1", "arr3", "array\n", "str2", "arr4", "arc\n", "arc0", "arr1", "str4"], "i": ["ji", "id", "v", "e", "ii", "index", "l", "n", "xi", "yi", "li", "iu", "o", "c", " ii", "h", "ie", "jp", "si", "I", "u", "m", "ai", "b", "p", "d", "z", "ij", "di", "k", "f"], "j": ["ji", "v", "ii", "e", " k", "je", "l", "n", "q", "J", "jj", "xi", "li", "jc", "o", "js", "c", " jo", " ii", "ie", "h", "oj", "jp", "kj", "jl", " J", "ci", "adj", "jo", "b", "p", "d", "z", "ix", " il", "ij", "ja", "k", "f", "uj"]}}
{"code": " \n  \n  data Test = Test {\n        choix1 :: Int\n      , table1 :: [[Int]]\n      , choix2 :: Int\n      , table2 :: [[Int]]\n      } deriving Show\n  \n  data Solution = Bonne Int | BadMag | Cheat\n  \n  instance Show Solution where\n      show (Bonne i) = show i\n      show BadMag    = \"Bad magician!\"\n      show Cheat     = \"Volunteer cheated!\"\n  \n  main = do\n      interact (unlines . map showCase . zip [1..] . map (resoudre) . goTest . tail . lines)\n  \n    where\n      goTest [] = []\n      goTest ls =\n          let (c1, t1, ls')  = goTable ls\n              (c2, t2, ls'') = goTable ls'\n          in Test c1 t1 c2 t2 : goTest ls''\n  \n      goTable (n:ls) =\n          let c = read n\n              (t, ls') = splitAt 4 ls\n          in (c, map goLigne t, ls')\n  \n      goLigne = map read . words\n  \n      showCase :: (Int, Solution) -> String\n      showCase (i, s) = printf \"Case #%d: %s\" i (show s)\n  \n  resoudre :: Test -> Solution\n  resoudre Test {..} =\n      let choisis1 = table1 !! (choix1 - 1)\n          choisis2 = table2 !! (choix2 - 1)\n          communs  = filter (`elem` choisis1) choisis2\n      in case communs of\n          [x]     -> Bonne x\n          (_:_:_) -> BadMag\n          []      -> Cheat\n", "substitutes": {"Test": ["Example", "Rule", "Table", "Value", "Lie", "T", "Script", "Runner", "Text", "Beta", "Result", "All", "The", "Index", "Setup", "Rest", "Success", "Question", "App", "Path", "Data", "Title", "Reader", "Testing", "Loop", "Temp", "Version", "Edit", "Unit", "Fix", "Fit", "Class", "Time", "X", "Course", "Train", "Match", "Exception", "File", "Use", "Of", "Split", "Check", "Model", " test", "Search", "Sub", "Lib", "Type", "Ch", "Response", "Step", "Fixed", "String", "Stage", "Server", "Case", "Try", "Empty", "Report", "Base", "Config", "Name", "If", "Sample", "Code", "Info", "Feature", "LT", "test"], "Solution": ["Game", "Long", "Problem", "Y", "N", "Correction", "Location", "Result", "iment", "Setup", "Site", "Success", "olutions", "Data", "ation", "Plot", " solution", "Sol", "Section", "olution", "ve", "Entry", "Sat", "Num", "Version", "Nice", "Resp", "Time", "Course", "Answer", "Object", "CV", "Package", "File", "Choice", "Exception", "Array", "Matrix", "Model", "Error", "Done", "Integer", "Conclusion", "Response", " solutions", "Station", "Step", "Hash", "S", "Fixed", "Details", "String", "Results", "Server", "XY", "Part", "olve", "Str", "Report", "Set", "Sample", "Code", "Sim", "ID", "Description"], "BadMag": ["GoodMAG", "badMag", "BadMAG", " BadAge", "BadAge", "BugAge", " BadMagic", "badMAG", "ErrorMagic", "ErrorMag", "badAge", " badmag", " BadMAG", "GoodMagic", " Badmag", "BugMAG", "ErrorMAG", "Goodmag", " badMag", "GoodMag", " badMagic", "badMagic", " badMAG", "BugMag", "Badmag", "BadMagic"], "Cheat": ["Quats", "Guar", " Cheap", "CheAT", " Chead", "Chat", "cheat", "Cheap", "Quad", "chead", "GuAT", "Chats", "cheap", " Cheash", "Chear", "Guat", "Chead", " Cheats", "cheAT", " CheAT", " cheat", " Chear", "Cheash", "Cheats", "Guash", "cheats", "Chad", "Chap", "Quat", " cheats", "Quap", "cheash", " cheap", " chead", "chear"], "main": ["x", "id", "j", "gui", "root", "result", "Result", "exit", "run", "output", "module", "src", "mult", "section", "Train", "ng", "loop", "m", "p", "Main", "plot", "results", "doc", "obj", "next", "example", "script", " Main"], "goTest": ["coServer", "GoSample", " goSample", "coT", "goSample", "goneTest", " goTesting", "GoTable", "goT", "coTable", "coSample", "goTesting", "GOTable", "coTest", "GOTesting", "goBase", "goneSample", "GoServer", "coTesting", "goTable", "goneTesting", "GOTest", " goTable", " goBase", "GoT", "GoTesting", "goServer", "GOBase", "GOSample", " goServer", "GoTest", "GoBase", " goT"]}}
{"code": "def get_a(r, c, f='.'):\n      A = []\n      for i in xrange(r):\n          A.append([f] * c)\n      return A\n  \n  \n  def apply(A, r, c, B):\n      for i, b in enumerate(B):\n          for j, v in enumerate(b):\n              A[r + i][c + j] = v\n  \n  \n  def draw(A):\n      if A is None:\n          return '\nImpossible'\n      res = ['']\n      for a in A:\n          res.append(''.join(a))\n      return '\n'.join(res)\n  \n  \n  def trans(A):\n      if not A:\n          return None\n      B = get_a(len(A[0]), len(A))\n      for i, a in enumerate(A):\n          for j, v in enumerate(a):\n              B[j][i] = v\n      return B\n  \n  \n  def check(A, m, r, c):\n      if A is None:\n          return True\n      cnts = {'c': 0, '*': 0, '.': 0}\n  \n      assert len(A) == r\n      for i in xrange(r):\n          assert len(A[i]) == c\n          for j in xrange(c):\n              cnts[A[i][j]] += 1\n      assert cnts['*'] == m\n      assert cnts['c'] == 1\n      assert cnts['.'] == r * c - m - 1\n  \n  \n  def CASE(IN):\n      def rstr():\n          return IN.readline().strip()\n  \n      def rint():\n          return int(rstr())\n  \n      def rints():\n          return map(int, rstr().split())\n      r, c, m = rints()\n      A = solve(m, r, c)\n      if A:\n          A[-1][-1] = 'c'\n      check(A, m, r, c)\n      return draw(A)\n  \n  \n  def solve(m, r, c):\n      if r > c:\n          return trans(solve(m, c, r))\n      assert r <= c\n      assert m != r * c\n      e = r * c - m\n      if e == 1:\n          A = get_a(r, c, '*')\n          return A\n      if r == 1:\n          A = get_a(1, c, '.')\n          for i in xrange(m):\n              A[0][i] = '*'\n          return A\n      if r == 2:\n          if e == 2 or e % 2 == 1:\n              return None\n          A = get_a(2, c, '.')\n          assert m % 2 == 0\n          for i in xrange(m / 2):\n              A[0][i] = A[1][i] = '*'\n          return A\n      assert r >= 3\n      A = get_a(r, c, '*')\n      if e in (2, 3, 5, 7):\n          return None\n      E = [c] * (e / c) + ([e % c] if e % c else [])\n      if sum(E) < e:\n          E.append(e % c)\n          assert sum(E) == e\n      if len(E) == 1:\n          E = [e / 2] * 2\n          if sum(E) < e:\n              e.append(1)\n      if E[0] != E[1]:\n          s = sum(E[:2])\n          E[0] = E[1] = s / 2\n          if sum(E[:2]) != s:\n              assert len(E) == 2\n              E.append(1)\n      if E[-1] == 1:\n          if len(E) > 3:\n              E[-2] -= 1\n              E[-1] += 1\n          else:\n              E[0] -= 1\n              E[1] -= 1\n              E[2] += 2\n      for i in xrange(len(E)):\n          for j in xrange(E[i]):\n              A[-i - 1][-j - 1] = '.'\n      return A\n  \n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1, t + 1):\n          OUT.write(\"Case #%i: %s\n\" % (i, CASE(IN)))\n  \n  if __name__ == \"__main__\":\n      RUN(sys.stdin, sys.stdout)\n", "substitutes": {"r": ["x", "mr", "fr", "rr", "err", "yr", "Rs", "l", "ru", "n", "ro", "end", "rd", "q", "w", "dr", "rh", "o", "g", "cr", "rm", "ir", "h", "R", "ar", "nr", "rc", "sr", "rl", "range", "pr", "ur", "u", "rb", "rs", "tr", "ra", "p", "d", "z", "rg", "cur", "re", "k", "er"], "c": ["x", "nc", "pc", "cs", "l", "n", "dc", "lc", "count", "q", "ce", "w", "cu", "jc", "col", "o", "rec", "ec", "co", "cr", "g", "h", "sc", "rc", "y", "cf", "ci", "xc", "con", "can", "u", "cm", "mc", "p", "d", "C", "ch", "z", "fc", "cc", "cy", "k", "cp", "ac"], "f": ["fold", "x", "fr", "ff", "rf", "l", "q", "fa", "af", "fx", "field", "feed", "bf", "g", "fe", "h", "fl", "cf", "F", "fi", "fm", "of", "fp", "u", "fs", "p", "fb", "df", "d", "fc", "form", "ef", "sf", "fun"], "A": ["Ab", "Wa", "T", "Product", "As", "P", "Parts", "This", "G", "Content", "AM", "System", "Art", "alpha", "Ac", "Az", "O", "PA", "At", "C", "Ha", "OA", "L", "Y", "AC", "Result", "array", "Ma", "Input", "Order", "Data", "Min", "X", "Alpha", "Adam", "Ar", "API", "Auth", "Error", "Average", "D", "HA", "p", "Ant", "Action", "mA", "_", "Ca", "Am", "V", "all", "AV", "All", "LA", "Entry", "H", "R", "ar", "AA", "I", "MA", "Gener", "New", "d", "Empty", "If", "data", "Any", "Mult", "First", "RA", "N", "AS", "Args", "ap", "The", "end", "App", "An", "And", "AU", "W", "CA", "K", "g", "There", "Ad", "Q", "Array", "AD", "F", "S", "AP", "Res", "AF", "Instance", "Ap", "Act", "Code", "M", "GA", "AR", "NA", "General", "U"], "i": ["x", "id", "ui", "ii", "bi", "ri", "index", "im", "ip", "l", "n", "ind", "xi", "yi", "iu", "li", "it", "o", "g", "ti", "ie", "h", "gi", "si", "y", "I", "ori", "ni", "ci", "ini", "u", "ai", "p", "d", "z", "pi", "int", "di", "k", "zi", "io"], "B": ["Y", "N", "Other", "Ab", "BA", "T", "P", "NB", "J", "BC", "H", "G", "BL", "W", "K", "X", "CB", "R", "Q", "AA", "I", "BM", "AB", "D", "F", "MB", "O", "WB", "S", "Z", "BI", "C", "V", "Bs", "BB", "M", "L", "U"], "b": ["x", "l", "br", "n", "nb", "w", "un", "o", "g", "h", "bs", "sb", "y", "u", "base", "p", "d", "z", "ab", "k", "BB"], "j": ["ji", "x", "ii", "key", "im", "br", "l", "n", "ind", "q", "J", "jj", "li", "jc", "o", "js", "g", "ie", "h", "oj", "jp", "y", "jl", "si", "jo", "u", "str", "p", "d", "ch", "aj", "z", "int", "ja", "ij", "k", "_", "uj"], "v": ["x", "vs", "vv", "l", "n", "q", "w", "ve", "o", "g", "value", "h", "conv", "nv", "y", "vi", "lv", "uv", "u", "ver", "sv", "p", "d", "av", "z", "k", "va", "V"], "res": ["ps", "remote", "blocks", "ons", "err", "Rs", "result", "Result", "ras", "RE", "gr", "args", "right", "pres", "os", "rh", " results", "RES", "ms", "R", "bs", "values", "rev", "rap", "ress", "RS", "breaks", "rs", "resolution", "relations", "p", "powers", "details", "results", "response", "Results", " R", "ros", "Res", "es", " Res", "vals", " resolution", "re", "arr", "data", "resp", "ris"], "a": ["am", "all", "sa", "ap", "aw", "array", "n", "ga", "area", "args", "ha", "na", "w", "ae", "aaa", "h", "ar", "aa", "ach", "parts", "alpha", "actions", "au", "ad", "Array", "app", "an", "ia", "analysis", "art", "u", "ai", "p", "ra", "d", "av", "aj", "z", "ab", "response", "wa", "api", "ma", "ac", "ba", "va"], "m": ["x", "am", "mr", "all", "mu", "ym", "im", "l", "mi", "n", "q", "mm", "w", "o", "g", "rm", "h", "R", "ar", "bm", "y", "range", "an", "ur", "cm", "u", "mc", "p", "sm", "d", "C", "pm", "z", "um", "md", "re", "k", "er", "M"], "cnts": ["cNTe", "cntns", "critp", "Cndls", "ecNTns", "cndi", "Cnotp", "ecntp", " contns", " cnti", "cpte", "Cntls", "cnots", "cNTp", "cntches", "Cntps", "categi", "cnotches", "critls", "CNTps", "countches", "Cndi", "cntl", "categns", "Cnots", "cNTi", " conti", "ccts", "cNTd", "ecNTp", "Cndl", "conti", "cntp", "ecNTs", "ecnts", "cnte", "Cnts", "countp", "critns", "crts", "cNTches", "ecNTls", " conts", "cntls", "CNTs", "cNTps", "cndls", "cnotps", "cptd", "ecntns", "cnti", "crte", "criti", "cNTns", "CNTe", "Cnotches", "cntd", "Cnti", "cNTls", "contns", "crtps", "cctns", "Cnte", "cwns", " cntns", "counts", "Cnotps", "Cntp", "Cntd", "cpts", "cNTl", "Cntl", "cptps", "cctp", "cwnl", "CNTd", "conts", "cNTs", "crits", "countps", "cnotp", "cctls", "ecntls", "cwnls", "cwni", "categs", "cntps", "Cntches", "Cnds", "crtd", "cndl", "cnds"], "IN": ["EN", "AC", "OU", "AN", "Input", "INS", "Reader", "BL", "INT", "DATA", "ins", "LIN", "Out", "PIN", "LIB", "AD", "I", "input", "inner", "IR", "IC", "IL", "CON", "CL", "MN", "FILE", "URL", "In", "AL", "IM", "RAW", "IO", "M", "bin", "Con", "URI"], "e": ["x", "err", "l", "n", "end", " ce", "ce", "w", "ae", "ec", "fe", "h", "y", " eb", "range", "u", "p", "d", "ed", "z", "ee", "es", "er", "se"]}}
{"code": "def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rints(): return map(int, rstr().split())\n      def rr():\n          x = rint()\n          m = [rints() for i in xrange(4)]\n          return set(m[x-1])\n      s = rr().intersection(rr())\n      if not s:\n          return \"Volunteer cheated!\"\n      if len(s) == 1:\n          return s.pop()\n      return \"Bad magician!\"\n  \n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          OUT.write(\"Case #%i: %s\n\" % (i, CASE(IN)))\n  \n  if __name__ == \"__main__\":\n      RUN(sys.stdin, sys.stdout)\n", "substitutes": {"IN": ["N", "MIN", "EN", "SQL", "NS", "AC", "OU", "TEXT", "UL", "AN", "TIME", "EX", "Input", "INS", "BC", "II", "INT", "X", "DATA", "GE", "ins", "LIN", "PIN", "Out", "IT", "OSS", "ID", "input", "STR", "NO", "IR", "DIR", "IND", "NG", "IL", "IC", "S", "CL", "MN", "String", "FILE", "NE", "URL", "In", "READ", "WIN", "INE", "AL", "FIN", "NAME", "HTTP", "RAW", "IO", "LINE", "URI", "IP"], "x": ["rx", "id", "j", "xx", "e", "v", "index", "n", "xy", "tx", "q", "xi", "fx", "w", "o", "xxx", "X", "c", "ex", "xes", "ww", "xp", "y", "xc", "xt", "u", "dx", "p", "z", "ix", "ax", "int", "xs", "k", "sex", "f"], "m": ["ym", "mr", "v", "e", "l", "mi", "n", "r", "mm", "o", "g", "rm", "c", "ms", "bm", "h", "gm", "y", "hm", "range", "fm", "u", "cm", "mc", "b", "p", "sm", "d", "tm", "dm", "f", "M", "imm"], "i": ["id", "j", "ii", "e", "v", "ri", "index", "ip", "l", "n", "ei", "ind", "xi", "li", "iu", "r", "o", "on", "abi", "c", "ti", "ie", "ir", "gi", "qi", "si", "ih", "I", "ci", "u", "ai", "b", "p", "d", "ime", "z", "ix", "pi", "int", "a", "f"], "s": ["ps", "e", "v", "ns", "ds", "cs", "l", "n", "rors", "ops", "r", "sym", "os", "o", "ing", "g", "its", "c", "ms", "ips", "ins", "ows", "ses", "ws", "y", "abs", "gs", "an", "strings", "ss", "rows", "rs", "S", "b", "p", "acks", " lines", "d", "results", "ls", "errors", "lines", "a", "es", "ments", "xs", "f", "ions", "ches", "eds"], "OUT": ["ST", "OT", "WARN", "OU", "TEXT", "INS", "Output", "VER", "PATH", "ISO", "OS", "PUT", "NET", "INT", "TER", "Out", "ERROR", "EXT", "out", "STR", "USE", "IR", "STDOUT", "RET", "CL", "FILE", "FS", "NER", "READ", "UT", "NAME", "VERSION", "RAW", "IO", "WR", "UN", "EX", "NG"], "t": ["j", "v", "e", "T", "st", "l", "n", "time", "r", "w", "tt", "at", "g", "c", "ti", "h", "pt", "wt", "y", "ta", "ot", "ty", "out", "dt", "u", "tz", "b", "p", "tp", "d", "z", "ts", "f", "temp"]}}
{"code": " \n  \n  \n  class Minesweeper_2014_QC(puzutils.CodeJamProblem):\n    def __init__(self, inputFilename):\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\n  \n      self.T = None\n  \n    def load(self):\n      \"\"\"\n        input:\n  \n        T (number of test cases)\n  \n        R C M (integers)\n  \n      \"\"\"\n  \n      self.tests = []\n  \n      with open(self.inputFilename, \"rt\") as file:\n        self.T = int(file.readline().strip())\n  \n        for i in xrange(self.T):\n          (R,C,M) = [int(x) for x in file.readline().split(' ')]\n  \n          self.tests.append([R,C,M])\n  \n      return True\n  \n    def boardToString(self, board):\n      retval = \"\"\n  \n      for row in board:\n        retval = retval + \"\n\" + \"\".join(row)\n  \n      return retval\n  \n    def executeTest(self, test):\n      \"\"\"\n        Run a test and return output.\n      \"\"\"\n  \n      (R,C,M) = test\n  \n      spaces = R * C\n      blanks = spaces - M\n  \n      if (blanks <= 0):\n        return \"Impossible\"\n  \n      board = [['.' for x in range(C)] for y in range(R)]\n  \n      board[R-1][C-1] = \"c\"\n  \n      badpositions=[]\n      positions=[]\n  \n      for x in xrange(C):\n        for y in xrange(R):\n          if (x == (C-1)) and (y == (R-1)):\n            continue\n          if (x == (C-1)) and (y == (R-2)):\n            badpositions.append((x,y))\n            continue\n          if (x == (C-2)) and (y == (R-1)):\n            badpositions.append((x,y))\n            continue\n          if (x == (C-2)) and (y == (R-2)):\n            badpositions.append((x,y))\n            continue\n  \n          positions.append((x,y))\n  \n      positions.reverse()\n  \n      for x in badpositions:\n        positions.insert(0, x)\n  \n      m = M\n  \n      while (m > 0):\n        if len(positions) <= 0:\n          return \"Impossible\"\n  \n        pos = positions.pop()\n        (x,y) = pos\n  \n        if (board[y][x] != \".\"):\n          return \"Impossible\"\n  \n        board[y][x] = '*'\n        m = m - 1\n  \n      mines = sum([x.count('*') for x in board])\n  \n      if (mines != M):\n        return \"Impossible\"\n  \n      if (blanks > 1):\n        if (R > 1):\n          if board[R - 2][C - 1] == \"*\":\n            return \"Impossible\"\n  \n        if (C > 1):\n          if board[R - 1][C - 2] == \"*\":\n            return \"Impossible\"\n  \n        if (R > 1) and (C > 1):\n          if board[R - 2][C - 2] == \"*\":\n            return \"Impossible\"\n  \n      return self.boardToString(board)\n  \n  with Minesweeper_2014_QC(sys.argv[1]) as problem:\n    problem.load()\n  \n    problem.run()\n", "substitutes": {"self": ["parent", "http", "args", "student", "driver", "spec", "ref", "private", "ws", "app", "k", "case", "resp", "layer", "instance", "object", "l", "n", "writer", "r", "connection", "function", "p", "block", "full", "error", "form", "plus", "ctx", "Self", "all", "user", "other", "q", "server", "event", "func", "public", "s", "ng", "context", "static", "host", "view", "method", "lf", "client", "comment", "f", "er", "hub", "worker", "part", "e", "default", "cache", "w", "this", "g", "me", "c", "file", "load", "base", "results", "es", "cl", "work", "node", "wrapper"], "inputFilename": ["requestSourceFile", "outputFilename", "outputFILE", "sourceSourceFile", "outputDirectory", "sourceFilename", "inputSourceFile", " inputfilename", "InputSourceFile", " inputFile", "InputFile", "requestFilename", "inputFILE", "outputfilename", "inputFile", "sourceFile", " inputSourceFile", "Inputfilename", "outputFile", "tempFilename", " inputFILE", "inputfilename", "tempFile", "sourceDirectory", "InputFilename", "requestFILE", "requestFile", "inputDirectory", "tempSourceFile", "tempDirectory", "outputSourceFile"], "T": ["N", "Y", "Ts", "TE", "TN", "t", "P", "TH", "TF", "TS", "TI", "U", "Length", "E", "H", "G", "W", "K", "X", "LT", "Test", "NT", "Q", "I", "B", "TA", "D", "F", "WT", "O", "CT", "S", "TT", "Z", "TB", "A", "L", "V"], "tests": ["tips", "videos", "testers", "Times", "TS", "features", "reads", "ests", "Testing", "ports", "sections", "files", "checks", "classes", "values", "amples", "runs", "scripts", "forms", "rows", "steps", "events", "types", "results", "rules", "boards", "reports", "lines", "suits", "ts", "cases", "tools", "tracks", "times", "ches", "testing"], "i": ["id", "j", "e", "index", "xb", "ip", "xy", "ind", "ei", "ace", "xi", "col", "o", "ti", "h", "bit", "iii", "xp", "I", "ci", "u", "xf", "z", "ix", "axis", "sex", "f", "io"], "R": ["Rh", "Y", "N", "HR", "SC", "GR", "Rs", "Range", "P", "RE", "MR", "Cl", "J", "CR", "RH", "DC", "Re", "r", "JR", "E", "G", "H", "SR", "RM", "W", "RO", "RF", "K", "X", "Right", "RW", "ER", "Q", "CC", "DR", "RS", "BR", "Rec", "I", "B", "Run", "AR", "D", "F", "RC", "RG", "IR", "O", "LR", "RL", "RN", "S", "Z", "CL", "RR", "V", "NR", "KR", "A", "L", "U", "RA"], "C": ["N", "Y", "NC", "SC", "CNN", "AC", "Cs", "P", "VC", "DC", "CM", "CR", "Cl", "E", "CE", "H", "G", "W", "CA", "K", "X", "c", "YC", "Co", "Sc", "CV", "CO", "Q", "CC", "CW", "Cu", "B", "KC", "I", "D", "CI", "F", "RC", "Cr", "CS", "Ca", "Ch", "CP", "CT", "O", "S", "CL", "CH", "EC", "MC", "V", "CU", "CN", "Code", "A", "L", "U"], "M": ["N", "Y", "MD", "Multiple", "FM", "P", "n", "MS", "MQ", "MR", "CM", "CR", "VM", "E", "H", "MX", "MI", "Mass", "G", "RM", "W", "DM", "K", "X", "mode", "NM", "Mo", "Q", "CC", "OM", "I", "B", "MF", "D", "F", "MB", "LM", "MM", "EM", "cm", "O", "S", "CL", "MN", "ME", "Z", "MC", "length", "V", "number", "A", "L", "U", "Mac"], "x": ["id", "v", "t", "model", "ay", "image", "match", "ux", "position", "xc", "yx", "ax", "xs", "sex", "case", "rx", "Y", "j", "l", "xy", "n", "time", "xxxx", "xxx", "one", "X", "ex", "xp", "name", "xa", "xt", "ext", "p", "xf", "ix", "wa", "check", "ct", "ctx", "number", "word", "step", "index", "xb", "px", "ip", "code", "q", "xi", "event", "on", "s", "pe", "an", "yl", "u", "dx", "b", "d", "ch", "cross", "mx", "data", "f", "xe", "xx", "e", "key", "tx", "w", "o", "width", "g", "c", "h", "ic", "z", "ey", "int", "cy", "wx", "cl"], "board": ["flow", "bug", "game", "deck", "object", "ack", "string", "code", "array", " clipboard", "ro", "control", "card", "home", "core", "table", "bo", "channel", "problem", "shape", "square", "path", "co", "Board", "list", "bar", "coll", "reader", "loop", "buffer", "view", "sequence", "frame", "hole", "layout", "cube", "block", "box", "boarding", "line", "boards", "arrow", "axis", "back", "comment", "room", "cell", "form", "case", " boards", "rank", "player", " Board", "cart", "bank", "word"], "retval": ["Retval", " retvals", "Retvalue", "RETvalue", "RetVal", "interVal", "returnvals", "returnVal", "retVal", " reteval", " retvalue", " retVal", "returnval", "Retvals", "retvals", "RETvals", "reteval", "retvalue", "RETval", "returnvalue", "interval", "RETVal", "Reteval", "intereval"], "row": ["flow", "bug", "Row", "key", "object", "ack", "string", "insert", "result", "user", "array", "ro", "run", "server", "feed", "col", "record", "round", "value", "raw", "reader", "val", "item", "buffer", "range", "view", "rows", "str", "roll", "block", "ride", "line", "arrow", "entry", "error", "comment", "cell", "rank", "node", "page"], "test": ["instance", "est", "valid", "all", "min", "v", "string", "result", "code", "t", "array", "che", "train", "trial", "table", "run", "server", "model", "sample", "shape", "match", "top", "arg", "value", "X", "c", "fit", "pattern", "Test", "loop", "unit", "buffer", "txt", "host", "F", "py", "slave", "long", "xt", " Test", "call", "p", "line", "true", "sub", "int", "check", "pack", "iter", "case", "f", "example", "form", "temp", "_", "script", "mat", "testing"], "spaces": ["braces", "stacing", "spacing", "brans", "Spacing", " space", " spanks", "Spans", "space", "stans", "branks", "spanks", "staces", "brace", "spans", " spacing", "Spanks", " spans", "Spaces", "stanks", "Space"], "blanks": [" blank", "Blaces", "Blacks", "plans", " blaces", "Blank", "planks", " blacks", "blans", "places", "Blans", "blaces", "plank", " blans", "blacks", "placks", "blank", "Blanks"], "y": ["yer", "Y", "j", "ym", "id", "sy", "e", "yr", "yt", "ky", "ys", "t", "xy", "ny", "q", "iny", "vy", "yan", "ies", "yd", "yi", "ay", "r", "ady", "col", "o", "yu", "yy", "c", "ish", "h", "yn", "ya", "iy", "ty", "yl", "py", "my", "ry", "zy", "b", "ch", "gy", "z", "ey", "year", "ye", "dy", "yo", "cy", "oy", "isy", "hy"], "badpositions": ["badosations", " badposites", "BadPosals", "badPosions", "badposations", "goodposits", "badpositionitions", "badPosresses", "Badposition", "badcondresses", "badPosition", "badnosresses", "badlocition", "BadPosites", "badnosions", "BadPosations", "badnositions", " badposions", "badposites", "badcondits", "badconditions", "badlocitions", "badpositionites", "badpositionations", "badposes", "badosions", "badPoses", "badpositionions", "badPosals", "badposition", "badPosites", "BadPosions", "Badpositions", " badositions", " badposes", "badposresses", " badosions", "goodPosits", "badposions", "badposals", " badoses", "badoses", "badcondition", "badlocals", "Badposations", "badPosits", "badPositions", "badcondions", " badosites", "goodpositions", "Badposals", "badnosits", "goodPositions", "badosites", "goodPosions", "badpositiones", "BadPosition", "badPosations", " badposations", "goodposresses", "Badposites", "badositions", "goodPosresses", " badosations", "badlocions", "badposits", "Badposions", "badcondals", "goodposions", "BadPositions"], "positions": ["posences", "condelines", " posresses", "posations", " posits", " posations", " position", "locations", "potences", "condances", "condations", "conditions", "Posices", "Posresses", "Posations", " poselines", "Posions", "Posals", " posences", "posices", "posits", "potensions", "psances", " posensions", "Posances", "Position", "partits", "posances", "partition", "partitions", "position", "poselines", "posensions", "posresses", "condresses", "Positions", " posices", "partals", "psations", "locresses", "posals", " posals", "partences", "locelines", "partices", "partensions", "psitions", "psresses", "locions", "posions", "potits", "potitions", "condions", "locitions", " posions"], "m": ["mu", "am", "ym", "v", "e", "mr", "im", "l", "mi", "t", "n", "man", "r", "w", "mm", "o", "bm", "c", "ms", "gm", "mass", "meta", "machine", "cm", "u", "mc", "b", "p", "sm", "d", "pm", "um", "z", "tm", "mini", "dm", "f"], "pos": ["ps", "e", "object", "pl", " Pos", "st", "l", "no", "n", " position", "cond", "po", "Pos", "o", "POS", "s", "lab", "position", "trans", "found", "p", "d", "f", "loc", "pro", " POS"]}}
{"code": " \n  \n  \n  class Magic_2014_QA(puzutils.CodeJamProblem):\n    def __init__(self, inputFilename):\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\n  \n      self.T = None\n  \n    def load(self):\n      \"\"\"\n        input:\n  \n        T (number of test cases)\n  \n        A (answer to first question)\n        x x x x\n        x x x x\n        x x x x\n        x x x x\n        B (answer to second question)\n        x x x x\n        x x x x\n        x x x x\n        x x x x\n  \n      \"\"\"\n  \n      self.tests = []\n  \n      with open(self.inputFilename, \"rt\") as file:\n        self.T = int(file.readline().strip())\n  \n        for i in xrange(self.T):\n          a = int(file.readline().strip())\n          test = {'a': a}\n          board = []\n          \n          for j in xrange(4):\n            line = file.readline().strip()\n            row = set([int(x) for x in line.split(' ')])\n            board.append(row)\n  \n          test['aboard'] = board\n  \n          b = int(file.readline().strip())\n          test['b'] = b\n          board = []\n          \n          for j in xrange(4):\n            line = file.readline().strip()\n            row = set([int(x) for x in line.split(' ')])\n            board.append(row)\n  \n          test['bboard'] = board\n  \n          self.tests.append(test)\n  \n      return True\n  \n    def executeTest(self, test):\n      \"\"\"\n        Run a test and return output.\n      \"\"\"\n  \n  \n      rowA = test['aboard'][test['a'] - 1]\n      rowB = test['bboard'][test['b'] - 1]\n  \n  \n      intersect = rowA.intersection(rowB)\n  \n  \n      if (len(intersect) == 1):\n        (element,) = intersect\n        return element\n      elif (len(intersect) == 0):\n        return \"Volunteer cheated!\"\n      else:\n        return \"Bad magician!\"\n  \n  with Magic_2014_QA(sys.argv[1]) as problem:\n    problem.load()\n  \n    problem.run()\n", "substitutes": {"self": ["parent", "http", "model", "args", "spec", "old", "ref", "private", "master", "app", "m", "k", "case", "resp", "layer", "instance", "object", "n", "time", "gen", "r", "connection", "job", "my", "function", "str", "p", "full", "error", "plus", "ctx", "Self", "all", "parse", "user", "result", "other", "q", "server", "event", "func", "public", "module", "s", "python", "ng", "context", "host", "view", "method", "lf", "pos", "client", "comment", "f", "er", "worker", "part", "e", "home", "cache", "w", "this", "me", "g", "c", "h", "ess", "file", "manager", "load", "results", "es", "cl", "work", "node"], "inputFilename": ["sourcefilename", "outputFilename", "outputDirectory", "sourceFilename", "inputSourceFile", " inputfilename", "InputSourceFile", " inputFile", "InputFile", "outputfilename", "inputFile", "sourceFile", " inputSourceFile", "Inputfilename", "InputDirectory", "outputFile", "inputfilename", "sourceDirectory", "InputFilename", "inputDirectory", "outputSourceFile"], "T": ["N", "Y", "Ts", "TE", "TN", "t", "P", "PT", "TH", "TF", "TS", "TI", "Length", "E", "G", "H", "W", "K", "X", "R", "Test", "NT", "Q", "B", "TA", "D", "F", "WT", "Type", "O", "S", "TT", "Z", "C", "TB", "M", "A", "L", "V"], "tests": ["groups", "models", "testers", "features", "reads", "ests", "thumbnails", "modules", "tested", "settings", "sections", "files", "checks", "classes", "runs", "rows", "forms", "scripts", "steps", "types", "events", "results", "rules", "fixes", "reports", "lines", "errors", "suits", "ts", "cases", "tools", "testing"], "i": ["ji", "id", "ii", "e", "ip", "n", "ind", "q", "ei", "xi", "iu", "on", "c", "ti", "ie", "gi", "y", "I", "num", "iq", "u", "ib", "ai", "z", "ix", "ij", "k", "io"], "a": ["am", "oa", "ea", "la", "sa", "array", "n", "asa", "ga", "area", "ca", "fa", "na", "ae", "c", "tta", "aa", "action", "alpha", "au", "ad", "ana", "qa", "an", "ai", "ata", "p", "da", "aj", "ab", "wa", "ma", "ac", "A", "ba", "va"], "test": ["game", "est", "parent", "stage", "t", "train", "model", "run", "complete", "target", "feed", "tt", "old", "match", "master", "pattern", "unit", "app", "search", "call", "pack", "cell", "case", "example", "bug", "rule", "catch", "tested", "value", "set", "list", "sc", "use", "config", "rest", "diff", "new", "full", "check", "scale", "rate", "form", "all", "result", "code", "report", "table", "dev", "server", "event", "create", "shape", "off", "type", "Test", "style", "fill", "build", "acc", "the", "cross", "comment", "data", "transfer", "port", "testing", "valid", "both", "default", "trial", "this", "show", "sync", "file", "fail", "load", "ss", "null", "temp", "script"], "board": ["game", "area", "model", "ca", "course", "col", "square", "coll", "head", "length", "boarding", "cell", "bug", "deck", "down", "array", "card", "store", "oard", "que", "one", "list", "road", "loop", "buffer", "bean", "clean", "block", "away", "scale", "back", "error", "form", "number", "team", "cart", "word", "union", "flow", "lane", "code", "che", "control", "table", "hack", "group", "ward", "type", "bar", "bee", "view", "layout", "cross", "box", "foot", "une", "comment", "land", "data", "menu", "ack", "string", "home", "bo", "ox", "co", "flo", "Board", "sequence", "boards", "design"], "j": ["ji", "id", "v", "im", "je", "ip", "dj", "n", "l", "ind", "q", "J", "r", "o", "c", "ie", "jp", "jam", "jl", "y", "job", "p", "d", "z", "obj", "ja", "ij", "k", "f", "uj"], "line": ["liner", "inline", "la", "object", "ze", "string", "lane", "code", "l", "log", "play", "home", "lc", "ine", "se", "pin", "ell", "label", "el", "feed", "co", "lo", "one", "list", "cle", "pe", "coll", "byte", "name", "loop", "sync", "file", "unit", "lock", "buffer", "style", "message", "source", "write", "frame", "page", "block", "entry", "chain", "lines", "lin", "link", "comment", "Line", "cell", "case", "point", "band", "lined", "word"], "row": ["step", "bug", "Row", "key", "sel", "ner", "ro", "server", "r", "feed", "col", "order", "where", "group", "ward", "stroke", "one", "value", "bar", "pe", "coll", "raw", "reader", "way", "loop", "sync", "fail", "column", "view", "rows", "roll", "block", "box", "cross", "ride", "entry", "scale", "link", "cell", "case", "node", "page"], "x": ["id", "rx", "e", "xx", "index", "string", "l", "code", "t", "n", "ga", "q", "time", "day", "xi", "w", "ck", "xxx", "on", "one", "X", "c", "h", "ex", "ux", "bit", "y", "num", "out", "xc", "xt", "u", "m", "ph", "p", "d", "gy", "z", "ix", "ax", "full", "int", "ct", "xs", "f", "data", "lex", "word"], "b": ["e", "v", "book", "bi", "l", "t", "n", "bc", "nb", "r", "w", "ob", "body", "g", "c", "h", "binary", "s", "bar", "bb", "sb", "y", " eb", "B", "u", "base", "lb", "boot", "p", "d", "ab", "new", "f", "bin", "ba"], "rowA": ["RowB", "colB", "roB", "roA", "rowC", "servera", "rowa", "roa", " rowC", "roC", "colA", "serverB", "colC", "RowC", "RowA", "serverC", " rowa", "serverA"], "rowB": ["RowB", "colB", "bugA", "roB", "roA", "RowBB", "rob", "colA", "rowBB", "RowA", "rowb", "Rowb", " rowBB", "bugB", "colb", "roBB", " rowb", "bugb"], "intersect": ["Intersect", "interconnect", "Interception", "surcept", "crossception", "crosspass", "presection", "intercept", "consect", "extsections", "Intercept", "preconnect", "Interpass", "interception", "presect", "extsection", "interect", "crossect", "precept", "Intersections", "intersection", "intersections", "crossconnect", "surconnect", "Interconnect", "surpass", "crosssect", "corception", "sursection", "sursect", "consection", "corsection", "extsect", "concept", "extcept", "Interect", "interpass", "consections", "corect", "corsect", "Intersection", "crosssection"], "element": ["layer", "instance", "parent", "feature", "component", "e", "all", "root", "object", "Element", "result", "array", "address", "table", "server", "member", "sect", "this", "lement", "match", "module", "value", "div", "empty", "action", "article", "section", "ele", "unit", "item", "style", "sequence", "null", "document", "ee", "length", "entry", "option", "cell", "case", "node", "union"]}}
{"code": " \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for test in range(T):\n      R, C, M = map(int, f.readline().strip().split())\n      Rorig = R\n      Corig = C\n      impossible = False\n      grid = [['.' for i in range(C)] for j in range(R)]\n  \n      curr_coord = [0,0]\n      while M > 0 and not impossible:\n          if (C > R): # more columns - fill one in\n              num_mines_in_column = R\n              if M < R:\n                  num_mines_in_column = min(R - 2, M)\n              if num_mines_in_column <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_in_column):\n                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'\n              C -= 1\n              curr_coord[1] += 1\n              M -= num_mines_in_column\n          else:\n              num_mines_in_row = C\n              if M < C:\n                  num_mines_in_row = min(C - 2, M)\n              if num_mines_in_row <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_in_row):\n                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'\n              R -= 1\n              curr_coord[0] += 1\n              M -= num_mines_in_row\n  \n      print \"Case #%d:\" % (test + 1)\n      if impossible:\n          print \"Impossible\"\n      else:\n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == '.':\n                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n  \n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == 'dirty':\n                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      else:\n                          if ii != Rorig - 1 or jj != Corig - 1:\n                              impossible = True\n  \n          if impossible:\n              print \"Impossible\"\n          else:\n              grid[Rorig-1][Corig-1] = 'c'\n  \n              for ii in range(Rorig):\n                  print \" \".join([val for val in grid[ii]])\n  \n  \n", "substitutes": {"f": ["fn", "e", "fr", "v", "fast", "ff", "l", "t", "n", "tf", "fa", "stream", "r", "w", "fd", "feed", "files", "bf", "g", "c", "s", "h", "info", "file", "fen", "fw", "raf", "F", "handler", "fp", "m", "lf", "b", "p", "fs", "fb", "df", "d", "z", "buff", "fc", "form", "iter", "io"], "T": ["TR", "N", "Y", "Table", "TN", "t", "P", "TF", "DT", "TS", "Length", "E", "H", "G", "W", "K", "X", "TC", "TX", "NT", "Q", "TM", "I", "B", "D", "F", "WT", "TG", "O", "S", "TT", "GT", "L", "V"], "test": ["x", "TR", "all", "v", "vv", "code", "t", "P", "n", "end", "ind", "train", "trial", "count", "ctr", "sect", "course", "G", " trial", "order", "thread", "g", "match", "X", "ti", "gi", "chi", "Test", "seq", "loop", "tests", "config", "txt", "start", "I", "rest", "ID", "F", "acc", "tri", "tr", "S", "uit", "NUM", "diff", "ct", "iv", "di", "iter", "case", "temp", "mat", "testing"], "R": ["Rh", "TR", "N", "Y", "GR", "Rs", "Range", "P", "RE", "MR", "J", "RH", "CR", "RT", "r", "E", "G", "H", "SR", "RM", "W", "RO", "K", "X", "Right", "Co", "Center", "RW", "ER", "Q", "DR", "RS", "I", "B", "D", "F", "RC", "RG", "Ra", "O", "Max", "S", "CL", "RR", "V", "NR", "A", "L", "U", "RA"], "C": ["N", "Y", "NC", "Cor", "CNN", "AC", "Cs", "P", "VC", "DC", "CM", "CR", "RH", "Cl", "CF", "II", "E", "G", "CE", "H", "RM", "W", "COR", "CA", "K", "X", "c", "Co", "CO", "CC", "Q", "CW", "Cu", "B", "I", "D", "CI", "F", "Cr", "CCC", "O", "CT", "Max", "S", "CL", "Z", "EC", "MC", "V", "NR", "CU", "CN", "A", "L", "U"], "M": ["N", "Y", "MD", "FM", "P", "MOD", "MR", "MO", "J", "CM", "VM", "r", "MT", "E", "G", "MX", "MI", "H", "RM", "W", "DM", "AM", "X", "NM", "Q", "TM", "ML", "I", "B", "OM", "MF", "MH", "D", "JM", "F", "MB", "LM", "MM", "m", "cm", "O", "S", "Mi", "MA", "MN", "MC", "V", "OR", "L", "U", "RA"], "Rorig": ["Rorigin", "Mlim", "NOrig", "Rlim", "Torig", "ROrig", "Corigin", "Torigin", "Toriginal", "Clim", "COrig", "Norigin", "MOrig", "Cprev", "Morig", "rlim", "rOrig", "rorig", "TOrig", "Roriginal", "Coriginal", "Norig", "rprev", "Rprev", "Noriginal", "Mprev"], "Corig": [" Corigo", "corig", "Corigon", "Correg", "CorIG", "RectIG", " CorIG", "Rectigon", "corIG", "CORig", "ContIG", "Corigo", "corigo", "Contigo", "CORIG", "correg", "Contig", "Rectig", "Contigon", " Correg", "corigon", "CORigo", "CORreg", "Rectigo"], "impossible": [" impure", "possible", "expple", "compossibility", "impossibly", "ispossible", "compple", "Impair", "Impant", " impickle", "impallel", " imporsche", "pant", "Impple", "Impickle", "impair", "isporsche", " impressive", "possibility", "impressive", " impair", "ispure", "compallel", "impossibility", "impant", "possibly", "Impossibly", "pallel", "impure", "imporsche", "pickle", "expossibly", "Impure", "impickle", "impple", "Imporsche", " impant", "expossibility", "compair", "expossible", "compossibly", "Impossibility", "Impressive", "ispair", "compressive", "Impallel", "compossible", "Impossible", " impossibility"], "grid": ["remote", "parent", "book", "stage", "hold", "gr", "model", " structure", "G", "ridge", "yard", "align", "window", "storage", "gi", "unit", "range", "gap", "gp", "df", "vg", "chain", "cell", "age", "db", "house", "Grid", "layer", "gui", "GR", "rule", "array", "sky", "site", "edge", "list", "cells", "panel", "tree", "cube", "block", "scale", "flat", "export", "flow", " Grid", "query", "product", "server", "order", "group", "module", "dict", "update", "filter", "active", "mag", "input", "layout", "plot", "line", "client", "graph", "data", "draw", "play", "cache", "json", "g", "grain", "dim", "sync", "file", "row", "column", "ange", "arr", "work", "node", "mat", "station", " grids"], "i": ["x", "id", "ri", "im", "ip", "iu", "li", "on", "c", "ir", "ie", "ih", "I", "ni", "fi", "ci", "ib", "ai", "b", "p", "pi", "k", "io"], "j": ["ji", "x", "im", "je", "br", "n", "ind", "q", "J", "r", "jc", "o", "g", "c", "h", "jp", "jl", "ci", "m", "cm", "b", "d", "aj", "z", "ij", "ja", "k"], "curr_coord": ["curr__cp", "curvr_channel", "currOpair", "curre_loc", "currPco", "curr4channel", "curvr_align", "curre_orig", "curr_pair", "curpr_marg", "currt_pixel", "curpr_cube", "curr4align", "currOcoord", "curr_channel", "curr_dim", "currPcoord", "curr_data", "curr_loc", "curr_scale", "currPcube", "curr_co", "curvr_orig", "curr7coord", "currt_coord", "curr_cp", "curr_align", "curre_scale", "curr_orig", "curr7cell", "curpr_co", "curr_marg", "curr_point", "curr_cube", "currPmarg", "curre_coord", "curre_point", "curr__pixel", "curr7orig", "curre_data", "curr_cell", "curr7byte", "currOco", "curpr_coord", "curr4orig", "currOdim", "curr_byte", "curr4coord", "curr_pixel", "curre_co", "curvr_coord", "curr__scale", "currt_loc", "curr__loc", "curr__data", "currt_cp", "curr__coord"], "num_mines_in_column": ["num_mines_per_cell", "num_mines_in_month", "num_mines_in_cell", "num_mines_in_col", "num_mines_in_section", "num_mines_in_min", "num_mines_per_column", "num_mines_per_month", "num_mines_per_col", "num_mines_per_section", "num_mines_per_min", "num_mines_per_row"], "ii": ["id", "cli", "agi", "image", "ti", "ir", "gi", "chi", "oci", "iii", "sci", "oi", "inn", "qa", "iw", "eni", "ni", "cm", "ien", "quad", "iv", "iter", "ijk", "im", "ei", "li", "ari", "ou", "ice", "ie", "info", "inf", "img", "fi", "ai", "ani", "ix", "ij", "di", "zi", "ui", "aff", "ius", "index", "ind", "xi", "iu", "qi", "element", "mag", "fl", "vi", "ih", "I", "uri", "ci", "py", "uv", "ini", "iq", "iso", "pi", "ne", "ji", "II", "uni", "DI", "c", "dim", "\u00ee", "attr", "ili", "si", "iss", "z", "ig", "int", "mini", "io"], "num_mines_in_row": ["num_mines_per_cell", "num_mines_in_month", "num_mines_in_cell", "num_mines_in_col", "num_mines_in_section", "num_mines_per_rows", "num_mines_per_column", "num_mines_per_entry", "num_mines_per_month", "num_mines_in2section", "num_mines_per_section", "num_mines_in2rows", "num_mines_in_rows", "num_mines_per_col", "num_mines_in2row", "num_mines_in_entry", "num_mines_in2column", "num_mines_per_row"], "jj": ["pg", "yah", "jc", "gi", "iii", "dq", "jp", "inn", "qa", "uu", "jar", "iw", "git", "note", "bj", "iv", "ijk", "uj", "sq", "bug", "ann", "ga", "J", "vision", "kk", "mm", "url", "hh", "sn", "bb", "jah", "kj", "track", "job", "aja", "jad", "ai", "ix", "aq", "ij", "di", "ht", "qq", "ah", "dj", "q", "journal", "JR", "qi", "hop", "kn", "nav", "jam", "jl", "ih", "uri", "ci", "jo", "iq", "nn", "vc", "oh", "aj", "ja", "ji", "xx", "ack", "java", "JJ", "jit", "json", "yy", "batch", "JC", "ww", "lv", "aii", "jan", "hn"]}}
{"code": " \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for test in range(T):\n      first_row_index = int(f.readline())\n      first_row = []\n      for ii in range(4):\n          if (ii + 1) == first_row_index:\n              first_row = f.readline().strip().split()\n          else:\n              f.readline()\n      second_row_index = int(f.readline())\n      second_row = []\n      for ii in range(4):\n          if (ii + 1) == second_row_index:\n              second_row = f.readline().strip().split()\n          else:\n              f.readline()\n      combined = [val for val in first_row if val in second_row]\n  \n      print \"Case #%d:\" % (test + 1), \"Bad magician!\" if len(combined) > 1 else \"Volunteer cheated!\" if len(combined) == 0 else combined[0]\n  \n  \n", "substitutes": {"f": ["x", "fn", "e", "fr", "v", "fast", "http", "ff", "rf", "l", "t", "fo", "tf", "fing", "fa", "af", "fx", "w", "fd", "feed", "bf", "g", "c", "fe", "s", "h", "i", "info", "conf", "inf", "file", "y", "fw", "fen", "F", "handler", "of", "fm", "fp", "m", "function", "lf", "found", "b", "fs", "p", "fb", "df", "d", "z", "fc", "full", "iter", "form", "io", "api", "fu"], "T": ["N", "Y", "TN", "t", "P", "TS", "TI", "E", "G", "H", "W", "X", "R", "Test", "Q", "Tu", "I", "B", "D", "F", "WT", "O", "S", "TT", "C", "Ti", "M", "L", "V"], "test": ["x", "id", "est", "v", "err", "t", "ind", "trial", "train", "count", "sect", "order", "match", "ice", "init", "ti", "gi", "i", "dim", "Test", "seq", "loop", "tests", "y", "vi", "unit", "txt", "num", "out", "app", "py", "ss", "tri", "acc", "ver", "diff", "int", "fix", "pack", "di", "iter", "case", "example", "seed", "temp", "testing"], "first_row_index": ["first_row_num", "first_col_index", "first_rows_width", "first_row_width", "first_rows_num", "first_row_length", "first_rows_index", "first_col_length", "first_col_num"], "first_row": ["first_rows", "first_line", "last_row", "first_entry", " first_col", "last_rows", "second_line", "second_rows", " first_rows", "first_col", " first_entry", "first_ro", "last_ro", "last_col", "second_entry"], "ii": ["ji", "id", "lli", "index", "ind", "ei", "xi", "yi", "agi", "li", "iu", "II", "ou", "ice", "ie", "i", "qi", "chi", "sci", "iii", "gi", "ti", "inf", "hi", " iii", "si", "ih", "vi", "img", "iff", "qa", "iw", "ni", "ci", "fi", "ini", "iq", "ien", "ai", "z", "ix", "pi", "mini", "di", "zi", "iter", "ui"], "second_row_index": ["second_row_end", "second_row0index", "second_row0end", "second_row_num", "second_col_length", "second_col_index", "second_row_length", "second_row0length", "second_col_num", "second_col_end"], "second_row": ["first_rows", "first_ow", "two_row", "two_rows", "second_ow", "two_entry", "second_rows", "second_raw", "next_row", "two_month", "next_page", "next_rows", "second_month", "second_page", "first_raw", "second_index", "next_index", "second_entry"], "combined": ["comining", "combered", " combining", " combination", "laminated", "confined", "combines", "confination", "confinated", "decloded", "lamine", "combaned", "confining", "comboded", "confered", "combining", "comered", "comines", "combination", "comaned", "confoded", "labination", "declined", "declaned", "labined", "Combine", "lamined", " comboded", "declered", " combered", "combine", "Combined", "combinated", "comoded", " combines", "comined", " combaned", "confines", "confine", "Combinated", "Combining", "labered", "laboded", "lamining"], "val": ["x", "all", "valid", "id", "v", "eval", "key", "index", "sel", "pl", "Val", "l", "bl", "ind", "dev", "li", "col", "ref", "std", "g", "arg", "value", "div", "elt", "unit", "item", "ot", "num", "viol", "fill", "fi", "py", "il", "VAL", "str", "p", " v", "pos", "int", "vals", "data", "pr", "sl", "var"]}}
{"code": "\"\"\"\n  Google Code Jam 2014 Qualification Problem C\n  Usage:\n      python c.py < input.txt > output.txt\n  \"\"\"\n  \n  \n  def iter_neighbors(x, y, cells):\n      columns = len(cells[0])\n      rows = len(cells)\n  \n      if y > 0:\n          if x > 0:\n              yield x - 1, y - 1\n          yield x, y - 1\n  \n          if x + 1 < columns:\n              yield x + 1, y - 1\n  \n      if x > 0:\n          yield x - 1, y\n  \n      if x + 1 < columns:\n          yield x + 1, y\n  \n      if y + 1 < rows:\n          if x > 0:\n              yield x - 1, y + 1\n  \n          yield x, y + 1\n  \n          if x + 1 < columns:\n              yield x + 1, y + 1\n  \n  \n  def try_to_click(x, y, cells, remaining):\n      if remaining == 0:\n          return cells\n  \n      recent = []\n  \n      opened = 0\n  \n      for n_x, n_y in iter_neighbors(x, y, cells):\n          if cells[n_y][n_x] == \"?\":\n              cells[n_y][n_x] = \".\"\n              opened += 1\n              recent.append((n_x, n_y))\n  \n      if opened == remaining:\n          return cells\n  \n      if opened > remaining:\n          return []\n  \n      for n_x, n_y in recent:\n          solution = try_to_click(n_x, n_y, copy.deepcopy(cells), remaining - opened)\n          if solution:\n              return solution\n  \n      return []\n  \n  \n  def solve_problem(rows, columns, mines):\n  \n      for x in xrange(columns):\n          for y in xrange(rows):\n              cells = [[\"?\" for i in xrange(columns)] for j in xrange(rows)]\n              cells[y][x] = \"c\"\n              solution = try_to_click(x, y, cells, rows * columns - mines - 1)\n  \n              if solution:\n                  return \"\n\".join([\"\".join(row) for row in solution]).replace(\"?\", \"*\")\n  \n      return \"Impossible\"\n  \n  \n  if __name__ == \"__main__\":\n      num_of_cases = int(sys.stdin.readline().strip())\n      for i in xrange(1, num_of_cases + 1):\n  \n          rows, columns, mines = map(int, sys.stdin.readline().strip().split())\n  \n          print \"Case #{0}:\n{1}\".format(i, solve_problem(rows, columns, mines))\n", "substitutes": {"x": ["id", "v", "t", "ay", "col", "image", "cel", "win", "xc", "m", "yx", "ax", "cell", "xs", "k", "content", "rx", "Y", "bug", "l", "ys", "no", "n", "xy", "xxx", "X", "xml", "ex", "name", "num", "my", "xt", "ry", "p", "ix", "ye", "ct", "a", "_", "plus", "index", "px", "code", "q", "xi", "na", "event", "on", "s", "ya", "max", "input", "ci", "u", "yes", "dx", "b", "d", "ch", "f", "xx", "e", "tx", "w", "o", "width", "co", "g", "c", "h", "xes", "val", "ty", "column", "close", "ic", "z", "ey", "int", "dy", "cy", "wx", "work"], "y": ["id", "v", "sy", "t", "vy", "ies", "ay", "col", "yn", "size", "yx", "m", "gy", "cell", "k", "hy", "Y", "ym", "poly", "ky", "ys", "l", "n", "xy", "wy", "sky", "yd", "yu", "ish", "my", "ry", "zy", "p", "ye", "a", "yt", "q", "yi", "ady", "s", "type", "ya", "iy", "python", "yl", "py", "ci", "yes", "b", "ch", "d", "uy", "oy", "xx", "e", "key", "yr", "ny", "yan", "w", "o", "yy", "g", "c", "h", "ty", "z", "ey", "year", "dy", "cy", "yo"], "cells": ["fields", "cats", "ports", "sections", " games", "cel", "ells", "versions", " cell", "sites", "tests", "breaks", "forms", "types", "false", "images", "cases", "cell", "xs", "case", "ks", "ches", "comments", "groups", "phones", "headers", "apses", "models", "keys", "words", "codes", "parts", "conf", "values", " Cells", "qs", "facts", "windows", "items", "details", "rules", "odes", "sheets", "lines", "charges", "csv", "_", "blocks", "holes", "ces", "cs", "code", "apps", "games", "features", "aps", "files", "classes", "s", "ences", "ows", "ci", "letters", "grid", "states", "ls", "reports", "errors", "ples", "ions", "Cell", "cb", "ices", "points", "cache", "rooms", "c", "xes", "books", "objects", "cards", "devices", "ed", "z", "es", "cy", "pages"], "columns": ["colizations", "columes", "colories", "cols", "columnizations", "mins", "COLizations", "columnlines", "arrowories", "visualrows", "pulls", "minses", "cellows", "celli", "COLrows", "coli", " columnments", " columnps", "welles", "widths", "COLments", "arrowows", "columnizes", "visualments", "widthi", "wells", "arrowless", "minumes", "columnows", "Columnizes", "colments", "colrows", "columnless", "Columnments", " columnes", "widthes", "widthizes", "coles", "visualizations", "dims", "colches", "Columnches", "columni", "colless", "cellless", "columnumes", "celles", "visuals", "columnses", "columnrows", "dimumes", "columnories", "arrows", "Columnes", "columnments", "columnches", "COLses", "colses", "cellps", "colizes", "Columnlines", "pulles", "pullses", "colps", "COLes", "columnes", "cellories", "COLches", " columni", "Columnses", "COLs", "dimses", "columnps", "dimes", "colows", "wellses", "Columni", "collines", "Columns", " columnlines"], "rows": ["blocks", "rown", "members", "groups", "holes", "headers", "index", "planes", "features", "reads", "fields", "keys", "modules", "ports", "feed", "col", "files", "posts", "checks", "orders", "rooms", "classes", "opens", "s", "ows", "ins", "users", "heads", "values", "rings", "tests", "height", "runs", "forms", "rs", "relations", "windows", "items", "flows", "types", "events", "works", "results", "rules", "length", "errors", "lines", "reports", "frames", "cases", "vals", "builders", "pages", "boxes", "tracks", "times", "views", "ks"], "remaining": [" remiving", "demaining", "remielding", "renains", "romained", "Remained", "demained", "Remiving", "Remaging", "romaining", "Remaining", "reshained", "renain", " remainer", " remain", "Remielding", " remaging", "remain", "promaining", "Remainer", "Remain", "reshielding", "reshaining", "promained", "remanging", "Remaine", "remained", " remaine", "remainer", " remained", "resaining", "resained", "remaine", "demainer", "reshanging", "renained", "Remains", "renielding", "remains", "romain", "promain", "resaging", "demiving", "remiving", "remaging", "promains", "Remanging", "renanging", "renaining", "resain", "romaine"], "recent": ["instance", " last", "quick", "remote", "valid", "original", "successful", "open", " expanded", "history", "hold", "shared", "exclusive", "complete", "complex", "event", "just", "folder", "updated", "Recent", "old", "region", "ready", "window", "progress", "active", "available", "needed", "raw", "apsed", "initial", "many", "lost", "sofar", "left", "similar", " recently", "ances", "memory", "unique", "current", "today", "later", "close", "closed", "items", "events", "last", "past", "latest", "new", "true", "client", "shown", "archive", "false", "used", "confirmed", "exp", "fresh", "record"], "opened": ["drawn", "orig", "successful", "adjusted", "original", "open", "edited", "focused", "ran", " expanded", " established", "rated", "ordered", "raised", "aced", " closed", "updated", "ended", "ned", "locked", "opens", "anged", " consumed", "signed", "active", "created", " accepted", "apsed", "expected", "released", "forced", "sofar", "held", " tested", "closed", "anded", "eno", "defined", "selected", "answered", "ed", "ened", "connected", "served", "early", "shown", "rawn", "opening", "used", "established", "added", "assembled", "initialized", "pressed", "produced", "handled", "sized", "worked", "ocated", "awed", "lined", " reopened", "started"], "n_x": ["n_xi", " n_ya", "n_xy", " n_xi", " n_wy", " n_xy", " n_a", "n_X", "dn_y", "n__x", "nin_z", "n_a", "dn_x", "nin_ya", "n___ya", "n_ex", "n__z", "nin_x", "dn_ex", "n_z", "n_yx", "n__yx", "n_ey", "nin_yx", "n___y", "n___x", " n_z", " n_X", "n_wy", "n___wy", "n__ya", "dn_ey", "n_ya"], "n_y": [" n_ya", "nn_sys", "n33hy", "n_dy", " n_vy", "n_ay", "n08dy", " n_yi", "nJy", "nDx", "nDxx", "n08y", "on25hy", "nJx", "on_hy", "n33sy", "nPy", "n08hy", "n_vy", "on_y", "nin_my", "nDy", "n33y", "n25sy", "n_z", " n_yt", "on_sy", "n_yi", "n_sy", "on25dy", "nPyi", "nn_x", "nPx", "nin_y", "nJz", "nDsys", "n_sys", "nJvy", "n_xx", " n_z", "nin_ay", "n_my", "nPya", "n_yt", "n_ya", "on25sy", "nin_yt", "n25y", "n_hy", "on_dy", "nn_y", "on25y", "n25hy", "n25dy", "n33dy", "nn_xx", "n08sy"], "solution": ["statesersion", " solve", "ssolutions", "folved", "ssersion", "folver", "Solution", "Solving", "solve", "esault", "csolution", " solving", "resault", "Sault", "sesolved", "suffolving", "csansion", "statesolution", "Solve", "esolution", "resolve", "Solver", "folving", "Solved", "qsolve", "solving", "sersion", "resolutions", "ssolved", "ssolution", "sault", "qsolution", "csolver", "sesolve", "solver", "confansion", "confolver", "sesolutions", " solutions", "resolution", "confersion", "ssolve", "csersion", "folution", "ssolving", "suffolver", "esolutions", "statesolve", "sesolution", "esolve", "suffolution", "qsolving", "suffolved", "solutions", "statesolving", "solved", "sansion", "confolution", "Solutions", "qsersion"], "mines": ["Minions", "Minices", "minves", "minions", "minices", "millves", "mins", "Mins", "serves", " mins", "MINes", "Minizes", "services", "milles", "servions", " minizes", "Mines", "servs", "MINs", "Minves", "MINices", "MINions", " minves", "minizes", "mills", "millizes"], "i": ["ji", "v", "ii", "e", "ip", "l", "ei", "ind", "q", "xi", "yi", "iu", "li", "o", "c", "ie", "qi", "iy", "si", "I", "ci", "u", "ai", "b", "p", "ix", "pi", "int", "ij", "f", "io"], "j": ["ji", "bi", "yr", "je", "l", "q", "ay", "r", "o", "co", "yy", "g", "h", "iy", "ci", "py", "ry", "m", "zy", "b", "p", "z", "ye", "ij", "dy", "k", "f", "hy"], "row": [" key", " col", "bug", " z", "Row", "rown", "key", "cer", "array", "xy", "model", "q", "server", " Row", "json", "r", "container", "feed", "col", " c", "value", "sc", "raw", "rc", "ow", "item", "uu", "you", "range", " d", "tr", "cube", " u", "entry", "client", "error", "rect", "cell", "node", " r", "record"], "num_of_cases": ["num_ofofdata", "num_of2lines", "num_of2times", "num_expectedofdata", "num_expectedoftimes", "num_expectedofcases", "num_expected_data", "num_expectedoflines", "num_expected_lines", "num_ofofcases", "num_of_data", "num_expected_cases", "num_expected_times", "num_of_lines", "num_of2cases", "num_of_times", "num_ofoflines", "num_ofoftimes", "num_of2data"]}}
{"code": "\"\"\"\n  Google Code Jam 2014 Qualification Problem A\n  Usage:\n      python a.py < input.txt > output.txt\n  \"\"\"\n  \n  \n  def solve_problem(first, first_rows, second, second_rows):\n      intersection = set(first_rows[first - 1]) & set(second_rows[second - 1])\n  \n      if not intersection:\n          return \"Volunteer cheated!\"\n      elif len(intersection) > 1:\n          return \"Bad magician!\"\n      else:\n          return intersection.pop()\n  \n  \n  \n  if __name__ == \"__main__\":\n      num_of_cases = int(sys.stdin.readline().strip())\n  \n      for i in xrange(1, num_of_cases + 1):\n          first_answer = int(sys.stdin.readline().strip())\n          first_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\n  \n          second_answer = int(sys.stdin.readline().strip())\n          second_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\n  \n          print \"Case #{0}: {1}\".format(i, solve_problem(first_answer, first_arrangement, second_answer, second_arrangement))\n", "substitutes": {"first": ["missing", "part", "all", "st", "default", "th", "third", "final", "table", "right", "leading", "fourth", "only", "one", "top", "value", "self", "name", "alpha", "initial", "start", "split", "left", "prev", "current", "last", "latest", "full", "next", "primary", "front", "case", "now", "central", "same", "fifth", "First"], "first_rows": ["second_row", "first_cells", "second_ows", "last_row", "last_rows", "last_lines", "first_lines", "first_ows", "first_results", "last_cells", "first_row", "second_results"], "second": ["double", "both", "lower", "other", "south", "multiple", "final", "member", "site", "follow", "secondary", "two", "fourth", "one", "after", "also", "initial", "future", "left", "split", "again", "another", "middle", "later", "current", "last", "latest", "new", "next", "same", "secret", "Second", "fifth", "video", "common", "seconds"], "second_rows": ["second_row", "two_row", "two_rows", "two_lines", "second_cells", "two_cells", "two_cases", "second_cases", "second_lines"], "intersection": ["interunion", "intection", "corsections", "Interection", "oversection", "overscription", "intsections", "extection", " intersector", " intersect", "oversections", "extsection", " interscription", "Intersector", "tersection", "intersect", "intsector", "incsections", "intsection", "extsector", "Intersections", "intersections", "interection", "incection", "intscription", "interscription", "intersector", "corunion", " interunion", "terscription", "corsection", "INTERsect", "Interunion", "extsect", "incscription", "INTERsector", "INTERsection", "INTERection", "overection", "tersections", "corsect", "tersector", "Intersection", "Intersect", "incsection", " intersections"], "num_of_cases": ["num_Of_case", "num_ofofcase", "num_of_case", "num_ofofcases", "num_Ofoflines", "num_ofoftests", "num_of_lines", "num_Ofofcase", "num_Of_times", "num_Ofofcases", "num_of_times", "num_ofoflines", "num_of_tests", "num_Ofoftimes", "num_Of_lines", "num_ofofsteps", "num_Of_cases", "num_ofoftimes", "num_of_steps"], "i": ["id", "j", "e", "ii", "ri", "index", "ip", "t", "n", "end", "phi", "ind", "xi", "yi", "r", "it", "o", "c", "ti", "gi", "qi", "iii", "y", "si", "I", "start", "eni", "uri", "ci", "u", "ai", "p", "ix", "pi", "int", "a", "k", "f", "io"], "first_answer": [" first__response", " first_response", " first_Answer", "pre_acid", "first_acid", "first__result", "first___acid", "first___examination", "first_examination", " first__Answer", "first___response", "first_response", "first_Answer", "first__response", " first_result", " first__answer", "first_result", "pre_response", "first__Answer", "pre_answer", "first___answer", " first__result", "pre_examination", "first__answer"], "first_arrangement": ["first_arangement", "first_aranguation", "first_arragment", "first_arrongement", "first_aronggment", "first_arangment", "first_aranggment", "first_arracmentation", "first_arrancuation", "first_arrongmentation", "first_arragement", "first_arranginguation", "first_arangmentation", "first_arracuration", "first_arronguation", "first_arrancment", "first_arrangingement", "first_arranguration", "first_arongment", "first_arongmentation", "first_arronggment", "first_arraguration", "first_arongement", "first_arrangmentation", "first_arrangment", "first_arronguration", "first_arrongment", "first_arrancement", "first_arracement", "first_arragmentation", "first_aranguration", "first_arranginggment", "first_aronguration", "first_arranguation", "first_arranggment", "first_arracment", "first_arrancgment", "first_aronguation", "first_arrangingment"], "x": ["id", "e", "v", "xx", "index", "ip", "code", "l", "n", "xy", "ga", "xi", "col", "X", "c", "ex", "pe", "xp", "xa", "num", "xc", "u", "ph", "ic", "p", "xf", "page", "d", "ix", "ax", "wx", "_", "f", "word"], "second_answer": ["secondary_question", "secondLAnswer", "secondary_eni", "second_eni", "second_Answer", "secondLanswer", "secondary_Answer", "second_square", "secondLsquare", "secondary_square", "secondary_answer", "secondLquestion", "second_question"], "second_arrangement": ["second_arrongment", "second_arangement", "second_arronggment", "second_arrangeement", "second_aronggment", "second_arrongements", "second_arrandgment", "second_arrangements", "second_arrongignment", "second_arrrangment", "second_arrrangement", "second_arrandament", "second_arrangegment", "second_arrandement", "second_arrangment", "second_arongment", "second_aranggment", "second_arrangeignment", "second_arrrangements", "second_arongement", "second_arrangament", "second_arangignment", "second_arrandements", "second_arongignment", "second_arrandignment", "second_arangament", "second_arranggment", "second_arangment", "second_arongament", "second_arrandment", "second_arrrangament", "second_arrangignment", "second_arangements", "second_arongements", "second_arrongement", "second_arrongament"]}}
{"code": " if len(sys.argv) == 1:\n      sys.stdin = open(\"C.in\")\n  else:\n      sys.stdin = open(sys.argv[1])\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  def get_ints():\n      return to_ints(raw_input())\n  \n  sys.setrecursionlimit(4000)\n  \n  def fill(rows, cols, mines):\n      seen = set()\n      visited = set()\n  \n      def search(numbered, zeros, min_numbered):\n          left = (rows * cols - mines) - len(numbered)\n          if left == 0:\n              raise StopIteration((numbered, zeros))\n          if left < 0:\n              return\n          for n in xrange(min_numbered, len(numbered)):\n              number = numbered[n]\n              if number in zeros:\n                  continue\n              row, col = number\n              neigh = []\n              if row > 0:\n                  if col > 0: neigh.append((row - 1, col - 1))\n                  neigh.append((row - 1, col))\n                  if col < cols - 1: neigh.append((row - 1, col + 1))\n              if col > 0: neigh.append((row, col - 1))\n              if col < cols - 1: neigh.append((row, col + 1))\n              if row < rows - 1:\n                  if col > 0: neigh.append((row + 1, col - 1))\n                  neigh.append((row + 1, col))\n                  if col < cols - 1: neigh.append((row + 1, col + 1))\n              neigh = list(set(neigh) - set(numbered))\n              zeros.add(number)\n              search(numbered + neigh, zeros, n + 1)\n              zeros.remove(number)\n  \n      try:\n          for row in xrange(rows):\n              for col in xrange(cols):\n                  search([(row, col)], set(), 0)\n      except StopIteration, e:\n          numbered, zeros = e.message\n          board = {}\n          for row, col in numbered + list(zeros):\n              board[row, col] = '.'\n          if zeros:\n              board[zeros.pop()] = 'c'\n          else: # case where first click is on a number\n              board[0, 0] = 'c'\n          out = ''\n          for row in xrange(rows):\n              for col in xrange(cols):\n                  out += board.get((row, col), '*')\n              out += '\n'\n          return out.strip()\n      return 'Impossible'\n  \n  n_cases = input()\n  for case in xrange(1, n_cases + 1):\n      rows, cols, mines = get_ints()\n  \n      result = fill(rows, cols, mines)\n  \n      print \"Case #%d:\" % case\n      print result\n", "substitutes": {"sys": ["kernel", "pc", "cs", "parse", "ys", "np", "hw", "run", "server", "cache", "site", "os", "net", "func", "ll", "module", "c", "self", "exec", "python", "wp", "shell", "proc", "sync", "parser", "Sys", "win", "host", "php", "input", "console", "py", "mac", "usr", "machine", "so", "linux", "process", "sim", "fs", "lib", "call", "p", "auto", "tty", "system", "util", "er", "bin", "script"], "stdin": ["stdint", " stdine", "STDine", "randout", "STDout", "liveint", "livein", "liveout", "randins", "stdins", "STDin", "stdine", "randin", "stdout", "liveins", " stdins", " stdout", "STDins", "STDint", " stdint", "randine"], "s": ["v", "e", "string", "l", "array", "su", "r", "o", "g", "c", "services", "ssl", "sb", "si", "second", "strings", "ss", "source", "m", "str", "S", "b", "p", "sv", "d", "sg", "ls", "a", "f", "data", "sf", "sl", "sq"], "rows": ["blocks", "rown", "groups", "holes", "planes", "ends", "ries", "features", "thumbnails", "fields", "levels", "cats", "keys", "grades", "ports", "sections", "orders", "locks", "checks", "files", "words", "rooms", "opens", "ips", "ows", "ins", "xes", "users", "heads", "rings", "values", "tests", "balls", "cells", "qs", "ids", "runs", "vers", "rs", "items", "obs", "flows", "events", "sels", "boards", "lines", "frames", "cases", "xs", "pages", "boxes", "tracks", "times", "views", "ks", "shows", "months"], "cols": ["columni", "keeps", "widthds", "periodops", "pathes", " colp", "colions", "Colrows", "widthpages", "periodpages", "keepc", "columnc", "keepgs", "widthops", " colions", "periodds", "roundi", "columnl", "Cols", "columnions", " colrows", "colgs", "colln", "colds", " coli", " colses", "Coli", "columngs", "collgs", "columnses", "columnrows", "columnes", " colops", "pathses", "pathn", "periods", "colls", "coll", "colp", "colrows", "columnn", " colpages", "keepn", "collc", "Coln", "columns", "coli", " coles", "roundl", "colc", "colops", "colses", " coll", "colpages", " colds", "Coles", "coles", "coln", "widths", "paths", "Colions", "rounds", "roundp", " coln", "columnp"], "mines": ["licongs", " minists", "mine", "Minions", "millongs", "minions", "tunises", "mineds", "minongs", "milleds", "tuneds", "milles", "minses", "minsions", " minions", "minse", "Minists", "tunongs", "Mines", "licises", "tunes", "liceds", "minises", "Mine", "lices", "millises", " mine", "minsists", "minists"], "seen": ["missing", "registered", "generated", "required", "finished", "ordered", "received", "hidden", "kept", "given", "known", "sent", "see", "master", "written", "expected", "changed", "lost", "found", " unseen", "selected", "served", "connected", "shown", "used", "confirmed", "visible", "started"], "visited": ["expored", "expitable", "posoved", "positable", "navored", "expoved", "visored", "navited", "posited", "posored", "visoved", "navitable", "visitable", "expited", "navoved"], "numbered": ["matched", "done", "complete", "meter", "interrupted", "modified", "updated", "collection", "coll", "zero", "specified", "umbers", "mentioned", "printed", "provided", "selected", "partial", "length", "initialized", "none", "random", "issued", "generated", "received", "kk", "que", "outer", "eled", "num", "ordering", "aligned", "found", "loaded", "lines", "filled", "runner", "zi", "even", "original", "blocks", "rown", "index", "required", "colored", "identified", "address", "zen", "shaped", "Numbers", "locked", "padding", "won", "bee", "total", "een", "inner", "meaning", "ln", "layout", "line", "nil", "umbered", "sized", "lined", "drawn", "named", "ordered", "winner", "given", "series", "signed", "written", "below", "initial", "balls", "joined", "nor", "sequence", "later", "running", "limited", "uno", "shown", "player", "rawn", "design", "started"], "zeros": ["zeroids", "zeroes", "zops", "zeroses", "azbos", "zesos", "zols", "infos", "zeols", "demotes", "azoes", "zesoes", "zotes", "azoids", "economos", "zersotes", "demoss", "zeops", "demops", "zersros", "zesols", "erops", "zersoses", "zo", "zoes", "zerso", "eroes", "ero", "zeos", "demols", "zenos", "zero", "zeoses", "zeross", "econombos", "zebos", "zerros", "infnos", "zersbos", "zersnos", "zeoids", "infros", "zersos", "zernos", "zeo", "zerops", "economops", "demoses", "demo", "demoes", "zerbos", "eros", "zos", "zerotes", "zersoss", "zeso", "eross", "zersops", "zersoids", "demos", "zerols", "zersols", "azos", "zeoes", "infoes", "economoes", "zersoes"], "min_numbered": ["minmmnumbered", "len_drawn", "miningnumbered", "len_numbered", "miningnumber", "minmmkept", "miningdrawn", "min_drawn", "len_number", "min_number", "len_named", "miningnamed", " min_drawn", "min_named", "min_kept", " min_kept", "minmmdrawn"], "left": ["index", "pl", "l", "no", "ner", "low", "lc", "right", "hidden", "li", "ell", "nl", "label", "two", "offset", "hide", "lo", "flo", "empty", "cle", "len", "coll", "counter", "fl", "initial", "size", "position", "le", "inner", "cost", "null", "found", "ln", "p", "roll", "last", "leave", "Left", "diff", "partial", "pos", "small", "ne", "full", "used", "cl", "cell", "none", "loc"], "n": ["x", "N", "j", "e", "nc", "ns", "index", "l", "no", "count", "na", "nb", "r", "w", "un", "o", "sn", "c", "len", "i", "nt", "size", "nor", "num", "nd", "nn", "m", "u", "pn", "ln", "non", "b", "p", "d", "nin", "z", "ne", "nan", "k", "nw", "f", "none", "network"], "number": ["x", "N", "version", "rown", "object", "string", "index", "no", "ner", "count", "address", "member", "Number", "month", "nb", "r", "un", "label", "two", "o", "group", "square", "collection", "div", "value", "c", "sn", "mult", "coll", "zero", "counter", "word", "nr", "name", "initial", "size", "position", "total", "nor", "letter", "num", "range", "column", "message", "nn", "null", "phone", "b", "block", "umber", "length", "line", "note", "ne", "error", "even", "none", "work", "node", "page"], "row": ["model", "ug", "feed", "coll", "head", "rc", "position", "range", "roll", "length", "rot", "cell", "hour", "pull", "bug", "sel", "our", "no", "chrom", "r", "round", "value", "keep", "name", "zip", "num", "ry", "ull", "block", "arrow", "form", "rank", "step", "rown", "rr", "la", "index", "user", "day", "month", "order", "group", "view", "tr", "ver", "box", "line", "cur", "port", "record", "x", "Row", "key", "ack", "ko", "ro", "right", "post", "w", "rh", "co", "c", "arch", "ow", "column", "year", "entry", "rid", "rect", "ew", "node", "loc", "page"], "col": ["pol", "fact", "ail", "log", "sec", "cond", "field", "ref", "cel", "div", "coll", "win", "near", "cm", "roll", "length", "ol", "rot", "cell", "bug", "poly", "cat", "sel", "cal", "lc", "core", "round", "cr", "lo", "keep", "byn", "cycle", "il", "con", "p", "block", "COL", "fc", "ct", "cor", "ac", "word", "fn", "index", "count", "day", "ell", "el", "Col", "rel", "fl", "y", "yl", "fil", "long", "ver", "ch", "pos", "line", "cur", "oy", "f", "inc", "icol", "x", "part", "min", "key", "pl", "child", "ill", "co", "path", "c", "conn", "val", "file", "column", "year", "int", "cy", "cl", "cp", "loc", " column", "char", "page"], "neigh": ["neoph", "nesffield", " neque", " neok", "naok", "seighth", "noph", " neear", "naoph", "gechel", "sealth", " nealth", " neighth", "pseigl", " neigl", "neigl", "noteoph", "naco", "seig", "pseco", "seok", "nauch", "nehood", "noigh", "nobor", "geig", "naiv", "neear", " nebor", "nauth", "geoph", "noteighth", " neoph", "eneigh", "ineoph", "neighth", "naigh", "neiv", "psealth", "geigh", "nffield", "neok", " neather", "eneider", "nchel", "seque", " neig", "neffield", " nechel", " nehood", "pseig", "pseuth", "noteig", "nesigh", "naig", "nesigl", "nig", "enealth", "neather", "noighth", "naque", "naider", "neque", "naear", "nalth", "nechel", "inealth", "neider", " neuch", "notebor", "nealth", "neuth", "neig", "ineiv", " neuth", "pseigh", "nebor", "neco", "ineigh", "psehood", " neco", "seigh", "neuch", "naffield", "seider", "naather", "geear", "seather", "nigh", "geque", "nesig", "nesalth", "eneig", "naalth", "notechel", "neshood", "nochel", "naighth", "seuch", " neiv", "noteigh"], "board": ["flow", "bug", "menu", " dashboard", "deck", "la", "object", "code", " clipboard", "che", "ko", "conference", "card", "control", "home", "table", " card", "bo", "holder", "channel", "que", "ward", "flo", "Board", "ban", "list", "bar", "craft", "loop", "buffer", "cart", "bird", "league", "sequence", "phone", "hole", "layout", "plan", "box", "block", "boarding", "boards", "boy", "comment", "land", "form", " boards", "bank", "video", "word"], "pop": ["remove", "reverse", "crop", "flush", "shift", "push", "top", "bottom", "head", "join", "highest", "max", "high", "delete", "clear", "peak", "close", "prev", "clone", "drop", "pick", "last", "strip", "stack", "back", "first", "op", "pull", "tail"]}}
{"code": " if len(sys.argv) == 1:\n      sys.stdin = open(\"A.in\")\n  else:\n      sys.stdin = open(sys.argv[1])\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  def get_ints():\n      return to_ints(raw_input())\n  \n  n_cases = input()\n  \n  for case in xrange(1, n_cases + 1):\n      a_row, = get_ints()\n      a_layout = [get_ints() for _ in range(4)]\n      b_row, = get_ints()\n      b_layout = [get_ints() for _ in range(4)]\n  \n      poss = set(a_layout[a_row - 1])\n      poss.intersection_update(b_layout[b_row - 1])\n  \n      result = 'Bad magician!'\n  \n      if len(poss) == 0:\n          result = 'Volunteer cheated!'\n      elif len(poss) == 1:\n          result = poss.pop()\n  \n      print \"Case #%d: %s\" % (case, result)\n", "substitutes": {"sys": ["gui", "kernel", "cs", "parse", "user", "ys", "np", "hw", "run", "server", "site", "os", "net", "ll", "std", "math", "module", "self", "window", "exec", "python", "sb", "wp", "shell", "proc", "Sys", "win", "host", "input", "py", "mac", "machine", "so", "linux", "windows", "process", "sim", "call", "fs", "pkg", "int", "system", "util", "script"], "stdin": ["STDdin", "stin", "builtinc", "STDout", "stdins", "STDin", "STDinc", "stdout", " stdins", " stdout", " stddin", "STDins", "builtin", "builtins", "stdinc", "builtout", "stout", " stdinc", "stins", "stddin"], "s": ["v", "e", "string", "l", "array", "args", "su", "r", "w", "o", "g", "c", "services", "ssl", "i", "sb", "sync", "si", "second", "strings", "ss", "source", "m", "S", "b", "p", "d", "sg", "ls", "a", "f", "sf", "sl", "sq"], "n_cases": ["nnumcases", "nnumsections", " n_rows", "nxcases", "n_cells", " n_cells", "nnumcells", "n_lines", " n_lines", "nxrows", "n_sections", "nxlines", "nnumrows", " n_sections", "n_rows", "nxcells"], "case": ["instance", "x", " Case", "sea", "bug", "code", " position", "slice", "address", "trial", "core", "ace", "ce", "bc", "catch", "count", " sub", "chance", "space", " c", "match", "ice", " code", "c", "mode", "i", "section", " loop", " example", " feat", " count", " cases", " seq", "race", " num", " d", "base", " x", " me", " p", " u", " fe", "length", " CASE", "client", "Case", "ase", "ide", "cases", " id", " line", "se", "test"], "a_row": [" a_rows", "a_entry", "a_rows", " a_col", "a_col", " a_entry"], "a_layout": ["b_shape", "b_col", "b_style", "a_layer", "a_style", "b_position", "b_layer", "a_col", "a_position", "a_shape"], "_": ["x", "flow", "all", "ip", "n", "un", "ning", "ing", "en", "val", "m", "non", "p", "d", "block", "ed", "line", "a", "al", "f"], "b_row": ["b__range", "b_col", "b__col", "bkcol", "bkcell", " b_cell", "bkrow", "b_range", "bklayout", "b__row", " b_range", "b_cell", " b_col", "b__layout"], "b_layout": ["b_section", "b_position", "a_range", "a_position", "b_range", "a_section"], "poss": ["ppos", "tpos", "expobs", " pOSS", "boss", "lposs", "Pense", " poses", "apose", "Pss", " pss", "bowers", "pens", "pOSS", "Posit", "bosit", "spore", "spose", "apore", " powers", " pore", "toss", "passes", "Pens", "toses", "Powers", "Passes", "bens", "lppos", "POSS", " posit", " pens", "lpasses", "apass", " ppos", "pose", "pore", "aposs", "posit", "powers", "tOSS", "lpense", "sposs", " passes", "Ppos", "expOSS", " pense", " pobs", "poses", "Poss", "pense", "pobs", "Pobs", "exposs", "pss", "expss", "spass", " pose", "Poses"], "result": ["step", "successful", "valid", "cash", "root", "err", "res", "warning", "summary", "Result", "grade", "report", "score", "our", "compl", "success", "default", "final", "catch", "su", "r", "status", "answer", "term", "match", "description", "date", "name", "rc", "msg", "reason", "ret", "message", "source", "effect", "results", "cup", "response", "diff", "error", "runner", "notice", "comment", "main", "data", "page", "test"]}}
{"code": " \n  NEIGHBOURS = [\n      (-1, -1), (-1, 0), (-1, 1),\n      ( 0, -1),          ( 0, 1),\n      ( 1, -1), ( 1, 0), ( 1, 1),\n  ]\n  \n  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n  \n  def valid(size, location, changes):\n      y, x = location\n      for y1, x1 in changes:\n          y1 += y\n          x1 += x\n          if y1 < 0 or y1 >= size[0]:\n              continue\n          if x1 < 0 or x1 >= size[1]:\n              continue\n          yield (y1, x1)\n  \n  def click(size, grid, location):\n      y, x = location\n      if grid[y][x] is 0:\n          return None\n  \n      grid = [row[:] for row in grid]\n      grid[y][x] = 0\n  \n      for y, x in valid(size, location, NEIGHBOURS):\n          if grid[y][x]:\n              grid[y][x] = False\n  \n      return grid\n  \n  def sweep(R, C, M):\n      grid = [[True] * C for _ in range(R)]\n      size = (R, C)\n  \n      if M + 1 == R * C:\n          grid[0][0] = False\n          return grid, (0, 0)\n  \n      states = []\n      for y in range(R):\n          for x in range(C):\n              location = (y, x)\n              states.append((click(size, grid, location), location))\n  \n      while states:\n          grid, location = states.pop(0)\n  \n          mines_count = sum([sum(row) for row in grid])\n          if mines_count == M:\n              return grid, location\n  \n          if mines_count < M:\n              continue\n  \n          for new_location in valid(size, location, NEIGHBOURS):\n              new_grid = click(size, grid, new_location)\n              if new_grid:\n                  states.insert(0, (new_grid, new_location))\n  \n      return None\n  \n  def validate(size, grid, location):\n  \n      result = [row[:] for row in grid]\n  \n      y, x = location\n      result[y][x] = sum([\n          grid[y1][x1]\n          for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n      ])\n      assert result[y][x] == 0\n  \n      seen = set([location])\n      locations = set([location])\n  \n      while locations:\n          location = locations.pop()\n          for y, x in valid(size, location, NEIGHBOURS):\n              assert grid[y][x] is not True\n              result[y][x] = sum([\n                  grid[y1][x1]\n                  for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n              ])\n              if result[y][x] == 0 and (y, x) not in seen:\n                  locations.add((y, x))\n                  seen.add((y, x))\n  \n      for row in result:\n          for col in row:\n              assert col is not False\n  \n      for y, row in enumerate(result):\n          output = ''\n          for x, col in enumerate(row):\n              if col is True:\n                  output += '*'\n              else:\n                  output += str(col)\n          print output\n  \n  \n  def process(case, R, C, M):\n      result = sweep(R, C, M)\n  \n      print 'Case #%d:' % (case + 1)\n      if not result:\n          print 'Impossible'\n          return\n  \n      grid, location = result\n      for y, row in enumerate(grid):\n          output = ''\n          for x, col in enumerate(row):\n              if (y, x) == location:\n                  output += 'c'\n              elif col:\n                  output += '*'\n              else:\n                  output += '.'\n          print output\n  \n  \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          R, C, M = map(int, sys.stdin.readline().split())\n          process(case, R, C, M)\n  \n      return\n      for case in range(100):\n          R = random.randrange(51) + 1\n          C = random.randrange(51) + 1\n          M = random.randrange(R * C - 1) + 1\n          process(case * 100000 + M - 1, R, C, M)\n  \n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"NEIGHBOURS": ["NEIGHBOWrs", "NEIGHEBours", "NEIGHEBOUTPS", "NEIGHBOWPS", "NEIGHBOWRS", "NEIGHNBOUPS", "NEIGHBOUNDS", "NEIGHBouRS", "NEIGHBOPLERS", "NEIGHBOOTS", "NEIGHBHOURS", "NEIGHBOUNLS", "NEIGHBOUPS", "NEIGHBHOUPS", "NEIGHBouTS", "NEIGHBOUTRS", "NEIGHNBOOLS", "NEIGHNBOUDS", "NEIGHBours", "NEIGHBOOPS", "NEIGHBHOUDS", "NEIGHEBOUTrs", "NEIGHBOOrs", "NEIGHEBouPS", "NEIGHNBOULS", "NEIGHEBOURT", "NEIGHBHOULS", "NEIGHBOODS", "NEIGHBOUNPS", "NEIGHEBOUTRS", "NEIGHBOPLEPS", "NEIGHBouPS", "NEIGHEBOUPS", "NEIGHEBOUrs", "NEIGHBOUTTS", "NEIGHBOUNRS", "NEIGHBOULS", "NEIGHEBouRT", "NEIGHBOORS", "NEIGHNBOOPS", "NEIGHNBOORS", "NEIGHBOUTPS", "NEIGHBOURT", "NEIGHNBOURS", "NEIGHBOUTrs", "NEIGHBOWRT", "NEIGHNBOODS", "NEIGHEBOUTTS", "NEIGHBouRT", "NEIGHBOPLERT", "NEIGHBOUrs", "NEIGHBOOLS", "NEIGHEBouRS", "NEIGHEBOUTS", "NEIGHBOUTS", "NEIGHEBOURS", "NEIGHBOUDS", "NEIGHBOPLErs"], "MOVES": ["MOVING", " MOUSes", "MOVes", "MATCHED", "MOVED", "MATCHING", " MOUSING", "MARKES", "MATCHes", "MOUSES", " MOVes", "MARKING", "MATCHES", "MARKes", "MARKED", " MOUSES", " MOVED", "MOUSING", "MOUSes", " MOUSED", "MOUSED", " MOVING"], "size": ["remote", "south", "engine", "area", "model", "activity", "ize", "course", "settings", "square", "storage", "action", "position", "unit", "SIZE", "speed", "source", "m", "cm", "chain", "content", "example", "Y", "time", "core", "member", "site", "edge", "mode", "center", "connection", "name", "large", "six", "function", "capacity", "city", "scale", "state", "form", "export", "ui", "external", "code", "address", "count", "day", "shape", "region", "ng", "style", "general", "uri", "ci", "small", "sized", "draw", "string", "grade", "cache", "Size", "sample", "status", "width", "empty", "c", "zone", "sum", "sync", "si", "security", "scene", "z", "year", "loc"], "location": ["remote", "feature", "Location", "south", "area", "model", "activity", "filename", "image", "place", "description", "collection", "storage", "position", "unit", "range", "command", "population", "m", "moving", "length", "auto", "cell", "content", "L", "layer", "instance", "Y", "definition", "l", "slice", "lc", "success", "member", "site", "X", "mode", "center", "connection", "selection", "message", "function", "response", "new", "error", "state", "point", "localhost", "operation", "address", "event", "shape", "folder", "region", "module", "section", "uri", "language", "layout", "d", "box", "ion", "division", "gallery", "LOC", "network", "direction", "draw", "move", "directory", "local", "home", "origin", "g", "c", "i", "density", "null", "generation", "community", "entry", "node", "loc", "station"], "changes": ["comments", "history", "change", "features", "grades", "fields", "status", "settings", "shape", "files", "Changes", "codes", "values", "actions", " moves", "objects", "changed", "places", "cells", "breaks", "rows", "steps", "marks", "moving", "items", "details", "events", "works", "results", "diff", "errors", "lines", "images", "xs", "content", "boxes", "maps", "dates"], "y": ["id", "game", "v", "sy", "t", "area", "vy", "ay", "yn", "m", "yx", "gy", "hy", "country", "service", "Y", "ym", "j", "ys", "n", "xy", "sky", "yd", "r", "story", "height", "my", "ry", "zy", "sim", "p", "ix", "ye", "yt", "q", "yi", "ady", "module", "type", "ya", "ci", "py", "yl", "b", "d", "ch", "uy", "client", "oy", "f", "hub", "e", "key", "yr", "ny", "yp", "w", "o", "yang", "yy", "c", "h", "i", "ory", "z", "ey", "year", "dy", "cy", "yo", "loc"], "x": ["id", "v", "t", "ay", "image", "position", "xc", "yx", "m", "ax", "xs", "sex", "content", "example", "Y", "j", "rx", "im", "l", "change", "xy", "n", "time", "r", "xxx", "X", "ice", "xml", "ex", "xp", "name", "xa", "my", "xt", "p", "xf", "ix", "wa", "ct", "index", "px", "xb", "q", "act", "xi", "event", "na", "create", "ady", "ya", "ng", "host", "view", "yl", "u", "dx", "cross", "pos", "f", "xe", "xx", "e", "key", "w", "width", "c", "h", "i", "column", "z", "int", "cy", "wx", "cl", "work", "loc", "exp"], "y1": ["xed", "yed", "Yed", "ey01", "ya1", " y3", " y0", "vyOne", "vy81", "vy1", "Y0", "ry2", "Y4", "Y2", "ya01", "vy2", "y2", "x81", " y4", "yOne", "ey81", "ry1", "x0", "ya0", " yed", " yOne", "ya2", "Y3", "Y1", " y2", "y0", "x2", "xOne", "y4", " y01", "y81", "ry3", "yaOne", "ey1", "ry4", "y3", "ya81", "y01", " y81"], "x1": ["xt2", "xt0", "z81", " x2", " xone", "z10", "xt1", "xx3", "xi2", "x3", " xOne", "xiOne", "xtone", "z2", "z1", "zone", " x81", "xi1", "X1", "z0", "y2", "xone", "x81", "xx1", "x10", "x0", " yOne", " x10", " y2", "x2", "y0", "y10", "xOne", "y81", "X\n", "X3", "yone", "y3", " x0"], "grid": ["remote", "game", "parent", "hold", "model", "gr", "activity", "feed", "image", "square", "div", "storage", "window", "unit", "range", "gap", "cm", "chain", "cell", "age", "content", "db", "house", "layer", "Grid", "bug", "gui", "rule", "site", "edge", "cfg", "connection", "plugin", "config", "num", "cells", "message", "gate", "function", "sim", "cube", "domain", "details", "block", "new", "scale", "back", "state", "contact", "form", "export", "point", "cart", "route", "flow", "all", " Grid", "multi", "query", "code", "address", "server", "cum", "group", "module", "update", "active", "static", "input", "uri", "general", "frame", "layout", "line", "client", "mid", "graph", "gallery", "gru", "data", "network", "valid", "draw", "move", "default", "grade", "ace", "cache", "tile", "status", "g", "dim", "sum", "scope", "sync", "file", "lock", "security", "column", "debug", "ed", "link", "main", "node", "page", "station", " grids"], "row": ["flow", "bug", "Row", "key", "query", "user", "ro", "area", "model", "day", "up", "server", "month", "r", "post", "field", "container", "feed", "image", "status", "order", "group", "round", "record", "ward", "co", "week", "module", "element", "zero", "way", "wheel", "item", "range", "column", "view", "build", "rows", "frame", "device", "roll", "box", "block", "line", "arrow", "entry", "year", "client", "scale", "error", "link", "state", "cell", "oy", "form", "node", "port", "page"], "R": ["Rh", "TR", "N", "Y", "T", "GR", "Rs", "P", "RE", "MR", "CR", "RH", "r", "JR", "E", "H", "SR", "RM", "RO", "K", "X", "RW", "ER", "Q", "DR", "RS", "B", "D", "F", "Cr", "RG", "O", "S", "RR", "V", "NR", "A", "L", "U", "RA"], "C": ["N", "Y", "T", "AC", "P", "DC", "CM", "CR", "E", "H", "G", "Size", "CE", "W", "K", "X", "c", "Q", "CC", "CS", "I", "B", "Cu", "D", "F", "CI", "CP", "O", "S", "Z", "CL", "EC", "V", "CU", "CN", "A", "L", "U"], "M": ["N", "Y", "T", "P", "MS", "J", "CM", "r", "U", "MT", "E", "SM", "G", "H", "RM", "W", "K", "X", "NM", "Q", "I", "B", "D", "F", "LM", "m", "O", "S", "MN", "MC", "A", "L", "V"], "_": ["Y", "j", "q", "oc", "ck", "X", "p", "new", "cc", "f", "ac"], "states": ["plays", "blocks", "groups", "points", "south", "models", "args", "features", "keys", "States", "ports", "modules", "ages", "status", "settings", "sections", "files", "locks", "rates", "services", "storage", "s", "ins", "active", "parts", "sites", "actions", "gs", "cells", "ids", "plugins", "strings", "rows", "runs", "stats", "steps", "relations", "items", "details", "flows", "works", "results", "events", "rules", "stores", "powers", "reports", "lines", "images", "errors", "charges", "state", "chains", "jobs", "uses"], "mines_count": ["minises_Count", "mines_sum", "minesh_child", "mines_dist", "mines_code", "minises_len", "minesh_count", "mines_Count", "minES_sum", "minES_count", "minises_count", "minES_code", "mines_len", "mines_child", "minesh_dist"], "new_location": [" new_loc", "newJloc", "New_region", "New_position", " new_address", "new67module", " new_position", "New_location", "new67address", "newJlocation", " new_module", "new_address", "new_region", "new_site", "newJaddress", "new67loc", "New_loc", " new_site", "new_position", "new_loc", "new67location", "newJmodule", "new_module"], "new_grid": ["newnetvolume", "new_storage", " new_state", "newjlocation", "newsstate", "newnetgrid", "newjgrid", "new_volume", "newsvolume", "new_media", "newsgrid", "new_row", "newjmodule", " new_module", "newnetstate", "newnetstorage", "New_state", " new_storage", "New_media", " new_volume", "New_row", "new_state", "New_grid", "newjstate", "new_module", "newsstorage"], "result": ["root", "err", "res", "done", "Result", "product", "report", "default", "success", "final", "table", "complete", "r", "status", "group", "match", "progress", "master", "sum", "range", " Result", "source", "search", "found", "function", "results", "response", "diff", "new", "dist", "now", "content", "data", "page", "test"]}}
{"code": " \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          row1 = int(sys.stdin.readline())\n          arrangement1 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen1 = set(arrangement1[row1 - 1])\n  \n          row2 = int(sys.stdin.readline())\n          arrangement2 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen2 = set(arrangement2[row2 - 1])\n  \n          chosen = chosen1 & chosen2\n  \n          if not chosen:\n              print 'Case #%d: Volunteer cheated!' % (case + 1)\n          elif len(chosen) != 1:\n              print 'Case #%d: Bad magician!' % (case + 1)\n          else:\n              print 'Case #%d: %d' % (case + 1, chosen.pop())\n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"cases": ["comments", "blocks", "groups", "tips", "changes", "ends", "count", "trial", "features", "cycles", "sections", "settings", "shape", "rooms", "classes", "its", "c", "section", "values", "tests", "size", "cells", "runs", "rows", "steps", "details", "events", "types", "pieces", "days", "ls", "length", "lines", "Case", "ase", "chains", "times", "loc", "shows", "ches", "test"], "case": ["instance", "x", "step", "id", "sea", "bug", "hyp", "uc", "key", " i", "patch", "code", "default", "no", "slice", "character", "count", "time", "ace", "trial", "catch", "address", "month", "order", "shape", "space", "path", "match", "ice", "c", "connection", "set", "type", "i", "section", "name", "size", "row", "position", "config", "line", "length", "division", "client", "Case", "condition", "se", "test"], "row1": ["rowFirst", "server2", "bug2", "col1", "col3", "rowOne", "case2", "colFirst", "bugD", "server1", "rowD", "bug1", " rowOne", "case3", "caseOne", "serverD", "colOne", "row3", " row3", "col2", "bugFirst", "serverFirst", "colD", "case1"], "arrangement1": ["arranglement0", "arranglementA", "arrongmentA", "arrongment1", "arrangment1", "arrangment81", "arrangmentOne", "arrongement0", "arrangeements81", "arrangements2", "arrangmentA", "arrangeements1", "arrangements81", "arranglement2", "arrangement81", "arrangament0", "arranglement1", "arrangeements2", "arrangeement1", "arrangeementsOne", "arrangation2", "arrongementA", "arrangamentA", "arrangementsOne", "arrangeementOne", "arrangeement81", "arrangation1", "arrangament1", "arrongement2", "arrangements1", "arrongment2", "arrangation81", "arrangment2", "arrangementOne", "arrongement1", "arrangment0", "arrangement0", "arrangationOne", "arrangeement2", "arrongment0", "arrangementA", "arrangament2"], "_": ["x", "all", "ip", "n", "count", "time", "get", "ay", "un", "place", "ing", "g", "c", "s", "val", "out", "m", "non", "p", "d", "block", "__", "a", "k", "f", "ac"], "chosen1": ["choin01", "anchosenone", "chosen0", "chosed01", "chosingOne", "choosen0", "chosed2", "choren2", "choosen01", "chosing3", "chosenone", "chosingone", "chosenOne", "anchosen3", "chosed1", "choin3", "chosing1", "anchoinone", "choinOne", "choosed1", "chosed3", "choosed2", "choosed0", "anchosenOne", "anchosen1", "choren1", "chosen3", "chosedOne", "chosen01", "choin2", "anchoinOne", "choosed01", "chosedone", "choinone", "choren01", "anchoin1", "choin1", "choren0", "chosed0", "choin0", "choosen2", "anchoin3", "choosen1"], "row2": ["blocksecond", "ry22", "row62", "ranksecond", "rank22", "rowTwo", "rowsecond", "ry2", " row62", "ry62", " row22", "blockTwo", "rankTwo", "owTwo", "ow2", "row22", "owSecond", "rank02", "block2", "owsecond", "rank62", "rank2", "rowSecond", " row02", "rankSecond", "blockSecond", "row02", "ry02"], "arrangement2": ["arrangEMENT2", "arrangEMENT0", "arrongment1", "arrangment4", "arrangment1", "arrongement0", "arrangEMENT4", "arrangements2", "arranguation4", "arranguation2", "arrangment3", "arrongment4", "arrangements4", "arrongment3", "arranguation1", "arranguation0", "arrongement4", "arrangEMENT1", "arrangements1", "arrongement2", "arrongment2", "arrangEMENT3", "arrangment2", "arrangement4", "arrangement3", "arrangements3", "arrongement1", "arrangment0", "arrangement0", "arrongement3", "arrongment0"], "chosen2": [" chosentwo", "chosen4", "chosed02", "chern3", " chosen4", "cheosen1", "chosed4", "chern2", " chonne4", " chonne2", "chonnetwo", "choser2", "chosed2", "choser52", "chosentwo", "choser1", "chonne4", "chosen02", " chonnetwo", "cheosen3", " chosen02", "chern02", "chown3", "cheoser52", "cheosen2", "chown1", "chown52", "chosen3", "cheosen52", "chosedtwo", "chonne2", "chonne02", "chosen52", "cheoser3", "chern52", " chonne02", "chown2", "choser3", "cheoser2", "chern1", "cheoser1", "chern4", "cherntwo"], "chosen": ["echoin", "echosen", "choren", "CHoin", "echisson", " choin", "candosen", "chuc", "Choin", "candoin", "CHisson", "chnoser", "cherlied", " choren", "chouc", "chooren", "CHosen", "Chosen", " chitched", " chisson", "CHosing", "choosen", "chlied", "chisson", "cheroren", "Chitched", "choin", "chnoin", "chaoser", "chaosen", "echosing", " choser", "chaoren", "chnosen", "cherosen", "cheroin", "chitched", "chooser", "Choser", "chauc", " chlied", "candlied", "choser", "chnitched", " chuc", " chosing", "chosing", "candoren"]}}
{"code": " \n  T = int(raw_input())\n  \n  def generate(R, C, a, sw):\n      if sw:\n          R, C = C, R\n      res = [['*']*C for i in xrange(R)]\n      for i in xrange(len(a)):\n          for j in xrange(a[i]):\n              if sw:\n                  res[j][i] = '.'\n              else:\n                  res[i][j] = '.'\n      res[0][0] = 'c'\n      return str(res)[2:-2].replace(' ', '').replace(\"'\",'').replace('[', '').replace('],','\n').replace(',', '')\n  \n  \n  def solveEq(k, s, x1):\n      if 2*(x1 + k - 2) > s or k*x1 < s:\n          return None\n      r = [0]*k\n      r[0] = r[1] = x1\n      s -= 2*x1\n      for i in xrange(k-2, 0, -1):\n          t = min(x1, s - 2*i + 2)\n          r[k-i] = t\n          s -= t\n      return r\n  \n  def solve(R, C, M):\n      S = R*C\n      nm = S - M\n      if R == 1 or C == 1:\n          if R == 1:\n              return '*'*M + '.'*(S-M-1) + 'c'\n          else:\n              return '*\n'*M + '.\n'*(S-M-1) + 'c'\n      else:\n          sw = False\n          if R > C:\n              R, C = C, R\n              sw = True\n          if nm == 2 or nm == 3 or nm == 5 or nm == 7 or (R == 2 and nm%2 == 1 and nm > 1):\n              return \"Impossible\"\n          if nm == 1:\n              return generate(R, C, [1], sw)\n          for k in xrange(2, R+1):\n              for x1 in xrange(2, C+1):\n                  r = solveEq(k, nm, x1)\n                  if r != None:\n                      return generate(R, C, r, sw)\n          return \"Something wrong\"\n  \n  for z in xrange(T):\n      c, f, x = map(int, raw_input().split())\n      print \"Case #%d:\n%s\" % (z+1, solve(c, f, x))\n", "substitutes": {"T": ["TR", "N", "Y", "TN", "P", "G", "H", "W", "K", "X", "Time", "TC", "NT", "TM", "I", "B", "D", "F", "O", "TT", "Z", "TB", "A", "L", "V"], "R": ["Rh", "TR", "N", "Y", "Tr", "GR", "Rs", "Range", "P", "MR", "J", "RH", "CR", "Re", "RT", "JR", "E", "H", "G", "SR", "RM", "W", "RO", "K", "X", "RW", "Q", "DR", "ARR", "RS", "I", "B", "Run", "RP", "D", "F", "RG", "Ra", "rb", "O", "RN", "RR", "V", "Res", "NR", "KR", "A", "L", "U", "RA"], "C": ["N", "NC", "Y", "SC", "Cs", "P", "VC", "DC", "CM", "CR", "U", "E", "CE", "H", "G", "W", " c", "K", "X", "c", "Sc", "CA", "Co", "YC", "CO", "Cos", "CC", "Q", "CS", "Cu", "B", "I", "KC", "CI", "D", "F", "Ch", "O", "CT", "CL", "EC", "V", "NR", "CU", "CN", "A", "L", "Con"], "a": ["x", "am", "all", "e", "sa", "array", "n", "area", "args", "ca", "na", "w", "ae", "aaa", "at", "o", "c", "ar", "aa", "alpha", "au", "an", "m", "u", "ai", "ra", "p", "b", "da", "aj", "z", "ab", "wa", "arr", "f", "Na", "ac", "A"], "sw": ["x", "est", "nc", "wrap", "sa", "sp", "im", "default", "array", "oss", "hw", "su", "stream", "w", "igh", "wt", "rh", " SW", "W", "cr", "sn", "rew", "tw", "sh", "sc", "ww", "h", "RW", "zero", "hop", "coll", "wp", "ws", "sync", "ng", "row", "ow", "sr", "switch", " Sw", "iw", "zip", "wh", "wn", "sk", "cv", "null", "WS", "rw", "sm", "response", "wa", "SW", "ew", "cc", "wx", "now", "nw", "WR", "sf", "sl", "Sw"], "res": ["x", "remote", "blocks", "e", "mr", "ons", "err", "ns", "cs", "Rs", "result", "ras", "br", "rss", "eps", "gr", "args", "q", "pres", "os", "rh", "sol", " results", "cr", "RES", "rez", "c", "ms", "bs", "rev", "rc", "ret", "reg", "rest", "qs", "runs", "rows", "req", "rs", "resolution", "p", "results", "response", "rep", "rem", "Res", "es", " Res", "vals", "arr", "re", "data", "resp", "ris"], "i": ["ji", "x", "id", "ii", "v", "e", "index", "im", "ip", "l", "ik", "n", "mi", "phi", "ei", "q", "xi", "yi", "li", "iu", "o", "g", "c", "ti", "ie", "qi", "gi", "si", "y", "I", "ci", "ini", "iq", "u", "m", "ai", "b", "p", "d", "z", "pi", "int", "ij", "di", "zi", "f", "io", "ui"], "j": ["ji", "x", "v", "e", "ii", "je", "l", "br", "n", "ind", "q", "J", "jj", "xi", "li", "iu", "jc", "o", "g", "c", " ii", "ie", "gi", "oj", "jp", "kj", "jl", "y", "si", "IJ", "ci", "ni", "u", "str", "b", "p", "d", "aj", "z", "ja", "ij", "f", "uj"], "k": ["x", "N", "v", "key", "ky", "ko", "l", "n", "q", "ok", "w", "kk", "ak", "ck", "it", "o", "uk", "g", "K", "ku", "c", "h", "ke", "y", "max", "sk", "m", "u", "b", "p", "kin", "d", "kw", "z", "ch", "tk", "mk", "_", "f", "ks"], "s": ["x", "ps", "v", "e", "ns", "sup", "sa", "cs", "ds", "l", "south", "n", "sec", "se", "su", "w", "sym", "os", "o", "g", "c", "h", "ms", "ws", "sync", "y", "si", "gs", "second", "sk", "ss", "m", "u", "sign", "rs", "ats", "b", "p", "span", "d", "sv", "tp", "z", "ls", "es", "ts", "xs", "f", "ks", "sq"], "x1": ["x4", "z4", " xone", " x2", "Xn", "xn", "X2", "xi2", "X4", "p2", "z2", "z1", "xione", "f0", "xi1", "X1", "Xone", "X0", "xi0", "xone", "y2", "f1", "XN", " x4", "x0", "wn", "w2", "y0", "x2", "y1", "w1", "zN", " xN", "p0", "p1", " x0", " xn", "xN"], "r": ["x", "mr", "e", "v", "rr", "err", "fr", "Rs", "result", "l", "br", "n", "ru", "P", "q", "right", "w", "rt", "rh", "o", "lr", "g", "cr", "c", "h", "kr", "ar", "ir", "nr", "rc", "nor", "sr", "range", "pr", "ur", "hr", "m", "u", "rb", "rs", "b", "p", "d", "z", "RR", "rg", "re", "f", "er"], "t": ["x", "v", "e", "l", "tor", "n", "tf", "w", "target", "o", "te", "at", "tt", "g", "c", "h", "ti", "wt", "total", "y", "ta", "ot", "m", "u", "b", "p", "tp", "d", "z", "tm", "new", "ts", "f", "test"], "M": ["N", "Y", "MD", "P", "n", "MQ", "J", "CM", "Ms", "U", "E", "G", "H", "MI", "W", "DM", "K", "X", "NM", "Mo", "Q", "I", "B", "D", "F", "GM", "JM", "LM", "m", "O", "Z", "MN", "ME", "MC", "A", "L", "V"], "S": ["N", "Y", "SC", "NS", "Rs", "P", "n", "Single", "Su", "SA", "SE", "U", "E", "G", "H", "SR", "W", "K", "X", "SL", "SS", "Q", "RS", "I", "B", "D", "F", "O", "FS", "SH", "A", "L", "V", "SU"], "nm": [" N", "N", "ym", "mr", "all", "NC", "nc", "ns", "NL", "NS", " n", "TN", "PM", "mi", "np", "n", "km", "ny", "CM", "Ms", "mm", "nl", "Num", "RM", "wm", "mn", "me", "rm", "c", "NM", "ms", "bm", "nv", "nr", "NT", "nt", "cn", "nor", "Ns", "nom", "CW", "num", "range", "arm", "ni", "LM", "fm", "m", "cm", "nn", "MN", "sm", "pm", "nu", "ne", "md", "mid", "NR", "dm", " NM", "NW", "nw", "rn"]}}
{"code": "T = int(raw_input())\n  \n  def readSq(n):\n      res = []\n      for i in xrange(n):\n          res.append(set(map(int, raw_input().split())))\n      return res\n  \n  def solve():\n      a1 = int(raw_input())\n      s1 = readSq(4)\n      a2 = int(raw_input())\n      s2 = readSq(4)\n      ans = s1[a1-1] & s2[a2-1]\n      if len(ans) == 0:\n          return \"Volunteer cheated!\"\n      if len(ans) > 1:\n          return \"Bad magician!\"\n      return str(list(ans)[0])\n  \n  for z in xrange(T):\n      print \"Case #%d: %s\" % (z+1, solve())\n", "substitutes": {"T": ["N", "Y", "Ts", "TN", "t", "P", "TH", "TF", "TS", "E", "H", "G", "W", "K", "X", "Time", "R", "TC", "TW", "NT", "Q", "I", "B", "D", "F", "WT", "O", "S", "TT", "Z", "C", "M", "A", "L", "V"], "n": ["x", "N", "j", "e", "ns", "l", "t", "nb", "r", "w", "net", "o", "sn", "c", "s", "en", "y", "num", "m", "u", "b", "p", "d", "ne", "k", "f"], "res": ["ps", "blocks", "Rs", "cs", "result", "ras", "Result", "q", "args", "right", "pres", "r", "os", "sol", " results", "ES", "RES", "rez", "s", "R", "resources", "ret", "RS", "reg", "out", "ids", "runs", "str", "rs", "resolution", "details", "powers", "results", "response", "Results", "Res", " Res", "vals", "arr", "re", "_", "resp"], "i": ["id", "j", "ii", "ip", "ind", "ei", "q", "xi", "li", "iu", "c", "ti", "ie", "gi", " ii", "y", "I", " I", "ni", "ci", "ini", "iq", "ai", "p", "ix", "f"], "a1": [" aOne", "an3", "aOne", "A1", "aone", "A3", "aa1", " aone", "aaOne", "as3", "an1", "sa1", "Aone", "aaone", "anone", "as1", "AOne", " a3", "saone", "aa3", "anOne", "a3", "saOne", "sa3", "asone", "asOne"], "s1": ["S1", "pone", "aone", "S2", "p2", "sa13", "a13", "sone", "sa1", "sa2", "a01", "p01", "s13", "saone", "Sone", "S01", " sone", "p1", "s01", " s13"], "a2": ["b5", " aTwo", "a02", "s4", "anTwo", "aTwo", "b02", "an02", "sa1", "sa2", "an5", " a5", "bTwo", "an2", "a4", " a4", "sa4", "b2", "a5", " a02"], "s2": ["atwo", "an3", "ans5", "anstwo", " s8", "as5", "astwo", "as2", "ans1", "an1", "s5", "as1", "ans2", "a3", "s3", "an2", "a8", " s3", "s8", "a5", "stwo", "an8"], "ans": ["ens", "ams", "oa", "ons", "ann", "aus", "ns", "ds", "anne", "ras", "ents", "AN", "args", "atan", "reads", "na", "ars", "aning", "An", "os", "lan", "ants", "s", "ins", "amps", "anas", "antis", "nas", "anus", "anc", "ana", "an", "sk", "ids", "can", "ant", "ats", "ai", "ays", "plan", "span", "cross", "anon", "ani", "aned", "san", "a", "cases", "ANS", "ions", "scan", "anned"], "z": ["x", "za", "j", "v", "e", "ze", "t", "ind", "q", "zen", "zz", "ld", "ice", "c", "zh", "zone", "y", "az", "zip", "ez", "gz", "u", "iz", "zer", "zy", "tz", "Z", "p", "d", "int", "a", "zi", "cz", "k", "nz", " Z"]}}
{"code": " \n  T = int(input())\n  \n  for n in range(1, T+1):\n      print(\"Case #%d:\" % n)\n      (R, C, M) = (int(x) for x in input().split())\n      dots = R*C - M\n      if M == 0:\n          print(\"\n\".join([\"c\"+(C-1)*\".\"] + (R-1)*[C*\".\"]))\n      elif dots == 0:\n          print(\"Impossible\")\n      elif R == 1:\n          assert C - M > 0\n          print(\"c\"+(C-M-1)*\".\"+M*\"*\")\n      elif C == 1:\n          assert R - M > 0\n          print(\"c\n\"+(R-M-1)*\".\n\"+M*\"*\n\", end='')\n      elif dots == 1:\n          print(\"\n\".join([\"c\"+ (C-1)*\"*\"] + (R-1)*[C*\"*\"]))\n      elif dots > 3:\n          if (dots == 5) or (dots == 7):\n              print(\"Impossible\")\n              continue\n          if (R == 2) or (C == 2):\n              if dots%2 != 0 :\n                  print(\"Impossible\")\n                  continue\n              elif R == 2:\n                  l = int(dots/2)\n                  print(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\n                  print(l*\".\"+(C-l)*\"*\")\n                  continue\n              elif C == 2:\n                  l = int(dots/2)\n                  print(\"c.\")\n                  print((l-1)*\"..\n\", end='')\n                  print(int(M/2)*\"**\n\", end='')\n                  continue\n          (lines, extra) = divmod(dots, C)\n          temp = []\n          if (lines >= 2) and (extra != 1):\n              temp.append(\"c\"+(C-1)*\".\")\n              temp.extend((lines-1)*[C*\".\"])\n              temp.append(extra*\".\"+(C-extra)*\"*\")\n              temp.extend((R-lines-1)*[C*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif (lines > 2) and (extra == 1):\n              temp.append(\"c\"+(C-1)*\".\")\n              temp.extend((lines-2)*[C*\".\"])\n              temp.append((C-1)*\".\"+\"*\")\n              temp.append(\"..\"+ (C-2)*\"*\")\n              temp.extend((R-lines-1)*[C*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif (lines == 2) and (extra == 1):\n              temp.append(\"c\"+(C-2)*\".\"+\"*\")\n              temp.append((C-1)*\".\"+\"*\")\n              temp.append(3*\".\"+(C-3)*\"*\")\n              temp.extend((R-3)*[C*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif lines < 2:\n              (l, rem) = divmod(dots, 2)\n              if rem == 1:\n                  l -= 1\n                  rem += 2\n              temp.append(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\n              temp.append(l*\".\"+(C-l)*\"*\")\n              temp.append(rem*\".\"+(C-rem)*\"*\")\n              temp.extend( (R-3)*[ C*\"*\" ])\n              print(\"\n\".join(temp))\n              continue\n      else:\n          print(\"Impossible\")\n  \n", "substitutes": {"T": [" N", "N", "Y", "TN", "t", "P", "time", "TS", "Length", "E", "H", "G", "W", "K", "X", "Time", "TC", "NT", "I", "B", "D", "F", "WT", " t", "O", "S", "TT", "Z", "TB", "A", "L", "V"], "n": [" N", "N", "j", "v", "e", "ns", "nc", "t", "na", "r", "w", "un", "o", "g", "c", "s", "i", "en", "nt", "y", "Ns", "ot", "num", "nd", "u", "nn", "m", "ln", "b", "p", "d", "z", "a", "k", "f"], "R": ["UR", "Rh", "Y", "N", "GR", "Rs", "P", "RE", "MR", "J", "CR", "RT", "Re", "r", "E", "G", "H", "SR", "RM", "W", "RO", "K", "X", "c", "Co", "RW", "ER", "Q", "DR", "RS", "Rec", "B", "RP", "AR", "D", "F", "RC", "RG", "Cr", "IR", "O", "RN", "RL", "LR", "S", "rs", "RR", "V", "NR", "A", "L", "U", "RA"], "C": ["Y", "N", "NC", "SC", "CNN", "AC", "Cs", "P", "VC", "count", "DC", "CM", "Cl", "CR", "CF", "r", "CD", "Length", "E", "CE", "H", "G", "W", "CA", "K", "X", "c", "Co", "Sc", "YC", "LINE", "JC", "CV", "CC", "Q", "LC", "CS", "Cu", "B", "I", "D", "CI", "F", "RC", "Cr", "Ch", "CCC", "CT", "O", "S", "CL", "EC", "MC", "V", "CU", "Count", "CN", "Code", "A", "L", "U"], "M": ["Y", "N", "MD", "P", "MQ", "MR", "MO", "J", "CM", "r", "U", "MT", "E", "SM", "G", "MI", "H", "MX", "RM", "W", "DM", "AM", "K", "X", "Sl", "Q", "ML", "I", "B", "MF", "D", "F", "LM", "m", "O", "S", "MA", "Z", "MN", "MC", "IM", "Line", "A", "L", "V"], "x": ["rx", "xxxxxxxx", "xe", "xx", "v", "e", "j", "xb", "t", "xy", "q", "xi", "r", "w", "xxxx", "xxx", "g", "X", "c", "ex", "i", "h", "ux", "xp", "y", "xa", "xc", "m", "u", "b", "p", "xd", "xf", "d", "z", "ax", "wx", "xs", "f"], "dots": ["tot", "mdotted", "Dods", "mdots", "dods", "didods", "dumbers", "didumbers", "didots", " dott", "Dongs", "indOTS", "indots", "dongs", "sdott", "dops", "tOTS", " dotted", "ddots", "didot", "lotes", "longs", "Dashes", "dips", " drots", "sdods", "dotted", " dongs", "dashes", "bOTS", "Dots", "dugs", "drots", "mots", "bugs", "potted", "Dips", "sdots", "Drots", "tiffs", "ddashes", "diffs", " dists", "Dot", "dOTS", " diffs", "Dotted", "tots", "indugs", "tops", "Dumbers", "Dugs", "dotes", "dott", "mashes", "pot", "Dists", "tets", " dashes", "ddotted", "lots", "pots", "Diffs", "mOTS", " dot", " dips", "lOTS", "mdOTS", "dot", "sdumbers", " dops", "sdOTS", "sdot", "tips", " dumbers", "ddOTS", "Dotes", "bots", "indrots", "DOTS", "pOTS", "brots", "mdot", "motes", " dOTS", "Dets", " dets", "dists", "Dott", "Dops", "lashes", "dets"], "l": ["j", "v", "e", "dl", "pl", "t", "lc", " L", "lu", "r", "li", "ell", "nl", "w", "el", "o", "ll", "c", "s", "h", "i", "fl", "ul", "le", "il", "m", "u", "ln", "b", "p", "d", "z", "ls", "line", "ol", "kl", "lin", "al", "f", "loc", "sl", "L"], "end": ["est", "id", "ent", "begin", "object", "End", "index", "END", "append", "add", "ends", "anch", "output", "event", "enter", "post", " End", "edge", "stop", "ending", "it", "then", "offset", "ended", "init", "set", "type", "en", "name", "use", "ad", "size", "start", "rest", "inner", "method", "ion", "pos", "length", "entry", "error", "send", "exit", "tail"], "lines": ["notes", "N", "comments", "blocks", "v", "ns", "planes", "points", "NL", "inline", "Rs", "models", "log", " Lines", "ends", "limits", "levels", "cycles", "checks", "links", "c", "s", "h", "i", "ins", "ines", "codes", "size", "zip", "cells", "letters", "strings", "breaks", "lins", "rows", "runs", "LR", "rs", "b", "p", "d", "z", "ls", "line", "length", "lin", "cases", "Line", "pages", "f", "times", "LINE"], "extra": ["random", "missing", "original", "e", "external", "inline", "err", "Extra", "ignore", "ras", "default", "other", "area", "q", "args", "exclusive", "origin", "order", "aux", "empty", "regular", "special", "ex", "optional", " extras", "info", "after", "EXT", "outer", "needed", "white", "internal", "alpha", "magic", "size", "rc", "max", "margin", "zip", "config", "skip", "fake", "second", "inner", "custom", "current", "base", "ext", "border", "diff", "line", "radius", "length", "ne", "error", "di", "next", "added", "background", "plus", "data", "wrapper", " Extra"], "temp": ["j", "v", "key", "err", "multi", "index", "other", "options", "get", "output", "cache", "holder", "tem", "copy", "Temp", "body", "edit", "empty", "init", "let", "list", "template", "white", "size", "unit", "buffer", "tmp", "zip", "left", "fake", "clean", "inner", "adj", "current", "base", "tree", "partial", "response", "diff", "note", "full", "stack", "mini", "now", "flat", "iter", "api", "export", "pre", "test"]}}
{"code": " ncases = int(input())\n  \n  for n in range(1, ncases+1):\n      row = int(input())\n      for m in range(1, 5):\n          if m == row:\n              r1list = [int(x) for x in input().split()]\n              assert len(r1list) == 4\n          else:\n              tmp = input()\n      row = int(input())\n      for m in range(1,5):\n          if m == row:\n              r2list = [int(x) for x in input().split()]\n              assert len(r1list) == 4\n          else:\n              tmp = input()\n      nset = set(r1list) & set(r2list)\n      if len(nset) == 1:\n          print(\"Case #%d:\" % n, nset.pop())\n      elif len(nset) > 1:\n          print(\"Case #%d:\" % n, \"Bad magician!\")\n      else:\n          print(\"Case #%d:\" % n, \"Volunteer cheated!\")\n", "substitutes": {"ncases": ["nsases", "lcasts", "bcases", "ncased", "lcases", "aucases", "bcamps", "bcasing", "NCased", "nsamps", "lcasing", "nsasing", "ncasts", "nvases", "nvamps", "aucased", "nvasing", "aucasing", "NCasing", "ncasing", "ncamps", "lcased", "aucasts", "nvased", "nsased", "NCasts", "bcased", "NCases"], "n": ["N", "j", "v", "min", "ns", "nc", "e", "l", "t", "na", "nb", "r", "w", "un", "net", "o", "on", "mn", "c", "s", "i", "en", "name", "nt", "cn", "max", "y", "num", "nn", "u", "pn", "ln", "p", "nu", "d", "z", "nm", "k", "f", "rn"], "row": ["instance", "bug", "Row", "min", "key", "ack", "index", "user", "no", "ro", "end", "run", "right", "ok", "server", "month", "pri", "r", "w", "channel", "feed", "col", "order", "where", "group", "round", "one", "c", "batch", "micro", "i", "raw", "mod", "ow", "max", "y", "uu", "num", "skip", "range", "rows", "ry", "tr", "roll", "block", "auto", "entry", "year", "dy", "error", "cell", "k", "f", "node", "port", "page"], "m": ["id", "ym", "mu", "v", "min", "e", "am", "l", "mi", "r", "mm", "col", "o", "mn", "bm", "c", "ms", "rm", "h", "i", "mult", "om", "y", "num", "an", "fm", "cm", "u", "b", "p", "sm", "d", "pm", "um", "z", "nm", "dm", "k", "f", "ma", "M", "mo"], "r1list": ["R1list", "R1string", "r0set", "r3set", "r1cont", "r3List", "r1string", "r0List", "R2set", "R2string", "R1List", "r1set", "r1List", "r5list", "r7List", "R1cont", "r9list", "r3list", "r0list", "R1set", "r9bl", " r3list", "r2cont", "r9set", " r1set", " r3set", "R2bl", "R2list", "r6list", "r01bl", "r1bl", "r6cont", "r2bl", "R1bl", " r3List", " r1List", "r5string", "r01set", "r5cont", "r6string", "r7set", "R2List", "r2List", "r01List", "r2set", "r7list", "r01list", "R2cont", "r9List", "r6List", "r5List", "r2string"], "x": ["id", "e", "v", "xx", "px", "xb", "t", "q", "xi", "event", "xxxx", "w", "r", "xxx", "X", "c", "ex", "i", "h", "xes", "ww", "bit", "y", "num", "xc", "xt", "u", "ph", "b", "p", "xf", "d", "ch", "z", "ix", "ax", "int", "ct", "xs", "k", "sex", "cl", "f", "word", "test"], "tmp": ["mu", "part", "qq", "sup", "ignore", "np", "area", "cache", "nb", "mm", "copy", "mmm", "yy", "rm", "batch", "mp", "upload", "bb", "proc", "nt", "rc", "img", "cont", "txt", "zip", "cmp", "rup", "pre", "rb", "emp", "nu", "obj", "stuff", "now", "buf", "form", "seed", "temp"], "r2list": ["r2x", "c4list", "r4List", "r3List", "c4l", "r3l", "r4x", "r1List", " r4list", "r1l", "c4List", " r4l", "r3list", " r2List", "r4list", " r4List", "c2List", "c2list", "r2l", "c2l", " r2x", " r4x", "r4l", "r3x", "r2List", "r1x", " r2l"], "nset": [" nsc", " nmatch", "NSet", "Nset", "rset", "nsets", "dlist", "rlist", "nsc", "nsection", "unst", " nsection", "dcheck", "nlist", " nSet", "cnlist", "Nsc", "unsc", "nnmatch", "unSet", "nnsc", "cnset", "cnsync", "nst", "nnset", "nnsection", "unset", " nlist", "dsync", "rsets", "rcheck", "cnsets", "nsync", "ncheck", "Nmatch", "rsync", "nmatch", "nSet", "Nsection", " ncheck", "dset", " nsync", "Nst", " nsets", " nst"]}}
{"code": " \n  \n  IMPOSSIBLE = []\n  \n  def transpose(grid):\n      return map(list, zip(*grid))\n  \n  def find_grid(R, C, M):\n      \"\"\"Return a grid of a solution, if one exists, otherwise []\n  \n      Observations:\n      * WLOG, C <= R (otherwise, take the transpose of a solution)\n      * Trivial cases are:\n        - M = 0 or  M = RC - 1\n        - C = 1\n        - (R, C) = (2, 2)\n        - (R, C, M) = (3, 3, 2)\n        - (C, M) = (2, 1)\n      * If M >= C >= 2 and R >= 3, we can add a row of C mines to the bottom and consider M'=M-C, R'=R-1\n      * The remaining cases are M <= R-2, and M + 1 == R == C >= 4, which are both solvable\n      \"\"\"\n      if M == 0:\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\n          grid[0][0] = 'c'\n          return grid\n      elif M == R * C - 1:\n          grid = [['*' for c in xrange(C)] for r in xrange(R)]\n          grid[0][0] = 'c'\n          return grid\n      elif C > R:\n          return transpose(find_grid(C, R, M))\n      elif C == 1:\n          return [['c']] + [['.'] for i in xrange(R-M-1)] + [['*'] for i in xrange(M)]\n      elif (R, C) == (2, 2) or (R, C, M) == (3, 3, 2) or (C, M) == (2, 1):\n          return IMPOSSIBLE\n  \n      assert 2 <= C <= R >= 3, \"R={} C={} M={}\".format(R, C, M)\n  \n      if M >= C:\n          s = find_grid(R-1, C, M-C)\n          return s and s + [['*' for c in xrange(C)]]\n      elif M <= R-2 and C >= 3:\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\n          grid[0][0] = 'c'\n          for i in xrange(M):\n              grid[R-i-1][C-1] = '*'\n          return grid\n      elif M + 1 == R == C >= 4:\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\n          grid[0][0] = 'c'\n          grid[R-1][C-2] = '*'\n          for i in xrange(M-1):\n              grid[R-i-1][C-1] = '*'\n          return grid\n  \n      assert False, \"R={} C={} M={}\".format(R, C, M)\n  \n  def check_soln(grid, R, C, M):\n      \"\"\"checking, because debugging...\"\"\"\n      error = \"R={} C={} M={}\".format(R, C, M)\n      assert sum(row.count('*') for row in grid) == M, error\n      assert sum(row.count('c') for row in grid) == 1, error\n      assert len(grid) == R, error\n      assert all(len(row) == C for row in grid), error\n      _ = [i for i, row in enumerate(grid) if 'c' in row][0]\n      click = (_, [i for i, c in enumerate(grid[_]) if c == 'c'][0])\n  \n      def neighbours(r, c):\n          ns = [(i, j) for i in range(max(r-1,0),min(r+2,R)) for j in range(max(c-1,0),min(c+2,C))]\n          ns.remove((r, c))\n          return ns\n  \n      cpy = map(list, grid)\n      def fill(cpy, pos):\n          cpy[pos[0]][pos[1]] = str(sum(1 for i, j in neighbours(*pos) if grid[i][j] == '*'))\n          if cpy[pos[0]][pos[1]] == '0':\n              for i, j in neighbours(*pos):\n                  if cpy[i][j] == '.':\n                      fill(cpy, (i, j))\n      fill(cpy, click)\n      assert sum(row.count('.') for row in cpy) == 0, error\n  \n  def solve(R, C, M):\n      soln = find_grid(R, C, M)\n      if soln == IMPOSSIBLE:\n          return \"Impossible\"\n      else:\n          check_soln(soln, R, C, M)\n          return '\n'.join(''.join(row) for row in soln)\n  \n  if __name__ == '__main__':\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n      with fin, fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n              r, c, m = map(int, fin.readline().split())\n              soln = solve(r, c, m)\n              print >> fout, \"Case #{0}:\n{1}\".format(case, soln)\n  \n", "substitutes": {"IMPOSSIBLE": ["IMPOSIBLE", "IMPUSibles", "IMPASSIBLE", "IMPASSible", "IMPUSIBLE", "IMPESSIVE", "IMPOSSible", "IMpASSURE", "IMPESSibles", "IMPOSible", "IMPOSSibles", "IMpOSSibles", "IMPOSSIVE", "IMpASSibles", "IMpOSSIVE", "IMpOSSORS", "IMPOSURE", "IMPOSSURE", "IMPASSibles", "IMPASSURE", "IMpASSible", "IMpASSIBLE", "IMPUSible", "IMpOSSIBLE", "IMpOSSURE", "IMPESSible", "IMPESSIBLE", "IMPOSIVE", "IMPASSIVE", "IMpASSIVE", "IMpASSORS", "IMPOSSORS", "IMPUSORS", "IMpOSSible", "IMPASSORS", "IMPESSURE", "IMPESSORS"], "grid": ["id", "model", "gr", "complex", "G", "square", "align", "window", "storage", "ge", "unit", "lat", "range", "gap", "cm", "df", "volume", "chain", "cell", "age", "house", "db", "Grid", "layer", "mu", "array", "card", "site", "edge", "list", "out", "cells", "rows", "str", "sim", "panel", "tree", "cube", "block", "flat", "flow", "rr", "index", "query", "q", "table", "server", "order", "group", "module", "dict", "type", "filter", "input", "method", "lay", "frame", "plot", "layout", "sg", "choice", "line", "client", "graph", "data", "network", "f", "x", "draw", "move", "play", "sort", "cache", "copy", "g", "dim", "file", "reg", "manager", "column", "sequence", "arr", "node", "mat", "page"], "R": ["Rh", "TR", "N", "Y", "GR", "Rs", "Range", "P", "RE", "MR", "Cl", "CR", "RH", "Re", "RT", "U", "JR", "E", "G", "H", "SR", "RM", "W", "RO", "K", "X", "RW", "ER", "Q", "DR", "RS", "Rec", "B", "Run", "RP", "AR", "D", "F", "RC", "RG", "Ra", "Ro", "IR", "LR", "RN", "S", "RR", "NR", "WR", "A", "L", "V", "RA"], "C": ["N", "Y", "NC", "SC", "AC", "Cs", "P", "VC", "DC", "CM", "CR", "U", "E", "CE", "H", "G", "W", "CA", "K", "X", "Co", "YC", "CV", "CO", "CC", "Q", "CS", "Cu", "B", "I", "D", "CI", "Cr", "F", "RC", "Ch", "O", "CT", "S", "CL", "EC", "MC", "CU", "CN", "A", "L", "V"], "M": ["Y", "N", "MD", "Range", "P", "MOD", "MR", "Man", "MO", "J", "CM", "DC", "CR", "VM", "E", "G", "H", "MI", "RM", "W", "DM", "AM", "K", "X", "Mo", "Q", "CC", "DR", "OM", "I", "B", "AR", "D", "F", "RC", "MB", "LM", "MM", "cm", "O", "S", "MA", "CL", "MN", "ME", "Me", "Z", "Mor", "MC", "RR", "V", "Mc", "IM", "CU", "A", "L", "U", "RA"], "c": ["x", "e", "v", "unc", "cat", "cs", "l", "code", "n", "lc", "ca", "ce", "cu", "col", "ec", "co", "g", "cr", "h", "arc", "cn", "cf", "xc", "con", "cm", "ic", "b", "p", "d", "ch", "z", "a", "ct", "cc", "k", "cl", "f", "ac"], "r": ["x", "id", "e", "v", "fr", "err", "yr", "l", "br", "t", "n", "ner", "ru", "gr", "it", "o", "lr", "g", "ir", "ar", "sr", "range", "pr", "ur", "u", "rb", "rs", "b", "p", "rg", "re", "f", "er", "rn"], "i": ["x", "id", "ii", "e", "v", "bi", "im", "ip", "l", "n", "ind", "q", "xi", "iu", "it", "col", "g", "ti", "ir", "ar", "arc", "I", "ci", "iq", "ic", "ai", "b", "p", "z", "pi", "int"], "s": ["ps", "blocks", "e", "v", "l", "t", "n", "su", "sym", " S", "w", "sample", "o", "sets", "g", "storage", "h", "services", "ses", "sites", "sb", "sync", "ws", "si", "y", "abs", "gs", "cells", "ss", "u", "sim", "S", "p", "b", "d", "states", "sg", "a", "es", "ts", "f", "sq"], "row": ["flow", "Row", "rown", "plane", "ack", "array", "ro", "run", "ho", "ox", "copy", "col", "ice", "sc", "head", "ow", "unit", "roc", "column", "rug", "rows", "cube", "roll", "block", "ros", "rid", "cell"]}}
{"code": " \n  \n  def read_row(fin, n):\n      rows = [set(map(int, fin.readline().strip().split())) for i in xrange(4)]\n      return rows[n-1]\n  \n  def solve(rowa, rowb):\n      both = rowa & rowb\n      if len(both) == 1:\n          return list(both)[0]\n      elif len(both) > 1:\n          return \"Bad magician!\"\n      elif not both:\n          return \"Volunteer cheated!\"\n  \n  if __name__ == '__main__':\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n      with fin, fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n              n = int(fin.readline())\n              rowa = read_row(fin, n)\n              n = int(fin.readline())\n              rowb = read_row(fin, n)\n              soln = solve(rowa, rowb)\n              print >> fout, \"Case #{0}: {1}\".format(case, soln)\n  \n", "substitutes": {"fin": ["fat", "cin", "final", "run", "rt", "spec", "div", "die", "tick", "len", "en", "thin", "serv", "inn", "start", "win", "syn", "commit", "nu", "df", "FIN", "front", "send", "rf", "info", "prem", "inf", "fine", "proc", "ur", "fi", "details", "dir", "bin", "han", "fn", "rin", "token", "tin", "fr", "res", "report", "dev", "fd", "rec", "init", "Fin", "fen", "txt", "raf", "skip", "inner", "nit", "hr", "ini", "ln", "tr", "do", "f", "pen", "br", "end", "fa", "pub", "conn", "after", "fit", "file", "before", "inv", "fail", "close", "fp", "pid", "kin", "lin", "fun"], "n": [" N", "x", "N", "v", "e", "ns", "nc", "l", "t", "np", "count", "na", "nb", "r", "w", "un", "net", "o", "g", "sn", "c", "s", "h", "len", "en", "nr", "nt", "size", "y", "num", "ni", "m", "u", "b", "p", "nu", "d", "z", "ne", "k", "f", "number", "L"], "rows": ["blocks", "members", "groups", "headers", "index", "result", "models", "reads", "fields", "keys", "feed", "col", "files", "dict", "ows", "ins", "users", "values", "row", "cells", "ids", "runs", "relations", "items", "flows", "events", "results", "rules", "reports", "lines", "frames", "cases", "vals", "pages", "views", "ks"], "i": ["instance", "id", "j", "e", "key", "index", "ip", "ind", "q", "li", " c", "ice", "c", "ti", "ie", "gi", "item", "I", "ci", "iq", "u", "ic", "ai", "p", "d", "ix", "k"], "rowa": ["Rowsa", "oxa", "roarea", "rowada", "cola", "Rowas", "rolla", "rollb", "rowarea", "oxada", "oxsa", "Rowp", "roa", "rowas", "rowssa", "rosa", " rowas", "roada", " rowada", "Rowa", "rawas", "rawa", "colp", "rawb", " rowsa", "rollp", "rowsb", "rowp", "rowsa", "Rowb", " rowp", "rowsas", "colb", " rowarea", "oxarea", "rawp"], "rowb": ["coa", " rowf", "rown", "ryb", "rowbb", "rowf", "rolla", "rollb", "cob", "rollbb", "rollba", "rowc", "rowba", "viewb", "col", "roa", "rob", " rowl", "rollf", "viewc", "vieweb", "ryf", "roweb", " rown", "arrowc", "arrowb", "viewn", "rowl", " rowba", "con", "viewa", " rowc", "viewl", "rolleb", "ryeb", "arroweb", "robb", "rya", " roweb", " rowbb", "arrowa", "roba"], "both": ["all", "part", "odd", "short", "always", "holes", "hand", "half", "multi", "either", "alone", "l", "t", "other", "multiple", "Both", "right", " Both", "this", "two", "only", "then", "who", "old", "equal", "one", "empty", "private", "cho", "list", "also", "tw", " neither", "yet", "total", "many", "three", "before", "left", "inner", "wh", "null", "between", "each", "p", "partial", "balanced", "length", "diff", "full", "now", "same", "none", "pair", "off", "sometimes"], "fout": [" Fobj", "FOUT", " fOUT", "fouts", "FOut", "sfOut", "Fouts", " fouts", "fsouts", "sfio", "sfout", "Fin", "fsin", "fsOut", "sfouts", "Fout", " Fin", "fOUT", "sfOUT", "sfobj", " fobj", " Fout", "sfin", "fOut", "fsout", " fio", " fOut", "fobj", "fio", " Fio"], "T": [" N", "N", "TN", "t", "P", "trial", "time", "E", "H", "X", "Time", "R", "NT", "tests", "Q", "max", "I", "B", "D", "F", "O", "S", "TT", "C", "Case", "number", "M", "L", "V", "test"], "case": ["instance", "id", "bug", "code", "end", "time", "trial", "ace", "ce", "rice", "su", "match", "X", "ice", "c", "type", "one", "pe", "section", "exc", "name", "use", "position", "row", "switch", "race", "p", "call", "C", "line", "chain", "Case", "ase", "cases", "de", "loc", "se", "test"], "soln": [" sols", "sln", "esln", "sols", "sol", "ssols", "solk", "ssln", "esols", "solen", "ssol", "esolen", "ssolk", "esolk", "esol", " sln", " solen", "esoln", " sol", " solk", "ssolen", "ssoln"]}}
{"code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      RR, CC, M = map(int, fin.readline().split())\n      R, C = None, None\n      blocks = RR*CC - M\n      inverse = False\n      if RR > CC:\n          inverse = True\n          R, C = CC, RR\n      else:\n          R, C = RR, CC\n      result = None\n      if R == 1:\n          result = [('.' * blocks) + ('*' * M)]\n      elif R == 2:\n          if blocks == 1:\n              result = ['.' + ('*' * (C-1)), '*' * C]\n          elif blocks % 2 == 0 and blocks != 2:\n              cc = blocks // 2\n              result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \n          else:\n              result = None\n      else:\n          if blocks == 1:\n              result = ['*' * C] * R\n          elif blocks == 4:\n              result = ['..' + (C-2)*'*']*2\n              result += ['*'*C] * (R-2)\n          elif blocks == 6:\n              result = ['...' + (C-3)*'*']*2\n              result += ['*'*C] * (R-2)\n          for rows in range(3, R+1):\n              for columns in range(rows, C+1):\n                  size = rows * columns\n                  if size - blocks >= 0:\n                      if size - blocks <= columns - 2: \n                          result = []\n                          for r in range(rows):\n                              if r < rows - 1:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              else:\n                                  cc = columns - (size - blocks)\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      elif size - blocks == columns - 1 and rows >= 4:\n                          result = []\n                          for r in range(rows):\n                              if r < rows - 2:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              elif r == rows - 2:\n                                  cc = columns - 1\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                              else:\n                                  cc = 2\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      \n  \n  \n  \n      print(\"Case #%d: \" % (case))\n      if result is None:\n          debug('impossible', blocks, RR, CC)\n          print(\"Impossible\")\n      else:\n          mines = 0\n          for r in range(RR):\n              row = ''\n              for c in range(CC):\n                  rr, cc = r, c\n                  if inverse:\n                      rr, cc = c, r\n                  if rr == 0 and cc == 0:\n                      row += 'c'\n                  else:\n                      row += result[rr][cc]\n                      if result[rr][cc] == '*':\n                          mines += 1\n              print(row)\n          if mines != M:\n              raise Exception(\"%d != %d %d x %d\" % (mines, M, RR, CC))\n              \n  \n  \n", "substitutes": {"fin": ["fn", "rin", "tin", "fr", "ran", "fat", "br", "fa", "su", "os", "fd", "el", "lo", "init", "div", "conn", "die", "h", "len", "fit", "en", "thin", "inf", "tun", "fine", "Fin", "file", "serv", "fen", "inn", "raf", "inv", "inner", "fi", "fp", "ini", "rb", "ln", "nu", "kin", "lin", "FIN", "util", "iter", "f", "bin"], "T": [" N", "TR", "N", "Y", "TN", "t", "P", "TH", "time", "TF", "TS", "RT", "E", "H", "W", "K", "X", "Time", "TC", "Q", "B", "D", "F", " t", "O", "CT", "S", "TT", "Z", "TB", "L", "V"], "case": ["v", "e", "P", "end", "sec", "time", "trial", "ace", "bc", "ice", "X", "section", "TC", "seq", "tc", "B", "num", "b", "p", "d", " time", "length", "line", "cor", "cases", "times", "test"], "RR": ["Rh", "TR", "HR", "GR", "Rs", "MR", "DC", "RH", "CR", "RT", "RB", "JR", "SR", "RM", "RF", "RD", "RO", "CV", "RW", "DR", "ARR", "RS", "RP", "RC", "RG", "IR", "CCC", "LR", "RN", "RL", "NR", "WR", "RA"], "CC": ["NC", "UC", "SC", "CNN", "AC", "VC", "DC", "CM", "FC", "CR", "CF", "BC", "CD", "CE", "RM", "CA", "X", "CB", "OC", "CV", "TC", "CO", "LC", "RS", "CW", "RC", "MM", "GC", "CCC", "CP", "CT", "CON", "CL", "Z", "CH", "EC", "MC", "FF", "PC", "WC", "XX", "GG"], "M": ["N", "Y", "MD", "CNN", "AC", "P", "MS", "MOD", "MR", "DC", "CM", "U", "G", "MI", "H", "RM", "W", "DM", "K", "Q", "TM", "OM", "I", "B", "MF", "D", "F", "RC", "LM", "MM", "m", "CCC", "O", "S", "CL", "MN", "MC", "IM", "A", "L", "V"], "R": ["Rh", "A", "N", "Y", "TR", "GR", "Rs", "Range", "P", "MR", "right", "RH", "CR", "RT", "RB", "U", "JR", "E", "H", "G", "SR", "RM", "W", "RF", "RO", "RD", "X", "Right", "Co", "K", "RW", "DR", "Q", "RS", "BR", "I", "B", "Run", "RP", "D", "F", "RC", "RG", "IR", "LR", "RN", "RL", "S", "NR", "Block", "L", "V", "RA"], "C": ["P", "Cl", "CR", "E", "CE", "G", "YC", "CO", "Cu", "Ch", "O", "EC", "MC", "CU", "A", "L", "Y", "SC", "AC", "CF", "HC", "X", "Co", "Sc", "CS", "CI", "D", "V", "NC", "Cs", "VC", "Control", "Length", "H", "B", "CCC", "Z", "Count", "WC", "N", "CNN", "DC", "CM", "BC", "Size", "W", "CA", "K", "Right", "JC", "CV", "Q", "CW", "F", "RC", "GC", "CT", "CON", "S", "CL", "CN", "Code", "U"], "blocks": ["Blocks", "levels", " Blocks", " results", "cycles", "checks", "CB", "bs", "nos", "breaks", "plugins", "types", "events", "length", "MC", "cases", "chains", "jobs", "ks", "L", "maps", "RESULTS", "groups", "planes", "n", "BL", "words", "X", "values", "cells", "quarters", "items", "block", "days", "rules", "lines", "bars", "bytes", "PC", "times", "Rs", "outs", "control", "ops", "features", "files", "classes", "s", "packages", "heads", "units", "B", "runs", "b", "flows", "errors", "frames", "Block", "boxes", "ions", "rons", "N", "cb", "MS", "bc", "limits", "BC", "modules", "locks", "W", "K", "ins", "users", "TM", "balls", "RS", "CW", "F", "steps", "S", "results", "pieces", "cl", "bits", "pages"], "inverse": ["uninverted", "insverse", "uninclude", "include", "uninreverse", "uninverse", "insvert", "Invert", "invert", "outverse", "INreverse", "INclude", "inreverse", "INverted", "outverted", "outreverse", "inverted", "Include", "Inverted", "outvert", "Inreverse", "insreverse", "insverted", "Inverse", "INverse"], "result": ["root", "err", "final", "complete", "match", "description", "coll", "master", "source", "current", "color", "search", "df", "length", "true", "pack", "rule", "Result", "array", "success", "catch", "url", "answer", "round", "list", "info", "use", "buffer", "config", "desc", "rest", "message", "found", "function", "details", "block", "rules", "response", "diff", "error", "runner", "number", "res", "compl", "product", "report", "output", "table", "features", "event", "func", "group", "math", "dict", "filter", "reason", " Result", "view", "method", "Results", "comment", "data", "record", "valid", "summary", "default", "grade", "cache", "package", "json", "follow", "status", "replace", "date", "attr", "params", "ret", "memory", "results", "account", "page", "test"], "cc": ["cb", "pc", "uc", "nc", "ff", "cs", "code", "dc", "sec", "control", "lc", "count", "DC", "ce", "bc", "ca", "FC", "kk", "cca", "mm", "ck", "CE", "shape", "ec", "ll", "co", "cr", "cci", "sc", "coll", "cd", "ucc", "anc", "rc", "tc", "lv", "cf", "cells", "RC", "ci", "con", "cv", "cost", "cm", "acc", "mc", "block", "length", "fc", "ct", "cases", "cl", "content", "PC", "cp", "cell", "weight", "ac", "rank", "loc", "ced", "sq", "inc"], "rows": ["members", "col", "sections", "checks", "rc", "tests", "breaks", "forms", "vers", "types", "events", "length", "cases", "xs", "ks", "groups", "planes", "n", "OWS", "keys", "sc", "values", "cells", "height", "qs", "items", "p", "rules", "lines", "_", "rank", "times", "all", "rown", "rss", "cs", "count", "features", "s", "ows", "heads", "runs", "rs", "d", "ros", "errors", "frames", "boxes", "x", "end", "ries", "DC", "right", "rh", "orders", "h", "ins", "users", "RS", "results", "es", "pages", "views"], "columns": ["columnsets", "scrollows", "roundes", "cellrows", "paragraphses", "methodows", "patterns", "columnl", "celles", "cols", "colers", "Columnings", "columnS", "columnb", "columnses", "methods", "columnes", "indexsets", "columnrows", "Columnrows", "columners", "methodS", "structns", "patternns", "scrollb", "columnows", "coll", "methodes", "roundrows", "patternes", "paragraphs", " columnb", "patternings", "colensions", " columnows", "scrollS", "rounders", "colrows", "ColumnS", "scrolls", "Columnes", "Columnsets", "colsets", "indexes", "columnns", "structs", " columnS", "cells", "cellensions", "Columners", "Columnses", "colses", "colS", "structings", "paragraphes", "columnensions", "coles", "colb", "colows", "Columnns", "paragraphows", "Columnensions", "rounds", "Columnows", "structes", "Columns", "indexl", "Columnl", "columnings", "indexs"], "size": ["x", "external", "cs", "default", "code", "n", "sec", "count", "address", "core", "area", "time", "sort", "member", "ize", "shift", "w", "Size", "order", "shape", "width", "empty", "sn", "mode", "s", "len", "sc", "ows", "see", "enc", "en", "white", "name", "use", "position", "SIZE", "large", "cells", "clean", "column", "ci", "source", "six", "when", "capacity", "z", "length", "year", "radius", "small", "scale", "support", "es", "rate", "cl", "content", "form", "loc", "number", "sized"], "r": ["x", "v", "fr", "e", "yr", "rf", "ru", "br", "l", "ner", "n", "ro", "rd", "gr", "resh", "right", "w", "rh", "lr", "rec", "cr", "g", "h", "i", "ar", "ir", "nr", "rc", "sr", "rl", "range", "ur", "m", "rb", "rs", "rw", "b", "p", " rc", "d", "z", "rg", "k", "f", "er", "pr"]}}
{"code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      answer1 = int(fin.readline())\n      rows1 = []\n      for i in range(4):\n          rows1.append(set(map(int, fin.readline().split())))\n      answer2 = int(fin.readline())\n      rows2 = []\n      for i in range(4):\n          rows2.append(set(map(int, fin.readline().split())))\n  \n      possibilities1 = rows1[answer1-1]\n      possibilities2 = rows2[answer2-1]\n  \n      numbers = possibilities1.intersection(possibilities2)\n      result = None\n      if len(numbers) == 1:\n          result = list(numbers)[0]\n      elif len(numbers) == 0:\n          result = 'Volunteer cheated!'\n      else:\n          result = 'Bad magician!'\n  \n  \n      print(\"Case #%d: %s\" % (case, result))\n  \n", "substitutes": {"fin": ["rin", "fn", "tin", "fr", "nir", "ran", "fat", "br", "report", "n", "zen", "final", "fa", "ven", "fd", "spec", "rt", "init", "div", "conn", "die", "loader", "len", "en", "thin", "prem", "reader", "Fin", "fine", "tun", "proc", "file", "finder", "fen", "inn", "raf", "gener", "vec", "cook", "inner", "ini", "trans", "ln", "non", "nu", "kin", "pos", "lin", "dir", "FIN", "front", "util", "iter", "f", "central", "bin", "han", "fun"], "T": [" N", "N", "Y", " P", "Total", "TN", "t", "P", "n", "time", "TS", "TI", "E", "H", "X", "Time", "R", "Q", "I", "B", "D", "F", " t", "O", "test", "S", "TT", "Z", "C", "M", "A", "L", "V", " time"], "case": ["instance", "x", "id", "bug", "sea", "key", "code", "t", "count", "time", "trial", "ace", "ce", "se", "day", "su", "U", "answer", "me", "match", "ice", "c", "section", "seq", "name", "loop", "use", "size", "ue", "phase", "row", "switch", "race", "tim", "sequence", "C", "line", "length", "Case", "ase", "cases", "adi", "page", "test"], "answer1": ["rankone", "response1", "AnswerOne", "addressone", "size1", "rank01", "size01", "response2", "responseOne", " answerOne", "answer01", "address1", "rank1", "Answer1", "sizeone", "answerone", "answerOne", "address01", "Answer2"], "rows1": ["orders01", "row1", "ordersone", "row2", "blocks2", "readsone", "reads1", "owsOne", "reads0", "rowsone", "rowOne", "orders1", "ows2", "owsone", "rows01", "row0", "ows01", "reads2", "ows0", "rowsOne", " rowsOne", "rowone", "blocks1", "blocks01", "orders2", "blocksone", "rows0", "ows1"], "i": ["ait", "x", "id", "j", "ii", "e", "v", "ri", "index", "ip", "l", "ei", "ind", "li", "iu", "r", "it", "o", "c", "ti", "ie", "chi", "qi", "gi", "si", "I", "ci", "iq", "u", "ai", "p", "pi", "int", "isin", "k", "f", "io", "ui"], "answer2": ["issue4", "replyTwo", "resultTwo", "Answer5", "response02", "responsetwo", "address2", "response2", "answer02", "issue2", "issue5", "Answer4", "reply2", "addresstwo", "AnswerTwo", "issueTwo", "address02", "result5", "answer5", "answertwo", "reply02", "responseTwo", "addressTwo", "answerTwo", "replytwo", "Answer2", "result4", "answer4", "result2"], "rows2": ["reads02", "shows62", "row1", "row62", "row4", "ows02", "ows4", " rows02", "row2", "owstwo", "reads1", " rowstwo", "shows4", "ows62", " rows0", "ows2", "row0", "rows4", "readstwo", "rows02", "reads2", "ows0", "showstwo", "rowtwo", "rowstwo", "shows2", "rows62", "rows0", "row02", "ows1"], "possibilities1": ["possitions2", "pposibilities1", "pOSSibles1", "pOSSibles3", "pOSSibilities1", "possibilities01", "possibilitiesone", "possibles01", "pposibilityone", "possibles1", "possibles3", "possibilities3", "pposibility2", "possitions01", "possibility2", "pOSSibles2", "pposibilitiesone", "pOSSibilities2", "possibility01", "possives1", "pposibilities01", "possibilityone", "possitions1", "possibles2", "pOSSibilities3", "pposibility01", "pposibility1", "possiblesone", "possibility3", "possives3", "pposibilities2", "possibility1", "possives2", "possitionsone"], "possibilities2": ["pOSSibility4", "pOSSibility1", "possibilitiesTwo", "pOSSibilities1", "possibility4", "possibles1", "possesTwo", "pOSSibilities4", "possibility2", "possibilities4", "posses4", "possities2", "pOSSibilities2", "possipes2", "posses1", "possities4", "pOSSibility2", "possibilityTwo", "posses2", "pOSSibilityTwo", "possibles2", "possities1", "possitiesTwo", "possipes1", "possibility1", "pOSSibilitiesTwo"], "numbers": [" nefficients", "numer", "cumbers", "rnumbers", "pums", "Nodes", "rnumer", "cumber", "Number", "generumbers", "neumer", "Numbers", "cums", "rnodes", "codes", "nums", "generums", "neums", "nodes", "neefficients", "pumber", "rnums", "pumbers", "podes", "generodes", "Numer", "nefficients", "Nefficients", " nums", "cumer", "neumbers", "Nums", "number", " numer", "generumer"], "result": ["successful", "valid", "cash", "root", "err", "res", "summary", "Result", "product", "report", "compl", "grade", "default", "success", "our", "final", "output", "catch", "su", "package", "winner", "repl", "status", "answer", "folder", "ise", "match", "description", "date", "type", "mate", "msg", "reason", "ret", "message", "source", "current", "search", "effect", "results", "cup", "response", "length", "division", "diff", "error", "runner", "rect", "obj", "comment", "main", "data", "account", "test"]}}
{"code": " \n  def generate_matrix(r, c, char):\n  \tmat = [[char for i in range(c)] for j in range(r)]\n  \treturn mat\n  \t\n  def merge(mat1, mat2):\n  \tfor i in range(len(mat1)):\n  \t\tfor j in range(len(mat1[i])):\n  \t\t\tmat2[i][j] = mat1[i][j]\n  \treturn mat2\n  \n  def solve(r, c, m):\n  \tif 0 == m:\n  \t\tmat = generate_matrix(r, c, '.')\n  \t\tmat[0][0] = 'c'\n  \t\treturn mat\n  \t\t\n  \tf = r * c - m\n  \t\n  \tif 0 == f:\n  \t\treturn False\n  \t\t\n  \tif 1 == f:\n  \t\tmat = generate_matrix(r, c, '*')\n  \t\tmat[0][0] = 'c'\n  \t\treturn mat\n  \t\t\n  \tif 1 == min(r, c):\n  \t\tmat = generate_matrix(r, c, '*')\n  \t\tfor i in range(f):\n  \t\t\tmat[0 if 1 == r else i][0 if 1 == c else i] = '.'\n  \t\tmat[0][0] = 'c'\n  \t\treturn mat\n  \n  \tif 2 == min(r, c):\n  \t\tif (0 != f % 2) or (2 == f):\n  \t\t\treturn False\n  \t\tmat = generate_matrix(r, c, '*')\n  \t\tfor i in range(f // 2):\n  \t\t\tmat[0 if 2 == r else i][0 if 2 == c else i] = '.'\n  \t\t\tmat[1 if 2 == r else i][1 if 2 == c else i] = '.'\n  \t\tmat[0][0] = 'c'\n  \t\treturn mat\n  \t\t\n  \tif (3 == r) and (3 == c):\n  \t\tif (4 == f) or (6 == f):\n  \t\t\tmat = generate_matrix(r, c, '*')\n  \t\t\tfor i in range(f // 2):\n  \t\t\t\tmat[0][i] = '.'\n  \t\t\t\tmat[1][i] = '.'\n  \t\t\tmat[0][0] = 'c'\n  \t\t\treturn mat\n  \t\tif 8 == f:\n  \t\t\tmat = generate_matrix(r, c, '.')\n  \t\t\tmat[2][2] = '*'\n  \t\t\tmat[0][0] = 'c'\n  \t\t\treturn mat\n  \t\treturn False\n  \t\t\n  \trows_to_reduce = min(r - 3, m // c)\n  \tif 0 < rows_to_reduce:\n  \t\tres = solve(r - rows_to_reduce, c, m - rows_to_reduce * c)\n  \t\tif False == res:\n  \t\t\treturn False\n  \t\tmat = merge(res, generate_matrix(r, c, '*'))\n  \t\treturn mat\n  \t\t\n  \tcols_to_reduce = min(c - 3, m // r)\n  \tif 0 < cols_to_reduce:\n  \t\tres = solve(r, c - cols_to_reduce, m - cols_to_reduce * r)\n  \t\tif False == res:\n  \t\t\treturn False\n  \t\tmat = merge(res, generate_matrix(r, c, '*'))\n  \t\treturn mat\n  \t\n  \tmat = generate_matrix(r, c, '.')\n  \tfor i in range(min(m, r - 2)):\n  \t\tmat[r - i - 1][c - 1] = '*'\n  \tif m == r - 1:\n  \t\tmat[r - 1][c - 2] = '*'\n  \tmat[0][0] = 'c'\n  \treturn mat\n  \t\t\t\n  \n  t = int(sys.stdin.readline().strip())\n  \n  for i in range(t):\n  \tprint \"Case #\" + str(i + 1) + \":\"\n  \n  \tr, c, m = [int(i) for i in sys.stdin.readline().strip().split()]\n  \t\n  \tres = solve(r, c, m)\n  \t\n  \tif False == res:\n  \t\tprint \"Impossible\"\n  \telse:\n  \t\tfor i in range(r):\n  \t\t\tfor j in range(c):\n  \t\t\t\tsys.stdout.write(res[i][j])\n  \t\t\tprint\n", "substitutes": {"r": ["x", "e", "v", "fr", "err", "rr", "yr", "rf", "l", "ru", "n", "ro", "br", "q", "run", "right", "w", "rt", "dr", "rh", "cr", "g", "s", "ir", "R", "ar", "h", "nr", "rc", "y", "sr", "range", "pr", "ur", "hr", "u", "rb", "rs", "b", "p", "ra", "d", "z", "rg", "a", "k", "re", "er", "rn"], "c": ["x", "e", "v", "nc", "uc", "cs", "l", "n", "dc", "cin", "lc", "q", "ca", "ce", "w", "cu", "col", "rec", "ec", "cr", "g", "s", "h", "sc", "arc", "rc", "y", "cf", "ci", "con", "cm", "u", "ic", "mc", "b", "p", "d", "C", "ch", "z", "ct", "a", "cc", "cy", "k", "cp", "cl", "cell", "ac"], "char": ["x", "id", "v", "fr", "uc", "e", "im", "cs", "dc", "character", "q", "ctr", "w", "co", "cr", "g", "s", "gi", "h", "ar", "Char", "rc", "letter", "I", "ci", "u", "cm", "mc", "tr", "ch", "C", "d", "int", "cell", "k"], "mat": ["opt", "Mat", "atom", "sat", "rt", "et", "col", "MAT", "ut", "match", "ort", "mp", "template", "agg", "unit", "lat", "hm", "pat", "app", "mar", "fm", "mac", "cm", "feat", "mit", "mitt", "mun", "mon", "material", "layer", "mu", "crit", "cat", "array", "mem", "ha", "mt", "atten", "mm", "format", "bt", "net", "dat", "at", "bm", "mode", "met", "mult", "wat", "att", "Matrix", "num", "stat", "p", "wa", "ct", "md", "hot", "flat", "util", "_", "ma", "ac", "ht", "fn", "all", "token", "tab", "act", "man", "na", "mic", "it", "abc", "module", "math", "dict", "wt", "mate", "hat", "mag", "om", "qt", "mc", "ata", "b", "plot", "mot", "d", "mol", "doc", "graph", "mx", "map", "x", "min", "mas", " Mat", "text", "nat", "comb", " matrix", "dim", "h", "file", "cont", "ith", "struct", "arr", "loc", "tag", "test"], "i": ["id", "v", "ri", "bi", "ti", "ir", "gi", "oi", "ni", "iv", "k", "api", "mu", "l", "n", "ei", "li", "hip", "ie", "name", "ai", "p", "ij", "a", "di", "zi", "ment", "ui", "ii", "index", "ip", "mi", "phi", "ind", "q", "xi", "yi", "iu", "it", "qi", "y", "vi", "I", "uri", "ci", "ini", "u", "b", "d", "ion", "pi", "ji", "x", "e", "key", "o", "g", "h", "si", "z", "int", "io", "loc", "ia"], "j": ["ji", "x", "v", "ii", "e", "l", "br", "n", "ind", "q", "J", "jj", "li", "iu", "it", "jc", "o", "js", "g", "h", "qi", "oj", "jp", "jl", "y", "si", "ci", "u", "b", "p", "ch", "d", "z", "ij", "a", "k", "uj"], "mat1": ["ha1", "Mat7", "m5", "ha2", "m2", "mat3", "mm3", " mat10", " mat7", "Mat0", "Mat1", "mat7", "ha0", "mm2", "mat10", " mat0", "m3", "mat0", "matr", "Matr", "m1", "Mat10", "m7", "mm0", "m0", "natr", " mat5", "ha5", "mat5", "nat2", "nat10", "Mat2", "mm1", "nat1", "Mat3", " matr"], "mat2": ["nat5", " mat4", "Mat4", "mp2", " matall", "mp0", "Mat1", "mat4", "cat1", "math1", "mp1", "mp5", " matrix2", " mat0", "cat5", "matall", "mat0", "cat0", "cat2", " mat5", " matrix1", "mat5", "nat2", "math5", "Mat2", "Matall", "math2", " matrix4", "nat1", " matrixall"], "m": ["x", "mu", "mr", "v", "e", "mad", "l", "mi", "n", "q", "w", "mm", "o", "g", "s", "h", "y", "range", "fm", "u", "cm", "mc", "b", "p", "d", "z", "a", "k", "M"], "f": ["x", "fold", "all", "e", "v", "fr", "ff", "rf", "l", "n", "q", "tf", "fa", "w", "feed", "o", "g", "s", "h", "fit", "fe", "y", "fen", "cf", "F", "fm", "fp", "of", "u", "function", "found", "b", "p", "fs", "xf", "d", "fb", "z", "df", "fc", "a", "k", "form", "sf"], "rows_to_reduce": ["rows_to_redolve", "rows_to_duce", "rows_to_induction", "rows_to_induce", "rows_to_meruction", "rows_to_dolve", "rows_to_down", "rows_to_reduction", "rows_to_indown", "rows_to_indolve", "rows_to_duction", "rows_to_redown", "rows_to_meruce", "rows_to_merolve", "rows_to_merown"]}}
{"code": " \n  def read_row():\n  \ta = int(sys.stdin.readline().strip())\n  \tfor j in range(a - 1):\n  \t\tsys.stdin.readline()\n  \tread_set = set(sys.stdin.readline().strip().split(\" \"))\n  \tfor j in range(5 - a - 1):\n  \t\tsys.stdin.readline()\n  \t\t\n  \treturn read_set\n  \n  \n  t = int(sys.stdin.readline().strip())\n  \n  for i in range(t):\n  \tprint \"Case #\" + str(i + 1) + \":\",\n  \n  \tset1 = read_row()\n  \tset2 = read_row()\n  \t\n  \tintersect = set1.intersection(set2)\n  \t\n  \tif 1 == len(intersect):\n  \t\tprint intersect.pop()\n  \telif 0 == len(intersect):\n  \t\tprint \"Volunteer cheated!\"\n  \telse:\n  \t\tprint \"Bad magician!\"\n", "substitutes": {"a": ["A", "x", "am", "all", "ea", "la", "sa", "l", "n", "ga", "area", "count", "ca", "af", "w", "eta", "offset", "c", "aa", "active", "alpha", "au", "ta", "y", "an", "m", "u", "ai", "ata", "b", "p", "da", "aj", "z", "ab", "int", "data", "ma", "f", "ia", "ba", "va"], "j": ["x", "v", "e", "je", "l", "n", "dj", "q", "J", "jj", "r", "w", "it", "g", "h", "ie", "jp", "jl", "y", "job", "u", "str", "ai", "b", "p", "aj", "z", "ja", "ij", "k", "_", "f"], "read_set": [" read_section", "read2gen", "read1sc", "read64section", "readfcount", "read1section", "read2set", "Read_count", "read_count", "read_Set", "read64set", "read6set", "read64gen", "read2sc", "read_list", " read1section", "read_sc", "Read_Set", " read1set", "read1set", " read_sc", "read1gen", "read6count", "read6Set", "readfset", " read_gen", "read_section", "readflist", "read_gen", "Read_set", "read6list", "read2section", "read64sc", " read1gen", " read1sc", "readfSet", "Read_list"], "t": ["x", "v", "e", "T", "l", "n", "time", "trial", "ation", " total", "r", "w", "it", "o", "tt", "at", " T", "g", "c", "ti", "type", "set", "h", "s", "total", "tc", "nt", "ta", "y", "ty", "dt", "m", "u", "b", "p", "d", "z", "ts", "trace", "f", "test"], "i": ["x", "id", "ii", "e", "index", "l", "n", "phi", "ind", "xi", "li", "iu", "c", "ie", "type", "y", "ih", "si", "start", "I", "ci", "ini", "u", "m", "ai", "b", "p", "d", "z", "pi", "isi", "int", "di", "k", "f"], "set1": ["case01", "etOne", " set01", " setOne", "setOne", " setone", "et1", "case2", "set3", "et2", "case3", "caseOne", "setone", "etone", "et3", "caseone", " set3", "case1", "et01", "set01"], "set2": ["et0", " set02", "set02", "read1", "readTwo", "et1", "read62", " set0", "section0", "read2", " setTwo", "section2", "et2", " set62", "section62", "et02", "sectionTwo", "setTwo", "set0", "section1", "set62", "section02"], "intersect": ["arect", "presection", "oversection", "intercept", "arcept", "iterect", "interct", "artsection", "Intercept", "presect", "arsection", "partsection", "iterct", "interect", "itersect", "prect", "preect", "intersection", "partcept", "oversect", "itersection", "overcept", "partect", "artsect", "Interct", "overect", "Interect", "artect", "arsect", "artcept", "Intersection", "partsect", "Intersect"]}}
{"code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'\n  \n  \n  \n  def solve_one_case (R,C,M):\n          l = []\n          for i in range(R):\n              for j in range(C):\n                  l.append((i,j))\n  \n          empty_mat = []\n          for i in range(R):\n              empty_mat.append(['.']*C)\n  \n          found = False\n  \n          assert (0,0) in l\n          l = l[1:]\n          l = l[::-1]\n          assert (0,0) not in l\n          \n          output = ''\n          \n          for mine_placement in itertools.combinations(l,M):\n              mat = deepcopy(empty_mat)\n              for cell in mine_placement:\n                  mat[cell[0]][cell[1]] = '*'\n              if isOneClick(mat, R, C, M):\n                  mat[0][0] = 'c'\n                  for line in mat:\n                      output += ''.join(line) + '\n'\n                  found = True\n                  return output\n              \n          if not found:\n              return 'Impossible\n'\n          \n          assert ValueError()\n          \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          line = f_in.readline()\n          R,C,M = [int(q) for q in line.split()]\n          print (testcase,R,C,M)\n  \n          output = solve_one_case (R,C,M)\n          f_out.write('Case #' + str(testcase) + ':\n')\n          f_out.write(output)\n  \n          \n  \n  \n  def isOneClick (mat, R, C, M):\n  \n      mat_cpy = deepcopy(mat)\n      oneclickcells = [(0,0)]\n      while oneclickcells:\n          node = oneclickcells.pop()\n          mat_cpy[node[0]][node[1]] = 'v'\n          if noNearbyMines(mat_cpy,node):\n              oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))\n  \n      return sum([l.count('.') for l in mat_cpy]) == 0\n      \n  \n  def getNearbyUnvisited(mat, node):\n      R = len(mat)\n      C = len(mat[0])\n      deltas_r = [0]\n      deltas_c = [0]\n      if node[0] > 0:\n          deltas_r.append(-1)\n      if node[1] > 0:\n          deltas_c.append(-1)\n      if node[0] < R-1:\n          deltas_r.append(1)\n      if node[1] < C-1:\n          deltas_c.append(1)\n  \n      ret_list = []\n      for delta_r in deltas_r:\n          for delta_c in deltas_c:\n              next_node = (node[0]+delta_r, node[1] + delta_c)\n              if mat[next_node[0]][next_node[1]] not in ['*','v']:\n                  ret_list.append((next_node[0],next_node[1]))\n  \n      return ret_list\n  \n  def noNearbyMines(mat,node):\n      R = len(mat)\n      C = len(mat[0])\n      deltas_r = [0]\n      deltas_c = [0]\n      if node[0] > 0:\n          deltas_r.append(-1)\n      if node[1] > 0:\n          deltas_c.append(-1)\n      if node[0] < R-1:\n          deltas_r.append(1)\n      if node[1] < C-1:\n          deltas_c.append(1)\n  \n      for delta_r in deltas_r:\n          for delta_c in deltas_c:\n              if mat[node[0] + delta_r][node[1] + delta_c] == '*':\n                  return False\n      return True\n      \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n  \n", "substitutes": {"directory": ["prefix", "comments", "cat", "generated", "home", "filename", "folder", "Directory", "files", "path", "description", "module", "mode", "pattern", "unit", "cont", "config", "desc", "language", "uri", "command", "document", "tree", "d", "entry", "dir", "content", "page"], "R": ["id", "Range", "P", "CR", "E", "G", "SR", "RM", "pattern", "RG", "RL", "example", "A", "L", "Y", "GR", "RH", "r", "RO", "X", "D", "IR", "LR", "_", "V", "all", "index", "Rs", "JR", "H", "s", "I", "B", "input", "d", "pos", "RA", "Rh", "N", "MR", "Re", "W", "g", "K", "RW", "Q", "DR", "RS", "BR", "F", "RC", "RN", "S", "ed", "RR", "Res", "NR", "Line", "WR", "AR", "U"], "C": ["N", "Y", "NC", "SC", "AC", "Cs", "P", "VC", "DC", "CM", "CR", "Con", "E", "H", "CE", "Size", "G", "W", "CA", "K", "X", "c", "YC", "Sc", "JC", "CV", "CC", "Q", "CW", "I", "B", "Cu", "KC", "CS", "D", "CI", "Cr", "F", "O", "CT", "S", "CL", "Z", "EC", "MC", "V", "CU", "CN", "Code", "A", "L", "U"], "M": ["N", "Y", "MD", "v", " m", "FM", "P", "n", "MQ", "MS", "Man", "MR", "J", "CM", " L", "Ms", "VM", "r", "E", "H", "G", "MX", "RM", "W", "DM", "AM", "K", "X", "NM", "MU", "Q", "Memory", "I", "B", "range", "MF", "D", "F", "LM", "MM", "EM", "m", "O", "S", "CL", "MN", "ME", "Z", "MC", "V", "L", "U"], "l": ["all", "dl", "v", "e", "la", "pl", "sel", "t", "n", "lc", " L", "r", "li", "it", "nl", "lit", "el", "o", "ll", "g", "c", "s", "list", "len", "fl", "lis", "ul", "lv", "left", "le", "ml", "lp", "rl", "acl", "long", "m", "u", "lf", "ln", "b", "p", " lines", "d", "z", "ls", "ol", "kl", "lines", "lin", "ly", "f", "loc", "sl", "L"], "i": ["id", "ii", "v", "e", "ri", "bi", "ip", "n", "ind", "xi", "yi", "li", "iu", "r", "it", "c", "ti", "ie", "qi", "si", "y", "I", "start", "ni", "ci", "ini", "u", "m", "ai", "b", "p", "d", "pi", "int", "a", "di", "k", "f", "io", "ui"], "j": ["ji", "ii", "v", "n", "q", "J", "jj", "li", "r", "jc", "js", "g", "c", "ie", "jp", "jam", "jl", "y", "I", "m", "b", "p", "d", "z", "ij", "ja", "k", "f"], "empty_mat": ["empty_math", "blank_mat", "white_mat", "empty_batch", "empty67mat", "white_math", "empty_match", "blank_list", "empty_format", "empty67mas", " empty_mm", " empty_tab", "empty_list", "blank_all", "white_batch", " empty_format", "empty67batch", "empty_mas", "empty67math", "empty_tab", "empty_all", "blank_match", "empty_mm", "white_mas"], "found": ["missing", "Found", "matched", "successful", "fixed", "like", "default", "finished", "count", " find", "sect", "fall", "given", "old", "ll", "built", "fe", "fl", "expected", "finder", "find", "lost", "left", "printed", "source", "search", "loaded", "failed", "finding", " Found", "broken", "z", "new", "error", "filled", "Find", "used", "now", "confirmed", "form", "f", "temp", "still", "defined"], "output": ["log", "model", "complete", "target", "image", "letter", "unit", "command", "console", "current", "display", "content", "example", "L", "layer", "generated", "n", "format", "xml", "value", "connection", "config", "left", "job", "out", "analysis", "message", "expression", "str", "response", "new", "full", "resource", " Output", "fn", "all", "result", "control", "Output", "module", "production", "reason", "input", "language", "style", "write", "ln", "doc", "graph", "plain", "comment", "dot", "version", "summary", "string", "end", "text", "written", "shell", "file", "struct", "generation", "document", "debug", "lib"], "mine_placement": ["mine_expluster", "mine_replacing", "mine_splacing", "mine_Plignment", "mine_placing", "mine_replacement", "mine_splacements", "mine_splacement", "mine_pluster", "mine_plignment", "mine_Placements", "mine_repluster", "mine_placements", "mine_explacing", "mine_Placement", "mine_replacements", "mine_explacement", "mine_Pluster", "mine_Placing", "mine_explacements", "mine_splignment", "mine_replignment"], "mat": ["Mat", "atom", "col", "match", "ut", "mp", "position", "unit", "lat", "hm", "pat", "mac", "m", "feat", "material", "layer", "dom", "cat", "array", "n", "mt", "atten", "mm", "format", "net", "at", "list", "mult", "nt", "att", "config", "Matrix", "stat", "p", "wa", "ct", "md", "flat", "ma", "fn", "tab", "la", "phi", "table", "act", "man", "na", "math", "module", "dict", "wt", "hat", "qt", "ml", "pot", "grid", "plot", "mot", "mol", "map", "graph", "dot", "text", "nat", "c", "h", "lab", "dim", "file", "reg", "document", "lin", "arr", "loc", "temp", "test"], "cell": ["layer", "v", "key", "object", "cat", "character", "lc", "q", "model", "ce", "ell", "field", "edge", "label", "col", "el", "group", "cel", "co", "match", "c", "cle", "lic", "list", "element", "shell", "row", "unit", "letter", "cells", "column", "call", "p", "entry", "cc", "cy", "contact", "k", "case", "cl", "Cell", "char", "word"], "line": ["layer", "e", "look", "inline", "string", "code", "log", "n", "lc", "model", "run", "text", "li", "nl", "label", "col", "header", "lo", "match", "LINE", "len", "list", "section", "word", "name", "shell", "sync", "cycle", "unit", "row", "file", "left", "ml", "out", "input", "live", "range", "column", "source", "str", "lf", "ln", "frame", "block", "entry", "lines", "int", "chain", "lin", "error", "link", "Line", "case", "data", "point", "lined", "page"], "T": ["TR", "N", "Y", "Total", "Ts", "TN", "t", "P", "DT", "TS", "TI", "Length", "E", "H", "W", "K", "X", "Time", "NT", "Q", "I", "B", "TA", "D", "F", "WT", "Type", "O", "CT", "S", "TT", "Z", "V", "L", "U"], "testcase": ["estCase", "esttrial", "showcase", "fitcase", "catchtype", "catchsequence", "fitposition", "testCase", "catchcase", "showtype", "Testcase", " testCase", "testsequence", "exampletrial", "fitnumber", "exampleCase", "Testtrial", "Testtype", "TestCase", "estnce", "testnce", "testtrial", "estcase", "examplence", " testnumber", "testnumber", "showCase", "showsequence", "xtnumber", " testposition", "fitCase", "examplecase", "xtposition", "xtcase", "Testnce", "xtCase", "Testsequence", "testposition", "catchCase", "testtype"], "mat_cpy": ["mat_ncpython", "mat_locpy", "mat_cpc", "mat_fpc", "mat_Cp", "mat_Cpy", "mat_fopy", "mat_cps", "mat_Cpython", "mat_fps", "mat_fpy", "mat_Cpc", "mat_cpu", "mat_cachepy", "mat_fpu", "mat_popy", "mat_locpes", "mat128ccpe", "mat_cachepython", "mat_ncpsy", "mat_lpy", "mat_ppy", "mat_ccps", "mat_locpe", "mat128cpu", "mat_fpes", "mat128ccpy", "mat_Cpu", "mat_fPy", "mat_ccpy", "mat128cpe", "mat_ccpe", "mat_Cpsy", "mat_pPy", "mat128ccps", "mat_cpsy", "mat_ncpy", "mat_lopy", "mat128cps", "mat_cachepsy", "mat_Cps", "mat_locpc", "mat_fp", "mat_cpes", "mat128ccpu", "mat_cp", "mat_cpe", "mat_Copy", "mat_ccpu", "mat_ncpe", "mat_cPy", "mat_cachepe", "mat_lpe", "mat_cpython", "mat_Cpe", "mat_fpe", "mat_CPy", "mat_ppe", "mat_Cpes", "mat_copy", "mat128cpy", "mat_lp"], "oneclickcells": ["onefocusells", "oneclicklines", "onebuttonells", " onechiplines", "onecrosscells", "onefocuscells", "oneClickcell", " oneclickcats", "oneClickcells", "onefocusrows", "onechipholes", "oneleftcell", "onechiplines", "onecrossells", "oneClickstates", " oneswitchcells", "onefocuscases", "onechipcats", " oneclickholes", " onebuttoncs", "oneclickcats", "onebuttoncells", " onechipcats", "oneClickcats", " oneswitchells", "onepixelcats", " onebuttonholes", "oneswitchrows", "oneClicklines", "oneleftstates", "oneswitchcases", " oneclicklines", " oneclickstates", " onebuttonells", "oneclickrows", " oneclickcases", "oneswitchholes", "oneswitchcs", "oneclickcases", "oneleftcells", "oneswitchells", " oneclickells", " oneswitchrows", "onecrosscases", "oneclickcs", "onepixellines", "oneclickholes", " oneswitchcases", "onecrossrows", "oneswitchcells", "oneclickells", "onechipcells", "onechipells", "oneclickstates", "oneclickcell", " oneclickrows", " onechipcells", " oneclickcs", "onechipcs", "onebuttoncs", "onepixelcells", "onebuttonholes", " onebuttoncells", " oneclickcell"], "node": ["layer", "missing", "parent", "id", "N", "component", "remote", "e", "object", "key", "index", "cut", "parse", "location", "root", "child", "n", "card", "local", "model", "anch", "day", "core", "ha", "gen", "event", "mor", "package", "post", "edge", "un", "label", "cdn", "path", "stroke", "connection", "set", "enc", "element", "part", "name", "valid", "row", "input", "load", "source", "ode", "nn", "scene", "document", "tree", "leaf", "block", "dest", "link", "comment", "f", "seed", "op", "none", "loc", "Node", "live", "word", "route"], "f_in": ["f64inner", "fLogout", "f__in", "cf_inner", "f64in", "f_ins", "f__out", "cf_in", "f2out", "f_resource", "f__ins", "f_inner", "sf_inner", "cf_out", "sf_in", "fLogins", "f64out", "sf_In", "f64ins", "sf_out", "fLoginner", "f_In", "cf_ins", "fLogin", "f2inner", "f__inner", "sf_resource", "f2ins", "f2in", "sf_ins"], "f_out": ["c_out", "f2output", " f2in", "f_temp", "f_err", "fiddleout", "c_err", "f__in", "f__err", "f__out", "f2out", " f_temp", " f2out", " f_engine", "fiddlein", "fiddletemp", "c_in", "firmout", "f2err", "f__io", "f_io", "c_io", " f_io", "fiddleengine", "firmin", "firmtemp", " f2io", " f2output", "f_output", " f_output", "f_engine", "firmengine", "f2io", "f2in"]}}
{"code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/A/'\n  \n  \n  \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          \n          c1 = int(f_in.readline())\n          l1 = []\n          for i in range(4):\n              l1.append(f_in.readline())\n          \n          c2 = int(f_in.readline())\n          l2 = []\n          for i in range(4):\n              l2.append(f_in.readline())\n  \n          d1 = l1[c1-1].split()\n          d2 = l2[c2-1].split()\n  \n          foundFlag = False\n          chosenCard = None\n          badMagician = False\n          for card in d1:\n              if card in d2:\n                  if not foundFlag:\n                      foundFlag = True\n                      chosenCard = card\n                  else:\n                      badMagician = True\n  \n          f_out.write('Case #' + str(testcase) + ': ')\n          if badMagician:\n              f_out.write('Bad magician!\n')\n          elif not foundFlag:\n              f_out.write('Volunteer cheated!\n')\n          else:\n              f_out.write(chosenCard + '\n')\n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n", "substitutes": {"directory": ["service", "prefix", "definition", "root", "timeout", "category", "direct", "home", "minute", "picture", "output", "distance", "filename", "package", "drive", "office", "whatever", "folder", "Directory", "space", "path", "description", "module", "mode", "connection", "collection", "window", "storage", "binary", "template", "python", "application", "config", "duration", "project", "selection", "environment", "command", "manager", "message", "language", "source", "machine", "expression", "password", "document", "library", "tree", "d", "volume", "division", "tty", "system", "archive", "resource", "dir", "number", "direction", "location", "database"], "f_in": ["rf_bin", "f_ins", "sf_int", "f_nin", "fLoginside", " f_nin", "f__inn", "f_int", "fLogins", "rf_in", "f_inn", "f_init", "sf_out", "f__In", "fLogin", " f_inner", "sf_ins", "fLogout", "f__in", "f_inner", "f8nin", "f_inside", "rf_nin", "sf_inn", "f8ins", "rf_out", " f_In", "f__inner", "f_again", "sf_init", "f_IN", "sf_nin", " f_ins", "sf_in", "f_In", "f__out", "f__init", "f_bin", "sf_inner", "sf_IN", "f8out", " f_inside", "f__IN", " f_again", "f8in"], "f_out": ["c_out", "f_w", "c_in", "f2err", "f_OUT", "f__again", " f_OUT", " f_Out", "f2again", "fadeagain", "f__OUT", "f__in", "fockouts", " f_w", " f_err", "f__outs", "f_again", "f__Out", "fadein", "fockin", "fockagain", "f_outs", "f_Out", "f_err", "c_again", "f__out", "f2out", "fockout", "fadeout", " f_again", "c_outs", "fadew", "f2in"], "T": ["N", "Y", "Total", "TN", "t", "P", "time", "trial", "DT", "TI", "Length", "E", "H", "G", "W", "X", "Time", "R", "Test", "Q", "I", "B", "D", "F", "O", "S", "TT", "C", "NUM", "M", "A", "L", "V", "IP"], "testcase": [" testcode", "matchcode", "newc", "matchcases", "matchCase", " testc", "testCase", "Testcase", "testingCase", "newcases", "newcase", "testcases", "testtest", "matchtest", "matchc", "TestCase", "testsection", "Testtest", "testc", "matchcase", "matchsection", "testingcase", "testingtest", "newcode", "testingsection", "Testsection", "testcode", " testcases"], "c1": ["cOne", "C3", "lc1", "lc2", "lOne", " c3", "C1", " cOne", "c3", "l0", "COne", "lc0", "C2", "lcOne", "l3", "c0", " c0"], "l1": ["ln0", "t0", "L0", "l61", "t2", "Lanks", "ln1", "r1", "L001", "t61", "lfirst", " l61", "r4", " lanks", "d0", "Lfirst", " l0", "lc1", "li001", "lc2", "lc4", "r2", "lanks", "ln3", "cfirst", "t1", "L4", "c3", "c001", "l0", "d61", "li0", "d3", "l001", "li2", "l3", "L1", "c0", "li1", "lnfirst", "dfirst", "l4", "rfirst", "lianks", "L2", "lcfirst"], "i": ["id", "j", "ii", "v", "e", "index", "ip", "l", "n", "ind", "li", "iu", "r", "it", "g", "c", "ti", "ie", "h", "I", "ci", "u", "ai", "b", "p", "z", "pi", "int", "a", "isin", "di", "f", "io"], "c2": ["n2", " c96", "n96", "cs2", " c02", "l02", "c02", " c5", "cetwo", "csTwo", "cstwo", "ceTwo", "c5", "ce2", "ctwo", "l96", " cTwo", "n02", "l0", "n0", " ctwo", "c96", "cs5", "c0", "ce5", " c0", "cTwo"], "l2": ["d02", "li6", "isecond", " l4", "d6", "rltwo", "rl4", "l02", "el02", "c4", "i2", "el2", "el6", "rl2", "li02", "ctwo", "i1", "c3", "el3", "li3", "rlsecond", " lsecond", "l6", "d3", "dsecond", " ltwo", "li2", "l3", "l4", "i3", "csecond", "lsecond", "ltwo"], "d1": ["d4", "ld4", "cOne", "ld1", "c4", "lOne", "dOne", "c3", "f1", "f4", "ldOne", "d3", "ld2", "f3", "l3", "l4", "f2"], "d2": [" d7", "n2", "n4", "c8", "d4", "d7", "d8", "c7", "nTwo", "c4", "l8", " dTwo", "dtwo", "n7", " dtwo", "ctwo", " d8", "dTwo", "cTwo", "ltwo", " d4"], "foundFlag": ["foundflag", " foundflag", "findFlag", "foundFlags", "foundCard", "givenflag", "FoundFlag", "FoundCard", "givenFlag", " foundCard", " Foundflag", "FoundFlags", "Foundflag", "givenFlags", " foundFlags", "findCard", " FoundFlag"], "chosenCard": ["choinLine", "choincard", "chosedLine", "chrawnCat", " chainedChar", "chrawnLine", "corosenFlag", "chosercard", "chosencard", " Chosencard", "chainedCard", " chosenCat", "choinCard", " chainedCell", "chosedCard", "chribedcard", "chosenChar", "chosenCase", "chribedCell", "choinCat", "chribedChar", " chosenChar", "choserFlag", "chrawnCard", "corosenCard", "choserCase", "chribedCase", "corosercard", "choinCell", "chosedCase", "chosedCat", "chosenLine", "chosenCat", "coroserCard", "choinChar", "chosenCell", "coroserCase", "chribedCard", " ChoinLine", "corosenCase", " ChosenLine", "chainedCell", "coroserFlag", "choserCard", "chribedFlag", "chrawncard", "chosedcard", "chainedCat", "chosedFlag", "corosencard", " chainedCat", "chainedChar", " ChoinCat", "chribedCat", " chosenCell", " Choincard", " ChosenCat", "chosenFlag", " ChoinCard", " chainedCard", " ChosenCard"], "badMagician": ["Badmagicians", "Badmagian", "badMatian", "BadMagick", "badmagick", "badMAGicians", "badMagnicator", "badmagicians", "badmagicator", "badMaticians", "BadMagician", "badTechnician", "badMerician", "badMAGian", "badmagician", "Badmagician", "badMagicians", "badMericator", "badTechnicians", "BadMagicians", "badMAGick", "badMerick", "badMericians", "badMagnicians", "badMagnician", "BadMagian", "badMAGician", "badMagicator", "badMagnian", "badmagian", "badMerian", "badMatician", "badMatick", "Badmagick", "badTechnian", "badTechnick", "badMagick", "Badmagicator", "badMagian", "BadMagicator"], "card": ["dom", "A", "id", "valid", "crit", "cat", "draw", "category", "compl", "default", "Default", "no", "character", "day", "man", "gu", "any", "du", "coord", "ward", "co", "match", "div", "X", "list", "coll", "cd", "arc", "cont", "cf", "cards", "viol", "D", "ci", "custom", "ard", "null", "void", "Card", "yes", "d", "C", "check", "Case", "comment", "cell", "none", "Na", "cart", "char", "word", "defined"], "filenames": ["fileenumbers", "filvenumbers", "ilennums", " filonenumbers", "fileernumbers", "filonenamed", "filenAMES", "filenamed", "filernumbers", "filernamed", "filenuments", " filonuments", "filtenuments", " filonrams", " filonenews", "filfenames", "fillenumbers", "filtenrams", "filennews", "ilenumbers", "filenews", "filenaming", "filfenumbers", "filtenAMES", "filennations", "filvenamed", "filrenamed", " filonames", "fileenames", "fileenamed", "filennamed", "filtenames", "filENrams", "filenrams", "ilenations", "ilennumbers", "filrenews", " filonenames", "ilenames", " filenamed", " filenAMES", "filfenations", "ilennames", "filrenames", "filonAMES", "fillenames", "ilennations", "fileernames", " filonenamed", "filernaming", "filonenews", "filvenames", " filenuments", "filonenumbers", "filennumbers", " filenrams", "filENAMES", "fileernamed", "fileenaming", "filvenaming", "filENames", "filonenames", "filenums", "filenations", "filENuments", "fillenations", "fillenums", "filonrams", "ilenums", "fileernaming", "filfenums", " filonAMES", "filrenumbers", " filenumbers", "filennames", "filonenaming", "filernames", "filenumbers", "filonuments", "filennums", " filenews", "filonames"], "x": ["opt", "v", "rax", "t", " xx", "filename", "ux", "xc", "m", "search", "ph", "ax", "xs", "sex", " X", "content", "rx", "l", "array", "n", "xy", "time", "xxxx", "xxx", "X", "xml", "ex", "xp", "name", "xa", "xt", "ext", "hex", "xf", "p", "ix", "a", "ct", "_", "ctx", "com", "prefix", "rex", "index", "xb", "code", "q", "www", "xi", "y", "ci", "dx", "xd", "d", "cross", "ch", "mx", "f", "data", "xe", "xx", "e", "string", "tx", "fx", "w", "co", "g", "path", "c", "h", "xes", "upload", "file", "php", "z", "nex", "wx", "work", "lex", "test"], "chosen_filename": ["chosen2name", "chotedPFilename", "chitched_template", "chosen_string", "chosen_name", "choted_name", "choseningfile", "chosing_filename", "chosenPname", "chosing_name", "chosen2Filename", "choseningfilename", "chosen2filename", "choseningname", "choted_filename", "choted_Filename", "chosen_path", "chosen_Filename", "chosenPfilename", "chosenPstring", "chosenPFilename", "chotedPstring", "chosen_file", "chitched_directory", "chitched_filename", "choted_string", "chosen_template", "chitched_path", "chosing_Filename", "chotedPfilename", "chosing_file", "chotedPname", "choseningFilename", "chosen_directory", "chosen2file"]}}
{"code": " \n  \n  FREE = '.'\n  BOMB = '*'\n  CLICK = 'c'\n  \n  \n  class Board:\n  \n  \tdef __init__(self, R, C, M):\n  \t\tself.initial_M = M\n  \t\tself.R = R\n  \t\tself.C = C\n  \t\tself.M = M\n  \t\tself.matrix = [[FREE for c in range(C)] for r in range(R)]\n  \t\tself.endx = len(self.matrix[0])\n  \t\tself.endy = len(self.matrix)  # 0 < R * C\n  \t\tself.startx = 0\n  \t\tself.starty = 0\n  \n  \tdef fill_row(self, row):\n  \t\tfor c in self.range_active_cols:\n  \t\t\tself.matrix[row][c] = BOMB\n  \t\tself.starty += 1\n  \t\tself.M -= self.active_cols\n  \n  \tdef fill_col(self, col):\n  \t\tfor r in self.range_active_rows:\n  \t\t\tself.matrix[r][col] = BOMB\n  \t\tself.startx += 1\n  \t\tself.M -= self.active_rows\n  \n  \tdef pprint(self):\n  \t\tfor row in self.matrix:\n  \t\t\tfor cell in row:\n  \t\t\t\tprint(cell, end='')\n  \t\t\tprint()\n  \n  \t@property\n  \tdef active_rows(self):\n  \t\treturn self.endy - self.starty\n  \n  \t@property\n  \tdef active_cols(self):\n  \t\treturn self.endx - self.startx\n  \n  \tdef optimize(self):\n  \t\twhile 1:\n  \t\t\tif (self.active_cols <= self.active_rows\n  \t\t\t\t\tand self.active_cols <= self.M):\n  \t\t\t\tself.fill_row(self.starty)\n  \t\t\telif (self.active_rows < self.active_cols\n  \t\t\t\t\tand self.active_rows <= self.M):\n  \t\t\t\tself.fill_col(self.startx)\n  \t\t\telse:\n  \t\t\t\tbreak\n  \n  \t@property\n  \tdef range_active_cols(self):\n  \t\treturn range(self.startx, self.endx)\n  \n  \t@property\n  \tdef range_active_rows(self):\n  \t\treturn range(self.starty, self.endy)\n  \n  \tdef is_free(self, row, col):\n  \t\treturn self.matrix[row][col] == FREE\n  \n  \tdef place_bomb(self):\n  \t\tfor row in self.range_active_rows:\n  \t\t\tfor col in self.range_active_cols:\n  \t\t\t\tif (self.is_free(row, col) \n  \t\t\t\t\t\tand row + 2 < self.R\n  \t\t\t\t\t\tand col + 2 < self.C):\n  \t\t\t\t\tself.matrix[row][col] = BOMB\n  \t\t\t\t\tself.M -= 1 \n  \t\t\t\t\treturn True\n  \t\tfor col in self.range_active_cols:\n  \t\t\tfor row in self.range_active_rows:\n  \t\t\t\tif (self.is_free(row, col)\n  \t\t\t\t\t\tand row + 2 < self.R\n  \t\t\t\t\t\tand col + 2 < self.C):\n  \t\t\t\t\tself.matrix[row][col] = BOMB\n  \t\t\t\t\tself.M -= 1\n  \t\t\t\t\treturn True\n  \t\treturn False\n  \n  \tdef mark_click(self):\n  \t\tself.matrix[-1][-1] = 'c'\n  \n  \tdef win_condition(self):\n  \t\tclick_row = len(self.matrix) - 1\n  \t\tclick_col = len(self.matrix[0]) - 1\n  \t\tif (click_col - 1 >= 0\n  \t\t\t\tand not self.is_free(click_row, click_col - 1)):\n  \t\t\treturn False\n  \n  \t\tif (click_row - 1 >= 0\n  \t\t\t\tand not self.is_free(click_row - 1, click_col)):\n  \t\t\treturn False\n  \n  \t\tif (click_row -1 >= 0\n  \t\t\t\tand click_col -1 >= 0\n  \t\t\t\tand not self.is_free(click_row - 1, click_col - 1)):\n  \t\t\treturn False\n  \t\t\n  \t\treturn True\n  \n  \tdef win_cond2(self):\n  \t\tif self.initial_M + 1 == self.C * self.R:\n  \t\t\treturn True\n  \t\treturn False\n  \n  \tdef solve(self):\n  \t\tself.optimize()\n  \t\twhile self.M > 0 and self.place_bomb():\n  \t\t\tpass\n  \t\tif self.M == 0 and (self.win_condition() or self.win_cond2()):\n  \t\t\tself.mark_click()\n  \t\t\tself.pprint()\n  \t\telse:\n  \t\t\tprint('Impossible')\n  \n  \n  def read_case(f):\n  \treturn map(int, f.readline().split())\n  \n  \n  def main():\n  \tfn = sys.argv[1]\n  \twith open(fn, encoding='utf-8') as f:\n  \t\tncases = int(f.readline())\n  \t\tfor case in range(1, ncases + 1):\n  \t\t\tR, C, M = read_case(f)\n  \t\t\tprint('Case #{}:'.format(case))\n  \t\t\tb = Board(R, C, M)\n  \t\t\tb.solve()\n  \n  \n  def main1():\n  \tb = Board(2, 1, 1)\n  \tb.solve()\n  \n  \n  if __name__ == '__main__':\n  \tmain()\n", "substitutes": {"FREE": ["random", "A", "N", "Y", "ST", "ERE", "MAX", "DE", "OFF", "Free", "VALUE", "OWN", "ONE", "RE", "DEF", "NEW", "FE", "RO", "FA", "ROM", "WARNING", "GE", "X", "MW", "OVER", "REM", "CO", "MER", "ARM", "RA", "DOWN", "cf", "B", "USE", "D", "F", "NO", "free", " free", "ERO", "CON", "ME", "NE", "FR", "UME", "new", "DER", "ECA", "ANY", "REE", "NAME", "UM", "LE", "data", "LINE", "UN", "OK", "U", "WARN", "EW"], "BOMB": ["OBOMM", "BOLB", "SBomB", "SBomE", "BOMD", "OBOMB", "SBomF", "BOTO", "OBOMO", "BomF", "BARF", "BomA", "SBOMA", "BAMB", "OBOMD", "BANKBE", "BANKM", " BOMM", "BOMBE", "BomM", "BOLM", "BOMM", "OBomD", "SBOMF", "BomD", "BomBE", "SBOME", "BANKA", "OBomB", "BOTD", "BOLD", "BomB", "OBomO", "BANKF", "BAME", "BAMF", "BOMF", "BOLO", "BARBE", "BomE", " BARM", "BANKE", "OBomM", "BOMO", " BARBE", "BARM", "BomO", "BANKB", "BOMA", "BOME", " BARF", "SBOMB", "BAMA", "BOTB", " BARB", "BARB", "SBomA", " BOMBE", " BOMF", "BOTM"], "CLICK": ["ClICK", " Click", "CLACK", " ClICE", " ClICK", " ClACK", "CLick", "ClACK", " CLACK", " CLick", "CLICE", " CLICE", "Click", "ClICE"], "self": ["parent", "game", "members", "v", "sys", "http", "hand", "err", "remote", "per", "model", "args", "ok", "complete", "spec", "field", "old", "ref", "div", "private", "mp", "master", "ws", "tmp", "qa", "app", "go", "events", "your", "false", "auto", "now", "k", "api", "case", "resp", "shared", "instance", "layer", "object", "l", "no", "n", "time", "writer", "comp", "os", "top", "connection", "google", "name", "reader", "proc", "plugin", "high", "config", "cook", "acl", "function", "p", "block", "new", "full", "axis", "error", "a", "support", "next", "form", "plus", "ctx", "_", "word", "Self", "missing", "all", "cs", "parse", "user", "result", "other", "q", "dev", "man", "event", "func", "group", "on", "public", "math", "s", "type", "progress", "filter", "raw", "ng", "context", "skip", "host", "style", "view", "method", "lf", "yes", "frame", "d", "ch", "pos", "line", "client", "map", "data", "er", "f", "x", "worker", "part", "cb", "utils", "e", "ack", "default", "home", "cache", "w", "this", "show", "co", "me", "g", "conn", "h", "i", "craft", "cmd", "lock", "manager", "load", "struct", "close", "elf", "results", "cl", "player", "callback", "work", "node", "wrapper", "off", "page"], "R": ["N", "Y", "Row", "T", "Rs", "P", "RE", "MR", "RH", "CR", "E", "G", "H", "SR", "RM", "W", "RO", "RF", "Right", "X", "RS", "B", "RP", "D", "F", "RN", "RL", "S", "RR", "V", "NR", "A", "L", "U", "RA"], "C": ["N", "Y", "NC", "SC", "T", "CNN", "Cs", "P", "VC", "DC", "Cl", "CR", "E", "G", "H", "W", "COR", "CA", "K", "X", "JC", "CV", "CO", "CC", "Cu", "B", "I", "D", "F", "RC", "CI", "CT", "S", "CL", "EC", "MC", "V", "CU", "CN", "A", "L", "U"], "M": ["Y", "N", "MD", "MIN", "T", "FM", "P", "MQ", "MS", "Man", "MO", "J", "CM", "E", "SM", "G", "MX", "H", "RM", "W", "DM", "AM", "X", "NM", "MAL", "Q", "OM", "I", "B", "MF", "D", "F", "MB", "JM", "LM", "MM", "m", "O", "S", "MA", "Z", "MN", "MC", "V", "A", "L", "U"], "initial_M": ["random_F", "random_R", "initial_R", "random_m", "random_M", "initial_F", "initial_m"], "matrix": [" matbox", "MATfix", "Matbook", "Matrator", "MATcube", "matric", "matbox", "catuit", "atbox", "matxi", "Matfix", "catMatrix", "dimrix", "atometry", "atrices", "matfix", "latogram", "catrix", " matuit", "Matxi", "mxi", " matrator", "matometry", " matrices", "matcube", "matogram", "memrices", " matMatrix", "Matcube", " matbook", "dimMatrix", "Matbox", "dimuit", "latstrument", "dimrices", "mrices", "memstrument", "latrix", "Matric", "atric", "Matrix", "mometry", "memrix", "dimcube", "atxi", "atrix", "mric", "matuster", "matrices", "matuit", "Matuster", "matbook", "atrator", "latrices", "mrix", "matMatrix", "Matstrument", "matstrument", "atbook", " matuster", "memogram", "dimfix", "Matrices", "matrator", " matometry", "MATrices", "MATrix", "catrices", "Matogram", "atuster", " matric"], "c": ["x", "cb", "e", "v", "nc", "unc", "uc", "l", "code", "dc", "n", "lc", "right", "w", "ctrl", "rec", "co", "cr", "s", "h", "i", "arc", "ac", "rc", "anc", "y", "cf", "ci", "con", "m", "cm", "u", "mc", "p", "d", "fc", "cur", "ct", "a", "cc", "cor", "k", "f", "rn"], "r": ["j", "v", "fr", "rr", "err", "e", "yr", "rf", "ru", "br", "l", "n", "ro", "rd", "gr", "run", "right", "w", "dr", "rh", "ref", "cr", "ir", "h", "ar", "attr", "i", "nr", "rc", "reg", "nor", "sr", "range", "pr", "ur", "m", "rb", "cm", "rs", "tr", "u", "p", "d", "rg", "re", "k", "f"], "endx": ["Endw", "idw", "idx", " endX", "idX", "midyn", "midX", "endw", "midx", "Endx", " endyn", "endyn", "midy", "startX", " endw", "EndX", "idy", "Endy", "endX", "startyn", "startw"], "endy": ["endedy", "startcol", "endedx", "endyy", "headyy", "endedys", "pendcol", "pendx", " endyy", "headx", "heady", "startys", "headY", "Endx", " endys", "endY", "startyy", "endys", " endY", "endcol", "pendY", "Endcol", "pendy", "endedY", "startY", "Endy", "EndY"], "startx": ["Startw", "idz", "startcol", "endry", "storey", "storex", " startw", "idx", "endX", "Starty", " startry", "minx", "endw", "frontry", "Startx", "storez", "startz", " startz", "Startz", "startry", "endyn", "minz", " startX", " startyn", "mincol", "storeyn", "frontx", "startX", "frontX", "endcol", "miny", "endz", "fronty", "idy", " startcol", "idw", "startyn", "startw"], "starty": ["beginx", "endrow", "idz", "showrow", "startrow", "endvy", "idx", "Starty", "headx", "beginy", "heady", "inity", "headyn", "idya", "beginvy", "headY", "endya", "Startx", "Startz", "startz", "idY", "endY", "startvy", "endyn", "showx", "initx", " startyn", " startY", "Startrow", " startya", "initvy", "endz", "beginY", "idy", "showY", "startY", "initY", "showy", "startyn", "startya", "StartY"], "row": ["run", "feed", "week", "window", "coll", "head", "rc", "uu", "range", "df", "roll", "hour", "bug", "array", "slice", "lc", "round", "cr", "sc", "reader", "roc", "rows", "ry", "block", "arrow", "fc", "flow", "rown", "rr", "index", "query", "user", "q", "month", "order", "board", "group", "ward", "element", "raw", "item", "view", "tr", "grid", "frame", "line", "cur", "oy", "f", "port", "record", "x", "Row", "e", "key", "ack", "child", "ro", "right", "post", "w", "rh", "o", "co", "batch", "h", "arch", "ow", "column", "null", "rw", "year", "entry", "rect", "link", "cl", "node", "loc", "page"], "col": ["ail", "v", "field", "collection", "coll", "cn", "win", "roll", "ol", "pull", "j", "cat", "sel", "l", "lc", "offset", "cr", "num", "con", "p", "block", "COL", "fc", "ct", "cor", "th", "rr", "uc", "index", "ind", "q", "day", "act", "month", "ell", "el", "Col", "rel", "fl", "y", "cf", "yl", "vc", "ch", "pos", " coll", "line", "cur", "f", "Column", "icol", "x", "key", "patch", "child", "w", "co", "h", "i", "val", "column", "null", "year", "int", "cy", "cl", "loc", " column", "pr"], "cell": ["j", "Row", "v", "key", "index", "atom", "array", "slice", "q", "month", "field", "ell", "spec", "label", "group", "cel", "co", "div", "window", "i", "ad", "y", "num", "range", "cells", "column", "str", "grid", "call", "line", "entry", "obj", "k", "f", "node", "number", "Cell", "char", "record"]}}
{"code": " \n  \n  \n  def read_grid(f):\n  \treturn [\n  \t\t[int(x) for x in line.split()]\n  \t\tfor line in [f.readline() for _ in range(4)]\n  \t]\n  \n  def read_case(f):\n  \tanswer1 = int(f.readline())\n  \tgrid1 = read_grid(f)\n  \tanswer2 = int(f.readline())\n  \tgrid2 = read_grid(f)\n  \treturn (grid1[answer1 - 1], grid2[answer2 - 1])\n  \n  \n  def solve(r1, r2):\n  \tres = set(r1) & set(r2)\n  \tif len(res) == 0:\n  \t\treturn 'Volunteer cheated!'\n  \tif len(res) == 1:\n  \t\treturn list(res)[0]\n  \treturn 'Bad magician!'\n  \n  \n  \n  def main():\n  \tfn = sys.argv[1]\n  \twith open(fn, encoding='utf-8') as f:\n  \t\tncases = int(f.readline())\n  \t\tfor case in range(1, ncases + 1):\n  \t\t\trow1, row2 = read_case(f)\n  \t\t\tsolution = solve(row1, row2)\n  \t\t\tprint('Case #{}: {}'.format(case, solution))\n  \n  \n  if __name__ == '__main__':\n  \tmain()\n", "substitutes": {"f": ["e", "fr", "v", "ff", "http", "rf", "l", "t", "tf", "fa", "af", "r", "w", "fd", "fx", "feed", "files", "folder", "ref", "bf", "g", "c", "fe", "self", "h", "i", "fore", "inf", "file", "finder", "fen", "fw", "input", " F", "F", "handler", "fi", "of", "fm", "fp", "m", "function", "lf", "frame", "b", "p", "fs", "fb", "df", "d", "xf", "buff", "fc", "full", " df", "flat", "form", "sf"], "x": ["rx", "id", "xe", "xx", "e", "v", "key", "index", "px", "t", "xy", "n", "q", " xx", "xi", "r", "w", "X", "c", "ex", "i", "xp", "y", "row", "xc", "yx", "str", "dx", "p", "z", "ix", "int", "xs", " X", " y", "pair"], "line": ["id", "e", "fr", "inline", "string", "l", "code", "n", "lc", "ine", "run", "li", "r", "nl", "answer", "c", "len", "word", "name", "fl", "file", "row", "range", "str", "lf", "ln", "frame", "b", "p", " lines", "d", "block", "lines", "chain", "int", "lin", "Line", "cell", "lined", "page"], "_": ["all", "l", "time", "g", "by", "len", "file", "long", "non", "p", " time", "k"], "answer1": ["response0", "response1", "addressone", "issueone", "issue1", " answer0", "addressOne", "responseOne", "responseone", " answerOne", "answer01", "address1", "response01", "address0", " answer01", "issue01", "answerone", "answer0", "answerOne", " answerone"], "grid1": ["lineBack", "row01", "grid01", "rank01", " grid01", "rowpart", "gridpart", " gridpart", "lineone", "line2", "grain2", "rankpart", "rank1", "grainone", "rowone", "rowBack", "grain1", "rank2", "line1", "grainBack", "gridBack", "gridone"], "answer2": [" answerTwo", "resultTwo", "result02", "response02", "result22", "answer22", "response2", "answer02", "response22", "grid22", "AnswerTwo", "grid02", "gridTwo", "responseTwo", "Answer1", "answerTwo", "Answer2", "result2"], "grid2": ["grid0", "range2", "gridtwo", "row4", "gridall", "grid4", "rowTwo", " gridTwo", " grid4", "row0", "gridTwo", "rangetwo", " gridtwo", "range4", "rowall", "rowtwo", " gridall", " grid0", "answer0", "rangeTwo", "answerall"], "r1": ["Rone", "rh83", "ro1", "sr3", "rone", "sr1", "rh51", "ra1", "R3", " rone", "rh1", "srone", "ro51", " r3", "ra83", "ra01", "r3", "ro83", "R2", "rh01", "sr2", "R1", "ro01", "r83", "r51", "ra51", "r01"], "r2": [" r02", "r02", " r4", "sr02", "sr1", "r4", "sr0", "R02", "p2", "r0", "sr4", "p4", " r0", "R2", "p0", "sr2", "R1", "p1", "R0"], "res": ["part", "remote", "rr", "err", "rss", "result", "ras", "our", "Result", "vre", "resh", "gr", "core", "right", "pres", "r", "os", "spec", "des", "rh", "sol", "rec", "RES", "rez", "rm", "R", "rel", "reed", "rev", "val", "row", "ret", "reg", "rest", "req", "rs", "resolution", "grid", "ver", "details", "box", "results", "response", "rem", "Res", "rect", "vals", "re", "data", "resp"], "fn": ["bin", "ff", "np", "dn", "output", "rn", "filename", "bn", "fd", "fin", "cdn", "func", "path", "bf", "wl", "sn", "fe", "conn", "wt", "kn", "fl", "cn", "file", "fen", "arf", "cf", "syn", "fil", "method", "fm", "fp", "function", "ln", "b", "FN", "fs", "p", "fb", "fc", "feat", "nm", "sf", "hn", "fun"], "ncases": ["nases", "ncased", "aucases", "nicase", "nasing", "nicases", "aucased", "necased", "aucasing", "nicased", "necasing", "ncasing", "necases", "nased", "aucase", "nase", "necase", "ncase", "nicasing"], "case": ["instance", "fold", "nce", "id", "definition", "string", "rule", "result", "code", "change", "cer", "time", "trial", "ace", "ce", "rice", "core", "r", "chance", "du", "shape", "space", "path", "match", "ice", "sc", "pe", "section", "name", "size", "position", "row", "sequence", "base", "length", "division", "a", "Case", "ase", "cases", "condition", "data", "number", "test"], "row1": ["ry9", "ryone", "ro1", "roone", "row01", "rows9", "ow3", "rowsone", " row01", "ro2", "ry2", "ro9", "rows1", "ry1", "rowone", "Row3", "ow01", "Row1", "row3", "ow1", " row3", "row9", "Row01", "rows2"], "row2": ["order4", "row4", "ow4", "lineTwo", " rowtwo", "rowsTwo", "rowTwo", "linetwo", "ordertwo", " rowTwo", "line2", "orderTwo", "rows4", "ow2", "owTwo", "rows1", "order2", "line4", " row4", "rowtwo", "ow1", "rows2"], "solution": [" solve", "ssolutions", "insolve", "Solution", "ssolver", "solve", " solved", "insolver", "Solve", "Solver", "insolved", "Solutions", "ssolved", "ssolution", "solver", " solutions", "insolution", "ssolve", "solutions", "solved", " solver"]}}
{"code": " \n  lines = [line.strip() for line in open(sys.argv[1])]\n  count = int(lines[0])\n  \n  for i in xrange(count):\n      R,C,M = map(int, lines[i+1].split())\n      print \"Case #%s:\" % (i+1)\n  \n      w = max(R,C)\n      h = min(R,C)\n      X = R*C - M\n      assert X > 0\n  \n      if X == 1:\n          rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]\n      elif h == 1:\n          rows = ['c' + '.' * (X-1) + '*' * M]\n      elif X == 4:\n              rows = [\n                  'c.' + '*' * (w-2),\n                  '..' + '*' * (w-2),\n              ] + ['*' * w] * (h-2)\n      elif h == 2:\n          if X%2 == 1 or X == 2:\n              rows = None\n          else:\n              rows = [\n                  'c' + '.' * (X/2-1) + '*' * (M/2),\n                  '.' + '.' * (X/2-1) + '*' * (M/2)\n              ]\n      elif X <= 5 or X == 7:\n          rows = None\n  \n      elif X%2 == 0 and X <= w*2:\n          r = X/2\n          rows = [\n              'c' + '.' * (r - 1) + '*' * (w-r),\n                    '.' * r       + '*' * (w-r),\n          ] + ['*' * w] * (h-2)\n  \n      elif X <= w*3 and (X % 3) != 1:\n          n = (X+1) / 3\n          t = X - 2*n\n          rows = [\n              'c' + '.' * (n-1) + '*' * (w-n),\n                    '.' * n     + '*' * (w-n),\n                    '.' * t     + '*' * (w-t)\n          ] + ['*' * w] * (h-3)\n      else:\n          n = X / w\n          t = X % w\n          if t == 1:\n              rows = (\n                      ['c' + (w-1) * '.']\n                  +   ['.' * w] * (n-2)\n                  +   ['.' * (w-1) + '*']\n                  +   ['..' + '*' * (w-2)]\n                  +   ['*' * w] * (h - n - 1)\n              )\n          else:\n              k = 1 if t == 0 else 0\n              rows = (\n                      ['c' + (w-1) * '.']\n                  +   ['.' * w] * (n-1)\n                  +   ['.' * t + '*' * (w-t)] * (1 - k)\n                  +   ['*' * w] * (h - n - 1 + k)\n              )\n  \n      if rows:\n          if R > C:\n              rows = [\"\".join(row[i] for row in rows) for i in xrange(R)]\n  \n          for row in rows:\n              print row\n  \n          assert len(rows) == R\n          assert len(rows[0]) == C\n          assert sum(1 for row in rows for col in row if col == '*') == M\n  \n      else:\n          print \"Impossible\"\n  \n", "substitutes": {"lines": ["blocks", "groups", "los", "headers", "points", "vs", "ds", "l", "models", " Lines", "args", "limits", "files", "posts", "words", "links", "s", "ips", "ins", "ines", "values", "ses", "objects", "cells", "qs", "strings", "plugins", "letters", "lins", "elines", "runs", "ids", "breaks", "items", "ls", "es", "vals", "xs", "pages", "lined"], "line": ["e", "v", "inline", "sel", "l", "lane", "code", "lc", "ine", "day", "li", "nl", "c", "cle", "name", "file", "split", "le", "source", "m", "str", "lf", "page", "block", "d", "strip", "lin", "link", "Line", "cell", "de", "f", "LINE", "sl", "word"], "count": ["x", "N", "id", "index", "code", "l", "q", "c", "len", "coll", "counter", "sum", "depth", "limit", "total", "size", "y", "max", "start", "num", "con", "m", "base", "found", "call", "b", "ch", "z", "length", "cc", "Count", "case", "number"], "i": ["x", "id", "j", "ui", "ii", "e", "index", "multi", "l", "mi", "slice", "phi", "ind", "xi", "yi", "li", "iu", "c", "ti", "gi", "qi", "chi", "y", "si", "vi", "I", "start", "eni", "uri", "inner", "ci", "my", "ini", "iq", "u", "m", "ai", "p", "d", "pi", "int", "mini", "di"], "R": ["Rh", "Y", "N", "T", "GR", "Rs", "P", "CR", "RH", "U", "E", "H", "G", "SR", "RM", "W", "RO", "K", "Q", "RS", "I", "B", "D", "F", "RC", "IR", "S", "RR", "Res", "NR", "A", "L", "V", "RA"], "C": ["Y", "N", "SC", "T", "AC", "P", "VC", "DC", "CM", "CR", "Cl", "U", "E", "H", "G", "W", "K", "c", "CC", "Q", "I", "B", "D", "F", "Cr", "Ch", "O", "Max", "S", "Z", "MC", "WC", "A", "L", "V"], "M": ["N", "Y", "MD", "T", "P", "MS", "MR", "J", "CM", "E", "H", "G", "Mass", "W", "AM", "K", "Q", "ML", "I", "B", "MH", "D", "F", "MM", "m", "O", "S", "Me", "Z", "MN", "ME", "MC", "V", "A", "L", "U"], "w": ["v", "wl", "week", "tw", "way", "wal", "ws", "win", "we", "iw", "m", "wb", "Y", "aw", "l", "hw", "time", "sh", "wave", "p", "kw", "wa", "a", "word", "q", "west", "H", "s", "wt", "sw", "y", "max", "u", "b", "d", " W", "f", "x", "o", "W", "width", "g", "c", "ww", "TW", "ow", "Wh", "wh", "wd", "rw", "z", "wall", "ew", "work"], "h": ["x", " H", "j", "all", "v", "e", "min", "l", "ah", "hw", "q", "time", "uh", "rh", "H", "o", "W", "width", "g", "hh", "c", "sh", "HH", "ww", "hi", "y", "max", "ih", "gh", "hm", "wh", "hr", "m", "ph", "u", "oh", "b", "p", "d", "ch", "z", "bh", "wa", "a", "f", "th", "ht"], "X": ["x", "A", "Y", "N", "FW", "MAX", "T", "Width", "Do", "P", "TH", "J", "RH", "Work", "U", "Length", "E", "H", "XX", "MX", "CE", "Size", "Cross", "W", "XM", "K", "Right", "Time", "PE", "XXX", "IX", "TX", "TW", "DX", "Q", "WH", "y", "ML", "I", "Wh", "B", "D", "F", "XP", "WS", " x", "O", "S", "Z", "CH", "XL", "z", "MC", "XY", "PH", "Event", "ZX", "FF", "Ex", "Count", "HTTP", "WR", "Any", "ID", "L", "V"], "rows": ["x", "blocks", "members", "Row", "groups", "holes", "headers", "planes", "index", "rown", "ews", "array", "models", "OWS", "features", "fields", "keys", "ports", "orders", "posts", "files", "checks", "workers", "rooms", "classes", "ows", "users", "heads", "raw", "values", "ws", "tests", "cells", "roots", "ids", "runs", "breaks", "forms", "relations", "rs", "items", "ays", "flows", "works", "events", "results", "rules", "errors", "images", "frames", "cases", "pages", "tracks", "data", "times", "views"], "r": ["x", "j", "e", "v", "rr", "fr", "rf", "ru", "l", "ro", "br", "q", "right", "rh", "o", "cr", "g", "c", "ar", "nr", "rc", "y", "nor", "sr", "hr", "m", "u", "rs", "rw", "b", "p", "d", "z", "a", "re", "er"], "n": [" N", "x", "N", "j", "all", "v", "e", "ns", "nc", "l", "no", "q", "nb", "un", "net", "o", "on", "at", "g", "c", "s", "en", "name", "nt", "y", "nor", "ot", "num", "an", "out", "m", "nn", "u", "b", "p", "d", "z", "ne", "a", "f"], "t": ["x", "N", "j", "v", "e", "T", "l", "q", "time", "tn", "it", "o", "tt", "at", " T", "g", "c", "s", "type", "pt", "nt", "y", "ta", "ot", "out", "ty", "dt", "m", "u", "b", "p", "tp", "d", "z", "a", "ts", "f"]}}
{"code": " \n  \n  lines = [map(int, line.strip().split(\" \")) for line in open(sys.argv[1]).readlines()]\n  [count] = lines[0]\n  assert count * 10 + 1 == len(lines)\n  \n  for i in xrange(count):\n      base = i*10\n      [n1] = lines[base+1]\n      [n2] = lines[base+6]\n      row1 = set(lines[base+1+n1])\n      row2 = set(lines[base+6+n2])\n      common = row1.intersection(row2)\n      print \"Case #%s:\" % (i+1),\n      if len(common) == 1:\n          print list(common)[0]\n      elif not common:\n          print \"Volunteer cheated!\"\n      else:\n          print \"Bad magician!\"\n", "substitutes": {"lines": ["comments", "blocks", "lists", "groups", "los", "headers", "points", "vs", "l", "log", "models", "args", "limits", "sections", "files", "locks", "posts", "words", "orders", "links", "s", "ips", "ins", "ines", "verts", "users", "codes", "parts", "books", "values", "heads", "tests", "balls", "objects", "pins", "styles", "cells", "strings", "runs", "ids", "rows", "lins", "elines", "breaks", "steps", "items", "flows", "results", "ls", "rules", "names", "sheets", "les", "lights", "frames", "vals", "ones", "pages", "data", "faces", "shows"], "line": ["x", "e", "inline", "key", "string", "l", "lane", "lc", "ine", "li", "nl", "el", "header", "len", "word", "byte", "name", "val", "file", "row", "letter", "column", "source", "lf", "ln", "d", "block", "strip", "entry", "kl", "lin", "Line", "cell", "de", "lined", "LINE", "sl", "char", "page"], "count": ["id", "part", "key", "index", "code", "n", "ind", "core", "area", "col", "c", "len", "list", "sum", "depth", "name", "limit", "total", "size", "file", "max", "start", "num", "current", "found", "p", "length", "int", "check", "Count", "case", "weight", "number", "loc"], "i": ["x", "id", "j", "part", "ii", "e", "bi", "index", "ip", "l", "n", "slice", "ind", "q", "li", "it", "col", "c", "ie", "qi", "type", "gi", "limit", "position", "y", "si", "I", "start", "uri", "ci", "u", "ai", "b", "p", "pos", "ix", "pi", "int", "a", "mini", "zi", "f", "ui"], "base": ["prefix", "x", "part", "id", "parent", "root", "bi", "key", "index", "change", "n", "home", "area", "bas", "core", "server", "cache", "site", "create", "offset", "body", "basic", "family", "init", "c", "batch", "set", "len", "ie", "pe", "name", "size", "file", "letter", "unit", "y", "based", "birth", "start", "cycle", "range", "source", "build", "b", "p", "pos", "length", "year", "check", "scale", "ase", "Base", "flat", "case", "number"], "n1": ["l01", "N01", "N5", "N3", "n01", " n5", " n3", "p2", "n3", "p5", "p3", "l2", "N2", "p01", "l1", "N1", "p1", "n5"], "n2": [" n6", "Ntwo", "noe", "coe", "n6", "nTwo", "nodeoe", " ntwo", "v02", "nodeTwo", " n02", "ntwo", "v2", "node2", "vtwo", "N2", "v6", "N6", "n02", " nTwo", "c2", " noe", "cTwo", "N02"], "row1": ["raw8", " rowone", "col01", "row01", "col1", "raw1", "col3", "rowsone", " row01", "row8", "raw2", "rows01", "rows8", "rows1", "rawone", " row8", "rowone", "row3", "rows3", " row3", "col2", "rows2"], "row2": ["owtwo", "row6", "row4", "ow4", "ow5", "cell3", " rowtwo", "nodetwo", "cell2", "node2", "line2", "line3", "node4", "ow2", "line6", "cell4", "node5", "line4", " row4", "rowtwo", " row6", "row3", " row3", "cell6", " row5", "row5"], "common": ["Common", "parent", "valid", "la", "generic", "no", "specific", "local", "low", "ordered", "other", "core", "lc", "compatible", "complex", "known", "standard", "family", "basic", "public", "c", "normal", "ban", "total", "similar", "general", "custom", "unique", "con", "long", "found", "extra", "norm", "border", "recent", "broad", "diff", "new", "seen", "dist", "comment", "same", "central", "shared", "union"]}}
{"code": " \n  \n  \n  \n  INPUT = \"tiny\"\n  INPUT = \"C-small-attempt1.in\"\n  \n  def debug(*args):\n      sys.stderr.write(str(args) + \"\n\")\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args    \n  \n  IMPOSSIBLE = set([(2,2,2), (2,2,1), (2,3,1), (2,4,1), (2,5,1)])\n  \n  for i in range(2,51):\n      IMPOSSIBLE.add((2,i,1))\n      IMPOSSIBLE.add((i,2,1))\n  \n  SOLN = {\n      (1,2,1) : [\"c*\"],\n      (2,1,1) : [\"c\", \"*\"],\n      (2,2,3) : [\"c*\", \"**\"],\n  }\n  \n  def solve(R, C, M):\n      if M == 0:\n          s = [\"c%s\" % ('.' * (C-1))]\n          for i in range(R-1):\n              s.append('.' * C)\n          return s\n      t = (R, C, M)\n      if t in IMPOSSIBLE:\n          debug(\"** %s %s %s\" % t)\n          raise ValueError\n      if t in SOLN:\n          return SOLN[t]\n  \n      if C < M and R > 2:\n          try:\n              return solve(R-1, C, M-C) + [\"*\" * C]\n          except ValueError:\n              pass\n  \n      if C <= R:\n          if M >= C and R > 2:\n              return solve(R-1, C, M-C) + [\"*\" * C]\n      else:\n          if M >= R and C > 2:\n              return [\"%s*\" % s for s in solve(R, C-1, M-R)]\n      if R > 2:\n          mines = min(C, M)\n          if mines == C - 1:\n              mines -= 1\n          try:\n              return solve(R-1, C, M-mines) + [(\".\" * (C - mines)) + (\"*\" * mines)]\n          except ValueError:\n              if C > 2:\n                  mines = min(R, M)\n              if mines == R - 1:\n                  mines -= 1\n              s = [\"%s%s\" % (s, '*' if k > C-mines else '.') for k, s in enumerate(solve(R, C-1, M-mines))]\n              return s\n      debug(R, C, M)\n      return []\n  \n  def do_trial(R, C, M):\n      try:\n          r = solve(R,C,M)\n          s = \"\n\" + '\n'.join(r)\n          assert len(r) == R\n          for r1 in r:\n              assert len(r1) == C\n          assert len(''.join(k for k in s if k == '*')) == M\n          return s\n      except ValueError:\n          return \"\nImpossible\"\n  \n  \n  def all():\n      for R in range(1,50):\n          for C in range(1,50):\n              for M in range(R*C):\n                  print(R, C, M)\n                  print(do_trial(R, C, M))\n      sys.exit(0)\n  \n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      R, C, M = [int(x) for x in f.readline().split()]\n      v = do_trial(R, C, M)\n      print \"Case #%d: %s\" % (i+1, v)\n", "substitutes": {"INPUT": ["OUTPUT", "INLINE", "OUTVERT", " INVERT", "inInput", "OUTLINE", " inInput", "inPUT", " inPUT", " inLINE", "inVERT", "OUTInput", "INVERT", " INInput", "INInput", "inLINE", " INLINE", " inVERT"], "self": ["instance", "worker", "part", "layer", "parent", "e", "all", "object", "parse", "user", "patch", "other", "per", "child", "q", "args", "server", "event", "w", "api", "this", "func", "ref", "me", "g", "public", "c", "connection", "private", "master", "python", "ng", "plugin", "context", "app", "host", "manager", "point", "load", "view", "current", "proxy", "session", "call", "p", "full", "client", "resource", "now", "_", "work", "er", "form", "ctx", "plus", "case", "data", "node", "Self"], "function": ["instance", "fn", " func", "unc", "object", "string", "array", "package", "this", "func", "module", "functional", "float", "python", "name", "Function", " Function", "position", "F", "handler", "method", "library", "call", "document", "new", "resource", "full", "callback", "wrapper", "node", "closure", "number", "word", "operation", "fun"], "_cache": ["_ache", "pyCache", "logcall", "logcache", "_function", "logache", "pyconfig", " _call", "_Cache", "pyfunction", "pycache", "_object", "_config", "allfunction", "allconfig", " _object", "_call", "logobject", " _ache", "allCache", "allcache"], "_callable": ["_Calling", "_cable", "_generable", "_caller", "_callables", "_callFunction", "_createer", " _CallFunction", "_callb", "_createing", " _Callable", " _Callb", "_Caller", "_generer", "_CallFunction", " _callFunction", "_Callb", " _Callables", "_Callable", " _calling", " _Calling", " _callb", "_createable", "_cb", "_calling", " _callables", " _Caller", "_generables", "_generb", "_Callables", "_cables", "_cer", " _caller", "_createFunction"], "cache": ["instance", "parent", "root", "cat", "index", "object", "parse", "result", "default", "array", "code", "get", "model", "args", "table", "store", "match", "module", "c", "dict", "value", "storage", "conf", "lock", "config", "fake", "cookie", "can", "hash", "base", "null", "pool", "mc", "session", "call", "p", "client", "ache", "Cache", "api", "data", "wrapper", "ac", "temp", "case"], "key": ["service", "id", "parent", "root", "object", "index", "string", "query", "result", "code", "core", " Key", "ace", "keys", "copy", "path", "value", "c", "connection", "type", "date", "KEY", "section", "sum", "name", "file", "y", "size", "item", "reason", "method", "hash", "source", "base", "sign", "str", "ver", "call", "p", "Key", "entry", "int", "error", "link", "data", "temp", "page"], "cachedValue": ["cachedKey", "encodedValue", "cachedvalue", "cappedvalue", "encodedvalue", "encodedValues", "codedValue", "scappedValue", "cashedvalue", "casedValues", "scachedvalue", "cappedVal", "encachedVal", "cachedValues", "scappedKey", "codedvalue", "encachedvalue", "scachedValue", "cashedValue", "cappedKey", "scachedValues", "cashedKey", "casedvalue", "encodedVal", "cashedValues", "casedVal", "cryptedValues", "scappedvalue", "cryptedKey", "scachedKey", "codedVal", "codedValues", "casedValue", "encachedValues", "cappedValues", "cryptedValue", "scappedValues", "cryptedvalue", "cachedVal", "encachedValue", "cappedValue"], "IMPOSSIBLE": ["IMLPASSibles", "IMPUSibles", "IMPASSIBLE", "IMPASSible", "IMpESSibility", "IMPUSIBLE", "IMpOSSibility", "IMPOSSible", "IMPRECIBLE", "IMPOSSibility", "IMLPASSibility", "IMPESSibles", "IMLPASSible", "IMPossIBLE", "IMPOSSibles", "IMpESSible", "IMLPOSSible", "IMpASSibility", "IMpOSSibles", "IMPASSibilities", "IMpASSibles", "IMPESSibility", "IMPOSSibilities", "IMPossible", "IMPISSibles", "IMPISSible", "IMLPOSSIBLE", "IMPossibilities", "IMPASSibility", "IMPRECible", "IMPASSibles", "IMLPOSSibles", "IMpASSible", "IMLPASSIBLE", "IMpESSIBLE", "IMpASSIBLE", "IMPossibility", "IMPossibles", "IMLPOSSibility", "IMPUSible", "IMpOSSIBLE", "IMPRECibility", "IMPRECibles", "IMPESSible", "IMPESSIBLE", "IMPUSibility", "IMpESSibles", "IMPISSibilities", "IMPISSIBLE", "IMpOSSible"], "i": ["id", "j", "ii", "e", "bi", "ri", "index", "im", "ip", "l", "n", "phi", "ind", "xi", "iu", "li", "two", "o", "c", "ti", "ie", "h", "gi", "qi", "si", "y", "I", "ci", "u", "m", "cm", "ai", "b", "p", "d", "z", "pi", "int", "a", "io"], "SOLN": ["SOLNG", "SVOLn", "SALNs", "SALK", "SOLM", "SLn", "SOLNE", "SOLNs", " SALNT", " SOLNs", "SILn", "SolM", "SALn", "SALN", "SVOLNT", " SALn", "SILNE", "SSolNG", "SVOLNs", "SSolK", "SOVK", "SolK", "SOVn", "solM", "SOLNT", " SOLn", "SLM", "SolNG", "SSolN", "SILN", "SRLN", "soln", "sOLn", "Soln", "sOLM", "SALNG", "SILM", "SOVNG", "SSOLNG", "SRLNT", "SRLNs", " SALN", "solNE", "sOLNE", "SOVN", "SOLn", "SRLn", "SSOLN", "SSOLn", "SVOLN", " SOLNT", "SLNE", "SLN", "SolN", "SolNE", " SALNs", "sOLN", "SOLK", "SALNT", "solN", "SSoln", "SSOLK"], "R": ["Rh", "N", "Y", "Rs", "Range", "P", "RE", "MR", "CR", "RH", "Re", "JR", "E", "G", "H", "SR", "RM", "W", "RO", "K", "X", "c", "RW", "ER", "DR", "Rec", "I", "B", "Run", "RP", "AR", "D", "F", "RC", "RG", "IR", "m", "RN", "S", "RR", "V", "NR", "WR", "A", "L", "U", "RA"], "C": ["N", "Y", "NC", "SC", "CNN", "AC", "Cs", "P", "VC", "DC", "Cl", "CM", "CR", "CF", "E", "H", "Size", "CE", "G", "W", "CA", "K", "X", "c", "Sc", " c", "YC", "CV", "CO", "Q", "CC", "CS", "I", "Cu", "B", "D", "CI", "F", "Cr", "Ch", "O", "CT", "S", "CL", "EC", "MC", "V", "Mc", "Count", "CU", "Cache", "A", "L", "U"], "M": ["N", "Y", "MD", " m", "PM", "P", "MQ", "RE", "MR", "J", "CM", "U", "MT", "E", "H", "G", "MI", "RM", "W", "AM", "K", "X", "Q", "TM", "OM", "I", "B", "D", "F", "LM", "MM", "Ch", "m", "O", "S", "MA", "MN", "MC", "Mc", "IM", "A", "L", "V"], "s": ["ps", "e", "ns", "string", "cs", "ds", "array", "n", "south", "args", "w", "os", "o", "g", "its", "c", "services", "h", "ins", "params", "sites", "y", "gs", "strings", "ss", "m", "u", "rs", "S", "b", "p", "https", "d", "states", "ed", "ls", "lines", "a", "es", "ts", "ings", "als", "_", "ssl", "sl"], "t": ["all", "j", "e", "string", "st", "l", "tor", "n", "tf", "w", "it", "this", "te", "tt", "o", "g", "ut", "c", "ti", "h", "type", "tc", "y", "ta", "tmp", "tip", "out", "tim", "dt", "m", "str", "u", "tr", "the", "S", "b", "p", "d", "z", "tm", "int", "a", "ts", "tg", "temp", "test"]}}
{"code": " \n  \n  \n  INPUT = \"tiny\"\n  if 1:\n      INPUT = \"A-large.in\"\n      INPUT = \"A-small-attempt0.in\"\n  \n  def debug(*args):\n      return\n      sys.stderr.write(str(args) + \"\n\")\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args    \n  \n  def do_trial(a1, r1, a2, r2):\n      p1 = set(r1[a1-1])\n      p2 = set(r2[a2-1])\n      u = p1.intersection(p2)\n      if len(u) < 1:\n          return \"Volunteer cheated!\"\n      if len(u) > 1:\n          return \"Bad magician!\"\n      return list(u)[0]\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      rows1 = []\n      a1 = int(f.readline()[:-1])\n      for r in range(4):\n          rows1.append([int(x) for x in f.readline().split()])\n      a2 = int(f.readline()[:-1])\n      rows2 = []\n      for r in range(4):\n          rows2.append([int(x) for x in f.readline().split()])\n      v = do_trial(a1, rows1, a2, rows2)\n      print \"Case #%d: %s\" % (i+1, v)\n", "substitutes": {"INPUT": [" INCT", "inCT", "InLINE", "INLINE", "outPUT", "INinput", "inputinput", " INVERT", "ininput", "inInput", " inInput", "outFILE", "inputInput", "inPUT", " InInput", "inputPUT", "INFILE", " inPUT", "inVERT", "InVERT", "inputFILE", " InPUT", "outinput", " inULT", "InPUT", "INVERT", " InULT", "InInput", "InULT", "INCT", "inULT", " INInput", " INULT", "INInput", " InLINE", "inFILE", "INULT", "inLINE", " INLINE", "outInput", " inCT"], "self": ["instance", "layer", "parent", "part", "worker", "e", "remote", "public", "object", "ack", "user", "patch", "other", "per", "child", "q", "args", "right", "server", "w", "this", "func", "me", "g", "module", "c", "s", "connection", "private", "master", "type", "python", "h", "plugin", "context", "app", "host", "point", "manager", "load", "py", "m", "session", "call", "p", "d", "full", "client", "now", "form", "work", "er", "data", "plus", "ctx", "api", "case", "shared", "Self"], "function": ["instance", "fn", "parent", " func", "unc", "object", "array", "package", "func", "module", "functional", "c", "action", "section", "python", "name", "Function", " Function", "unit", "job", "F", "handler", "method", "library", "call", "document", "new", "full", "resource", "callback", "node", "wrapper", "closure", "number", "word", "operation", "fun"], "_cache": ["jcache", "objconfig", "objcall", "objkey", "pycall", "lexcall", "lexcode", "pycode", "objcache", "lexcache", "_key", "pyconfig", " _key", " _call", "jconfig", "pycache", "jkey", "_config", "jcall", " _code", "_call", " _config", "_code", "lexconfig"], "_callable": [" _callability", "_iterable", "_Callative", "lexgenerable", "_generable", "_loadability", "_callables", "_Callability", "_callFunction", "_loadable", " _callFunction", "_CallFunction", "_iterables", "_iterability", "_generability", "_Callable", "_iterate", "_Callate", " _callative", "lexgenerables", " _functionFunction", "_functionability", "_loadative", " _functionative", "lexcallables", "_generate", "lexgenerability", "lexcallable", "_functionable", " _functionability", "_generables", "_callability", "_callate", "_callative", "_Callables", "_functionative", "lexcallability", "_loadFunction", " _functionable", "lexgenerate", "_functionFunction", "lexcallate"], "cache": ["parent", "root", "cat", "index", "object", "parse", "query", "code", "default", "model", "args", "table", "ca", "store", "empty", "module", "c", "dict", "match", "storage", "conf", "sync", "config", "fake", "cookie", "cmp", "py", "can", "hash", "base", "pool", "session", "call", "p", "lib", "client", "ache", "cell", "Cache", "api", "data", "ac", "temp"], "key": ["service", "id", "root", "index", "string", "rule", "result", "code", "core", " Key", "keys", "path", "match", "value", "c", "by", "type", "connection", "KEY", "section", "date", "element", "sum", "name", "file", "y", "reason", "item", "size", "sync", "host", "hash", "source", "mac", "base", "str", "call", "year", "Key", "entry", "check", " entry", "error", "link", "full", "k", "case", "data", "temp", "page"], "cachedValue": ["cachedKey", "cachedvalue", "cappedvalue", "cappedValue", "capedValues", "capedKey", "encappedValue", "ucasedvalue", "cashedvalue", "casedValues", "ucachedKey", "codedvalue", "cappedVal", "encachedVal", "cachedValues", "encachedvalue", "cashedValue", "cappedKey", "casedvalue", "cashedKey", "ucasedValue", "ucasedValues", "cashedValues", "cashedVal", "encappedKey", "codedVal", "casedKey", "casedValue", "codedKey", "ucachedValues", "ucasedKey", "encappedVal", "ucachedValue", "encappedvalue", "ucachedvalue", "capedValue", "encachedKey", "cachedVal", "capedvalue", "encachedValue", "codedValue"], "a1": ["alpha3", "pone", "alphaone", "A1", " a01", "A2", "rone", "aone", "A3", " aone", "A4", "p3", "Aone", "a01", "alpha2", "p01", " a3", "a3", "a4", " a4", "alpha01", "p4", "r3", "alpha1", "r01"], "r1": ["ar2", "pone", " rb", "rone", "aone", "ar1", "ar11", "a11", "p3", "pb", " r3", "a3", "p11", "r11", "rb", "ab", "r3", "arone"], "a2": [" a72", "ar2", " aTwo", "u52", "a52", "aII", "u72", "p62", "a62", "ga62", " a62", "r4", "aTwo", "aa2", "p72", "ar1", "ar62", "aa4", "ga2", "u2", "p5", "gaTwo", "p52", " a5", "a72", " a52", " aII", "ar5", "ga4", "a4", " a4", "uII", "aa62", "p4", "pII", "aaTwo", "a5"], "r2": ["atwo", "r4", "ptwo", "ftwo", "p3", "r8", "rtwo", "f1", " r3", "f4", "a3", "a8", "a4", "p8", "p4", "r3", " r8", "f2"], "p1": ["pone", "a0", "rone", "aone", " p3", " p0", "p3", " pone", "r0", "pa1", "pa2", "a3", "pa3", "r3", "p0"], "p2": ["r02", "a02", "ttwo", "t2", "a0", "tTwo", "pTwo", "ptwo", " p0", "r0", " p02", "rtwo", "t1", "ctwo", "c1", "p0", "c2", "p02", "rTwo", "cTwo"], "u": ["tu", "mu", "us", "uc", "e", "uid", "l", "t", "ru", "home", "up", "su", "lu", "iu", "cu", "du", "un", "ou", "o", "g", "ut", "uni", "c", "bu", "eu", "ku", "h", "ul", "ups", "uu", "you", "uri", "ur", "uv", "current", "m", "b", "p", "nu", "hu", "uno", "uy", "chu", "universal", "fu", "ui", "U"], "f": ["fn", "part", "version", "e", "fr", "fast", "ff", "l", "t", "fo", "tf", "stream", "fx", "w", "fd", "feed", "folder", "bf", "g", "fe", "c", "h", "info", "conf", "inf", "fl", "file", "fw", "fen", "F", "handler", "of", "fp", "m", "lf", "frame", "b", "p", "fs", "fb", "d", "df", "xf", "z", "ch", "buff", "line", "fc", "full", "fac", "form", "io"], "T": ["N", "Y", "Total", "TN", "t", "P", "n", "time", "TS", "TI", "E", "H", "G", "W", "K", "X", "Time", "R", "NT", "Q", "I", "B", "TA", "D", "F", "WT", "O", "S", "TT", "C", "NUM", "V", "M", "A", "L", "U"], "i": ["id", "j", "ii", "e", "ri", "bi", "index", "ip", "l", "cli", "t", "n", "slice", "phi", "q", " ir", "xi", "li", "it", " c", "uni", "c", "ti", "ie", "h", "ir", "gi", "chi", "qi", "hi", "y", "si", "vi", "I", "uri", "ci", "bis", "go", "b", "p", "d", "z", "pi", "mini", "di", "k", "zi"], "rows1": ["row1", " rows4", "ows4", "row2", "blocks4", "blocks2", " rowsone", "rowsone", " rows0", "blocks3", "ows2", "owsone", "rows01", "ows3", "blocks0", "row0", "rows4", "ows01", "ows0", " rows3", "blocks1", "blocks01", "blocksone", "rows0", "rows3", " rows01", "ows1"], "r": ["rr", "err", "yr", "like", "br", "l", "t", "ner", "ro", "rd", "q", "run", "un", "o", "lr", "cr", "c", "ir", "h", "R", "ar", "nr", "rc", "range", "ur", "m", "rs", "b", "p", "d", "rg", "re", "k"], "x": ["id", "rx", "rex", "xx", "e", "index", "rax", "t", "code", "xy", "n", "l", "time", "q", "sect", "xi", "w", "xxx", "on", "X", "c", "ex", "h", "xes", "xp", "y", "xc", "xt", "p", "xf", "d", "ch", "z", "ix", "ax", "int", "ct", "wx", "xs", "sex", "_", "k", "ctx", " X", "test"], "rows2": ["row1", "ows32", " rows4", "row4", "loads4", "loads2", "ows4", "row2", "rows32", "ows102", "ows2", "rows102", "ows3", "loads3", "rows4", " rows102", "loads102", " rows3", "row32", "row3", "rows3", " rows32", "ows1"], "v": ["variable", "version", "e", "volt", "vs", "vv", "l", "t", "vd", "n", "q", "vari", "w", "ve", "g", "value", "c", "s", "h", "conv", "val", "vi", "uv", "m", "sv", "p", "d", "av", "z", "ev", "iv", "vals", "k", "va", "V"]}}
{"code": " \n  lines = iter('''\n  13\n  5 5 23\n  3 1 1\n  1 3 1\n  2 2 1\n  4 7 3\n  10 10 82\n  10 1 4\n  1 10 5\n  2 10 8\n  10 2 8\n  2 10 9\n  10 2 7\n  5 3 3\n  '''.splitlines(False)[1:])\n  out = sys.stdout\n  \n  sys.setrecursionlimit(1500)\n  \n  \n  class MyException(Exception):\n  \tpass\n  lines = iter(open(r'C-small-attempt7.in').readlines(False))\n  out = open('c-small.answer', 'w')\n  \n  def solve(C, R, M):\n  \tboard = [['.']*C for _ in range(R)]\n  \tboard[-1][-1] = 'c'\n  \ttry:\n  \t\tfor r in range(R-2):\n  \t\t\tfor c in range(C-2):\n  \t\t\t\tif r == R-3 and c == C-3:\n  \t\t\t\t\traise StopIteration()\n  \t\t\t\tboard[r][c] = '*'\n  \t\t\t\tM -= 1\n  \t\t\t\tif M == 0:\n  \t\t\t\t\treturn board \n  \texcept StopIteration:\n  \t\tpass\n  \t\t\n  \tif M % 2 == 0:\n  \t\tfor r in range(R-3):\n  \t\t\tboard[r][C-1] = '*'\n  \t\t\tboard[r][C-2] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\tfor c in range(C-3):\n  \t\t\tboard[R-1][c] = '*'\n  \t\t\tboard[R-2][c] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\t\n  \t\t\n  \t\traise MyException()\n  \telse:\n  \t\tboard[R-3][C-3] = '*'\n  \t\tM -= 1\n  \t\tif M == 0:\n  \t\t\treturn board\n  \t\tfor r in range(R-2):\n  \t\t\tboard[r][C-1] = '*'\n  \t\t\tboard[r][C-2] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\tfor c in range(C-2):\n  \t\t\tboard[R-1][c] = '*'\n  \t\t\tboard[R-2][c] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\t\n  \t\traise MyException()\n  \t\t\n  \t\n  caseCnt = int(next(lines))\n  \n  for case in range(1, caseCnt+1):\n  \tR,C,M = map(int, next(lines).split())\n  \t\n  \tprint('Case #%d:'%case, file=out)\n  \tif M == 0:\n  \t\tprint('c' + '.'*(C-1), file=out)\n  \t\tfor _ in range(R-1):\n  \t\t\tprint('.'*C, file=out)\n  \telif R*C==M+1:\n  \t\tprint('c' + '*'*(C-1), file=out)\n  \t\tfor _ in range(R-1):\n  \t\t\tprint('*'*C, file=out)\n  \telif C == 1 and R == 1:\n  \t\tprint('Impossible', file=out)\n  \telif C == 1:\n  \t\tif M > R-1:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c', file=out)\n  \t\t\tfor _ in range(R-M-1):\n  \t\t\t\tprint('.', file=out)\n  \t\t\tfor _ in range(M):\n  \t\t\t\tprint('*', file=out)\n  \telif R == 1:\n  \t\tif M > C-1:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c' + '.'*(C-M-1) + '*'*M, file=out)\n  \telif C == 2:\n  \t\tif M %2 or M//2 > R-2:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c.', file=out)\n  \t\t\tfor _ in range(R-M//2-1):\n  \t\t\t\tprint('..', file=out)\n  \t\t\tfor _ in range(M//2):\n  \t\t\t\tprint('**', file=out)\n  \telif R == 2:\n  \t\tif M %2 or M//2 > C-2:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)\n  \t\t\tprint(      '.'*(C-M//2)   + '*'*(M//2), file=out)\n  \telif M > R*C-4:\n  \t\tprint('Impossible', file=out)\n  \telse:\n  \t\ttry:\n  \t\t\tboard = solve(C, R, M)\n  \t\t\tfor line in board:\n  \t\t\t\tprint(''.join(line), file=out)\n  \t\texcept MyException:\n  \t\t\tprint('Impossible', file=out)\n  \t\n  \t\n", "substitutes": {"lines": ["comments", "blocks", "inline", "holes", "los", "headers", "ze", "l", "models", "log", "liners", "limits", "drivers", "files", "posts", "locks", "lo", "links", "rooms", "ips", "ines", "codes", "users", "books", "ses", "balls", "objects", "cells", "ances", "strings", "letters", "plugins", "lins", "rows", "elines", "runs", "breaks", "ids", "items", "sticks", "mails", "ls", "line", "rules", "boards", "errors", "lights", "lin", "frames", "Line", "pages", "bytes", "f", "scenes", "faces", "LINE", "boxes", "ipes"], "out": ["parent", "OUT", "sys", "err", "outs", "result", "code", "array", "user", "log", "output", "writer", "w", "channel", "copy", "net", "problem", "image", "o", "co", "list", "Out", "name", "ac", "file", "buffer", "again", "inner", "call", "block", "line", "client", "error", "doc", "comment", "data", "io", "dot", "bin", "word"], "C": ["N", "Y", "Cor", "T", "AC", "Chain", "Rs", "Cs", "P", "VC", "DC", "CM", "CR", "Cl", "E", "H", "G", "Size", "Channel", "W", "Col", "CA", "K", "X", "Sc", "Co", "CC", "Q", "St", "Rec", "I", "B", "From", "Cu", "D", "F", "RC", "Ch", "O", "S", "CL", "Z", "EC", "V", "Count", "WC", "Code", "A", "Country", "L", "U"], "R": ["A", "Rh", "N", "Y", "Row", "T", "Rev", "Rs", "Range", "All", "P", "Cl", "J", "CR", "RH", "Re", "Record", "U", "JR", "E", "G", "H", "SR", "RM", "W", "RO", "Right", "X", "Co", "Sc", "K", "Review", "RW", "Q", "RS", "Rec", "I", "B", "Run", "D", "F", "RC", "Cr", "Ra", "IR", "Ch", "Read", "O", "RL", "S", "Group", "RR", "Line", "Code", "L", "V"], "M": ["N", "Y", "MD", "T", " m", "PM", "FM", "P", "MQ", "MS", "All", "MO", "J", "CM", "Ms", "U", "MT", "E", "SM", "G", "MI", "H", "MX", "RM", "W", "DM", "AM", "K", "X", "NM", "MAL", "Mo", "Q", "ARM", "TM", "OM", "I", "B", "ML", "MF", "D", "F", "MB", "JM", "LM", "MM", "EM", "m", "O", "S", "MA", "Me", "MN", "ME", "Z", "Mor", "MC", "OR", "IM", "A", "L", "V"], "board": ["game", "model", "student", "stream", "feed", "problem", "square", "coll", "head", "bridge", "ode", "call", "broad", "boarding", "ide", "ba", "video", "bug", "deck", "object", "cat", "array", "rock", "core", "catch", "oard", "que", "stroke", "one", "list", "sc", "join", "road", "loop", "door", "function", "p", "block", "boy", "error", "back", "form", "rank", "point", " Board", "cart", "word", "flow", "result", "lane", " clipboard", "che", "code", "control", "table", "event", "body", "ward", "ban", "ault", "view", "lay", "void", "frame", "b", "layout", "d", "ion", "line", "client", "foot", "comment", "land", "room", "menu", "ack", "draw", "play", "home", "bo", "channel", "co", "flo", "Board", " row", "row", "sequence", " game", "hole", "builder", "boards", "entry", "player", "work", " line", "bank", "design"], "_": ["x", "all", "l", "t", "code", "rec", "h", "i", "row", "con", "p", "f"], "r": ["x", "all", "j", "mr", "v", "e", "rr", "err", "yr", "Rs", "ru", "br", "l", "n", "ro", "t", "rd", "q", "P", "right", "w", "o", "lr", "cr", "g", "ir", "h", "ar", "i", "nr", "rc", "nor", "sr", "range", "pr", "ur", "m", "rb", "u", "rs", "b", "p", "d", "ch", "RR", "rg", "a", "k", "re", "f", "er", "rn"], "c": ["v", "nc", "t", "ca", "ce", "cu", "col", "coll", "arc", "anc", "rc", "cn", "m", "cm", "chain", "k", "rn", "cat", "l", "n", "lc", "cr", "sc", "name", "cycle", "roc", "p", "fc", "ct", "a", "orc", "cor", "ac", "uc", "cs", "code", "dc", "count", "q", "rec", "y", "cf", "ci", "u", "mc", "b", "ch", "d", "cur", "cc", "f", "x", "e", "unc", "cache", "w", "channel", "o", "ec", "path", "g", "h", "i", "cd", "cont", "z", "cy", "cl", "cp"], "caseCnt": ["casecn", " caseCtor", "casecNT", " casecNT", "caseGCn", "casectx", "caseScn", "caseSctx", "caseScnt", " caseCNT", "caseGCNT", "caseCNT", "caseSctor", "caseCtor", "caseScNT", "caseGCnt", " casecnt", "caseGCtor", " caseCtx", " caseCn", " casectx", " casector", "caseCn", "casecnt", "caseCtx", " casecn", "casector"], "case": ["x", "code", "end", "character", "time", "ace", "bc", "match", "section", "max", "row", "range", "m", "block", "when", "choice", "line", "length", "Case", "ase", "cases", "loc", "number"]}}
{"code": " \n  input = open(r'C:\\MyDocument\\home\\gcj\\2014-04-12\\A-small-attempt0.in')\n  caseCnt = int(input.readline())\n  for caseNo in range(1, caseCnt+1):\n  \tans1 = int(input.readline())\n  \tfor i in range(1, 5):\n  \t\tline = input.readline()\n  \t\tif ans1 == i:\n  \t\t\tcandidates = set(map(int, line.split()))\n  \t\t\n  \tans2 = int(input.readline())\n  \tfor i in range(1, 5):\n  \t\tline = input.readline()\n  \t\tif ans2 == i:\n  \t\t\tanswers = candidates.intersection(set(map(int, line.split())))\n  \t\t\n  \tif len(answers) == 0:\n  \t\tprint('Case #%d: Volunteer cheated!'%caseNo)\n  \telif len(answers) > 1:\n  \t\tprint('Case #%d: Bad magician!'%caseNo)\n  \telif len(answers) == 1:\n  \t\tanswer = answers.pop()\n  \t\tprint('Case #%d: %d'%(caseNo, answer))\n", "substitutes": {"input": ["double", "instance", "inside", "http", "string", "accept", "parse", "Input", "output", "select", "submit", "table", "addin", "driver", "event", "stream", "enter", "url", "container", "this", "ou", "image", "loader", "batch", "keep", "request", "socket", "active", "audio", "element", "upload", "raw", "inf", "reader", "initial", "file", "agent", "buffer", "context", "qa", "again", "command", "interface", "view", "single", "source", "current", "machine", "session", "document", "process", "volume", "resource", "int", "error", "client", "form", "plus", "f", "io", "ssl", "temp", "pull"], "caseCnt": ["casecn", "casecNT", "casecnc", "caseCun", " casecNT", "caseScn", "caseCuust", "caseScnt", "caseCunt", "caseCuNT", " caseCNT", "casecust", "caseCNT", "caseScnc", " casecust", "caseScNT", "caseCust", " casecnt", " caseCn", " caseCnc", "caseCn", "casecnt", "caseCnc", " caseCust", " casecn"], "caseNo": ["CaseId", "blockN", "caseno", "patchId", "seaName", "iceNO", "patchNO", "iceN", "iceNum", "blockNo", "CaseNum", "seano", "Caseno", "blockNO", "patchNum", "caseNum", "blockNum", "conditionno", "seaNo", " caseno", "conditionNO", " caseId", "CaseNo", "CaseNO", "CaseN", "caseId", "iceNo", "seaNO", "conditionNo", "conditionNum", " caseNum", "patchNo", " caseNO", "caseName", "caseNO", " caseName", "CaseName", "caseN"], "ans1": ["ans01", "nsone", "cs2", "ns3", "lanone", "lan3", "cs01", "as2", "ams1", "an1", "ans0", "cs0", "ns1", "ansone", "as1", "ams3", "an01", "ns0", "ans3", "as0", "an2", "cs1", "as01", "amsone", "ams0", "lan1", "an0", "lan0"], "i": ["x", "id", "ui", "j", "ii", "v", "e", "bi", "multi", "im", "ip", "l", "index", "n", "ind", "xi", "yi", "iu", "li", "o", "c", "ti", "ie", "gi", "qi", "si", "y", "oi", "I", "ni", "ci", "m", "u", "ai", "b", "p", "z", "pi", "int", "a", "di", "k", "f", "io"], "line": ["layer", "look", "inline", "key", "string", "rule", "parse", "l", "lane", "log", "end", "lc", "time", "text", "side", "pin", "char", "li", "url", "channel", "el", "lo", "match", "LINE", "cle", "section", "name", "online", "shell", "sync", "letter", "file", "unit", "row", "item", "le", "range", "message", "single", "source", "lf", "non", "page", "block", "strip", "entry", "chain", "lines", "lin", "link", "comment", "Line", "cell", "data", "live", "word"], "candidates": ["continidates", "candues", "continidate", "coridate", "Candidates", "Candplates", "Candiders", "Candues", "chidate", "chues", "candidate", "callplates", "corplates", "chidates", "candplates", "candids", "continids", "coridates", "callidate", "candiders", "Candids", "calliders", "Candidate", "chids", "continues", "coriders", "callidates"], "ans2": ["ans5", "cs2", "anTwo", "aus0", "an02", "an1", "lan02", "an5", "ans0", "ANS2", "ans02", "aus1", "csTwo", "ansTwo", "lan2", "ANSTwo", "aus2", "an2", "cs1", "ANS5", "cs5", "ANS1", "lan1", "aus02", "an0", "lan0"], "answers": ["annwer", "annwers", "ansewer", "answERS", "annswERS", "answiners", "answinackers", "annewers", "answoered", "answordlers", "ansewners", "anworder", "answordackers", "ansewards", "answordered", "annewards", "answordERS", "annwners", "annwERS", "ansWERS", "answners", "answinERS", "answaitERS", "anwer", "anwackers", "ansewered", "annwered", "ansWackers", "answackers", "ansswlers", "annswers", "answiner", "anwordackers", "anwERS", "answards", "ansewERS", "answordards", "answaitners", "answaiters", "annewer", "ansswer", "answoer", "anworders", "answorder", "answoERS", "ansWer", "annwlers", "annewlers", "ansewlers", "ansswners", "answsers", "answlers", "annswer", "answsERS", "answoers", "ansWers", "answered", "anwordERS", "annewERS", "answaiter", "annswners", "anwers", "answsards", "ansewers", "answorders", "ansswers", "answser", "annwards", "ansswERS", "annewered"], "answer": ["average", "string", "result", "default", "grade", "score", "array", "address", "area", "text", "complete", "reply", "edge", " answered", "issue", "feed", "term", "match", "Answer", "name", "say", "eni", "message", "question", "answered", "response", "length", "entry", "fix", "option", "error", "comment", "next", "blank", "data", "equ", "exit", "word", "test"]}}
{"code": " \n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tyield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tcase_counter = 1\n  \t\tcase = []\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tcase.append(line.strip().split(' '))\n  \t\t\tif not line_index % n:\n  \t\t\t\tyield case_counter, case\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tcase = []\n  \n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tcase_counter = 0\n  \t\tnew_case = True\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tif new_case:\n  \t\t\t\tnew_case = False\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tcase = []\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\n  \t\t\t\tlines_left = int(line.strip())\n  \t\t\t\tif not lines_left:\n  \t\t\t\t\tnew_case = True\n  \t\t\t\t\tyield case_counter, case\n  \t\t\t\tcontinue\n  \t\t\tif lines_left:\n  \t\t\t\tlines_left -= 1\n  \t\t\t\tcase.append(line.strip().split(' '))\n  \t\t\tif not lines_left:\n  \t\t\t\tnew_case = True\n  \t\t\t\tyield case_counter, case\n  \t\t\t\n  def part_of_list_to_int(array, flags):\n  \tassert len(array) == len(flags)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif flags[index]:\n  \t\t\toutput.append(int(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_int(array):\n  \treturn part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  \tassert len(array) == len(flags)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif flags[index]:\n  \t\t\toutput.append(float(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_float(array):\n  \treturn part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  \telem_len = len(array[0])\n  \tassert index < elem_len\n  \tfor elem in array:\n  \t\tassert elem_len == len(elem)\n  \tmax_sub = array[0][index]\n  \tmax_elem = array[0]\n  \tfor elem in array:\n  \t\tif elem[index] > max_sub:\n  \t\t\tmax_sub = elem[index]\n  \t\t\tmax_elem = elem\n  \treturn max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  \tlist_len = len(a_list)\n  \tif list_len == 1:\n  \t\tif a_list[0] == value:\n  \t\t\treturn pos\n  \t\treturn -1\n  \tif a_list[list_len/2] > value:\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  \telse:\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  \t\n  def list_index_in_sorted_list(a_list, value):\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\n  \n  def copy_list(list):\n  \tres = []\n  \tfor elem in list:\n  \t\tres.append(elem)\n  \treturn res\t\n  \n  \n  def conj_mat(a):\n  \tR = len(a)\n  \tC = len(a[0])\n  \tres = [['.' for _ in xrange(R)] for __ in xrange(C)]\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t\tres[j][i] = a[i][j]\n  \treturn res\n  \n  def one_line_builder(R, C, M):\n  \tres = []\n  \tres.extend(['*'] * M)\n  \tres.extend(['.'] * (C - M))\n  \tres[-1] = 'c'\n  \treturn [res]\n  \t\n  def two_line_builder(R, C, M):\n  \tline = []\n  \tline.extend(['*'] * (M / 2))\n  \tline.extend(['.'] * (C - M / 2))\n  \tres = [line, copy_list(line)]\n  \tres[1][-1] = 'c'\n  \tif M%2 == 1:\n  \t\tres[0][-1] = '*'\n  \treturn res\n  \t\n  def three_line_builder(R, C, M):\n  \tres = [['.' for _ in xrange(C)] for __ in xrange(R)]\n  \tres[-1][-1] = 'c'\n  \tm = min([M, R * C - 9])\n  \tstop_flag = False\n  \tfor j in xrange(C):\n  \t\tif stop_flag:\n  \t\t\tbreak\n  \t\tfor i in xrange(R):\n  \t\t\tif m == 0:\n  \t\t\t\tstop_flag = True\n  \t\t\t\tbreak\n  \t\t\tres[i][j] = '*'\n  \t\t\tm -= 1\n  \tprint i,j\n  \tif i == 2:\n  \t\tres[1][j-1] = '.'\n  \t\tif j == C - 3:\n  \t\t\tres[0][j] = '*'\n  \t\telse:\n  \t\t\tres[0][-1] = '*'\n  \t\n  \tif M <= R * C - 9:\n  \t\treturn res\n  \telse:\n  \t\tm = M - (R * C - 9)\n  \t\tassert m not in [2, 4, 6, 7, 9]\n  \t\tassert m > 0\n  \t\tassert m < 10\n  \t\t\n  \t\tres[-3][-3] = '*'\n  \t\tm -= 1\n  \t\tif m == 0: return res\n  \t\tres[-2][-3] = '*'\n  \t\tres[-1][-3] = '*'\n  \t\tm -= 2\n  \t\tif m == 0: return res\n  \t\tres[-3][-2] = '*'\n  \t\tres[-3][-1] = '*'\n  \t\tm -= 2\n  \t\tif m == 0: return res\n  \t\tres[-2][-2] = '*'\n  \t\tres[-2][-1] = '*'\n  \t\tres[-1][-2] = '*'\n  \t\tm -= 3\n  \t\tif m == 0: return res\n  \t\tassert False\n  \t\n  \t\n  \t\n  def over_three_line_builder(R, C, M):\n  \tif M <= (R - 3) * C:\n  \t\tres = [['*' for _ in xrange(C)] for __ in xrange(M / C)]\n  \t\tflag = False\n  \t\tif (M % C) != (C - 1):\n  \t\t\tline = ['*' for _ in xrange(M % C)]\n  \t\t\tline.extend(['.' for _ in xrange(C - (M % C))])\n  \t\telse:\n  \t\t\tline = ['*' for _ in xrange((M % C) - 1)]\n  \t\t\tline.extend(['.' for _ in xrange((C - (M % C)) + 1)])\n  \t\t\tflag = True\n  \t\tres.append(line)\n  \t\tindex = len(res)\n  \t\tres.extend([['.' for _ in xrange(C)] for __ in xrange(R - len(res))])\n  \t\tif flag:\n  \t\t\tres[index][0] = '*'\n  \t\tres[-1][-1] = 'c'\n  \t\tassert len(res) == R\n  \t\tassert len(res[0]) == C\n  \t\treturn res\n  \telse:\n  \t\tres = [['*' for _ in xrange(C)] for __ in xrange(R - 3)]\n  \t\tM -= (R - 3) * C\n  \t\ttmp = three_line_builder(3, C, M)\n  \t\tif len(tmp) != 3: # error msg\n  \t\t\treturn tmp\n  \t\tres.extend(tmp)\n  \t\treturn res\n  \t\n  def solve(R, C, M):\n  \tres = None\n  \t\n  \tif M == R * C:\n  \t\treturn 'Impossible'\n  \tif R >= 3 and C >= 3:\n  \t\tif R*C - M in [7, 5, 3, 2]:\n  \t\t\treturn 'Impossible'\n  \t\treturn over_three_line_builder(R, C, M)\n  \t\t\n  \telif R != 1 and C != 1:  #which means one of them is 2, and the other not 1\n  \t\tif (R*C - M) % 2 == 1:\n  \t\t\tif M < R*C - 1:\n  \t\t\t\treturn 'Impossible'\n  \t\tif M + 2 == R * C:\n  \t\t\treturn 'Impossible'\n  \t\telse:\n  \t\t\tif R == 2:\n  \t\t\t\treturn two_line_builder(R, C, M)\n  \t\t\telse:\n  \t\t\t\ttmp = two_line_builder(C, R, M)\n  \t\t\t\treturn conj_mat(tmp)\n  \t\n  \telse:\t\t\t\t\t#which means one of them is 1\n  \t\tif R == 1:\n  \t\t\treturn one_line_builder(R, C, M)\n  \t\telse:\n  \t\t\ttmp = one_line_builder(C, R, M)\n  \t\t\treturn conj_mat(tmp)\n  \t\t\n  \treturn res\n  \n  def mat_to_str(a):\n  \tif a in ['Impossible', 'Not Implemented']:\n  \t\treturn a\n  \tstr_out = ''\n  \tfor row in a:\n  \t\tfor elem in row:\n  \t\t\tstr_out += elem\n  \t\tstr_out += '\n'\n  \treturn str_out[:-1]\n  \t\n  def calc_result(case):\n  \tresult = None\n  \t\n  \tR = int(case[0])\n  \tC = int(case[1])\n  \tM = int(case[2])\n  \tprint R, C, M\n  \t\n  \tresult = solve(R, C, M)\n  \t\n  \tstr_out = mat_to_str(result)\n  \tm = str_out.count('*')\n  \tassert (m==0 or m==M)\n  \tprint str_out\n  \t\n  \treturn '\n%s' % str_out\n  \n  def main(filepath):\n  \tstart_time = time.time()\n  \twith file('output.txt', 'wb') as f_out:\n  \t\t\n  \t\tfor case_index, case in iterate_cases_1lpc(filepath):\n  \t\t\t\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\n  \t\t\tresult = calc_result(case)\n  \t\t\t\n  \t\t\tf_out.write(\"Case #%d: %s\n\" % (case_index, result))\n  \t\t\t\t\n  if __name__ == '__main__':\n  \tmain(sys.argv[1])\n", "substitutes": {"filepath": ["fpointer", "workname", "FilePath", "fname", "linepath", "Filepath", "ilePath", " filetext", "filetext", " filename", "fflow", "linecache", "filename", "basepath", " fileflow", "baseath", "fpath", "linesize", " filesystem", " fileath", "fileflow", "lineflow", "ftext", "basename", " filesize", "fPath", "workpath", "ilesystem", "Filetext", "linesystem", " filePath", "filecache", "fileath", "ilepath", "linePath", " filepointer", "fsize", "workath", "filesize", " filecache", "filepointer", "filesystem", "fcache", "Filename", "linepointer", "filePath"], "line_index": ["line___type", "line6index", "line67letter", "line_no", "line___inc", "word_prefix", "line___index", "line2index", "lin__pos", "line_ind", "line__length", "case_number", "word6index", "lineIdprefix", "frame_key", "case_size", "line_size", "case_condition", "letter_sum", "lineIdconnection", "frame_size", "lin_pos", "line2size", "line6connection", "line_connection", "link67length", "layer_sum", "lin__in", "word_ind", "word_connection", "layer_type", "line__pos", "line_in", "line67address", "layer_inc", "lin__index", "line_length", "lineIdindex", "link67letter", "line_key", "word6prefix", "line_type", "line_pos", "line_counter", "line_condition", "link67address", "line2type", "line__in", "line_point", "case_type", "line2length", "letter_no", "line2number", "link_letter", "line2condition", "line_prefix", "word6ind", "lin_in", "frame_index", "word_index", "line6ind", "line_sum", "line67index", "frame_counter", "link67index", "line6prefix", "line_number", "link_length", "link_index", "letter_index", "line__index", "case_length", "line_letter", "lin_length", "lin__length", "lineIdind", "line67length", "letter_point", "link_address", "word6connection", "line___sum", "line_address", "layer_index", "line_inc", "lin_index"], "line": ["inline", "key", "object", "string", "rule", "user", "code", "lane", "parse", "log", "slice", "character", "time", "ine", "day", "side", "text", "char", "edge", "label", "office", "header", "lo", "LINE", "connection", "cle", "section", "name", "loop", "shell", "sync", "file", "letter", "position", "unit", "phase", "item", "buffer", "lock", "le", "profile", "style", "column", "message", "load", "long", "source", "frame", "non", "page", "block", "entry", "note", "lines", "error", "chain", "lin", "link", "comment", "Line", "cell", "force", "data", "de", "lined", "word"], "n": [" N", "x", "N", "e", "ns", "nc", "l", "t", "count", "dn", "nb", "r", "nl", "net", "sn", "c", "en", "nr", "nt", "size", "y", "num", "nn", "u", "ln", "b", "p", "nu", "span", "ne", "nw", "f", "number", "node", "rn", "network"], "case_counter": [" case_manager", "section__consumer", "case_Counter", "case_number", "section_consumer", "line_finder", "section_counter", "line_count", "section_number", "case_leader", "case64count", "base_counter", "case__counter", "case__count", "base_book", "case_book", "section__count", "case24counter", "case_manager", "section__number", "case24offset", "ability_leader", "case64chain", "case_keeper", "line_counter", "case_current", "ability_counter", "case24number", "cases_count", " case_count", "case__number", "case24finder", "case_sum", " case_keeper", "case_count", "case64current", "section_count", "case64counter", "line_number", "base_instance", "case_finder", "base_manager", "case_instance", "line_offset", "case24chain", "ability_Counter", "cases_counter", "cases_chain", "case24current", "case_offset", "case24count", "ability_sum", "section__counter", "case_consumer", "case_chain", "cases_current", "case__consumer"], "case": ["ignore", "character", "ce", "match", "size", "position", "current", "call", "length", "true", " CASE", "chain", "force", "cases", "now", "example", "pair", "instance", "bug", "rule", "change", "time", "core", "catch", "once", "one", "mode", "connection", "self", "name", "loop", "use", "config", "block", "ride", "new", "error", "Case", "condition", "word", "fold", "code", "count", "address", "create", "shape", "space", "type", "section", "max", "choice", "client", "part", "key", "patch", "default", "end", "trial", "ace", "cache", "then", "path", "me", "c", "make", "switch", "sequence", "ance", "ase", "page", "test"], "new_case": ["new_cases", " new_division", "new_part", "newfcases", " new_sea", "new_Case", "new_division", "newfchange", " new_Case", "new67sea", " new_part", "newfCase", "new67Case", " new_section", "newfcase", " new_cases", "new67case", "new67section", "new_ce", "New_case", "new_change", "New_ce", " new_change", "new_section", "New_Case", "new_sea"], "lines_left": ["lines_end", "lines_leave", "lines_right", "line_right", "cases_less", "lines_top", "lines___left", "liners___left", "cases_right", "lines_joined", "cases_Left", "liners_left", "lines_center", "line_end", "liners___leave", "lines___top", "cases_top", "lines_where", "lines6null", "line_left", "cases_joined", "liners___center", "liners_leave", "cases_left", "cells_loaded", "liners_center", "lines6right", "lines6Left", "cells_Left", "liners_top", "lines6end", "cells_where", "lines___leave", "liners___top", "lines_null", "lines6left", "cases_null", "lines6top", "lines_Left", "lines_less", "lines_loaded", "lines___center", "cells_left"], "array": ["instance", "original", "all", "component", "feature", "remote", "external", "ray", "object", "multi", "string", "address", "complex", "site", "package", "any", "this", "sample", "image", "group", "allow", "collection", "coll", "section", "audio", "element", "initial", "file", "Array", "application", "app", "range", "input", "analysis", "view", "sword", "base", "expression", "function", "the", "queue", "air", "arrow", "auto", "true", "force", "archive", "enum", "arr", "now", "form", "api", "example", "data", "database"], "flags": ["ols", "utils", "lists", "groups", "planes", "Flags", "alls", "local", "options", "args", "mask", "features", "fields", "forces", "ports", "settings", "image", "files", "leans", "ils", "links", "ants", "versions", "services", "itives", "opens", "parts", "rings", "values", "lag", "fl", "fires", "file", "styles", "ints", "strings", "long", "allows", "ats", "windows", "items", "fs", "orts", "types", "details", "states", "weights", "rules", "feat", "reports", "lines", "frames", "vals", "arr", "bits", "fits", "FLAG", "dates"], "output": ["model", "complete", "target", "image", "match", "en", "pattern", "position", "unit", "letter", "console", "current", "display", "example", "send", "double", "generated", "hidden", "format", "binary", "config", "num", "out", "expression", "function", "process", "block", "response", "new", " Output", "flat", "export", "number", "operation", "all", "external", "append", "other", "count", "Output", "public", "s", "type", "protected", "input", "style", "method", "long", "write", "version", "summary", "string", "end", "sort", "four", "put", "status", "width", "batch", "after", "struct", "memory", "document", "lib", "int", "main", "exit", "page"], "index": ["x", "parent", "version", "id", "open", "key", "draw", "level", "default", "Index", "slice", "address", "model", "run", "ind", "success", "office", "image", "xxx", "offset", "thread", "action", "update", "active", "pattern", "pointer", "name", "alpha", "initial", "sync", "position", "letter", "find", "config", "unit", "fail", "num", "lead", "point", "fill", "column", "expression", "search", "block", "argument", "condition", "val", "example", "weight", "loc", "node", "page"], "elem": ["eelement", " elee", "elelements", " ehem", "elee", "gelements", "gelev", "gelee", "sele", "elelement", "gele", "celee", "elelev", "selee", "gelem", "celement", " element", "gelement", " elev", " ele", "eelements", "sehem", "elev", "celem", "eehem", "elelem", "geject", "element", "ele", "eelee", "elements", "eelev", "selev", "eelem", "eele", "selem", "cele", "ehem", " elements", "eeject", " eject", "selement", "eject"]}}
{"code": " \n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tyield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tcase_counter = 1\n  \t\tcase = []\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tcase.append(line.strip().split(' '))\n  \t\t\tif not line_index % n:\n  \t\t\t\tyield case_counter, case\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tcase = []\n  \n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tcase_counter = 0\n  \t\tnew_case = True\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tif new_case:\n  \t\t\t\tnew_case = False\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tcase = []\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\n  \t\t\t\tlines_left = int(line.strip())\n  \t\t\t\tif not lines_left:\n  \t\t\t\t\tnew_case = True\n  \t\t\t\t\tyield case_counter, case\n  \t\t\t\tcontinue\n  \t\t\tif lines_left:\n  \t\t\t\tlines_left -= 1\n  \t\t\t\tcase.append(line.strip().split(' '))\n  \t\t\tif not lines_left:\n  \t\t\t\tnew_case = True\n  \t\t\t\tyield case_counter, case\n  \t\t\t\n  def part_of_list_to_int(array, flags):\n  \tassert len(array) == len(flags)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif flags[index]:\n  \t\t\toutput.append(int(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_int(array):\n  \treturn part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  \tassert len(array) == len(flags)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif flags[index]:\n  \t\t\toutput.append(float(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_float(array):\n  \treturn part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  \telem_len = len(array[0])\n  \tassert index < elem_len\n  \tfor elem in array:\n  \t\tassert elem_len == len(elem)\n  \tmax_sub = array[0][index]\n  \tmax_elem = array[0]\n  \tfor elem in array:\n  \t\tif elem[index] > max_sub:\n  \t\t\tmax_sub = elem[index]\n  \t\t\tmax_elem = elem\n  \treturn max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  \tlist_len = len(a_list)\n  \tif list_len == 1:\n  \t\tif a_list[0] == value:\n  \t\t\treturn pos\n  \t\treturn -1\n  \tif a_list[list_len/2] > value:\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  \telse:\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  \t\n  def list_index_in_sorted_list(a_list, value):\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\n  \n  def copy_list(list):\n  \tres = []\n  \tfor elem in list:\n  \t\tres.append(elem)\n  \treturn res\t\n  \n  \n  def intersect(arr_A, arr_B):\n  \tprint '\\t\\t%s\n\\t\\t%s' % (arr_A, arr_B)\n  \tres = []\n  \tfor a in arr_A:\n  \t\tif arr_B.count(a):\n  \t\t\tres.append(a)\n  \tprint '\\t\\t%s' % res\n  \treturn res\n  \n  def solve(row_A_selected, board_A,\n  \t\t  row_B_selected, board_B):\n  \tres = intersect(board_A[row_A_selected - 1], \n  \t\t\t\t\tboard_B[row_B_selected - 1])\n  \tif len(res) == 0:\n  \t\treturn 'Volunteer cheated!'\n  \tif len(res) == 1:\n  \t\treturn res[0]\n  \treturn 'Bad magician!'\n  \t\n  def calc_result(case):\n  \tresult = None\n  \t\n  \trow_A_selected = int(case[0][0])\n  \trow_B_selected = int(case[5][0])\n  \tboard_A = case[1:5]\n  \tboard_B = case[6:10]\n  \t\n  \tprint \"row_A_selected: %s\" % row_A_selected\n  \tprint \"row_B_selected: %s\" % row_B_selected\n  \tprint \n  \tprint board_A\n  \tprint \n  \tprint board_B\n  \tprint\n  \t\n  \tresult = solve(row_A_selected, board_A,\n  \t\t\t\t   row_B_selected, board_B)\n  \tprint result\n  \t\n  \t\n  \treturn result\n  \n  def main(filepath):\n  \tstart_time = time.time()\n  \twith file('output.txt', 'wb') as f_out:\n  \t\t\n  \t\tfor case_index, case in iterate_cases_nlpc(filepath, 10):\n  \t\t\t\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\n  \t\t\tresult = calc_result(case)\n  \t\t\t\n  \t\t\tf_out.write(\"Case #%d: %s\n\" % (case_index, result))\n  \t\t\t\t\n  if __name__ == '__main__':\n  \tmain(sys.argv[1])\n", "substitutes": {"filepath": ["fpointer", "workname", "FilePath", "fname", "linepath", "Filepath", "ilePath", " filetext", "filetext", " filename", "fflow", "linecache", "filename", "basepath", " fileflow", "baseath", "fpath", "linesize", " filesystem", " fileath", "fileflow", "lineflow", "ftext", "basename", " filesize", "fPath", "workpath", "ilesystem", "Filetext", "linesystem", " filePath", "filecache", "fileath", "ilepath", "linePath", " filepointer", "fsize", "workath", "filesize", " filecache", "filepointer", "filesystem", "fcache", "Filename", "linepointer", "filePath"], "line_index": ["line___type", "line6index", "line67letter", "line_no", "line___inc", "word_prefix", "line___index", "line2index", "lin__pos", "line_ind", "line__length", "case_number", "word6index", "lineIdprefix", "frame_key", "case_size", "line_size", "case_condition", "letter_sum", "lineIdconnection", "frame_size", "lin_pos", "line2size", "line6connection", "line_connection", "link67length", "layer_sum", "lin__in", "word_ind", "word_connection", "layer_type", "line__pos", "line_in", "line67address", "layer_inc", "lin__index", "line_length", "lineIdindex", "link67letter", "line_key", "word6prefix", "line_type", "line_pos", "line_counter", "line_condition", "link67address", "line2type", "line__in", "line_point", "case_type", "line2length", "letter_no", "line2number", "link_letter", "line2condition", "line_prefix", "word6ind", "lin_in", "frame_index", "word_index", "line6ind", "line_sum", "line67index", "frame_counter", "link67index", "line6prefix", "line_number", "link_length", "link_index", "letter_index", "line__index", "case_length", "line_letter", "lin_length", "lin__length", "lineIdind", "line67length", "letter_point", "link_address", "word6connection", "line___sum", "line_address", "layer_index", "line_inc", "lin_index"], "line": ["inline", "key", "object", "string", "rule", "user", "code", "lane", "parse", "log", "slice", "character", "time", "ine", "day", "side", "text", "char", "edge", "label", "office", "header", "lo", "LINE", "connection", "cle", "section", "name", "loop", "shell", "sync", "file", "letter", "position", "unit", "phase", "item", "buffer", "lock", "le", "profile", "style", "column", "message", "load", "long", "source", "frame", "non", "page", "block", "row", "entry", "note", "lines", "error", "chain", "lin", "link", "comment", "Line", "cell", "force", "data", "de", "lined", "word"], "n": [" N", "x", "N", "j", "e", "ns", "nc", "l", "t", "count", "dn", "nb", "r", "nl", "net", "sn", "c", "i", "en", "nr", "nt", "size", "y", "num", "m", "nn", "u", "ln", "b", "p", "nu", "span", "ne", "nw", "f", "number", "node", "rn", "network"], "case_counter": [" case_manager", "section__consumer", "case_Counter", "case_number", "section_consumer", "line_finder", "section_counter", "line_count", "section_number", "case_leader", "case64count", "base_counter", "case__counter", "case__count", "base_book", "case_book", "section__count", "case24counter", "case_manager", "section__number", "case24offset", "ability_leader", "case64chain", "case_keeper", "line_counter", "case_current", "ability_counter", "case24number", "cases_count", " case_count", "case__number", "case24finder", "case_sum", " case_keeper", "case_count", "case64current", "section_count", "case64counter", "line_number", "base_instance", "case_finder", "base_manager", "case_instance", "line_offset", "case24chain", "ability_Counter", "cases_counter", "cases_chain", "case24current", "case_offset", "case24count", "ability_sum", "section__counter", "case_consumer", "case_chain", "cases_current", "case__consumer"], "case": ["ignore", "character", "ce", "match", "size", "position", "current", "call", "length", "true", " CASE", "chain", "force", "cases", "now", "example", "pair", "instance", "bug", "rule", "change", "time", "core", "catch", "once", "one", "mode", "connection", "self", "name", "loop", "use", "config", "block", "ride", "new", "error", "Case", "condition", "word", "fold", "code", "count", "address", "create", "shape", "space", "type", "section", "max", "choice", "client", "part", "key", "patch", "default", "end", "trial", "ace", "cache", "then", "path", "me", "c", "make", "switch", "sequence", "ance", "ase", "page", "test"], "new_case": ["new_cases", " new_division", "new_part", "newfcases", " new_sea", "new_Case", "new_division", "newfchange", " new_Case", "new67sea", " new_part", "newfCase", "new67Case", " new_section", "newfcase", " new_cases", "new67case", "new67section", "new_ce", "New_case", "new_change", "New_ce", " new_change", "new_section", "New_Case", "new_sea"], "lines_left": ["lines_end", "lines_leave", "lines_right", "line_right", "cases_less", "lines_top", "lines___left", "liners___left", "cases_right", "lines_joined", "cases_Left", "liners_left", "lines_center", "line_end", "liners___leave", "lines___top", "cases_top", "lines_where", "lines6null", "line_left", "cases_joined", "liners___center", "liners_leave", "cases_left", "cells_loaded", "liners_center", "lines6right", "lines6Left", "cells_Left", "liners_top", "lines6end", "cells_where", "lines___leave", "liners___top", "lines_null", "lines6left", "cases_null", "lines6top", "lines_Left", "lines_less", "lines_loaded", "lines___center", "cells_left"], "array": ["instance", "original", "all", "component", "feature", "remote", "external", "ray", "object", "multi", "string", "address", "complex", "site", "package", "any", "this", "sample", "image", "group", "allow", "collection", "coll", "section", "audio", "element", "initial", "file", "Array", "application", "app", "range", "input", "analysis", "view", "sword", "base", "expression", "function", "the", "queue", "air", "arrow", "auto", "true", "force", "archive", "enum", "arr", "now", "form", "api", "example", "data", "database"], "flags": ["ols", "utils", "lists", "groups", "planes", "Flags", "alls", "local", "options", "args", "mask", "features", "fields", "forces", "ports", "settings", "image", "files", "leans", "ils", "links", "ants", "versions", "services", "itives", "opens", "parts", "rings", "values", "lag", "fl", "fires", "file", "styles", "ints", "strings", "long", "allows", "ats", "windows", "flag", "items", "fs", "orts", "types", "details", "states", "weights", "rules", "feat", "reports", "lines", "frames", "vals", "arr", "bits", "fits", "FLAG", "dates"], "output": ["model", "complete", "target", "image", "match", "en", "pattern", "position", "unit", "letter", "console", "current", "display", "example", "send", "double", "generated", "hidden", "format", "binary", "config", "num", "out", "expression", "function", "process", "block", "response", "new", " Output", "flat", "_", "export", "number", "operation", "all", "external", "append", "other", "count", "Output", "public", "s", "type", "protected", "input", "style", "method", "long", "write", "version", "summary", "string", "end", "sort", "four", "put", "status", "width", "batch", "after", "struct", "memory", "document", "lib", "int", "main", "exit", "page"], "index": ["x", "parent", "j", "version", "id", "open", "key", "draw", "level", "default", "Index", "slice", "address", "model", "run", "ind", "success", "office", "image", "xxx", "offset", "thread", "action", "update", "i", "active", "pattern", "pointer", "name", "alpha", "initial", "sync", "position", "letter", "find", "row", "config", "unit", "fail", "num", "lead", "point", "fill", "column", "expression", "search", "block", "argument", "condition", "val", "example", "weight", "loc", "node", "page"], "elem": ["eelement", " elee", "elelements", " ehem", "elee", "gelements", "gelev", "gelee", "sele", "elelement", "gele", "celee", "elelev", "selee", "gelem", "celement", " element", "gelement", " elev", " ele", "eelements", "sehem", "elev", "celem", "eehem", "elelem", "geject", "element", "ele", "eelee", "elements", "eelev", "selev", "eelem", "eele", "selem", "cele", "ehem", " elements", "eeject", " eject", "selement", "eject"]}}
{"code": " \n  def Fill(outmat,R,C,F):\n      nF=F\n      outmat[:2,:2]='.'\n      nF-=4\n      if nF==0: return\n  \n      outmat[2,:2]='.'\n      nF-=2\n      if nF==0: return    \n  \n      outmat[:2,2]='.'\n      nF-=2\n      if nF==0: return\n  \n      for iC in xrange(3,C):\n          if nF==1:\n              outmat[2,2]='.'\n              return\n          outmat[:2,iC]='.'\n          nF-=2\n          if nF==0: return\n          \n      for iR in xrange(3,R):\n          if nF==1:\n              outmat[2,2]='.'\n              return\n          outmat[iR,:2]='.'\n          nF-=2\n          if nF==0: return\n  \n      for iR,iC in ( (iR,iC) for iR in xrange(2,R)\n                     for iC in xrange(2,C)):\n          outmat[iR,iC]='.'\n          nF-=1\n          if nF==0: return\n      \n  \n  \n  \n  def Solve(R,C,M):\n      F=R*C-M\n      if F==0: return '\nImpossible'\n      if (R>1 and C>1 and F in (2,3)):\n          return '\nImpossible'\n  \n      outmat=np.zeros( (R,C), dtype='S1')\n      outmat[:,:]='*'\n  \n      if R==1:\n          for i in xrange(F):\n              outmat[0][i]='.'\n      \n      elif C==1:\n          for i in xrange(F):\n              outmat[i][0]='.'\n  \n      elif F>1:\n          if F in (2,3,5,7): return \"\nImpossible\"\n          elif (R==2 or C==2) and F%2 != 0:\n              return \"\nImpossible\"\n          elif R==2:\n              outmat[:,:F/2]='.'\n          elif C==2:\n              outmat[:F/2,:]='.'\n          else: Fill(outmat,R,C,F)\n          \n      outmat[0,0]='c'\n      outmatlines=[ ''.join(x) for x in outmat ]\n      answer='\n'+'\n'.join(outmatlines)\n  \n      Verify(answer,F)\n  \n      return answer\n  \n  disp=[ (dx,dy) for dx in (-1,0,1)\n      for dy in (1,0,-1) if (dx !=0 or dy!=0) ]\n  \n  def Verify(answer,F):\n      lines=[list(x) for x in answer.split('\n')]\n      if len(lines[0])==0: lines.pop(0)\n      R,C=len(lines),len(lines[0])\n      assert lines[0][0]=='c'\n      assert answer.count('.')+1==F\n      q=Queue.Queue()\n      q.put( (0,0) )\n  \n      def adjToMine(x,y):\n          for dx,dy in disp:\n              if 0<=x+dx<R and 0<=y+dy<C:\n                  if lines[x+dx][y+dy]=='*': return True\n          return False\n                  \n  \n      while not q.empty():\n          x,y=q.get()\n          for dx,dy in disp:\n              if 0<=x+dx<R and 0<=y+dy<C:\n                  if lines[x+dx][y+dy]=='c': continue\n                  lines[x+dx][y+dy]='c'\n                  if not adjToMine(x+dx,y+dy):\n                      q.put( (x+dx,y+dy) )\n  \n      clicked='\n'.join([ ''.join(x) for x in lines])\n      if clicked.find('.')>=0:\n          print '\n','*'*20,\"\nERROR, input:\"\n          print answer\n          print 'OUTPUT:'\n          print clicked\n      \n  \n  \n  \n  def parse(infile):\n      R,C,M=map(int, infile.readline().split() )\n      return R,C,M\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n  \n      outname=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(outname):\n          oldout=outname+'.old'\n          ii=0\n          while os.path.isfile(oldout):\n              ii+=1\n              oldout=outname+'.old'+str(ii)\n          os.rename(outname,oldout)\n          print 'Rename: %s -> %s'%(outname,oldout)   \n   \n      outfile=open(outname,'w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n", "substitutes": {"outmat": ["againformat", "OutMat", "Outlat", "OUTMat", "upmatch", "inflat", "inmat", "offmatch", "OUTmath", " outMat", "outputmot", "againcat", "Outmult", "upmol", " outformat", "outputcat", "informat", "outputmatch", " outmol", "offcat", " outmult", "inmath", "atcat", "OUTflat", "againmult", "atmat", " outmot", "outlat", "outmot", "Outmol", "resultMat", "outputmol", "againmol", "Outformat", "againmatch", "outmol", "outcat", "OUTformat", "resultmol", " outcat", "inMat", "againmath", "outmatch", "outputmat", "outflat", "atmol", "Outmot", "OUTmult", "Outmath", "atmath", "OUTmol", "outputlat", "againmot", " outmatch", "resultmat", "againflat", "outputformat", " outlat", "againlat", "outmath", "incat", "upformat", "Outcat", "againMat", "outformat", "againmat", "outmult", "inmult", "OUTmot", "resultmult", "outMat", "Outmat", "outputMat", " outmath", "offmat", "OUTmat", "inmol", "offmol", "OUTlat", "upmat"], "R": ["UR", "Rh", "TR", "N", "Y", "HR", "T", "GR", "Rs", "Range", "P", "RE", "MR", "CR", "RH", "Re", "r", "U", "JR", "E", " r", "G", "H", "SR", "RM", "W", "Rank", "RO", "RF", "K", "X", "Right", "RW", "BR", "Q", "DR", "RS", "Rec", "Br", "I", "B", "Run", "RP", "AR", "D", "Ro", "RG", "RC", "Ra", "IR", "O", "RN", "RL", "S", "RR", "OR", "NR", "KR", "WR", "A", "L", "V", "RA"], "C": ["N", "Y", "NC", "SC", "Cor", "T", "CNN", "AC", "Cs", "P", "VC", "DC", "CM", "Cl", "CR", "FC", "Or", "U", "E", "CE", "G", "H", "W", "CA", "K", "X", "c", "Sc", "Three", "YC", " c", "JC", "CV", "CC", "CW", "Cu", "B", "I", "KC", "CS", "CI", "D", "Cr", "Ca", "Ch", "GC", "O", "CT", "S", "CL", "EC", "V", "CU", "A", "L", "Con"], "F": ["Fun", "N", "Y", "Fine", "FD", "FO", "T", "OF", "FH", "P", "TF", "J", "FC", "CR", "CF", "FG", "U", "WF", "Fs", "E", "Fi", "H", "FE", "G", "W", "K", "X", "Fit", "File", "GF", "Q", "I", "B", "DF", "cf", "Fl", "D", "O", "Fe", "S", "Z", "Fixed", "FR", "EF", "EC", "FB", "new", "IF", "FF", "FL", "AF", "ELF", "PF", "If", "f", "IO", "Family", "A", "L", "V", "Far", "FA"], "nF": ["NL", "nFamily", "lnQ", "lnF", " nG", "NOF", " nEF", "nanQ", "pE", "NELF", "lnf", " nD", "nOF", "lnE", "neD", "neG", "pnF", "unH", "fnf", "ynD", "lF", "fnE", " nFile", "neF", "cnE", "ND", "dnFamily", "nV", "NFile", " nV", " nU", "iFile", " nOF", "fnC", "connF", "cnM", " nW", "lG", "dnF", "lC", "noneV", "fnU", "fnV", "nL", "ynF", "lD", "wW", "unQ", "ynL", "nwF", "nELF", "noneFamily", "NFamily", "wL", "nwL", "neU", "fnF", "nE", "lnH", "wf", "dnD", "unFamily", "nD", "NC", "neC", " nH", "lnFamily", " nL", " nM", "NF", "cnf", "unD", " nC", " nf", "iF", "unC", "nFile", "nM", "nf", "NM", "nEF", "nG", "nU", "nanE", " nFamily", "nanFamily", "nH", "Nf", "pF", "nanC", "fnD", "nwf", "unF", "iE", "nanF", "connFile", "dnC", "nW", "unFile", " nQ", "ynELF", "NV", " nE", "connE", "lnEF", "lFamily", "cnF", "noneF", "pnELF", "nC", "nQ", "wF", "NE", "pf", "connf", "pEF", "nwW", "pnD", "nanOF", "pnL", "noneE"], "iC": ["biR", "aF", "siR", "niN", "niM", "iiN", "iM", "iCNN", "iCs", "siL", "jR", "iuM", " iF", " iT", "aC", "iU", "aR", "liF", "iiM", "iF", "iiR", "niL", "biM", "iDC", "eniDC", "iiF", " iN", "niR", " iCNN", "eniCNN", "aSc", "iN", "iuSc", "iT", "aU", "eniF", "siM", " iDC", " iCs", "iuC", "aM", "siCs", "iL", "iSc", "niCs", "biT", "liC", "siF", "jC", "niC", "liDC", " iL", "jT", "iiC", "eniC", "iiU", "iuR", "biC", "siC", "liCNN", " iSc", "siU", "jM", " iM"], "iR": ["biR", "siR", "cAr", "iiRs", "biRs", "iM", "jR", "aiR", " iRs", "jRh", "ciM", " iB", "aiAr", "cR", "iAr", "ciN", "iRs", "ciRs", "siN", "iiR", "biM", "uRs", "cC", "siRh", "aiC", "ciR", " iG", " iN", "iB", "iRh", "ciC", "uM", "siRs", "iN", " iAr", "siM", "jRs", "uC", "jC", "uR", "ciAr", "iiC", "siAr", "iiG", "pR", "iG", "cB", "siG", " iRh", "pRs", "biC", "siC", "aiB", "pM", "pC", " iM"], "M": ["N", "Y", "T", "P", "MS", "MR", "J", "CM", "E", "G", "MI", "H", "RM", "W", "K", "X", "c", "Q", "I", "B", "MF", "D", "MM", "m", "Z", "MN", "MC", "V", "OR", "A", "L", "U"], "i": ["id", "j", "v", "e", "multi", "im", "l", "t", "index", "n", "mi", "phi", "xi", "r", "li", "iu", "it", "c", "ti", "ie", "qi", "ar", "si", "I", "ni", "ci", "ini", "m", "u", "ic", "ai", "b", "p", "d", "z", "pi", "int", "a", "f", "io"], "outmatlines": ["Outmatlines", "outMatline", "out_lines", "out_line", "Outmatlin", "Outmatline", "OutMatline", "OutMatlines", "outcatline", "outcatlin", "OutMatlin", "outMatlin", "outMatlines", "outmatlin", "outmatline", "outcatlines", "out_lin"]}}
{"code": " \n  \n  def Solve(F1,r1,F2,r2):\n      s1=set(F1[r1-1])\n      s2=set(F2[r2-1])\n      sx=s1.intersection(s2)\n      if len(sx)>1:\n          return \"Bad magician!\"\n      elif len(sx)==0:\n          return \"Volunteer cheated!\"\n      else:\n          return sx.__iter__().next()\n  \n  \n  \n  def parse(infile):\n      r1=int(infile.readline().strip())\n      F1=[]\n      for i in xrange(4):\n          F1.append( map(int, infile.readline().split() ))\n      r2=int(infile.readline().strip())\n      F2=[]\n      for i in xrange(4):\n          F2.append( map(int, infile.readline().split() ))\n      return F1,r1,F2,r2\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n  \n      outname=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(outname):\n          oldout=outname+'.old'\n          ii=0\n          while os.path.isfile(oldout):\n              ii+=1\n              oldout=outname+'.old'+str(ii)\n          os.rename(outname,oldout)\n          print 'Rename: %s -> %s'%(outname,oldout)   \n   \n      outfile=open(outname,'w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n", "substitutes": {"F1": ["fn", "Rone", "R81", "Fs91", "Fone", "M1", "M3", "f81", "R6", "F6", "F3", "F81", " F91", "R3", " F6", "FOne", " F3", "PF3", "F91", " Fone", " FOne", "ROne", "Fsn", "Fs1", " Fn", "f1", "PF2", "fone", "PF1", "M2", "M81", "f6", "f3", "R2", "fOne", "R1", "Fs2", "Fn", "f91", "f2"], "r1": ["nr0", "rx", "Rone", "nr2", "cOne", "sr3", "rhx", "rone", "sr1", "R3", " rone", "nrone", "rh3", "rh1", "ROne", "r0", "rOne", " r01", "R01", "rh2", "f1", " r3", " rOne", "c1", "Rx", "c01", "r3", "f3", " r0", "R2", "fOne", "srx", "nr1", "sr2", "R1", "R0", "c2", "f2", "r01"], "F2": ["R4", "FSecond", "F4", "F22", "F3", "F8", "f8", "R3", "FO2", "f22", "R22", "RSecond", "F0", " F3", "FO3", "R02", " F8", " F22", "FOSecond", "f0", " F02", "F02", "f1", "f4", "fII", "R8", " F0", " FSecond", "f3", "f02", "R2", " FII", "R1", " F4", "f2", "FII", "R0", "FO4", "RII"], "r2": ["R4", "r02", "RTwo", "F4", " r4", " R4", "F8", "r4", "R02", "rgTwo", "rg02", "rg2", "r8", " r56", " R56", " R2", "f1", "R8", "R56", "fTwo", " R1", "rg1", "f02", "R2", "R1", "r56", " r8", "rTwo", "f2"], "s1": ["S1", "s81", "ssx", "f81", "ss3", "s10", "S2", "ss2", "ss1", "f1", " s10", "Sx", "s3", "S3", "f10", " s3", " s81", "f2"], "s2": ["S1", "STwo", "sTwo", "s0", "S2", "S62", " s52", "f52", "f0", "f1", "r62", " s62", " sTwo", " s0", "s62", "S0", "S52", "rTwo", "s52", "f2"], "sx": ["S1", "esxs", "sesX", "sX", "sxy", "ssx", "ssX", "sespx", "esx", "Sxs", "ssxy", "es1", "sxx", "Sxx", "sxs", "sesxs", "esX", "Spx", "Sx", " sxy", " sX", "sz", "Sz", "ssxs", "sesx", "spx", "esxx", "esxy", "SX", " sxs", "esz"], "infile": ["inihandle", "Infile", "inline", "Inline", " inline", "Infilename", "outline", "Infolder", " inFile", " inf", "Instream", "binf", "outfolder", " infilename", "insline", "inifile", "outFile", "infilename", "ininame", "outstream", "inname", " inhandle", "insfolder", "outfilename", "inf", "incfolder", "incFile", "insfile", "inifilename", " inname", "outf", "incline", "outhandle", " infolder", "inhandle", "iniFile", "inFile", "inistream", "instream", "binfile", "binline", " instream", "InFile", "incfile", "insfilename", "binFile", "infolder"], "i": ["x", "id", "j", "v", "ip", "l", "n", "ind", "li", "r", "iu", "it", "o", "g", "c", "ti", "h", "I", "ci", "iq", "u", "ai", "b", "p", "z", "pi", "int", "a", "f", "io"], "self": ["parent", "http", "sys", "spec", "ref", "private", "request", "master", "ws", "tmp", "app", "m", "call", "now", "k", "case", "resp", "instance", "ps", "ns", "object", "l", "n", "time", "r", "os", "reader", "proc", "parser", "config", "function", "session", "p", "full", "error", "_", "plus", "ctx", "Self", "parse", "user", "result", "other", "q", "event", "func", "public", "s", "type", "python", "context", "host", "cmp", "view", "method", "b", "pos", "client", "data", "f", "worker", "x", "part", "e", "default", "home", "cache", "w", "this", "co", "me", "g", "c", "h", "exc", "selves", "results", "es", "wx", "cl", "work", "node", "temp"], "fname": ["flatname", "fileno", "Fpath", "filename", "inno", "fpath", "flatno", "inname", "flatName", "fno", "Ffile", "flatfile", "outpath", "fileName", "fName", "filepath", "outName", "FName", "filefile", "Fname", "inName", "ffile"], "NumCases": ["numAcase", "NumCodes", "numCodes", "NumScaces", "numAcodes", "NumPodes", "NumberScaces", "NumAcodes", "NumPases", "NumberScalls", "numCams", "NumCase", "numAcams", "NumCams", "NumAcase", "Numcases", "NumFams", "Numcaces", "numCases", "NumCaces", "NumAcases", "NumFodes", "NumberCalls", "NumAcams", "NumberCases", "NumberScases", "numAcases", "NumPase", "NumberScase", "NumScases", "Numcase", "NumberCase", "NumPams", "NumScalls", "Numcalls", "NumPalls", "numCase", "NumFases", "NumCalls", "NumFase", "NumScase", "NumPaces", "NumberCaces"], "caseNum": [" caseNo", " caseNumber", "trialnum", "testNumber", "caseNo", "CaseNum", "testnum", "aseNum", "caseNumber", "trialNum", " casenum", "CaseVal", "CaseNo", "Casenum", "testNum", "aseNumber", "casenum", "caseVal", "asenum", " caseVal", "trialNumber", "CaseNumber", "testNo", "trialNo", "aseVal"], "args": ["ams", "x", "plays", "all", "cs", "Args", "parse", "aw", "other", "ras", "ds", "Arg", "limits", "gen", "fields", "ay", "w", "spec", "ages", "gu", "ae", "body", "aux", "flags", "words", "g", "init", "arg", "dict", "s", "conn", "ar", "params", "parts", "parser", "gs", "ass", "atts", "py", "stats", "long", " arg", "extra", "items", "call", "works", "pos", "ix", "ig", "ax", "lines", " arguments", "obj", "doc", "argument", "a", "arr", "now", "GS", "_", "data", "loc", "inc"], "myCases": ["myCsased", "myCase", "MyAcases", "MyAcakes", "MyCases", "myCsase", "myCased", "myChase", "MyCase", "MyCaser", "MyAcaser", "myChases", "myCaser", "MyCased", "myChased", "myCsakes", "MyAcased", "myChakes", "myAcases", "myCsaser", "myAcase", "myAcakes", "myCsases", "myAcased", "myChaser", "MyAcase", "myAcaser", "myCakes", "MyCakes"], "outname": ["insize", "outputname", " outsize", "outputsize", "inline", "Outnamed", "offname", "outputName", "outline", "OUTbase", "Outname", "offName", "OutName", "inbase", "Outline", "infilename", "Outpath", "OUTnamed", "inname", "OUTName", " outpath", " outName", "Outfilename", "offpath", "outfilename", "inpath", "Outfile", "outpath", "outnamed", "outbase", "Outbase", " outline", "offline", "OUTname", "outName", "OUTfile", "outputfile", " outfilename", "innamed", "inName", "outsize"], "oldout": ["OLDouts", " oldin", "OLDin", "OLDOut", "OLDname", "oldOUT", "oldOut", "oldin", "newOut", " oldagain", "oldnet", "OldOut", "olderin", "oldname", "Oldout", "newout", "Oldnet", " oldnet", "Oldin", "oldouts", "oldernet", "newin", " oldname", "OLDOUT", "OldOUT", "Oldname", " oldOut", "newagain", "Oldouts", "oldagain", "Oldagain", "olderout", " oldOUT", "newouts", "OLDout"], "ii": ["lli", "bi", "index", "ind", "ei", "imi", "ali", "lu", "agi", "li", "II", "iana", "uni", "abi", "ice", "ti", "qi", "gi", "sci", "iii", "inf", " iii", "ili", "hi", "si", "img", "vi", "uu", "eni", "ori", "ni", "ci", "fi", "ini", "iat", "iss", "ai", "iso", "ani", "pi", "mini", "di", "zi", "flat", "ui"], "outfile": ["exline", "outFile", "exfile", "Outfile", "exFile", " outFile", "outline", "exname", " outline", "Outname", "Outline", "OutFile"], "iCase": [" icase", "ICase", "aSection", "icase", "iSection", " iSection", "acase", "aCase", "ISection", "Icase"], "answer": [" Answer", "result", "Result", "array", "output", "cache", "su", "reply", "ell", " answers", "match", "Answer", " result", "size", "search", "call", "answered", "results", "response", "entry", "arr", "now", "example", "respond", "data", "number", "resp"]}}
{"code": "f = open('input.in')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in xrange(T) :\n      R, C, M = map(int, f.readline()[:-1].split())\n      FREE = R*C - M\n      if FREE == 0 : res = '\nImpossible'\n      elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\nImpossible'\n      elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\nImpossible'\n      else :\n          MAP = [['.' for c in range(C)] for r in range(R)]\n          MAP[0][0] = 'c'\n          if R == 1 :\n              for i in range(C-1, C-M-1, -1) : MAP[0][i] = '*'\n          elif C == 1 :\n              for i in range(R-1, R-M-1, -1) : MAP[i][0] = '*'\n          elif R == 2 :\n              for i in range(C-1, C-M/2-1, -1) : MAP[0][i], MAP[1][i] = '*', '*'\n              if FREE == 1 : MAP[1][0] = '*'\n          elif C == 2 :\n              for i in range(R-1, R-M/2-1, -1) : MAP[i][0], MAP[i][1] = '*', '*'\n              if FREE == 1 : MAP[0][1] = '*'\n          else :\n              com = M / C\n              for i in range(R-1, max(R-com-1, 2), -1) :\n                  MAP[i] = ['*' for j in range(C)]\n                  M -= C\n              I = max([i for i, j in enumerate(MAP) if j[0] == '.'])\n              if I == 2 :\n                  com = M / 3\n                  if com == 0 : i = C\n                  for i in range(C-1, C-com-1, -1) :\n                      MAP[0][i], MAP[1][i], MAP[2][i] = '*', '*', '*'\n                      M -= 3\n                  if M >= 1 : MAP[2][i-1] = '*'\n                  if M >= 2 :\n                      if i != 1 : MAP[2][i-2] = '*'\n                      else : MAP[1][0] = '*'\n              else :\n                  for i in range(C-1, C-M-1, -1) : MAP[I][i] = '*'\n                  if i == 1 :\n                      MAP[I][i] = '.'\n                      MAP[I-1][C-1] = '*'\n          res = '\n' + '\n'.join([''.join(i) for i in MAP])\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\n      g.write(output + '\n')\n      print output\n  \n  f.close()\n  g.close()\n", "substitutes": {"f": ["x", "v", "e", "fr", "ff", "rf", "uf", "l", "t", "n", "tf", "w", "fd", "feed", "o", "s", "h", "info", "file", "input", "F", "fp", "m", "u", "lf", "b", "fs", "p", "fb", "d", "df", "z", "fc", "form", "io", "sf"], "g": ["gg", "gui", "gc", "log", "ga", "q", "mem", "gen", "gd", "w", "G", "wm", "group", "cfg", "gi", "h", "gm", "ng", "gl", "gs", "gz", "gp", "m", "go", "sg", "z", "gb", "k"], "T": ["N", "Y", "TN", "TEXT", "t", "P", "TH", "TF", "DT", "TS", "E", "G", "H", "W", "X", "TC", "TX", "NT", "Q", "TM", "SIZE", "TA", "D", "F", "CT", "S", "TT", "Z", "GT", "UT", "TB", "L", "V"], "case": ["x", "TR", "SC", "sec", "time", "trial", "ace", "bc", "E", "ice", "X", "ti", "TC", "toc", "seq", "CO", "size", "cycle", "row", "TA", "cm", "O", "REC", "EC", "cor", " X", "times", "U", "test"], "R": ["UR", "Rh", "Y", "N", "GR", "Rs", "Range", "YR", "P", "Rem", "RE", "VC", "MR", "Cl", "CR", "RH", "Re", "RT", "JR", "E", "G", "H", "SR", "RM", "W", "COR", "RO", "K", "X", "Co", "RW", "ER", "CO", "Q", "DR", "RS", "Rec", "B", "RP", "AR", "D", "F", "RC", "RG", "IR", "Ra", "Ch", "O", "RN", "S", "CL", "Group", "RR", "NER", "V", "NR", "RED", "WR", "A", "L", "U", "RA"], "C": ["P", "Cl", "CR", "FC", "E", "G", "CE", "SR", "YC", "CO", "Cu", "Ch", "O", "EC", "MC", "CU", "A", "ANC", "L", "Y", "SC", "AC", "J", "COR", "X", "Co", "Sc", "Core", "CC", "CS", "D", "CI", "Ca", "V", "NC", "Cs", "VC", "CAR", "H", "ERC", "B", "WC", "RFC", "N", "CNN", "DC", "CM", "U", "W", "CAN", "CA", "K", "JC", "CV", "Q", "CW", "F", "RC", "GC", "CP", "CT", "CON", "S", "CL", "Cache", "CN", "Code", "Con"], "M": ["Y", "N", "MD", "FM", "P", "MS", "MR", "MO", "J", "CM", "VM", "U", "MT", "E", "G", "MX", "H", "MI", "RM", "W", "DM", "AM", "K", "X", "MU", "Mo", "Q", "OM", "B", "MF", "AR", "D", "F", "LM", "MM", "Mon", "m", "O", "MA", "S", "Z", "MN", "CL", "MC", "IM", "COM", "A", "L", "V", "RA"], "FREE": ["NOR", "DE", "ERE", "MAX", "EN", "GR", "Free", "VALUE", "ORE", "RE", "ONE", "ICE", "ZE", "TYPE", "USER", "Re", "ARE", "ENT", "NEW", "MORE", "FE", "EW", "FIELD", "COR", "RO", "ROM", "CLE", "GE", "ALE", "RES", "BER", "WARNING", "MEN", "MW", "OVER", "ERROR", " FRE", "REM", "CO", "MER", "ER", "SIZE", "USE", "WE", "F", "NO", "YOU", "free", "CRE", "MODE", "MON", "CON", "REC", "NE", "FR", "CONT", "NUM", "FILE", "NER", "DER", "REE", "NR", "NULL", "CLOSE", "NAME", "UM", "LE", "HOW", "WR", "UN", "WARN", "RA"], "res": ["css", "GR", "err", "result", "ras", "our", "MS", "RE", "resh", "gr", "pres", "cache", "release", "match", "RES", "rez", "correct", "reed", "ress", "rap", "msg", "reason", "reg", "clear", "rus", "VAL", "req", "resolution", "REG", "reset", "REC", "details", "results", "response", "resource", "Res", "arr", "re", "lear", "resp", " RES"], "MAP": ["TR", "RESULTS", "MAX", "LOAD", "JSON", "MS", "MR", "MO", "APP", "TYPE", "PER", "ARE", "CAP", "PATH", "SM", "LIST", "RM", "MAS", "MAT", "RO", "DO", "PUT", "RES", "DATA", "MP", "MEN", "OP", "ACC", "KEY", "MW", "GET", "ACE", "CO", "CC", "ML", "SIZE", "MAC", "MH", "USE", "WE", "SO", "Maps", "LM", "CT", "MODE", "REG", "CON", "MA", "CL", "MN", "AP", "FILE", "NUM", "MC", "map", "SET", "LOC", "NULL", "NAME", "Map", "COM", "GROUP", "RAW", "UN", "maps"], "c": ["x", "e", "l", "n", "lc", "w", "o", "ec", "h", "cn", "cf", "m", "cm", "u", "b", "p", "d", "z", "ct", "cc", "k", "cp", "cl"], "r": ["v", "e", "rr", "err", "yr", "rf", "ro", "rec", "co", "cr", "ir", "ar", "rc", "range", "ur", "m", "cm", "u", "b", "p", "rg", "re", "rn"], "i": ["id", "v", "bi", "ri", "cli", "ti", "gi", "chi", "iw", "ni", "m", "k", "mu", "im", "l", "n", "ei", "comp", "li", "ish", "ie", "CI", "fi", "il", "ai", "p", "a", "ij", "di", "zi", "ui", "ii", "index", "multi", "ip", "mi", "phi", "ind", "q", "xi", "yi", "iu", "it", "s", "qi", "y", "uri", "ci", "ini", "u", "ib", "b", "d", "pi", "ji", "x", "e", "II", "o", "h", "si", "ic", "z", "int", "mini", "io", "ia"], "com": ["dom", "x", "all", " COM", "min", "uc", " Com", "im", "Com", "log", "cal", "mem", "CM", "up", "comp", "cum", "lim", "imp", "comb", "COR", "co", "X", "ex", "comm", "TC", "om", "conf", "REM", "CO", "mod", "CC", "tc", "OM", "num", "WE", "CI", "con", "cm", "Component", "sim", "CL", "ME", "CONT", "ab", "SIM", "tm", "rem", "communication", "IM", "cl", "lam", "CU", "al", "COM", "loc", "company", "common"], "j": ["ji", "v", "im", "l", "dj", "n", "t", "q", "J", "jj", "jit", "json", "li", "it", "o", "js", " it", " jo", " Dj", "oj", "jp", "jl", "si", "item", " J", "num", "IJ", "ci", "adj", "jo", "m", "b", "p", "aj", "z", "bj", "obj", "ja", "ij", "k", "_"], "I": ["N", "Y", "PI", "P", "VC", "J", "SI", "KI", "II", "MI", "NI", "W", "DI", "Is", "X", "IT", "IA", "Q", "B", "CI", "IJ", "F", "ci", "VI", "LI", "IC", "BI", "AI", "Z", "V", "UI", "L", "GI", "U"]}}
{"code": "f = open('input.in')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in xrange(T) :\n      a1 = int(f.readline()[:-1])\n      M1 = [map(int, f.readline()[:-1].split()) for i in range(4)]\n      a2 = int(f.readline()[:-1])\n      M2 = [map(int, f.readline()[:-1].split()) for i in range(4)]\n      r1 = M1[a1-1]\n      r2 = M2[a2-1]\n      res = set(r1).intersection(set(r2))\n      if len(res) == 1 : res = res.pop()\n      elif len(res) == 0 : res = 'Volunteer cheated!'\n      else : res = 'Bad magician!'\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\n      g.write(output + '\n')\n      print output\n  \n  f.close()\n  g.close()\n", "substitutes": {"f": ["flow", "e", "v", "fr", "ff", "uf", "rf", "l", "t", "n", "fo", "tf", "fa", "af", "r", "w", "fd", "feed", "folder", "bf", "c", "fe", "s", "h", "info", "conf", "inf", "file", "fen", "fw", "input", "F", "handler", "fp", "m", "lf", "frame", "b", "p", "fs", "fb", "d", "df", "fc", "full", "a", "form", "plus", "sf", "fu"], "g": ["x", "game", "j", "gui", "gc", "v", "e", "l", "t", "gen", "r", "w", "G", "o", "group", "bg", "cfg", "c", "ge", "h", "gi", "s", "gm", "msg", "file", "gs", "out", "gz", "m", "u", "og", "go", "b", "p", "d", "vg", "sg", "ig", "gb", "rg", "io"], "T": ["N", "Y", "TN", "t", "P", "TH", "time", "TS", "Length", "E", "H", "G", "W", "K", "X", "Time", "R", "NT", "Q", "I", "B", "D", "F", "WT", "O", "S", "TT", "Z", "C", "V", "M", "A", "L", "U"], "case": ["step", "x", "instance", "id", "nce", "bug", "patch", "code", "end", "slice", "time", "trial", "ace", "rice", "catch", "ce", "CE", "ASE", "me", "match", "X", "c", "date", "ice", "section", "name", "phase", "num", "race", "USE", "CI", "C", "choice", "line", "length", " CASE", "a", "Case", "ase", "cases", "loc", "number", "test"], "a1": [" a81", "areaone", "A1", "area81", "A2", "rone", "A81", "aone", " aone", "ga2", "ga1", "area2", "Aone", "a01", "a81", "gaone", "area1", "A01", "ga01", "r01"], "M1": ["Mone", "Rone", "m2", "A1", "M0", "MOne", "A2", " M10", "F2", "F0", "ROne", "Aone", "AOne", "F1", "R10", "m1", "M10", "mone", "mOne", "R2", "R1", " M0", "R0", "F10"], "i": ["x", "id", "ui", "j", "ii", "e", "v", "ip", "l", "n", "ind", "xi", "iu", "r", "li", "it", "o", "ti", "si", "I", "ci", "il", "ai", "b", "p", "pi", "int", "di", "k", "io"], "a2": [" atwo", "r02", "aatwo", " aTwo", "atwo", "aa22", "a02", "ma02", "aa2", "aa02", "aTwo", "itwo", "i2", "iTwo", "a22", "ma22", "ma2", "rtwo", " a22", "i02", "matwo", " a02", "rTwo"], "M2": ["R4", " M4", "m2", "A1", "M4", "M0", "A2", "R02", "M02", "A02", "A0", "m1", "m0", "m02", "R2", "m4", "R1", "R0"], "r1": ["Rone", "m2", "rone", "R3", " rone", "ROne", "rOne", "m3", " r3", " rOne", "m1", "mone", "mOne", "r3", "R2", "R1"], "r2": ["R4", "r02", "a02", "m2", "RTwo", "r4", "R02", "cr1", "r0", "cr2", "m1", "m0", "m02", "a4", "crTwo", "mTwo", "R2", "m4", "R1", "rTwo", "cr0", "R0"], "res": ["ps", "remote", "rx", "part", "rr", "err", "rss", "Rs", "key", "result", "ras", "Result", "our", "rises", "RE", "success", "gr", "core", "right", "pres", "r", "os", "des", "rh", "sol", "rates", "RES", "rez", "rm", "R", "coll", "sum", "rel", "rev", "ress", "resources", "rap", "msg", "reason", "ret", "reg", "RS", "rest", "range", "rus", "req", "str", "rs", "resolution", "ver", "reset", "details", "results", "response", "rep", "Results", "resource", "rem", "Res", "obj", "error", "rect", "vals", "arr", "re", "content", "loc", "resp", "ris"], "output": ["version", "open", "summary", "cut", "st", "result", "report", "log", "n", "information", "final", "Output", "four", "complete", "core", "text", "Input", "r", "print", "format", "w", "region", "description", "fore", "section", "en", "outer", "letter", "unit", "file", "img", "pretty", "out", "input", "message", "console", "struct", "method", "current", "expression", "str", "O", "write", "document", "debug", "plot", "CONT", "display", "response", "resource", "full", "plain", " Output", "content", "example", "respond", "dot", "op", "io"]}}
{"code": " \n  \n  '''\n  ...\n  ...\n  ...\n  ...\n  ...\n  '''\n  \n  for i in range(int(input())):\n  \n      r, c, m = tuple(map(int, str.split(input())))\n      count = r * c - m\n      field = dict(map(lambda c: (c, \"*\"), itertools.product(range(c), range(r))))\n      answer = \"Impossible\"\n  \n      if m == 0:\n  \n          answer = field\n  \n      elif 1 in (r, c):\n  \n          for p in itertools.islice(itertools.product(range(c), range(r)), count):\n  \n              field[p] = \".\"\n  \n          answer = field\n  \n      elif count in (0, 2, 3, 5, 7):\n  \n          pass\n  \n      elif count == 1:\n  \n          answer = field\n  \n      elif count // 2 < c or count == c * 2 + 1:\n  \n          if count % 2 != 0:\n  \n              tail = 3\n              ncount = count - 3\n  \n          else:\n  \n              tail = 0\n              ncount = count\n  \n          for x in range(ncount // 2):\n  \n              field[(x, 0)] = field[(x, 1)] = \".\"\n  \n          for x in range(tail):\n  \n              field[(x, 2)] = \".\"\n  \n          answer = field\n  \n      elif not (c == 2 and count % c == 1):\n  \n          for x in range(c):\n  \n              field[(x, 0)] = field[(x, 1)] = \".\"\n  \n          count -= 2 * c\n          tail = 0\n          if count % c == 1:\n  \n              tail = 2\n              count -= 1\n  \n          y = 2\n          while count > 0:\n  \n              rx = min(count, c)\n              for x in range(rx):\n  \n                  field[(x, y)] = \".\"\n  \n              count -= rx\n              y += 1\n  \n          for x in range(tail):\n  \n              field[(x, y)] = \".\"\n  \n          answer = field\n  \n      field[(0, 0)] = \"c\"\n      print(str.format(\"Case #{}:\", i + 1))\n      if isinstance(answer, dict):\n  \n          for y in range(r):\n  \n              print(str.join(\"\", map(lambda x: field[(x, y)], range(c))))\n  \n      else:\n  \n          print(answer)\n", "substitutes": {"i": ["id", "j", "ii", "v", "e", "index", "im", "ip", "mi", "multi", "n", "slice", "phi", "ind", "xi", "li", "iu", "ice", "ti", "si", "I", "eni", "uri", "ci", "ini", "iq", "u", "ai", "z", "ix", "pi", "int", "mini", "di", "f", "ui"], "r": ["v", "e", "rr", "rf", "ru", "l", "t", "n", "ro", "q", "right", "w", "rh", "o", "g", "cr", "s", "ir", "R", "ar", "h", "nr", "rc", "sr", "range", "pr", "ur", "u", "rb", "rs", "b", "d", "radius", "cur", "a", "k", "re", "rar", "f", "er", "rn"], "c": ["v", "e", "nc", "pc", "unc", "uc", "cs", "l", "code", "t", "n", "dc", "lc", "q", "ce", "cache", "w", "cu", "col", "o", "rec", "ec", "co", "cr", "g", "s", "h", "sc", "coll", "arc", "rc", "size", "cn", "max", "cycle", "cf", "ci", "xc", "con", "u", "cm", "mc", "vc", "b", "C", "d", "ch", "z", "fc", "a", "ct", "cc", "cy", "k", "f", "ac"], "m": ["j", "mr", "v", "e", "l", "mi", "n", "q", "more", "mm", "o", "co", "g", "h", "mult", "dim", "size", "num", "range", "cm", "u", "mc", "b", "d", "C", "pm", "z", "pi", "length", "f", "number", "M"], "count": ["id", "parent", "v", "nc", "log", "cond", "const", "col", "match", "len", "coll", "counter", "depth", "limit", "size", "range", "current", "cm", "flag", "call", "C", "length", "force", "age", "content", "case", "weight", "l", "n", "lc", "time", "core", "catch", "offset", "allow", "cr", "value", "list", "conf", "name", "scroll", "cycle", "zip", "num", "con", "found", "process", "error", "number", "ac", "all", "index", "code", "carry", "q", "ind", "more", "order", "type", "max", "cf", "race", "ount", "mc", "b", "ch", "d", "cc", "comment", "Count", "f", "level", "min", "e", "key", "default", "child", "score", "cache", "w", "h", "sum", "base", "null", "z", "loc"], "field": ["id", "model", "fields", "only", "FIELD", "term", "match", "size", "Field", "range", "source", "question", "C", "force", "wire", "cell", "layer", "service", "attribute", "object", "rule", "upp", "array", "url", "format", "value", "list", "info", "ground", "plugin", "message", "custom", "function", "block", "diff", "fix", "check", "condition", "form", "_", "number", "word", "all", "index", "query", "user", "result", "q", "table", "output", "man", "order", "folder", "group", "type", "update", "element", "cover", "input", "the", "d", "box", "line", "comment", "data", "f", "seed", "equ", "record", "variable", "e", "key", "string", "patch", "default", "child", "play", "end", "cache", "post", "label", "file", "row", "pp", "manager", "dd", "document", "lib", "entry", "option", "player", "page", "test"], "answer": ["average", "parent", "err", "area", "reply", "image", "term", " answers", "description", "audio", "size", "eni", "arel", "swers", "energy", "source", "question", "ee", "example", "video", "attribute", "array", "edge", "value", "name", "say", "margin", "message", "expression", "fee", "response", "fix", "error", "archive", "metadata", "form", "number", "query", "result", "address", "output", "ell", "issue", "order", " answering", "update", "offer", "cover", "fake", "fill", "knowledge", "answered", "comment", "equ", " Answer", "string", "grade", "score", " explanation", "entity", "ace", "side", "cache", " answered", "replace", "correct", "after", "Answer", "install", "evidence", "memory", "document", "practice", "option", "player"], "p": ["j", "e", "pc", "v", "like", "ip", "np", "code", "P", "n", "t", "patch", "get", "q", "l", "post", "w", "col", "o", "param", "g", "h", "pe", "ach", "python", "proc", "pp", "lp", "py", "fp", "u", "ph", "pn", "b", "pm", "d", "pos", "z", "pi", "int", "a", "cp", "f", "pre"], "tail": ["all", "ail", "wrap", "index", "patch", "code", "l", "child", "n", "end", "local", "lc", "ind", "slice", "t", "act", "run", "cache", "li", "target", "stop", "col", "offset", "body", "thread", "width", "term", "collection", "sn", "batch", "tick", "type", "len", "coll", "sum", "head", "limit", "size", "position", "unit", "sync", "tc", "margin", "zip", "cycle", "start", "lead", "row", "left", "tails", "test", "call", "span", "length", "line", "chain", "support", "condition", "weight", "loc", "number", "lex", "pull", "tag"], "ncount": ["dcount", "llimit", "nlength", "Ncount", "dcoll", "dtail", "llength", "ntail", "ncoll", " nlimit", "lsize", "lcall", "nsize", "nntail", "ccount", "Nlimit", "zcount", "zcall", "Nsize", "nncount", " nsize", "nlimit", "nnlength", "zlength", "lcount", "dlength", "nncoll", "ncall", "ccall", "lcoll", "clength", "ltail"], "x": ["id", "v", "t", "col", "ux", "xc", "yx", "search", "ax", "sex", "xs", "k", "j", "l", "no", "xy", "n", "time", "xxxx", "xxx", "one", "X", "ice", "self", "ex", "xp", "name", "xa", "num", "my", "xt", "xf", "ix", "full", "check", "ct", "plus", "index", "px", "code", "q", "xi", "any", "el", "on", "s", "pe", "view", "u", "b", "d", "cross", "f", "xe", "xx", "e", "key", "tx", "w", "o", "co", "g", "h", "xes", "ww", "row", "php", "ic", "z", "int", "es", "wx", "work", "lex", "exp"], "y": ["Y", "ym", "j", "e", "sy", "v", "key", "id", "yr", "yt", "ys", "t", "code", "n", "l", "ny", "q", "get", "iny", "vy", "xy", "yd", "ay", "yi", "w", "col", "o", "yy", "h", "type", "yn", "ya", "python", "ty", "yl", "py", "ry", "u", "zy", "b", "d", "z", "ey", "year", "ye", "dy", "a", "cy", "isy", "oy", "f"], "rx": ["xxxxxxxx", "min", "rr", "nc", "rss", "index", "rf", "ri", "n", "tx", "lc", "rd", "core", "act", "push", "rt", "rh", "col", "rec", "lr", "width", "co", "cr", "abc", "ex", "R", "coll", "nr", "limit", "rc", "sync", "cycle", "size", "circ", "rl", "ry", "rb", "rs", "rw", "ra", "cross", "radius", "fc", "mx", "wx", "loc", "lex", "pull"]}}
{"code": "def read_case():\n  \n      answer = int(input())\n      lines = tuple(map(lambda _: set(str.split(input())), range(4)))\n      return lines[answer - 1]\n  \n  \n  for i in range(int(input())):\n  \n      intersection = read_case() & read_case()\n      count = len(intersection)\n      if count == 1:\n  \n          answer = intersection.pop()\n  \n      elif count > 1:\n  \n          answer = \"Bad magician!\"\n  \n      elif count < 1:\n  \n          answer = \"Volunteer cheated!\"\n  \n      print(str.format(\"Case #{}: {}\", i + 1, answer))\n", "substitutes": {"answer": ["average", "err", "area", "episode", "reply", "field", "amount", " answers", "description", "len", "audio", "size", "eni", "energy", "question", "span", "ee", "length", "now", "age", "blank", "example", "respond", "cash", "array", "username", "n", "edge", "format", "offset", "see", "name", "say", "message", "ix", "response", "fix", "support", "archive", "next", "number", "word", "index", "result", "code", "address", "output", "ell", "issue", "order", "section", "offer", "duration", "cover", "answered", "line", "une", "comment", "x", "e", "string", "grade", "score", "ace", "text", "empty", "after", "Answer", "nr", "evidence", "year", "int", "account", "page", "test"], "lines": ["notes", "comments", "blocks", "groups", "points", "models", "changes", " Lines", "reads", "cycles", "sections", "files", "posts", "words", "ips", "ines", "codes", "parts", "values", "objects", "cells", "strings", "letters", "ids", "rows", "breaks", "elines", "runs", "items", "states", "results", "rules", "line", "errors", "cases", "pages", "faces"], "i": ["instance", "x", "id", "j", "ii", "e", "index", "ip", " j", "n", "end", "ind", "li", "r", "field", "it", "c", "ti", "h", "ie", "info", "item", "I", "start", "eni", " I", "uri", "ci", "iq", "u", "ib", "ai", "p", "ix", "int", "k", "f"], "intersection": ["intection", "Interection", "presection", "intsect", "intsections", " intersector", "presect", " intersect", "presections", "intsector", "Intersector", "intersect", "intsection", "Intersections", "intersections", "presector", "Interdivision", "interection", " interdivision", "intersector", "INTERsections", "INTERsect", "intdivision", "INTERsector", " interection", "INTERsection", "interdivision", "Intersection", "Intersect", " intersections"], "count": ["missing", "part", "parent", "all", "id", "index", "code", "array", "child", "low", "ind", "area", "more", "catch", "handle", "cache", "group", "match", "div", "c", "empty", "type", "len", "list", "coll", "sum", "depth", "limit", "size", "find", "start", "second", "current", "base", "found", "call", "span", "length", "check", "force", "every", "int", "next", "Count", "content", "case", "number", "weight", "f", "test"]}}
{"code": " \n  class Solver(object):\n      def __init__(self):\n          pass\n      \n      def solve(self, inputs):\n          R, C, M = [int(x) for x in inputs[0].split()]\n          mp = []\n          for r in range(R):\n              mp.append(['.']*C)\n          mp[0][0] = 'c'\n          outputs = []\n          if M == 0:\n              for row in mp:\n                  outputs.append(''.join(row))\n              return outputs\n          rr, cc, rm = R, C, M\n          while rm >= min(rr, cc):\n              if rr <= cc:\n                  for r in range(rr):\n                      mp[r][cc-1] = '*'\n                  cc -= 1\n                  rm -= rr\n              else:\n                  for c in range(cc):\n                      mp[rr-1][c] = '*'\n                  rr -= 1\n                  rm -= cc\n          \n          if rm == 0:\n              if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:\n                  return ['Impossible']\n          else:\n              if min(rr, cc) - rm >= 2:\n                  if rr <= cc:\n                      for r in range(rr-rm, rr):\n                          mp[r][cc-1] = '*'\n                  else:\n                      for c in range(cc-rm, cc):\n                          mp[rr-1][c] = '*'\n              else:\n                  if min(rr, cc) >= 4:\n                      if rr <= cc:\n                          for r in range(2, rr):\n                              mp[r][cc-1] = '*'\n                          mp[rr-1][cc-2] = '*'\n                      else:\n                          for c in range(2, cc):\n                              mp[rr-1][c] = '*'\n                          mp[rr-2][cc-1]='*'\n                  elif min(rr,cc) == 3:\n                      if max(rr, cc) == 3:\n                          return ['Impossible']\n                      else:\n                          if rr <= cc:\n                              mp[2][cc-1] = '*'\n                              mp[2][cc-2] = '*'\n                          else:\n                              mp[rr-1][2] = '*'\n                              mp[rr-2][2] = '*'\n                  else:\n                      return ['Impossible']\n                      \n          for row in mp:\n              outputs.append(''.join(row))\n          return outputs\n          pass\n      \n      def feed(self, inputs):\n          lines = [x.strip() for x in inputs]\n          outputs = []\n          test_case_n = int(lines[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 1\n              case_inputs = lines[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              R, C, M = [int(x) for x in case_inputs[0].split()]\n              rslt = self.solve(case_inputs)\n              if self.verify(rslt, R, C, M):\n                  outputs.append(rslt)\n              else:\n                  raise 'Failed'\n          return outputs\n      \n      def verify(self, outputs, RR, CC, MCNT):\n          if 'Impossible' == outputs[0]:\n              return True\n          rr = len(outputs)\n          cc = len(outputs[0])\n          if RR != rr or CC != cc:\n              return False\n          bd = []\n          mask = []\n          for i in range(rr):\n              mask.append([1]*cc)\n              bd.append([0]*cc)\n              for j in range(cc):\n                  if outputs[i][j] == '*':\n                      bd[i][j] = 9\n                  elif outputs[i][j] == 'c':\n                      start = (i, j)\n          for r in range(rr):\n              for c in range(cc):\n                  if bd[r][c] == 9:\n                      for i in [r-1,r,r+1]:\n                          for j in [c-1,c,c+1]:\n                              if 0 <= i < rr and 0 <= j < cc:\n                                  if bd[i][j] != 9:\n                                      bd[i][j] += 1\n  \n          nlist = [start]\n          while len(nlist):\n              i, j = nlist.pop(0)\n              if mask[i][j] != 0:\n                  mask[i][j] = 0\n                  if bd[i][j] == 9:\n                      raise '!!! BOMB'\n                  elif bd[i][j] == 0:\n                      for ii in [i-1,i,i+1]:\n                          for jj in [j-1,j,j+1]:\n                              if 0<=ii<rr and 0<=jj<cc:\n                                  if ii != i or jj != j:\n                                      nlist.append((ii,jj))\n          mcnt = 0\n          for r in range(rr):\n              for c in range(cc):\n                  if mask[r][c] == 1:\n                      mcnt += 1\n                  if mask[r][c] == 1 and bd[r][c] != 9:\n                      return False\n                  if mask[r][c] != 1 and bd[r][c] == 9:\n                      return False\n          return (mcnt == MCNT)\n                  \n  \n  if __name__ == '__main__':\n      iname = 'C-small-attempt0.in'\n      sample_in = '''\n  7\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  3 4 0\n  2 2 3\n      '''\n      sample_out = '''\n  Case #1: 1.0000000\n  Case #2: 39.1666667\n  Case #3: 63.9680013\n  Case #4: 526.1904762\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              inputs = f.readlines()\n      else:\n          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      outputs = solver.feed(inputs)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for i, v in enumerate(outputs):\n                  print >> f, 'Case #%d:'%(i+1)\n                  print >> f, '\n'.join(v)\n      print '===================================================='\n      for i, v in enumerate(outputs):\n          print 'Case #%d:'%(i+1)\n          print '\n'.join(v)\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n", "substitutes": {"self": ["worker", "e", "object", "user", "t", "n", "q", "gen", "w", "os", "this", "func", "g", "h", "s", "selves", "app", "host", "py", "p", "d", "client", "obj", "k", "_", "f", "er", "resp", "Self"], "inputs": [" inputtests", "inputsets", "Inputlines", "inputd", "Inputtests", " inputlines", "Inputs", "outputp", "inputlines", "dictlines", "dictd", "outputsets", "outputtests", "inputp", "outputd", "inputtests", "dicts", "Inputsets", "dictsets", "Inputp", " inputp", "Inputd", "outputlines"], "R": ["N", "Y", "T", "GR", "Rs", "P", "MR", "RH", "CR", "RT", "E", "G", "H", "SR", "RM", "W", "RO", "RF", "K", "X", "DR", "RS", "B", "D", "F", "RC", "RG", "LR", "RN", "S", "V", "NR", "A", "L", "U", "RA"], "C": ["N", "NC", "SC", "T", "P", "VC", "DC", "CM", "CR", "E", "G", "CE", "RM", "W", "CA", "K", "X", "cr", "CW", "Cu", "B", "I", "KC", "CS", "D", "F", "CI", "RC", "CCC", "O", "S", "CL", "MC", "CU", "WC", "CN", "A", "L", "U"], "M": ["N", "Y", "MD", "T", "P", "MR", "CM", "mm", "E", "G", "MX", "H", "RM", "W", "X", "Q", "I", "B", "MF", "MH", "D", "F", "LM", "MM", "m", "O", "mc", "S", "MN", "MC", "V", "A", "L", "U"], "x": ["rx", "xxxxxxxx", "id", "xx", "e", "xe", "px", "t", "xy", "tx", "xi", "xxxx", "fx", "w", "xxx", "X", "ex", "xes", "ux", "ww", "xp", "y", "xa", "xc", "xt", "dx", "p", "xf", "xd", "d", "z", "ix", "ax", "mx", "wx", "xs", " X", "sex", "f", "lex", "exp"], "mp": ["pg", "lim", "spec", "match", "wp", "jp", "agg", "tmp", "app", "fm", "mac", "MM", "m", "cm", "ph", "clip", "rep", "mk", "ps", "mph", "par", "mop", "upp", "ep", "mem", "comp", "mm", "amp", "mult", "amps", "proc", "zip", "large", "lp", "vp", "rup", "emp", "p", "Mp", "md", "csv", "ma", "company", "omp", "px", "ip", "eps", "up", "imp", "aps", "MP", "pe", "mate", "mag", "mod", "cmp", "mc", "frame", "pm", "map", "mx", "op", "pc", "pl", "ap", "sp", "np", "yp", "cap", "post", "mom", "me", "ms", "params", "gm", "msg", "mb", "pp", "meta", "fp", "cop", "cp", "loc", "mo"], "r": ["e", "err", "fr", "yr", "rf", "ru", "br", "l", "ro", "rd", "oc", "rt", "w", "dr", "rh", "order", "lr", "cr", "ir", "h", "ar", "attr", "nr", "rc", "sr", "rl", "range", "pr", "ur", "hr", "m", "rb", "u", "rs", "b", "p", "rg", "re", "rar", "k", "f", "er", "loc", "rn"], "outputs": ["Outputlines", "OutputS", "outputS", "Outputi", "inputS", "Outputions", " outputS", "columnions", "columnlines", "Outputs", "Outputks", "inputlines", "outputi", " outputlines", "outputks", " outputks", "columns", "Outputps", "columnks", " outputi", " outputps", "inputi", " outputions", "outputions", "inputps", "outputps", "outputlines"], "row": ["Row", "mr", "rown", "ack", "array", "ro", "slice", "model", "up", "month", "post", "mm", "w", "feed", "col", "order", "rec", "round", "match", "rew", "micro", "ows", "sc", "raw", "agg", "rc", "mod", "ow", "roc", "input", "mar", "mac", "rows", "gram", "cm", "rup", "mc", "frame", "line", "rep", "entry", "arr", "cell", "rank", "rn", "mat", "record"], "rr": ["err", "gr", "vr", "ce", "CR", "rt", "dr", "ck", "lr", "ir", "rer", "coll", "arc", "agg", "rc", "rl", "call", "rg", "iter", "rn", "gg", "rx", "bug", "rf", "ror", "gro", "cr", "rack", "aa", "bb", "track", "actor", "ra", "error", "ac", "route", "orig", "mr", "fr", "uc", "rss", "ru", "code", "q", "act", "order", "rec", "kr", "ar", "wr", "sr", "cf", "cover", "der", "hr", "rb", "rs", "mc", "tr", "vc", "irc", "air", "rar", "f", "er", "inc", "adr", "ack", "add", "rd", "rh", "co", "g", "h", "attr", "nr", "rol", "pp", "RC", "req", "dd", "rw", "addr", "arr", "loc", "pr"], "cc": ["nc", "ca", "ce", "cu", "ck", "col", "cci", "coll", "ucc", "anc", "rc", "cn", "xc", "can", "cm", "go", "call", "cell", "k", "case", "rn", "gg", "rule", "lc", "kk", "cca", "ll", "cr", "sc", "aa", "bb", "custom", "con", "fc", "ct", "ac", "com", "uc", "ff", "cs", "code", "dc", "q", "rec", "cf", "cmp", "ci", "CCC", "acc", "rs", "mc", "vc", "f", "inc", "cb", "pc", "ack", "oc", "bc", "ec", "co", "g", "cd", "lv", "RC", "sk", "cv", "ic", "cy", "cl", "cp", "loc"], "rm": ["adr", "rx", "ym", "mr", "min", "pc", "err", "cb", "rf", "mi", "rom", "km", "rd", "lc", "MR", "cond", "mm", "rt", "dr", "rh", "cdn", "lr", "RM", "ref", "co", "cr", "mn", "bm", "ir", "kr", "vm", "cd", "attr", "nr", "rc", "cn", "mod", "nor", "sr", "RP", "range", "cmp", "arm", "RC", "ci", "fm", "irm", "m", "cm", "rb", "orm", "mc", "cre", "pm", "orr", "mir", "rem", "nm", "md", "dm", "cp", "rn"], "c": ["e", "uc", "unc", "nc", "pc", "cs", "l", "code", "n", "dc", "lc", "q", "count", "ce", "cache", "cu", "un", "col", "ec", "co", "cr", "g", "h", "sc", "coll", "cd", "arc", "anc", "rc", "cn", "ci", "xc", "con", "m", "u", "cm", "ic", "mc", "b", "p", "d", "ct", "cy", "cl", "cp", "k", "f", "loc", "ac"]}}
{"code": " \n  class Solver(object):\n      def __init__(self):\n          pass\n      \n      def solve(self, inputs):\n          r1 = int(inputs[0])\n          cs1 = set([int(x) for x in inputs[r1].split()])\n          r2 = int(inputs[5])\n          cs2 = set([int(x) for x in inputs[5+r2].split()])\n          r = cs1.intersection(cs2)\n          cnt = len(r)\n          if 1 == cnt:\n              return max(r)\n          elif 0 == cnt:\n              return 'Volunteer cheated!'\n          else:\n              return 'Bad magician!'\n          pass\n      \n      def feed(self, inputs):\n          lines = [x.strip() for x in inputs]\n          outputs = []\n          test_case_n = int(lines[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 10\n              case_inputs = lines[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              outputs.append(self.solve(case_inputs))\n          return outputs\n  \n  if __name__ == '__main__':\n      iname = 'A-small-attempt0.in'\n      sample_in = '''\n      3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n      '''\n      sample_out = '''\n   Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              inputs = f.readlines()\n      else:\n          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      outputs = solver.feed(inputs)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for i, v in enumerate(outputs):\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\n      else:\n          ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])\n          for i, v in enumerate(outputs):\n              t = 'Case #%d: %s'%(i+1, str(v))\n              if t not in ans:\n                  print '!!! Wrong:', t\n                  fail_flag = True\n      print '===================================================='\n      for i, v in enumerate(outputs):\n          print 'Case #%d: %s'%(i+1, str(v))\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n", "substitutes": {"self": ["worker", "parent", "j", "e", "object", "user", "other", "peer", "q", "writer", "server", "cache", "w", "os", "this", "g", "c", "h", "connection", "master", "reader", "ws", "selves", "context", "app", "host", "view", "m", "b", "p", "d", "full", "client", "super", "k", "_", "work", "node", "f", "er", "cl", "Self"], "inputs": ["inputes", "Inputwords", "outputuments", "subjects", "inputples", "inputd", "accepterences", "columngroups", "columnlines", "Inputs", "acceptments", "outputwords", "pulls", "outputl", "Inputn", "pullds", "inputss", "Inputerences", "Inputl", "subjectwords", "outputn", "Inputsets", "inputb", " inputd", " inputerences", "inputsets", "columnples", " inputsets", " inputlines", "Inputds", "acceptwords", "inputwords", " inputss", "outputments", " inputments", "subjectd", " inputl", " inputb", "outputd", "inputds", "columns", "subjectes", "columnuments", "inputl", " inputds", "subjectsets", "subjectds", "columnsets", "accepts", "Inputlines", "incsets", "Inputss", "columnb", "Inputgroups", "inclines", "Inputb", "acceptlines", "acceptd", "Inputd", " inputwords", "pulles", "Inputes", "outputerences", "Inputples", " inputgroups", "inputerences", "pulld", "incs", "inputlines", "inputuments", "inputments", "subjecterences", "inputgroups", "outputsets", " inputn", " inputples", "incuments", "columnss", "inputn", "outputlines"], "r1": ["nr0", "nr5", "R5", "nr2", " r61", "r61", "sr1", "r5", "sr5", "sr0", " r7", "r0", "R7", "R61", "rr1", "rr61", "rr7", "r7", "R2", "nr1", "sr2", "R1", "R0", "rr2"], "cs1": ["qs2", "CS1", "qs1", "qs5", "css0", "cone", "css5", "CS91", "cs0", "c91", "c5", "css2", "csone", "CS2", " csone", "c1", "cs5", "cs91", "c0", "CSone", "c2", "css1", " cs91", "qs0"], "x": ["id", "est", "ux", "xc", "m", "inx", "ax", " X", "xs", "sex", "k", "content", "case", "layer", "rx", "l", "n", "xy", "xxxx", "xxx", "X", "xml", "ex", "xp", "name", "xa", "config", "out", "xt", "str", "p", "xf", "ix", "ct", "_", "word", "rex", "px", "index", "code", "q", "xi", "ady", "s", "python", "y", "input", "yl", "u", "plex", "dx", "d", "cross", "f", "data", "e", "xx", "string", "tx", "text", "fx", "w", "expl", "g", "c", "h", "xes", "file", "z", "nex", "read", "int", "wx", "work", "lex", "test"], "r2": ["ar2", "R5", " r5", "er2", "sr1", "r5", "sr5", "ar1", "ar0", "r0", "rtwo", "c5", "Rtwo", "srtwo", "ar5", "er5", "ertwo", "c1", "er1", " r0", "R2", "c0", "R1", "sr2", "c2"], "cs2": ["acs1", "CS1", "csn", "css5", " csn", "cssTwo", "cs0", "csTwo", "c5", "cn", " cs0", "CS0", "css2", "acs2", "CS2", "acs5", "c1", "acsTwo", "cs5", "CSn", "c0", "c2", "css1", "cTwo"], "r": ["rx", "e", "fr", "rr", "result", "l", "br", "n", "q", "right", "w", "rh", "o", "rec", "g", "cr", "c", "s", "ir", "R", "kr", "h", "nr", "rev", "sr", "range", "m", "rb", "u", "rs", "rw", "b", "p", "d", "radius", "rg", "arr", "k", "re", "er"], "cnt": ["pcrt", "cnc", "cnd", "rcnt", "pcnc", "pcnt", "lcnc", "conrt", "cst", "fcct", "connc", "cne", "fcnt", "lcnt", "connt", "lcne", "pcst", "fcnd", "fcnc", "rcct", "rcnd", "rcnc", " cnc", "conne", "crt", "lcrt", " cne", " crt", "lcct", "lcst", " cst", "cct", "lcnd"], "lines": ["comments", "blocks", "groups", "points", "vs", "l", "models", "log", "liners", "limits", "reads", "cycles", "sections", "files", "words", "s", "ins", "ines", "codes", "rings", "values", "ses", "sites", "ws", "tests", "objects", "pins", "cells", "strings", "runs", "plugins", "ids", "rows", "elines", "steps", "lins", "breaks", "items", "works", "ls", "line", "rules", "es", "frames", "cases", "vals", "xs", "pages", "faces"], "outputs": [" outputn", "inputes", "Outputlines", "pathd", "Outputl", " outputl", "methodd", "Outputments", "outputes", "Outputwords", "Outputs", "methods", "outputts", "inputlines", "inputwords", "methodn", "inputments", "inputts", "Outputes", " outputlines", "outputl", "outputwords", "pathn", "outputments", " outputes", "putts", " outputd", "puts", "outputd", " outputwords", "outputn", "putl", "putlines", " outputments", "paths", "inputl", " outputts", "outputlines"], "test_case_n": ["test_case_num", "test_case_c", "test_cases_n", "case_cases_size", "case_case_num", "case_cases_N", "case_cases_n", "case_cases_num", "case_case_N", "test_cases_p", "case_case__N", "test_cases_num", "test_cases_c", "case_case__n", "case_case_n", "case_case_size", "case_case__num", "case_case__size", "test_case_p"], "cur": ["id", "uc", "Cur", "sth", "ah", "aug", "focus", "count", "ind", "ctr", "shift", "const", "cu", "dr", "pub", "cr", "div", "c", "dec", "keep", "sc", "enc", "oct", "rev", "rc", "row", "sur", "start", "num", "rest", "ser", "ur", "sr", "ci", "usr", "prev", "current", "con", "ph", "tri", "ver", "ch", "length", "quad", "ct", "cor", " Cur", "iter", "case", "loc", "th", "pr", "char", "inc"], "i": ["id", "j", "ii", "e", "bi", "index", "ip", "l", "n", "phi", "ind", "xi", "li", "iu", "it", "c", "ti", "gi", "h", "chi", "y", "ih", "si", "I", "start", "rest", " I", "uri", "inner", "ci", "ini", "u", "ai", "b", "p", "d", "ch", "pos", "ix", "pi", "z", "int", "a", "k", "f"], "case_line_cnt": ["case_line_acNT", "case_line_cnc", "case_line_nNT", "case_line_lcNT", "case_line_cct", "case_line_lcnc", "case_line_cNT", "case_line_ucnt", "case_line_lcct", "case_line_nct", "case_line_CNT", "case_line_ucct", "case_line_Cnc", "case_line_Cnt", "case_line_cn", "case_line_Cno", "case_line_ucNT", "case_line_acnt", "case_line_acno", "case_line_acnc", "case_line_nnt", "case_line_lcno", "case_line_acn", "case_line_lcnt", "case_line_acct", "case_line_nn", "case_line_ucn", "case_line_cno"], "case_inputs": ["case_configs", "case_columnstates", "case_selectes", "case_outputlines", "case_controllines", "case_columnlines", "case_inputstates", "case_configlines", "case_outputs", "case_configes", "case_controlerences", "case_selectlines", "case_columns", "case_outputstates", "case_controlstates", "case_inputlines", "case_controls", "case_inputerences", "case_inputes", "case_selects", "case_columnerences", "case_outputerences", "case_outputes"], "iname": ["inamed", "insAME", "innam", "namer", "named", "iniamer", "iniame", "iniAME", "ninAME", "inasm", "nAME", " inAME", " inaming", "inamer", "inaming", "insame", " inamer", "name", "inames", "insasm", " innam", "niname", "ninaming", "inAME", "iniames", " inames", " inasm", "ninasm", "ininam", "IName", "INnam", "INames", " inamed", "iniamed", "INamer", "insaming"], "sample_in": ["sample_IN", "samplepleout", "samplepleins", " sample_IN", "sample_ins", "sample2conn", "sample2ins", "sample2in", "sample_conn", "sample2out", " sample_ins", "sampleplein", "samplepleconn", " sample_conn"], "sample_out": ["samplepin", "case_out", "sampleplist", "sample_list", "case_in", "case_again", "sample_again", "samplepout", "case_list", "samplepagain"], "solver": ["Sistor", " sistor", " solve", "solution", "Solution", " solved", " solution", "setsolution", "Solver", "Solve", "Solved", "solar", "sistor", "setsolved", "Solar", "setsistor", "setsolar", "setsolve", " solar", "setsolver", "solved", "solve"], "fail_flag": ["cond\n", " fail\n", "success\n", "fail\n"]}}
{"code": "'''\n  Created on Apr 12, 2014\n  \n  @author: mostasem\n  '''\n  \n  def getFloorRoots(m):\n      r1 = -1 + math.sqrt(1 + (8 * m))/2\n      r2 = -1 - math.sqrt(1 + (8 * m))/2\n      return int(math.floor(r1))\n      \n  def boardHasZero(R,C,M):\n      if(R > 1 and C > 1):\n          S = M/C\n          Sr = M % C\n          print S,Sr\n          return R >= S+3 or (R == S+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (R == S+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)\n      else :\n          return M <= ((R*C) - 2)\n  \n  \n  def generateMineSweeperCase(R,C,M):\n  \n      board = \"\"\n  \n      if( R > 1 and C > 1 ): # generate special\n          S = M/C\n          Sr = M % C\n          print S,Sr\n          if(S): # all rows of *\n              board +=\"\n\"\n              if(R >= S+3 or (R == S+2 and Sr % 2 == 0)):\n                  board += (S - 1) * ((C*\"*\") + \"\n\")\n              else:\n                  board += (S - 2) * ((C*\"*\") + \"\n\")\n              board +=  ((C*\"*\"))\n              \n          if(R >= S+3):\n              if(Sr):\n                  board +=\"\n\"\n                  board += ((Sr *\"*\") + ((C - Sr) *\".\"))\n              Rm = R - (S + 1)\n              if(Rm):\n                  board +=\"\n\"\n                  board += (Rm - 1) * ((C*\".\") + \"\n\")\n                  board +=  ((C*\".\"))\n                  \n          elif(R == S + 2):\n              Sm = 0\n              if(Sr % 2 == 0):\n                  board +=\"\n\"\n                  board += (((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\") +\"\n\")\n                  board += ((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\")\n              else:\n                  board +=\"\n\"\n                  board += (((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\") +\"\n\")\n                  board += ((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\")\n          else :\n              Sm = Sr + C\n              board +=\"\n\"\n              board += (((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\") +\"\n\")\n              board += ((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\")\n                  \n          list_board = list(board)\n          list_board[len(list_board) - 1] = 'c'\n          board = \"\".join(list_board)\n      else:\n          board +=\"\n\"\n          if(C == 1):\n              board += M * \"*\n\"\n              board += (R-M-1) * \".\n\"\n              board +=  \"c\"\n          else:\n              board += M * \"*\"\n              board += (C-M-1) * \".\"\n              board += \"c\"\n              \n      return board\n         \n         \n         \n  \n  f_r = open('C.in',\"r\")\n  n_test=int(f_r.readline().strip()) \n  f_w = open(\"C.out\", \"w\")\n  result = \"\"\n  for i in range(n_test):\n      R,C,M = map(int,f_r.readline().split())\n      print R,C,M\n      if(boardHasZero(R,C,M)):\n          result = generateMineSweeperCase(R,C,M)\n      else :\n          result =\"\nImpossible\"\n      print result\n      output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n      \n  f_r.close()\n", "substitutes": {"m": ["x", "mu", "ym", "mr", "v", "e", "j", "im", "l", "mi", "t", "n", "Ms", "r", "mm", "w", "o", "g", "c", "ms", "s", "h", "om", "gm", "y", "hm", "fm", "b", "p", "d", "tm", "a", "dm", "f"], "r1": ["R6", "R3", "rc2", "p2", "p3", "rc1", "r6", "r0", "rc3", " r6", "rc6", " r3", "r3", " r0", "R2", "p0", "R1", "p1", "R0"], "r2": ["p2", " r0", "R2", "p0", "R1", "r0", "p1", "R0"], "R": ["Rh", "TR", "N", "Y", "T", "GR", "Rs", "Range", "P", "RE", "MR", "Cl", "J", "CR", "Re", "r", " r", "JR", "E", "H", "G", "SR", "RM", "W", "RO", "K", "X", "Right", "RW", "ER", "Q", "DR", "RS", "BR", "Rec", "B", "Run", "RP", "AR", "D", "F", "RG", "IR", "Ra", "O", "RN", "RL", "Ren", "RR", "V", "Res", "KR", "WR", "A", "Role", "L", "U", "RA"], "C": ["N", "Y", "NC", "Cor", "T", "CNN", "AC", "Cs", "P", "ASC", "VC", "DC", "CM", "CR", "Cl", "FC", "CF", "U", "E", "G", "H", "Size", "CE", "W", "COR", "CA", "K", "X", "c", "Co", "Sc", "JC", "YC", "CV", "CO", "Q", "CC", "LC", "ERC", "CS", "I", "B", "Cu", "CW", "KC", "D", "F", "CI", "Cr", "Ch", "Ac", "GC", "O", "CT", "CP", "CL", "Custom", "CH", "EC", "MC", "V", "Mc", "CU", "Count", "CN", "RFC", "A", "L", "Con"], "M": ["Y", "N", "MD", "T", "P", "MS", "Man", "MR", "MO", "J", "CM", "Ms", "E", "SM", "G", "H", "Mass", "RM", "W", "DM", "X", "MU", "NM", "Mo", "Q", "Memory", "TM", "I", "B", "MF", "D", "F", "LM", "O", "MA", "CL", "MN", "ME", "Z", "MC", "V", "IM", "AR", "L", "U"], "S": ["PS", "Y", "N", "SC", "Socket", "T", "NS", "Rs", "Es", "P", "HS", "Single", "Su", "SI", "TS", "Ds", "SA", "SE", "U", "E", "G", "H", "SR", "Size", "OS", "W", "ES", "Ps", "K", "X", "Is", "SL", "s", "Si", "Sc", "System", "DS", "US", "Service", "SS", "Sl", "IS", "Q", "Ns", "RS", "CS", "I", "B", "Session", "D", "F", "Se", "WS", "O", "Z", "Source", "Case", "GS", "SH", "Set", "Sh", "A", "L", "V", "SU"], "Sr": ["PSR", "NSm", " Sru", "PSrc", "SSz", "Esra", "SSr", "SR", "Set\n", "sR", "Drs", "src", "Ssr", "ScR", "PSrb", "Scr", "GSnr", "NSra", " Sc", "DSri", "Esrf", "srb", "Psdr", "Src", "Asr", "PSnr", "GSra", "Sz", "sm", "Psrb", "S20", "Syr", "Usre", "PSm", "ssr", "Dsrb", "Srb", "DSre", "PSpr", "Sec", "Sre", "Dsra", "NSr", "Shippr", "GSr", "Sc", "Npr", "sc", "SSm", "Svr", "Asrc", "srs", "NSR", "Dsrs", "PsR", "Psrf", "Insr", " Sz", "Shipri", "Usyr", "Se\n", "GSR", " Spr", "SSnr", "Insrb", "Asm", "CSm", "ISre", "Shipr", "GSvr", " SR", "InsR", "ISR", "Srf", "Snr", "Spr", "Scrc", "Insm", "Psvr", " Sdr", " S20", " Syr", " Snr", "SSrc", "snr", "Assr", "CSnr", "Drb", "Asrb", "SSrs", "Esr", "DSpr", "ISri", "Asrs", "Dsrc", "SSsr", "Jspr", "Asp", "NSrf", " Src", "Psrc", "sr", "Sp", "Scsr", "Jsru", "Dsr", "UsR", "AsR", "Sru", "PSr", "ISr", "Nr", "Set20", "Psra", "Usr", "ISpr", "Se20", "NSre", "SSp", "CSr", "Jsr", "Psc", "Psyr", "Pssr", "sp", " Ssr", "NSrb", "Esrb", "NSsr", "Shipre", "Usdr", "JsR", "GSrb", "GSrc", " Srb", "Uspr", "Psr", "Pspr", "Sra", "Dspr", "Sdr", "PSra", "Sri", "NSpr", "Psnr", "PSvr", "DsR", "sz", "Srs", "SSR", "Dr", "CSrc", "DSr", "NR", "Setc", "Dra", "Nru", "NSrs"], "board": ["bug", "menu", "game", " dashboard", "deck", "ack", "la", "lane", "che", "card", "model", "table", "bo", "post", "channel", "ck", "feed", "body", "que", "round", "ward", "flo", "Board", "co", "ban", "square", "stroke", "list", "coll", "stone", " row", "head", "road", "byte", "wheel", "row", "door", "clean", "bird", "stick", "view", "sequence", "can", "lay", "rows", "function", "throw", "phone", "builder", "hole", "layout", "plan", "cross", "block", "box", "panel", "boarding", "line", "boards", "entry", "chain", "check", "foot", "error", "comment", "land", "player", "case", "cart", "bank", "video", "design"], "Rm": ["Rr", "rmr", "rr", "Hp", " RM", "PM", "Dc", "Dp", "Mr", "Mm", "rdm", "RM", "DM", "rm", "rc", "Hm", "Rnm", "MM", "Dm", "Rp", "rM", "Rdm", "Pm", "HM", "Mnm", "Mp", "Dr", "Pmr", " Rdm", "Mc", "Dnm", "Rc", "Rmr", "Pdm", "Hnm", " Rmr"], "Sm": ["step", "game", "Row", "blocks", "draw", "move", "model", "channel", "feed", "sample", "square", "Board", "progress", "sum", "sb", "shell", "margin", "switch", "rug", "border", "roll", "block", "line", "error", "foot", "comment", "Block", "cell", "rank", "Sk"]}}
{"code": "'''\n  Created on Apr 11, 2014\n  \n  @author: mostasem\n  '''\n  \n  \n  \n  def getIntersection(A,B):\n      intersect_list = []\n      dict = {};\n      for i in range(4):\n          if(dict.get(A[i]) <> None):\n              dict[A[i]] += 1\n              if(intersect_list.count(A[i]) == 0):\n                  intersect_list.append(A[i])\n          else:\n              dict[A[i]] = 1\n          if(dict.get(B[i]) <> None):\n              dict[B[i]] += 1\n              if(intersect_list.count(B[i]) == 0):\n                  intersect_list.append(B[i])\n          else:\n              dict[B[i]] = 1\n  \n      return intersect_list\n  \n  f_r = open('A.in',\"r\")\n  n_test=int(f_r.readline().strip()) \n  f_w = open(\"A.out\", \"w\")\n  result = \"\"\n  for i in range(n_test):\n      cards1 = []\n      row_index_1 = int(f_r.readline()) - 1\n      for j in range(4):\n          cards1.append(map(int,f_r.readline().split()))\n      cards2 = []\n      row_index_2 = int(f_r.readline()) - 1\n      for j in range(4):\n          cards2.append(map(int,f_r.readline().split())) \n      int_list =  getIntersection(cards1[row_index_1], cards2[row_index_2])\n      result = \"\"\n      if(len(int_list) == 0):\n          result = \"Volunteer cheated!\"\n      elif(len(int_list)  == 1):\n          result = str(int_list[0])\n      else:\n          result = \"Bad magician!\"\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n      print output_str\n      f_w.write(output_str+'\n')\n  f_r.close()\n  f_w.close()\n", "substitutes": {"A": ["N", "Ab", "Y", "T", "Product", "Args", "Default", "As", "The", "P", "LA", "All", "Input", "App", "Data", "This", "And", "E", "G", "Al", "Australia", "W", "CA", "X", "Alpha", "Ang", "There", "Center", "File", "AA", "Ar", "API", "Auth", "Array", "I", "Apple", "Init", "Ca", "D", "F", "From", "Application", "S", "At", "C", "AP", "Ant", "Am", "One", "Action", "Part", "Ha", "a", "Files", "If", "M", "Any", "L", "Average", "First"], "B": ["N", "Y", "Other", "QB", "BA", "T", "Cloud", "But", "Beta", "The", "P", "NB", "Both", "Data", "Bar", "BC", "E", "G", "H", "BF", "BS", "OB", "X", "GB", "R", "DB", "File", "BD", "LB", "Ub", "I", "AB", "D", "F", "Sub", "BE", "VB", "WB", "O", "Band", "BI", "b", "S", "UB", "C", "AP", "V", "Bi", "Big", "Block", "Base", "Bs", "BB", "Second", "M", "Two", "L", "U"], "intersect_list": ["intersectingLIST", "intersectall", "interconnect_lists", "intersectinglist", "intersect_count", "intersect_lc", "intersection_l", "intersection_string", "intersect_List", "intersection_tree", "intersectalll", "intersect_chain", "intersectedcount", "intersect_string", "intersection_count", "intersectetlist", "interconnect_List", "intersectetl", "intersection_chain", "intersectinglc", "intersectallist", "intersection_LIST", "intersectalList", "intersectedlist", "intersectingl", "intersection_lc", "interconnect_l", "interconnect_list", "intersectedl", "intersectingchain", "intersect_lists", "intersectedlists", "intersectallists", "intersect_tree", "intersect_diff", "intersectetlc", "intersect_LIST", "intersectalllist", "intersectetstring", "intersect_l", "intersection_lists", "intersectallchain", "intersectingdiff", "intersectingstring", "intersection_diff", "intersection_list", "intersectallLIST"], "dict": ["parent", "bug", "id", "key", "index", "ignore", "patch", "compl", "array", "default", "code", "phi", "count", "model", "table", "cond", "cache", "json", "const", "col", "conn", "rec", "body", "dat", "record", "div", "batch", "module", "list", "c", "self", "coll", "sum", "conf", "sync", "file", "lock", "config", "host", "clean", "view", "con", "hash", "sign", "document", "session", "b", "details", "do", "df", "block", "d", "ict", "diff", "doc", "map", "client", "int", "dir", "condition", "arr", "state", "fix", "data", "dot", "pair", "collect", "db", "inc"], "i": ["id", "v", "ri", "bi", "cli", "t", "ti", "gi", "chi", "counter", "hi", "oi", "ni", "bis", "k", "l", "n", "slice", "ei", "li", "r", "ki", "ie", "name", "num", "udi", "fi", "ai", "p", "a", "di", "zi", "ui", "ii", "index", "multi", "ip", "phi", "ind", "ali", "xi", "yi", "iu", "it", "init", "s", "type", "qi", "y", "I", "ori", "uri", "ci", "ini", "u", "b", "d", "pi", "f", "ji", "x", "e", "key", "trial", "o", "g", "c", "h", "si", "z", "int", "mini", "io"], "f_r": ["f_f", "f5r", "info_ro", "f2dr", " f2w", "f7out", " f2dr", " f5d", "f_ro", "fs_reader", "fileinner", "f5out", " f_out", "filer", "info23u", "f67w", "fs_r", "info_rr", "fo25ro", " f5out", "f2in", "f2w", "f_rr", "f8w", "fo25inner", "info23ro", "f67fr", "fmlreader", "f2reader", "f67r", "f_R", " f2in", "f_n", " f2reader", "f25inner", " f_n", " f_f", "fo_rt", "fo_ro", "f_inner", "f8dr", "fo25rt", "f7d", "fplinner", " f_reader", " f_err", "fplro", "f25rt", "f_rt", " f_dr", "f_in", " f_d", "f2fr", "filero", "f5n", "fmlin", "f5d", "f2r", "f67dr", "f25ro", "fplr", " f_in", "f7n", "f23r", "info_r", "fo_inner", "fo25r", "f23rr", "f67in", " f2fr", "f_out", "fmlr", "f_reader", "f7in", "f_dr", "f_fr", "info23rr", "f23u", "f_u", "fs_in", "fpyrr", "f25r", "f_d", "fpyro", "filert", " f5r", " f5n", "f8reader", "f_err", " f_fr", "info_u", "fo_r", "f7fr", "fpyr", "info23r", "f23ro", "f7w", "fpyu", "fmlR", " f2r", "f8r", "f67reader", "fs_R", "f7r", "fplrt"], "n_test": [" n_match", "N_testing", "n_tests", "n_testing", "n_Test", "N_test", " n_testing", "N_Test", "n_match", "N_tests"], "f_w": ["f32wt", "f6w", " f_wa", " f2wt", "fockdest", "f2r", "fadewa", "f2dest", " f2w", "f2out", " f_dest", "f32dest", " f2out", "fader", "f_wt", "f32r", " f_wt", "fadeout", " f_writer", "f6r", "fockw", " f_out", "f_out", "fockr", "f_dest", "fadew", " f2wa", "f32w", " f2dest", "f6wa", " f2r", "f_wa", "fockwt", "f2wa", "f_writer", "f2wt", "f2w", "f6out", " f2writer", "f2writer"], "result": ["err", "res", "summary", "string", "Result", "array", "report", "our", "compl", "card", "success", "default", "final", "output", "end", "catch", "html", "complete", "json", "r", "format", "status", "answer", "term", "match", "description", "value", "date", "name", "product", "msg", "reason", "ret", "message", "method", "search", "str", "ver", "results", "response", "diff", "resource", "error", "comment", "main", "content", "case", "data", "example", "page", "test"], "cards1": [" cards01", "groupsp", "card81", " cardsOne", "fieldsA", " cards81", "cardsp", "fields1", "cases1", "cards01", "cardsOne", "cardsA", " cardsp", "cases81", "card01", "listsOne", "listsA", " cardsA", "lists81", "groups2", "card1", "cases2", "groups1", "casesOne", "fields81", "lists1", "cardOne", "groups01", "cardp", "cards81", "fieldsOne", "card2"], "row_index_1": ["row_index_7", "row_index_4", "row_index_one", "row_indexing4", "row_indexing1", "row_position_one", "row_position_4", "row_indexingone", "row_index_8", "row_position_1", "row_indexing7", "row_position_7"], "j": ["x", "v", "e", "im", "l", "t", "n", "end", "ind", "q", "J", "jj", "r", "it", "g", "c", "h", "jp", "row", "num", "job", "m", "b", "p", "d", "aj", "z", "k", "_", "f", "uj"], "cards2": ["cuts1", "cardsTwo", " cards0", "card0", "lights2", "lines8", "cardTwo", "lines5", "cards0", " cards32", "cuts5", "cards4", "cards32", " cards8", "cards8", "cards5", "lights0", "lights1", "lines4", "card1", "card4", "cuts4", " cardsTwo", "cuts2", "lights4", "cutsTwo", " cards4", "cuts32", "lines2", "card2", "cuts8", "card32", " cards5"], "row_index_2": ["row_column_two", "row_length_02", "row_index_82", "row_column_to", "row_index_list", "row_length_2", "row_column_20", "row_index_to", "row_column_2", "row_index__2", "row_index_02", "row_length_82", "row_index_two", "row_index_20", "row_indexW02", "row_indexW2", "row_index__02", "row_indexWlist", "row_indexW82", "row_index__list", "row_index__82", "row_length_list"], "int_list": [" int9List", "int5listed", "nice_listed", "nice5map", "int5default", "nice_map", "int64stack", "int5list", "int242", "int6List", "int_List", "int_lists", "int_listed", "intenlist", "int5map", "intenlists", "void24lists", " int9list", "int9pair", "group64list", "int2List", " int_pair", "int9list", "void_lists", "group64stack", " int9stack", "intfstack", "int64lists", "void_2", "void242", "group_stack", "nice5list", "intflist", "group_count", "int24lists", "group_list", " int9pair", "int6pair", "int64list", " int_List", "void_list", "int9List", "group64count", "nice5listed", "nice5default", "int24list", "int64count", "nice_list", "int9stack", "int2list", "int_stack", "inten2", "int_2", "int_pair", "int_map", "intflists", "group64lists", "int6stack", " int_stack", "int6list", "intfcount", "int2stack", "nice_default", "int_count", "void24list", "int_default", "int2pair", "group_lists"], "output_str": ["outputPdata", "Output_res", "output\u00b7Str", "output_char", "outputPres", "output_arr", "Output_arr", "Output_data", " output_arr", "output2char", "output\u00b7arr", "output\u00b7str", " output_res", "outputParr", "outputPstr", "outputgdata", "outputgres", "output2arr", "output2str", "output_data", "output_res", "Output_str", " output_char", "output\u00b7char", "output2Str", "outputgarr", "outputgstr", " output_Str", "output_Str"]}}
{"code": " \n  FILE_NAME_BASE = 'C-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  def parse(inp):\n  \trows, cols, mines = (int(x) for x in inp.readline().split())\n  \treturn rows, cols, mines\n  \n  def search(rows, cols, mines):\n  \n  \tassert 0 <= mines < rows * cols\n  \tif mines == 0:\n  \t\treturn ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)\n  \tif mines == rows * cols - 1:\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n  \n  \tif rows == 1:\n  \t\treturn ['c' + '.' * (cols - 1 - mines) + '*' * mines]\n  \tif cols == 1:\n  \t\treturn ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines\n  \n  \tif mines > rows * cols - 4:\n  \t\treturn None\n  \n  \n  \treturn None\n  \n  class SearchBoard(object):\n  \n  \tdef __init__(self, rows, cols):\n  \t\tself.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]\n  \t\tself.mineCount = 0\n  \n  \tdef addMine(self, row, col):\n  \t\tcounts = self.counts\n  \t\tassert counts[row + 1][col + 1] < 10\n  \t\ttop = counts[row + 0]\n  \t\ttop[col + 0] += 1\n  \t\ttop[col + 1] += 1\n  \t\ttop[col + 2] += 1\n  \t\tmid = counts[row + 1]\n  \t\tmid[col + 0] += 1\n  \t\tmid[col + 1] += 10\n  \t\tmid[col + 2] += 1\n  \t\tbot = counts[row + 2]\n  \t\tbot[col + 0] += 1\n  \t\tbot[col + 1] += 1\n  \t\tbot[col + 2] += 1\n  \t\tself.mineCount += 1\n  \n  \tdef removeMine(self, row, col):\n  \t\tcounts = self.counts\n  \t\tassert counts[row + 1][col + 1] >= 10\n  \t\ttop = counts[row + 0]\n  \t\ttop[col + 0] -= 1\n  \t\ttop[col + 1] -= 1\n  \t\ttop[col + 2] -= 1\n  \t\tmid = counts[row + 1]\n  \t\tmid[col + 0] -= 1\n  \t\tmid[col + 1] -= 10\n  \t\tmid[col + 2] -= 1\n  \t\tbot = counts[row + 2]\n  \t\tbot[col + 0] -= 1\n  \t\tbot[col + 1] -= 1\n  \t\tbot[col + 2] -= 1\n  \t\tself.mineCount -= 1\n  \n  \tdef checkConnected(self):\n  \t\tcounts = self.counts\n  \t\tcols = len(counts[0]) - 2\n  \t\trows = len(counts) - 2\n  \n  \t\tfor rowIdx, row in enumerate(counts):\n  \t\t\tif rowIdx == 0 or rowIdx > rows:\n  \t\t\t\tcontinue\n  \t\t\ttry:\n  \t\t\t\tcolIdx = row.index(0, 1, -1)\n  \t\t\texcept ValueError:\n  \t\t\t\tpass\n  \t\t\telse:\n  \t\t\t\tclick = (rowIdx, colIdx)\n  \t\t\t\tbreak\n  \t\telse:\n  \t\t\treturn None\n  \n  \t\trevealed = set()\n  \t\tdef reveal(row, col):\n  \t\t\tif 1 <= row <= rows and 1 <= col <= cols:\n  \t\t\t\tpos = (row, col)\n  \t\t\t\tif pos not in revealed:\n  \t\t\t\t\trevealed.add(pos)\n  \t\t\t\t\tcount = counts[row][col]\n  \t\t\t\t\tif count == 0:\n  \t\t\t\t\t\tfor dr in (-1, 0, 1):\n  \t\t\t\t\t\t\tfor dc in (-1, 0, 1):\n  \t\t\t\t\t\t\t\tif dr != 0 or dc != 0:\n  \t\t\t\t\t\t\t\t\treveal(row + dr, col + dc)\n  \t\t\t\t\telse:\n  \t\t\t\t\t\tassert count < 10\n  \t\treveal(*click)\n  \t\tnumNonMines = rows * cols - self.mineCount\n  \t\tif len(revealed) != numNonMines:\n  \t\t\tassert len(revealed) < numNonMines\n  \t\t\treturn None\n  \n  \t\tboard = [\n  \t\t\t\t['.' if cell < 10 else '*' for cell in row[1 : -1]]\n  \t\t\t\tfor row in counts[1 : -1]\n  \t\t\t\t]\n  \t\tboard[click[0] - 1][click[1] - 1] = 'c'\n  \t\treturn [''.join(row) for row in board]\n  \n  def searchBruteForce(rows, cols, mines):\n  \tif mines == rows * cols - 1:\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n  \n  \tsearchBoard = SearchBoard(rows, cols)\n  \n  \tdef searchRec(idx, remaining):\n  \t\tif remaining == 0:\n  \t\t\treturn searchBoard.checkConnected()\n  \t\telif idx < remaining:\n  \t\t\treturn None\n  \t\telse:\n  \t\t\tpos = divmod(idx, cols)\n  \t\t\tsearchBoard.addMine(*pos)\n  \t\t\tfound = searchRec(idx - 1, remaining - 1)\n  \t\t\tsearchBoard.removeMine(*pos)\n  \t\t\tif found is not None:\n  \t\t\t\treturn found\n  \t\t\treturn searchRec(idx - 1, remaining)\n  \n  \treturn searchRec(rows * cols - 1, mines)\n  \n  def solve(rows, cols, mines):\n  \tboard = search(rows, cols, mines)\n  \n  \tif board is None:\n  \t\tboard = searchBruteForce(rows, cols, mines)\n  \t\tif board is None:\n  \t\t\treturn '\n' + 'Impossible'\n  \t\tprint 'ERROR: fast search missed solution for %dx%d board, %d mines:' \\\n  \t\t\t\t% (rows, cols, mines)\n  \t\tfor row in board:\n  \t\t\tprint row\n  \t\tprint\n  \n  \tassert len(board) == rows\n  \tassert all(len(row) == cols for row in board)\n  \tcounts = { 'c': 0, '.': 0, '*': 0 }\n  \tfor row in board:\n  \t\tfor cell in row:\n  \t\t\tcounts[cell] += 1\n  \tassert counts['c'] == 1\n  \tassert counts['*'] == mines\n  \n  \tflowBoard = [\n  \t\t\t['.' if cell == 'c' else cell for cell in row]\n  \t\t\tfor row in board\n  \t\t\t]\n  \tdef countMinesOn(row, col):\n  \t\tif 0 <= row < rows and 0 <= col < cols:\n  \t\t\treturn 1 if flowBoard[row][col] == '*' else 0\n  \t\telse:\n  \t\t\treturn 0\n  \tdef countMinesNear(row, col):\n  \t\treturn sum(\n  \t\t\tcountMinesOn(row + dr, col + dc)\n  \t\t\tfor dr in (-1, 0, 1)\n  \t\t\tfor dc in (-1, 0, 1)\n  \t\t\t)\n  \tdef reveal(row, col):\n  \t\tif 0 <= row < rows and 0 <= col < cols:\n  \t\t\tassert flowBoard[row][col] != '*'\n  \t\t\tif flowBoard[row][col] == '.':\n  \t\t\t\tcount = countMinesNear(row, col)\n  \t\t\t\tflowBoard[row][col] = str(count)\n  \t\t\t\tif count == 0:\n  \t\t\t\t\tfor dr in (-1, 0, 1):\n  \t\t\t\t\t\tfor dc in (-1, 0, 1):\n  \t\t\t\t\t\t\treveal(row + dr, col + dc)\n  \tclickRow, = [i for i, row in enumerate(board) if 'c' in row]\n  \tclickCol = board[clickRow].index('c')\n  \treveal(clickRow, clickCol)\n  \tassert all('.' not in row for row in flowBoard), flowBoard\n  \n  \tassert all(type(row) == str for row in board)\n  \treturn '\n' + ''.join('\n' + ''.join(row) for row in board)\n  \n  def main():\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\n  \n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\n  \tnumCases = int(inp.readline())\n  \tif NUM_PROCESSES == 0:\n  \t\tresults = [\n  \t\t\tsolve(*parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \telse:\n  \t\tpool = Pool(NUM_PROCESSES)\n  \t\tresults = [\n  \t\t\tpool.apply_async(solve, parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \tinp.close()\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\n  \tfor case, result in enumerate(results):\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n  \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n  \t\tout.flush()\n  \tout.close()\n  \n  if __name__ == '__main__':\n  \tmain()\n", "substitutes": {"FILE_NAME_BASE": ["FILE_NAME_LIBAME", "FILE_NAME_BAME", "FILE_NAME_BAS", "FILE_NAME_LIBARS", "FILE_NAME_CAME", "FILE_NAME_WASE", "FILE_NAME_CARS", "FILE_NAME_LIBAS", "FILE_NAME_LIBASE", "FILE_NAME_WAME", "FILE_NAME_WARS", "FILE_NAME_WAS", "FILE_NAME_CAS", "FILE_NAME_BARS", "FILE_NAME_CASE"], "NUM_PROCESSES": [" NUM_PRECESSE", " NUM_PROCNECTED", " NUM_PRECESTE", " NUM_PROCUSes", " NUM_PRECESSES", " NUM_PROCUSES", " NUM_PROCESTED", " NUM_PROCNECTE", " NUM_PROCESTes", " NUM_PRECESTes", " NUM_PROCNECTES", " NUM_PROCESSED", " NUM_PROCNECTes", " NUM_PRECESSED", " NUM_PROCESTE", " NUM_PROCESSE", " NUM_PRECESSes", " NUM_PRECESTES", " NUM_PROCESSes", " NUM_PROCUSED", " NUM_PRECESTED", " NUM_PROCESTES", " NUM_PROCUSE"], "MEM_LIMIT_GB": ["MEM_LIMIT_MAX", "MEM_LIMITED_MAX", "MEM_LIMITED_MS", "MEM_LIMIT_MB", "MEM_LIMIT_MS", "MEM_LIMITED_MB", "MEM_LIMITED_GB"], "RECURSION_LIMIT": ["RECURSION_LOBITE", "RECURSION_LIMITION", "RECURSION_CLOWITE", "RECURSION_LOBITS", "RECURSION_CLIMITE", "RECURSION_LOWITE", "RECURSION_CLOWITION", "RECURSION_LOBITION", "RECURSION_LOWITION", "RECURSION_CLIMIT", "RECURSION_LOBIT", "RECURSION_CLOWITS", "RECURSION_CLOWIT", "RECURSION_LIMITS", "RECURSION_LOWITS", "RECURSION_CLIMITION", "RECURSION_LOWIT", "RECURSION_LIMITE", "RECURSION_CLIMITS"], "inp": ["rinp", "rinfp", "Infp", "insfp", "INp", "outb", "INb", "INP", "outc", "insb", "insp", "Inb", "Inc", " inb", "infp", "Inp", " infp", "INfp", "insP", "inP", "rinb", "inb", " inc", "outfp", "outp", "rinP", "inc"], "rows": ["members", "docs", "levels", "fields", "cats", "ports", "feed", "sections", "checks", "ws", "tests", "breaks", "forms", "vers", "obs", "acks", "events", "types", "length", "images", "cases", "ks", "groups", "planes", "headers", "models", "OWS", "keys", "words", "ips", "values", "cells", "roots", "qs", "ids", "items", "works", "days", "rules", "lines", "bars", "times", "blocks", "rown", "holes", "rss", "multi", "cs", "features", "thumbnails", "files", "opens", "s", "ows", "heads", "runs", "rs", "flows", "ros", "reports", "errors", "frames", "boxes", "tracks", "months", "ries", "orders", "posts", "rooms", "ins", "users", "objects", "boards", "es", "pages", "projects", "views"], "cols": [" colp", "minows", "columnc", " colions", " colows", "lls", "rowc", "mins", " colops", "Colp", "yles", "wellions", "colp", "Colops", "Coln", "filops", "coli", "rowss", "welles", "Coles", "coln", "Colions", " colths", "rounds", "columnp", "colld", "roundes", "filths", "colions", "Cols", "wells", "Coli", "roundc", "flss", "columnows", "flc", "lles", "fls", "colsets", "llows", "llops", "columns", " coles", "reln", "colops", "wellsets", "coles", "columni", "columnls", "colss", "columnsets", "rown", "minss", "filions", "llls", "columnions", " colses", "fln", "columnses", "files", "Colsets", "roundops", "columnn", "collses", "colses", "ylops", "rels", " colss", "celops", "cels", "Colc", "Colths", "yls", " colc", "llss", "celes", "colln", " coli", "cold", "colths", "columnes", " colls", "filses", "fili", "colls", "columnops", "columnd", "reld", "relses", "colc", "colows", "fils", "columnss", " coln"], "mines": ["millus", "millions", "mine", "cole", "Minoes", "colists", "mins", "Mins", " minues", "linues", "Minizes", "colites", "minsees", "minses", "Minus", " minizes", "minees", "milluses", "Minies", " minuses", "minists", "millizes", "tenes", "Minues", "rains", "colions", "linus", "Minis", "Mined", "Minions", "servis", "minues", "milles", "linions", "tenizes", "millees", "minse", "Minuses", "Minees", "lines", "coles", "minizes", "minsists", "minsus", " minists", "Minzes", "coled", "coleds", " minies", " minites", "minsizes", "mineds", "milloes", " mins", "milleds", "minations", "minoes", "millations", "minsions", " minions", "minzes", "minus", "Mines", "serveds", "minites", " mine", "minis", " mined", "colzes", "mills", "tenions", "rainites", "colies", " minzes", "Miners", "millers", "minuses", "minions", " mineds", "raines", "serves", "minsers", "servions", "minies", "mined", " minoes", "miners", " minus", "colations", "Minations", "Mineds", "raineds", "tenus", "millis"], "x": ["rx", "xe", "xx", "e", "v", "px", "index", "xb", "t", "n", "xi", "w", "xxx", "X", "ex", "h", " f", "xp", "python", "y", "xa", "xc", "hex", "dx", "xf", "xd", "d", "z", "wx", "xs", "f", "pair"], "self": ["parent", "game", "http", "per", "spec", "ck", "image", "private", "ws", "app", "m", "k", "resp", "layer", "instance", "bug", "ns", "object", "l", "n", "r", "connection", "plugin", "config", "p", "full", "util", "plus", "form", "ctx", "Self", "all", "cs", "user", "other", "q", "server", "event", "func", "group", "public", "type", "context", "host", "view", "mc", "d", "client", "f", "er", "data", "worker", "part", "e", "utils", "cache", "w", "this", "co", "me", "g", "conn", "h", "z", "wx", "cl", "work", "node", "github"], "counts": [" countows", "logries", "Counting", "maines", "colds", " countws", "countes", "mainws", " countfs", "Countments", "Counts", "lengthes", "hosts", "stats", "condfs", "Countories", "lengthd", "lengthries", "lengthqs", " countries", "conds", "colples", " countments", "colns", "condns", "logd", "coling", "countows", "colqs", "countories", "Countds", "Countls", "countries", "mains", " countstates", "Countws", " countories", "hostds", "loging", "hostls", "lengthstates", "countments", " countd", "colments", "Countes", "countws", "lengths", "coles", "loges", "mainories", "condes", "colstates", "countples", "Countows", "logs", "Countns", "countns", " countns", "states", "Countd", "countls", " countqs", "Countples", "logples", "lengthments", "countfs", "countd", "hostes", "Countries", "statows", "cold", "colls", "countds", "colries", "countstates", "lengthws", "Countfs", "colows", "counting", " countes", "countqs"], "_": ["all", "ip", "oc", "len", " p", " __", " time"], "mineCount": ["dimRef", "dustRef", "coreCount", "corecount", "dustCount", "dimSum", " mineSum", "mineLen", "dimLen", " minecount", "MineCounter", "dimCount", "dustSum", " mineRef", " mineCounter", "mineWeight", "MineWeight", "mineSum", "Minecount", "minecount", "MineCount", " mineLen", "coreWeight", " mineWeight", "mineRef", "dustLen", "mineCounter", "coreCounter"], "row": ["flow", "bug", "Row", "tab", "uc", "ack", "key", "index", "sel", "rr", "user", "chrom", "ro", "model", "day", "server", "ha", "month", "post", "r", "spec", "channel", "container", "feed", "thread", "group", "round", "co", "header", "div", "c", "batch", "coll", "head", "raw", "wheel", "mod", "rc", "ow", "win", "range", "column", "view", "con", "role", "roll", "block", "box", "um", "year", "entry", "error", "form", "node", "th", "port", "record"], "col": ["fact", "ail", "bug", "min", "tab", "uc", "key", "cat", "index", "sel", "patch", "child", "log", "cal", "lc", "core", "table", "act", "ca", "el", "Col", "ref", "co", "path", "collection", "c", "keep", "conn", "coll", "section", "cour", "kn", "rol", "ac", "cn", "file", "port", "win", "column", "fil", "il", "can", "con", "cm", "vc", "p", "ch", "block", "mot", "box", "COL", "year", "fc", "ol", "ct", "chain", "dir", "cor", "cy", "cl", "oy", "form", "f", "loc", "th", "char", "db", "icol"], "top": ["part", "Top", "id", "min", "hyp", "above", "px", "cat", "ap", "sp", "t", "th", "home", "icon", "up", "best", "this", "at", "path", "pt", "master", "bottom", "hop", "bit", "sum", "alpha", "lot", "tops", "hi", "max", "high", "tip", "lat", "left", "cover", "start", "middle", "meta", "py", "pop", "p", "sub", "client", "hot", "main", "first", "TOP", "op", "upper", "foo"], "mid": ["dom", "id", "part", "mr", "min", "pad", "mouse", "cat", "mad", "patch", "mi", "med", "man", "mer", "rand", "lim", "mm", "mill", "mob", "dem", "ms", "dim", "master", "bottom", "ng", "hi", "max", "high", "mind", "tip", "lat", "start", "alt", "middle", "nd", "meta", "py", "pop", "sub", "client", "md", "dm", "main", "mon", "Mid"], "bot": ["dom", "id", "bug", "pad", "min", "cat", "mad", "big", "log", "n", "home", "bo", "bad", "ball", "hide", "at", "round", "dem", "bots", "pt", "h", "master", "bit", "hat", "bottom", "kit", "hi", "lot", "high", "tip", "lat", "alt", "bat", "nd", "py", "long", "pop", "m", "b", "p", "plot", "domain", "mot", "last", "diff", "sub", "mini", "front", "main", "mon", "bin"]}}
{"code": " \n  FILE_NAME_BASE = 'A-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  def parseBoard(inp):\n  \trowSel, = (int(x) for x in inp.readline().split())\n  \tboard = tuple(\n  \t\ttuple(int(x) for x in inp.readline().split())\n  \t\tfor _ in xrange(4)\n  \t\t)\n  \treturn board, rowSel - 1\n  \n  def parse(inp):\n  \tbefore, beforeSel = parseBoard(inp)\n  \tafter, afterSel = parseBoard(inp)\n  \treturn before, beforeSel, after, afterSel\n  \n  def solve(before, beforeSel, after, afterSel):\n  \tcandidates = set(before[beforeSel]) & set(after[afterSel])\n  \n  \tif len(candidates) == 0:\n  \t\treturn \"Volunteer cheated!\"\n  \telif len(candidates) == 1:\n  \t\treturn candidates.pop()\n  \telse:\n  \t\treturn \"Bad magician!\"\n  \n  def main():\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\n  \n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\n  \tnumCases = int(inp.readline())\n  \tif NUM_PROCESSES == 0:\n  \t\tresults = [\n  \t\t\tsolve(*parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \telse:\n  \t\tpool = Pool(NUM_PROCESSES)\n  \t\tresults = [\n  \t\t\tpool.apply_async(solve, parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \tinp.close()\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\n  \tfor case, result in enumerate(results):\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n  \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n  \t\tout.flush()\n  \tout.close()\n  \n  if __name__ == '__main__':\n  \tmain()\n", "substitutes": {"FILE_NAME_BASE": ["FILE_NAME_DETA", "FILE_NAME_BEGIN", "FILE_NAME_BAME", "FILE_NAME_BIASE", "FILE_NAMEINGBASE", "FILE_NAMEINGABASED", "FILE_NAME_BEASE", "FILE_NAME_LAME", "FILE_NAME_OBASE", "FILE_NAME_BOUND", "FILE_NAME_BEAME", "FILE_NAME_ABASED", "FILE_NAME_ABAME", "FILE_NAME_DEGIN", "FILE_NAMEINGBOUND", "FILE_NAME_BEOUND", "FILE_NAMEINGBAME", "FILE_NAME_LASED", "FILE_NAME_BEETA", "FILE_NAME__BETA", "FILE_NAME__BASE", "FILE_NAME_BETA", "FILE_NAME_BIAME", "FILE_NAME_BEEGIN", "FILE_NAME_OBAME", "FILE_NAMEINGABAME", "FILE_NAME_LASE", "FILE_NAME_BASED", "FILE_NAME_BIATE", "FILE_NAME_ABOUND", "FILE_NAME_LOUND", "FILE_NAMEINGABASE", "FILE_NAME_BEASED", "FILE_NAMEINGBASED", "FILE_NAME__BEGIN", "FILE_NAME_OBATE", "FILE_NAME_DASE", "FILE_NAME_BATE", "FILE_NAMEINGABOUND", "FILE_NAME_ABASE"], "NUM_PROCESSES": ["NUM_PRECProcesses", "NUM_PRECProcessORS", "NUM_PROCECIONS", "NUM_PROCACTERS", "NUM_PROCESSERS", "NUM_PROCProcessORS", "NUM_PROGRESSERS", "NUM_PROCECTERS", "NUM_PROCITERS", "NUM_PROCESTORS", "NUM_PRECESSORS", "NUM_PROCITes", "NUM_PROCACTORS", "NUM_PRECESSERS", "NUM_PROCACTIONS", "NUM_PROCITORS", "NUM_PROGRECes", "NUM_PROCECES", "NUM_PROGRITORS", "NUM_PROCACTes", "NUM_PROCACTTS", "NUM_PROCECTES", "NUM_PRECProcessERS", "NUM_PROCESTERS", "NUM_PROCECes", "NUM_PROCESSIONS", "NUM_PROGRESSes", "NUM_PROGRECERS", "NUM_PRECACTTS", "NUM_PROGRECES", "NUM_PROCNECTIONS", "NUM_PROGRITES", "NUM_PROCECERS", "NUM_PROCNECTES", "NUM_PRECESSes", "NUM_PROCESTES", "NUM_PROCNECTes", "NUM_PRECESSTS", "NUM_PROCProcessERS", "NUM_PROGRESSIONS", "NUM_PRECACTES", "NUM_PROCProcessES", "NUM_PROGRITes", "NUM_PROCITES", "NUM_PROCECTes", "NUM_PROCECTTS", "NUM_PROCProcesses", "NUM_PROCESSes", "NUM_PROGRESSORS", "NUM_PROCESSORS", "NUM_PROCNECTORS", "NUM_PROGRITIONS", "NUM_PRECACTERS", "NUM_PRECACTes", "NUM_PROCESTes", "NUM_PROGRESSES", "NUM_PROCESSTS", "NUM_PROGRECIONS", "NUM_PROCESTTS", "NUM_PROCACTES", "NUM_PRECESSES", "NUM_PROCITIONS", "NUM_PRECProcessES"], "MEM_LIMIT_GB": ["MEM_LIMIT_US", "MEM_LIMIT2GA", "MEM_LIMITEDECGB", "MEM_LIMITECGB", "MEM_LIMIT_MB", "MEM_LIMITEDECG", "MEM_LIMITE_US", "MEM_LIMIT_SI", "MEM_LIMITECGA", "MEM_LIMIT_GA", "MEM_LIMITED_G", "MEM_LIMITEDECGA", "MEM_LIMITEDECMB", "MEM_LIMIT2GB", "MEM_LIMITECG", "MEM_LIMITECMB", "MEM_LIMIT2G", "MEM_LIMITED_MB", "MEM_LIMITE_GB", "MEM_LIMIT_G", "MEM_LIMITE_MB", "MEM_LIMITE_SI", "MEM_LIMITED_GB", "MEM_LIMITED_GA", "MEM_LIMIT2MB"], "RECURSION_LIMIT": ["RECURSION_LIGIN", "RECURSION_LENGTHITE", "RECURSION_CLIMITED", "RECURSION_Limit", "RECURSION_LIGIT", "RECURSION_CLIMITE", "RECURSION_LIGit", "RECURSION_LIMIN", "RECURSION_LIGITED", "RECURSION_LENGTHIN", "RECURSION_LimITE", "RECURSION_LOCit", "RECURSION_LimIN", "RECURSION_LIGITE", "RECURSION_CLIGITED", "RECURSION_CLIGIN", "RECURSION_CLIMIT", "RECURSION_LENGTHIT", "RECURSION_CLIMTE", "RECURSION_LIMTE", "RECURSION_LENGTHITED", "RECURSION_LOCIT", "RECURSION_LimIT", "RECURSION_CLIGTE", "RECURSION_LIMITED", "RECURSION_LIMit", "RECURSION_LimITED", "RECURSION_CLIMIN", "RECURSION_LIGTE", "RECURSION_CLIGITE", "RECURSION_CLIGit", "RECURSION_CLIGIT", "RECURSION_CLIMit", "RECURSION_LOCITED", "RECURSION_LIMITE", "RECURSION_LOCTE", "RECURSION_LimTE"], "inp": ["winf", "inng", "innp", "kinping", "INc", " inj", "zincp", "zinpi", "arinl", "infp", "INf", "winp", "kinl", "inspe", "insps", "inlp", "ninpo", " inh", "arinp", "innpc", "inb", "inping", "inpl", "insg", "INps", "insl", "inslp", "arinps", "winpc", "kinP", " inf", "idl", "insb", "INl", "Inc", "inccp", "zinp", "kinp", "insc", "innpe", " inpc", "INcp", "inf", "inpo", "ninf", "incc", "inspl", "Inp", "incb", "insP", "arincp", "innpo", "idb", "Inj", "innfp", "insping", "INb", "arinP", "innl", "Inl", "inscp", "inq", "incp", "Inb", "INh", "idc", "ing", "inipl", " inb", "inps", "idp", "ninp", "incpc", "inspi", " incp", "idq", "inh", "inP", "inpi", "inspo", "innq", "inipe", "iniv", "innf", "Inf", "idpc", "inpc", "inc", "ninb", "exb", "inl", "zinlp", "INp", "arinc", "arinping", "innv", "innpl", "Incp", "Inh", "idg", "insp", "innb", "insf", "exc", "inip", " inl", "inv", " infp", "inpe", "winfp", " inc", "inclp", "insv", "inj", "incpi", "insq", "exj", "exp"], "rowSel": ["pageSn", " rowSl", "rowSl", "pageSel", "pageSe", "RowSe", "rowSe", " rowSn", "rowLen", "RowSel", "pageEl", "cellLen", "RowLen", "cellSl", " rowEl", " rowSe", " rowLen", "rowsel", "RowSn", "rowEl", "RowSl", "Rowsel", "rowSn", "RowEl", "cellSel", " rowsel", "cellsel"], "x": ["id", "rx", "xe", "xx", "v", "e", "index", "px", "xb", "l", "t", "xy", "n", "q", "xi", "xxxx", "w", "fx", "xxx", "width", "X", "c", "ex", "i", "h", "ww", "ux", "xp", "y", "row", "num", "xc", "m", "u", "hex", "b", "p", "xf", "z", "ix", "ax", "int", "wx", "xs", "k", "data", "f", "ctx", "number"], "board": ["flow", "game", "bug", "deck", "uc", "object", "lane", "array", "control", "card", "home", "bo", "channel", "image", "co", "flo", "Board", "batch", "window", "list", "coll", "head", "row", "buffer", "split", "view", "sequence", "layout", "block", "box", "boarding", "line", "boards", "entry", "fc", "form", "video", "word"], "_": ["___", "all", " un", " the", " over", " sub", "un", "ing", "g", "s", "c", " non", "m", "non", "d", " time", "__", " new", "f", " block", " local", "ac", " mem", "U"], "before": ["inside", "both", "above", "like", "patch", "kick", "child", "end", "local", "right", "package", "post", "around", "then", "private", "window", "self", "info", "head", "below", "start", "range", "view", "prev", "current", "ant", "between", "Before", "last", "length", "false", "new", "auto", "back", "now", "front", "next", "first", "form", "plus", "without", "off", "pre"], "beforeSel": ["beforeSol", "betweenSel", "BeforeSl", "prevSol", "beforeEl", "afterSl", "BeforeEl", "betweenSol", "headEl", "afterSe", " beforeSe", "beforesel", "prevsel", "BeforeSe", " beforeSl", "prevSel", "betweensel", "afterSol", "viewSe", "viewSl", "aftersel", "afterEl", "headSel", "prevEl", "viewsel", " beforesel", " beforeEl", "viewSel", "headSe", "headsel", "BeforeSel", "beforeSl", "beforeSe", "betweenEl"], "after": ["all", "until", "above", "integer", "like", "other", "end", "final", "output", "right", "up", "complete", "around", "post", "follow", "only", "o", "on", "at", "update", "progress", "active", "below", "during", "over", "left", "middle", "later", "current", "between", "p", "when", "last", "outside", "auto", "full", "next", "After", "off", "pre"], "afterSel": ["offsel", "endSel", "endEll", "beforeEl", "afterSl", "endSl", "beforeEdit", "offEl", " afterSl", " aftersel", "afterSe", "AfterSe", "beforesel", " afterSe", "aboveSe", "AfterSel", "afterEdit", "beforeEll", "offSel", "afterEl", "aftersel", "aboveEdit", "AfterEl", "AfterSl", "endEl", " afterEl", "afterEll", "AfterEdit", "aboveEl", " afterEll", "beforeSl", "beforeSe", "offSe", "aboveSel"], "candidates": ["charests", " Candidates", "Candies", "Candests", "charles", " candidate", "homidate", "Candles", " candidation", "centidates", "centies", "Candidates", " candcakes", "candournaments", "charidate", "candidate", " Candidate", "predidate", " Candles", "potickets", "candies", "homidates", " candickets", "Candournaments", " candournaments", "candests", "charidates", "Candidation", "candles", "potidate", "candidation", "centles", "predidates", "Candickets", "potournaments", "predests", "potidates", "Candidate", "Candcakes", "homcakes", "predles", " Candies", "candickets", "homidation", "centidate", "candcakes"], "soft": ["sea", "us", "user", "local", "server", "mm", "net", "virtual", "allow", "percent", "normal", "bit", "gross", "use", "protected", "forced", "speed", "large", "free", "cost", "force", "system", "Soft", "smart", "used", "weight", "char"], "hard": ["press", "remote", "external", "tight", "easy", "direct", "low", "core", "act", "dr", "virtual", "old", "active", "raw", "limit", "protected", "high", "forced", "win", "large", "rest", "custom", "clear", "con", "base", "strong", "windows", "reset", "deep", "Hard", "full", "int", "force", "client", "weak", "work", "weight", "bound", "live", "ht"], "numCases": ["ncances", "numLades", "numberBasing", "numAcands", "numcases", "nCakes", "nCances", " numChases", "numBands", "numCodes", "numChalls", "numBodes", "numAcodes", "numLalls", "numChades", " numChades", "numCalls", "numFases", "numberCodes", "numFades", "numAcasing", " numCalls", "numPances", "numConances", "numPakes", "numChodes", "numFodes", "numberBands", "nCases", "numcances", "numCakes", "numberBases", "numConakes", "numCances", " numChalls", "numberCases", "ncases", "ncakes", "nCatches", " numCodes", "numNodes", "numCasing", "numLodes", "numberCands", "numChases", " numChodes", "numAcases", "numNands", "numFalls", "numberBodes", "numberCasing", "numBasing", "numNasing", "ncatches", "numcatches", "numNases", " numCades", "numPases", "numCatches", "numLases", "numBases", "numCands", "numConatches", "numcakes", "numCades", "numPatches", "numConases"], "results": ["successful", "blocks", "RESULTS", "members", "groups", "res", "outs", " Results", "models", "changes", "games", "output", "features", "reads", "grades", "complete", "performance", "settings", "locks", "words", "versions", "gets", "ips", "values", "resources", "tests", "allows", "runs", "stats", "rows", "measures", "forms", "items", "details", "works", "events", "includes", "rules", "response", "Results", "reports", "errors", "vals", "projects", "helps", "views", "maps"], "pool": ["flow", "parent", "rain", "res", "timeout", "child", "cache", "net", "container", "thread", "group", "round", "collection", "Pool", "conn", "batch", "list", "sum", "loop", "max", "lock", "app", "can", "con", "process", "hole", "p", "queue", "call", "box", "block", "resource", "client", "chain", "wa", "graph", "wrapper", "port"], "out": ["prefix", "part", "OUT", "err", "key", "timeout", "outs", "user", "default", "report", "log", "output", "writer", "w", "image", "group", "match", "conn", "connection", "ex", "Out", "sum", "exec", "outer", "name", "size", "file", "sync", "lock", "again", "inner", "write", "extra", "session", "call", "diff", "line", "full", "client", "error", "doc", "obj", "comment", "work", "io", "bin", "temp", "exp", "word"], "case": ["instance", "nce", "bug", "sea", "key", "rule", "cer", "code", "change", "default", "patch", "slice", "address", "trial", "time", "ace", "ce", "catch", "core", "chance", "shape", "match", "ice", "mode", "type", "section", "use", "config", "switch", "ance", "choice", "length", "division", "client", "Case", "ase", "cases", "age", "example", "test"], "result": ["root", "err", "res", "draw", "default", "Result", "report", "user", "array", "end", "success", "output", "event", "r", "group", "round", "match", "description", "dict", "date", "list", "section", "sum", "counter", "outer", "val", "row", "item", "ser", "method", "search", "function", "ver", "df", "block", "response", "entry", "resource", "error", "back", "rate", "runner", "comment", "data", "number", "pair", "page", "test"], "value": ["instance", "id", "feature", "valid", "Value", "v", "version", "key", "index", "VALUE", "default", "end", "count", "trial", "json", "type", "section", "name", "values", "val", "size", "position", "unit", "total", "item", "num", "message", "memory", "current", "null", "response", "length", "comment", "content", "data", "example", "number", "weight", "test"]}}
{"code": "T = int(raw_input().strip())\n  misses = set()\n  \n  for i in xrange(T):\n  \tR, C, M = map(int, raw_input().strip().split(' '))\n  \tF = R * C - M\n  \timpossible = False\n  \tif F == 1:\n  \t\tmatrix = [\"c\" + \"*\" * (C - 1)]\n  \t\tfor _ in xrange(R - 1):\n  \t\t\tmatrix.append(\"*\" * C)\n  \telif R == 1:\n  \t\tmatrix = [\"c\" + \".\" * (F - 1) + \"*\" * (C - F)]\n  \telif C == 1:\n  \t\tmatrix = [\"c\"]\n  \t\tfor _ in xrange(F - 1):\n  \t\t\tmatrix.append(\".\")\n  \t\tfor _ in xrange(R - F):\n  \t\t\tmatrix.append(\"*\")\n  \telif R == 2:\n  \t\tif F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):\n  \t\t\tmatrix = [\n  \t\t\t\t\"c\" + \".\" * (F / 2 - 1) + \"*\" * (C - F / 2),\t\n  \t\t\t\t\".\" * (F / 2) + \"*\" * (C - F / 2)\n  \t\t\t]\n  \t\telse:\n  \t\t\tmatrix = []\n  \t\t\timpossible = True\n  \telse:\n  \t\tstack = []\n  \t\tmatrix = []\n  \t\tfor j in xrange(C, 1, -1):\n  \t\t\tif F - 2 * j >= 0 and (R - 2) * j >= F - 2 * j:\n  \t\t\t\tstack.append([j, j])\n  \n  \t\twhile stack:\n  \t\t\telems = stack.pop()\n  \t\t\tse = sum(elems)\n  \t\t\tif se == F:\n  \t\t\t\tfor count in elems:\n  \t\t\t\t\tmatrix.append(\".\" * count + \"*\" * (C - count))\n  \t\t\t\tfor _ in xrange(R - len(elems)):\n  \t\t\t\t\tmatrix.append(\"*\" * C)\n  \t\t\t\tmatrix[0] = \"c\" + matrix[0][1:]\n  \t\t\t\tbreak\n  \t\t\telif len(elems) < R:\n  \t\t\t\tfor j in xrange(elems[-1], 1, -1):\n  \t\t\t\t\tif F - se - j >= 0 and (R - len(elems)) * j >= F - se:\n  \t\t\t\t\t\tstack.append(elems[::] + [j])\n  \n  \t\tif matrix == []:\n  \t\t\timpossible =True\n  \n  \tprint \"Case #%s:\" % (i + 1)\n  \tif impossible:\n  \t\tprint \"Impossible\"\n  \telse:\n  \t\tfor row in matrix:\n  \t\t\tprint row\n", "substitutes": {"T": ["N", "Y", "Total", "TN", "t", "P", "TF", "TS", "U", "E", "H", "W", "X", "Time", "TC", "NT", "Q", "I", "B", "TA", "D", "O", "S", "TT", "Z", "TB", "L", "V"], "misses": ["missits", "maned", "liced", "manages", "lices", "manits", "processed", "manes", "missed", "missages", "licits", "processages", "licages", "processes", "processits"], "i": ["id", "N", "ii", "all", "im", "ip", "n", "ind", "J", "r", "col", "g", "c", "ti", "h", "gi", "I", " I", "D", "iq", "p", "d", "z", "int", "cor"], "R": ["Rh", "N", "Y", "Rs", "Range", "P", "n", "MR", "J", "CR", "RH", "Re", "RT", "r", "JR", "E", "G", "H", "SR", "RM", "W", "RO", "RF", "K", "X", "Right", "RW", "Q", "RS", "BR", "I", "B", "D", "RC", "RG", "O", "S", "RR", "V", "NR", "A", "L", "U", "RA"], "C": ["N", "Y", "Cor", "CNN", "AC", "Cs", "P", "DC", "CM", "Cl", "CR", "J", "CF", "r", "E", "G", "H", "Size", "CE", "W", "COR", "YC", "K", "X", "c", "Co", "CA", "CV", "CO", "CC", "Q", "I", "B", "Cu", "D", "CI", "Cr", "Ch", "O", "CT", "S", "CL", "EC", "MC", "V", "Count", "CU", "A", "L", "U"], "M": ["N", "Y", "FM", "P", "MS", "CM", "CR", "U", "E", "G", "H", "RM", "W", "DM", "X", "Q", "I", "B", "MF", "D", "MM", "m", "O", "S", "Z", "MN", "MC", "A", "L", "V"], "F": ["N", "Y", "Fine", "FD", "FO", "OF", "FH", "FM", "P", "All", "J", "Full", "FC", "CF", "U", "E", "FG", "G", "H", "FE", "Fi", "BF", "W", "RF", "K", "X", "File", "GF", "Q", "SF", "I", "B", "L", "Fl", "DF", "D", "O", "S", "Z", "Fixed", "FR", "EF", "FS", "FB", "IF", "FF", "Fa", "FL", "AF", "PF", "Inf", "f", "IO", "Family", "A", "Fs", "V", "Far"], "impossible": ["Impective", " impure", "compossibility", "impossibly", "ispossible", "compurity", "impective", "greatossible", "ispure", "impossibility", "ispective", "impure", " impective", "greatossibility", "ispossibility", "Impure", "impurity", "greatossibly", "ispossibly", "ispurity", "compossibly", "Impossibility", "compossible", "Impossible", "greaturity", " impossibility"], "matrix": ["tplex", "MATfix", "morturi", "trix", " matplex", " matrow", "matrics", "latMatrix", "macrix", "metric", "matux", " matrices", "latx", "matogram", "mathric", "mride", "macress", "mathux", "atMatrix", "atrics", "molress", "molrices", "mathribution", "atric", "atri", "rubrix", "scheri", "metrix", "mmrix", "rubvector", "attric", "Matrices", "attral", " matux", "matrice", "MATrices", "rubplex", "atuster", "rubrices", " matride", "macric", "matribution", "matri", "mathrices", "matfix", "matvector", "mathrix", "atplex", " matrics", "matensor", "attrices", "latrix", "Matrix", "macrices", "scherix", "matment", "latrice", "matx", "mrix", "Matride", " matuster", "metment", " matract", "tric", " matfix", " matric", "matric", " matress", "mathensor", "matride", "mortrix", " maturi", "matral", "Matfix", "atrices", "matract", " matri", "Matment", " matx", "molric", "mmrice", "Matric", " matribution", "metrics", "scheuster", "latrices", " matogram", "matrow", "mfix", "tensor", "tvector", " matensor", "Matogram", "mortric", "atract", "maturi", "scherices", "atrow", "latfix", "mmric", "mathuri", " matral", " matMatrix", "mathral", "trices", "matplex", "attribution", "molrix", "mrices", "mortux", "metogram", "latvector", " matment", "mmrices", "attrix", "atrix", "matress", "matuster", "matrices", "metract", "MATx", "matMatrix", "attrice", "latplex", "metrow", "latric", "metrices", "MATrix"], "_": ["x", "A", "___", "all", "ip", "l", "n", " un", "q", "up", "place", "o", "ing", "g", "s", "val", "out", "of", "u", "non", "p", "d", "__", "a", "k", "al", "ac", "lex", "U"], "j": ["ji", "x", "v", "e", "ii", "fr", "index", "sp", "l", "br", "n", "t", "dj", "ind", "q", "J", "jj", "r", "li", "jc", "el", "o", "js", "g", "c", "h", "ie", "sh", "seq", "jp", "fl", "y", "jl", "si", "num", "je", "py", "adj", "jo", "m", "b", "p", "jet", "ch", "d", "aj", "z", "pos", "uj", "note", "int", "ij", "ja", "k", "f", "pr"], "elems": ["oleks", "Elems", "lemns", " eleks", "elelems", "lemms", "Eleks", "elens", "lems", "lements", " elec", "ellems", " elemes", "elks", "elc", "eleks", "elms", "elec", "olements", "olem", " elens", "elements", "elm", "elns", "lemks", "lemlems", "olemes", "elmes", "lemments", " elelems", "Elem", " elem", "Elec", "elemes", "lem", "lemm", "Elemes", "lemmes", "lemes", "elem", "Elens", "olems", "elments"], "se": ["est", "sea", "e", "fr", "sy", "ze", "sa", "parse", "sp", "sel", " SE", "sle", "sec", "pse", "ce", "su", "SE", "ve", "ae", "me", "fe", "ge", "ie", "see", "pe", "sh", "sq", "sum", "ke", "ses", "use", "nt", "si", "size", " Se", "le", "nd", "ser", "ci", "sem", "Se", "ss", "arse", "sd", "ose", "ch", "ee", "length", "ne", "sed", "ase", "de", "th", "sl", "be"], "count": ["id", "e", "key", "cat", "index", "code", "l", "child", "n", "th", "ind", "core", "q", "cache", "li", "col", "c", "ge", "len", "see", "list", "coll", "sum", "seq", "depth", "nt", "size", "cycle", "max", "mass", "cf", "num", "start", "ph", "base", "p", "ch", "last", "z", "length", "cur", "ct", "cc", "Count", "f", "number", "loc", "weight"]}}
{"code": "T = int(raw_input().strip())\n  \n  for j in xrange(T):\n  \trow_num1 = int(raw_input().strip())\n  \tfor i in xrange(4):\n  \t\tif i + 1 == row_num1:\n  \t\t\trow1 = set(map(int, raw_input().strip().split(' ')))\n  \t\telse:\n  \t\t\traw_input()\n  \trow_num2 = int(raw_input().strip())\n  \tfor i in xrange(4):\n  \t\tif i + 1 == row_num2:\n  \t\t\trow2 = set(map(int, raw_input().strip().split(' ')))\n  \t\telse:\n  \t\t\traw_input()\n  \tcommon = row1 & row2\n  \tlc = len(common)\n  \tif lc == 1:\n  \t\tstuff = list(common)[0]\n  \telif lc > 1:\n  \t\tstuff = \"Bad magician!\"\n  \telse:\n  \t\tstuff = \"Volunteer cheated!\"\n  \n  \tprint \"Case #%s: %s\" % (j + 1, stuff)\n", "substitutes": {"T": ["N", "Y", "TN", "t", "P", "TI", "E", "H", "HI", "W", "X", "Time", "R", "TC", "TW", "NT", "TM", "I", "B", "num", "TA", "F", "O", "S", "TT", "Z", "C", "TB", "M", "L", "V"], "j": ["ji", "ii", "e", "im", "ip", "l", "t", "n", "q", "time", "J", "jj", "xi", "jit", "li", "jc", "o", "g", "c", "ie", "jump", "jp", "kj", "y", "jl", "I", "adj", "jo", "u", "ib", "m", "ai", "b", "p", "d", "ch", "z", "note", "bj", "obj", "ij", "k", "f", "uj"], "row_num1": ["row_no1", "row1num1", "row_Num1", "row_sum1", "row_dim0", "row_no0", "row_Num3", "row_Num2", "row1dim2", "row_num3", "row_sum3", "row_sum2", "row_no2", "row_dimOne", "row_sumOne", "row_num0", "row1num3", "row_numOne", "row1num0", "row_NumOne", "row1num2", "row_no3", "row_dim2", "row1dim1", "row1dim0", "row_dim1", "row_sum0", "row1dim3", "row_dim3"], "i": ["x", "id", "ui", "ii", "e", "v", "im", "ip", "l", "t", "n", "phi", "ei", "ind", "xi", "yi", "iu", "li", "it", "c", "ti", "ie", "qi", "hi", "si", "y", "oi", "I", "ori", "ni", "ci", "ini", "u", "ib", "ai", "b", "p", "d", "z", "pi", "isi", "int", "di", "zi", "k", "f", "io"], "row_num2": ["row_norm1", "row2no4", "row_norm52", "row_num52", "row_Num1", "row_sum1", "row_norm2", "row_Num3", "row2no2", "row_Num2", "row_num3", "row_numII", "row2num4", "row2noII", "row2no3", "row_sum2", "row_no4", "row_no2", "row_num0", "row2num3", "row_Num4", "row_num4", "row_no3", "row_norm0", "row_dim2", "row2num2", "row2numII", "row_dimII", "row_Num52", "row_Num0", "row_NumII", "row_noII", "row_sum52", "row_sum0", "row_dim4", "row_dim3"], "common": ["Common", "all", "multi", "generic", "conference", "specific", "local", "other", "low", "server", "compatible", "complex", "known", "basic", "standard", "public", "normal", "special", "simple", "name", "similar", "general", "custom", "unique", "con", "base", "null", "extra", "non", "diff", "seen", "misc", "flat", "same", "data", "central", "company", "media", "none", "shared", "union"], "lc": ["dl", "pc", "nc", "uci", "la", "lt", "cs", "l", "cli", "n", "sec", "lu", "li", "lr", "ll", "wl", "c", "len", "lic", "sc", "list", "coll", "rc", "LC", "tc", "sync", "nt", "lv", "oi", "lp", "lvl", "ci", "usc", "LR", "lf", "ln", "lb", "lib", "lict", "ls", "fc", "kl", "icc", "lam", "cl", "ly", "loc", "LT"], "stuff": ["know", "part", "bug", "wow", "nothing", "what", "sorry", "string", "like", "kick", "something", "fortune", "eddy", "www", " Stuff", "kk", "just", "field", "yeah", "hack", "kind", "place", "space", "standard", "mmm", "cheat", "type", "ie", "info", "thing", "name", "maybe", "say", "tmp", "start", "food", "pretty", "style", "shit", " shit", "things", "luck", "ticket", "concept", "question", "cause", "strip", "feat", "obj", "notice", "comment", "now", "front", "sex", "case", "rank", "company", "test"]}}
{"code": " \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  def count(z, r, c):\n      return len(z_and_nei(z,r,c))\n  \n  def nei(z, r, c):\n      s = z_and_nei(z, r, c)\n      s -= set(z)\n      return s\n  \n  def z_and_nei(z, r, c):\n      s = set()\n      for x in z:\n          s.add(x)\n          s.add((x[0]-1,x[1]-1))\n          s.add((x[0]-1,x[1]))\n          s.add((x[0]-1,x[1]+1))\n          s.add((x[0],x[1]-1))\n          s.add((x[0],x[1]+1))\n          s.add((x[0]+1,x[1]-1))\n          s.add((x[0]+1,x[1]))\n          s.add((x[0]+1,x[1]+1))\n      o = set()\n      for x in s:\n          if x[0] < 0 or x[0] > r-1 or x[1] < 0 or x[1] > c-1:\n              o.add(x)\n      s-=o\n      return s\n  \n  def find_config(z, r, c, t):\n      if count(z,r,c) == t:\n          return z\n      if count(z,r,c) > t:\n          return []\n      n = nei(z,r,c)\n      for x in n:\n          z.append(x)\n          if find_config(z,r,c,t) != []:\n              return z\n          z.pop()\n      return []\n  \n  for i in range(num):\n      print 'Case #{}:'.format(i+1)\n      r, c, m = [int(x) for x in f.readline().split()]\n      if r*c-m == 1:\n          print 'c' + '*'*(c-1)\n          for i in range(r-1):\n              print '*'*c\n      else:\n          z = find_config([(0,0)], c, r, c*r-m)\n          if z == []:\n              print \"Impossible\"\n          else:\n              s = z_and_nei(z, c, r)\n              for j in range(r):\n                  for k in range(c):\n                      if j == 0 and k == 0:\n                          print 'c',\n                      elif (k,j) in s:\n                          print '.',\n                      else:\n                          print '*',\n                  print\n  \n  \n", "substitutes": {"f": ["e", "fr", "v", "fast", "l", "fo", "tf", "af", "stream", "w", "fd", "fx", "feed", "ref", "g", "h", "info", "conf", "proc", "file", "y", "arf", "F", "handler", "fp", "b", "fs", "p", "fb", "d", "df", "ch", "fc", "ft", "form", "io"], "num": ["fn", "nc", "multi", "np", "no", "count", "ctr", "na", "nb", "w", "cu", "Num", "col", "g", "uni", "sn", "len", "h", "en", "sum", "om", "name", "total", "size", "max", "con", "u", "cm", "norm", "b", "p", "nu", "um", "NUM", "iter", "number", "loc", "bin", "temp", "inc"], "z": ["zn", "za", "bug", "e", "v", "all", "ze", "like", "l", "code", "zen", "q", "count", "ce", "zz", "w", "ld", "g", "zo", "one", "zh", "zone", "h", "fl", "y", "az", "config", "zip", "zl", "ez", "gz", "u", "iz", "zer", "zy", "tz", "b", "Z", "p", "d", "ed", "wa", "a", "zi", "cz", "cl", "er", "nz", " Z"], "r": ["v", "e", "fr", "rr", "err", "yr", "rf", "l", "ru", "br", "q", "w", "dr", "rh", "lr", "rec", "g", "cr", "h", "R", "ir", "ar", "nr", "rc", "y", "nor", "sr", "range", "pr", "ur", "hr", "rb", "u", "rs", "tr", "b", "p", "d", "C", "a", "re", "er", "rn"], "c": ["v", "e", "uc", "pc", "nc", "cs", "l", "dc", "cin", "count", "lc", "q", "ca", "ce", "w", "cu", "cr", "g", "h", "sc", "rc", "cn", "y", "cf", "ci", "con", "u", "cm", "b", "p", "C", "d", "ch", "ct", "a", "cc", "cy", "cl", "cell", "ac"], "s": ["v", "sys", "vs", "south", "ends", "options", "ies", "sets", "sb", "sites", "ws", "size", "gs", "events", "xs", "ks", "ps", "ns", "groups", "sa", "l", "ys", "su", "site", "sym", "os", "sn", "its", "set", "ves", "sc", "sh", "ips", "qs", "rows", "p", "lines", "a", "ts", "ments", "times", "multi", "cs", "ds", "js", "ing", "opens", "y", "an", "u", "so", "rs", "sv", "b", "d", "states", "sg", "ls", "er", "ions", "ssl", "e", "us", "ans", "w", "uns", "status", "posts", "g", "services", "h", "users", "sum", "ses", "sync", "si", "strings", "ss", "S", "fs", "ed", "es", "sl"], "x": ["opt", "id", "v", "ux", "alpha", "xc", "ph", "go", "ax", "sex", "xs", "case", " X", "rx", "l", "xy", "time", "zx", "xxx", "one", "X", "xml", "self", "ex", "xp", "config", "xt", "ext", "hex", "xf", "p", "ix", "wa", "check", "ct", "a", "_", "rex", "index", "xb", "px", "code", "q", "xi", "na", "event", "any", "on", "pe", "sw", "python", "y", "view", "ci", "u", "dx", "b", "cross", "d", "data", "xx", "e", "tx", "fx", "w", "co", "g", "h", "xes", "ww", "ic", "int", "wx", "cl", "work", "loc", "lex", "exp"], "o": ["e", "v", "oa", "l", "no", "ro", "other", "bo", "os", "w", "ou", "ob", "on", "g", "h", "y", "oo", "ot", "out", "u", "O", "so", "b", "p", "oe", "do", "d", "yo", "io", "op", "off"], "t": ["v", "e", "T", "l", "time", "q", "tf", "it", "tt", "at", " T", "g", "pt", "type", "h", "nt", "tc", "total", "ta", "y", "ot", "out", "dt", "u", "tr", "tz", "tp", "p", "b", "d", "tm", "int", "a", "ts"], "n": ["N", "all", "e", "v", "ns", "nc", "cs", "l", "q", "nb", "w", "net", "g", "sn", "en", "nt", "y", "ot", "ni", "con", "nn", "b", "p", "d", "ne", "a", "ct"], "i": ["id", "ii", "e", "v", "ri", "index", "im", "ip", "multi", "l", "slice", "phi", "ind", "q", "xi", "iu", "li", "ti", "ie", "h", "gi", "qi", "y", "ih", "si", "I", "eni", "uri", "ci", "ini", "iq", "u", "ai", "b", "p", "ix", "pi", "int", "di", "io", "ui"], "m": ["v", "e", "l", "mi", "q", "mm", "w", "g", "ms", "h", "y", "range", "u", "cm", "mc", "b", "p", "d", "C", "um", "a", "mini", "M"]}}
{"code": " \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      q1 = int(f.readline())\n      for j in range(4):\n          if j+1 == q1:\n              line1 = f.readline()\n          else:\n              f.readline()\n      q2 = int(f.readline())\n      for j in range(4):\n          if j+1 == q2:\n              line2 = f.readline()\n          else:\n              f.readline()\n      line1 = [int(x) for x in line1.split()]\n      line2 = [int(x) for x in line2.split()]\n      count = 0\n      for x in line1:\n          if x in line2:\n              count += 1\n              y = x\n      if count == 0:\n          print 'Case #{}: Volunteer cheated!'.format(i+1)\n      elif count == 1:\n          print 'Case #{}: {}'.format(i+1, y)\n      else:\n          print 'Case #{}: Bad magician!'.format(i+1)\n", "substitutes": {"f": ["fn", "e", "fr", "v", "ff", "fast", "rf", "l", "t", "fo", "tf", "fa", "af", "r", "w", "fd", "fx", "feed", "o", "bf", "g", "c", "s", "h", "conf", "inf", "file", "fw", "F", "handler", "of", "fm", "fp", "m", "function", "lf", "b", "p", "fs", "fb", "d", "df", "z", "fc", "full", "form", "api", "io", "sf", "fu"], "num": ["id", "min", "index", "multi", "np", "no", "n", "end", "cal", "nb", "lim", "Num", "coord", "col", "uni", "div", "c", "init", "dim", "en", "sum", "name", "size", "max", "unit", "ul", "split", "con", "m", "b", "nu", "NUM", "um", "number", "loc", "inc"], "i": ["id", "ii", "v", "e", "sup", "key", "index", "im", "ip", "l", "bi", "n", "slice", "ind", "iu", "r", "li", "c", "ie", "qi", "type", "info", "gi", "si", "I", "uri", "ci", "iq", "u", "m", "ai", "b", "p", "z", "ix", "pi", "isi", "int", "a", "mini", "k", "zi", "io", "ui"], "q1": ["qone", "q13", "pone", "Q2", " qone", "qN", " q13", "Q1", "p2", "pN", "v2", " q11", "query13", "v11", "v1", "Qone", " qN", "query1", "query2", "query11", "QN", "p1", "q11", "v13"], "j": ["ji", "v", "e", " n", "je", "l", "dj", "n", "q", "J", "jj", "r", "jc", "o", "on", "g", "c", "h", "jp", "jam", "jl", "job", "jo", "m", "b", "p", "d", "aj", "z", "ax", "bj", "ja", "ij", "k", "_", "uj"], "line1": ["lin2", "styleOne", "qone", " lineOne", "Line4", "linone", "styleHead", "style1", "lin3", "lin4", " line0", "lineone", "l2", "block0", "line3", "LineHead", "qOne", "line0", "caseHead", "caseOne", "block2", "lineOne", "LineOne", "lin0", "lin1", "Line3", "line4", "l1", "Line2", "block1", "Lineone", " lineone", "Line1", "lineHead", "linOne", "l3", "l4", "caseone", "case1", "blockone", "styleone"], "q2": ["qII", "qu12", "question82", "quest2", "q12", "qtwo", "question2", " q20", "ftwo", "qu02", "question02", "qu82", " q82", " qII", "qu2", "questtwo", "fII", "q82", " q02", " q12", "f20", "questII", "question12", "q02", "q20", " qtwo", "quest20", "f2"], "line2": ["lin2", " linetwo", "page0", "lines0", "ine2", "page1", " line02", "pagetwo", " line4", "Line0", "lane4", "lin4", "linetwo", " line0", "linesecond", "l2", "lines1", "Linetwo", " linesecond", "inesecond", "ine4", "linsecond", "line02", "ine02", "lane2", "lin02", "line0", "lintwo", "lane1", "lanetwo", "line4", "l1", "Line2", "page2", "lin0", "lin1", "linestwo", "Line1", "lines2", "l4", "ltwo"], "x": ["rx", "id", "e", "xx", "v", "Y", "index", "im", "px", "code", "t", "l", "n", "xy", "q", "time", "xi", "event", "w", "on", "width", "oint", "X", "c", "s", "ex", "h", "xes", "ux", "name", "mass", "point", "ci", "xc", "xt", "m", "ph", "yx", "u", "sex", "b", "p", "xf", "cross", "d", "z", "ix", "ax", "int", "check", "xs", "k", "_", "work", "number", "loc", "plus", "lex", "content"], "count": ["id", "part", "key", "index", "code", "l", "no", "n", "child", "q", "time", "ind", "catch", "nb", "label", "col", "offset", "match", "c", "type", "list", "len", "coll", "sum", "counter", "depth", "nt", "size", "total", "start", "base", "found", "call", "p", "span", "z", "length", "line", "note", "check", "cc", "Count", "number", "weight", "test"], "y": ["Y", "xx", "sy", "l", "xy", "n", "q", "vy", " Y", "yi", "ay", "col", "yy", "c", "type", "ya", "yl", "py", "b", "p", "ch", "z", "fy", "year", "dy", "cy", "yo", "oy"]}}
{"code": " \n  def check_bounds(state, coord):\n      if coord[0] < 0 or coord[1] < 0:\n          return False\n      elif coord[0] > (len(state) - 1):\n          return False\n      elif coord[1] > (len(state[coord[0]]) - 1):\n          return False\n      else:\n          return True\n  \n  def clear(state, coord):\n      for r in range(-1,2):\n          for c in range(-1,2):\n              row = coord[0] + r\n              col = coord[1] + c\n              if check_bounds(state, (row, col)):\n                  state[row][col] = 0\n  \n  def count(state):\n      return sum([sum(x) for x in state])\n  \n  def state_print(state):\n      print(\"c\" + \"\".join([\"*\"  if x else \".\" for x in state[0][1:]]))\n      for line in state[1:]:\n          print(\"\".join([\"*\"  if x else \".\" for x in line]))\n  \n  def solve(state, mines):\n      prev_state = deepcopy(state)\n      for row in range(len(state)):\n          for col in range(len(state[row])):\n              new_state = deepcopy(state)\n              clear(new_state, (row, col))\n              c = count(new_state)\n              if(c < mines):\n                  state = prev_state\n              elif( c == mines):\n                  state_print(new_state)\n                  return True\n              else:\n                  if col == len(state[row]) -2:\n                      prev_state = deepcopy(state)\n                  state = new_state\n      print(\"Impossible\")\n      return False\n  \n  \n  \n  \n  def main():\n      filename = \"C-small-attempt0.in\"\n  \n  \n      inp = open(filename, \"rU\")\n  \n      n = int(inp.readline().strip())\n  \n      for case in range(1, n + 1):\n          R, C, M = map(int, inp.readline().strip().split(\" \"))\n          state = [[1 for x in range(C)] for y in range(R)]\n          print(\"Case #{}:\".format(case))\n          solve(state, M)\n  \n  main()\n", "substitutes": {"state": ["parent", "st", "area", "model", "run", "statement", "old", "match", "private", "size", "position", "unit", "start", "range", "can", "source", "machine", "m", "ode", "length", "force", "now", "cell", "pair", "instance", "layer", "bug", "j", "object", "rule", "down", "l", "slice", "cal", "time", "core", "store", "un", "power", "value", "connection", "self", "list", "name", "use", "config", "zip", "message", "stat", "function", "session", "p", "STATE", "block", "new", "resource", "back", "error", "scale", "State", "form", "al", "point", "step", "all", "parse", "code", "address", "count", "output", "order", "shape", "body", "space", "region", "public", "type", "pe", "section", "update", "style", "frame", "states", "data", "f", "seed", "port", "part", "key", "string", "history", "patch", "grade", "local", "ace", "cache", "date", "scope", "sync", "file", "oper", "work", "node", "loc", "test"], "coord": ["dom", "layer", "component", "cat", "index", "patch", "code", "xy", "dc", "cal", "address", "area", "node", "pixel", "comp", " coordinate", "xxxx", "channel", "du", "ord", "order", "ctrl", "shape", "co", "connection", "date", "dim", "batch", "coll", "word", "com", "loop", "position", "config", "lat", "num", "range", "gap", "con", "color", "cand", "call", " coordinates", "cube", "span", "pos", "error", "rect", "cell", "form", "data", "loc", "point", "pair", "ctx", "direction", "location", "char", "record", "number", "route"], "r": ["v", "e", "rr", "br", "l", "ro", "end", "rd", "q", "w", "rh", "cr", "g", "s", "ir", "i", "ar", "h", "nr", "rc", "range", "m", "rs", "b", "p", "d", "z", "rg", "re", "k", "f", "rn"], "c": ["j", "v", "pc", "nc", "unc", "e", "min", "cs", "uc", "l", "dc", "lc", "count", "ca", "ce", "bc", "w", "cu", "ec", "co", "cr", "g", "center", "s", "h", "i", "sc", "coll", "toc", "rc", "cycle", "cf", "ci", "con", "u", "cm", "m", "mc", "b", "p", "d", "ch", "z", "chain", "ct", "a", "cc", "cy", "k", "f", "ac"], "row": ["ri", "low", "area", "field", "feed", "coll", "head", "rc", "range", "length", "cell", "k", "none", "bug", "xy", "offset", "one", "sc", "num", "con", "rows", "ry", "p", "block", "arrow", "scale", "rank", "flow", "rown", "uc", "index", "user", "server", "month", "order", "group", "hop", "view", "tr", "frame", "pos", "cur", "oy", "f", "port", "record", "Row", "min", "key", "ack", "ro", "right", "post", "w", "co", "batch", "h", "i", "ow", "lock", "column", "entry", "rid", "dy", "node", "loc", "page"], "col": ["ail", "j", "min", "key", "cat", "index", " Col", "l", "sec", "ind", "count", "act", "w", "ady", "el", "o", "offset", "Col", "co", "path", "cr", "keep", "h", "i", "coll", "rel", "seq", "fl", "rc", "val", "win", "cf", "num", "column", "ci", "yl", "con", "foot", "p", "ch", "pos", "COL", "year", "fc", "cur", "ol", "ct", "int", "cor", "cy", "rot", "cell", "oy", "cp", "cl", "f", "loc", "k", "word"], "x": ["rx", "rex", "xe", "xx", "v", "e", "id", "index", "px", "xb", "code", "t", "array", "xy", "l", "q", "xi", "w", "expl", "xxx", "on", "co", "g", "oint", "X", "ex", "i", "h", "ux", "xes", "xp", "pe", "xa", "xc", "long", "xt", "u", "yx", "ic", "inx", "dx", "p", "xf", "d", "cross", "z", "ix", "ax", "check", "int", "wx", "xs", "sex", " X", "_", "f", "ctx", "point", "work", "lex", "exp", "test"], "line": ["inline", "string", "l", "code", "log", "end", "slice", "time", "run", "day", "li", "un", "o", "co", "len", "pe", "name", "val", "cycle", "max", "range", "column", "con", "str", "ln", "frame", "block", "pos", "length", "lines", "ne", "lin", "Line", "cell", "number", "point", "lined"], "mines": ["MINus", "minores", "colions", "Minions", "minions", "minxes", "raines", "Minores", "colores", "MINes", " minores", "minations", "generES", "rainES", "Minics", " minions", " minxes", "minics", "Minus", "minus", " minus", " minations", "Mines", "MINations", "Minations", "generes", "rainics", "Minxes", "colxes", "generions", "coles", "rainions", "generics", "minES", "MINores", "MinES"], "prev_state": ["vious_line", " prev_position", " prev_states", " prev_resource", "prev_resource", " prev_start", "prev_name", "vious_resource", "prev_start", " prev_stat", "prev_states", "vious_key", "prev_line", "vious_state", "prev_stat", "prev_key", "prev_position", " prev_name"], "new_state": ["new_call", "new_private", "new67rule", "new_space", "newJstates", "new67row", "newParresource", "new_states", "new_style", "clean_state", "new_resource", "next_row", "newamstate", "newamcomponent", "new_order", "prev_order", "next_call", "clean_states", "new_object", "newJobject", "prev_resource", "cleanJspace", "newJspace", "new67style", "newJstate", "newParstate", "next_slice", "prev_rule", "newParorder", "cleanJstates", "new_slice", "next_state", "prev_private", "new_row", "newamscope", "new_rule", "new67private", "clean_object", "cleanJobject", "new_component", "cleanJstate", "prev_style", "new67slice", "clean_space", "newamstyle", "new67state", "prev_scope", "new67call", "prev_component", "new_scope"], "filename": ["ema", "mph", "fn", "open", "figure", "directory", "username", "jpg", "utf", "sf", "fd", "sheet", "approximately", "files", "amer", "itled", "subject", "ename", "path", "connection", "aml", "ppa", "binary", "File", "title", "file", "jl", "profile", "dll", "fil", "il", "SourceFile", "fp", "document", "jet", "FILE", "ls", "nil", "kl", "phrase", "Filename", "which", "appy", "iled", "download", "database"], "inp": ["inproc", "insl", "inl", "incps", "kinps", " inproc", "INp", "innp", "INc", " inpo", "Inl", "Inh", "inpt", "kinpt", "insp", "incp", "Inc", "INproc", "kinp", "inps", "insc", "Inpt", "Inps", "innc", "inf", "incf", "inpo", "innproc", "Inp", "kinf", "inh", " inh", "insh", "innpo", " inc", "INpo", "incpt", "Inf", " inl", "inc"], "n": ["N", "j", "ns", "nc", "l", "t", "count", "nb", "un", "o", "sn", "s", "len", "i", "en", "nt", "size", "cn", "num", "ni", "con", "m", "b", "p", "nu", "span", "ne", "k", "number", "network"], "case": ["instance", "nce", "id", "e", "SC", "uc", "key", "patch", "code", "change", "mi", "count", "trial", "time", "ace", "ce", "catch", "bc", "me", "match", "ice", "mode", "section", "name", "use", "size", "position", "config", "call", "p", "block", "length", "a", "Case", "ase", "cases", "cp", "loc", "number", "test"], "R": ["Rh", "N", "Y", "T", "Rs", "P", "MR", "RH", "CR", "E", "G", "H", "RM", "W", "RO", "K", "X", "Q", "DR", "RS", "I", "B", "D", "F", "RN", "S", "p", "RR", "V", "State", "A", "L", "U"], "C": ["N", "Y", "T", "P", "DC", "CR", "U", "E", "G", "H", "CE", "W", "Col", "COR", "K", "X", "Co", "CV", "Q", "CC", "I", "B", "Cu", "D", "CI", "F", "O", "S", "CL", "CU", "A", "L", "V"], "M": ["N", "Y", "MD", "T", " m", "P", "MS", "MO", "J", "CM", "U", "MT", "E", "G", "H", "RM", "W", "DM", "X", "Q", "I", "B", "MF", "D", "F", "LM", "MM", "m", "O", "S", "MN", "MC", "L", "V"], "y": ["Y", "ym", "j", "yr", "xy", "q", "day", "month", "yd", "ay", "ady", "yy", "h", "ya", "cycle", "yl", "my", "ry", "ch", "d", "gy", "z", "year", "ye", "dy", "cy", " yr", "oy"]}}
{"code": " \n  filename = \"A-small-attempt0.in\"\n  \n  inp = open(filename, \"rU\")\n  \n  n = int(inp.readline().strip())\n  \n  for case in range(1, n+1):\n      gr = lambda x: [list(map(int, inp.readline().strip().split(\" \"))) for p in range(4)][x-1]\n      ans1 = int(inp.readline().strip())\n      row1 = set(gr(ans1))\n      ans2 = int(inp.readline().strip())\n      row2 = set(gr(ans2))\n      sect = row1 & row2\n      if len(sect) <= 0:\n          print(\"Case #{}: Volunteer cheated!\".format(case))\n      elif len(sect) == 1:\n          print(\"Case #{}: {}\".format(case, sect.pop()))\n      elif len(sect) > 1:\n          print(\"Case #{}: Bad magician!\".format(case))\n      else:\n          print(\"ERROR\")\n", "substitutes": {"filename": ["prefix", "fn", "figure", "summary", "directory", "username", "utf", "final", "url", "fd", "sheet", "files", "knife", "path", "ename", "ppa", "binary", "maximum", "name", "title", "file", "dll", "SourceFile", "fil", "il", "fp", "document", "download", "jet", "FILE", "full", "nil", "kl", "phrase", "Filename", "which", "appy", "iled", "f", "sf", "location", "database"], "inp": ["inproc", "binproc", "inl", "insl", "incl", "innfp", "insfp", " inproc", "asp", "inasp", "innp", "insper", " inpp", " inf", "Inh", "insb", "insp", "innper", "Inb", "incp", "insf", "InP", " inb", "inps", "inips", "insc", "Inpp", "binper", " inps", "inip", "inaspp", "inf", "incf", "binp", "infp", "Insp", "iniper", "incc", "innproc", "Inp", " infp", "inh", "insP", "inP", "inassp", "binps", "iniproc", "inper", "insproc", "insh", " insp", "asb", "inasb", " inper", "inpp", "inb", "ash", " inc", "asP", " inl", "inc"], "n": ["x", "N", "j", "ns", "nc", "l", "t", "nb", "r", "w", "net", "o", "g", "c", "conn", "s", "i", "nt", "size", "cn", "y", "ot", "num", "m", "nn", "u", "b", "nu", "span", "d", "z", "k", "f", "number", "network"], "case": ["instance", "fold", "sea", "definition", "uc", "key", "charge", "code", "patch", "address", "time", "trial", "ace", "model", "bc", "catch", "rice", "ce", "li", "shape", "space", "path", "match", "ice", "c", "X", "connection", "h", "ex", "pe", "section", "exc", "type", "name", "y", "position", "config", "num", "serial", "xc", "m", "face", "base", "ch", "line", "division", "client", "Case", "ase", "cases", "condition", "cell", "example", "number", "pair", "test"], "gr": ["gg", "grad", "mr", "fr", "rr", "GR", "groups", "res", "err", "yr", "patch", "br", "ru", "grade", "our", "r", "dr", "ravel", "order", "col", "group", "gor", "g", "cr", "div", "Gr", "match", "ge", "mult", "arch", "row", "reg", "sr", "range", "gap", "ur", "hr", "usr", "tr", "grid", "ch", "rg", "chain", "cor", "arr", "pr", "char"], "p": ["j", "e", "pc", " pe", "pl", "ip", "t", "P", "q", "r", "w", "col", "X", "c", " xp", "i", "pe", "h", "y", "pp", "u", "pn", "b", "d", "pos", "ax", "f", "point"], "ans1": ["casOne", "cas1", "cas2", "ass0", "annp", "ann0", "an1", "ansp", "ans0", "lan2", "ass81", "anOne", "ann2", "an2", "ansOne", "annOne", "lan81", "ass2", "ans81", "lan1", "anp", "ass1", "lan0", "ann81", "casp", "ann1"], "row1": ["passone", "row01", "col1", "pass1", "rowsone", " row01", "rowOne", "line2", "pass2", "line3", "rows01", "rows1", "rowsOne", "passOne", "colOne", "rowone", "row3", "colone", "rows3", "line1", " row3", "col2", "line01", "rows2"], "ans2": ["atan2", "anssecond", "canTwo", "can2", "anTwo", "ann62", "ans62", "atan62", "annsecond", "atan1", "an02", "an1", "ans02", "rassecond", "ras1", "atansecond", "ras62", "can02", "ansTwo", "ann02", "ann2", "an2", "annTwo", "can1", "ras2", "ann1"], "row2": ["owtwo", "Row02", " rowtwo", "Row2", "coltwo", "row0", "ow2", "rows1", "rows02", " row0", "rowtwo", "Row1", "Row0", " row02", "rows0", "col2", "row02", "rows2"], "sect": ["fold", "part", "crit", "patch", " sections", "array", "fat", "respect", "dit", "zen", "lc", "west", "act", "na", "ign", " intersect", "sections", " section", "body", "sequ", "subject", "col", "conn", "sc", "section", "pattern", "sw", "seq", "rupt", "row", "cont", "config", "connect", "zip", "qa", "sector", "cells", "ect", "sequence", "struct", "rows", "access", "six", "rup", "chn", "pect", "cross", "feat", "contract", "ct", "sex", "form", "equ", "fts", "loc", "closure", "ctx", "pull", "sq", "test"]}}
{"code": " \n  def transpose(result, R, C):\n  \tresultSplitted = result.split(\"\n\")\n  \taux = R*[\"\"]\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t    aux[i] += resultSplitted[j][i]\n  \t\taux[i] += \"\n\"\n  \tresult = \"\"\n  \tfor item in aux:\n  \t\tresult += item + \"\n\"\n  \treturn result.strip()\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file(\"output.txt\", \"w\")\n  \n  T = int(f.readline())\n  \n  for case in xrange(T):\n  \tdata = f.readline().strip().split(\" \")\n  \tR = int(data[0])\n  \tC = int(data[1])\n  \tM = int(data[2])\n  \n  \tresult = \"\"\n  \n  \tx = min(R,C)\n  \ty = max(R,C)\n  \n  \tif M > (y - 2)*x and M != y*x - 1:\n  \t\tN = M - (y-2)*x\n  \t\tif N%2 == 1 or y*x - M == 2:\n  \t\t\tresult = \"Impossible\"\n  \tif result != \"Impossible\":\n  \t\ti = 0\n  \t\twhile M > 0: # 2\n  \t\t\tif i < y - 2:\n  \t\t\t\tif M >= x:\n  \t\t\t\t\tresult += x*\"*\" + \"\n\"\n  \t\t\t\t\tM -= x\n  \t\t\t\t\ti += 1\n  \t\t\t\telif M <= x - 2:\n  \t\t\t\t\tresult += M*\"*\" + (x - M) * \".\" + \"\n\"\n  \t\t\t\t\tM = 0\n  \t\t\t\t\ti += 1\n  \t\t\t\telif i + 2 < y - 1:\n  \t\t\t\t\tresult += (M-1)*\"*\" + (x - M + 1) * \".\" + \"\n\" + \"*\" + (x-1)*\".\" + \"\n\"\n  \t\t\t\t\tM = 0\n  \t\t\t\t\ti += 2\n  \t\t\t\telse:\n  \t\t\t\t\tresult = \"Impossible\"\n  \t\t\t\t\tbreak\n  \t\t\telse:\n  \t\t\t\tif M%2 != 0:\n  \t\t\t\t\tresult += x*\"*\" + \"\n\"\n  \t\t\t\t\tresult += (x-1)*\"*\" + \"c\"\n  \t\t\t\telse:\n  \t\t\t\t\tn = M/2\n  \t\t\t\t\tresult += n*\"*\" + (x-n)*\".\" + \"\n\"\n  \t\t\t\t\tresult += n*\"*\" + (x-n-1)*\".\" + \"c\"\n  \t\t\t\tM = 0\n  \t\t\t\ti += 2\n  \t\t\t\t\t\n  \t\twhile i <= y - 1 and result != \"Impossible\":\n  \t\t\tif i == y - 1:\n  \t\t\t\tresult += (x-1)*\".\" + \"c\"\n  \t\t\telse:\n  \t\t\t\tresult += x*\".\" + \"\n\"\n  \t\t\ti += 1\n  \t\n  \tif R < C and result != \"Impossible\":\n  \t\tresult = transpose(result, R, C)\n  \n  \tfout.write(\"Case #%d:\n%s\n\" %(case + 1, result))\n", "substitutes": {"result": ["feature", "root", "err", "transform", "model", "final", "complete", "term", "match", "description", "request", "master", "source", "current", "search", "df", "true", "iter", "content", "random", "successful", "RESULTS", "Result", "array", "success", "catch", "r", "url", "answer", "ise", "value", "list", "use", "buffer", "config", "out", "message", "function", "found", "response", "new", "resource", "diff", "error", "re", "number", "res", "product", "compl", "report", "include", "output", "table", "event", "ULT", "header", "math", "dict", "mate", "total", "reason", " Result", "input", "method", "void", "ver", "Results", "comment", "record", "valid", "figure", "summary", "string", "default", "text", "cache", "package", "this", "status", "replace", "date", "sum", "ret", "memory", "sequence", "null", "document", "results", "ult", "work", "exit", "page", "test"], "R": ["Rh", "Y", "Cor", "Red", "Rs", "Result", "P", "J", "RH", "Rad", "Re", "r", "JR", "E", "G", "H", "SR", "RM", "W", "RO", "RF", "Right", "X", "RW", "Q", "DR", "RS", "I", "B", "RP", "range", "D", "F", "RC", "RG", "IR", "Ra", "AR", "O", "RN", "S", "RR", "V", "Res", "NR", "A", "L", "U", "RA"], "C": ["Y", "NC", "SC", "Cs", "P", "VC", "DC", "CM", "J", "CR", "E", "CE", "W", "CA", "K", "X", "c", "YC", "JC", "Q", "CC", "CS", "I", "B", "CW", "Cu", "D", "F", "CI", "Ch", "CP", "O", "CT", "S", "Z", "CL", "MC", "V", "CU", "CN", "L", "U"], "resultSplitted": ["resultSpitched", "resultSpitted", "resultsplitized", "resultSkitched", "resultSpited", " resultSplitized", "resultDivitted", "resultSpitized", "resultSlited", " resultDivitted", "resultSkitized", " resultSplited", "resultSplitized", "resultBreited", "resultsplitted", " resultsplitched", "resultBreitized", " resultSplitched", "resultSkitted", "resultSplitched", "resultDivitized", " resultDivitched", " resultDivitized", "resultDivited", "resultSlitched", "resultSkited", "resultBreitched", " resultsplited", "resultsplitched", " resultsplitized", "resultDivitched", "resultsplited", " resultDivited", "resultSplited", "resultBreitted", " resultsplitted", "resultSlitized", "resultSlitted"], "aux": ["utils", "external", "uc", "ru", "array", "aug", "lc", "final", "args", "sect", "cas", "af", "asc", "auc", " auxiliary", "abc", "empty", "frac", "amp", "special", "ex", "ux", "section", "ww", "ault", "exec", "seq", "au", "total", "config", "tmp", "input", "sequence", "long", "aligned", "null", "Items", "iliary", "extra", "items", "ext", "ai", "layout", "events", "UX", "partial", "sub", "feat", "assembled", "flat", "main", "iterator", "front", "ctx", "ac", "temp", "ui", "union"], "i": ["Y", "mu", "v", "ii", "e", "bi", "ri", "index", "im", "ip", "l", "t", "mi", "phi", "ind", "q", "xi", "id", "li", "r", "iu", "it", "o", "c", "ti", "ir", "h", "qi", "gi", "ie", "chi", "si", "I", "ori", "ni", "ci", "ini", "m", "u", "ai", "Mi", "b", "p", "d", "z", "pi", "int", "a", "mini", "di", "k", "zi", "ui"], "j": ["ji", "id", "v", "ii", "e", "key", "index", "im", "l", "code", "ind", "q", "J", "xi", "li", "it", "o", "g", "c", "h", "ie", "jp", "si", "u", "ib", "b", "p", "ch", "d", "z", "obj", "ct", "ij", "k"], "item": ["original", "v", "anything", "root", "string", "ip", "other", "array", "Result", "q", "complex", "li", "r", "feed", "rec", "abc", "description", " it", "X", "value", "xml", "bar", "section", "raw", "val", "row", "I", "num", "job", "input", "null", "Items", "function", "items", "Item", "p", "new", "entry", "iter", "example", "temp", "foo"], "inputFileName": ["inputFilesPath", "inputPutDescription", "contextFileAlias", "inputFilesName", "contextFileName", "inputfileUrl", "inputFileAlias", "inputFILEAlias", "inputPutName", "contextFILEDescription", " inputFileUrl", "contextFILEName", "inputFilenameDescription", "inputFILEDescription", "inputFilesSize", "contextFileContents", "inputFileUrl", "inputStreamName", "inputFilenameAlias", "inputfilePath", " inputStreamName", "inputfileName", "contextFILEContents", " inputStreamSize", "inputFilePath", "inputFILEName", "inputFilenameContents", "inputStreamSize", "contextFILEAlias", "inputFileContents", "contextFileDescription", "inputfileSize", "inputFileDescription", "inputFilenameName", " inputStreamPath", " inputFileSize", " inputStreamUrl", "inputStreamPath", "inputFilesUrl", "inputFileSize", " inputFilePath", "inputFILEContents", "inputStreamUrl", "inputPutContents", "inputPutAlias"], "f": ["fn", "v", "e", "fr", "fast", "ff", "rf", "l", "t", "fo", "tf", "fa", "af", "r", "w", "fd", "feed", "folder", "c", "s", "h", "info", "inf", "file", "fw", "cf", "input", "F", "fp", "m", "b", "fs", "p", "d", "df", "buff", "fc", "form", "io", "fu"], "fout": ["Fstring", "fsint", "fint", "fsstring", "fstring", "fOut", "fsout", " fint", "FOut", " fOut", "fsOut", "Fout", " fstring", "Fint"], "T": ["Y", "TN", "t", "P", "J", "TS", "E", "H", "G", "W", "K", "X", "Time", "NT", "Q", "I", "B", "TA", "D", "F", "O", "S", "TT", "Z", "V", "TB", "A", "L", "U"], "case": ["je", "code", "sec", "ind", "time", "trial", "q", "col", "ice", "c", "ti", "gi", "h", "section", "seq", "val", "cycle", "row", "job", "ci", "tim", "ib", "ai", "z", "obj", "ct", "cell", "times", "test"], "data": ["missing", "e", "v", "pad", "object", "key", "index", "string", "default", "array", "t", "code", "slice", "end", "args", "output", "Data", "features", "complete", "na", "r", "sample", "dat", "body", "rec", "space", "one", "div", "DATA", "c", "series", "s", "value", "info", "batch", "aa", "sum", "reader", "val", "config", "start", "split", "input", "current", "m", "function", "str", "items", "p", "details", "d", "block", "results", "da", "response", "lines", "a", "first", "number", "record"], "M": ["Y", "MD", "P", "MS", "MR", "J", "CM", "Multi", "U", "MT", "E", "Num", "G", "MI", "MX", "H", "W", "DM", "K", "X", "NM", "Mo", "Q", "TM", "I", "B", "ID", "MF", "D", "F", "LM", "MM", "m", "O", "S", "Mi", "Z", "MN", "MA", "Me", "ME", "MC", "IM", "A", "L", "V"], "x": ["id", "v", "t", "model", "image", "xc", "m", "yx", "ax", "true", "xs", "sex", "Y", "rx", "l", "no", "xy", "time", "r", "xxx", "one", "X", "value", "xml", "ex", "num", "single", "my", "p", "ix", "full", "_", "plus", "index", "px", "code", "q", "up", "xi", "event", "any", "on", "s", "ya", "python", "max", "input", "u", "yes", "dx", "b", "d", "cross", "xx", "e", "min", "key", "w", "c", "fe", "h", "xes", "null", "ic", "z", "ey", "int", "cy", "wx", "io", "page"], "y": ["Y", "ym", "v", "sy", "min", "e", "key", "yr", "ky", "yt", "l", "t", "ys", "xy", "ny", "q", "vy", "sky", " Y", "ay", "yi", "r", "o", "yy", "X", "c", "type", "h", "ya", "python", "ty", "my", "py", "ry", "m", "b", "p", "d", "ch", "z", "ey", "year", "ye", "dy", "cy", "yo", "oy"], "N": ["Y", "P", "J", "E", "Num", "H", "G", "Size", "o", "W", "K", "X", "NM", "Q", "Ns", "I", "B", "D", "F", "m", "O", "Mi", "S", "MN", "V", "L", "U"], "n": ["e", "v", "ns", "nc", "min", "ii", "l", "t", "no", "dn", "q", "na", "nb", "r", "net", "o", "g", "sn", "c", "h", "en", "cn", "Ns", "nor", "num", "ni", "m", "nn", "u", "pn", "ln", "Ni", "b", "p", "nu", "d", "z", "ne", "nm", "k", "number"]}}
{"code": " \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file(\"output.txt\", \"w\")\n  \n  T = eval(f.readline())\n  \n  for case in xrange(T):\n  \n  \tA1 = int(f.readline().strip())\n  \n  \tfor i in xrange(4):\n  \t\tif i == A1 - 1:\n  \t\t\tpossibles1 = f.readline().strip().split(\" \")\n  \t\telse:\n  \t\t\tf.readline().strip().split(\" \")\n  \n  \tA2 = int(f.readline().strip())\n  \n  \tfor i in xrange(4):\n  \t\tif i == A2 - 1:\n  \t\t\tpossibles2 = f.readline().strip().split(\" \")\n  \t\telse:\n  \t\t\tf.readline().strip().split(\" \")\n  \n  \tfinal = []\n  \tfor item in possibles2:\n  \t\tif item in possibles1:\n  \t\t\tfinal.append(item)\n  \n  \tif len(final) == 0:\t\n  \t\tfout.write(\"Case #%d: Volunteer cheated!\n\" %(case + 1))\n  \telif len(final) == 1:\n  \t\tfout.write(\"Case #%d: %s\n\" %(case + 1, final[0]))\n  \telse:\n  \t\tfout.write(\"Case #%d: Bad magician!\n\" %(case + 1))\n", "substitutes": {"inputFileName": ["inputPathLocation", "inputClassCopy", "inputClassNames", "outputLinePath", "inputPathCopy", "outputFileNames", "outputFileCopy", "inputFullName", "inputFileCopy", "inputLineCopy", "inputTableName", "inputLineLocation", "inputFileNames", "inputfileCopy", "inputFullNames", "inputLineName", "inputPathPath", "inputTableCopy", "inputClassPath", "inputfileNames", "inputFullPath", "inputfilePath", "outputFileLocation", "outputLineName", "inputfileName", "outputLineCopy", "inputTablePath", "inputFilePath", "outputFileName", "outputClassPath", "outputLineLocation", "inputFileLocation", "inputClassName", "inputPathName", "outputClassCopy", "outputClassName", "inputTableLocation", "outputClassNames", "outputFilePath", "inputFullCopy", "inputLinePath"], "f": ["x", "fn", "fold", "v", "fr", "e", "fast", "ff", "rf", "l", "t", "fo", "tf", "more", "fa", "r", "w", "fd", "fx", "feed", "o", "func", "bf", "g", "c", "fe", "s", "info", "conf", "inf", "fl", "file", "fen", "fw", "cf", "input", "F", "of", "fm", "fp", "m", "u", "function", "lf", "found", "b", "fs", "p", "d", "z", "fc", "full", "flat", "form", "io", "sf"], "fout": ["FOUT", "fint", " fOUT", "fouts", "fpout", "cfint", " fint", "Fouts", "fpouts", "ifecho", "cfout", "ifout", "ifsync", " fagain", "fsync", " fuser", " fouts", "fin", " fin", "sfagain", "fileint", "fileagain", "fuser", "Fin", "sfout", "fileOut", "cfin", "cfOut", "fileout", "filein", "affout", "fagain", "sfuser", "affecho", "Fout", "affsync", " fsync", "fOUT", " fecho", "fOut", "sfin", " fOut", "fpin", "fecho", "fpOUT", "fileuser"], "T": ["N", "TE", "t", "P", "TS", "U", "E", "W", "X", "LT", "Time", "R", "TC", "NT", "Q", "I", "B", "D", "F", "WT", "O", "S", "TT", "C", "M", "A", "L", "V"], "case": ["instance", "id", "sea", "bug", "e", "key", "charge", "ip", "code", "t", "change", "patch", "end", "slice", "address", "time", "trial", "ace", "ce", "bc", "catch", "shift", "li", "shape", "match", "ice", "c", "ape", "ie", "type", "section", "seq", "name", "size", "position", "cycle", "phase", "config", "switch", "num", "C", "choice", "length", "line", "chain", "client", "Case", "ase", "cases", "point", "test"], "A1": [" AName", "AName", "A81", "C81", "CName", "AreaName", "LA61", "Area1", "Area81", " A81", "C1", "AOne", "a9", " A61", "LA8", "AreaOne", " A9", "a8", "a1", "COne", "a61", "A8", "A9", "LA9", " A8", " AOne", "A61", "LA1"], "i": ["x", "id", "j", "ii", "v", "e", "bi", "ip", "l", "t", "cli", "n", "phi", "ind", "xi", "yi", "iu", "li", "it", "o", "c", "s", "ie", "qi", "ti", "chi", "gi", "si", "oi", "vi", "I", "ori", "uri", "ni", "ci", "ic", "ai", "p", "d", "pi", "int", "a", "di", "zi", "io", "ui"], "A2": ["HA62", "All3", "A3", "AllSecond", "LA62", "ASecond", " A62", "All72", " ASecond", "A62", "All2", "HA2", "A72", "HA72", "HASecond", "HA3", "LA2", "LASecond", " A72", " A3"], "final": ["random", "original", "all", "part", "valid", "version", "external", "done", "fixed", "result", "other", "finished", "local", "actual", "complete", "package", "Final", "aux", "standard", "old", "public", "empty", "private", "real", "special", "update", "section", "initial", "total", "size", "static", "clean", "general", "serial", "single", "close", "unique", "later", "null", "current", "finals", "extra", "p", "last", "partial", "latest", "new", "full", "stack", "small", "confirmed", "data", "temp", "upper"], "item": ["step", "layer", "instance", "parent", "id", "missing", "individual", "anything", "root", "object", "index", "string", "im", "result", "ip", "something", "atom", "character", "trial", "member", "event", "li", "it", "edit", "rec", "match", "value", "bar", "section", "word", "hop", "name", "val", "unit", "row", "inner", "gap", "custom", "source", "extra", "items", "Item", "entry", "example", "loc", "number", "data", "temp", "exp", "page", "test"]}}
{"code": " \n  \n  EOL = \"\n\"\n  \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\n      \n      By default, 'epsilon' is 1e-6.\n      \"\"\"\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(fd):\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\n      return fd.readline().strip().split()\n  \n  def read_ints(fd):\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\n      return [int(p) for p in read_syms(fd)]\n  \n  def read_floats(fd):\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\n      return [float(p) for p in read_syms(fd)]\n  \n  \n  class Mtrx(object):\n      \"\"\"A matrix object.\"\"\"\n      \n      def __init__(self, rows, cols, data):\n          assert len(data) == rows * cols\n          self.rows = rows\n          self.cols = cols\n          self.data = data\n          \n      def cell(self, r, c):\n          return self.data[r * self.cols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in xrange(self.cols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in xrange(self.rows)]\n      \n      @classmethod\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\n          \n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\n          Pre-determined size can be passed using `rows` and `cols`.\n          \"\"\"\n          data = []\n          if rows is None:\n              assert cols is None\n              rows, cols = read_ints(fd)\n          else:\n              assert cols is not None\n          for _ in range(rows):\n              line = readfunc(fd)\n              assert len(line) == cols\n              data.extend(line)\n          return Mtrx(rows, cols, data)\n              \n      @classmethod\n      def read_int_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_ints, rows, cols)\n              \n      @classmethod\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_syms, rows, cols)\n              \n      def __str__(self):\n          res = \"\"\n          for i in xrange(self.rows):\n              res += str(self.getrow(i)) + EOL\n          return res\n      \n      def __repr__(self):\n          return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\n                                         self.cols, self.data)\n  \n  \n  cachetotals = 0\n  cachemisses = 0\n  \n  def statreset():\n      global cachemisses, cachetotals\n      cachemisses = 0\n      cachetotals = 0\n  \n  class memoizeit(object):\n      \"\"\"Decorator. Caches a function's return value each time it is called.\n      \n      If called later with the same arguments, the cached value is returned \n      (not reevaluated).\n      \"\"\"\n      \n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          \n          global cachetotals, cachemisses\n          cachetotals += 1\n          \n          try:\n              return self.cache[args]\n          except KeyError:\n              \n              cachemisses += 1\n              \n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n  \n              cachemisses += 1\n  \n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          \"\"\"Support instance methods.\"\"\"\n          return functools.partial(self.__call__, obj)\n  \n  \n  class timeit(object):\n      \"\"\"Decorator that times a function.\n      \n      When function ends, print name, runtime, return value and cache stats.\n      \"\"\"\n      \n      def __init__(self, func):\n          self.func = func\n          \n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n              cachetotals else 0\n          print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\n              delta, value, cachedata)\n          return value\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n  \n  def read_input(filename):\n      data = []\n      with open(filename, \"r\") as f:\n          cases = read_ints(f)[0]\n          for _ in xrange(cases):\n              case = {}\n              case[\"R\"], case[\"C\"], case[\"M\"] = read_ints(f)\n              data.append(case)\n      return data\n  \n  def make_output(fname, output):\n      CASE_PRFX = \"Case #%s: \"\n      fname = fname + time.strftime(\"%H%M%S\") + \".out\"\n      with open(fname, \"w\") as f:\n          restext = []\n          print \"Output content ===============\"\n          for i, outdata in enumerate(output):\n              line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL\n              print line,\n              restext.append(line)\n          print \"=\" * 30\n          f.writelines(restext)\n  \n  \n  MINE = \"*\"\n  CLICK = \"c\"\n  UNK = \".\"\n  \n  class Board(object):\n      \n      def __init__(self, r, c):\n          self.rows = r\n          self.cols = c\n          self.edge_row_idx = self.rows - 1\n          self.edge_col_idx = self.cols - 1\n          self.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]\n          self.board[0][0] = CLICK\n  \n      def fill_edge_row(self, m):\n          i = self.edge_col_idx\n          while m > 0 and i >= 0:\n              self.board[self.edge_row_idx][i] = MINE\n              i -= 1\n              m -= 1\n          self.edge_row_idx -= 1\n  \n      def fill_edge_col(self, m):\n          i = self.edge_row_idx\n          while m > 0 and i >= 0:\n              self.board[i][self.edge_col_idx] = MINE\n              i -= 1\n              m -= 1\n          self.edge_col_idx -= 1\n  \n      def __str__(self):\n          return EOL.join([\"\".join(r) for r in self.board])\n  \n  @memoizeit\n  def is_stage_solvable(rows, cols, mines):\n      \"\"\"Return True iff stage is solvable. \n      Also return fill instruction:\n      0 if impossible/dontcare, 1 to fill row, 2 to fill column, \n      3 for row special (most in the row), 4 for col special (most in the col)\n      \"\"\"\n      rc = rows * cols\n      \n      if mines == rc:\n          return False, 0\n  \n      if rows == 1:\n          return mines <= rc - 1, 2\n      if cols == 1:\n          return mines <= rc - 1, 1\n      \n      if mines == rc - 1:\n          return True, 1  # doesn't matter what to fill\n      \n      if mines > rc - 4:\n          return False, 0\n      \n      if rows == 2:\n          return (False, 0) if mines == 1 else (True, 2)\n      if cols == 2:\n          return (False, 0) if mines == 1 else (True, 1)\n          \n      if rows <= cols:\n          if mines >= rows:\n              return True, 2\n          if mines == rows - 1:\n              if mines == cols - 1:\n                  if rows == 3:\n                      return False, 0\n                  return True, 4 # L shape fill, most in the column\n              else:\n                  return True, 1 # fill row\n          return True, 2 \n      else:\n          if mines >= cols:\n              return True, 1\n          if mines == cols - 1:\n              if mines == rows - 1:\n                  if cols == 3:\n                      return False, 0\n                  return True, 3 # L shape fill, most in the row\n              else:\n                  return True, 2 # fill column\n          return True, 1 \n  \n  @timeit\n  def solveit(case):\n      rows = case[\"R\"]\n      cols = case[\"C\"]\n      mines = case[\"M\"]\n      \n      b = Board(rows, cols)\n      r, c, m = rows, cols, mines\n      \n      while m >= 0:\n          okgo, howtofill = is_stage_solvable(r, c, m)\n          if not okgo:\n              return \"Impossible\"\n          if howtofill == 1: # fill row\n              b.fill_edge_row(m)\n              if m <= c:\n                  break # fill and done\n              m -= c\n              r -= 1\n          elif howtofill == 2: # fill column\n              b.fill_edge_col(m)\n              if m <= r:\n                  break # fill and done\n              m -= r\n              c -= 1\n          elif howtofill == 3: # L shape fill, most in the row\n              b.fill_edge_row(m - 1)\n              b.fill_edge_col(1)\n              break # fill and done\n          elif howtofill == 4: # L shape fill, most in the column\n              b.fill_edge_col(m - 1)\n              b.fill_edge_row(1)\n              break # fill and done\n          else:\n              assert False\n  \n      return str(b) \n  \n  \n  \n  @timeit\n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          statreset() # reset cache stats\n          res = solveit(case)\n          output.append(res)\n      make_output(fname, output)\n  \n  \n  if __name__ == '__main__':\n      main(\"C-small-attempt0.in\")\n", "substitutes": {"EOL": ["eOL", "EBOF", "EOC", " EOF", "eOC", "EBol", "EBOL", "EOF", " Eol", "Eol", "EBOC", "eol", "eOF", " EOC"], "x": ["rx", "Y", "id", "v", "e", "xx", "xe", "px", "l", "t", "n", "xy", "time", "wy", "xi", "ay", "w", "on", "width", "X", "ex", "h", "ya", "xa", "win", "ty", "xc", "yx", "u", "ph", "dx", "xf", "d", "z", "ix", "ax", "int", "a", "wx", "xs", "cell", "k", "sex", "f", "point"], "y": ["Y", "ym", "j", "e", "sy", "v", "yr", "yt", "ky", "ys", "t", "l", "n", "ny", "wy", "vy", "ies", "yd", "yi", "ay", "w", "ady", "o", "yy", "ya", "iy", "ty", "yl", "py", "ry", "zy", "d", "z", "ey", "year", "ye", "dy", "cy", "yo", "oy", "hy", "f"], "epsilon": ["epsilone", "epsalon", "iprilon", "epilon", "eprilan", "EPeltony", "epalons", "ppsilone", "epillron", "epeltency", "epsalan", "EPeltone", "epillency", "epilON", "epelten", "epsilons", "epeltoner", "eprilone", "epiolan", "epilron", "EPsilon", "epsilor", "epSilony", "ppsilon", "epilone", "epilons", "ipsilron", "apsilron", "epeltons", "apillony", "eprilon", "EPeltency", "epillen", "epeltone", "epiloner", "epillone", "epillON", "epssilon", "epssilON", "epilan", "epssilhen", "epillan", "epeltron", "epalysoton", "EPsilone", "epiolhen", "epsilhen", "epSilron", "epsalON", "iprilron", "ppsilron", "apsilon", "epillon", "epalyson", "eprilron", "epilor", "epslron", "epsalhen", "epalhen", "epinelon", "epilen", "epalan", "ppillON", "ppsilony", "epsalron", "epalysron", "eprilen", "epssiloton", "ppillon", "eprilency", "EPsilency", "epineloner", "epsiloton", "eprilons", "ppeltony", "epeltony", "epillony", "epsiloner", "apillron", "epslan", "epssilan", "iprilony", "epelton", "epalysoner", "epSilor", "eprilON", "iprilor", "epiolons", "epillons", "epslon", "apsiloner", "epsilency", "epalron", "epssilron", "epiolon", "apilloner", "epiloton", "ppelton", "ppeltone", "apsilony", "epssilone", "epeltON", "epSilon", "EPelton", "epalon", "EPsilony", "epsilron", "ppsilON", "eprilony", "epsilan", "ipsilor", "ipsilon", "epsilON", "epsalons", "ppsilen", "epssiloner", "epinelron", "epillhen", "ppillron", "epineloton", "epslON", "epilloner", "ipsilony", "epssilen", "ppillen", "epalON", "epsilen", "epsilony", "epssilons", "epilony", "epssilony", "ppeltron", "eprilor", "apillon"], "fd": ["fn", "cb", "dl", "FD", "fr", "ff", "draw", "ds", "fat", "vd", "dc", "draft", "handle", "driver", "af", "stream", "gd", "fx", "fa", "pdf", "feed", "fin", "ld", "wind", "pd", "folder", "pipe", "bf", "cod", "fe", "bd", "reader", "fl", "file", "ecd", "fen", "fw", "cf", "nd", "handler", "wd", "fm", "fi", "fp", "rb", "dd", "lf", "fed", "wb", "fs", "fb", "df", "d", "hd", "td", "fc", "dir", " fid", "buf", "f", "sf", "db"], "p": ["bp", "v", "e", "pc", "sp", "ip", "np", "t", "P", "n", "ap", "l", "q", "ep", "o", "g", "type", "h", "mp", "python", "wp", "jp", "pp", "lp", "vp", "py", "fp", "u", "gp", "ph", "pa", "tp", "pid", "d", "pi", "cp", "f", "op", "pr"], "self": ["parent", "sys", "http", "err", "per", "spec", "old", "ref", "master", "ws", "tmp", "qa", "app", "proxy", "events", "df", "now", "k", "resp", "instance", "j", "object", "l", "n", "gen", "os", "plugin", "gh", "config", "new", "full", "error", "a", "form", "plus", "ctx", "Self", "all", "ff", "cs", "user", "other", "q", "dev", "event", "s", "ng", "context", "host", "view", "lf", "d", "pos", "client", "er", "f", "worker", "part", "e", "us", "default", "ko", "end", "home", "w", "this", "co", "g", "h", "req", "fs", "results", "z", "es", "wx", "cl", "work", "node", "wrapper", "github", "page"], "rows": ["members", "docs", "reads", "fields", "levels", "ports", "checks", "window", "head", "ws", "tests", "breaks", "forms", "types", "events", "length", "xs", "ks", "olds", "groups", "planes", "headers", "models", "OWS", "keys", "ips", "values", "cells", "roots", "qs", "ids", "items", " lines", "days", "rules", "lines", "vals", "aults", "bytes", "times", "all", "blocks", "rown", "holes", "index", "cs", "ops", "features", "files", "opens", "s", "ows", "heads", "rings", "runs", "rs", "relations", "flows", "d", "pos", "ls", "ros", "errors", "reports", "frames", "tracks", "boxes", "faces", "points", "ries", " columns", "modules", "orders", "posts", "rooms", "ins", " row", "users", "row", "devices", "results", "es", "pages", "views"], "cols": ["colli", " colp", "collcount", "Colabs", " colows", "colds", "colgs", "columnS", " colops", "Colp", "colsd", "columnsi", "COLd", "colp", " colgs", "Coln", "COLabs", "coli", "cld", "colS", " colds", "colb", "columncs", "coln", "yln", "colcount", "Colw", "ylls", "pooli", "Cols", " colw", " colb", "cles", "columncount", "Coli", "Cold", "columnds", "collows", " cold", "dicti", " colS", "columnsd", "columnows", "poolsi", "columns", " coles", "Colls", "columnw", "colops", "colabs", " colabs", "Colows", "coles", "Colts", "threads", "columni", "threadgs", "pools", "columnb", "clcs", " colcount", "COLgs", " colcs", "columnn", "pooln", "colles", "Colsd", "Colb", "dicts", "threadts", "dictn", "COLts", "Colds", " colsi", "columnabs", "colcs", "yls", "colsi", "ColS", " colts", "colw", "colln", " coli", "cold", "columnes", " colls", "ylp", "colls", "columnops", "COLn", "columnd", "columnts", "COLs", "colows", "COLops", " coln", "colts", "COLsd"], "data": ["parent", "model", "feed", "image", "div", "window", "alpha", "source", "breaks", "partial", "cell", "api", "content", "array", "Data", "li", "format", "xxx", "dat", "list", "values", "reader", "buffer", "config", "zip", "cells", "str", "items", "block", "response", "lines", "a", "scale", "di", "next", "bytes", "form", "media", "missing", "all", "blocks", "la", "index", "multi", "result", "code", "append", "table", "body", "group", "dict", "raw", "input", "ata", "d", "pos", "f", "valid", "draw", "string", "default", "text", "json", "post", "sample", "DATA", "batch", "float", "actions", "row", "column", "devices", "load", "memory", "dd", "steps", "da", "results", "arr"], "r": ["j", "v", "e", "rr", "l", "ru", "n", "q", "right", "w", "rh", "col", "rec", "lr", "cr", "s", "R", "ar", "nr", "row", "sr", "range", "u", "rb", "rs", "ra", "d", "z", "entry", "k", "rar", "f", "er"], "c": ["v", "e", "nc", "uc", "cat", "pc", "cs", "unc", "l", "code", "t", "dc", "n", "lc", "ce", "cu", "col", "rec", "ec", "co", "cr", "s", "h", "arc", "row", "cf", "ci", "xc", "u", "cm", "ic", "d", "C", "ch", "z", "fc", "int", "ct", "cc", "cy", "cell", "k", "cl", "cp", "f", "ac"], "i": ["id", "j", "ii", "e", "v", "ri", "index", "ip", "l", "mi", "n", "lc", "q", "xi", "yi", "iu", "li", "it", "cu", "col", "s", "qi", "si", "oi", "I", "ci", "ini", "u", "ic", "ai", "d", "ch", "z", "ix", "pi", "int", "di", "cell", "f", "io", "ui"], "cls": ["ClS", "clusters", "clp", " clsys", "CLs", "Clp", "Classsb", " Clp", "hells", "wellsb", "hellS", " clusters", "Classsg", "wells", "clsg", "hellsb", "clS", "Clusters", "Cls", "CLsg", "clsb", " clsb", "CLS", " clabs", "wellusters", "CLabs", "Classs", "clabs", "Clsb", "CLsb", "Clabs", "clsys", "Clsys", " Clsys", " Cls", " clp", "Clsg"], "readfunc": ["loadfun", "writefun", "readfun", "writeproc", "loadfunction", " readfun", "writefunc", "loadproc", "readfunction", " readproc", "writefunction", " readfunction", "readproc", "loadfunc"], "_": ["all", "l", "q", "un", "g", "non", "k", "al", "f"], "line": ["inline", "string", "l", "code", "no", "log", "end", "lc", "model", "text", "li", "col", "el", "body", "record", "header", "lo", "LINE", "len", "section", "byte", "reader", "name", "limit", "sync", "file", "row", "buffer", "item", "zip", "range", "input", "column", "base", "str", "lf", "frame", "d", "block", "length", "entry", "lines", "lin", "Line", "cell", "content", "number", "band", "char", "page"]}}
{"code": " \n  \n  EOL = \"\n\"\n  \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\n      \n      By default, 'epsilon' is 1e-6.\n      \"\"\"\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(fd):\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\n      return fd.readline().strip().split()\n  \n  def read_ints(fd):\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\n      return [int(p) for p in read_syms(fd)]\n  \n  def read_floats(fd):\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\n      return [float(p) for p in read_syms(fd)]\n  \n  class Mtrx(object):\n      \"\"\"A matrix object.\"\"\"\n      \n      def __init__(self, rows, cols, data):\n          assert len(data) == rows * cols\n          self.rows = rows\n          self.cols = cols\n          self.data = data\n          \n      def cell(self, r, c):\n          return self.data[r * self.cols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in xrange(self.cols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in xrange(self.rows)]\n      \n      @classmethod\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\n          \n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\n          Pre-determined size can be passed using `rows` and `cols`.\n          \"\"\"\n          data = []\n          if rows is None:\n              assert cols is None\n              rows, cols = read_ints(fd)\n          else:\n              assert cols is not None\n          for _ in range(rows):\n              line = readfunc(fd)\n              assert len(line) == cols\n              data.extend(line)\n          return Mtrx(rows, cols, data)\n              \n      @classmethod\n      def read_int_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_ints, rows, cols)\n              \n      @classmethod\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_syms, rows, cols)\n              \n      def __str__(self):\n          res = \"\"\n          for i in xrange(self.rows):\n              res += str(self.getrow(i)) + EOL\n          return res\n      \n      def __repr__(self):\n          return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\n                                         self.cols, self.data)\n  \n               \n  cachetotals = 0\n  cachemisses = 0\n  \n  def statreset():\n      global cachemisses, cachetotals\n      cachemisses = 0\n      cachetotals = 0\n  \n  class memoizeit(object):\n      \"\"\"Decorator. Caches a function's return value each time it is called.\n      \n      If called later with the same arguments, the cached value is returned \n      (not reevaluated).\n      \"\"\"\n      \n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          \n          global cachetotals, cachemisses\n          cachetotals += 1\n          \n          try:\n              return self.cache[args]\n          except KeyError:\n              \n              cachemisses += 1\n              \n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n  \n              cachemisses += 1\n  \n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          \"\"\"Support instance methods.\"\"\"\n          return functools.partial(self.__call__, obj)\n  \n  class timeit(object):\n      \"\"\"Decorator that times a function.\n      \n      When function ends, print name, runtime, return value and cache stats.\n      \"\"\"\n      \n      def __init__(self, func):\n          self.func = func\n          \n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n              cachetotals else 0\n          print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\n              delta, value, cachedata)\n          return value\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n", "substitutes": {"EOL": ["eOL", "EBOF", "EOC", " EOF", "eOC", "EBol", "EBOL", "EOF", " Eol", "Eol", "EBOC", "eol", "eOF", " EOC"], "x": ["rx", "Y", "id", "v", "e", "xx", "xe", "px", "l", "t", "n", "xy", "time", "wy", "xi", "ay", "w", "on", "width", "X", "ex", "h", "ya", "xa", "win", "ty", "xc", "m", "yx", "u", "ph", "b", "dx", "xf", "d", "z", "ix", "ax", "int", "a", "wx", "xs", "cell", "k", "sex", "f", "point"], "y": ["Y", "ym", "j", "e", "sy", "v", "yr", "yt", "ky", "ys", "t", "l", "n", "ny", "wy", "vy", "ies", "yd", "yi", "ay", "w", "ady", "o", "yy", "ya", "iy", "ty", "yl", "py", "ry", "zy", "b", "d", "z", "ey", "year", "ye", "dy", "cy", "yo", "oy", "hy", "f"], "epsilon": ["epsilone", "epsalon", "iprilon", "epilon", "eprilan", "EPeltony", "epalons", "ppsilone", "epillron", "epeltency", "epsalan", "EPeltone", "epillency", "epilON", "epelten", "epsilons", "epeltoner", "eprilone", "epiolan", "epilron", "EPsilon", "epsilor", "epSilony", "ppsilon", "epilone", "epilons", "ipsilron", "apsilron", "epeltons", "apillony", "eprilon", "EPeltency", "epillen", "epeltone", "epiloner", "epillone", "epillON", "epssilon", "epssilON", "epilan", "epssilhen", "epillan", "epeltron", "epalysoton", "EPsilone", "epiolhen", "epsilhen", "epSilron", "epsalON", "iprilron", "ppsilron", "apsilon", "epillon", "epalyson", "eprilron", "epilor", "epslron", "epsalhen", "epalhen", "epinelon", "epilen", "epalan", "ppillON", "ppsilony", "epsalron", "epalysron", "eprilen", "epssiloton", "ppillon", "eprilency", "EPsilency", "epineloner", "epsiloton", "eprilons", "ppeltony", "epeltony", "epillony", "epsiloner", "apillron", "epslan", "epssilan", "iprilony", "epelton", "epalysoner", "epSilor", "eprilON", "iprilor", "epiolons", "epillons", "epslon", "apsiloner", "epsilency", "epalron", "epssilron", "epiolon", "apilloner", "epiloton", "ppelton", "ppeltone", "apsilony", "epssilone", "epeltON", "epSilon", "EPelton", "epalon", "EPsilony", "epsilron", "ppsilON", "eprilony", "epsilan", "ipsilor", "ipsilon", "epsilON", "epsalons", "ppsilen", "epssiloner", "epinelron", "epillhen", "ppillron", "epineloton", "epslON", "epilloner", "ipsilony", "epssilen", "ppillen", "epalON", "epsilen", "epsilony", "epssilons", "epilony", "epssilony", "ppeltron", "eprilor", "apillon"], "fd": ["fn", "cb", "dl", "FD", "fr", "ff", "draw", "ds", "fat", "vd", "dc", "draft", "handle", "driver", "filename", "af", "stream", "gd", "fx", "fa", "pdf", "feed", "fin", "ld", "wind", "pd", "folder", "pipe", "bf", "cod", "fe", "bd", "reader", "fl", "file", "ecd", "fen", "fw", "cf", "nd", "handler", "wd", "fm", "fi", "fp", "rb", "dd", "lf", "fed", "wb", "fs", "fb", "df", "d", "hd", "td", "fc", "dir", " fid", "buf", "f", "sf", "db"], "p": ["bp", "v", "e", "pc", "sp", "ip", "np", "t", "P", "n", "ap", "l", "q", "ep", "o", "g", "type", "h", "mp", "python", "wp", "jp", "pp", "lp", "vp", "py", "fp", "u", "m", "gp", "ph", "pa", "tp", "pid", "b", "d", "pi", "cp", "f", "op", "pr"], "self": ["parent", "sys", "http", "err", "per", "spec", "old", "ref", "master", "ws", "tmp", "qa", "app", "m", "proxy", "events", "df", "now", "k", "case", "resp", "instance", "j", "object", "l", "n", "gen", "os", "plugin", "gh", "config", "new", "full", "error", "a", "form", "plus", "ctx", "Self", "all", "ff", "cs", "user", "other", "q", "output", "dev", "event", "s", "ng", "context", "host", "view", "lf", "b", "d", "pos", "client", "er", "f", "worker", "part", "e", "us", "default", "ko", "end", "home", "w", "this", "co", "g", "h", "req", "fs", "results", "z", "es", "wx", "cl", "work", "node", "wrapper", "github", "page"], "rows": ["members", "docs", "reads", "fields", "levels", "ports", "checks", "window", "head", "ws", "tests", "breaks", "forms", "types", "events", "length", "cases", "xs", "ks", "olds", "groups", "planes", "headers", "models", "OWS", "keys", "ips", "values", "cells", "roots", "qs", "ids", "items", " lines", "days", "rules", "lines", "vals", "aults", "bytes", "times", "all", "blocks", "rown", "holes", "index", "cs", "ops", "features", "files", "opens", "s", "ows", "heads", "rings", "runs", "rs", "relations", "flows", "d", "pos", "ls", "ros", "errors", "reports", "frames", "tracks", "boxes", "faces", "points", "ries", " columns", "modules", "orders", "posts", "rooms", "ins", " row", "users", "row", "devices", "results", "es", "pages", "views"], "cols": ["colli", " colp", "collcount", "Colabs", " colows", "colds", "colgs", "columnS", " colops", "Colp", "colsd", "columnsi", "COLd", "colp", " colgs", "Coln", "COLabs", "coli", "cld", "colS", " colds", "colb", "columncs", "coln", "yln", "colcount", "Colw", "ylls", "pooli", "Cols", " colw", " colb", "cles", "columncount", "Coli", "Cold", "columnds", "collows", " cold", "dicti", " colS", "columnsd", "columnows", "poolsi", "columns", " coles", "Colls", "columnw", "colops", "colabs", " colabs", "Colows", "coles", "Colts", "threads", "columni", "threadgs", "pools", "columnb", "clcs", " colcount", "COLgs", " colcs", "columnn", "pooln", "colles", "Colsd", "Colb", "dicts", "threadts", "dictn", "COLts", "Colds", " colsi", "columnabs", "colcs", "yls", "colsi", "ColS", " colts", "colw", "colln", " coli", "cold", "columnes", " colls", "ylp", "colls", "columnops", "COLn", "columnd", "columnts", "COLs", "colows", "COLops", " coln", "colts", "COLsd"], "data": ["parent", "model", "feed", "image", "div", "window", "alpha", "source", "breaks", "partial", "cell", "api", "content", "array", "Data", "li", "format", "xxx", "dat", "list", "values", "reader", "buffer", "config", "zip", "cells", "str", "items", "block", "response", "lines", "a", "scale", "di", "next", "bytes", "form", "media", "missing", "all", "blocks", "la", "index", "multi", "result", "code", "append", "table", "output", "body", "group", "dict", "raw", "input", "ata", "d", "pos", "f", "valid", "draw", "string", "default", "text", "json", "post", "sample", "DATA", "batch", "float", "actions", "row", "column", "devices", "load", "memory", "dd", "steps", "da", "results", "arr"], "r": ["j", "v", "e", "rr", "l", "ru", "n", "q", "right", "w", "rh", "col", "rec", "lr", "cr", "s", "R", "ar", "nr", "rc", "row", "sr", "range", "m", "u", "rb", "rs", "b", "ra", "d", "z", "entry", "k", "rar", "f", "er"], "c": ["v", "e", "nc", "uc", "cat", "pc", "cs", "unc", "l", "code", "t", "dc", "n", "lc", "ce", "cu", "col", "rec", "ec", "co", "cr", "s", "h", "arc", "row", "cf", "ci", "xc", "u", "cm", "m", "ic", "b", "d", "C", "ch", "z", "fc", "int", "ct", "cc", "cy", "cell", "k", "cl", "cp", "f", "ac"], "i": ["id", "j", "ii", "e", "v", "ri", "index", "ip", "l", "mi", "n", "lc", "q", "xi", "yi", "iu", "li", "it", "cu", "col", "s", "qi", "si", "oi", "I", "ci", "ini", "u", "ic", "ai", "b", "d", "ch", "z", "ix", "pi", "int", "di", "cell", "f", "io", "ui"], "cls": ["ClS", "clusters", "clp", " clsys", "CLs", "Clp", "Classsb", " Clp", "hells", "wellsb", "hellS", " clusters", "Classsg", "wells", "clsg", "hellsb", "clS", "Clusters", "Cls", "CLsg", "clsb", " clsb", "CLS", " clabs", "wellusters", "CLabs", "Classs", "clabs", "Clsb", "CLsb", "Clabs", "clsys", "Clsys", " Clsys", " Cls", " clp", "Clsg"], "readfunc": ["loadfun", "writefun", "readfun", "writeproc", "loadfunction", " readfun", "writefunc", "loadproc", "readfunction", " readproc", "writefunction", " readfunction", "readproc", "loadfunc"], "_": ["all", "l", "q", "un", "g", "non", "k", "al", "f"], "line": ["inline", "string", "l", "code", "no", "log", "end", "lc", "model", "text", "li", "col", "el", "body", "record", "header", "lo", "LINE", "len", "section", "byte", "reader", "name", "limit", "sync", "file", "row", "buffer", "item", "zip", "range", "input", "column", "base", "str", "lf", "frame", "d", "block", "length", "entry", "lines", "lin", "Line", "cell", "content", "number", "band", "char", "page"]}}
{"code": " \n  \n  \n  directions = list(itertools.product([1, 0, -1], [1, 0, -1]))\n  def count_neighbors(table, r, c):\n      cols = len(table[0])\n      rows = len(table)\n      return sum(table[r + x][c + y] == \"*\" for x, y in directions \n                  if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\n  \n  def is_valid(table):\n      cols = len(table[0])\n      rows = len(table)\n      for r in xrange(rows):\n          for c in xrange(cols):\n              has_zero = any(table[r + x][c + y] == 0 for x, y in directions \n                              if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\n              if table[r][c] != \"*\" and not has_zero:\n                  return False\n  \n      return True\n  \n  \n  def draw_table(table, hide=False):\n      cols = len(table[0])\n      rows = len(table)\n      ascii_table = \"\"\n      for r in xrange(rows):\n          for c in xrange(cols):\n              if table[r][c] != \"*\":\n                  ch = \"c\" if r == 0 and c == 0 else \".\"\n                  table[r][c] = count_neighbors(table, r, c) if not hide else ch\n  \n              ascii_table += str(table[r][c])\n  \n          ascii_table += \"\n\"\n  \n      return ascii_table[:-1]\n  \n  def solve(R, C, M):\n      r = c = 0\n      current_mines = R * C\n      table = [[\"*\"] * C for k in xrange(R)]\n      while M < current_mines:\n          if table[r][c] == '*':\n              table[r][c] = \".\"\n              current_mines -= 1\n  \n          if current_mines > M and r + 1 < R and table[r+1][c] == \"*\":\n              table[r+1][c] = \".\"\n              current_mines -= 1\n  \n          draw_table(table)\n          c += 1\n          if c >= C:\n              c = 0\n              r += 1\n  \n      return table\n  \n  for i in xrange(readint()):\n      R, C, M = readintarray()\n  \n      print \"Case #%d:\" % (i + 1)\n      if M < (R * C) - 1:\n          table = solve(R, C, M)\n          if is_valid(table):\n              print draw_table(table, hide=True)\n          else:\n              table = solve(C, R, M)\n              rotated = [[\"*\"] * C for k in xrange(R)]\n              for r in xrange(R - 1, -1, -1):\n                  for c in xrange(C):\n                      rotated[R - r - 1][c] = table[c][r]\n  \n              print draw_table(rotated, hide=True) if is_valid(rotated) else \"Impossible\"\n  \n      elif M == R * C:\n          print \"Impossible\"\n  \n      else:\n          table = [[\"*\"] * C for k in xrange(R)]\n          table[0][0] = '.'\n          print draw_table(table, hide=True)\n", "substitutes": {"directions": ["directionion", "connections", "connectors", "Directions", "Directations", "irection", "directations", "directionives", "Directories", "structations", "irectories", "directionions", "struction", "connection", "structions", "directors", "directories", "irections", "irectives", "irectors", "Directors", "Direction", "connectories", "structors", "directives", "directionors", "Directives", "irectations", "direction"], "table": ["feature", "root", "transform", "stage", "t", "character", "model", "course", "stream", "col", "image", "term", "div", "window", "master", "app", "range", "interface", "source", "machine", "m", "MM", "chain", "cell", "case", "db", "layer", "Table", "object", "rule", "array", "slice", "time", "core", "stable", "container", "round", "connection", "list", "story", "buffer", "config", "profile", "out", "message", "function", "session", "panel", "tree", "cube", "block", "error", "system", "flat", "form", "tab", "query", "result", "code", "che", "count", "q", "output", "server", "month", "body", "header", "module", "bar", "section", "element", "python", "total", "TABLE", "input", "style", "view", "py", "tr", "frame", "b", "choice", "comment", "f", "data", "database", "e", "figure", "key", "chart", "conference", "cache", "package", "channel", "this", "batch", "article", "file", "row", "sequence", "base", "page", "test"], "r": ["j", "mr", "v", "e", "rr", "fr", "err", "yr", "Rs", "user", "l", "ru", "t", "n", "ro", "br", "rd", "gr", "q", "vr", "right", "w", "rt", "dr", "rh", "o", "lr", "rec", "cr", "g", "ir", "ar", "h", "kr", "nr", "rc", "row", "sr", "range", "pr", "ur", "hr", "m", "u", "rb", "rs", "tr", "b", "p", "ra", "d", "rg", "a", "re", "f", "er"], "c": ["v", "nc", "t", "ca", "ce", "course", "cu", "col", "arc", "rc", "cn", "xc", "m", "cm", "chain", "cat", "l", "n", "lc", "cr", "sc", "con", "function", "p", "fc", "a", "ct", "_", "ac", "uc", "cs", "code", "dc", "count", "q", "rec", "s", "ar", "cf", "ci", "u", "mc", "vc", "b", "d", "cc", "f", "e", "pc", "unc", "oc", "cache", "w", "o", "ec", "co", "g", "h", "cd", "z", "cy", "cl", "cp"], "cols": ["columnsym", "lls", "columnlines", "critubs", "calments", "patherences", "colsym", " colws", "colours", "columnsi", "columnx", "pathments", " colours", "methodws", "icolses", "filx", "columnubs", "filops", "columncs", "calcs", "colways", "rolls", "colerences", "columnws", " colways", " colments", "colments", "llops", "columns", "lengths", "colops", "icolws", " colsym", "poolubs", "critments", "contracts", "colss", "pathcs", "pools", "poolments", "methodses", "colubs", " colses", "methods", "columnses", "rollways", "contractcs", "lengthsym", "rollss", " colcs", "icols", "columnments", "colws", "critlines", "COLws", "COLses", "colses", "llws", "calerences", " colss", "contractsi", "llsi", "colcs", "colsi", " colerences", "llx", "llcs", "poollines", "filses", "cals", "columnops", "contractws", "crits", "colx", "lengthws", "llses", "COLs", "lengthses", "rollours", "paths", "collines", "fils"], "rows": ["blocks", "rown", "members", "groups", "holes", "planes", "olds", "cs", "rog", "ubs", "OWS", "ries", "ums", "features", "levels", "fields", "cats", "rh", "orders", "posts", "checks", "cr", "rooms", "classes", "rew", "opens", "ips", "ows", "users", "heads", "values", "wards", "ws", "rc", "tests", "row", "ow", "roc", "cells", "roots", "ids", "runs", "breaks", "forms", "vers", "relations", "rs", "rw", "items", "acks", "flows", "types", "events", "results", "rules", "length", "ros", "reports", "lines", "errors", "frames", "cases", "pages", "tracks", "boxes", "times", "views", "ks"], "x": ["rx", "j", "Y", "e", "v", "id", "xx", "index", "px", "l", "t", "ys", "n", "xy", "tx", "time", "wy", "xi", "ay", "w", "any", "fx", "o", "on", "X", "s", "ex", "h", "xes", "xml", "ya", "win", "ci", "xc", "my", "py", "xt", "u", "m", "ic", "b", "p", "d", "cross", "z", "ix", "ey", "ax", "int", "a", "ct", "ye", "dy", "cy", "es", "xs", "wx", "work", "f", "lex", "com"], "y": ["Y", "j", "ym", "e", "sy", "yr", "yt", "ky", "ys", "t", "n", "ny", "wy", "vy", "ies", "yd", "yi", "ay", "w", "col", "yy", "s", "h", "yn", "ya", "iy", "ty", "yl", "py", "ci", "ry", "m", "zy", "b", "p", "d", "z", "ey", "ye", "dy", "cy", "oy", "f", "hy"], "has_zero": ["have_zero", "has_one", "have_Zero", "has_0", "have_money", "have_one", "has_money", " has_one", " has_0", " has_alpha", "has_Zero", "has_alpha"], "hide": [" show", "id", "sea", "late", "ignore", "code", "child", " hidden", "home", "ha", "mask", "hidden", "disable", "shift", "li", "label", "show", "rub", "que", "ise", "fe", "h", "fit", "bar", "info", "hi", "ider", "use", "Hide", "fake", "cover", "shadow", "ib", "plot", "layout", "broad", "ride", "display", "isi", "sub", "shown", "ide", "secret", "case", "bare", "loc", "hid"], "ascii_table": ["asciini_list", "asciini_body", "asciio_section", "asciietlist", "ascii_section", "ascii_body", "ascii_trace", "ascii2section", "asciiettable", "asciui_Table", "asciio_trace", "ascii_list", "asciui_table", "asciui_cache", "asciietcomb", "ascii2trace", "ascii2table", "asciini_term", "ascii_Table", "asciini_table", "asciui_body", "ascii_term", "ascii_cache", "ascii_comb", "asciini_comb", "asciini_section", "asciio_table"], "ch": ["j", "cb", "e", "root", "code", "che", "chart", "chrom", "n", "character", "channel", "cr", "div", "h", "chi", "cd", "conf", "sch", "ci", "qu", "Ch", "chan", "CH", "cur", "chain", "cor", "cl", "cp", "case", "f", "char"], "R": ["Rh", "Y", "N", "T", "GR", "Rs", "P", "MR", "J", "RH", "CR", "Re", "E", "G", "H", "SR", "RM", "W", "RO", "K", "X", "Q", "I", "B", "RP", "D", "F", "Cr", "Ra", "O", "S", "RR", "V", "A", "L", "U", "RA"], "C": ["Y", "N", "T", "P", "VC", "DC", "CM", "CR", "CF", "E", "H", "G", "W", "K", "X", "CC", "Q", "CW", "I", "B", "D", "F", "CI", "Ch", "O", "S", "Z", "MC", "V", "CU", "A", "L", "U"], "M": ["N", "Y", "T", " m", "P", "MS", "Ma", "J", "CM", "E", "G", "H", "RM", "W", "K", "X", "MW", "Q", "I", "B", "MF", "D", "F", "MM", "m", "O", "S", "Mi", "Z", "MC", "V", "L", "U"], "current_mines": ["current_Minions", "current_minodes", "current_minser", "current_minors", "current_masterodes", "current_masteres", "current_minsizes", "current_minse", "current_minES", "current_minses", "current_minsES", "current_partes", "current_Minizes", "current_milles", "current_mnodes", "current_manors", "current_manis", "current_millions", "current_maxizes", "current_minizes", "current_masterizes", "current_miner", "current_manions", "current_minss", "current_MinES", "current_minsors", "current_miller", "current_maxe", "current_millES", "current_partions", "current_mnizes", "current_masterions", "current_manes", "current_Miner", "current_minsis", "current_mons", "current_minis", "current_mones", "current_maxions", "current_mnions", "current_versions", "current_mnes", "current_partis", "current_mine", "current_Mines", "current_partors", "current_monizes", "current_monions", "current_maxes", "current_versiones", "current_minsodes", "current_mins", "current_minions", "current_minsions", "current_versionizes", "current_Mine", "current_versionions"], "k": ["king", "ces", "ky", "cs", "n", "ner", "km", "get", "q", "kk", "w", "ck", "co", "g", "K", "cr", "ku", "ket", "ke", "d", "ct", "a", "cc", "cor", "ks"]}}
{"code": " \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(start=0):\n      elems = readintarray()[start:]\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n", "substitutes": {"start": ["x", "part", "id", "e", "v", "index", "st", "add", "n", "end", "count", "ind", "shift", "stop", "offset", "Start", "set", "len", "ie", "s", "use", "size", "skip", "range", "source", "p", "pos", "int", "next", "k", "f", "seed", "send", "se"], "elems": ["Elems", "lemns", "lemms", "elens", "Elemas", " elemes", "elma", "elms", " elecs", "elemas", "elm", "elements", " elens", "elcs", "elns", "lemcs", "elmes", "elecs", " elema", "elmas", " elements", " elem", "lemments", "Elecs", "elemes", "elema", "lemma", "lemm", "Elemes", "elem", "lemmes", " elemas", "elments"], "i": ["x", "id", "j", "ii", "v", "e", "ri", "bi", "index", " index", " n", "l", "mi", " j", "n", "ind", "xi", "iu", "li", "col", "c", "ti", "qi", "si", "oi", "I", " I", "fi", "ci", "ini", "u", " x", "ai", "p", "z", "ix", "pi", "pos", "int", "a", "di", "k", "f"]}}
{"code": " \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  def print_board(r, c, free):\n      board = {}\n      for row in range(0, r):\n          board[row] = {}\n          for col in range(0, c):\n              board[row][col] = '*'\n  \n      pending = free\n  \n      if free == 1:\n          board[0][0] = '.'\n      elif r == 1 or c == 1:\n          for row in range(0, r):\n              for col in range(0, c):\n                  if pending > 0:\n                      pending -= 1\n                      board[row][col] = '.'\n      else:\n          for row in range(0,2):\n              for col in range(0,2):\n                  board[row][col] = '.'\n          pending -= 4\n          col=2\n          row=2\n  \n          while pending >= 2 and (col<c or row<r):\n              if pending >= 2 and col<c:\n                  board[0][col] = '.'\n                  board[1][col] = '.'\n                  col += 1\n                  pending -= 2\n              if pending >= 2 and row<r:\n                  board[row][0] = '.'\n                  board[row][1] = '.'\n                  row += 1\n                  pending -= 2\n  \n          for row in range(2, r):\n              for col in range(2, c):\n                  if pending > 0:\n                      board[row][col] = '.'\n                      pending -= 1\n  \n      board[0][0] = 'c'\n  \n      for row in range(0, r):\n          line = ''\n          for col in range(0, c):\n              line += board[row][col]\n          print(line)\n  \n  \n  for t in range(1, ncases+1):\n      values = sys.stdin.readline().strip().split()\n      r = int(values[0])\n      c = int(values[1])\n      m = int(values[2])\n  \n      cells = r * c\n      free = cells - m\n  \n      possible = False\n  \n      if r == 1 or c == 1:\n          if free >= 1:\n              possible = True\n      elif r == 2 or c == 2:\n          if free == 1 or (free >= 4 and free%2 == 0):\n              possible = True\n      else:\n          if free == 1 or (free >= 4 and free != 5 and free != 7):\n              possible = True\n  \n      print(\"Case #{0}:\".format(t))\n  \n      if possible:\n          print_board(r, c, free)\n      else:\n          print(\"Impossible\")\n", "substitutes": {"ncases": ["nsases", "lcasts", "ncased", "lcases", "lcurses", "lcasing", "lcase", "nsasing", "ncasts", "ncurses", "cased", "necased", "casts", "casing", "ncasing", "necases", "lcased", "nsurses", "necasts", "curses", "cases", "case", "nsase", "necase", "ncase"], "r": ["x", "j", "e", "v", "rr", "fr", "err", "yr", "rf", "l", "ru", "br", "n", "ro", "rd", "q", "right", "rt", "w", "order", "o", "g", "cr", "s", "ir", "h", "R", "ar", "kr", "i", "nr", "rc", "nor", "sr", "range", "pr", "ur", "rb", "u", "rs", "tr", "b", "p", "ra", "d", "ch", "z", "rg", "k", "re", "rar", "f", "er", "rn"], "c": ["x", "v", "e", "nc", "pc", "cs", "l", "ru", "n", "dc", "lc", "q", "ca", "ce", "bc", "w", "cu", "o", "rec", "ec", "co", "cr", "s", "h", "sc", "i", "R", "rc", "y", "cf", "ci", "con", "cm", "u", "b", "p", "C", "d", "ch", "z", "fc", "cur", "ct", "cc", "a", "cy", "cor", "cell", "k", "cp", "f", "ac"], "free": ["err", "sec", "low", "price", "complete", "const", "floor", "len", "cle", "available", "size", "unit", "range", "current", "random", "Free", "rule", "rf", "no", "n", "stable", "un", "lease", "outer", "use", "fre", "left", "out", "con", "function", "found", "fee", "usable", "error", "re", "util", "FREE", "all", "fr", "lower", "required", "mi", "rec", "func", "covered", "raw", "total", "static", "cf", "used", "f", "N", "valid", "version", "min", "open", "e", "sp", "cache", "release", "co", "empty", "fe", "float", "F", "non", "vol", "off", "common", "fun"], "board": ["game", "book", "model", "course", "stream", "feed", "square", "coll", "bridge", "ode", "length", "boarding", "ide", "cell", "bug", "deck", "object", "rule", "array", "card", "core", "que", "stroke", "list", "loop", "plugin", "buffer", "config", "clean", "pool", "block", "boy", "back", "error", "form", "rank", "point", "cart", "word", "flow", "code", "che", " clipboard", "lane", "control", "table", "server", "group", "ward", "ban", "view", "lay", "phone", "layout", "client", "comment", "land", "room", "data", "menu", " dashboard", "ack", "draw", "ko", "home", "bo", "channel", "flo", "Board", "sync", "lock", "sequence", "hole", "builder", "boards", "player", "work", "node", "bank", "design"], "row": ["model", "run", "feed", "coll", "rc", "range", "ear", "roll", "length", "rot", "cell", "hour", "object", "sel", "core", "container", "ou", "offset", "round", "cr", "value", "keep", "micro", "sc", "name", "nt", "roc", "rows", "ry", "ull", "block", "arrow", "error", "scale", "system", "re", "form", "rank", "word", "flow", "rown", "uc", "rr", "index", "query", "user", "q", "day", "table", "server", "month", "order", "group", "ward", "module", "bar", "raw", "wheel", "mod", "y", "max", "view", "u", "tr", "ver", "device", "ch", "cur", "port", "record", "x", "Row", "ack", "key", "draw", "ko", "ro", "oc", "right", "post", "w", "channel", "rh", "o", "co", "h", "sync", "ow", "column", "rw", "year", "entry", "rect", "node", "loc", "mo", "page"], "col": ["ail", "cond", "ca", "sect", "field", "ref", "collection", "coll", "seq", "arc", "cn", "win", "can", "color", "cm", "length", "chain", "rot", "cell", "j", "cat", "sel", "l", "n", "cal", "lc", "core", "ou", "ll", "name", "nt", "cycle", "left", "num", "il", "con", "p", "block", "COL", "fc", "ct", "cor", "car", "point", "ac", "word", "fn", "count", "q", "day", "act", "pixel", "ell", "el", "Col", "enc", "rel", "fl", "y", "ci", "vc", "ch", "oy", "f", "x", "min", "key", "patch", "child", "ro", "w", "channel", "path", "co", "g", "flo", "file", "ow", "column", "year", "int", "cy", "cl", "cp", "loc", "io", "temp", "char", "page"], "pending": ["cpadding", "cpend", "apending", "apended", "lpend", "pend", "lpended", "fadding", "fended", "spoding", "opadding", "apaging", "pushed", "Pended", "npadding", "fending", "opending", "lpaging", "panging", "spending", "opushed", "Pushed", "spadding", "jpending", "cpending", " pended", "lpushed", " pushed", " poding", "padding", "Pending", "jpend", "foding", "npending", "opended", "spanging", "Panging", "spend", "spaging", "ppending", "opend", "ppaging", " paging", "jpoding", "jpushed", "npend", "apushed", "ppend", "ppended", " pend", "npoding", "Poding", "pended", " padding", "poding", "paying", "opaging", "jpended", "Pend", "paging", "opaying", "spended", "opoding", "Paging", "cpended", "Padding", "lpending", "npanging", "npended", "jpaying", " paying"], "line": ["definition", "inline", "object", "string", "l", "code", "log", "text", "li", "feed", "el", "LINE", "value", "cle", "pe", "section", "name", "letter", "file", "item", "zip", "le", "range", "message", "long", "source", "base", "str", "lf", "write", "frame", "block", "strip", "entry", "lines", "lin", "link", "comment", "cell", "cl", "content", "point", "page"], "t": ["e", "tab", "T", "cat", "cut", "l", "n", "time", "table", "task", "tile", "it", "te", "co", "lo", "got", "ti", "type", "i", "toc", "nt", "y", "tr", "d", "ct", "f", "times"], "values": ["comments", "blocks", "members", "lists", "vs", "changes", "docs", "grades", "fields", "keys", "ports", "players", "settings", "files", "value", "ms", "gets", "ves", "verts", "codes", "bs", "seconds", "fine", "tests", "vi", "objects", "pins", "places", "roots", "strings", "rows", "forms", "items", " lines", "details", "events", "flows", "results", "days", "rules", "boards", "names", "lines", "images", "es", "frames", "vals", "xs", "bytes", "pages", "views", "Values", "maps", "dates"], "m": ["v", "e", "mi", "l", "n", "q", "mm", "w", "o", "mn", "co", "ms", "s", "i", "y", "mass", "margin", "num", "range", "fm", "con", "cm", "u", "mc", "b", "p", "d", "z", "nm", "cell", "f", "M"], "cells": ["blocks", "members", "v", "ns", "groups", "planes", "cs", "l", "models", "n", "features", "levels", "fields", "cats", "keys", "mins", "files", "ells", "classes", "ms", "s", "fe", "units", "y", "runs", "breaks", "rows", "cm", "mc", "items", "b", "p", "flows", "states", "rules", "lines", "frames", "cell", "pages", "bytes", "faces", "f", "ks"], "possible": ["Porsche", " porsche", " picted", "spossibly", "pable", "Pausible", "cossible", "xpossible", " pable", "Picted", "picted", " possibly", "possibility", "pausible", "porsche", " pausible", "xpable", "possibly", "Pable", "causible", "xpossibility", "Possible", "spossibility", "spossible", "sporsche", "Possibility", "Possibly", "xpicted", " possibility", "cossibly", "cossibility"]}}
{"code": " \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  def read_arrangement():\n      arr = []\n      for row in range(0,4):\n          arr.append(sys.stdin.readline().strip().split(' '))\n      return arr\n  \n  for t in range(1, ncases+1):\n      answer1 = int(sys.stdin.readline().strip())\n      arrang1 = read_arrangement()\n      answer2 = int(sys.stdin.readline().strip())\n      arrang2 = read_arrangement()\n  \n      row1 = arrang1[answer1-1]\n      row2 = arrang2[answer2-1]\n  \n      intersect = set(row1) & set(row2)\n  \n      if len(intersect) == 1:\n          print(\"Case #{0}: {1}\".format(t, intersect.pop()))\n      elif len(intersect) == 0:\n          print(\"Case #{0}: Volunteer cheated!\".format(t))\n      else:\n          print(\"Case #{0}: Bad magician!\".format(t))\n", "substitutes": {"ncases": ["ncances", "nsases", "ncodes", "necannels", "NCannels", "ncones", "ncased", "NCances", "nsannels", "aucases", "ncannels", "NCodes", "necances", "NCased", "nsasing", "aucased", "necased", "necasing", "NCasing", "ncasing", "necases", "aucodes", "necodes", "NCones", "necones", "nsances", "aucones", "NCases"], "arr": ["adr", "par", "x", "all", "fr", "ray", "ann", "res", "err", "cat", "append", "array", "br", "bl", "l", "n", "gr", "train", "r", "dat", "align", "abc", "g", "dict", "list", "i", "ar", "enc", "aa", "attr", "coll", "seq", "arc", "au", "Ar", "att", "img", "Array", "app", "adj", "acc", "str", "ext", "p", "av", "aj", "air", "rep", "ab", "obj", "stack", "a", "data", "mat", "test"], "row": ["x", "v", "e", "insert", "user", "array", "time", "ay", "r", "w", "col", "order", "week", "seq", "ow", "num", "rows", "u", "d", "line", "obj", "f"], "t": ["ait", "x", "e", "v", "T", "st", "l", "n", "time", "q", "tf", "task", "r", "w", "it", "te", "tt", "o", " T", "at", "g", "c", "s", "type", "i", "name", "title", "nt", "tests", "y", "ta", "num", "kt", "ty", "tim", "dt", "m", "tr", "the", "tz", "b", "p", "d", "ab", "tm", "ts", "f", "tower", "test"], "answer1": ["response1", "issueone", "issue1", "answer91", "response2", "issue2", "reply2", "responseone", " answer91", "row91", "answerone", "reply91", " answerone", "reply1"], "arrang1": ["arrang0", "arrangingOne", "arrannFirst", "arrange2", "arrang3", "arrangOne", "arrongOne", "arrangeOne", "arong3", "arrong1", "arranging2", "arong2", "arangFirst", "arranging1", "arrbangFirst", "arangOne", "arong0", "arrann3", "arrann1", "arrong2", "arrbang1", "arranging0", "arrbang3", "arang0", "arrong0", "arrbangOne", "arrange1", "arrong3", "arrannOne", "arongOne", "arrangFirst", "arongFirst", "arrongFirst", "arong1", "arang3", "arang2", "arrange0", "arang1"], "answer2": ["response1", "array02", " answerTwo", "resultTwo", "issue102", "result02", "response02", "answer102", "reply102", "array2", "response2", "answer02", "issue2", "result1", "reply2", "issue02", "reply02", "responseTwo", "array102", "answerTwo", " answer02", "result2"], "arrang2": ["arrlang2", "arranchtwo", "arrang0", "arrng2", "arrang3", "arranch1", "arrangtwo", "arrng3", "arong3", "arrong1", "arong2", "arragtwo", "arranchTwo", "arranch2", "arong0", "arangtwo", "arragTwo", "arrong2", "arrng1", "arrag1", "arang0", "arrlang1", "arrong0", "arrangTwo", "arongTwo", "arrong3", "arrag2", "arrlang3", "arrng0", "arongtwo", "arrongtwo", "arrlang0", "arrongTwo", "arong1", "arang2", "arangTwo", "arang3", "arang1"], "row1": ["ro1", "ro2", "feed3", "row0", "rows1", "feed2", " row0", "feed0", "row3", "ro5", "feed1", "rows5", "rows0", "rows3", " row3", "ro3", " row5", "row5", "rows2"], "row2": ["col4", "row42", "row4", "array42", "col1", " rowtwo", "array2", " row42", "Row2", "arrayb", "rows4", "rows1", "rows02", "rows2", "rowb", "rowtwo", " row4", "Rowb", "Rowtwo", "arraytwo", "Row42", " row02", "col2", "row02", " rowb", "col02"], "intersect": ["surcept", "corsections", "interrupt", "intercept", "earrupt", "verect", "consect", "INTERcept", "earsect", "surect", "Intercept", "conect", "partsection", "interect", "intersections", "Intersections", "intersection", "conrupt", "INTERect", "partcept", "partect", "earsection", "sursection", "sursect", "consection", "corsection", "INTERsect", "concept", "Interrupt", "Interect", "INTERsection", "consections", "corect", "versection", "corsect", "versect", "Intersection", "partsect", "vercept", "Intersect", "earcept"]}}
{"code": " \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      return [reader(f, *args, **kwargs) for i in range(R)]\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      return read_ints(f)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      if isinstance(res, list):\n          res[0][0] = 'c'\n          res = '\n'.join(''.join(c for c in r) for r in res)\n      f.write('\n%s'%res)\n      f.write('\n')\n  \n  \n  def solve_small(case):\n      (R, C, M) = case\n      if R == 1:\n          return 'c' + '.'*(C-M-1) + '*'*M\n      if C == 1:\n          return '\n'.join(['c'] + ['.']*(R-M-1) + ['*']*M)\n      m = R*C - M\n      res = [['*']*C for r in range(R)]\n      if m == 1:\n          return res\n      for r in range(2, R+1):\n          c = m // r\n          z = m % r\n          if c < 2 or c + (z>0) > C:\n              continue\n          if z == 1 and (r < 3 or c < 3):\n              continue\n          for x in range(r):\n              for y in range(c):\n                  res[x][y] = '.'\n          for y in range(z):\n              res[y][c] = '.'\n          if z == 1:\n              res[z][c] = '.'\n              res[r-1][c-1] = '*'\n          return res\n      return 'Impossible'\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'f'\n  \n", "substitutes": {"f": ["fold", "j", "e", "fr", "v", "ff", "rf", "uf", "l", "t", "fo", "tf", "fa", "af", "w", "fd", "fx", "feed", "this", "files", "func", "bf", "g", "fe", "s", "h", "info", "self", "fit", "conf", "inf", "file", "fen", "fw", "cf", "F", "fi", "of", "fm", "fp", "u", "function", "lf", "fed", "frame", "p", "fs", "fb", "df", "xf", "buff", "fc", "a", "ft", "form", "sf", "fun"], "b": ["j", "v", "e", "bi", "l", "t", "n", "end", "nb", "w", "o", "body", "bf", "g", "s", "h", "bs", "bb", "sb", "B", "base", "u", "lb", "rb", "wb", "p", "ab", "length", "a", "dy", "k", "be", "db"], "x": ["rx", "id", "j", "v", "e", "xx", "xe", "valid", "index", "xb", "l", "t", "n", "xy", "get", "q", "xi", "fx", "w", "xxxx", "xxx", "g", "X", "s", "ex", "h", "xp", "bit", "max", "xa", "num", "input", "xc", "u", "p", "xf", "ix", "ax", "int", "wx", "xs", "k", "_", "word"], "d": ["id", "j", "dl", "e", "v", "ds", "l", "t", "dc", "end", "n", "w", "fd", "ld", "o", "dat", "g", "dim", "h", "cd", "name", "ad", "split", "nd", "D", "dt", "dd", "sd", "u", "p", "dx", "do", "da", "dy", "md", "a", "dir", "di", "k", "data", "db"], "R": ["TR", "N", "Y", "GR", "Rs", "Range", "P", "RE", "J", "CR", "RH", "Re", "U", "JR", "E", "rh", "H", "G", "SR", "RM", "W", "RF", "RO", "K", "X", "Q", "DR", "RS", "I", "B", "range", "RP", "D", "F", "AR", "RG", "RC", "O", "RN", "RL", "S", "CL", "RR", "Res", "A", "L", "V", "RA"], "reader": ["instance", "rr", "array", "ner", "slice", "lc", "Reader", "writer", "driver", "w", "feed", "loader", "ctor", "reading", "value", "rc", "row", "parser", "finder", "input", "inner", "handler", "method", "rb", "rw", "library", "builder", "ride", "read", "length", "entry", "runner", "argument", "iter", "callback", "er", "io", "wrapper", "transfer", "upper"], "i": ["id", "j", "ii", "e", "v", "bi", "ri", "index", "im", "ip", "l", "t", "mi", "n", "phi", "ind", "q", "xi", "li", "iu", "it", "ti", "gi", "qi", "s", "chi", "si", "I", "uri", "ni", "ci", "fi", "ini", "iq", "u", "ai", "p", "ix", "pi", "int", "a", "di", "k", "zi", "io"], "solver": [" solve", "insolve", "Solving", "ssolver", "solves", "soper", " solving", "seolver", "seolves", "insolver", "insolving", "Soper", "Solve", "Solver", "seolve", "solving", "insoper", "seolving", "ssolves", "ssolve", "ssolving", "Solves", "solve", " soper"], "fn": ["v", "nc", "fat", "n", "dn", "output", "fa", "filename", "fd", "format", "o", "path", "sn", "wt", "h", "enc", "kn", "name", "fl", "cn", "file", "fen", "native", "syn", "out", "fi", "fp", "function", "ln", "write", "typ", "p", "lib", "FN", "fb", "orn", "fc", "feat", "nm", "io", "loc", "node", "fun"], "out_fn": ["outqfc", "flat_fn", "outPn", "output_path", "flatingfn", "flatingfc", "out_path", "out_fd", "out2filename", "flatingfp", "outPfn", "out_fc", "extraPfp", "outFilepath", "output_fun", "output_fp", "extraPfunc", "out_fun", "extra_fn", "outqbin", "out_file", "out_fp", "extraPfn", "out_func", "flatingbin", "extra_func", "extraPn", "in_filename", "outqfp", "out2fd", "outFilefn", "extra_fp", "out2file", "out2fn", "outingfp", "in_fd", "outingfc", "outFilefp", "out_filename", "outPfp", "flat_fp", "outFilefun", "out_bin", "outingbin", "flat_fc", "outingfn", "outqfn", "outPfunc", "out_n", "extra_n", "in_file", "flat_bin", "output_fn"], "in_fn": ["in_filename", "in_folder", "in_fp", "inwfp", "in_fil", "bin_fp", "bin_filename", "inwmn", "out_folder", "inwfn", "bin_mn", "inwfilename", "out_fil", "in_mn", "bin_fn", "out_fp"], "T": ["N", "Y", "t", "P", "J", "TS", "U", "E", "G", "H", "W", "X", "NT", "Q", "I", "B", "TA", "D", "F", "CI", "O", "S", "Z", "p", "A", "L", "V"], "case": ["instance", "fact", "e", "uc", "key", "string", "result", "code", "change", "cer", "default", "slice", "fo", "end", "trial", "time", "ace", "ce", "catch", "rice", "cache", "fa", "cas", "shape", "ise", "match", "ice", "X", "type", "sc", "pe", "section", "info", "use", "config", "profile", "switch", "rest", "fi", "base", "function", "call", "p", "ch", "ride", " CASE", "force", "Case", "ase", "cases", "cl", "cp", "loc", "pair", "test"], "res": ["remote", "err", "ri", "gr", "pres", "spec", "match", "RES", "rez", "rap", "rc", "esc", "cases", "ches", "resp", "ps", "rx", "ns", "ras", "Result", "core", "catch", "su", "os", "ex", "rest", "out", "fi", "p", "details", "response", "resource", "error", "Case", "re", "mr", "fr", "ces", "cs", "Rs", "result", "vre", "rec", "s", "rs", "ch", "ros", "data", "e", "ro", "rice", "right", "rh", "ms", "exc", "rev", "val", "ret", "reg", "RS", "req", "resolution", "results", "rem", "Res", "es", " Res", "arr", "ris"], "c": ["v", "e", "uc", "unc", "cs", "l", "t", "n", "dc", "lc", "w", "cu", "rec", "co", "h", "sc", "cd", "anc", "rc", "cn", "cf", "ci", "xc", "con", "p", "ch", "ct", "a", "cc", "k", "cp", "ac"], "r": ["all", "v", "e", "err", "ri", "result", "ru", "l", "br", "n", "ro", "gr", "w", "rh", "co", "cr", "rm", "ir", "h", "rc", "rl", "range", "ur", "rb", "str", "rs", "u", "p", "re", "pr"], "C": ["N", "Y", "NC", "SC", "P", "VC", "DC", "Cl", "E", "G", "H", "W", "CA", "K", "X", "CO", "Q", "CC", "CS", "I", "B", "Cu", "CW", "D", "F", "CI", "Cr", "Ch", "O", "S", "CL", "MC", "V", "CU", "CN", "A", "L", "U"], "M": ["N", "Y", "MD", "P", "MQ", "J", "CM", "E", "G", "MX", "MI", "H", "RM", "W", "X", "Q", "CC", "I", "B", "MF", "D", "F", "LM", "MM", "O", "S", "Z", "MN", "MC", "V", "A", "L", "U"]}}
{"code": " \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      return [reader(f, *args, **kwargs) for i in range(R)]\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      R1 = read_int(f)\n      Q1 = read_arr(f, 4)\n      R2 = read_int(f)\n      Q2 = read_arr(f, 4)\n      return (R1, Q1, R2, Q2)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%s'%res)\n      f.write('\n')\n  \n  \n  def solve_small(case):\n      (R1, Q1, R2, Q2) = case\n      s = set(Q1[R1-1]) & set(Q2[R2-1])\n      if len(s) == 0:\n          return 'Volunteer cheated!'\n      if len(s) == 1:\n          return s.pop()\n      return 'Bad magician!'\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n", "substitutes": {"f": ["fold", "j", "tif", "e", "fr", "v", "ff", "rf", "uf", "l", "t", "fo", "tf", "fa", "af", "r", "w", "fd", "fx", "feed", "this", "files", "func", "bf", "g", "c", "fe", "h", "info", "fit", "fam", "conf", "fore", "inf", "file", "fen", "fw", "fish", "cf", "F", "fi", "of", "fm", "fp", "m", "u", "function", "lf", "fed", "frame", "p", "fs", "fb", "df", "xf", "fff", "buff", "fc", "full", "ft", "fac", "die", "form", "sf", "fun"], "b": ["j", "v", "e", "bi", "l", "t", "n", "bc", "nb", "r", "w", "o", "body", "bf", "g", "c", "h", "bs", "bb", "sb", "y", "B", "m", "base", "u", "lb", "rb", "ib", "wb", "p", "fb", "z", "ab", "length", "a", "dy", "k", "be", "db"], "x": ["rx", "id", "j", "v", "e", "xx", "xe", "xxxxxxxx", "index", "xb", "l", "t", "n", "xy", "get", "q", "xi", "fx", "w", "r", "xxx", "co", "g", "X", "c", "ex", "h", "self", "xp", "bit", "y", "xa", "num", "input", "xc", "u", "m", "p", "xf", "z", "ix", "ax", "int", "xs", "k", "_", "wx", "word"], "d": ["id", "j", "e", "dl", "v", "ud", "ds", "l", "t", "dc", "n", "end", "dh", "r", "w", "fd", "ld", "o", "dat", "g", "c", "dim", "h", "cd", "name", "ad", "y", "split", "nd", "D", "dt", "m", "dd", "u", "p", "dx", "do", "da", "z", "diff", "dy", "dir", "di", "k", "dm", "data", "db"], "R": ["N", "Y", "Rs", "P", "J", "CR", "r", "H", "G", "SR", "RM", "W", "RF", "RO", "X", "Q", "I", "B", "D", "F", "RG", "runs", "rb", "O", "RN", "S", "C", "RR", "V", "NR", "M", "A", "L", "U", "RA"], "reader": ["rx", "rr", "array", "slice", "lc", "Reader", "writer", "driver", "r", "w", "spec", "dr", "format", "feed", "loader", "reading", "value", "RW", "rc", "row", "parser", "finder", "buffer", "input", "inner", "handler", "method", "source", "rb", "function", "rw", "df", "ride", "read", "length", "entry", "runner", "argument", "iter", "er", "io", "wrapper", "transfer", "word"], "i": ["id", "j", "ui", "ii", "e", "v", "ri", "bi", "index", "im", "ip", "mi", "t", "l", "n", "phi", "ei", "ind", "q", "xi", "iu", "r", "li", "it", "col", "c", "ti", "gi", "qi", "type", "chi", "y", "si", "I", "uri", "ni", "ci", "fi", "ini", "u", "m", "ic", "ai", "p", "z", "ix", "pi", "int", "a", "di", "k", "zi", "io"], "solver": [" solve", "saver", "Solving", "ssolver", " solving", "seolver", " saver", "safer", "Solve", "Solver", "seolve", "solving", "ssaver", "seafer", "seolving", " safer", "ssolve", "Saver", "Safer", "ssolving", "solve"], "fn": ["v", "nc", "rf", "fat", "n", "output", "fa", "filename", "fd", "format", "o", "path", "bf", "sn", "c", "wt", "h", "kn", "name", "fl", "cn", "file", "fen", "native", "syn", "out", "fi", "fp", "function", "ln", "document", "p", "FN", "fb", "fc", "feat", "nm", "io", "node", "fun"], "out_fn": ["outUfp", "in_n", "outUfile", "in_filename", "biningfp", "output_file", "in_fp", "out_function", "outUfn", "outlogfn", "outUfolder", "bin_cf", "output_folder", "out_fc", "outlogfp", "in_function", "output_fp", "biningcf", "bin_fc", "bin_fp", "outingfn", "out_folder", "biningfc", "outingcf", "out_n", "outingfp", "out_cf", "outingfc", "in_file", "out_file", "out_fp", "bin_fn", "out_filename", "biningfn", "outlogcf", "outlogfc", "output_fn"], "in_fn": ["in_sn", " in_path", " in_fp", "out_fd", "in_fp", "out_dn", "in_path", "in_fd", "in_dn", " in_sn", "out_fp"], "T": ["N", "Y", "t", "P", "TS", "U", "E", "G", "H", "W", "X", "type", "NT", "Q", "I", "B", "TA", "D", "F", "CI", "Type", "O", "CT", "S", "Z", "C", "M", "A", "L", "V"], "case": ["instance", "fact", "id", "sea", "e", "key", "string", "result", "code", "default", "P", "slice", "trial", "core", "ace", "ce", "catch", "rice", "fa", "cas", "time", "q", "cache", "r", "feed", "shape", "ise", "co", "match", "ice", "c", "X", "type", "lic", "pe", "info", "sc", "exc", "section", "conf", "config", "profile", "switch", "fi", "base", "p", "ch", "C", "ride", "sub", "force", "Case", "ase", "cases", "_", "pair", "test"], "res": ["mr", "us", "err", "result", "Result", "rice", "catch", "pres", "su", "ce", "r", "os", "spec", "rh", "ise", "co", "me", "match", "RES", "ms", "exc", "rev", "rap", "rc", "ress", "val", "ret", "reg", "sr", "rest", "range", "out", "fi", "req", "rs", "resolution", "details", "ch", "results", "response", "resource", "rem", "Res", "error", "Case", " Res", "re", "resp", "ris"], "R1": [" RONE", "I1", "RONE", "R81", "QONE", "R4", "Q81", "r1", "Run81", "X2", "Run001", "r4", "X81", "X4", "QOne", "ROne", " ROne", "I0", "r2", "R01", "X1", "RR0", " R81", "Q0", "P2", "P1", " R001", "r81", "Run1", "R001", "RR1", "RR2", "I2", "RunONE", "Q4", " R01", "P01", "POne", "Q01", "R0", "Q001"], "Q1": ["R4", "Query2", "X31", "Query1", "P3", "q4", "R9", " Q10", " Q31", "R3", "Qu1", "q2", " Q9", "Qu31", "Q6", " Q3", "Qu3", "X6", "Qu6", "Q10", "X1", "QU2", "R10", "q1", "Query4", " Q6", "P2", "P1", "RN", "QU10", " QN", "P9", "QUN", "QN", "QU1", "X3", "Q4", "Q9", "Q31", "Q3"], "R2": ["R4", "r02", "r14", "QB", "R5", "Rh2", " Rsecond", "Q72", " R14", "Rhsecond", " R4", "r1", "r5", "r4", "RB", "R02", " R0", "R14", "Q14", "Qsecond", "Rh02", " R72", "r0", "r8", "r2", "RA4", "Rsecond", "rB", "RA2", "RA8", "RA5", "Q0", " R5", "Rh72", "R8", " RB", "Q02", " R02", " R8", "Q4", "R72", "R0"], "Q2": ["R4", "IQ02", "Query2", " Q12", "R5", "q14", "q12", "q_", "Query1", "Query22", "IQ2", "q4", "qtwo", "Q62", " Qtwo", "R22", "q2", "R14", "Q14", "R62", "Q12", "P5", "IQ_", "Query62", " Q14", "q1", "Qtwo", "Q22", "P2", "P1", "P4", "q5", "q62", "Q02", "IQtwo", "Q5", " Q_", "q02", "Q4", "Q_", " Q02", "R12", "q22"], "s": ["v", "e", "ns", "string", "cs", "l", "t", "n", "slice", "args", "r", " S", "sym", "sections", "sets", "g", "c", "services", "h", "type", "set", "parts", "ses", "sb", "ws", "sync", "y", "start", "gs", "strings", "ss", "u", "m", "S", "p", "session", "a", "es", "cases", "ssl"]}}
{"code": "__author__ = 'jrokicki'\n  \n  RL = lambda: sys.stdin.readline().strip()\n  IA = lambda: map(int, RL().split(\" \"))\n  LA = lambda: map(long, RL().split(\" \"))\n  FA = lambda: map(float, RL().split(\" \"))\n  \n  T = int(sys.stdin.readline())\n  \n  def clear(R,C,b, x, y):\n      b = b[:]\n      n = 0\n      for i in range(max(0,x-1), min(R,x+2)):\n          for j in range(max(0,y-1), min(C, y+2)):\n              if b[C*i+j] == '*':\n                  n += 1\n                  b = b[:C*i+j] + '.' + b[C*i+j+1:]\n      return b, n\n  mem = dict()\n  def pb(R,C,b):\n      for x in range(R):\n          print b[x*C:x*C+C]\n  \n  def board(R,C,b,x,y,M,m):\n      global mem\n      print x\n      key = (R,C,b,M,x,y,m)\n      if key in mem: return mem[key]\n      if x >= R or y >= C:\n          mem[key] = None\n      else:\n          lb = b\n          n = 0\n          good = False\n          for i in range(y,C):\n              nb,nn = clear(R,C, lb, x, i)\n              n += nn\n              if m - n - M == 0:\n                  mem[key] = nb\n                  good = True\n                  break\n              elif m - n - M < 0:\n                  break\n              lb = bb\n          mem[key] = board(R,C,bb,M,x+1,0,m-n)\n      return mem[key]\n  \n  for CASE in range(T):\n      R,C,M = IA()\n      IMPOSSIBLE = \"Impossible\"\n  \n      b = \"\"\n      cleared = R*C-M\n      for x in range(R):\n          b += \"*\" * C\n      if M == R*C-1:\n          b = \"c\" + b[1:]\n          answer = b\n      else:\n          good = False\n          x,y = 0,0\n          q = [(b,0,0,0)]\n          mem = {}\n          while not good and q:\n              board,total_cleared,x,y = q.pop(0)\n              if (board,total_cleared,x,y) in mem:\n                  continue\n              mem[(board,total_cleared,x,y)] = True\n              if x >= R: continue\n              if y >= C:\n                  q.append((last_board,total_cleared,x+1,0))\n                  continue\n              last_board = board\n              new_board, cleared_mines = clear(R,C,last_board,x,y)\n              total_cleared += cleared_mines\n  \n              if total_cleared == cleared:\n                  good = True\n                  last_board = new_board\n                  q = []\n                  break\n              elif total_cleared - cleared == -1:\n                  q.append((new_board,total_cleared,x,y+1))\n                  q.append((new_board,total_cleared,x+1,0))\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\n              elif total_cleared > cleared:\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\n              else:\n                  q.append((new_board,total_cleared,x,y+1))\n              last_board = new_board\n          if good:\n              answer = last_board\n          else:\n              answer = None\n      if not answer:\n          answer = \"Impossible\"\n      else:\n          b = \"\"\n          for x in range(R):\n              b += answer[x*C:x*C+C] + \"\n\"\n          answer = \"c\" + b[1:-1]\n      print \"Case #%d:\n%s\" % (CASE+1, answer)\n  \n", "substitutes": {"__author__": ["__title__", " __version__", "__alias__", " __version___", "__version__", "__version___", "__author___", "__alias___", " __author___", "__title___"], "RL": ["OL", "HR", "VR", "GR", "NL", "UL", "EL", "Ul", "TL", "MR", "QL", "CR", "RB", "REL", "SB", "BL", "SR", "DL", "LU", "LD", "VL", "SL", "LT", "LL", "El", "LC", "ARR", "DR", "RS", "BR", "ML", "rl", "STR", "RC", "IR", "rb", "LR", "IL", "LP", "CL", "LS", "XL", "RR", "HL", "URL", "FL", "WR", "IO", "L"], "IA": ["AE", "IE", "Y", "A", "BA", "area", "ca", "SI", "SA", "CR", "II", "MI", "NI", "CA", "IG", "AA", "Q", "DA", "RA", "I", "TA", "CI", "AR", "ci", "BBC", "IR", "VI", "LI", "IL", "BI", "AI", "MA", "HA", "IB", "a", "IM", "BB", "IO", "GA", "ia", "NA", "IP"], "LA": ["BA", "la", "SA", "SI", "LAN", "AU", "LU", "CA", "LL", "LIB", "LB", "LO", "TA", "LM", "LR", "La", "LI", "LP", "MA", "IL", "LG", "CL", "LS", "Li", "GA", "NA", "LT", "Lu"], "FA": ["FW", "FD", "FFFF", "fa", "FG", "FP", "PLA", "Fi", "FE", "CA", "WA", "GF", "EA", "AA", "FI", "Fe", "MA", "VA", "PA", "HA", "HF", "FB", "Fa", "FF", "FL", "FIN", "AAA", "GA"], "T": ["Y", "N", "TN", "t", "P", "J", "TS", "U", "E", "H", "G", "W", "K", "X", "TX", "Q", "TM", "I", "B", "D", "F", "O", "S", "TT", "Z", "TB", "L", "V"], "R": ["Rh", "Y", "N", "HR", "GR", "Rs", "P", "RE", "MR", "J", "CR", "RH", "Re", "RT", "r", "U", "JR", "E", " r", "H", "G", "SR", "RM", "W", "RO", "K", "X", "ER", "Q", "DR", "RS", "BR", "I", "B", "AR", "D", "F", "RC", "RG", "Ra", "IR", "RI", "RN", "S", "RR", "NR", "KR", "WR", "A", "L", "V", "RA"], "C": ["Y", "N", "NC", "SC", "AC", "Cs", "P", "VC", "DC", "CM", "CR", "CF", "U", "r", "Con", "E", "H", "G", "CE", "W", "CA", "YC", "X", "c", "K", " c", "IX", "Sc", "Co", "Cy", "CC", "Q", "CS", "I", "B", "Cu", "Ca", "KC", "D", "CI", "F", "Cr", "Ch", "CP", "O", "CT", "S", "CL", "Z", "EC", "MC", "CU", "Code", "CN", "A", "L", "V"], "b": ["bp", "id", "v", "bi", "t", "bool", "E", "bs", "sb", "MB", "wb", "ab", "k", "abb", "ba", "db", "l", "bl", "r", "bt", "ub", "beta", "bf", "X", "binary", "bit", "bb", "buffer", "num", "D", "message", "emb", "p", "fb", "a", "_", "bin", "all", "xb", "s", "B", "eb", "u", "rb", "ib", "d", "f", "be", "cb", "e", "bc", "w", "ob", "o", "g", "c", "bu", "bd", "h", "pb", "mb", "base", "z", "gb", "BB"], "x": ["id", "v", "t", " xx", "ay", "hi", "win", "xc", "ax", "k", "xs", "sex", " X", "rx", "Y", "im", "l", "change", "xy", "r", "one", "X", "ex", "xa", "num", "my", "xt", "p", "ix", "a", "_", "rex", "index", "code", "xi", "on", "s", "max", "I", "ci", "u", "dx", "d", "mx", "f", "xe", "min", "e", "xx", "tx", "w", "o", "width", "g", "c", "h", "ic", "ed", "z", "int", "cy", "wx"], "y": ["Y", "ym", "v", "e", "sy", "yr", "yt", "l", "t", "ys", "ny", "time", "vy", "sky", " Y", "ay", "yi", "r", "w", "o", "yy", "c", "s", "h", "type", "yn", "ya", "I", "ty", "yl", "py", "ry", "u", "p", "d", "ch", "z", "ey", "dy", "a", "cy", "yo", "oy", "k"], "n": [" N", "N", "all", "v", "min", "ns", "nc", "e", "l", "t", "no", "np", "ny", "dn", "na", "r", "w", "nl", "un", "net", "o", "g", "init", "sn", "c", "len", "h", "yn", "en", "name", "nt", "cn", "num", "nd", "out", "ni", "u", "ln", "p", "nu", "d", "z", "ne", "k", "f", "number"], "i": ["ji", "id", "Y", "v", "ii", "e", "bi", "index", "im", "ip", "l", "mi", "t", "phi", "ind", "xi", "yi", "li", "r", "iu", "o", "g", "c", "ie", "qi", "hi", "si", "I", "eni", "ni", "ci", "ini", "u", "ai", "p", "d", "z", "ix", "pi", "int", "di", "k", "f", "io", "ia", "ui"], "j": ["ji", "v", "e", "ii", "je", "l", "t", "xy", "J", "jj", "r", "w", "li", "jc", "o", "js", "g", "c", "h", "ie", "jp", "jl", "si", "jo", "u", "p", "d", "ch", "aj", "z", "ix", "ja", "ij", "k", "f"], "mem": ["lim", "image", "term", "ref", "gl", "range", "access", "tm", "note", "ym", "im", "bl", "hw", "ram", "member", "store", "mm", "bm", "value", "info", "nt", "buffer", "num", "large", "nd", "gram", "function", "ME", "nm", "md", "de", "all", "tab", "index", "mi", "temp", "asm", "Mem", "vm", "mod", "max", "item", " Mem", "ib", "mc", "pm", "um", "map", "comment", "data", "am", "summary", "cache", "mor", "comb", "program", "dem", "me", "rm", "sum", "val", "mb", "reg", "BM", "memory", "struct", "EM", " MEM", "lib", " memory", "gb", "rem", "link", "mini", "em", "node", "loc", "imm", "mo"], "M": ["N", "Y", "MD", "v", "P", "MS", "J", "CM", "Ms", "r", "MT", "E", "H", "G", "RM", "W", "K", "X", "c", "NM", "Q", "I", "B", "BM", "MF", "D", "F", "EM", "cm", "O", "S", "Mi", "Z", "p", "MN", "ME", "MC", "V", "A", "L", "U"], "m": ["Y", "mr", "v", "e", "min", "N", "ym", "im", "l", "t", "mi", "r", "w", "mm", "o", "mn", "g", "bm", "c", "ms", "h", "s", "en", "om", "fm", "cm", "u", "mc", "p", "sm", "d", "pm", "z", "tm", "nm", "mini", "dm", "f"], "key": ["id", "parent", "sec", "field", "ck", "col", "ref", "match", "source", "go", "ee", "Key", "note", "k", "cell", "case", "short", "change", "no", "core", "keys", "value", "KEY", "info", "name", "ke", "use", "num", "my", "ry", "p", "kw", "block", "fix", "error", "cor", "number", "index", "code", "count", "order", "rec", "type", "ver", "ne", "f", "N", "e", "ace", "right", "cache", "label", "co", "arg", "c", "val", "sync", "msg", "row", "lock", "switch", "close", "base", "sign", "int", "link", "cy", "loc", "char"], "lb": ["cb", "dl", "la", "bi", "pl", "lt", "l", "bl", "lc", "bc", "lu", "li", "ub", "nl", "lr", "ll", "abc", "bm", "lab", "blog", "pb", "bb", "sb", "lot", "LB", "ml", "rl", "B", "lp", "BBC", "BM", "eb", "acl", "abl", "rb", "cm", "lf", "ln", "wb", "lib", "fb", "afe", "ls", "gb", "lbs", "lin", "lam", "BB", "L"], "good": ["quick", "bug", "valid", "done", "err", "like", "big", "result", " cool", "success", "ok", "bad", "best", "hack", "show", "Good", "kind", " bug", " GOOD", "ready", "wrong", " nice", "better", "slow", "fine", "pretty", "little", "job", "clean", "improve", " bad", "yes", "gy", "broken", "nice", " Good", "fix", "error", "check", "stuff", "comment", "next", "same", "bugs", "fun"], "nb": ["cb", "kb", "nc", "bi", "ns", "np", "ny", "count", "dn", "NB", "bc", "nl", "bf", "bm", "sn", "bd", "len", "nr", "bb", "sb", "nt", "cn", "tmp", "num", "nd", "ni", "adj", "ln", "wb", "nu", "fb", "ab", "dy", "abb", "number", "bn"], "nn": ["fn", "ii", "nc", "ns", "ann", "np", "ny", "dn", "NB", "gn", "NN", "na", "nl", "mn", "sn", "byn", "len", "nv", "kn", "bb", "nr", "nt", "inn", "nd", "ni", "wn", "pn", "ln", "nu", "nm", "dy", "ne", "nan", "nw", "abb", "nz", "bn"], "CASE": ["Rases", "CUASE", "CMASS", "CMODY", "CUases", "CASS", "RODY", "RASS", "CUODY", "Cases", "RASE", "CMASE", "CMases", "CODY", "CUASS"], "IMPOSSIBLE": ["IMPossIVE", "IMpossIBLE", "IMPOSSible", "IMPORTSible", "IMPossIBLE", "IMPENSIVE", "IMpossBILITY", "IMPOSSIVE", "IMpOSSIVE", "IMPORTSIVE", "IMPossible", "IMPORTSIBLE", "IMpossIVE", "IMPossBILITY", "IMpOSSIBLE", "IMPENSIBLE", "IMpOSSBILITY", "IMpOSSible", "IMpossible", "IMPENSBILITY", "IMPORTSBILITY", "IMPENSible", "IMPOSSBILITY"], "cleared": [" cleanned", "CLEanned", "cleed", "CLEaring", "clearing", "Cleed", "cleanned", "Clearing", "CLEed", "CLEared", " clearing", "Cleanned", " cleed", "Cleared"], "answer": ["short", "rr", "err", "result", "reply", "best", "ell", "ll", "abc", "aa", "Answer", "better", "rc", "eb", "question", "fb", "z", "ab", "gain", "gb", "back", "comment", "BB", "blank", "abb", "f", "ac"], "q": ["quick", "id", "qq", "short", "like", "query", " questions", "ll", "g", " quick", "bit", "dq", "Q", "ad", "qt", "qa", "nd", "iq", " question", "p", "question", "z", "buff", "check", "back", "comment", "k", "quit"], "board": ["flow", "bug", "game", "pad", "deck", "uc", "ack", "book", "draw", "forward", "play", "table", "bc", "bo", "cache", "post", "channel", "hack", "program", "ward", "Board", "c", "loop", "row", "buffer", "lay", "hole", "block", "line", "boards", "error", "comment", "player", "bank", "video", "word", "design"]}}
{"code": "__author__ = 'jrokicki'\n  \n  RL = lambda: sys.stdin.readline().strip()\n  IA = lambda: map(int, RL().split(\" \"))\n  LA = lambda: map(long, RL().split(\" \"))\n  \n  T = int(sys.stdin.readline())\n  \n  for CASE in range(T):\n      g1 = IA()[0]-1\n      board1 = []\n      for i in range(4):\n          board1.append(IA())\n      g2 = IA()[0]-1\n      board2 = []\n      for i in range(4):\n          board2.append(IA())\n  \n      r1 = board1[g1]\n      r2 = board2[g2]\n  \n      answer = set(r1).intersection(r2)\n      if len(answer) > 1:\n          answer = \"Bad magician!\"\n      elif len(answer) == 0:\n          answer = \"Volunteer cheated!\"\n      else:\n          answer = list(answer)[0]\n  \n      print \"Case #%d: %s\" % (CASE+1, answer)\n  \n", "substitutes": {"__author__": ["__title__", "_title__", "_title_", "__creator___", "__version_", "__creator__", "_title___", "__version__", "__version___", "__author_", "__author___", "__creator_", "__title_", "_author__", "_author_", "_author___", "__title___"], "RL": ["HR", "VR", "NL", "UL", "EL", "Ul", "TL", "PL", "MR", "CR", "RB", "JR", "BL", "SR", "DL", "lr", "LU", "LV", "VL", "SL", "LT", "LL", "R", "LC", "LB", "ARR", "DR", "RS", "BR", "ML", "RC", "LM", "IR", "LR", "LP", "IL", "CL", "LS", "XL", "RR", "HL", "FL", "WR", "L", "RA"], "IA": ["AE", "IE", "FW", "AV", "PI", "SA", "SI", "LAN", "Area", "IAN", "Wikipedia", "II", "MI", "AU", "KA", "CA", "FA", "WA", "ILA", "SPA", "AA", "API", "EA", "RA", "I", "CHA", "TA", "CI", "ia", "IJ", "LM", "IR", "CIA", "ISA", "ICA", "La", "LI", "IL", "MA", "AI", "LG", "LR", "HA", "ATA", "IB", "League", "IF", "ACA", "AF", "IM", "IO", "IV", "GA", "A", "NA", "IP"], "LA": ["BA", "la", "UL", "SA", "LAN", "CA", "ILA", "LL", "LC", "LO", "TA", "AR", "LM", "LR", "La", "LI", "LP", "MA", "IL", "LG", "PA", "LS", "CLA", "LE", "GA", "KA", "NA", "LU"], "T": ["Y", "N", "TE", "TN", "t", "P", "TF", "DT", "TS", "E", "H", "G", "X", "Time", "R", "Q", "I", "B", "D", "F", "WT", "Type", "TG", "O", "S", "TT", "Z", "C", "M", "A", "L"], "CASE": [" CASS", "cASE", "CPE", " Case", "CACH", "PASE", "CASS", "ACPE", "PACE", "cACH", "ACASS", "ACASE", " CACH", " CACE", "BPE", " CPE", "POPLE", " COPLE", "cACE", "CACE", "COPLE", "BASE", "ACase", "Case", "PACH", "Base", "BASS", "cOPLE"], "g1": [" g01", "ga1", "ga2", "game01", "gone", "agg2", "g01", "gg1", "ggone", "agg1", "gaone", "gg01", "gg2", "game2", "agg01", "gameone", "ga01", "game1"], "board1": ["group0", "row1", "boardOne", "row2", " boardN", "group3", "rowN", "group2", " boardOne", "rowOne", "group1", "boards3", "line2", "row0", "lineN", "rank1", "boards1", "rank0", "board0", "lineOne", "boards2", "row3", "rank2", " board3", "board3", "line1", "rank3", "boardN"], "i": ["x", "j", "ii", "v", "e", "im", "ip", "l", "t", "n", "ind", "xi", "iu", "r", "li", "it", "o", "g", "c", "s", "ie", "ir", "I", "range", "u", "m", "ai", "b", "p", "d", "int", "f"], "g2": ["g62", "r4", "G0", "i2", "g32", " g4", "i32", "iTwo", "r0", " gTwo", "G62", "g4", "G2", "G4", "r62", "i0", "r32", "G32", "g0", "GTwo", " g62", "gTwo", "rTwo"], "board2": ["group0", " board4", "board4", "boardstwo", " boardTwo", "board64", "ga1", "ga2", "Board22", "group3", "group2", "linetwo", "boards64", "group1", "boardTwo", "block64", "ga0", "board22", "line2", "blockTwo", "boardtwo", " board64", "boardsTwo", "Board2", "ga3", " boardtwo", "g3", "board0", "line4", "block2", "boards2", "Board4", "Boardtwo", "g0", "blocktwo", "board3", "line22", " board22"], "r1": ["Rone", "r15", "rone", "rg5", "r5", "hr15", " rone", "hr2", "gone", "r0", "rg2", "hr1", "hr5", "rg15", "g0", "g5", " r0", "rg1", "R2", "R1", "R0", "g15"], "r2": ["er2", " rb", " r4", "r4", "r0", " r22", "g4", "er22", "er4", "rb", "Rb", "g0", "er1", "gb", " r0", "r22", "R2", "R1", "g22", "R0"], "answer": ["average", "err", "area", "episode", "reply", "term", " answers", "match", "description", "audio", "eni", "range", "swers", "energy", "current", "question", "vale", "ee", "length", "case", "example", "respond", "video", "array", "username", "r", "edge", "value", "see", "name", "say", "message", "assembly", "expression", "fee", "response", "new", "error", "support", "archive", "next", "eden", "number", "word", "result", "code", "address", "output", "edition", "ell", "issue", "order", "update", "section", "offer", "translation", "duration", "race", "knowledge", "answered", "notice", "comment", "equ", "equality", "data", "e", " Answer", "string", "grade", "score", "side", "cache", " answered", "status", "replace", "Answer", "topic", "evidence", "pole", "results", "test"]}}
{"code": "class Sweeper(object):\n      def __init__(self, r, c, m):\n          self.matrix = [['.' for j in range(0, c)] for i in range(0, r)]\n          self.matrix[0][0] = 'c'\n  \n          self.r = r\n          self.c = c\n          self.m = m\n          self.current_r = r\n          self.current_c = c\n          self.current_m = m\n  \n      def fill_row(self):\n          if self.current_r >= 3 and self.current_m >= self.current_c:\n              for i in range(0, self.current_c):\n                  self.matrix[self.current_r - 1][i] = '*'\n              self.current_r -= 1\n              self.current_m -= self.current_c\n              return True\n          return False\n  \n      def fill_col(self):\n          if self.current_c >= 3 and self.current_m >= self.current_r:\n              for i in range(0, self.current_r):\n                  self.matrix[i][self.current_c - 1] = '*'\n              self.current_c -= 1\n              self.current_m -= self.current_r\n              return True\n          return False\n  \n      def fill_partial(self):\n          if self.current_r >= 3:\n              fill_num = min(self.current_m, self.current_c - 2)\n              for i in range(0, fill_num):\n                  self.matrix[self.current_r - 1][self.current_c - 1 - i] = '*'\n              self.current_m -= fill_num\n              if fill_num > 0:\n                  self.current_r -= 1\n          if self.current_c >= 3:\n              fill_num = min(self.current_m, self.current_r - 2)\n              for i in range(0, fill_num):\n                  self.matrix[self.current_r - 1 - i][self.current_c - 1] = '*'\n              self.current_m -= fill_num\n              if fill_num > 0:\n                  self.current_c -= 1\n          if self.current_m > 0:\n              return False\n          else:\n              return True\n  \n      def fill_special_one(self):\n          if self.current_r * self.current_c == self.current_m + 1:\n              for i in range(0, self.current_r):\n                  for j in range(0, self.current_c):\n                      self.matrix[i][j] = '*'\n              self.matrix[0][0] = 'c'\n              self.current_r = 0\n              self.current_c = 0\n              self.current_m = 0\n              return True\n          return False\n  \n      def fill_special_col(self):\n          if self.current_c == 1 and self.current_r > self.current_m:\n              for i in range(0, self.current_m):\n                  self.matrix[self.current_r - 1 - i][0] = '*'\n              self.matrix[0][0] = 'c'\n              self.current_m = 0\n              self.current_r = 0\n              self.current_c = 0\n              return True\n          return False\n  \n      def fill_special_row(self):\n          if self.current_r == 1 and self.current_c > self.current_m:\n              for i in range(0, self.current_m):\n                  self.matrix[0][self.current_c - 1 - i] = '*'\n              self.matrix[0][0] = 'c'\n              self.current_m = 0\n              self.current_r = 0\n              self.current_c = 0\n              return True\n          return False\n  \n  def print_matrix(matrix):\n      for row in matrix:\n          s = ''\n          for col in row:\n              s += col\n          print s\n  \n      \n  def solve_case(t):\n      r, c, m = [int(num) for num in raw_input().strip().split()]\n      sweeper = Sweeper(r, c, m)\n      print 'Case #%d:' % (t,)\n      if sweeper.fill_special_one() or sweeper.fill_special_col() or sweeper.fill_special_row():\n          print_matrix(sweeper.matrix)\n          return\n      f_result = True\n      while sweeper.current_m > 0 and f_result:\n          f_result = False\n          f_result |= sweeper.fill_row()\n          f_result |= sweeper.fill_col()\n      if sweeper.current_m > 0:\n          sweeper.fill_partial()\n      if sweeper.current_m > 0:\n          print 'Impossible'\n      else:\n          print_matrix(sweeper.matrix)\n  \n  def main():\n      t = int(raw_input().strip())\n      for i in range(1, t + 1):\n          solve_case(i)\n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"self": ["parent", "remote", "game", "v", "http", "sys", "err", "hand", "per", "args", "ok", "complete", "spec", "field", "ref", "private", "coll", "master", "ws", "mass", "qa", "app", "go", "k", "case", "world", "resp", "layer", "instance", "ns", "object", "kernel", "l", "no", "n", "lc", "time", "comp", "site", "os", "proc", "plugin", "config", "high", "p", "new", "full", "error", "a", "next", "form", "plus", "ctx", "point", "word", "Self", "missing", "all", "res", "user", "result", "other", "q", "www", "man", "event", "func", "group", "public", "type", "mate", "raw", "ng", "context", "skip", "host", "style", "view", "method", "lf", "b", "cross", "ch", "d", "pos", "line", "client", "map", "data", "er", "f", "worker", "x", "part", "e", "utils", "ack", "default", "right", "cache", "w", "this", "o", "co", "me", "g", "h", "manager", "load", "base", "extra", "results", "es", "wx", "cl", "work", "node", "wrapper", "temp", "page"], "r": ["x", "mr", "e", "v", "rr", "fr", "rf", "l", "ru", "n", "ro", "rd", "right", "w", "dr", "rh", "cr", "ir", "R", "ar", "h", "nr", "rc", "y", "sr", "range", "hr", "u", "rb", "rs", "b", "p", "ra", "d", "radius", "rg", "k", "re", "f", "er"], "c": ["x", "e", "v", "nc", "cat", "l", "n", "dc", "lc", "q", "count", "ce", "w", "cu", "rec", "cr", "g", "h", "rc", "cn", "y", "ci", "con", "u", "cm", "mc", "b", "p", "C", "d", "ch", "z", "a", "cc", "cy", "k", "f", "ac"], "m": ["x", "mu", "mr", "v", "e", "l", "mi", "n", "q", "mm", "w", "o", "g", "rm", "ms", "h", "y", "max", "range", "cm", "u", "mc", "b", "p", "d", "pm", "z", "a", "md", "k", "f", "M", "ac"], "matrix": [" matcost", "matric", "attrow", "matbox", "tment", "attpack", " matmap", "trix", "matq", "atpack", "atrow", "dimrix", "atrices", "atcost", "dimrib", "mensor", "Matment", "matvector", " matvector", " matrices", "Matcost", "matrib", "Matrib", "attmap", "trices", "matensor", "Matbox", "attrices", "latrix", "mrib", "atric", "latq", "matcost", "Matrix", "Matensor", "mbox", "attrix", "atrix", "matment", "atmap", "matrices", "latrices", "matpack", "mrix", "Matvector", " matpack", "matrow", "atvector", "dimbox", "latrow", "attric", "tq", "Matrices", "Matq", "latment", "latric", "dimensor", "matmap", " matric"], "j": ["ji", " ti", "ri", "bi", "je", "xi", " b", "o", "abi", " ii", "ie", "gi", "iii", "ati", " si", "ai", "b", " bi", "ime", "z", "ja", "iv", " o", "ij", " ni", "di", "zi", "k"], "i": ["ji", "x", "id", "ui", "ii", "e", "v", "ri", "bi", "index", "multi", "ip", "l", "mi", "n", "phi", "ei", "xi", "yi", "iu", "li", "o", "ti", "ie", "qi", "ir", "h", "gi", "si", "y", "oi", "I", "iw", "ni", "ci", "ini", "u", "ic", "ai", "b", "p", "z", "ix", "pi", "int", "ij", "mini", "di", "k", "zi", "f", "io", "ia"], "current_r": ["currentQm", "currentXr", "currentAllrf", "currentDr", "current_rc", "reported_l", "currentSr", "current_R", "currentDc", "reported_rg", "reported_c", "reported_reb", "currentScol", "reported_rate", "reported_rb", "currentVrate", "currentDmr", "current_col", "currentPc", "currentPr", "currentXm", "currentMc", "reported_R", "current_rr", "current_rg", "reported_hr", "currentXrg", "currentVm", "current__c", "reported_rc", "reported_mr", "current_e", "current___c", "currentVr", "current_rb", "reported_row", "reported_rf", "current__m", "reported_col", "currentXc", "reported_e", "current__r", "current_rate", "currentQc", "currentMR", "current_rf", "current___r", "current_l", "currentSc", "currentDreb", "current_hr", "currentQr", "currentVc", "current_mr", "reported_rr", "reported_m", "currentPrb", "current__e", "currentMm", "currentQrr", "currentMr", "current_row", "reported_r", "current_reb", "current___reb", "current___mr", "currentAllr", "currentAllm", "currentAllc", "currentPm", "currentSm"], "current_c": ["currentAr", "currentDmc", "reported_cin", "currentIr", "currentXr", "currentMemm", "current_h", "currentParc", "currentMemr", "currentDr", "currentParr", "current_rc", "current_count", "currentDc", "reported_c", "current_rec", "current_cur", "currentIPcin", "currentIcount", "currentPd", "reported_mc", "reported_pc", "currentLc", "current_n", "reported_cur", "currentPc", "currentAcur", "currentPr", "currentXm", "currentMemc", "currentAc", "reported_n", "current_w", "currentMemfc", "reported_rc", "reported_count", "current_rn", "_", "currentParrn", "currentLrec", "all", "currentXc", "reported_h", "currentIPr", "current_b", "reported_fc", "currentIPm", "current_pc", "currentDcount", "reported_rn", "pos", "currentLm", "current_d", "current_fc", "reported_m", "currentAh", "end", "currentIc", "w", "currentXpc", "currentImc", "reported_d", "currentParw", "current_mc", "reported_r", "reported_b", "reported_rec", "reported_w", "currentIPc", "currentLr", "currentPm", "current_cin"], "current_m": ["currentDmc", "currentDr", "currently_c", "currentDc", "currentOc", "reported_c", "current_f", "current_nm", "current_co", "reported_mc", "currently_p", "currentOco", "currentKnr", "currentKc", "currentJm", "currently_r", "current_mu", "currentKm", "reported_ar", "currentJc", "current_nr", "reported_nm", "currentJp", "currentOm", "current_am", "currentWm", "currentOr", "current64nm", "reported_f", "current_b", "reported_am", "reported_nr", "currentWc", "current64r", "currentDm", "reported_mu", "current64c", "reported_m", "current_ar", "currentWmu", "currentKr", "currentJr", "current_mc", "reported_r", "currently_m", "current_p", "reported_b", "current64m", "reported_co", "currentWr"], "fill_num": [" fill_nb", " fill_Num", "fill67sum", "update_um", "update_num", "fillingnone", "fillNcommon", "fill_mom", "fill_sum", "fill___sum", "fill_nb", "fill_name", "fill2number", "fillingnu", " fill_sum", "fill2sum", "fill_none", "fillingum", "fill_net", " fill_name", " fill_mom", "ill_sum", "update_nu", "fill_dim", "fillNnum", "fillingnum", "ill_none", "fill___num", "fill67num", " fill_net", "update_none", "fill_Num", "update_sum", "fill2name", "fill64num", "fill64sum", "fill32num", "ill_common", "fill_number", "fill_common", "fill_nu", "fill___net", "fill2num", "fillensum", "fill67nb", "fill64gap", "fillencommon", "fill64nb", " fill_multi", "fill32Num", "fill_gap", "fill32multi", "fillennone", "fill_um", "fillNsum", "fill67gap", "fill_n", " fill_number", " fill_dim", "update_n", "fillennum", "ill_num", "fill_multi", "fillNnone", "fill___Num", " fill_gap", "fill32mom"]}}
{"code": "def solve_case(t):\n      interested_row = int(raw_input().strip())\n      i = 1\n      while i <= 4:\n          row = raw_input()\n          if i == interested_row:\n              first_set = set(row.strip().split())\n          i += 1\n      interested_row = int(raw_input().strip())\n      i = 1\n      while i <= 4:\n          row = raw_input()\n          if i == interested_row:\n              second_set = set(row.strip().split())\n          i += 1\n      ans_set = first_set & second_set\n      if len(ans_set) == 1:\n          print 'Case #%d: %s' % (t, ans_set.pop(),)\n      elif len(ans_set) > 1:\n          print 'Case #%d: Bad magician!' % (t,)\n      else:\n          print 'Case #%d: Volunteer cheated!' % (t,)\n  \n  def main():\n      t = int(raw_input().strip())\n      for i in range(1, t + 1):\n          solve_case(i)\n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"t": ["x", "token", "tu", "j", "v", "e", "T", "st", "l", "bot", "n", "time", "tf", "table", "task", "trial", "mt", "r", "it", "o", "tt", "g", "ut", "c", "window", "pt", "type", "s", "h", "template", "name", "title", "nt", "tc", "y", "qt", "ta", "start", "tim", "dt", "m", "u", "the", "tz", "tp", "p", "b", "d", "z", "tm", "int", "ts", "k", "f", "temp", "tower", "port", "test"], "interested_row": ["interest_cell", "interest_col", "interestededrow", "interest_none", "interested_section", "interestedingrow", "interested_ro", "interested67row", "interest_section", "interested_none", "interestedianrows", "interestedingsection", "interested67rows", "interestedingcell", " interested_set", "interestediannone", "interested_cell", " interested_ro", "interestedingrows", "interested_set", "interestededcell", "mentioned_server", "interest_row", " interested_rows", "interested_server", "interestededsection", "interestededrows", "interested_rows", "interested67set", "interest_rows", "interested_col", "mentioned_row", "interestediancol", "mentioned_rows", "interestedianrow", "interested67ro", "mentioned_set"], "i": ["x", "id", "j", "ii", "v", "e", "bi", "ri", "multi", "index", "ip", "mi", "l", "cli", "n", "phi", "ind", "q", "xi", "anti", "yi", "iu", "li", "ki", "r", "col", "o", "c", "ti", "ie", "qi", "info", "chi", "gi", "h", "hi", "si", "y", "oi", "I", "start", "ori", "uri", "ni", "ci", "ini", "m", "u", "ai", "p", "d", "z", "ix", "pi", "int", "a", "mini", "di", "zi", "k", "f", "io", "ui"], "row": ["instance", "bug", "id", "Row", "key", "result", "user", "array", "ro", "q", "up", "server", "ha", "month", "seed", "r", "w", "channel", "container", "feed", "col", "image", "group", "ward", "batch", "set", "sc", "section", "coll", "sw", "raw", "reader", "wheel", "sync", "ow", "port", "input", "column", "view", "ry", "rows", "dd", "tr", "p", "page", "block", "line", "arrow", "entry", "cell", "data", "f", "pair", "hub", "va", "record"], "first_set": ["small_size", "first___sc", "small_set", "primary_name", "first___set", "firstLSet", "first_size", "primary_setting", "first_setting", "primaryLsetting", "firstLname", "first___size", "small_block", "small_sc", "first_Set", "primaryLSet", "firstLset", "firstLsetting", "smallJblock", "primaryLname", "firstJsc", "firstJsize", "first_name", "first___block", "firstJset", "primary_set", "first_block", "first_sc", "firstJblock", "primary_Set", "smallJset", "smallJsc", "primaryLset", "smallJsize"], "second_set": ["second_row", "second__set", "second_setting", "second_sc", "second_case", " second_pack", "second__sc", " second_row", "second__setting", " second_sc", " second_case", " second_setting", "second_pack"], "ans_set": ["ans_row", "ans_sche", "ans2seen", "an_sche", "ans_list", "an_set", "an_part", "ans_seen", "ans2set", "an_setting", "an_seen", "ans_setting", "an_list", "an_et", "an_row", "ans_et", "ans_part", "ans_match", "ans2match", "an_match", "ans2list"]}}
{"code": " \n  \n  def read_str(): return stdin.readline().rstrip('\n')\n  def read_int(): return int(stdin.readline())\n  def read_ints(): return map(int, stdin.readline().split())\n  def read_floats(): return map(float, stdin.readline().split())\n  \n  \n  def atos(A):\n      return '\n'.join([''.join(row) for row in A])\n      \n  \n  def get_field(r, c):\n      field = [['.'] * c for i in range(r)]\n      field[0][0] = 'c'\n      return field\n      \n      \n  def is_forbidden(i, j):\n      return i == 0 and j == 0 or i == 0 and j == 1 or \\\n          i == 1 and j == 0 or i == 1 and j == 1\n      \n      \n  def fill(field, r, c, m):\n      left = m\n      for ii in range(r - 1, -1, -1):\n          i = ii\n          j = c - 1\n          while i < r and j >= 0:\n              if is_forbidden(i, j):\n                  i += 1\n                  j -= 1\n                  continue\n              if left == 0:\n                  return 0\n              field[i][j] = '*'\n              left -= 1\n              \n              i += 1\n              j -= 1\n              \n          if ii == 0:\n              for jj in range(c - 2, 1, -1):\n                  i = ii\n                  j = jj\n                  while i < r and j >= 0:\n                      if is_forbidden(i, j):\n                          i += 1\n                          j -= 1\n                          continue\n                      if left == 0:\n                          return 0\n                      field[i][j] = '*'\n                      left -= 1\n                      \n                      i += 1\n                      j -= 1\n              \n      if r * c == m + 1:\n          if r > 1:\n              field[1][0] = '*'\n          if c > 1:\n              field[0][1] = '*'\n          if r > 1 and c > 1:\n              field[1][1] = '*'\n          return 0\n              \n      return left\n  \n      \n  def solve_case():\n      r, c, m = read_ints()\n      \n      field = get_field(r, c)\n          \n      left = fill(field, r, c, m)\n          \n      return 'Impossible' if left != 0 else atos(field)\n      \n      \n  def main():\n      cases = read_int()\n      for case in range(1, cases + 1):\n          print('Case #{}:\n{}'.format(case, solve_case()))\n  \n          \n  main()\n", "substitutes": {"A": ["N", "Y", "T", "AC", "As", "array", "P", "AN", "n", "LA", "area", "ram", "This", "H", "G", "W", "CA", "K", "R", "alpha", "AA", "Ar", "AD", "I", "B", "an", "AR", "D", "analysis", "F", "AB", "grid", "S", "Z", "C", "a", "mA", "M", "ac", "NA", "L"], "row": ["instance", "x", "xxxxxxxx", "Row", "rown", "ud", "object", "insert", "result", "array", "ro", "model", " Row", "mm", " rows", "feed", "col", "board", "round", "rew", "raw", "reader", "rc", "ow", "uu", "input", "column", "rows", "gram", "rw", "df", "block", "line", "entry", "obj", "arr", "cell", "node", "f", "record"], "r": ["adr", "x", "mr", "e", "fr", "rr", "v", "err", "yr", "l", "br", "ru", "n", "t", "q", "gr", "right", "w", "dr", "rh", "lr", "rec", "g", "cr", "rm", "ir", "R", "h", "ar", "nr", "rc", "y", "sr", "range", "ur", "hr", "u", "rb", "rs", "str", "tr", "b", "p", "d", "z", "rg", "a", "arr", "re", "f", "er", "pr"], "c": ["x", "v", "e", "nc", "uc", "cs", "l", "t", "n", "dc", "end", "lc", "q", "ca", "ce", "right", "w", "cu", "col", "o", "ec", "co", "cr", "s", "h", "arc", "rc", "cn", "y", "cf", "ci", "con", "cm", "u", "mc", "b", "p", "C", "ch", "d", "z", "a", "cc", "cy", "k", "cp", "f", "ac"], "field": ["v", "root", "err", "model", "fields", "FIELD", "term", "match", "Field", "source", "machine", "true", "force", "cell", "layer", "object", "rule", "change", "slice", "time", "li", "round", "value", "list", "message", "function", "p", "block", "diff", "fix", "condition", "form", "number", "word", "all", "ff", "result", "user", "q", "table", "day", "man", "group", "module", "type", "section", "element", "cover", "input", "inner", "fill", "d", "line", "comment", "f", "data", "er", "record", "x", "part", "e", "key", "string", "patch", "default", "child", "play", "end", "sort", "post", "label", "g", "file", "lock", "manager", "column", "load", "null", "document", "ed", "option", "int", "player", "page"], "i": ["ji", "x", "id", "ui", "v", "e", "ri", "bi", "ik", "multi", "ip", "l", "mi", "n", "phi", "ind", "xi", "anti", "yi", "iu", "li", "it", "ki", "o", "s", "ie", "ti", "qi", "ir", "gi", "info", "y", "si", "vi", "oi", "I", "eni", "ori", "uri", "ni", "ci", "fi", "ini", "ib", "u", "ic", "ai", "b", "p", "d", "z", "ix", "pi", "int", "ij", "a", "iv", "mini", "di", "zi", "api", "f", "io", "ia"], "j": ["ji", "x", "all", "part", "v", "e", "key", "je", "l", "br", "n", "dj", "ah", "t", "q", "J", "jen", "li", "it", "jc", "el", "o", "on", "js", "off", "g", "pt", "ie", "h", "name", "oj", "jp", "y", "jl", "si", "ot", "ci", "adj", "jo", "u", "b", "p", "jet", "d", "ch", "aj", "z", "ix", "line", "note", "bj", "obj", "a", "ij", "ja", "ne", "k", "jon", "f", "uj", "page"], "m": ["x", "mu", "mr", "v", "e", "ym", "im", "l", "t", "mi", "n", "q", "man", "mm", "w", "o", "g", "ms", "h", "y", "range", "middle", "machine", "u", "cm", "mc", "b", "p", "d", "um", "z", "tm", "a", "re", "f", "M"], "left": ["id", "err", "ignore", "low", "fields", "only", "col", "cel", "len", "size", "le", "partial", "false", "length", "obj", "cell", "none", "L", "lt", "rule", "l", "no", "n", "lc", "member", "li", "url", "offset", "hide", "lo", "center", "self", "ul", "cost", "function", "found", "p", "ix", "diff", "full", "error", "plus", "missing", "all", "code", "shift", "ell", "two", "fl", "skip", "inner", "last", "leave", "line", "small", "used", "x", " Left", "min", "e", "pl", "default", "child", "end", "right", "copy", "label", "o", "empty", "Right", "fe", "wrong", "after", "shell", "joined", "null", "z", "Left", "cl"], "ii": ["ji", "id", "bug", "err", "ri", "ignore", "l", "n", "end", "ei", "ind", "li", "II", "url", "col", "yy", "init", "ice", "ort", "gi", "qi", "h", "sci", "iii", "ie", "center", "after", "inf", "ili", "fl", "size", "cycle", "vi", "img", "circle", "say", "qa", "cf", "iw", "eni", "y", "middle", "inner", "ni", "ci", "fi", "ini", "iq", "cm", "sil", "ai", "b", "p", "d", "ani", "z", "ix", "ig", "si", "iv", "mini", "di", "f", "illi"], "jj": ["ji", "x", "qq", "dj", "n", "q", "J", "right", "man", "JJ", "gn", "mm", "jc", "rec", "g", "h", "JC", "gm", "bb", "jp", "jl", "y", "jo", "cm", "b", "p", "d", "aj", "ix", "tm", "ij", "ja", "cc", "cp", "uj"], "cases": ["instance", "rule", "child", "ends", "options", "trial", "count", "fields", "shift", "sections", "path", "section", "counter", "children", "values", "tests", "size", "cells", "inner", "rows", "rules", "lines", "stack", "Case", "times", "mat", "test"], "case": ["all", "index", "end", "right", "pos", "_"]}}
{"code": " \n  def read_str(): return stdin.readline().rstrip('\n')\n  def read_int(): return int(stdin.readline())\n  def read_ints(): return map(int, stdin.readline().split())\n  \n  def read_cards():\n      cards = []\n      for i in range(4):\n          cards.append(read_ints())\n      return cards\n  \n  def main():\n      cases = read_int()\n      for case in range(1, cases + 1):\n          row = read_int() - 1\n          cards = read_cards()\n          candidates1 = set(cards[row])\n          \n          row = read_int() - 1\n          cards = read_cards()\n          candidates2 = set(cards[row])\n          \n          candidates = candidates1.intersection(candidates2)\n          if len(candidates) == 1:\n              ans = list(candidates)[0]\n          elif len(candidates) == 0:\n              ans = 'Volunteer cheated!'\n          else:\n              ans = 'Bad magician!'\n          \n          print('Case #{}: {}'.format(case, ans))\n          \n  main()\n", "substitutes": {"cards": ["parents", "grades", "cas", "fields", "cats", "reads", "settings", "checks", "cons", "tests", "attacks", "breaks", "events", "types", "guards", "cell", "comments", "lists", "phones", "groups", "array", "changes", "card", " card", "hands", "list", "codes", "styles", "cells", "quarters", "ids", "rows", "items", "ards", "ays", "kids", "bags", "rules", "lights", "charges", "lines", "times", "all", "holes", "cs", "carry", "games", "liners", "features", "files", "s", "rings", "cuts", "cf", "letters", "cross", "boxes", "stars", "months", "acs", "default", "yards", "limits", "clips", "rooms", "c", "caps", "books", "balls", "steps", "Card", "packs", "ickets", "pieces"], "i": ["x", "id", "j", "e", "index", "ip", "n", "ind", "ace", "bc", "li", "it", "col", "ice", "c", " ii", "I", " I", "u", " ic", "ic", "p", "pos", "ix", "line", "int", "char"], "cases": ["cus", "blocks", "groups", "points", "ces", "tips", "cs", "ends", "features", "fields", "settings", "sections", "shape", "checks", "ases", "rooms", "classes", "values", "tests", "cells", "runs", "breaks", "rows", "forms", "steps", "packs", "events", "types", "days", "ls", "lines", "Case", "xs", "chains", "boxes", "times", "shows", "ches", "test"], "case": ["instance", "id", "sea", "bug", "index", "code", "slice", "address", "trial", "time", "ace", "core", "ce", "ca", "cas", "li", "col", "shape", " c", "match", "ice", "c", "X", "ape", "mode", "sc", "section", "position", "start", "race", "rows", "ride", "pos", "length", "line", "division", "Case", "ase", "cell", "loc", "test"], "row": ["step", "instance", "x", "id", "bug", "Row", "uc", "key", "index", "ro", "slice", "month", "r", " rows", "post", "feed", "col", "order", "shape", "where", "group", "round", "ward", "week", "mode", "batch", "sc", "section", "coll", "head", "rc", "ow", "uu", "win", "race", "range", "column", "rows", "ry", "roll", "block", "box", "line", "entry", "scale", "cell", "rank", "loc", "port", "test"], "candidates1": ["candoresone", "candidateone", "Candidates1", "candodes1", "candidates3", "Candidate3", "candodesone", "candices2", "candodes0", "candidate1", "candotes3", "candotes2", "Candidate0", "candores1", "candidate3", "Candidates0", "candores0", "Candidate2", "candores2", "candices3", "Candidateone", "candidate2", "Candidate1", "Candidatesone", "candotes0", "candidatesone", "Candidates2", "candidates0", "Candidates3", "candodes2", "candices1", "candices0", "candotes1", "candidate0"], "candidates2": ["candles2", "candles0", "candles1", "Candidates1", "candodes1", "CandidateTwo", "Candidate02", "candodes0", "Candidates02", "candidate1", "candidateTwo", "candries1", "candates0", "Candidate0", "candates02", "Candidates0", "candates2", "candlesTwo", "candidate02", "candriesTwo", "CandidatesTwo", "Candidate2", "candates1", "candries0", "candidatesTwo", "candidate2", "Candidate1", "candries2", "Candidates2", "candidates0", "candidates02", "candodes2", "candodes02", "candidate0"], "candidates": ["Candates", "Candores", "matidates", "validales", "charates", "contractores", "candances", "Candales", "variates", "variations", "matles", "contracticates", "charles", "Candles", "Candidates", "indances", "charidate", "contractidate", "variances", "charations", "candidate", "contractidates", "charales", "indates", "candations", "charidates", "candates", "candales", "validles", "candles", "variidates", "candicates", "charicates", "indidates", "matidate", "matates", "Candicates", "Candidate", "valididates", "candores", "indations", "charances", "valididate", "charores"], "ans": ["ams", "cus", "aus", "ann", "ns", "ras", "AN", "atan", "aces", "na", "ars", "aning", "os", "lan", " Ans", "leans", "ain", "ants", "lang", "ane", "ins", "amps", "nas", "anas", " ang", "anc", "anus", "ana", "an", " sins", "sk", "can", "ats", "ai", "plan", "cross", " means", "ani", "aned", "ations", "les", "ania", "san", "aos", "nan", "ano", "ANS", "ean", "ang"]}}
{"code": "T = int(input())\n  \n  def solve(R,C,M):\n      if R>C:\n          flipboard = solve(C,R,M)\n          if flipboard:\n              return [[flipboard[j][i] for j in range(C)] for i in range(R)]\n          else:\n              return\n      if M==0:\n          board = [['.']*C for i in range(R)]\n          board[-1][-1] = 'c'\n          return board\n      if R == 1:\n          board = ['*' if i<M else '.' for i in range(R*C)]\n          board[-1] = 'c'\n          return [board]\n      if R == 2:\n          if R*C==M+1:\n              board = [['*']*C for i in range(R)]\n              board[-1][-1] = 'c'\n              return board\n          if (M%2) or (M+2)==(R*C):\n              return\n          board = [['*' if i<(M/2) else '.' for i in range(C)] for j in range(R)]\n          board[-1][-1] = 'c'\n          return board\n      if M>=R:\n          subboard = solve(R,C-1,M-R)\n          if subboard:\n              return [['*']+r for r in subboard]\n          return\n      if (R,C,M) == (3,3,2):\n          return\n      k = min(M,C-2)\n      board = [['*']*k+['.']*(C-k)]\n      for i in range(M-k):\n          board.append(['*']+['.']*(C-1))\n      while len(board)<R:\n          board.append(['.']*(C))\n      board[-1][-1] = 'c'\n      return board\n      \n           \n      \n  \n  for case in range(1,T+1):\n      print(\"Case #\",case,\": \",sep='')\n      R,C,M = (int(x) for x in input().split())\n      ans = solve(R,C,M)\n      if ans:\n          for r in ans:\n              print(''.join(r))\n      else:\n          print('Impossible')\n  \n  \n", "substitutes": {"T": ["N", "Y", "TN", "t", "P", "TS", "TI", "E", "G", "H", "W", "X", "Time", "Q", "TM", "I", "B", "D", "F", "Type", " t", "O", "CT", "S", "TT", "Z", "V", "TB", "A", "L", "U", "test"], "R": ["Rh", "TR", "N", "Y", "Rule", "GR", "Rs", "Range", "P", "RE", "MR", "J", "Cl", "CR", "RH", "Re", "RT", "JR", "E", "H", "G", "SR", "RM", "W", "RO", "K", "X", "Right", "c", "RW", "ER", "Q", "DR", "RS", "I", "B", "Run", "RP", "AR", "D", "F", "Cr", "RG", "IR", "Ra", "m", "O", "RN", "RL", "S", "CL", "RR", "Mor", "V", "NR", "KR", "WR", "A", "L", "U", "RA"], "C": ["N", "Y", "NC", "CNN", "AC", "P", "VC", "CAR", "DC", "CM", "CR", "Cl", "E", "H", "G", "CE", "Size", "W", "COR", "CA", "K", "X", "c", "Co", "Sc", "JC", "CV", "CO", "CC", "Q", "CW", "Cu", "B", "I", "CS", "D", "CI", "F", "Cr", "Ch", "CT", "O", "S", "CL", "Z", "EC", "MC", "V", "CU", "Count", "CN", "A", "L", "U"], "M": ["N", "Y", "MD", "FM", "P", "MS", "MR", "Man", "MO", "J", "CM", "VM", "U", "E", "G", "MI", "MX", "H", "RM", "W", "DM", "AM", "K", "X", "c", "NM", "Mo", "Q", "TM", "OM", "I", "B", "Model", "MF", "ID", "D", "F", "JM", "MB", "LM", "MM", "Ch", "m", "cm", "O", "S", "MA", "Z", "MN", "Mi", "CL", "Me", "ME", "Mor", "MC", "OR", "IM", "A", "L", "V"], "flipboard": ["flippcart", "Flipboard", "Flippcart", "flippingboard", "flippinghole", "flideboard", "flipback", "flippingline", " flipline", "flippingboards", "Flippboards", "flipphole", "Flipcart", "flippingback", " flippingback", "flipperboard", "Flipphole", "flippBoard", "flippedback", " fliprow", " flippingline", "slideboards", "flipprow", "Flipboards", "flippback", "slipboards", "slideboard", "flippboards", "flippedboards", "flipboards", " flipback", "fliprow", "flideboards", "flippedBoard", "slideBoard", "slipboard", "flippedrow", "flippingrow", "flipBoard", "flippline", "Fliphole", "flippedboard", "slipBoard", "fliphole", "Flippboard", "flipline", " flippingboard", "flipperhole", "flippedline", " flippingrow", "flideBoard", "flippingcart", "flippboard", "flippercart", "flipcart", "flipperboards"], "j": ["ji", "v", "ii", "e", "im", "je", "l", "n", "ind", "q", "J", "jj", "xi", "li", "jc", "o", "js", "g", "c", "ie", "qi", "h", "ir", "oj", "jp", "kj", "jl", "y", "ni", "adj", "m", "b", "p", "aj", "z", "obj", "ja", "ij", "f", "uj"], "i": ["ji", "id", "ii", "v", "e", "ri", "bi", "index", "ik", "ip", "l", "im", "n", "phi", "ei", "xi", "yi", "iu", "li", "it", "o", "g", "c", "ti", "ie", "qi", "chi", "gi", "si", "I", "iw", "ori", "ni", "ci", "iq", "m", "u", "ib", "ai", "b", "p", "d", "pi", "int", "di", "zi", "f", "io", "ui"], "board": ["game", "model", "stream", "feed", "coll", "head", "ode", "plan", "boarding", "length", "chain", "ide", "video", "ba", "bug", "deck", "object", "card", "rock", "core", "que", "round", "stroke", "one", "list", "join", "road", "loop", "clean", "custom", "rows", "function", "pool", "p", "block", "check", "back", "form", "rank", "cart", "word", "flow", "all", "uc", "result", "lane", "code", "che", " clipboard", "control", "table", "day", "hack", "ward", "ban", "bar", "view", "lay", "phone", "frame", "b", "layout", "d", "box", "cross", "ion", "line", "client", "foot", "une", "comment", "land", "room", "f", "port", "menu", "valid", "e", "ack", "ko", "child", "play", "home", "bo", "bc", "post", "channel", "co", "flo", "Board", "c", "val", "file", "row", "null", "document", "hole", "boards", "player", "work", "node", "off", "bank", "page", "design"], "subboard": ["ubcart", "searchview", "superrow", "ubboard", "ubrow", "ubview", " subview", "subBoard", "superboard", "Subrow", "Subboard", "Subboards", "searchboard", "ubline", "ubBoard", "superBoard", "subline", "subcart", "subview", " subcart", " subboards", "searchline", "ubboards", "subboards", "supercart", "searchrow", " subrow", " subBoard", "subrow", " subline"], "r": ["Rh", "id", "mr", "v", "e", "res", "im", "result", "ru", "br", "P", "n", "ro", "l", "ner", "q", "gr", "run", "right", "array", "w", "g", "cr", " c", "c", "s", "h", "ir", "ar", "kr", "nr", "rc", "nor", "sr", "range", "ur", "ear", "m", "u", "rb", "rs", "b", "p", "d", "chain", "a", "ring", "re", "al", "f", "er", "ac"], "k": ["v", "e", "key", "l", "ko", "t", "n", "km", "end", "q", "ok", "ak", "w", "kk", "it", " K", "ck", "o", "g", "K", "ku", "c", "s", "ke", "ac", "max", "y", "sk", "m", "u", "b", "p", "ch", "d", "block", "z", "kw", "mk", "work", "rank", "f", "ka", "ks"], "case": ["instance", "id", "e", "key", "code", "P", "time", "trial", "ace", "text", "ce", "E", "shape", "path", " c", "match", "X", "ice", "c", "mode", "type", "one", "pe", "section", "name", "tc", "position", "size", "switch", "race", "p", "choice", " CASE", "Case", "ase", "cases", "loc", "test"], "x": ["rx", "v", "e", "xx", "index", "xb", "l", "n", "xy", "q", "xi", "w", "xxx", "g", " c", "X", "ex", "h", "xp", "y", "xa", "xc", "xt", "u", "ic", "p", "d", "z", "ax", "int", "a", "wx", "xs", " X", "f"], "ans": ["cus", "ens", "ons", "ann", "ns", "aus", "ents", "ds", "ras", "ians", "AN", "ops", "man", "cas", "na", "aces", "aning", "os", "lan", "ases", "lang", "cons", "ants", "ms", "ins", "ane", "nas", "anc", "ana", "an", "sk", "can", "con", "ids", "anes", " scans", "ats", "ai", "ays", "plan", " means", "span", "ani", "ls", "aned", "ania", "ase", "ano", "ANS", "ions", "ks", "scan"]}}
{"code": "T = int(input())\n  for case in range(1,T+1):\n      row1 = int(input())\n      for i in range(1,5):\n          l = input()\n          if i==row1:\n              first = set(int(x) for x in l.split())\n      row2 = int(input())\n      for i in range(1,5):\n          l = input()\n          if i==row2:\n              second = set(int(x) for x in l.split())\n      poss = first & second\n      if len(poss) ==0:\n          ans = 'Volunteer cheated!'\n      elif len(poss) >1:\n          ans = 'Bad magician!'\n      else:\n          ans = min(poss)\n      print(\"Case #\",case,\": \",ans,sep = '')\n", "substitutes": {"T": ["N", "Y", "t", "P", "time", "trial", "TS", " L", "TI", "E", "H", "W", "K", "X", "Time", "R", "I", "B", "CI", "F", "WT", "D", "O", "S", "TT", "Z", "C", "Case", "M", "A", "L", "V"], "case": ["instance", " Case", "e", "uc", "st", "code", "end", "time", "trial", "ace", "ce", "bc", "se", "cas", "yi", "match", "ice", "X", "c", "ti", "gi", "type", "pe", "section", "series", "name", "vi", "zip", "ci", "xc", "u", "ai", "p", "b", "choice", "pi", "line", "length", " CASE", "a", "Case", "ase", "cases", "zi", "pair", "U", "test"], "row1": [" rowone", "entry0", "rankone", "rowFirst", " rowFirst", "postFirst", "post0", "row0", "post1", "rank1", " row0", "rank0", "rowone", "postA", "Rowone", "Row0", "Row1", "entryFirst", " rowA", "rowA", "entryA", "entry1"], "i": ["id", "ui", "ii", "v", "e", "bi", "index", "ip", "t", "end", "phi", "ind", "xi", "yi", "li", "iu", "it", "o", "c", "ti", "ie", "chi", "y", "si", "I", "start", "ori", "ci", "m", "u", "ic", "ai", "b", "p", "z", "pi", "int", "a", "di", "zi", "f"], "l": ["j", "v", "e", "dl", "la", "t", "n", "log", "lc", "lu", "li", "r", "ell", "w", "nl", "el", "o", "ll", "g", "c", "s", "y", "le", "rl", "lp", "il", "m", "u", "ln", "b", "p", "d", "z", "ls", "line", "ol", "kl", "lin", "f", "sl", "L"], "first": ["part", "lower", "st", "default", "th", "third", "final", "right", "up", "only", "one", "top", "s", "sum", "initial", "max", "start", "left", "split", "prev", "current", "u", "p", "last", "latest", "full", "a", "next", "now", "primary", "none", "front", "fifth", "First"], "x": ["rx", "id", "e", "xx", "unc", "t", "n", "xy", "q", "text", "w", "xxx", "X", "c", "s", "ex", "xml", "xes", "ux", "ww", "sw", "xp", "h", "y", "input", "ci", "xc", "xt", "u", "m", "ph", "b", "p", "cross", "z", "ax", "full", "int", "a", "ct", "wx", "xs", "sex", "k", "f", "work", "lex", "se"], "row2": ["owtwo", "row62", "row4", "col1", "ro62", "block62", "ro2", "ro4", " row62", "error0", "coltwo", "row0", "ow2", "block4", "block2", "block5", " row4", "rowtwo", "error2", "error1", "ro5", "ow1", "ow0", "errortwo", "col0", "col2", " row5", "row5"], "second": ["double", "lower", "south", "sec", "slice", "low", "follow", "url", "secondary", "two", "old", "len", "size", "letter", "future", "split", "left", "later", "long", "six", "bis", "between", "loss", "last", "latest", "small", "species", "mini", "secret", "danger", "Second", "next", "seconds"], "poss": [" pOSS", "possession", "paocol", " pos", "pOSS", "fos", "cposs", "paose", "pross", "prass", "prOSS", "paoss", "paOSS", "Pocr", "paass", " passo", "Passo", "Pocol", "cpos", "fOSS", "cpOSS", "pocr", "Possession", "cpass", "POSS", "procr", "ipocol", "paossession", "paasso", "pose", "passo", "fass", "ipass", " pocr", "pos", "Pass", "Poss", "pocol", " possession", "ipose", "iposs", "foss", "Pose"], "ans": ["cus", "ams", "acs", "aus", "ann", "ents", "ns", "ons", "cs", "anne", "ras", "oss", "eps", "AN", "lc", "atan", "act", "aces", "na", "cas", "ars", "aning", "os", "lan", "ain", "ases", "ants", "cons", "s", "ane", "amps", "ins", "anas", "nas", "params", "anc", "ana", "ass", "asin", "an", "sk", "can", "ant", "ai", "ays", "plan", "ani", "aned", "ls", "les", "ania", "san", "support", "es", "ase", "a", "ANS", "ks", "ast"]}}
{"code": "filename = raw_input(\"Name of file: \")\n  infile = open(filename, \"r\")\n  outfile = open(filename + \".out\", \"w\")\n  \n  \n  T = int(infile.readline()[:-1])\n  \n  def addMinesDiagonally(r, c, m):\n      field = []\n      for i in range (r):\n          row = []\n          for j in range(c):\n              row += [\".\"]\n          field += [row]\n          \n      for i in range (r + c):\n          ver = min (i, r - 1)\n          hor = max (0, 1 + i - r)\n          while ver >= 0 and hor <= c - 1 and m > 0:\n              if m == 1 and hor == c - 2 and ver == r - 2:\n                  ver -= 1\n                  hor += 1\n              field[ver][hor] = \"*\"\n              ver -= 1\n              hor += 1\n              m -= 1\n          \n      return field\n  \n  def isPossible(field):\n      if field[-1][-1] != \".\":\n          return False\n      up = True\n      left = True\n      diag = True\n      if len(field) > 1 and field[-2][-1] != \".\":\n              up = len(field[-1]) <= 1\n      if len(field[-1]) > 1 and field[-1][-2] != \".\":\n              left = len(field) <= 1\n      if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != \".\":\n          diag = False\n      return (up and left and diag) or \\\n             ((not up) and (not left) and (not diag))\n      \n  \n  for t in range(1, T + 1):\n      items = infile.readline()[:-1].split(\" \")\n      r = int(items[0])\n      c = int(items[1])\n      m = int(items[2])\n      field = addMinesDiagonally(r, c, m)\n      if isPossible(field):\n          field[-1][-1] = \"c\"\n          s = \"\"\n          for line in field:\n              for cell in line:\n                  s += cell\n              s += \"\n\"\n          outfile.write(\"Case #%d:\n%s\n\" %(t, s[:-1]))\n      else:\n          s = \"IMPOSSIBLE!!!!\n\"\n          for line in field:\n              for cell in line:\n                  s += cell\n              s += \"\n\"\n          outfile.write(\"Case #%d:\n%s\n\" %(t, s[:-1]))\n      \n          \n      \n  \n  outfile.close()\n  infile.close()\n", "substitutes": {"filename": ["fn", "ername", "figure", "directory", "username", "slice", "utf", "that", "til", "lace", "stem", "fd", "sheet", "files", "itled", "knife", "amer", "ename", "path", "wl", "subject", "binary", "kn", "name", "title", "sql", "file", "jl", "selection", "mble", "doi", "dll", "SourceFile", "fil", "il", "fp", "ln", "download", "document", "jet", "FILE", "nil", "kl", "phrase", "pal", "Filename", "which", "f", "ames", "sf", "database", "tail"], "infile": ["Infile", "inline", "Inline", " inline", "Infilename", "outline", "infiles", " inFile", "Instream", " infilename", "infilename", "outFile", "outstream", "Infiles", "outfilename", "inFile", "instream", " infiles", "outfiles", " instream", "InFile"], "outfile": ["Outf", "OUTstream", "inline", " outFile", "outline", "Outline", "outFile", "outstream", "OUTletter", "Outstream", "inf", "Outfile", "inletter", " outstream", "OUTFile", "outf", " outline", " outletter", "inFile", "OUTfile", "instream", "outletter", " outf"], "T": ["TR", "N", "Y", "TN", "P", "TS", "Length", "E", "G", "H", "Size", "W", "K", "X", "R", "Q", "I", "B", "D", "F", "WT", "O", "CT", "S", "TT", "Z", "C", "V", "M", "A", "L", "U"], "r": ["x", "e", "v", "rr", "ri", "fr", "l", "ru", "n", "ro", "rd", "right", "w", "rt", "rh", "o", "rec", "cr", "h", "R", "ar", "ir", "nr", "rc", "sr", "range", "pr", "ur", "u", "rb", "rs", "tr", "b", "p", "ra", "d", "a", "k", "re", "f", "er", "rn"], "c": ["x", "v", "e", "nc", "uc", "cat", "cs", "l", "n", "dc", "lc", "q", "ce", "w", "cu", "col", "o", "cr", "g", "center", "h", "en", "rc", "cn", "y", "ci", "con", "cm", "u", "mc", "b", "p", "d", "C", "ch", "z", "a", "cc", "ct", "cy", "k", "cp", "f", "ac"], "m": ["x", "am", "mr", "v", "min", "e", "im", "l", "mi", "n", "end", "q", "meter", "mm", "w", "o", "g", "rm", "bm", "h", "vm", "en", "om", "y", "range", "an", "fm", "machine", "cm", "u", "mon", "mc", "b", "p", "d", "um", "z", "tm", "pi", "a", "dm", "re", "k", "f", "er", "M"], "field": ["feature", "v", "area", "model", "fields", "FIELD", "cel", "match", "coll", "Field", "range", "source", "machine", "length", "force", "wire", "case", "pull", "layer", "service", "object", "rule", "uf", "array", "change", "slice", "time", "url", "format", "ld", "bf", "value", "list", "zip", "message", "function", "p", "block", "diff", "fix", "error", "condition", "util", "form", "number", "word", "all", "ff", "user", "result", "table", "man", "event", "order", "space", "group", "module", "type", "update", "section", "element", "input", "style", "flower", "frame", "box", "um", "comment", "f", "data", "seed", "er", "record", "part", "key", "string", "patch", "child", "play", "end", "eff", "sort", "package", "post", "label", "this", "file", "lock", "manager", "load", "null", "document", "pick", "option", "player", "node", "off"], "i": ["x", "id", "ii", "v", "e", "ri", "im", "ip", "l", "n", "phi", "ind", "xi", "li", "iu", "w", "o", "g", "h", "ie", "qi", "ir", "ar", "y", "si", "I", "range", "ci", "u", "b", "p", "d", "z", "pi", "int", "di", "k", "f", "io"], "row": ["step", "x", "id", "feature", "Row", "uc", "key", "index", "query", "array", "child", "our", "ro", "model", "server", "month", "w", "feed", "col", "order", "group", "cr", "value", "h", "sc", "coll", "element", "rc", "ow", "max", "ul", "num", "range", "column", "rows", "tr", "block", "box", "cur", "form", "rank", "f", "port"], "j": ["e", "v", "je", "code", "sec", "q", "jac", "jc", "o", "co", "g", "jam", "cycle", "y", "cf", "cm", "ib", "b", "p", "z", "year", "ij", "ct", "cc", "cy", "k", "f", "ac"], "ver": ["x", "version", "feature", "min", "v", "root", "mr", "res", "err", "fr", "vert", "br", "ter", "iver", "cher", "gr", "vr", "VER", "dr", "ve", "col", "reach", "inter", "cr", "h", "ir", "type", "coll", "conv", "om", "Ver", "aver", "over", "num", "cover", "range", "gener", "ever", "ur", "cv", "con", "vers", "browser", "b", "av", "air", "cur", "re", "oy", "iter", "car", "f", "er", "pr", "var", "test"], "hor": ["dom", "version", "mr", "v", "Hor", "ri", "lor", "vert", "mi", "br", "chrom", "xy", "hub", "home", "low", "vr", "mor", "ho", "meter", "reach", "rub", "hide", "lo", "floor", "cr", "h", "ir", "dim", "om", "aver", "hi", "far", "nor", "over", "door", "hom", "cro", "uri", "ever", "ur", "shadow", "hr", "cv", "bor", "vor", "tri", "ior", "hover", "oh", "ra", "broad", "d", "um", "mir", "air", "rum", "cur", "dy", "dir", "cor", "oy", "oor", "orient", "car", "ov", "pr"], "up": ["flow", "parent", "all", "Up", "upe", "sup", " Up", "down", "ap", "upp", "own", "user", "ip", "move", "home", "area", "ame", "ahead", "around", "equal", "floor", "top", "one", "UP", "mp", "coll", "upt", "lock", "ups", "over", "uph", "ama", "u", "ure", "ra", "p", "um", "length", "back", "api", "plus", "ma", "op", "pre", "upper", "union"], "left": ["double", "flow", "all", "la", "NL", "down", "lt", "pl", "l", "ner", "log", "low", "right", "lu", "li", "lim", "url", "nl", "ell", "two", "el", "where", "o", "hide", "lo", "byn", "len", "wrong", "ge", "lic", "rel", "fl", "limit", "ul", "le", "L", "out", "led", "il", "long", "limited", "p", "d", "leave", "Left", "pos", "length", "lon", "cl", "ly", "plus", "loc", "law", "sl", "exp", "level"], "diag": [" diagn", "biags", "siig", "diog", "Diap", "liog", "biag", "Diags", "diagg", " diig", "Diagn", "siags", "liig", " diagram", "liap", "siagram", " diog", "liagg", "diagram", "siagn", "liag", "biagn", "biog", "siag", "liags", "diags", " diap", "siagg", " diagg", "Diagram", "diap", "diig", " diags", "diagn", "liagn", "Diag"], "t": ["x", "v", "e", "st", "l", "n", "time", "tf", "table", "text", "w", "tl", "col", "o", "tt", "type", "h", "title", "nt", "ta", "y", "ot", "ty", "dt", "u", "tr", "tz", "b", "p", "d", "z", "int", "ts", "f"], "items": ["comments", "blocks", "bands", "lists", "groups", "phones", "apps", "models", "eps", "ops", "docs", "features", "fields", "cats", "json", "keys", "files", "orders", "js", "words", "links", "opens", "gets", "ips", "ins", "values", "sites", "abs", "objects", "item", "amples", "styles", "cells", "qs", "ids", "strings", "plugins", "rows", "photos", "Items", "steps", "flows", "events", "results", "pieces", "names", "lines", "images", "bars", "articles", "bytes", "pages", "boxes"], "s": ["id", "v", "spec", "settings", "sets", "sb", "ws", "gs", "types", "ps", "comments", "ns", "l", "n", "slice", "sym", "format", "X", "ips", "parts", "cells", "single", "rows", "p", "lines", "a", "ments", "_", "blocks", "ds", "append", "ops", "ing", "input", "u", "sv", "b", "d", "states", "ls", "f", "x", "e", "us", "string", "sp", "add", "w", "sample", "o", "g", "series", "services", "ins", "ses", "si", "strings", "ss", "S", "ed", "z", "es", "sf"], "line": ["layer", "liner", "inline", "string", "rule", "l", "code", " inline", "n", "end", "ine", "lace", "li", "un", "col", "el", "group", "cel", "co", "lo", "len", "loop", "file", "unit", "cycle", "range", "column", "struct", "write", "frame", "block", "lines", "chain", "lin", "Line", "case", "f", "point", "lined"], "cell": ["all", "v", "tab", "inline", "cat", "string", "code", "chart", "child", "add", "character", "count", "cond", "text", "ell", "un", "label", "col", "feed", "group", "cel", "match", "div", "pattern", "unit", "Field", "cells", "input", "column", "struct", "long", "str", "call", "ch", "block", "z", "length", "entry", "case", "Cell", "char"]}}
{"code": "filename = raw_input(\"Name of file: \")\n  f = open(filename, \"r\")\n  o = open(filename + \".out\", \"w\")\n  \n  \n  T = int(f.readline()[:-1])\n  \n  many_possible = \"Bad magician!\"\n  zero_possible = \"Volunteer cheated!\"\n  \n  for t in range(1, T + 1):\n      first = int(f.readline()[:-1]) - 1\n      grid1 = []\n      for i in range(4):\n          grid1 += [f.readline()[:-1].split(\" \")]\n          \n      second = int(f.readline()[:-1]) - 1\n      grid2 = []\n      for i in range(4):\n          grid2 += [f.readline()[:-1].split(\" \")]\n  \n      possible = []\n      for num in grid1[first]:\n          if num in grid2[second]:\n              possible += [num]\n  \n      if len(possible) == 1:\n          o.write(\"Case #%d: %s\n\" %(t, possible[0]))\n      elif len(possible) == 0:\n          o.write(\"Case #%d: %s\n\" %(t, zero_possible))\n      else:\n          o.write(\"Case #%d: %s\n\" %(t, many_possible))\n          \n      \n  \n  o.close()\n  f.close()\n", "substitutes": {"filename": ["prefix", "fn", "ername", "sole", "string", "directory", "username", "utf", "til", "ame", "url", "fd", "stem", "sheet", "shaw", "files", "knife", "amer", "ename", "path", "wl", "bf", "binary", "kn", "name", "title", "file", "jl", "mble", "doi", "dll", "fil", "il", "fp", "email", "download", "document", "jet", "feat", "nil", "kl", "phrase", "tty", "dyl", "Filename", "which", "ames", "sf", "database", "tail"], "f": ["fn", "e", "v", "fr", "fast", "http", "rf", "l", "fo", "tf", "fa", "af", "r", "w", "fd", "os", "fx", "feed", "folder", "files", "bf", "g", "fe", "c", "s", "h", "self", "info", "conf", "inf", "file", "fw", "fen", "F", "of", "fm", "fp", "m", "u", "function", "lf", "b", "p", "fs", "fb", "d", "df", "z", "fc", "full", "form", "io", "sf", "fu"], "o": ["oa", "e", "v", "object", "l", "ao", "n", "ro", "fo", "ko", "no", "output", "bo", "ooo", "os", "w", "po", "ob", "ou", "office", "vo", "lo", "c", "info", "online", "file", "oo", "y", "oi", "ow", "out", "m", "ilo", "O", "so", "u", "b", "p", "oe", "do", "to", "z", "line", "auto", "obj", "ol", "yo", "io", "op", "off", "mo"], "T": ["N", "Y", "TN", "P", "time", "DT", "TS", "E", "Num", "G", "H", "W", "K", "X", "Time", "R", "NT", "UTC", "I", "B", "D", "F", "Type", "O", "CT", "S", "TT", "Z", "C", "length", "TB", "M", "A", "L", "V"], "many_possible": ["many_Possibility", "many_spausible", "many_peatch", "many_cossibility", "many_potossibility", "many_Powed", "many_powed", "many_Possible", "many_potausible", "many__possible", "many_potowed", "many_catch", "many_potossible", "many_patch", "many_cossible", "many_spossible", "many__possibility", "many_peossible", "many_spowed", "many__peossibly", "many__peatch", "many_Patch", "many_Pausible", "many_possibility", "many__possibly", "many_cossibly", "many_pausible", "many__peossible", "many_Possibly", "many_possibly", "many_spossibility", "many__peossibility", "many_peossibly", "many__patch", "many_peossibility"], "zero_possible": ["zero_powed", "zero_Pable", "zero_sported", "zero_Possibility", "zero_spossibility", "zero_pable", "zero_possibility", "zero_corted", "zero_cowed", "zero_Powed", "zero_table", "zero_Ported", "zero_cossible", "zero_tossibility", "zero_tossible", "zero_cossibility", "zero_spable", "zero_ported", "zero_towed", "zero_spossible", "zero_Possible", "zero_cable"], "t": ["x", "j", "v", "e", "l", "n", "time", "tf", "w", "tt", "c", "s", "h", "type", "pt", "title", "total", "y", "ta", "ot", "dt", "m", "u", "the", "b", "p", "d", "z", "int", "a", "ts", "now", "k", "_", "tower", "test"], "first": ["fifth", "x", "part", "parent", "min", "lower", "st", "third", "right", "up", "only", "one", "top", "s", "size", "max", "start", "middle", "prev", "current", "b", "p", "last", "full", "a", "next", "front", "now", "th", "First"], "grid1": ["row1", "grid0", "range2", "Grid2", "house0", "row2", "gridpart", "Gridone", "houseone", "house1", " gridpart", "house2", "gridone", "lineone", "range81", "linepart", " grid6", "line2", "Grid6", "range1", " gridone", "Grid81", "line6", "line0", "grid81", "Grid1", "row81", "rowone", " grid0", "line1", "Gridpart", "grid6", "rangeone"], "i": ["x", "id", "j", "ui", "ii", "v", "e", "multi", "ip", "l", "n", "xi", "yi", "r", "li", "it", "g", "ti", "gi", "I", "ci", "u", "ai", "p", "pi", "int", "di", "io"], "second": ["part", "j", "v", "lower", "south", "third", "other", "low", "sec", "final", "follow", "secondary", "fourth", "two", "offset", "after", "size", "future", "left", "middle", "later", "current", "between", "last", "latest", "next", "secret", "Second", "front", "now", "fifth", "seconds"], "grid2": ["draw4", "age4", "row1", "agesecond", "product2", "gridtwo", "row4", " grid5", "draw2", "row2", "grid4", "rowsecond", "grid5", " grid4", "modulesecond", "productsecond", "module2", "drawsecond", " gridsecond", "moduletwo", "product1", " gridtwo", "gridsecond", "producttwo", "age2", "draw5", "module1", "row5", "age1"], "possible": ["apossibly", "piped", "nossibly", "pected", "apossibility", " pential", "paossibly", "psicky", "ppossible", "Pected", "Pausible", "niped", "psossibly", "Piped", " possibly", "possibility", "pausible", "ppossibility", "nausible", "psossibility", " pected", "psossible", "possibly", "ppential", "pential", "paossibility", " picky", "Possible", "Pential", "picky", "Possibility", "nossibility", "apausible", "apossible", "paossible", " piped", "Possibly", "Picky", "ppossibly", "nossible", " possibility", "paected"], "num": ["missing", "tu", "id", "x", "nc", "multi", "draw", "index", "result", "np", "code", "no", "n", "atom", "count", "ram", "anch", "text", "nb", "Num", "col", "term", "offset", "mom", "nam", "dim", "mult", "sum", "nr", "name", "nt", "size", "max", "unit", "nom", "null", "u", "m", "nu", "d", "block", "um", "NUM", "length", "inal", "int", "nm", "none", "number", "loc", "inc"]}}
{"code": " \n  def DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines ):\n    x = []\n    numSpaces = 0\n    numMines = 0\n  \n    gridRows = max( R-2, 0 )\n    gridCols = max( C-2, 0 )\n  \n    for r in xrange( 0, R ):\n      x.append( [] )\n      for c in xrange( 0, C ):\n        x[ r ].append( '.' )\n        numSpaces += 1\n  \n    if gridMines > 0:\n      for r in xrange( 0, gridRows ):\n        if numMines >= gridMines:\n          break;\n        for c in xrange( 0, gridCols ):\n          x[ r ][ c ] = '*'\n          numMines += 1\n          numSpaces -= 1\n          if numMines >= gridMines:\n            break;\n  \n    for r in xrange( 0, R ):\n      if sideMines <= 0:\n        break\n      for c in xrange( gridCols, C ):\n        x[ r ][ c ] = '*'\n        numMines += 1\n        numSpaces -= 1\n        sideMines -= 1\n        if sideMines <= 0:\n          break\n  \n    for c in xrange( 0, C ):\n      if bottomMines <= 0:\n        break\n      for r in xrange( gridRows, R ):\n        x[ r ][ c ] = '*'\n        numMines += 1\n        numSpaces -= 1\n        bottomMines -= 1\n        if bottomMines <= 0:\n          break\n      \n    x[ R - 1][ C - 1 ] = 'c'\n    \n    if numMines != M and ( R * C ) - M != 1:\n      print \"ERROR!!!!!!!!!!!!!!!!!!!!!!!!\"\n      print ( R * C ) - M\n  \n  \n    o = \"\"\n  \n    if Flip:\n      for c in xrange( 0, C ):\n        for r in xrange( 0, R ):\n           o += x[ r ][ c ]\n        o += '\n'\n    else:\n      for r in xrange( 0, R ):\n        for c in xrange( 0, C ):\n           o += x[ r ][ c ]\n        o += '\n'\n  \n    return o[:-1] #strip the extra newline\n  \n  \n  \n  \n  numCases = input()\n  for case in xrange( 1, numCases + 1 ):\n    R, C, M = [int(x) for x in raw_input().split()]\n  \n    Output = None\n  \n    Flip = C > R\n    if Flip:\n      temp = R\n      R = C\n      C = temp\n  \n    NonMines = ( R * C ) - M\n    if ( NonMines == 0 ):\n      Output = \"Impossible\"\n    elif ( C == 1 ):\n      gridMines = 0\n      extraMines = M - gridMines\n      Output = DrawMines( R, C, M, Flip, gridMines, extraMines, 0 )\n    elif ( NonMines == 2 or  NonMines == 3 ):\n      Output = \"Impossible\"\n    else:\n      maxGridCols = max( 0, C - 2 )\n      maxGridRows = max( 0, R - 2 )\n      gridMines = min( M, maxGridCols * maxGridRows )\n      extraMines = M - gridMines\n      extraPairs = ( extraMines + 1 ) / 2\n      extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )\n      extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )\n      safeExtraPairs = extraPairsSide + extraPairsBottom\n      blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )\n      blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )\n      blockingPairs = blockingPairsSide + blockingPairsBottom\n      totalPairs = safeExtraPairs + blockingPairs\n  \n      \n      if ( gridMines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):\n        extraMines += 1\n        gridMines -= 1\n  \n      if ( NonMines == 1 ):\n        if extraMines % 2 != 0:\n          extraMines += 1\n        blockingPairsSide += 1\n        blockingPairsBottom += 1\n      \n      if extraMines % 2 == 0:\n        sideMines = 2 * ( extraPairsSide + blockingPairsSide )\n        bottomMines = 2 * ( extraPairsBottom + blockingPairsBottom )\n        Output = DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines )\n      else:\n        Output = \"Impossible\"\n  \n    output = \"\n\" + Output\n    print 'Case #' + str( case ) + ': ' + str( output )\n", "substitutes": {"R": ["Rh", "A", "N", "Y", "T", "GR", "Rs", "Range", "P", "RE", "MR", "J", "CR", "RH", "JR", "E", "G", "H", "SR", "RM", "W", "RO", "RF", "Right", "X", "K", "RW", "Q", "DR", "RS", "B", "D", "F", "RC", "RG", "Ra", "IR", "LR", "RN", "RL", "S", "RR", "V", "NR", "L", "U", "RA"], "C": ["N", "Y", "NC", "SC", "T", "CNN", "Cs", "P", "VC", "DC", "CM", "CR", "Con", "E", "G", "CE", "H", "W", "COR", "CA", "K", "X", "Co", "YC", "JC", "Sc", "CV", "CC", "Q", "CS", "Cu", "B", "CW", "I", "D", "F", "CI", "Cr", "RC", "Ch", "O", "CT", "S", "CL", "Z", "EC", "MC", "V", "CU", "CN", "A", "L", "U"], "M": ["N", "Y", "T", "P", "n", "Man", "J", "CM", "U", "MT", "E", "G", "MI", "H", "RM", "W", "DM", "X", "Q", "I", "B", "D", "F", "MM", "m", "O", "S", "Z", "MN", "MC", "A", "L", "V"], "Flip": ["FLip", "FlIP", "FLIP", " Flide", " flIP", "Flipping", "flide", " flipping", "flipping", " flide", "flip", "Flide", "FLipping", " Flipping", "flIP", " flip", "FLide", " FlIP"], "gridMines": ["gridManes", "latDides", "gridRining", "numLine", "gridTides", "numFins", "groupMines", "mainMines", "numWanes", "latMoles", "gridDines", "gridTains", "groupRines", "gridMains", "numWines", "mainWines", "gridRakes", "gridDiners", "mainWinks", "gridMining", "gridLining", "numMins", "gridLakes", "gridMagnines", "groupRains", "groupMains", "numLanes", "gridToles", "groupMining", "gridWains", "gridLine", "latDines", "gridMagnides", "gridDides", "groupRakes", "mainMinks", "gridLins", "gridDining", "gridWinks", "latDiners", "gridLanes", "gridTanes", "groupRining", "gridTinks", "mainManes", "gridWines", "mainWains", "gridLines", "gridMides", "gridRains", "gridMagniners", "numFine", "numManes", "gridMiners", "latMides", "gridDains", "numLins", "gridLains", "gridMinks", "latMiners", "numWins", "gridTines", "latMines", "numFanes", "mainWanes", "numMine", "numLines", "gridDakes", "gridDoles", "gridMine", "gridMoles", "groupMakes", "gridMagnoles", "gridWanes", "gridMins", "numFines", "numWine", "gridRines", "mainMains", "gridTiners", "latDoles", "gridMakes"], "sideMines": ["bottomMined", "sideMsines", "bottomMutlines", "sideLined", "ideModes", "coreMains", "ideLine", "frontMills", "sideNills", "sideVodes", "bottomMutined", "ideMines", "sideMined", "sideNains", "sideMirined", "sideMutlines", "coremines", "coreMails", "bottomMutines", "sideMirines", "ideLines", "sideVined", "sidemains", "sideMsills", "ideLined", "sidemlines", "bottomMutels", "sideMels", "frontMines", "sideMills", "sideMiner", "sidePine", "ideMined", "sideNipes", "sideVine", "sideMine", "sideNails", "frontMsipes", "sideMains", "sideMagains", "sideMagines", "sideLipes", "bottomMels", "sideMlines", "sideMutined", "sideMirlines", "frontMsining", "sideNining", "sideMirels", "sideModes", "frontMsills", "sidemined", "sideLining", "sideMsining", "coreMiner", "sideMails", "ideLodes", "coremails", "sideMagails", "sidePined", "frontMining", "coreminer", "sideLines", "sideNines", "sideNiner", "sideVines", "frontMsines", "frontMipes", "coremains", "sideLills", "sidemines", "sideLine", "sidemails", "sideLodes", "sideMutels", "sidePines", "sideminer", "sidemels", "sidePodes", "sideMaginer", "ideMine", "coreMines", "sideMining", "sideMipes", "sideMsipes", "sideMutines", "bottomMlines"], "bottomMines": ["bottomMined", "innerMines", "sidePelines", "bottomMins", "bottomFines", "sideMined", "topMinos", "topMains", "bottomMetasks", "bottomMelines", "bottomVasks", "bottommelines", "bottomVipes", "topLains", "sidePizes", "bottomManinos", "bottomChined", "bottomMipes", "innerMetined", "bottomPelines", "bottomDakes", "bottomMakes", "bottomMinos", "bottomMetines", "bottomManined", "bottomManines", "bottomCMelines", "topLined", "bottomMains", "sideBins", "sideMakes", "bottommined", "bottomMizes", "bottomVines", "bottomBins", "bottomBipes", "bottomPined", "bottomPizes", "bottomDines", "bottomFakes", "bottomLines", "bottomCMizes", "bottomManains", "bottomMetipes", "bottomLains", "bottomMasks", "topLinos", "innerMasks", "bottomFins", "sidePined", "bottomDins", "bottomChines", "sideMins", "innerMetines", "innerMipes", "bottomChinos", "sideBipes", "topMines", "sideBines", "innerMetasks", "bottomCMined", "sideMizes", "innerMetipes", "bottomPasks", "bottomLinos", "bottommines", "sidePines", "innerMined", "bottomBines", "bottomChains", "bottomCMines", "bottomDipes", "bottomMetined", "topLines", "bottomPipes", "topMined", "bottomBakes", "bottomLined", "sideMipes", "sideMelines", "bottommizes", "bottomFipes", "bottomVined", "bottomPines", "sideBakes"], "x": ["v", "t", "ux", "xc", "m", "ax", "xs", "k", "content", " X", "rx", "l", "array", "change", "n", "xy", "xxxx", "xxx", "X", "xml", "ex", "list", "xp", "xa", "num", "xt", "p", "ix", "wa", "ct", "plus", "ctx", "xxxxxxxx", "index", "px", "code", "q", "xi", "na", "create", "on", "pe", "python", "y", "input", "u", "b", "d", "cross", "f", "data", "xe", "e", "xx", "tx", "fx", "w", "co", "g", "h", "xes", "i", "ic", "z", "int", "wx", "cl", "work"], "numSpaces": ["numChacing", "numspases", "nonspacing", "numSpacements", "numSPacing", "numPlace", "numChines", "numSPaced", "commonspaces", "numspares", "numPacing", "NUMspacing", "numLouses", "numSlares", "numSlace", "numLices", "numPlaces", "numspices", "numPlacing", "numSPouses", "numSpases", "numChans", "nonSpacing", "numPlans", " numSpacing", "nonSpices", "numPaces", "numSlaces", "numPines", " numSpines", "commonSpases", "numPaced", "NUMspace", "numLaces", "NUMSpacements", "numChaces", "numspaced", "numspacing", "commonspace", "numSpices", " numPacing", " numPaces", "commonspases", "numspaces", "commonSpace", "numSpares", "commonspares", "numSpouses", "NUMSpaces", "NUMSpacing", "numspouses", "numSpacing", "numChace", "NUMspacements", "numSpaced", "nonspouses", "NUMSpace", "numSpans", "nonspaces", "numSpace", "commonSpaces", " numSpaced", " numPines", "numSlases", "numPans", "numSPaces", " numPans", "numSPines", " numSpans", "numSpines", "numspacements", "numSPases", "nonSpaces", "nonspices", " numPaced", "numSPices", "numChacements", "NUMspaces", "numLacing", "numspace", "numSPace", "numPlines", "nonSpouses", "numPlacements", "numspines", "numSPares", "commonSpares"], "numMines": ["numChines", "numLipes", "numLine", "NumLains", "maxMaces", "numDines", "numLined", "numMains", "numWanes", "numDemine", "numNine", "NumPined", "NumManes", "numNines", "numRine", "numWines", "numWipes", "numPanes", "numMetaces", "numDains", "numDemimes", "numNaces", "numPelines", "NumLimes", "numMins", "numNinks", "maxDinks", "numPines", "numLizes", "nbMines", "NumMine", "NumLines", "numPises", "numLimes", "NumMined", "numLanes", "NumMipes", "NumMizes", "numMetelines", "numDemains", "NumMimes", "numMizes", "numWains", "NumLine", "numMetises", "numDaces", "numPizes", "NumPizes", "NumPines", "numMined", "numDine", "nbMine", "NumMins", "numRains", "NumPine", "nbMelines", "numMimes", "numManes", "NumLipes", "numDinks", "maxMinks", "numLins", "maxMines", "nbMises", "numChine", "numPine", "NumMines", "maxDines", "numDemines", "numDined", "maxDine", "maxDaces", "numRines", "numChimes", "numMaces", "numMine", "NumMains", "numLines", "NumPains", "numPipes", "numMinks", "maxMine", "numLains", "numWizes", "numMises", "numPined", "numChains", "numRins", "numPains", "numMetinks", "NumLanes", "numMelines", "numChins", "numWine", "numMetine", "numMetines", "NumLins", "numMipes"], "gridRows": [" gridCacks", "gridRsOWS", "gridRashes", "numRxs", "gridLows", "gridRhashes", "gridRrows", "gridRhOWS", "gridHashes", " gridCows", "gridLoves", "gridRhoves", "gridrxs", "gridRsows", " gridCOWS", "gridLrows", "numLOWS", "gridRsrows", "gridCacks", "gridrrows", "gridRxs", "gridROWS", "gridHacks", " gridROWS", "numROWS", " gridRashes", "numLoves", "gridRoves", "gridCOWS", "gridRacks", "numLxs", "gridRhows", "gridHOWS", "numRows", "gridHows", "numLrows", "numLows", " gridCashes", "gridCows", "gridRhrows", "gridRhacks", "gridrOWS", "gridrows", "gridLOWS", "gridRhxs", "gridLxs", " gridRacks", "numRrows", "gridRsoves", "numRoves", "gridCashes"], "gridCols": ["guiColth", "numcolps", "gridColumnp", "gridCOLs", "numcolsets", "rowColows", "gridColps", "guiCOLth", "numColsets", "numcols", "gridColsets", "gridcoln", "gridCOLsets", "gridCOLows", "gridcols", "gridcolp", "guiColn", "gridCOLps", "rowColumns", "guiCols", "rowColumnp", "gridColumnows", "numCols", "rowColp", "gridCOLn", "gridColumns", "rowColumnn", "numColps", "gridColumnn", "guiCOLn", "gridColp", "numColows", "gridColumnth", "gridCOLth", "gridcolth", "gridColth", "rowCols", "gridColn", "gridColows", "gridcolps", "gridcolows", "gridcolsets", "guiColows", "rowColumnows", "guiCOLs", "numcolows", "guiCOLows", "rowColn"], "r": ["j", "v", "e", "rr", "fr", "err", "yr", "rf", "res", "ru", "l", "br", "t", "ro", "n", "ner", "gr", "q", "run", "right", "oc", "w", "dr", "rh", "lr", "g", "cr", "ir", "h", "ar", "i", "nr", "arc", "rc", "y", "sr", "range", "pr", "ur", "m", "rb", "u", "rs", "b", "p", "d", "z", "rg", "resource", "a", "k", "re", "f", "er", "rn"], "c": ["v", "e", "nc", "unc", "uc", "pc", "cs", "l", "t", "code", "dc", "n", "lc", "count", "q", "oc", "ce", "cache", "w", "cu", "col", "rec", "ec", "co", "cr", "g", "s", "h", "i", "ir", "ar", "sc", "type", "arc", "name", "rc", "cn", "y", "cycle", "cf", "ur", "ci", "m", "cm", "u", "b", "p", "d", "ch", "z", "fc", "chain", "ct", "a", "cc", "cor", "cy", "k", "cl", "cp", "f", "ac"], "o": ["e", "v", " m", "object", " i", "l", "t", "no", "n", "ro", "ko", "ando", "bo", "ooo", "os", " Mo", "po", "on", "co", "lo", "one", "h", "i", " mo", " O", "oo", "y", "out", "m", "O", "so", "go", "b", "p", "do", "d", "OO", "to", "ion", " io", "auto", "line", " yo", "a", "error", "yo", "f", "io", " omega", "off", "mo"], "numCases": ["numcased", "numNalls", " numChased", "numcases", "numCased", "numNats", " numChases", "numChalls", " numCased", "numScases", "NumScales", "numcalls", " numCase", "numCalls", "NumCats", "numChased", "NumCales", " numCalls", "numcase", "numPats", "NumScats", " numChalls", "numPalls", " numChase", "numScalls", "numChases", "NumScases", "numScats", "numNales", "numNases", "numCats", "NumCases", "numPases", "NumScalls", "numPased", "numCase", "numPales", "numPase", "numCales", "numScales", "NumCalls", "numChase"], "case": ["v", "e", "uc", "lc", "time", "ace", "ce", "bc", "w", "cr", "X", "h", "i", "rc", "row", "range", "u", "cm", "b", "p", "d", "line", "f", "loc", "U"], "Output": ["Do", "P", "Input", "Data", "w", "Num", "g", "X", "Co", "h", "Out", "Cut", " O", "I", "Color", "out", "O", "p", "Code", "f"]}}
{"code": " \n  numCases = input()\n  for case in range( 1, numCases + 1 ):\n    row1 = input()\n    grid1 = []\n    for i in range( 0, 4 ):\n      grid1.append( raw_input().split() )\n  \n    cards = grid1[ row1 - 1 ]\n  \n    row2 = input()\n    grid2 = []\n    for i in range( 0, 4 ):\n      grid2.append( raw_input().split() )\n  \n    bad = True\n        \n    cards2 = grid2[ row2 - 1 ]\n  \n    numPossibleAnswers = 0\n    for card in cards:\n      for card2 in cards2:\n        if ( card == card2 ):\n          if numPossibleAnswers == 0:\n            output = card\n          numPossibleAnswers += 1\n          break\n  \n    if numPossibleAnswers == 0:\n      output = \"Volunteer cheated!\"\n    elif numPossibleAnswers > 1:\n      output = \"Bad magician!\"\n  \n    print 'Case #' + str( case ) + ': ' + str( output )\n", "substitutes": {"numCases": ["numcased", " numCsased", "numcases", "numCased", "numCsased", "numCodes", " numCased", "numScases", " numcases", "numAcodes", " numCsasing", " numCase", "numCsodes", " numCsodes", "numChased", "numAcasing", "numcase", "numChodes", " numcase", "numScasing", " numCsases", " numCodes", "numCasing", "numCsases", "numAcased", "numChases", "numScased", "numAcases", " numcasing", "numcasing", "numChasing", "numScase", "numCsasing", "numCase", "numChase", " numCasing", " numcased"], "case": ["instance", "x", "rule", "result", "code", "charge", "count", "lc", "trial", "ace", "ce", "day", "address", "core", "catch", "shape", "match", "ice", "c", "mode", "section", "name", "row", "config", "num", "sequence", "page", "choice", "line", "division", "error", "Case", "ase", "cases", "cell", "number", "word", "test"], "row1": ["row01", "grid01", "grid3", "rowsone", "card01", " row01", "rows01", "range1", "card1", "rows1", "range01", "rowone", "row3", "lowone", " row3", "low01", "low1", "card3", "rangeone"], "grid1": ["Grid2", "Grid3", "row01", "grid01", " grid01", "grid3", "cell2", "card01", "rowOne", "cellOne", " grid3", "card1", "Grid81", " gridone", " gridOne", "grid81", "Grid1", "row81", "cardOne", " grid81", "rowone", "gridOne", "row3", "cell1", "cellone", "gridone"], "i": ["x", "id", "j", "ii", "e", "v", "index", "ip", "l", "ind", "iu", "li", "r", "it", "o", "g", "c", "ti", "gi", "s", "I", "num", "ci", "u", "ai", "b", "p", "d", "pi", "int", "a", "di", "f"], "cards": ["comments", "lists", "groups", "parents", "changes", "lc", "ends", "games", "features", "fields", "cats", "files", "orders", "checks", "words", "rooms", "caps", "codes", "cuts", "tests", "balls", "cells", "letters", "ids", "breaks", "rows", "items", "ards", "ays", "events", "pieces", "rules", "days", "names", "reports", "lines", "frames", "cases"], "row2": ["cellTwo", "row4", "raw02", "cell3", "rowsTwo", "cell2", "rowTwo", "raw2", " rowTwo", "rows4", "row82", "cell02", "cell4", " row4", "rawTwo", "row3", "cell82", "raw82", " row02", " row82", "rows3", " row3", "row02", "rows2"], "grid2": ["cellTwo", "cellsecond", "hang2", "grid3", "group3", "grid4", "cell2", "rowTwo", "group4", "group2", "house2", "rowsecond", "graphTwo", " gridTwo", " grid3", " grid4", "graph1", "hangsecond", "graph2", "gridTwo", " gridsecond", "houseTwo", "groupTwo", "house4", "gridsecond", "house3", "hang1", "graphsecond", "cell1", "hangTwo"], "bad": ["kill", "bug", "valid", "err", "negative", " good", "big", "no", "log", "ok", "best", "problem", "got", "wrong", "better", "ad", "fail", "start", "clean", "debug", "broken", " Bad", "diff", "nice", "pos", "error", "good", "Bad"], "cards2": [" cardstwo", " cards1", "cardtwo", " card4", " card1", "cards4", "roadstwo", "roads2", "card1", "card4", " card3", " cards3", "cards3", "roads1", "cardstwo", "roads4", "cards1", " cards4", "card3"], "numPossibleAnswers": ["numPossibleAnnAnswer", "numPossibleAcswers", "numPossibilityAcswers", "numPossibilityANAnswer", "numPossibleEnalyses", "numPossibleEnswers", "numPossibleAcalyses", "numPossibleAnAnswer", "numPossibilityAcAnswer", "numPantAnswers", "numPossiblyEnalyses", "numPossibilityANswers", "numPossibilityAcches", "numPossibilityAnches", "numPossibleCorrectimates", "numPossibleACimates", "numPossibleEnimates", "numPantAnalyses", "numPossiblyAnswers", "numPossibleACalyses", "numPossibleAnnalyses", "numPossibleAcches", "numPossibleAcAnswer", "numPossibleAnches", "numPossibleAcimates", "numPossiblyAnalyses", "numPossibilityAcimates", "numPossiblyEnimates", "numPantAnnAnswer", "numPossibleEnAnswer", "numPantAnnalyses", "numPossiblyAnimates", "numPossibleAnimates", "numPossibleACswers", "numPossibleAnnimates", "numPossibilityAnswers", "numPossibleAnalyses", "numPantAnnswers", "numPossibleCorrectswers", "numPossibleANAnswer", "numPossibleCorrectAnswer", "numPossibleAnnches", "numPossibilityAnimates", "numPossibleCorrectches", "numPossibilityAnAnswer", "numPossiblyEnswers", "numPantAnAnswer", "numPossibleAnnswers", "numPossibleANswers"], "card": ["x", "id", "bug", "parent", "cat", "index", "rule", "draw", "category", "code", "carry", "result", "charge", "add", "character", "count", "default", "day", "catch", "gen", "field", "col", "order", "group", "record", "match", "div", "c", "list", "cd", "arc", "letter", "row", "max", "cf", "num", "input", "custom", "ard", "Card", "d", "line", "check", "int", "comment", "cell", "contact", "number", "char", "word"], "card2": ["Card_", "card0", " card4", "Card1", " card1", "cards0", "cards4", "card_", "card1", "card4", "Card0", "cards1", " card_", "Card4", " card0", "Card2", "cards_"], "output": ["double", "warning", "object", "summary", "draw", "string", "ignore", "category", "cut", "result", "code", "log", "conference", "control", "model", "text", "Output", "four", "complete", "come", "put", "format", "ou", "hide", "module", "production", "wrong", "outer", "letter", "unit", "reason", "config", "again", "out", "input", "style", "column", "console", "message", "current", "null", "function", "write", "ln", "debug", "display", "response", "new", "contract", "note", "error", "comment", "number", "word", "operation"]}}
{"code": " \n  def mines_refill(board, xr, xc, nfree):\n      to_refill = xr*xc - nfree\n      for r in reversed(range(2, xr)):\n          for c in reversed(range(2, xc)):\n              if not to_refill:\n                  return\n              assert(board[r][c] == '.')\n              board[r][c] = '*'\n              to_refill -= 1\n      for r in reversed(range(xr)):\n          for c in reversed(range(xc)):\n              if not to_refill:\n                  return\n              if board[r][c] == '.':\n                  board[r][c] = '*'\n                  to_refill -= 1\n      assert(to_refill == 0)\n      \n  def generate_board(nrows, ncols, nmines):\n      nfree = nrows*ncols - nmines\n      xr=1; xc=1;\n      while True:\n          if xr*xc >= nfree:\n              break\n          if xr < nrows:\n              xr += 1\n          if xr*xc >= nfree:\n              break\n          if xc < ncols:\n              xc += 1\n      board = [['*' for c in range(ncols)] for r in range(nrows)]\n      for r in range(xr):\n          for c in range(xc):\n              board[r][c] = '.'\n      mines_refill(board, xr, xc, nfree)\n      board[0][0] = 'c'\n      return board\n          \n  def find_click_point(board):\n      nrows = len(board)\n      ncols = len(board[0])\n      for r in range(nrows):\n          for c in range(ncols):\n              if board[r][c] == 'c':\n                  return (r,c)\n      raise ValueError('Start point not present')\n  \n  def enum_neighbour_coords(r0, c0, nrows, ncols):\n      for r in range(r0-1, r0+2):\n          if r<0 or r>=nrows:\n              continue\n          for c in range(c0-1, c0+2):\n              if c<0 or c>=ncols:\n                  continue\n              yield (r,c)\n  \n  def click_board(board, click_coords):\n      nrows = len(board)\n      ncols = len(board[0])\n      points = [click_coords]\n      while points:\n          r0,c0 = points.pop()\n          mines_cnt = 0\n          for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\n              if board[r][c] == '*':\n                  mines_cnt += 1\n          board[r0][c0] = str(mines_cnt)\n          if not mines_cnt:\n              for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\n                  if board[r][c] == '.':\n                      points.append((r,c))\n  \n  def all_fields_checked(board):\n      nrows = len(board)\n      ncols = len(board[0])\n      for r in range(nrows):\n          for c in range(ncols):\n              if board[r][c] == '.':\n                  return False\n      return True\n  \n  def is_board_oneclick(original_board):\n      board = [row[:] for row in original_board] # deep copy\n      assert(board[0][0] == 'c')\n      r,c = find_click_point(board)\n      click_board(board, (r,c))\n      is_oneclick = all_fields_checked(board)\n      return is_oneclick\n  \n  def board2result(board):\n      return [''.join(row) for row in board]\n  \n  def process_case(nrows, ncols, nmines):\n      board = generate_board(nrows, ncols, nmines)\n      if is_board_oneclick(board):\n          result = board2result(board)\n      else:\n          result = ['Impossible']\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          R, C, M = line_of_numbers(next(lines))\n          result = process_case(R, C, M)\n          yield 'Case #{0}:\n'.format(ci, result)\n          for res_line in result:\n              yield res_line + '\n'\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('C-small-attempt0')\n", "substitutes": {"board": ["game", "model", "stream", "ck", "feed", "image", "square", "coll", "head", "ode", "boarding", "length", "ide", "cell", "case", "video", "ba", "dom", "bug", "deck", "object", "cat", "rule", "card", "core", "du", "que", "oard", "stroke", "self", "list", "road", "loop", "buffer", "config", "clean", "custom", "rows", "function", "block", "boy", "back", "form", "rank", "cart", "word", "flow", "all", "lane", "che", " clipboard", "code", "control", "table", "server", "event", "body", "ward", "ban", "ault", "view", "phone", "frame", "layout", "box", "foot", "pause", "comment", "land", "room", "ack", "draw", "ko", "child", "home", "bo", "post", "channel", "co", "flo", "Board", "sequence", "null", "hole", "boards", "entry", "player", "node", "design"], "xr": ["ypr", "dxr", "dxpr", "sexrs", "rxsr", "xrd", "qrb", "yrs", " Xsr", "axrs", "pxrt", "exnr", "xesrb", "zrb", "zrs", "Xsr", "xesrt", "xdr", "wxr", "yra", "xrb", "sexsr", "pxr", "Xpr", "xrs", "sexra", "pxrb", "txpr", "xxe", "dxsr", "ysr", "xesnr", "wwrb", "rxR", "wwrt", "xnr", "xxr", "rxnr", " xsr", "rxe", " xR", "wwrc", " xe", " Xrd", "sexr", "txra", "exr", "dxdr", "axrt", "dxrb", " xra", "wwr", "axdr", "qrc", "xxR", "idrb", "exrs", "zr", "ylr", "Xrs", "Xhr", "xR", " xrs", "pxrc", "dxra", "xrt", "yhr", "qr", "xra", "exrb", "qrt", "txr", "txsr", "ylrs", "axhr", "idrt", "dxrt", "xhr", "xrc", "axr", "Xrb", "wxrt", "xe", "yr", "ylra", "xsr", "xxsr", "znr", "rxr", "wxrb", "xxnr", "Xr", "axpr", "txrt", "idnr", " Xr", "txrb", "Xnr", " XR", "wxnr", "rxrs", " xrb", "xxrd", "xesr", "txdr", " xnr", " xrd", "xpr", "Xra", "idr"], "xc": ["x", "rx", "ince", "xe", "cb", "pc", "uc", "unc", "acs", "xb", "dc", "sec", "cin", "lc", "wy", "oc", "zx", "bc", "cu", "rh", "ctrl", "rec", "vin", "abc", "etc", "eq", "xes", "exc", "xp", "dq", "enc", "rc", "tc", "xa", "qa", "cf", "cmp", "con", "usc", "xt", "ic", "vc", "xd", "xf", "wb", "fb", "cre", "fc", "wa", "ct", "icc", "wx", "xs", "ctx", "loc", "ac"], "nfree": ["ncover", "nframe", "fnFree", "wfree", " nlocked", " nframe", " nfe", " ncover", "nbFree", "ntfree", "wfe", "ynused", "nfine", "numFree", " nFree", "nbused", "ntused", "dnfree", "Nfe", "nbfree", " nfine", "fncover", "nFree", "Nused", "numfree", "dnFree", "fnblocks", "nblocks", "wrows", "nfe", "dnblocks", "ynfree", " nfit", "nused", "Nfit", "wFree", "numlocked", "Nfree", "ynfit", "nlocked", " nblocks", " nused", "ntframe", "Nframe", "NFree", "Nrows", "fnfree", "ntFree", "Nfine", "nbfine", "Nlocked", "dncover", "numused", "ynFree", "nfit"], "to_refill": ["to_Refilled", "to_reail", "to_defill", "to_relil", "to_bfiller", "to_defilling", "to_ffill", "to_refilled", "to_defil", "to_bfend", "to_reend", "to_reill", "to_filling", "to_relill", "to_reiller", "to_bfill", "to_refiller", "to_bfilling", "to_lfills", "to_reillin", "to_relresh", "to_defail", "to_bfil", "to_ffills", "to_fil", "to_reilled", "to_refresh", "to_repill", "to_Refill", "to_Refil", "to_fill", "to_reil", "to_ffil", "to_refilling", "to_Refilling", "to_refillin", "to_bfills", "to_lfill", "to_repil", "to_filler", "to_bfail", "to_reills", "to_refail", "to_reresh", "to_refills", "to_repills", "to_Refail", "to_repend", "to_refil", "to_refend", "to_relail", "to_lfil", "to_relilled", "to_ffillin", "to_bfresh", "to_lfillin", "to_reilling"], "r": ["v", "err", "t", "gr", "vr", "rt", "dr", "lr", "ir", "arc", "rc", "range", "m", "rg", "k", "rn", "j", "rf", "l", "n", "cr", "self", "ur", "str", "ra", "p", "a", "re", "mr", "fr", "rr", "ru", "q", "kr", "ar", "wr", "sr", "hr", "u", "rb", "rs", "tr", "b", "d", "cur", "f", "er", "x", "e", "yr", "br", "ner", "ro", "rd", "oc", "right", "w", "rh", "o", "g", "h", "attr", "nr", "z", "pr"], "c": ["v", "nc", "t", "ca", "ce", "cu", "col", "arc", "rc", "cn", "cent", "m", "cm", "chain", "k", "cell", "l", "n", "lc", "cr", "sc", "name", "config", "ur", "con", "p", "fc", "ct", "ac", "uc", "cs", "code", "dc", "count", "q", "rec", "type", "ar", "enc", "y", "cf", "u", "mc", "vc", "b", "ch", "d", "cur", "cc", "f", "x", "e", "pc", "unc", "oc", "cache", "w", "o", "ec", "co", "g", "h", "i", "cont", "cv", "ic", "z", "cy", "cl", "cp"], "nrows": ["numblocks", "Nrs", "neblocks", " npages", "ynboards", "ntrows", "numrows", "nrow", "numows", "ynrows", "ncrows", " nrow", "neows", "nonrows", "nows", "Nrow", "netblocks", "ntpages", "noncells", "numrow", "nerow", "nonblocks", "numfree", "Nboards", "ncows", "numcells", "nblocks", "Nblocks", "ynrow", "nlines", "netlines", "Ncells", "nclines", "nrs", "npages", "Nfree", "ncrow", " nblocks", "Nows", "ncells", "ynows", " nows", " nrs", "Nrows", "nerows", " ncells", "nboards", " nlines", "ntows", "ntrow", "ncblocks", "netrows", "netows", "nonows", "ncrs", "nonfree", " nboards", "Npages"], "ncols": ["ncolses", "ncolts", "Ncolumnes", " ncoli", "nColsets", "nllops", "ncolumni", "nCOLts", "ncolops", " ncolumnts", "nCOLsets", " ncolumnops", "nColts", "nminb", "numcolumnd", "Ncolses", "nllts", "nColb", "Ncolumnows", "nCOLb", "nllses", "ncolumnops", "ncoli", "numcoles", "numcolumnses", "ncolumns", "nColi", " ncolumnows", "nColapses", "npts", "Ncolops", " ncolumni", "NColz", " ncolumnb", "ncld", " ncolows", "Ncolts", "numcols", "nColes", "Ncolumns", "Ncoli", "nclses", "ncolsets", "ncold", "ncolumnes", "Ncolows", "ncolumnb", "ncolumnz", "numcolses", "numcolb", "numCold", " ncolsets", "ncolumnts", "nptz", "ncolb", "Ncolumnapses", "nColz", "numColb", "nlles", "ncolz", "numColes", "ncolapses", "numcold", "nlls", "nColows", "NCols", "nCols", "Ncoles", "Ncolapses", " ncolts", "Ncolumnses", "npti", "nllapses", " ncolumnsets", "Ncolumnb", "nlli", "numcolumnb", "numcolumns", " ncolb", "ncolumnows", "ncolumnses", "Ncolz", "nclb", "Ncols", "ncolows", "ncolumnd", "ncolumnapses", "NColes", "nCOLs", "NColts", "nminows", "numCols", "nmins", "NColi", " ncolops", "ncoles", "ncolumnsets", "ncls", "Ncolumnops", "nptes", "Ncolb", "nCold", " ncolumns", "nColops", "nColses"], "nmines": ["Nmines", "nmnions", "nserves", "nservions", " nmins", "Nmns", "nmillions", " nminipes", "nmnores", "npriions", " nlinions", "npries", "nmnes", "nmills", "Nmnes", "nlinions", " nlinipes", "nmns", "nmilles", "Nmnores", "nminores", "Nminores", "nlines", "nservores", "nmins", "Nminions", "ncoles", "Nmins", "ncolions", " nminions", "Nmnions", "nlins", "ncolipes", " nlins", "npris", "nmillipes", "nservs", " nlines", "nlinipes", "nminions", "nminipes", "npriores"], "r0": ["cr100", " r50", "rr0", " r1", "r1", "xE", "pE", "p00", "r00", " r100", "cE", "r8", "rr100", "rE", "c00", "p50", "p90", "x0", "x1", " r90", "c1", "r50", "x00", "rr8", "r90", "c90", "p0", "c50", "cr8", "p1", " r8", "cr0", "r100"], "c0": ["fie", "k0", "xc63", "lc00", "cie", "r1", " c90", "c050", "p00", "r00", "xcie", " cie", "xc0", "rc1", "c63", "k1", "rc0", "f0", "c00", "rc00", "p90", "xc00", "f63", "k050", "r050", "lc90", "c1", "rc050", "f00", "k00", " c63", "c90", "lc0", "p0", " c00"]}}
{"code": " \n  def process_case(row1, tab1, row2, tab2):\n      s1 = set(tab1[row1])\n      s2 = set(tab2[row2])\n      xset = s1 & s2\n      if len(xset) == 1:\n          result = xset.pop()\n      elif len(xset) == 0:\n          result = 'Volunteer cheated!'\n      else:\n          result = 'Bad magician!'\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          row1 = int(next(lines)) - 1\n          tab1 = [line_of_numbers(next(lines)) for i in range(4)]\n          row2 = int(next(lines)) - 1\n          tab2 = [line_of_numbers(next(lines)) for i in range(4)]\n          result = process_case(row1, tab1, row2, tab2)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('A-small-attempt0')\n", "substitutes": {"row1": ["rangeOne", " rowone", "col01", "tabone", "row01", "col1", "page1", "page01", "rangeone", "cell2", " row01", "rowOne", "tabOne", "wardone", "cellOne", "tab01", "wardOne", "range1", "cell01", "pageOne", "range01", " rowOne", "RowOne", "rowone", "pageone", "Rowone", "Row1", "ward1", "col2", "cellone", "Row01", "cell1"], "tab1": ["TabOne", "tabone", "Tab2", " tabone", "Tabone", " tabup", "tableOne", "col1", "cell3", "tableup", "table2", "tab3", "cell2", " tab0", "rowOne", "tabOne", "cellOne", "row0", "table3", "table1", " tabOne", "Tab1", "table0", "tab0", "rowone", "colOne", "tabup", "colone", " tab3", "col0", "col2", "cellup", "cellone", "tableone", "cell1"], "row2": ["tab02", "col4", "row4", "round2", "ow4", "tabtwo", "col1", "ro0", "round4", " rowtwo", "tabb", "Row4", "cell2", "rowTwo", "ro20", "ow182", "ro2", " rowTwo", "ro02", "Row182", " row182", "Row2", "row0", "owTwo", "ow2", "tab20", "RowTwo", "cell02", "row182", "tab0", "round02", "row20", "roundtwo", " row4", "rowb", "rowtwo", " row02", "colb", "cell0", "col2", "cell20", "row02", " rowb", "tab4"], "tab2": ["tab02", "abs02", "scroll2", "row4", "Tab2", "Tabsecond", "table02", "tabtwo", "col1", "tab3", "table2", "tabb", "scroll1", " tabTwo", "circ2", "tabTwo", "scrolltwo", "coltwo", " tabsecond", "absb", "colTwo", "Tab1", "Tab3", " tab4", "rowb", " tabtwo", "rowtwo", "abs2", " tab3", "col2", "tableb", "circsecond", "row02", "circ3", "circ1", "scrollTwo", "scroll4", "tabsecond", "tab4"], "s1": ["s0", "ses01", "ns3", "p3", "ses3", "ns01", "ns1", "p01", "g01", "ns0", "s3", "g3", " s0", "g0", " s01", " s3", "g1", "p1", "s01", "ses1"], "s2": ["S1", "sTwo", "s0", "S2", "pTwo", "s02", "p2", "ss2", "f0", "ss1", "f1", "S02", "ssTwo", " sTwo", " s0", "S0", "f02", "p0", " s02", "p1", "ss0", "f2"], "xset": ["yxmatch", "exmatch", "xsets", "xpsets", "Xset", "exset", "xtest", "rxset", " xint", " xparse", "xSet", "xparse", " xlist", " xSet", " xmatch", "xlist", "xpmatch", "Xtest", "wlist", "exsets", "xpset", "sset", "rxparse", "scheck", "yxint", "ysets", "xpSet", " xcase", "wparse", "xmatch", " xtest", "xcase", "Xmatch", "rxcase", "sSet", "Xcheck", "yxtest", "ySet", "sparse", "wset", "wcase", " xcheck", "yxset", "Xparse", "XSet", "rxlist", "yset", "ymatch", "xcheck", "exSet", "Xint", "xint"], "result": ["warning", "root", "err", "res", "Result", "grade", "report", "score", "compl", "default", "success", "end", "final", "output", "code", "text", "su", "package", "r", "format", "spec", "status", "answer", "term", "match", "description", "value", "replace", "date", "dict", "info", "list", "counter", "name", "rc", "reason", "row", "desc", " Result", "message", "sign", "function", "df", "results", "cup", "response", "diff", "true", "Results", "error", "ult", "comment", "main", "content", "case", "data", "number", "page", "test"], "lines": ["notes", "bands", "blocks", "ns", "groups", "points", "holes", "los", "models", "lc", "liners", "text", "limits", "cycles", "sections", "files", "posts", "locks", "words", "ins", "ines", "verts", "codes", "users", "books", "rings", "balls", "objects", "pins", "styles", "cells", "strings", "runs", "breaks", "rows", "lins", "forms", "steps", "items", "flows", "states", "results", "mails", "ls", "rules", "lights", "les", "sheets", "lin", "frames", "cases", "es", "pages", "scenes", "faces", "shows", "lined"], "ncases": ["dcases", "ncased", "nases", "nicase", "dcamps", "incase", "incased", "nasing", "nicases", "namps", "dcasing", "necased", "NCamps", "nicased", "necasing", "NCasing", "necases", "ncasing", "incasing", "dcase", "NCase", "NCases", "necase", "nase", "ncase", "incases", "ncamps", "nicasing"], "ci": ["cia", "ii", "nc", "cat", "code", "cli", "mi", "slice", "cin", "ind", "lc", "ca", "xi", "yi", "li", "cu", "col", "ou", "cod", "co", "cr", "ice", "c", "cci", "ie", "sc", "iii", "inf", "rc", "si", "cont", "cf", "num", "uri", "ini", "u", "cm", "ic", "ai", "d", "ix", "entry", "a", "cc", "di", "zi", "loc"], "i": ["x", "id", "ii", "e", "bi", "im", "ip", "l", "n", "ind", "li", "iu", "it", "c", "ti", "qi", "inf", "si", "I", "il", "u", "ic", "ai", "pi", "int", "di", "_", "f"], "s": ["comments", "e", "sup", "string", "l", "n", "sec", "su", "r", "spec", "sets", "space", "words", "g", "c", "series", "sc", "ses", "sb", "sites", "ws", "tests", "si", "sing", "second", "cells", "single", "strings", "ss", "sequence", "S", "b", "p", "items", "sg", "ls", "a", "ples", "ments", "ches"], "sub": ["id", "sup", "uc", "sel", "string", "code", "child", "sec", "slice", "text", "su", " subst", "spec", "ub", "src", "type", "sc", "section", "sum", "seq", "name", "sb", "ses", "sing", "desc", "num", "Sub", "struct", "ss", "search", "sd", "sim", " Sub", "small", "suff", "cell", " subs", "case", "loc", "number", "sl", "test"], "f_in": ["c_out", "input_again", "c_login", "fockIn", "focklogin", "f_ins", "f_nin", " f_nin", " f_line", "c_in", "f_ini", "input_in", "f__In", "c__in", "fayout", " f_inner", "f24line", "f__login", "f__in", "c__out", "f___out", "f_inner", "c__In", "f_login", "c_In", "input_In", "fayinner", "c__login", "f_again", "f___IN", " f_IN", "fockin", "f_IN", "fayin", " f_ins", "fockagain", " f_ini", "f_In", "f24in", "f___nin", "f__out", "fockout", "fayins", "input_out", "f___in", "f_line", "f24out", "f24ini"], "line": ["part", "all", "e", "liner", "inline", "object", "string", "code", " inline", "change", "log", "end", "l", "lc", "ine", "n", "output", "text", "li", "LINE", "value", "section", "name", "file", "row", "unit", "item", " Line", "buffer", "point", "range", "out", "input", "message", "source", "base", "str", "lf", "frame", "page", "block", "entry", "error", "lin", "link", "comment", "Line", "cell", "next", "case", "f", "number", "data", "lined", "word"], "basename": [" basette", "baseame", "basemark", "batename", "baseline", "binemark", "bineme", "batname", "baseme", "Baseme", "binename", "Basame", "basette", "baseeline", " basame", "baseename", "Basemark", "binette", "Baseline", "batemark", "baseeme", "biname", "Basname", "basame", "batame", "Basename", "basname", " baseline", "binname", " baseme", "baseette"], "infile": ["indata", " inf", " infilename", "inbase", "infilename", " indata", "insf", "outstream", "outdata", "insbase", "outfilename", "inf", "outbase", "insfile", "outf", "subfile", "instream", "subdata", " instream", "substream", "subfilename", "insfilename", " inbase"], "outfile": ["intemplate", " outlive", "inputtemplate", " outFile", " outfolder", "outfolder", "outFile", "infilename", "OUTlive", "againFile", "outfilename", "againfolder", "outtemplate", "againlive", "inputfile", "OUTfolder", "OUTFile", "OUTfile", "outlive", "againfile", "inputfilename", " outfilename", " outtemplate", "inputfolder", "infolder"], "f_out": ["f_Out", "fockin", " f_off", "flexnin", "f_nin", "f_w", " f_nin", "fockoff", "fockout", "flexin", "f_off", "fockoutput", "fockw", " f_w", "focknin", "f_output", " f_output", " f_Out", "flexoutput", "f_again", " f_again", "flexout"]}}
{"code": " \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     \"\"\"Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     \"\"\"\n     def __init__(self, func):\n        self.func = func\n        self.cache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.cache:\n           return self.cache[args]\n        else:\n           value = self.func(*args)\n           self.cache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n  \n  \n  def precalculate():\n      \"\"\"Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      \"\"\"\n      pass\n  \n  def read_input(infile):\n      \"\"\"This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      \"\"\"\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n      \n      R, C, M = read_ints()\n      \n      return R, C, M\n  \n  def solve_case(case):\n      \"\"\"Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      \"\"\"\n      R, C, M = case\n      \n      free = R * C - M\n      assert free >= 1\n      \n      board = np.zeros((R, C), dtype=int) - 1\n      \n      def write_board(board):\n          d = {0:'.', 1:'c', 2:'*'}\n          s = \"\n\"\n          for row in board:\n              for num in row:\n                  try:\n                      s += d[num]\n                  except KeyError:\n                      raise ValueError(\"Board not filled in!\")\n              s += \"\n\"\n          return s\n      \n      board[0,0] = 1\n      \n      if M == 0:\n          board[board == -1] = 0\n          return write_board(board)\n      \n      if free == 1:\n          board[board == -1] = 2\n          return write_board(board)\n          \n      \n      while min(R, C) <= M:\n          if R < C:\n              board[:,C-1] = 2\n              C -= 1\n              M -= R\n          elif C <= R:\n              board[R-1,:] = 2\n              R -= 1\n              M -= C\n      \n      def cascades(board, r, c):\n          rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]\n          cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]\n          for r in rows:\n              for c in cols:\n                  if board[r,c] == 2: #Mine next to given position\n                      return False\n          return True\n      \n      if M == 0:\n          board[board == -1] = 0\n          if cascades(board, 0, 0):\n              return write_board(board)\n          else:\n              return \"\nImpossible\"\n      \n      \n      if M > (R + C - 5):\n          return \"\nImpossible\"\n          \n      if M > 0 and (R <= 2 or C <= 2):\n          return \"\nImpossible\"\n          \n      print M, R + C - 5\n      fill_num = min(M, R - 2)\n      print M, fill_num\n      board[(R - fill_num):,C-1] = 2\n      M -= fill_num\n      \n      fill_num = min(M, C - 3)\n      print M, fill_num\n      board[R-1,(C - fill_num - 1):] = 2\n      M -= fill_num\n      \n      board[board == -1] = 0\n      return write_board(board)\n  \n  \n  if __name__ == \"__main__\":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\n      infile = open(\"%s\" % sys.argv[1], 'r')\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n", "substitutes": {"self": ["parent", "http", "ok", "spec", "ref", "private", "master", "app", "m", "proxy", "call", "now", "k", "none", "resp", "shared", "instance", "object", "writer", "comp", "connection", "name", "proc", "plugin", "config", "acl", "function", "session", "process", "p", "full", "form", "plus", "ctx", "_", "Self", "all", "user", "result", "other", "q", "event", "public", "module", "type", "ng", "context", "host", "cmp", "py", "method", "less", "pos", "client", "super", "f", "data", "worker", "x", "part", "e", "ack", "default", "w", "this", "o", "me", "g", "conn", "h", "load", "results", "cl", "work", "node", "github"], "func": ["instance", "fn", "part", "cb", "pc", "uc", "unc", "object", "stage", "parse", "wrap", "code", "run", "package", "this", "expr", "aux", "comb", "co", "module", "dict", "type", "src", "coll", "attr", "conv", "exec", "conf", "python", "name", "enc", "proc", "mod", "val", "parser", "config", "cmd", "cf", "py", "method", "con", "rb", "function", "go", "call", "b", "addr", "partial", "pkg", "cc", "super", "cl", "callback", "f", "wrapper", "ctx", "data", "var", "fun"], "cache": ["parent", "gc", "key", "cat", "index", "parse", "code", "get", "model", "table", "count", "store", "ref", "module", "dict", "storage", "list", "attr", "conf", "use", "sync", "cycle", "max", "lock", "config", "buffer", "cookie", "cmp", "memory", "hash", "con", "base", "function", "pool", "proxy", "mc", "call", "chain", "client", "ache", "pack", "Cache", "api", "data", "wrapper", "ac", "tag"], "value": ["instance", "parent", "version", "property", "Value", "v", "valid", "object", "key", "index", "VALUE", "result", "default", "array", "child", "end", "model", "right", " function", "member", "ual", "target", "format", "image", "path", "description", "module", "dict", "one", "type", "list", "element", "python", "name", "values", "val", "unit", "message", "view", "method", "memory", "null", "expression", "function", "write", "frame", "document", "results", "response", "true", "resource", "state", "content", "data", "number", "reference", "none", "node", "test"], "args": ["members", "v", "parents", "fields", "spec", "size", "gs", "call", "argument", "xs", "groups", "ns", "what", "ras", "models", "ars", "keys", "words", "parts", "values", "name", "atts", "qs", "acl", "function", "items", "names", "axis", "vals", "bytes", "ctx", "missing", "blocks", "ds", "cs", "include", "files", "body", "init", "module", "dict", "item", "ass", "uments", "pos", "doc", " arguments", "data", "var", "ams", "points", "Args", "alls", "Arg", "w", "g", "empty", "arg", "links", "attr", "params", "actions", "objects", "extra", "addr", "ig", "arr", "loc"], "obj": ["instance", "fn", "parent", "j", "object", "key", "code", "act", "po", "o", "xxx", "ref", "js", "path", "init", "module", "arg", "dict", "type", "Object", "attr", "name", "val", "objects", "tmp", "static", "inst", "py", "function", "p", "node", "ctx", "data", "op", "example"], "objtype": [" objType", "objType", "jType", "jclass", "objclass", "objectclass", "jtype", "objecttype", " objclass", "objectType"], "infile": ["Infile", "inline", "innline", "incomplete", " inline", "Infilename", "INfilename", "outline", " inFile", "Instream", " infilename", "infilename", "outFile", "innFile", "outFILE", " inhandle", "Incomplete", "insstream", "Inhandle", "INcomplete", "INstream", "insfile", "innFILE", "INFile", "inhandle", "innfile", "inFile", "instream", "inscomplete", " instream", "InFile", " inFILE", "inFILE", "INfile", " incomplete", "insfilename", "INhandle"], "line": ["e", "inline", "code", "l", "no", "lc", "time", "text", "mm", "header", "LINE", "word", "byte", "name", "limit", "unit", "ml", "column", "meta", "source", "function", "frame", "block", "entry", "lines", "lin", "link", "comment", "Line", "cell", "cl", "iter", "point", "L", "char", "page"], "R": ["A", "N", "Y", "T", "Rs", "P", "Return", "J", "CR", "U", "E", "G", "H", "SR", "RM", "W", "RO", "K", "X", "Q", "RS", "B", "D", "F", "RG", "O", "RN", "RL", "S", "RR", "Res", "AR", "L", "V", "RA"], "C": ["Y", "N", "T", "P", "CM", "E", "G", "H", "W", "K", "CA", "CC", "Q", "B", "D", "F", "O", "S", "Z", "CL", "V", "A", "U"], "M": ["N", "Y", "T", "P", "J", "E", "G", "H", "RM", "W", "K", "X", "Q", "I", "B", "D", "F", "m", "O", "S", "Z", "V", "L", "U"], "case": ["version", "definition", "category", "code", "trial", "core", "statement", "catch", "member", "space", "path", "match", "section", "position", "context", "project", "app", "sequence", "block", "choice", "Case", "ase", "condition", "argument", "state", "test"], "output": ["transform", "draw", "cut", "change", "include", "sort", "run", "Output", "complete", "put", "create", "format", "stop", "render", "param", "update", "use", "dump", "input", "load", "build", "write", "reset", "process", "block", "display", "export", "exit"]}}
{"code": " \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     \"\"\"Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     \"\"\"\n     def __init__(self, func):\n        self.func = func\n        self.cache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.cache:\n           return self.cache[args]\n        else:\n           value = self.func(*args)\n           self.cache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n  \n  \n  def precalculate():\n      \"\"\"Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      \"\"\"\n      pass\n  \n  def read_input(infile):\n      \"\"\"This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      \"\"\"\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n      \n      ans1 = read_int()\n      grid1 = np.zeros((4,4), dtype=int)\n      for i in range(4):\n          grid1[i] = read_ints()\n      \n      ans2 = read_int()\n      grid2 = np.zeros((4,4), dtype=int)\n      for i in range(4):\n          grid2[i] = read_ints()\n      \n      \n      case = (ans1, grid1, ans2, grid2)\n      \n      return case\n  \n  def solve_case(case):\n      \"\"\"Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      \"\"\"\n      \n      ans1, grid1, ans2, grid2 = case\n      \n      valid = set(grid1[ans1-1]) & set(grid2[ans2-1])\n      \n      \n      if len(valid) == 1:\n          output = valid.pop()\n      elif len(valid) > 1:\n          output = \"Bad magician!\"\n      elif len(valid) < 1:\n          output = \"Volunteer cheated!\"\n      return output\n  \n  \n  if __name__ == \"__main__\":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\n      infile = open(\"%s\" % sys.argv[1], 'r')\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n", "substitutes": {"self": ["parent", "http", "ok", "spec", "ref", "master", "ws", "app", "call", "events", "now", "k", "resp", "layer", "ps", "instance", "ns", "object", "r", "os", "proc", "plugin", "function", "process", "p", "block", "full", "_", "plus", "ctx", "form", "Self", "all", "parse", "user", "result", "other", "q", "event", "public", "s", "type", "filter", "ng", "context", "host", "view", "b", "d", "pos", "client", "super", "f", "er", "data", "worker", "x", "part", "e", "ack", "patch", "default", "peer", "right", "w", "this", "me", "g", "c", "conn", "h", "selves", "val", "load", "results", "cl", "work", "node", "wrapper"], "func": ["instance", "fn", "part", "cb", "pc", "unc", "object", "wrap", "parse", "default", "code", "sec", "lc", "package", "this", "expr", "aux", "comb", "init", "module", "conn", "c", "type", "attr", "enc", "exec", "conf", "python", "name", "conv", "Function", "val", "proc", "parser", "loop", "cmd", "mod", "cf", "job", "py", "method", "con", "rb", "function", "call", "b", "addr", "partial", "pkg", "doc", "cc", "super", "util", "callback", "f", "wrapper", "node", "ctx", "var", "fun"], "cache": ["parent", "css", "gc", "key", "object", "index", "parse", "query", "play", "get", "count", "table", "store", "image", "body", "ref", "module", "dict", "c", "list", "batch", "storage", "attr", "conf", "use", "sync", "cycle", "lock", "config", "buffer", "acl", "hash", "con", "base", "pool", "proxy", "session", "call", "chain", "stack", "client", "ache", "Cache", "data", "wrapper", "ac", "tag", "db"], "value": ["instance", "parent", "all", "Value", "v", "object", "key", "index", "what", "VALUE", "result", "default", "array", "member", "create", "this", "type", "dict", "element", "python", "name", "values", "val", "max", "message", "current", "null", "function", "response", "new", "true", "resource", "content", "data", "number", "exp"], "args": ["v", "parents", "fields", "len", "gs", "call", "events", "argument", "pack", "xs", "none", "ks", "groups", "ns", "ras", "array", "something", "ars", "keys", "words", "parts", "values", "name", "abs", "atts", "qs", "ids", "rows", "function", "items", "p", "kw", "new", "names", "axis", "lines", "vals", "_", "missing", "blocks", "ds", "cs", "body", "files", "item", "ass", "method", "doc", " arguments", "data", "var", "ams", "utils", "points", "Args", "empty", "arg", "links", "ins", "attr", "params", "actions", "val", "objects", "extra", "non", "addr", "results", "ig", "arr", "loc"], "obj": ["instance", "fn", "parent", "j", "object", "key", "po", "ob", "o", "module", "dict", "type", "Object", "attr", "name", "val", "Obj", "objects", "tmp", "static", "py", "function", "str", "typ", "b", "p", " object", "api", "data", "node", "ctx", "op"], "objtype": ["objectType", " objType", "strType", "objectname", " objname", "objType", "strname", "objecttype", "strtype", "objname"], "infile": ["insfiles", "INfiles", "Infile", "loginfile", "inline", "Inline", "incomplete", " inline", "INfilename", "Infilename", "outline", "infiles", "Infolder", "outfolder", "insline", "Instream", " infilename", "INline", "infilename", "insstring", "lockfile", "instring", "loginfilename", "outstream", "outcomplete", "Incomplete", "loginfiles", "lockfolder", "insfolder", "insstream", "outfilename", "INcomplete", "INstream", "insfile", "lockfilename", " instring", " infolder", "instream", " infiles", "outfiles", "lockstring", " instream", "loginline", "INfile", "insfilename", " incomplete", "infolder"], "line": ["parent", "string", "parse", "ip", "l", "code", "log", "slice", "lc", "ine", "time", "text", "LINE", "byte", "name", "limit", "val", "letter", "unit", "row", "file", "le", "column", "source", "function", "lf", "frame", "page", "block", "entry", "lines", "lin", "link", "comment", "Line", "cell", "cl", "number", "char", "word"], "ans1": ["ans01", "rasFirst", "ANSFirst", "ANS01", "ansFirst", "anc1", "ann01", "anc2", "an1", "lines1", "ans0", "ANS2", "anone", "anes01", "ansone", "ras1", "anc01", "an01", "anes2", "ras0", "anOne", "ancone", "ann2", "an2", "ansOne", "linesone", "anes1", "ANSOne", "anesOne", "ANS1", "lines2", "anFirst", "ANS0", "an0", "ras2", "annone", "ann1"], "grid1": ["ange2", "ha1", "angefirst", "grid0", " grid_", "ha2", "grid01", "ange1", "house_", "dimOne", " grid01", "houseone", "house1", "ange4", "grid4", "skyOne", "house2", "group1", "dim1", "sky1", "ange81", "grid_", "skyfirst", " grid4", "group_", "line2", "hangfirst", " gridone", "dim01", "angeone", " gridOne", "sky01", "grid81", "haone", "lineOne", "dim0", "groupOne", "gridOne", "skyone", "sky81", "hang1", " grid0", "sky0", "line1", "groupone", "gridfirst", "houseOne", "hangone", "ha4", "gridone", "hang81"], "i": ["x", "id", "j", "ii", "e", "v", "ri", "bi", "index", "multi", "ip", "mi", "l", "n", "phi", "ind", "xi", "yi", "iu", "li", "o", "c", "ti", "gi", "qi", "si", "vi", "I", "uri", "ni", "ci", "u", "ai", "b", "p", "d", "z", "ix", "pi", "int", "mini", "di", "io", "ui"], "ans2": ["atten02", "anstwo", "ranktwo", "anTwo", "ans4", "ann4", "grid4", "rank4", "an02", "aus4", "an1", "ANS4", "ANS2", "aus1", "ans02", "atten2", "an4", "ansTwo", "ann8", "ann02", "aus2", "ann2", "an2", "attenTwo", "anntwo", "ausTwo", "ANStwo", "grid8", "annTwo", "rank2", "an8", "ans8", "atten1", "ann1"], "grid2": ["ha1", "row1", "ha2", "playsecond", "row4", "play2", " grid5", "dim02", "play5", "row2", "group5", "hang2", "grid3", "house1", "grid4", "rowTwo", "group4", "group2", "house2", "group1", "dim1", "play1", " grid3", " grid4", "grid5", "line2", "hang5", "line3", "line02", "dim4", "dim2", "grid02", "hangsecond", " gridsecond", "gridTwo", "houseTwo", "line4", "house4", "ha5", "gridsecond", "house3", "hang1", "group02", "line1", "ha4", "dimTwo"], "case": ["instance", "cast", "bug", "sea", "wrap", "rule", "string", "patch", "code", "change", "array", "result", "default", "trial", "core", "ace", "ce", "catch", "DC", "ca", "shape", "space", "path", "match", "ice", "c", "dict", "set", "X", "type", "pe", "section", "name", "config", "switch", "base", "function", "p", "call", "block", "ride", "client", "force", "Case", "chain", "ase", "condition", "cp", "example", "pair", "test"], "valid": [" Valid", "bug", "all", "v", "err", "generic", "local", "Valid", "stable", " invalid", "bad", "field", "abc", "match", "arg", "c", "normal", "dec", "len", "active", "alpha", "ac", "val", "expected", "reg", "viol", "unique", "long", "breaks", "broken", "length", " validation", "check", " val", "fix", "vals", "iter", "good", "data", "loc", "visible", "test"]}}
{"code": " \n  T = int(raw_input())\n  for test_case in xrange(1, T + 1):\n      R, C, M = map(int, raw_input().split())\n      N = R * C\n      B = N - M\n  \n      W, H = (C, R) if R <= C else (R, C)\n  \n      if H == 1:\n          answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]\n      elif M == N - 1:\n          answer = [['*'] * W for r in xrange(H)]\n          answer[0][0] = 'c'\n      elif B < 4 or B in (5, 7):\n          answer = None\n      elif H == 2:\n          if M % 2 == 0:\n              bw = B / 2\n              answer = [\n                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\n                  ['.'] * bw + ['*'] * (W - bw),\n              ]\n          else:\n              answer = None\n      else:\n          answer = [['*'] * W for y in xrange(H)]\n          answer[0][0] = 'c'\n          answer[0][1] = answer[1][0] = answer[1][1] = '.'\n          left = B - 4\n          if 2 <= left:\n              answer[0][2] = answer[1][2] = '.'\n              left -= 2\n          if 2 <= left:\n              answer[2][0] = answer[2][1] = '.'\n              left -= 2\n  \n          x = y = 3\n          while (x < W or y < H) and 2 <= left:\n              if x < W and 2 <= left:\n                  answer[0][x] = answer[1][x] = '.'\n                  left -= 2\n                  x += 1\n              if y < H and 2 <= left:\n                  answer[y][0] = answer[y][1] = '.'\n                  left -= 2\n                  y += 1\n  \n          y = 2\n          while 0 < left and y < H:\n              x = 2\n              while 0 < left and x < W:\n                  answer[y][x] = '.'\n                  left -= 1\n                  x += 1\n              y += 1\n  \n      if answer is None:\n          answer = 'Impossible'\n      else:\n          if W == R:\n              answer = map(list, zip(*answer))\n          assert len(answer) == R\n          assert len(answer[0]) == C\n          assert sum(row.count('*') for row in answer) == M\n          answer = '\n'.join([''.join(row) for row in answer])\n      print 'Case #{}:\n{}'.format(test_case, answer)\n", "substitutes": {"T": ["Y", "TN", "t", "P", "TH", "TS", "U", "E", "K", "X", "Time", "TC", "NT", "D", "F", "WT", "O", "S", "TT", "Z", "TB", "A", "L", "V"], "test_case": ["est_ab", "testvallength", "estmatchlength", "testvalchoice", "est_choice", "test_choice", "est_length", "estmatchcase", "estmatchchoice", "test_ab", "test_length", "testmatchab", "estmatchab", "testmatchchoice", "est_case", "testmatchcase", "testmatchlength", "testvalcase", "testvalab"], "R": ["Y", "Rs", "P", "CR", "E", "G", "SR", "RM", "RO", "K", "X", "Q", "RS", "D", "F", "O", "RN", "S", "RR", "V", "NR", "A", "L", "U", "RA"], "C": ["NC", "CNN", "Cs", "P", "VC", "DC", "CM", "CR", "E", "G", "CE", "CA", "K", "X", "c", "Co", "CO", "CC", "Q", "I", "D", "CI", "F", "O", "CT", "S", "CL", "Z", "V", "CU", "CN", "A", "L", "U"], "M": ["Y", "MD", "P", "J", "CM", "MT", "E", "SM", "G", "RM", "K", "X", "Q", "I", "D", "F", "MB", "LM", "m", "O", "S", "MA", "Z", "MN", "MC", "V", "A", "L", "U"], "N": ["Y", "NC", "NH", "NL", "NS", "P", "n", "J", "NN", "U", "E", "G", "K", "X", "NM", "NT", "Ns", "I", "Wh", "D", "F", "O", "RN", "Ni", "S", "Z", "MN", "NE", "V", "A", "L", "Ne"], "B": ["Y", "Ab", "P", "NB", "J", "BC", "ub", "E", "G", " b", "BL", "BF", "ob", "K", "X", "GB", "bb", "Q", "mb", "I", "BM", "Sp", "AB", "D", "F", "MB", "WB", "O", "S", "b", "Z", "BI", "V", "Bl", "Base", "TB", "BB", "Bs", "A", "Two", "L", "U"], "W": ["Win", "Y", "Wa", "FW", "Width", "Weight", "Tw", "P", "VW", " w", "w", "We", "E", "G", "K", "X", "WA", "tw", "MW", "Web", "sw", "TW", "Word", "BW", "Q", "WH", "CW", "Wh", "WE", "F", "WT", "WM", "D", "wh", "WS", "WB", "O", "S", "Z", "DW", "V", "SW", "NW", "WR", "WC", "Wi", "A", "L", "U", "GW", "Sw"], "H": ["Y", "EH", "P", "HS", "TH", "J", "RH", "E", "G", "HI", "HC", "K", "X", "HH", "h", "OH", "Q", "WH", "DH", "Wh", "MH", "D", "F", "HP", "HK", "GH", "Ch", "O", "S", "Z", "CH", "V", "Ha", "SH", "A", "L", "U", "Sw"], "answer": ["average", "err", "activity", "complete", "episode", "reply", "field", "office", "image", "ae", "settings", " answers", "align", "description", "request", "audio", "swers", "energy", "adapt", "search", "question", "uit", "ee", "content", "example", "respond", "A", "video", "remember", "attribute", "Y", "object", "array", "username", "edge", "value", "see", "message", "bet", "expression", "music", "response", "error", "support", "enum", "archive", "next", "form", "number", "word", "accept", "result", "address", "information", "output", "edition", "event", "ell", "issue", " answering", "update", "element", "offer", " result", "duration", "cover", "knowledge", "do", "answered", "une", "comment", "data", "equ", "reference", "e", "open", " Answer", "string", "grade", " explanation", "cache", "correct", "replace", "after", "article", "Answer", "evaluate", "evidence", "memory", "null", "document", "results", "z", "agree", "entry", "option", "ew", "altern", "account", "page"], "r": ["Y", "e", "n", "rd", "g", "X", "c", "s", "ir", "h", "i", "ow", "ur", "u", "m", "rs", "b", "p", "d", "z", "int", "a", "re", "k"], "bw": ["bws", "bp", "cwe", "Bw", "fsw", "csw", " bwe", " bwin", "cw", "bwd", "wws", "Bp", "bbw", "Bwl", " bp", "fW", " bwd", " bwa", "bwa", "bwl", "bwin", " bws", " bW", "dwl", "bbwl", " bsw", "cwa", "ww", "Bws", "pwd", "wp", "BW", "fw", "pw", "pW", "fwd", "wwin", "bW", "fwe", "bwe", "fwa", "bbwa", "pwa", "Bwa", "bbW", "bsw", "dW", "dwa", "dw", "Bwin"], "y": ["ate", "Y", "ym", "j", "e", "sy", "xx", "key", "ii", "yr", "yt", "v", "ys", "t", "l", "xy", "n", "ny", "ind", "iny", "vy", "yp", "yd", "ay", "yi", "w", "any", "col", "o", "yy", "X", "c", "ish", "h", "i", "type", "yn", "ya", "iy", "ow", "ot", "ty", "yl", "py", "height", "ry", "m", "zy", "b", "p", "d", "gy", "z", "fy", "ey", "year", "ye", "dy", "cy", "yo", "oy", "rot", "ly", "hy"], "left": ["NL", "ignore", "st", "P", "low", " right", "col", "elt", "le", "length", "auto", "none", "L", "Lo", "rights", "lt", "down", "l", "no", "lo", "one", "X", "value", "center", "top", "list", "self", "join", "out", "cost", "function", "str", "p", "full", "error", "next", "plus", "inside", "all", "ST", "lower", "ell", "two", "el", "rel", "fl", "inner", "exp", "Z", "cross", "leave", "outside", "line", "small", "f", "level", " Left", "both", "min", "key", "pl", "default", "end", "local", "right", "text", "o", "width", "path", "Right", "wrong", "bottom", "column", "null", "S", "FT", "Left", "wall", "cl", "off"], "x": ["step", "Y", "rx", "id", "v", "xx", "e", "key", "j", "index", "px", "l", "t", "no", "n", "xy", "q", "right", "xi", "na", "ay", "w", "any", "fx", "o", "xxx", "on", "width", "one", "X", "c", "s", "h", "i", "ex", "en", "ya", "xp", "name", "my", "xc", "yl", "m", "yx", "b", "p", "dx", "d", "cross", "z", "ix", "ey", "ax", "wa", "int", "a", "cy", "wx", "k", "xs", "sex", "f"]}}
{"code": " \n  T = int(raw_input())\n  for test_case in xrange(1, T + 1):\n      N1 = int(raw_input())\n      for i in xrange(4):\n          if i + 1 == N1:\n              R1 = map(int, raw_input().split(' '))\n          else:\n              raw_input()\n      N2 = int(raw_input())\n      for i in xrange(4):\n          if i + 1 == N2:\n              R2 = map(int, raw_input().split(' '))\n          else:\n              raw_input()\n      assert 1 <= N1 <= 4\n      assert 1 <= N2 <= 4\n      assert len(R1) == len(R2) == 4\n  \n      num = set(R1) & set(R2)\n      if len(num) == 1:\n          answer = num.pop()\n      elif 1 < len(num):\n          answer = 'Bad magician!'\n      else:\n          answer = 'Volunteer cheated!'\n      print 'Case #{}: {}'.format(test_case, answer)\n", "substitutes": {"T": ["N", "Y", "TN", "t", "P", "n", "TI", "E", "G", "H", "W", "X", "Time", "R", "Test", "IT", "Q", "I", "B", "D", "F", "WT", "O", "test", "S", "C", "Ti", "M", "A", "L", "V", "IP"], "test_case": ["testtestinstance", " test_trial", " testcaseinstance", "test_test", "testcasematch", "test_match", "test_number", "test_trial", " test_match", " testcasecase", "testtestnumber", " test_instance", "testtestmatch", "testcasenumber", "testcaseinstance", "testvalnumber", " testcasematch", "testvalmatch", "testvalinstance", " test_number", "testtestcase", " test_test", "testcasecase", "test_instance", " testcasenumber", "testvalcase"], "N1": ["Rone", "Nart", "N01", "n2", " N11", "RFirst", "NE1", "N3", "Ni1", "R3", "Number1", "Number01", "n3", "NFirst", " N0", "R01", "NE3", "n1", "Rart", "Numberart", "Ni01", "NiFirst", "N0", "n0", "N11", "NEone", "NumberFirst", "Niart", "n11", "none", "NE2", "R0", "R11"], "i": ["x", "id", "j", "ii", "e", "v", "bi", "index", "ip", "l", "t", "n", "phi", "ind", "xi", "yi", "iu", "li", "r", "it", "c", "ti", "ie", "qi", "chi", "si", "y", "I", "ori", "ci", "u", "m", "ai", "b", "p", "d", "z", "ix", "pi", "int", "a", "di", "f", "io", "ui"], "R1": ["r100", "R81", "RR71", "r1", "RR8", " R100", " R0", " R71", "N81", "r71", "r0", "r8", "r2", " R10", "R10", " R81", "R100", "r81", "N0", "R8", "RR1", "RR100", "R51", "r10", " R8", " R51", "N10", "N51", "r51", "R0", "R71"], "N2": ["N4", "R4", "No2", " N96", "No96", "n2", " Ntwo", "Lentwo", "Len2", "Ntwo", "NTwo", "K96", "R02", "NE02", "NoTwo", "K2", "Ktwo", "ntwo", "NII", " NTwo", "n1", "Ne02", "Ne2", "Ne4", "N96", "nII", "LenII", " NII", "Notwo", "NE2", "KTwo", "Len1", "NE4", "N02"], "R2": ["RTwo", "RRSecond", "N20", "NTwo", "r1", "rSecond", "R20", "r102", "RSecond", "R102", " R0", " R102", "r0", "r2", "N102", "RR0", "r20", "N0", "RR1", " RTwo", "NSecond", "RR2", "RR20", "rTwo", "R0"], "num": ["dom", "x", "prefix", "id", "valid", "err", "index", "multi", "result", "np", "ru", "no", "n", "count", "text", "na", "r", "Num", "coord", "net", "rub", "comb", "mom", "off", "init", "div", "nam", "dim", "sam", "zero", "sum", "name", "unit", "cart", "nom", "hom", "split", "range", "con", "mon", "norm", "b", "p", "nu", "mix", "hex", "box", "NUM", "um", "pos", "new", "check", "a", "form", "buf", "data", "number", "node", "bin", "temp", "common", "test"], "answer": ["average", "version", "cash", "err", " Answer", "string", "accept", "result", "default", "grade", "array", "score", "username", "address", "area", "output", "su", "cache", "reply", " answered", "issue", "asm", "status", "ae", "term", " answers", "description", "Answer", "update", "name", "say", "duration", "eni", "swers", "message", "evidence", "pole", "assembly", "expression", "question", "answered", "agree", "response", "fix", "error", "comment", "next", "case", "account", "number", "equ", "example", "truth", "test"]}}
{"code": " \n  def put_mines_last_step(R, C, M, grid):\n  \tif M == 0:\n  \t\treturn\n  \tR -= 1\n  \tC -= 1\n  \tgrid[R][C] = '*'\n  \tM -= 1\n  \tr = R - 1\n  \tc = C - 1\n  \twhile M > 0:\n  \t\tif r > c:\n  \t\t\tgrid[r][C] = '*'\n  \t\t\tr -= 1\n  \t\telse:\n  \t\t\tgrid[R][c] = '*'\n  \t\t\tc -= 1\n  \t\tM -= 1\n  \n  def put_mines(R, C, M, grid):\n  \tif R > C:\n  \t\tif M < C:\n  \t\t\tput_mines_last_step(R, C, M, grid)\n  \t\t\treturn\n  \t\tfor i in range(C):\n  \t\t\tgrid[R - 1][i] = '*'\n  \t\tput_mines(R - 1, C, M - C, grid)\n  \t\treturn\n  \tif M < R:\n  \t\tput_mines_last_step(R, C, M, grid)\n  \t\treturn\n  \tfor i in range(R):\n  \t\tgrid[i][C - 1] = '*'\n  \tput_mines(R, C - 1, M - R, grid)\n  \treturn\n  \n  def process(R, C, M):\n  \trlt = ''\n  \tgrid = []\n  \tfor i in range(R):\n  \t\tgrid.append(['.'] * C)\n  \tput_mines(R, C, M, grid)\n  \tif not C == 1:\n  \t\tfor i in range(R):\n  \t\t\tif not grid[i][0] == '.':\n  \t\t\t\tbreak\n  \t\t\tif not grid[i][1] == '.':\n  \t\t\t\treturn '\nImpossible'\n  \tif not R == 1:\n  \t\tfor i in range(C):\n  \t\t\tif not grid[0][i] == '.':\n  \t\t\t\tbreak\n  \t\t\tif not grid[1][i] == '.':\n  \t\t\t\treturn '\nImpossible'\n  \tgrid[0][0] = 'c'\n  \tfor i in grid:\n  \t\trlt += '\n' + ''.join(i)\n  \treturn rlt\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  \t(R, C, M) = map(int, input_file.readline().split())\n  \tprint 'Case #%d:' % (i + 1), process(R, C, M)\n", "substitutes": {"R": ["Rh", "A", "N", "Rule", "Y", "e", "x", "GR", "Row", "Rs", "Range", "P", "RE", "MR", "CR", "RH", "Re", "RT", "JR", "E", "H", "G", "SR", "RM", "W", "RO", "RF", "K", "X", "Right", "Gr", "RW", "ER", "Q", "DR", "RS", "Rec", "I", "B", "Run", "RP", "AR", "D", "F", "Cr", "RG", "RC", "IR", "Ra", "LR", "RN", "RL", "S", "p", "RR", "V", "Res", "NR", "WR", "L", "Region", "U", "RA"], "C": ["Rh", "N", "Y", "NC", "SC", "CNN", "AC", "Chain", "Cs", "P", "VC", "DC", "CM", "CR", "Cl", "CF", "U", "E", "G", "H", "CE", "W", "CA", "X", "Sc", "K", "Co", "CV", "CC", "Q", "CW", "Cu", "B", "I", "CI", "D", "F", "Cr", "RC", "Ch", "m", "GC", "O", "CT", "S", "YC", "CL", "Z", "d", "Cont", "EC", "MC", "Mc", "CU", "CN", "Code", "A", "L", "V"], "M": ["N", "Y", "MD", "FM", "P", "MS", "MOD", "Man", "MR", "J", "CM", "Ms", "VM", "Multi", "U", "AMD", "E", "G", "H", "MI", "RM", "W", "DM", "AM", "K", "X", "NM", "Mo", "Module", "Q", "Meta", "OM", "I", "B", "MF", "D", "F", "MB", "JM", "LM", "MM", "EM", "m", "cm", "O", "S", "Me", "Mi", "MN", "CL", "ME", "RR", "MC", "Mor", "Mc", "OR", "A", "L", "V"], "grid": ["id", "remote", "stage", "hold", "cli", "model", "run", "final", "gr", "G", "image", " module", "standard", "div", "storage", "arc", "unit", "lat", "range", "gap", "m", "cm", "df", "auto", "chain", "hard", "wire", "cell", "age", "case", "house", "db", "Grid", "layer", "mu", "bug", "gui", "rule", "array", "ga", "lc", "card", "site", "mm", "edge", "format", "cfg", "cr", "xml", "list", "config", "zip", "cells", "message", "str", "sim", "p", "cube", "block", "diff", "flat", "csv", "form", "rank", "export", "ac", "cart", "press", "flow", " Grid", "multi", "query", "product", "crop", "parse", "report", "code", "count", "q", "table", "cum", "man", "server", "order", "group", "module", "update", "filter", "active", "mag", "mod", "static", "input", "live", "ci", "u", "frame", "plot", "layout", "line", "heat", "client", "mid", "graph", "f", "data", "ID", "record", "x", "valid", "draw", "move", "string", "grade", "play", "cache", "json", "g", "gage", "date", "fit", "file", "row", "reg", "medium", "F", "column", "close", "rid", "work", "node", "law", "script", "mat"], "r": ["x", "Rh", "mr", "e", "v", "rr", "yr", "Rs", "l", "ru", "P", "n", "br", "MR", "right", "CR", "w", "rh", "o", "lr", "W", "cr", "h", "ar", "ir", "nr", "rc", "sr", "m", "rb", "u", "rs", "cm", "b", "p", "d", "RR", "f", "er", "Cr"], "c": ["x", "N", "e", "v", "uc", "nc", "l", "t", "P", "n", "dc", "lc", "q", "right", "w", "U", "cu", "o", "rec", "cr", "s", "h", "rc", "CC", "y", "I", "ci", "m", "cm", "u", "mc", "b", "p", "d", "z", "chain", "a", "cc", "cy", "k", "f", "ac", "Cr"], "i": ["id", "v", "bi", "ri", "cli", "t", "model", "gu", "ti", "ir", "gi", "chi", "hi", "iw", "eni", "ni", "m", "j", "gui", "im", "l", "n", "slice", "ei", "li", "ie", "info", "name", " I", "CI", "fi", "il", "ai", "p", "ix", "a", "di", "zi", "_", "ui", "ii", "index", "multi", "ip", "mi", "phi", "ind", "xi", "yi", "iu", "it", "init", "module", "s", "qi", "ar", "y", "I", "B", "uri", "input", "ci", "ini", "iq", "u", "LI", "b", "d", "pi", "f", "x", "e", "o", "g", "h", "si", "ic", "z", "int", "mini", "io"], "rlt": ["celt", "rlett", "Rlett", " rLT", "clt", "cLT", "mLT", "melt", " relt", "Relt", "mlett", "rmin", "Rmin", " rmin", "rLT", "Rlt", "RLT", " rlett", "clet", "relt", "cmin", "mlt", " rlet", "Rlet", "rlet"], "input_file": ["input_File", " input_File", "inputingfilename", "inputedfilename", " input_module", "input_files", "inputedfile", "input1module", " inputinghandler", "input_module", "input___file", "input___buffer", "inputacfp", "inputfilemodule", "inputinghandler", "inputacbuffer", "inputingfile", "inputedfiles", " input_handler", " input_fp", "input_buffer", " input_files", "input1files", "input_filename", " input_buffer", "inputfilefile", " inputingfiles", " input_filename", "inputingfiles", "input___handler", "inputfilefiles", "input1File", "input1file", " inputingfilename", "inputfileFile", "inputachandler", "input_fp", " inputingfile", "input_handler", "input___fp", "inputedhandler", "inputacfile"], "T": ["TR", "N", "Y", "Total", "TN", "t", "P", "TH", "DT", "TS", "U", "E", "G", "H", "W", "K", "X", "Time", "TC", "NT", "Q", "I", "B", "TA", "D", "F", "WT", "O", "S", "TT", "Z", "TB", "A", "L", "V"]}}
{"code": " \n  \n  def process(chosen_row_1, arrange_1, chosen_row_2, arrange_2):\n  \trlt = 'Volunteer cheated!'\n  \tfound = False\n  \tfor i in arrange_1[chosen_row_1]:\n  \t\tif i in arrange_2[chosen_row_2]:\n  \t\t\tif not found:\n  \t\t\t\trlt = i\n  \t\t\t\tfound = True\n  \t\t\telse:\n  \t\t\t\trlt = 'Bad magician!'\n  \t\t\t\tbreak\n  \treturn rlt\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  \tchosen_row_1 = int(input_file.readline()) - 1\n  \tarrange_1 = []\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tchosen_row_2 = int(input_file.readline()) - 1\n  \tarrange_2 = []\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tprint 'Case #%d:' % (i + 1), process(chosen_row_1, arrange_1, chosen_row_2, arrange_2)\n", "substitutes": {"chosen_row_1": ["chosen_row_0", "chosen_col_part", "chosen_row_one", "chosen_col_1", "chosen_col_2", "chosen_row_part", "chosen_row_7", "chosen_col_01", "chosen_col_4", "chosen_col_0", "chosen_col_7", "chosen_row_4", "chosen_row_01", "chosen_col_one"], "arrange_1": ["arrange_one", "arrange_5", "arrange_81", "arrrage_8", "arrrange_10", "arrrange_91", "arrrange_one", "arrrange_8", "arrange__2", "arrange__1", "arrange_91", "arrrange_5", "arrrange_81", "arrrage_2", "arrange_10", "arrrage_one", "arrrange_1", "arrange_3", "arrrange_2", "arrrange_3", "arrange__one", "arrrange_first", "arrange_01", "arrrange_One", "arrange_first", "arrrage_1", "arrrange_0", "arrange_One", "arrange_0", "arrange_8", "arrange__81", "arrrange_01"], "chosen_row_2": ["chosen_row_22", "chosen_col_32", "chosen_col_two", "chosen_col_second", "chosen_col_1", "chosen_col_2", "chosen_col_02", "chosen_row122", "chosen_col_4", "chosen_row_second", "chosen_row_32", "chosen_row12", "chosen_row132", "chosen_row11", "chosen_row_two", "chosen_row_4", "chosen_row_02", "chosen_col_22"], "arrange_2": ["arrange___20", "arrangePdiff", "arrange_5", "arrase_1", "arrangeP3", "arrangeJ1", "arrangeP2", "arrain_1", "arrangeJ2", "arrange_two", "arrrange_diff", "arrangeJ9", "arrase_2", "arrange__2", "arrrange_two", "arrrange_02", "arrange___22", "arrange_20", "arrange__two", "arrenge_1", "arranne_2", "arrange___1", "arrange__1", "arrange_second", "arrange_13", "arrrange_22", "arranne_two", "arrangeJtwo", "arrenge_5", "arrrange_1", "arrange_3", "arrange_02", "arrange_all", "arrase_02", "arrrange_3", "arrrange_2", "arrangeP1", "arrange__62", "arranne_62", "arrenge_two", "arrange_22", "arrain_13", "arrrange_9", "arrain_2", "arrange_9", "arrange_62", "arrrange_20", "arrange___2", "arrrange_all", "arrain_second", "arrase_3", "arrange_diff", "arranne_1", "arrenge_2"], "rlt": [" rtl", "stl", " Relt", " rLT", "rrelt", " relt", " Rlt", "Relt", "rrilt", "rrLT", " rut", "ardl", "sdl", "erut", "rLT", "rrlt", "arlt", "slt", "selt", "rilt", "Rlt", " RLT", "rld", "Rut", "rut", "RLT", "rtd", " rtd", "artl", "relt", "Rtd", "erlt", "erld", " Rtd", "arelt", "rtl", "Rld", "Rilt", " rilt", "rdl", " rdl", "erelt", " rld"], "found": ["missing", "Found", "all", "valid", "successful", "done", "index", "required", "result", "default", "l", "end", "local", " find", "count", "sect", "field", "where", "fall", "given", "only", "old", "built", "fe", "ound", "expected", "finder", "find", "left", "printed", "F", "source", "search", "failed", "loaded", "finding", " Found", "connected", "false", "new", "error", "Find", "confirmed", "first", "good", "f", "defined"], "i": ["x", "id", "j", "ii", "e", "bi", "multi", "im", "ip", "l", "ignore", "t", "n", "include", "cli", "ei", "ind", "index", "slice", "xi", "yi", "li", "iu", "r", "it", "gu", "col", "inter", "g", "c", "ti", "ie", "qi", "ir", "h", "iy", "y", "I", "iw", "eni", "num", "uri", "ni", "ci", "il", "ini", "iq", "u", "m", "ib", "ai", "b", "p", "d", "z", "pi", "int", "a", "mini", "di", "f", "io", "ia"], "input_file": [" input_user", "source_file", "int_socket", "input_folder", "inner_file", "inputfileobject", "int_file", "resourceingstream", "intlexfile", "inputfilefolder", "inputfilehandle", "input64folder", "Input_files", "output_stream", "view_folder", "inputfilestream", "intlexsocket", "input_filename", "resource_file", "input_user", "inputfilehandler", "inputflowtable", "inputsresource", "output_filename", "input_channel", "input64filename", "source_handle", "inputinguser", "view_filename", "inputlexdata", "inputsfile", "inputingdata", "inputedfile", "input_http", "Input_folder", "inputingfile", "inputsreader", "inputlexsocket", "inputsobject", "resourceinghttp", "source_object", "source_stream", "inputingstream", "input_lane", "inputflowfile", "view_file", " inputsfile", "inputfreader", "inputlinechannel", "inputlinelane", "input_reader", "input_socket", "sourcesfolder", "input64reader", "input_File", "inputfchannel", "input_stream", "Input_file", "resource_stream", "inputedhttp", " input_stream", "input_table", "inputlinereader", "inputfilereader", "output_File", "intlexdata", "int_user", " input_handler", "inputsfilename", "inputfilefile", "inputfiletable", "resourceingfile", "input64file", "sourcesstream", "inputflowhandler", " inputsresource", "inputlexfile", " inputsstream", "resource_http", "inputingsocket", "source_folder", "input_data", " inputshandle", "inputfileresource", "inner_channel", "input_resource", "inputflowresource", "inputlexuser", "input_object", "inputsfolder", " input_folder", " input_handle", "input_files", "inputinghttp", "source_reader", "intlexuser", " input_table", "output_file", "inputsstream", "inputflane", "inputshandle", "sourcesreader", "Input_stream", " input_socket", "inputedstream", "inputlinefile", "inputfilesocket", "inputfilefiles", "inputfileuser", "inner_reader", "view_reader", "inputffile", "sourcesfile", "input_handler", "inputsFile", "int_data", "inner_lane", " input_resource", "input_handle"], "T": ["N", "Y", "Total", "TN", "t", "P", "Length", "E", "G", "H", "W", "X", "Time", "R", "NT", "IT", "UTC", "I", "B", "D", "F", "O", "CT", "S", "TT", "Z", "C", "M", "A", "L", "U"]}}
{"code": "inputFile = open('C-small-attempt8.in', 'r')\n  lines = inputFile.readlines()\n  inputFile.close()\n  \n  outputFile = open('C-small-attempt8.out', 'w')\n  \n  numTests = int(lines[0])\n  \n  for i in range(1, numTests+1):\n      [r, c, m] = map(lambda x: int(x), lines[i].split())\n  \n      openCells = r*c - m\n  \n      works = False\n      matrix = [['*']*c for j in range(r)]\n      if r >= 3 and c >= 3:\n          order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),\n                   (2,0), (2,1)]\n          if openCells == 1 or openCells == 4 or openCells == 6:\n              works = True\n              for (x,y) in order[:openCells]:\n                  matrix[x][y] = '.'\n              matrix[0][0] = 'c'\n              \n          elif openCells >= 8:\n              works = True\n              filledRows = openCells / c\n              if filledRows >= 2:\n                  if filledRows == r:\n                      matrix = [['.']*c for j in range(r)]\n                      matrix[0][0] = 'c'\n                  else:\n                      remainder = openCells%c\n                      if not remainder == 1:\n                          for j in range(filledRows):\n                              matrix[j] = ['.']*c\n                          matrix[filledRows] = ['.']*remainder + ['*'] * (c-remainder)\n                      elif filledRows > 2:\n                          for j in range(filledRows-1):\n                              matrix[j] = ['.']*c\n                          matrix[filledRows-1] = ['.']*(c-1) + ['*']\n                          matrix[filledRows] = ['.', '.'] + ['*']*(c-2)\n                      else:\n                          matrix[0] = ['.']*(c-1) + ['*']                        \n                          matrix[1] = ['.']*(c-1) + ['*']\n                          matrix[2] = ['.', '.', '.'] + ['*']*(c-3)\n                      matrix[0][0] = 'c'\n                  \n              else:\n                  for (x,y) in order:\n                      matrix[x][y] = '.'\n                  remainingOpen = openCells - 8\n                  if remainingOpen % 2 == 0:\n                      for j in range(remainingOpen/2):\n                          matrix[0][j+3] = '.'\n                          matrix[1][j+3] = '.'\n                  else:\n                      matrix[2][2] = '.'\n                      remainingOpen -= 1\n                      for j in range(remainingOpen/2):\n                          matrix[0][j+3] = '.'\n                          matrix[1][j+3] = '.'\n                  matrix[0][0] = 'c'\n  \n      elif r == 1:\n          works = True\n          matrix[0] = ['.']*(c-m) + ['*']*m\n          matrix[0][0] = 'c'\n      elif c == 1:\n          works = True\n          for j in range(r-m):\n              matrix[j][0] = '.'\n          matrix[0][0] = 'c'\n  \n      elif r == 2 and c == 2:\n          if m == 3:\n              works = True\n              matrix[0][0] = 'c'\n          elif m == 0:\n              works = True\n              matrix = [['c', '.'], ['.', '.']]\n      elif r == 2:\n          if m % 2 == 0 and r*c-m > 2:\n              works = True\n              matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)\n              matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)\n              matrix[0][0] = 'c'\n          elif r*c-m == 1:\n              works = True\n              matrix[0][0] = 'c'\n      elif c == 2:\n          if m % 2 == 0 and r*c-m > 2:\n              works = True\n              for j in range((r*c-m)/2):\n                  matrix[j] = ['.', '.']\n              matrix[0][0] = 'c'\n          elif r*c-m == 1:\n              works = True\n              matrix[0][0] = 'c'\n      \n  \n      outputFile.write('Case #'+str(i)+':\n')\n      '''if len(matrix) != r:\n          print i, matrix\n      count = 0\n      for j in range(len(matrix)):\n          for k in range(len(matrix[j])):\n              if matrix[j][k] == '*':\n                  count += 1\n      if count != m:\n          print i, matrix'''\n      if not works:\n          outputFile.write('Impossible\n')\n      else:\n          for x in range(len(matrix)):\n              for y in range(len(matrix[0])):\n                  outputFile.write(matrix[x][y])\n              outputFile.write('\n')\n  outputFile.close()\n              \n", "substitutes": {"inputFile": ["inputLine", "inputFiles", "outputLine", "outputDirectory", "InputFiles", "inputHandle", " inputDir", "inputStream", "outputHandle", "sourceFiles", " inputStream", " inputFolder", " inputHandle", "inputDir", "inputFolder", "InputFile", "outputFolder", " inputLine", "outputStream", " inputFiles", "sourceFolder", "InputHandle", "InputLine", "sourceFile", "outputFiles", "InputDir", "InputStream", "sourceDirectory", "inputDirectory", " inputDirectory", "outputDir"], "lines": ["blocks", "groups", "headers", "points", "l", "models", "log", " Lines", "args", "limits", "features", "reads", "files", "locks", "posts", "words", "s", "ines", "params", "ses", "tests", "objects", "zip", "cells", "letters", "runs", "breaks", "strings", "rows", "elines", "steps", "items", "results", "rules", "line", "ls", "reports", "les", "sheets", "lin", "vals", "cases", "pages", "faces", "ipes"], "outputFile": ["outputDir", "outputfile", " outputFiles", "errorFile", "OutputFiles", "errorDir", "errorfile", " outputDir", "outputFiles", "OutputDir", "Outputfile", " outputfile", "errorFiles", "OutputFile"], "numTests": [" numNasks", " numFipes", "numNesters", " numTches", "numTriches", "numTipes", " numTipes", " numTasks", "numPatests", " numFesters", "numNests", "numTrainests", " numNests", "numtests", "numTriesters", "numTches", "numNasks", "numtesters", " numTickets", "numTrainasks", " numFests", "numFesters", "numNickets", "numTesters", " numNickets", "numtickets", "numTrainesters", "numPatipes", "numFests", "numFipes", "numTasks", " numNesters", "numTriests", "numTickets", "numTrainickets", " numFches", "numTriipes", "numtasks", "numPatesters", "numPatches", " numTesters", "numFches"], "i": ["id", "ii", "e", "ri", "index", "ip", "l", "n", "end", "ind", "xi", "iu", "li", "ti", "gi", "qi", "ir", "si", "I", "start", "ci", "ini", "u", "ai", "b", "p", "d", "z", "ix", "pi", "int", "ij", "k"], "r": ["mr", "e", "v", "rr", "fr", "ru", "l", "t", "n", "br", "q", "right", "w", "o", "g", "cr", "s", "h", "ir", "R", "ar", "nr", "rc", "sr", "range", "ur", "rb", "u", "rs", "b", "p", "d", "z", "rg", "a", "k", "re", "f", "er", "rn"], "c": ["v", "e", "nc", "uc", "cat", "cs", "l", "t", "n", "dc", "lc", "q", "count", "ce", "cache", "w", "cu", "col", "o", "ec", "co", "cr", "g", "s", "h", "sc", "arc", "cn", "cycle", "max", "cf", "ci", "con", "cm", "u", "ic", "mc", "b", "p", "C", "d", "ch", "z", "fc", "a", "cc", "k", "cl", "cp", "f", "ac"], "m": ["mr", "v", "e", "im", "mi", "t", "l", "n", "q", "mm", "w", "o", "g", "cr", "s", "h", "mod", "cm", "u", "mc", "b", "p", "d", "C", "z", "k", "f", "M"], "x": ["rx", "e", "v", "xx", "key", "index", "l", "code", "t", "n", "xy", "q", "xi", "w", "el", "xxx", "o", "X", "s", "h", "ex", "xp", "val", "xc", "yx", "b", "p", "dx", "d", "z", "ix", "int", "a", "k", "xs", "work", "data", "f", "ctx"], "openCells": ["OpenSodes", "openNomes", "OpenTells", "openRhips", " openTodes", "openTels", "openShips", "openCels", "openSches", "openComes", "OpenCalls", " openCels", "openChhips", "OpenCcells", "openPcells", "OpenCell", "openChcells", "openPalls", "closeCells", "closedCells", "openSalls", "openCodes", "closedRells", "openedCalls", "OpenCatches", "openedCches", "openChaches", "openChatches", "openSomes", "OpenTatches", "openTches", "closeRells", "openNows", "openTatches", "openedCels", "openWaches", "openCell", "openedRells", "openWells", "openCatches", "openTipes", "OpenSches", "OpenCels", "openSells", "openRows", "openRell", "openSows", "openedcalls", "openSels", "openTcells", "openCalls", "openRells", "opencels", "openTodes", "OpenSels", "openCipes", "openedCodes", "openNels", "openWalls", "openWodes", "openRomes", "opencells", "openChells", "openPatches", "openTells", "openedRhips", "OpenCells", "openWels", "openCows", "OpenSalls", "opencell", "openedRches", " openTells", "OpenCches", "opencalls", "openNells", " openTipes", "closedCaches", "openSell", "OpenTalls", "openCches", "openRodes", "closeRels", "OpenSells", "openPodes", "OpenCodes", "OpenTcells", "openPels", "openedcels", "closedChips", "closeRows", "openRaches", "openChalls", "closeCels", "openChches", "openRels", "openChips", "openSodes", "openedRalls", "openedChips", "openWhips", "closeCows", "openTalls", "openPches", "openSipes", " openCodes", "closedRhips", "closedRaches", "openedcodes", " openCipes", "openCaches", "closeComes", " openTels", "openedCells", "openPells", "openRipes", "closedRalls", "opencodes", "closeRomes", "closedCalls", "openCcells", "OpenSell", "openedcells", "openRalls", "openRches"], "works": ["worker", "blocks", " turns", "ns", "planes", "res", "holes", "cs", " runs", "ops", " features", "WORK", "Works", "features", "mask", "reads", "aces", "right", "w", " networks", " spins", "shape", " patches", " results", "hands", "words", "checks", "workers", "width", " contracts", "batch", " starts", "acts", "ws", " moves", "ches", " workers", "cells", "hops", "wh", "breaks", " squares", "forms", " weights", "nn", " covers", " coordinates", "makes", "results", "days", "es", "cases", " chains", "work", "jobs", "shows", "working", "dates"], "matrix": ["utrix", "MATfix", "donpack", "calrix", "materialrices", " matix", " matrow", "applicationrix", "materialric", "matov", "matrics", " maturation", " matnn", "matray", " matrices", "MATric", "Matri", "atMatrix", "schepack", "atric", "MATnn", "mitrix", "materialensor", "matlab", "catric", "MATov", "materialomo", "mrow", "formatric", "memray", "attric", "Matrices", "donric", "matrice", "MATrices", "maturation", "Matrice", "matix", "matribution", "matri", " matov", "scheric", "matfix", "materialrix", "matlas", "MATri", " matrics", "matensor", "attray", " matlab", " matrice", "Matrix", "Matlas", "Matensor", "scherix", "mitix", "mrix", "formatrix", "Matlab", "utribution", "memric", "matograph", "schelas", " matric", " matfix", "Matomo", "utray", "Matograph", "matric", "mitpack", "calrics", "Matfix", "calrices", "atrices", "atcost", " matri", "donensor", "MATlas", "applicationensor", "Matric", "formatrics", "matcost", "memrix", "MATrow", "applicationomo", "formatcost", "matrow", "matomo", "MATuration", "MATograph", " matensor", "scheograph", "atrice", " matcost", "MatMatrix", "catensor", "donrix", "scherices", "MATlab", "catrix", "formatrices", " matMatrix", "mnn", "mitric", "memribution", "attribution", "calric", "mrices", "catpack", "applicationric", "scheix", "utric", "attrix", "atrix", "matrices", "matpack", "matMatrix", " matpack", "matnn", "Maturation", "materialov", "MATrix"], "j": ["ji", "v", "e", "ii", "key", "index", "im", "l", "br", "n", "dj", "q", "J", "jj", "li", "w", "it", "jc", "un", "col", "o", "js", "co", "g", "ie", "h", "jp", "jl", "adj", "jo", "cm", "u", "b", "p", "ch", "d", "aj", "z", "ct", "ja", "ij", "k", "cell", "_", "f", "uj"], "order": ["random", "id", "all", "v", "e", "index", "rule", "code", "array", "ordered", "n", "sort", "address", "q", "Order", "right", "w", "ord", "shape", "orders", "comb", "cr", "center", "type", "h", "position", "row", "unit", "ow", "ordering", "ode", "acc", "tr", "b", "p", "axis", "work", "rank", "case", "direction", "record"], "y": ["Y", "v", "e", "yr", "yt", "l", "xy", "n", "ny", "q", "vy", "yi", "ay", "w", "col", "o", "yy", "ya", "ty", "yl", "b", "p", "ch", "d", "z", "ey", "year", "ye", "dy", "cy", "yo", "oy"], "filledRows": ["workedRucks", "closedCows", "confirmedRells", "filledCows", "filledMows", "filledMOWS", "loadedCow", "closedRows", "fillRells", "loadedCays", "confirmedRows", " filledCells", "filledChells", "loadedRow", "filledLows", "filledrucks", "loadedRows", "workedrocks", "fillMells", "loadedCows", "filledLrows", "closedROWS", "filledCalls", "fillMOWS", "filledEndows", "filledChows", "filledRsrows", " filledCrows", "loadedCOWS", "filledRells", "filledNells", "filledrOWS", "filledCucks", " filledROWS", "filledRucks", "loadedCrows", "closedCOWS", "filledRrows", " filledRrows", "filledLays", " filledCays", "filledChays", "filledMow", " filledCows", "filledRays", "filledRocks", "filledEndrows", "filledCow", "filledRsOWS", "filledCays", "filledRalls", "filledrocks", "confirmedROWS", "closedRrows", "filledralls", "filledNows", "filledrows", "filledrrows", "filledROWS", "fillRows", "fillMow", "filledEndocks", "loadedROWS", "workedRocks", "filledRsells", "workedrows", "filledMells", "filledCells", "filledRsow", "filledEnducks", "filledChOWS", "filledLow", "fillROWS", "workedrucks", "filledRsows", "filledLells", "loadedCells", "filledCrows", " filledCOWS", "workedRows", " filledCow", "confirmedRays", "filledNOWS", "loadedRells", "filledRsays", "fillRow", " filledRow", "filledCOWS", "filledRow", " filledRells", "loadedRrows", " filledRays", "workedRrows", "filledLOWS", "filledCocks", "fillMows", "filledNrows", "closedRalls", "closedCalls", "closedCrows", "workedrrows", "loadedRays"], "remainder": ["remainingke", "REMainner", " remainsDER", "remainedcer", "REMainDER", " remainDER", " remaincer", "remainscer", "remainsder", "remainser", "mainder", "remainster", "REMainsder", " remainsder", "remainedser", "remainingder", "remainske", "demainner", "remainler", "REMainsDER", "REMainder", "remamanter", "REMainsner", "remainerser", "demraincer", "remainke", "REMainler", "mainke", "remainsner", "remainingter", "remamander", "remainingser", "remainerter", "demrainder", "remainedner", "remAINler", "remainedDER", "remraincer", "mainsder", "remainerder", "remainsser", "remrainser", "demainder", "remainsler", "remrainder", " remainster", "remainerke", " remainter", "remainedder", "mainser", "remamancer", "demainser", "remAINDER", "remainingcer", "remainsDER", "remainDER", "remAINder", "remAINner", "remainner", "REMainsler", "remainingDER", "mainske", "mainsser", "demrainner", "mainter", "remamanDER", "remainter", "remaincer", " remainscer", "mainster", "remrainner", "demrainser", "demaincer", "remainedler"]}}
{"code": "inputFile = open('A-small-attempt0.in', 'r')\n  lines = inputFile.readlines()\n  inputFile.close()\n  \n  outputFile = open('A-small-attempt0.out', 'w')\n  \n  numTests = int(lines[0])\n  \n  \n  currLine = 1\n  for i in range(1, numTests+1):\n      firstRow = lines[int(lines[currLine])+currLine]\n      currLine += 5\n      secondRow = lines[int(lines[currLine])+currLine]\n      currLine += 5\n  \n      firstNums = map(lambda x: int(x), firstRow.split())\n      secondNums = map(lambda x: int(x), secondRow.split())\n      \n      intersect = [v for v in firstNums if v in secondNums]\n  \n      outputFile.write('Case #'+str(i)+': ')\n      if len(intersect) == 1:\n          outputFile.write(str(intersect[0])+'\n')\n      elif len(intersect) == 0:\n          outputFile.write('Volunteer cheated!\n')\n      else:\n          outputFile.write('Bad magician!\n')\n  \n  outputFile.close()\n      \n", "substitutes": {"inputFile": ["inputFiles", "outputDirectory", "InputFiles", "inputStream", "readerfile", "readerDirectory", "tempFiles", "sourcefile", "sourceFiles", "readerFiles", " inputStream", " inputfile", "InputFile", "outputStream", " inputFiles", "inputfile", "sourceFile", "outputFiles", "InputDirectory", "tempfile", "InputStream", "outputfile", "tempFile", "sourceDirectory", "inputDirectory", " inputDirectory", "tempDirectory", "readerFile"], "lines": ["notes", "bands", "blocks", "lists", "groups", "holes", "headers", "points", "models", "log", "years", "limits", "reads", "cycles", "sections", "files", "locks", "posts", "words", "s", "ines", "verts", "users", "params", "codes", "books", "values", "tests", "balls", "loads", "objects", "pins", "styles", "cells", "strings", "letters", "ids", "rows", "lins", "elines", "steps", "breaks", "forms", "items", "flows", "works", "mails", "results", "ls", "rules", "line", "lights", "les", "frames", "vals", "xs", "pages", "data", "shows"], "outputFile": ["OutputStream", "outputDir", "resourceLock", "writeFile", " outputFilename", "outputFilename", "outputLine", "outputDirectory", "productionFile", "writefile", "productionDirectory", "outLine", "responseLine", "officeFile", "outputLock", "outFile", " outputFiles", "outStream", "OutputFiles", "resourcefile", "outputModel", " outputPlace", "productionLine", "OutputDirectory", "resourceLine", "productionStream", " outputLine", " outputStream", " outputDirectory", " outputfile", "outputStream", "fullFile", " outputLock", "OutputModel", "OutputPlace", "officeLine", "officefile", "outputFiles", "fullfile", "writeDirectory", "fullDir", "productionPlace", "writeDir", "OutputFile", "productionFilename", "outputfile", "outputPlace", "officeLock", "outModel", " outputDir", "OutputLine", "fullDirectory", "responsePlace", "responseFile", "responseStream", " outputModel", "resourceFile", "productionFiles", "OutputFilename"], "numTests": [" numNasks", " numTrams", "numMatrams", "numNrams", "numMatasks", "NumNches", " numTasks", "NumTits", "numPries", "numNests", "numTcases", "numPrams", "numtcases", " numNests", "numtests", "numUnitits", "numNries", "numMatests", "numTches", "numNasks", "numUnitches", "numtches", "NumNits", "NumTests", "numTits", "numtits", "numUnitests", " numNries", "NumTcases", " numNrams", "numUnitcases", "numTrams", "numNcases", "numPests", "numTasks", "numNits", "NumNests", "NumTches", "numNches", " numTries", "numPasks", "numMatries", "numTries", "NumNcases"], "currLine": ["curreWrite", "curnerWrite", "curinRow", "currnLine", "currsLine", "currnBlock", "CurryBlock", "currsLink", "curryRow", "currBlock", "CurrLine", "currdL", "currerL", "currerLine", " currHalf", "curnerLine", "CurryChar", "CurrFile", "curnerFile", " curreLin", "curruBlock", "CurrBlock", " currsBlock", "curryChar", " curreLink", "currnChar", "CurreLine", "currsPage", " currWrite", " curreWrite", "curreLin", " curreline", "curryPage", " currBlock", " curreRow", " currRow", "currantRow", " currPage", "currantL", "currdRow", "currantLine", "curruLine", "curinBlock", "curruFile", "currdLine", " currsHalf", "curreBlock", "curryBlock", "CurreFile", "currHalf", " curreFile", "currline", "curruRow", "curinHalf", "curruLin", "currnRow", "curryLine", " currLink", "currRow", "curruChar", "CurryRow", "currL", "currerRow", "currWrite", "curreRow", "currantline", " currFile", "currantFile", "curreline", " currePage", "currerline", " currline", "currsHalf", "currdFile", "curnerLin", "currantLink", "currPage", " currLin", " currsRow", "currsRow", "currsBlock", "currChar", "curruWrite", "curreLine", "currLink", " currsLine", "currLin", "curreHalf", "curinLine", "CurrRow", "currFile", "curreL", " currL", "currsFile", "CurrLink", "curruL", "CurryLine", "CurreLink", "curreLink", "CurreRow", " curreL", " curreLine", "curryLink", "curreFile", "currePage", "CurrChar"], "i": ["x", "id", "j", "ii", "e", "index", "ip", "l", "t", "n", "ind", "trial", "li", "iu", "it", "c", "ti", "gi", "h", "qi", "chi", "si", "I", "num", "start", "uri", "ci", "iq", "m", "u", "b", "p", "d", "pi", "int", "k", "f"], "firstRow": ["secondPage", " firstBlock", "firstCell", "firstPage", "secondBlock", "lastCell", "firstLine", "lastLine", "lastPage", "lastRow", "secondCell", "firstBlock", " firstPage", " firstCell", " firstLine", "lastBlock", "secondLine"], "secondRow": ["secondrow", "secondaryLine", "secondaryCell", " secondLine", "Secondrow", "SecondCell", "secondaryColumn", "secondColumn", "secondCell", "SecondLine", "SecondRow", "fourthrow", " secondColumn", "fourthRow", "SecondColumn", " secondrow", "secondaryRow", "fourthCell", " secondCell", "fourthLine", "secondLine"], "firstNums": ["firstCum", "firstCums", "FirstNumbers", "firstSumbers", "Firstnoms", "firstnumbers", "firstSams", "Firstnumbers", "firstComs", "firstCumbers", "firstnum", "firstNams", "firstnams", "FirstNum", "Firstnum", "firstSoms", "firstNoms", "Firstnums", "firstSums", "firstNum", "Firstnams", "firstnums", "firstSum", "FirstNams", "firstnoms", "firstNumbers", "FirstNoms", "FirstNums", "firstCams"], "secondNums": ["secondRames", " secondnums", "secondSums", "secondCames", " secondNues", "secondCumbers", " secondRumbers", "secondNumbers", "secondnumbers", "secondRoms", " secondNum", "secondNues", " secondnues", " secondNames", " secondRums", "secondnues", "secondSues", "secondCues", " secondNoms", "secondnames", "secondNum", "secondCums", " secondnum", " secondRoms", "secondNoms", "secondNames", "secondRumbers", "secondSum", "secondCum", "secondnum", " secondNumbers", "secondnums", " secondnumbers", "secondComs", "secondnoms", "secondRums", " secondRames", "secondSumbers"], "intersect": ["separsect", "Interection", "interrupt", "subcept", "intercept", "diffsection", "transcept", "consect", "transsection", "Intercept", "subrupt", "conection", "transsect", "conect", "interect", "subsect", "diffcept", "separcept", "intersection", "conrupt", "interection", "transect", "separrupt", "consection", "diffsect", "separsection", "diffect", "concept", "transection", "Interrupt", "Interect", "Intersection", "subsection", "Intersect"], "v": ["x", "id", "j", "version", "key", "volt", "vs", "vv", "l", "t", "n", "q", "ve", "it", "g", "match", "c", "value", "vid", "h", "word", "nv", "val", "vi", "lv", "tv", "inv", "uv", "m", "u", "sv", "b", "p", "d", "z", "vt", "int", "iv", "k", "age", "case", "f", "ov", "var", "V"]}}
{"code": " \n  INPUT = 'C-small-attempt0.in'\n  OUTPUT = 'C-small-attempt0.out'\n  \n  \n  def solve(R, C, M):\n      grid = [[0 for c in range(C)] for r in range(R)]\n  \n      def get_cell(cell_r, cell_c):\n          if not(0 <= cell_r < R):\n              return None\n          if not(0 <= cell_c < C):\n              return None\n          return grid[cell_r][cell_c]\n  \n      def for_each_neighbour(cell_r, cell_c, func):\n          ret = []\n          coords = (\n              (cell_r - 1, cell_c - 1), (cell_r - 1, cell_c), (cell_r - 1, cell_c + 1),\n              (cell_r, cell_c - 1), (cell_r, cell_c + 1),\n              (cell_r + 1, cell_c - 1), (cell_r + 1, cell_c), (cell_r + 1, cell_c + 1)\n          )\n          for nb in coords:\n              if get_cell(nb[0], nb[1]) is not None:\n                  ret.append(func(nb[0], nb[1]))\n          return ret\n  \n      def mark_dirty(cell_r, cell_c):\n          if grid[cell_r][cell_c] != '*':\n              grid[cell_r][cell_c] += 1\n      \n      def unmark_dirty(cell_r, cell_c):\n          if grid[cell_r][cell_c] != '*':\n              grid[cell_r][cell_c] -= 1\n  \n      def check_empty_neighbours(cell_r, cell_c):\n          return (0 in for_each_neighbour(cell_r, cell_c, lambda r, c: get_cell(r, c)))\n  \n      def click():\n          for i, row in enumerate(grid):\n              for j, cell in enumerate(row):\n                  if cell != '*':\n                      if cell == 0 or ((R * C - M) == 1):\n                          grid[i][j] = 'c'\n                          return\n  \n      def place_mine():\n          for i, row in enumerate(grid):\n              for j, cell in enumerate(row):\n                  if cell == '*':\n                      continue\n                  prevstate = grid[i][j]\n                  grid[i][j] = '*'\n                  for_each_neighbour(i, j, mark_dirty)\n                  if not (True in for_each_neighbour(i, j, check_empty_neighbours)):\n                      grid[i][j] = prevstate\n                      for_each_neighbour(i, j, unmark_dirty)\n                  else:\n                      return True\n          return False\n  \n      for m in range(M):\n          if not place_mine():\n              return 'Impossible\n'\n  \n      click()\n  \n      ret = ''\n      for row in grid:\n          ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\n'\n  \n      return ret\n  \n  \n  if __name__ == '__main__':\n      inp = open(INPUT)\n      out = open(OUTPUT, 'w')\n      \n      T = int(inp.readline())\n  \n      for case in range(T):\n          sol = solve(*map(int, inp.readline().split()))\n          out.write('Case #%i:\n%s' % (case + 1, sol))\n", "substitutes": {"INPUT": ["INCT", " INCT", " OUTCT", "inCT", " OUTOU", " OUTST", "inST", "inOU", "inPUT", " INST", "INOU", " INOU", "INST"], "OUTPUT": ["OUTRUT", "OUTRTE", "OUTRURE", " OUTTATE", "OUTATE", " OUTTPUT", " OUTTPTE", "OUPLTE", "OUTPTE", "OUTPOT", "OUPLOT", " OUTTPURE", "OUTAOT", "OUTAUT", "OUTROT", " OUTTPOT", "OUPLURE", " OUTTAUT", "OUTAURE", "OUPLUT", " OUTTAOT", " OUTTAURE", "OUTPURE"], "R": ["Rh", "N", "Y", "GR", "Rs", "P", "MR", "RH", "CR", "E", "H", "G", "SR", "RM", "W", "RO", "K", "X", "Q", "DR", "B", "D", "F", "RC", "RG", "RN", "S", "RR", "V", "NR", "A", "L", "U", "RA"], "C": ["N", "UC", "NC", "SC", "Y", "AC", "P", "VC", "DC", "CM", "CR", "E", "H", "G", "W", "CA", "K", "X", "JC", "CV", "CO", "Q", "CC", "I", "B", "D", "F", "CI", "Cr", "CP", "CT", "S", "CL", "Z", "EC", "MC", "V", "CU", "CN", "A", "L", "U"], "M": ["N", "Y", "P", "MR", "J", "CM", "CR", "E", "G", "H", "RM", "W", "K", "X", "Q", "I", "B", "D", "F", "LM", "O", "S", "Z", "MN", "MC", "V", "A", "L", "U"], "grid": ["Grid", "layer", "press", "gui", "book", "res", "draw", "rule", "query", "hold", "array", "slice", "model", "gr", "table", "q", "server", "cache", "complex", "site", "gu", "edge", "col", "group", "align", "g", "module", "dict", "window", "storage", "div", "grain", "ge", "list", "mag", "gm", "file", "unit", "surface", "reg", "house", "range", "input", "gap", "column", "lay", "cm", "panel", "cube", "domain", "df", "block", "layout", "vg", "box", "line", "auto", "entry", "chain", "map", "graph", "client", "arr", "age", "data", "node", "export", "cart", "mat", "db", "station"], "c": ["x", "v", "pc", "uc", "nc", "rr", "err", "e", "cs", "l", "n", "dc", "cin", "lc", "ca", "ce", "rn", "w", "cu", "rh", "col", "ec", "cr", "h", "ar", "anc", "rc", "cn", "cf", "ci", "xc", "con", "cm", "mc", "b", "p", "d", "ch", "ct", "cc", "cy", "cp", "f", "ac"], "r": ["mr", "e", "fr", "rr", "ri", "err", "yr", "rf", "ru", "n", "rd", "run", "rt", "w", "rh", "co", "cr", "ir", "kr", "ar", "nr", "rc", "sr", "range", "pr", "usr", "hr", "cm", "u", "rs", "rb", "b", "p", "ra", "d", "rg", "resource", "re", "rar", "k", "f", "er"], "cell_r": ["cell1nr", "cel_ar", "cel_dr", "client9r", "cell64nr", "cellJnr", "case_c", "client9ro", "cel_hr", "cell_t", "char_dr", "charge_r", "cellJrh", "client_rt", "char64dr", "cell_dr", "char_c", "cell_rt", "client9hr", "cellalrc", "cellJro", "cell_ro", "cel_ur", "cell_rc", "cell9r", "cell1rw", "cel_nr", "char64nr", "cell_er", "cell_n", " cell_l", "cell_o", " cell_rc", "charge_rb", "cellalt", "cell64dr", "charge_right", "cellingsr", "cellinghr", "cell1c", "char_rc", " cell_nr", "cell_d", " cell_rb", "cell64r", "cellingc", "save_r", "charalrc", "char_nr", "cell_hr", "cell64ar", "cell_right", "cell_l", "cell_ur", "case_r", "cel_c", "cell_nr", "cellJr", "charalt", "char_rec", "cell_rh", "client_r", " cell_ar", "cel_er", "cellingr", "charalr", "cel_l", "cellJdr", "cell64c", "client_ro", "cel_right", "cell_rec", "cell9rt", "case_d", "cell64h", "charalrec", "cell9ro", "cell_sr", "save_rh", "cellJrt", "client_hr", "draw_nr", "cel_o", "cellalrec", "cel_rt", "cell_rb", "cel_sr", "cel_h", "char64c", "cell1r", "save_nr", "cell_h", "cellJc", "cell_rw", "draw_ro", "cell_ar", "save_ro", "char_r", "charge_nr", "cellalr", "cel_ro", "cell9hr", "client9rt", "draw_n", "draw_r", "char64r", "char_t", "cel_rw", "cellingdr", "cel_r", "cellJhr", "case_ro"], "cell_c": ["cell53r", "cellIPcur", "cellXrec", "cell67ci", "CellIPc", "cell_ec", " cell_con", "cellFc", "cellScenter", "cellFci", "Cell_cu", "cellWm", " cell_center", "ice_cur", "contact_cs", "cellDcon", "cellLr", "cell67r", "cell_t", "iceJcur", "cellJw", "cellSw", "cell_C", "save67c", "cell54c", "cell54t", "cell_b", "cell25center", "cel_fc", " cell_pc", "contact_chain", "save67r", "cellScur", "cell67nc", "cell_dc", "cell_cs", "cell67c", "cell67ec", "cellJcur", "iceJc", "cel_i", "cell_1", "cell_n", "cellacdc", "Cell_cs", "cellDc", "cellSc", "cel_cu", "cell67t", "cellIPcs", "cell25d", "cel_cin", "cellDm", "cellIPr", "pixel_cin", "cellIPchain", "cellJcenter", "cell_w", " cell_m", "cell_fc", "CellIPr", "cellIPc", "cell_d", "cell_ct", "cel_ct", "contact_c", "cell25r", "cell53cin", "cellXC", "cell54r", "ell_cur", "cellAcc", "iceJcenter", "save_r", "cell25ci", "ell_c", "cell53ci", "cellIPC", "cellacr", "cellAcenter", "cellAr", "cellIdc", "cellArec", "cell_cur", "ice_center", "cell54nc", "cellIPcin", "pixel_d", "cellacc", "Cell_r", "cell_nc", "save_t", "cell25b", "cel_c", " cell_C", "cellWcon", "cell67cu", " cell_w", "save67nc", "cell25i", "cel_C", "cellFfc", "cellAc", "cellXc", "cellWr", " cell_ci", "cell_cc", "cell67cin", "cell_m", "cell_rec", "cellWc", "cel_b", "contact_n", "cell_con", "cellDr", " cell_cc", "CellIPcu", "cellAi", "cel_1", "cellLc", "cell_ci", " cell_fc", "cell53c", "cellAC", "cellac1", "cell_cin", "cell_pc", "cel_ci", "cellIdr", "cellIPfc", "cell67fc", "ell_chain", "ice_w", "cell25fc", "cel_d", "cellJc", "Cell_c", " cell_cin", "pixel_r", "save_c", "cell_center", "ell_C", "iceJw", "CellIPcs", "cell67center", "ice_c", "cell67i", "pixel_c", "cellXcc", "cell_i", " cell_i", "cel_ec", "cellAci", "cellIPcu", "cellIdpc", " cell_rec", "cellIdw", "cell_cu", "cell25c", "save_nc", "cel_center", "cellFr", "save67t", "cellAfc", "cell_chain", "cel_r", "cel_dc", "cellLcin"], "func": ["layer", "worker", "fn", "apply", "cb", "pc", "nc", "unc", "sys", "code", "aug", "slice", "sec", " function", "bc", "comb", "dec", "module", "self", "conv", "exec", "Function", "proc", "val", "loop", "cf", "method", "con", "function", "df", "fc", "obj", "map", "cc", "super", "callback", "work", "f", "wrapper", "node", "loc", "fun"], "ret": ["Ret", "fn", "part", "all", "res", "result", "default", "array", "end", "output", "reply", "repl", "rt", "el", "group", "ref", "bf", "arg", "dict", "len", "val", "nt", "det", "reg", "alt", "detail", "rets", "fab", "RET", "str", "ext", "b", "d", "last", "gt", "rep", "true", "obj", "arr", "re", "data", "resp", "mat", "db", "union", "fun"], "coords": ["coordord", "Coords", "coordinates", "locinates", "cocoord", "coord", "coinates", "coordords", "Cocoord", "locords", "coordorder", " cocoord", "locord", " coorder", "coorder", "locorder", " coord", " coinates", "loccoord", "Coord", "Coinates"], "nb": ["bp", "fn", "qq", "cb", "kb", "ns", "bi", "nc", "np", "n", "ny", "dn", "NB", "bc", "nl", "net", "ob", "bf", "bg", "sn", "bm", "batch", "byn", "bd", "lab", "binary", "bs", "nr", "bb", "sb", "cn", "mb", "num", "nd", "ni", "eb", "adj", "nit", "iq", "nn", "ib", "wb", "b", "nu", "ab", "gb", "obj", "nm", "ne", "nob", "node", "number", "abb", "bin", "db", "bn"], "i": ["x", "ui", "ii", "v", "e", "bi", "ri", "mi", "l", "n", "xi", "yi", "li", "iu", "o", "gi", "si", "y", "I", "ci", "ini", "u", "ai", "b", "p", "pi", "di", "k", "f", "io"], "row": ["x", "flow", "id", "Row", "v", "bug", "ray", "key", "object", "index", "user", "array", "child", "slice", "q", "post", "ell", "feed", "col", "order", "group", "raw", "item", "range", "input", "column", "rows", "cube", "roll", "block", "line", "auto", "entry", "k", "data", "node"], "j": ["ji", "x", "v", "ii", "e", "l", "dj", "n", "q", "J", "jj", "li", "jc", "el", "o", "h", "jp", "kj", "y", "jl", "si", "left", "job", "adj", "b", "p", "jet", "d", "ch", "aj", "z", "ij", "ja", "k", "f", "uj"], "cell": ["x", "component", "v", "uc", "key", "index", "charge", "l", "slice", "cal", "ind", "q", "count", "lc", "sec", "model", "pixel", "cache", "ell", "un", "field", "label", "col", "o", "offset", "group", "cel", "co", "g", "ice", "num", "cells", "column", "ci", "ver", "call", "p", "z", "line", "entry", " Cell", "cc", "k", "form", "f", "node", "Cell", "inc"]}}
{"code": " \n  INPUT = 'A-small-attempt0.in'\n  OUTPUT = 'A-small-attempt0.out'\n  \n  \n  def solve(answer1, arr1, answer2, arr2):\n      ret = None\n  \n      for card in arr1[answer1 - 1]:\n          if card in arr2[answer2 - 1]:\n              if ret is not None:\n                  return 'Bad magician!'\n              else:\n                  ret = card\n      if ret is None:\n          return 'Volunteer cheated!'\n      return ret\n  \n  if __name__ == '__main__':\n      inp = open(INPUT)\n      out = open(OUTPUT, 'w')\n      \n      T = int(inp.readline())\n  \n      def read_answer_and_arr():\n          answer = int(inp.readline())\n          arr = []\n          for i in range(4):\n              arr.append( map(int, inp.readline().split()) )\n          return answer, arr\n  \n      for case in range(T):\n          answer1, arr1 = read_answer_and_arr()\n          answer2, arr2 = read_answer_and_arr()\n  \n          out.write('Case #%i: %s\n' % \\\n                          (case + 1, solve(answer1, arr1, answer2, arr2)))\n", "substitutes": {"INPUT": ["InFILE", "InLINE", "INLINE", "INFIG", " INVERT", "inFT", " INFIG", "INFT", "inUT", "inPUT", "ADPUT", "INFILE", "ADVERT", "InVERT", " INFILE", "InPUT", "INVERT", "InFIG", "ADLINE", "InFT", "ADFIG", "INUT", "inFILE", "InUT", " INFT", " INLINE", " INUT"], "OUTPUT": ["OUCLORT", "OUDPOL", "OUTPPUT", " OUTTPOTT", " OUTTHut", "OUSPUT", "OUSPPUT", "OUTPFILE", "OUSPOL", "OUTDPOL", "OUTPORT", "OUTTPOL", " OUTTPUT", "OUCLOTT", "OUTPut", "OUTHORT", "OUCLut", " OUTTHOTT", "OUDCut", "OUTAPUT", "OUDPFILE", "OUCLUT", "OUDPUT", "OUTAUT", " OUTTPORT", "OUTAOL", "OUTTPUT", "OUDCOTT", "OUDCUT", "OUDPPUT", "OUDCORT", "OUTPOL", "OUTHUT", "OUTHut", " OUTTHORT", "OUTDPFILE", "OUTDPPUT", "OUTTPFILE", "OUTHOTT", "OUTDPUT", "OUTAFILE", "OUTTPPUT", " OUTTHUT", "OUTPOTT", " OUTTPut", "OUSPFILE"], "answer1": ["response0", "arr0", "response1", "addressone", "response3", " answer0", "question2", "questionOne", "order1", "response2", "result1", "responseOne", "Answerone", "address1", "answer01", "arr3", "resultOne", "orderone", "order2", " answer01", "Answer1", "answerone", "answer0", "Answer01", "answer3", "answerOne", " answerone", "resultone", "address01", "question1", "result2", " answer3"], "arr1": ["str3", "strone", "arrone", "strfirst", "adr01", "answerx", "array2", "arrayx", " arr3", "errone", "adr2", "array1", "str1", "arrayfirst", "err2", " arrfirst", "array3", "arrayOne", "answer01", "arrOne", "adr1", "arr3", " arrone", "ray1", "arrx", "errOne", "rayx", "answerone", "arrfirst", "answer3", "answerOne", "arrayone", "err1", "array01", "adrone", "arr01", "ray3", "ray2"], "answer2": ["arr0", "equ02", "ell02", "arr5", "array8", "array0", " answerTwo", "response1", "response52", " answer52", " answer5", "arrayTwo", " answer0", "reply12", "reply5", "array2", "answer8", "answer02", "response2", "reply8", "array1", "reply2", "ell2", "equ2", "array52", "answer5", "arr8", " answer8", "answertwo", " answertwo", "answer12", "responseTwo", "ellTwo", "answer52", " answer12", "answerTwo", "answer0", "arraytwo", " answer02", "arr12", "arrtwo", "equTwo"], "arr2": ["arr0", "ar2", "err96", "array6", "ray96", "rrtwo", "rr0", "arch1", "array4", "ar1", "array2", "ar0", "artwo", " arr3", "array1", "arr6", "err2", "arr96", "err3", "array3", "arch6", "arr3", "answertwo", "rr1", "arr4", "arch2", "err4", "array96", "answer0", "ray3", "answer3", "arrtwo", "ray2", "ray4", "answer6", "answer4", "arch4", "rr2"], "ret": ["opt", "id", "err", "vert", "final", "reply", "et", "ref", "ut", "match", "let", "arc", "alt", "pat", "rets", " Ret", "RET", "rep", "feat", "hard", "resp", "oret", "crit", "cat", "pret", "mt", "best", "capt", "det", "rest", "str", "gt", "back", "re", "Ret", "orig", "token", "res", "result", "compl", "code", "dict", "mart", "python", " result", "reason", "art", "ver", "mel", "comment", "pet", "f", "data", "part", "valid", "default", "end", "fun", "bad", "red", "lit", "arg", " RET", "fit", "val", "msg", "reg", "ert", "__", "exit", "mat", "test"], "card": ["orig", "par", " cards", "parent", "valid", "bug", "crit", "missing", "cat", "draw", "parse", "result", "compl", "default", "aqu", "n", "man", "gen", "catch", "gu", "any", "du", "ck", "coord", "co", "std", "match", "div", "c", "empty", "mart", "list", "mult", "author", "coll", "arc", "reason", "cont", "circ", "cards", "cmp", "custom", "ard", "null", "Card", "cue", "failed", "C", "check", "error", "ult", "comment", "blank", "vard", "cart", "char", "word"], "inp": ["innfp", "INp", "innp", "INc", "INP", " inf", " inpp", " inP", "inpt", "insp", "incp", "incsp", "INh", "elb", "innpp", "minpt", "innps", " inb", "inps", "insc", "elsp", " inps", "inf", "incf", "infp", "elp", "zenp", "incc", "incb", " infp", "zenpp", "minp", "inh", "insP", "inP", " inh", "zenps", "elf", "minf", "insh", " insp", "inpp", " inc", "inb", "incpt", " inpt", "zenfp", "minc", "inc"], "out": ["orig", "prefix", "opt", "part", "parent", "v", "OUT", "err", "outs", "np", "log", "trial", "output", "up", "w", "copy", "o", "at", "window", "ex", "Out", "name", "file", "img", "again", "str", "ext", "extra", "call", "lib", "new", "obj", "error", "doc", "int", "wx", "io", "temp", "exp"], "T": ["N", "Y", "TN", "t", "P", "Length", "E", "H", "W", "X", "type", "R", "TX", "NT", "Q", "I", "B", "D", "F", "WT", "sequence", "O", "S", "TT", "C", "length", "Case", "number", "M", "A", "L", "V"], "answer": ["err", "index", "result", "array", "score", "grade", "address", "time", "ace", "rue", "reply", "r", "ell", "order", "offset", " answers", "round", "abc", "value", "after", "Answer", "audio", "en", "au", "duration", "eni", "evidence", "question", "choice", "ee", "response", "length", "air", "true", "int", "a", "une", "next", "now", "number", "test"], "arr": ["adr", "par", "fr", "rr", "err", "res", "yr", "ras", "br", "array", "result", "train", "gr", "cache", "r", "ell", "aaa", "dat", "abc", "arg", "xml", "list", "aa", "ar", "attr", "enc", "adv", "arc", "au", "Ar", "Array", "ARR", "att", "app", "str", "acc", "tr", "ext", "aj", "air", "ab", "rep", "int", "data", "test"], "i": ["x", "id", "j", "e", "ip", "n", "ind", "q", "li", "r", "it", "ice", "c", "ti", "ie", "gi", "I", "num", "ci", "iq", "ib", "ic", "ai", "d", "a", "k", "char"], "case": ["instance", "x", "nce", "result", "code", "grade", "end", "character", "address", "time", "trial", "ace", "ce", "catch", "rice", "course", "rand", "chance", "CE", "order", "ASE", "me", "match", "ice", "section", "name", "ACE", "position", "num", "race", "app", "CI", "do", "choice", "length", " CASE", "Case", "ase", "cases", "example", "test"]}}
{"code": " \n  \n  \n  def check(R, C, M, _board):\n      board = [line[:] for line in _board]\n  \n      pos = [(0, 0)]\n      while pos:\n          row, col = pos.pop()\n          neighbor = []\n          for r in (-1, 0, 1):\n              r += row\n              for c in (-1, 0, 1):\n                  c += col\n                  if r >= 0 and r < R and c >= 0 and c < C:\n                      neighbor.append((r, c))\n          count = len([1 for r, c in neighbor if board[r][c] == '*'])\n          board[row][col] = str(count)\n          if count == 0:\n              for r, c in neighbor:\n                  if board[r][c] == '.':\n                      pos.append((r, c))\n  \n      flat = ''.join(''.join(line) for line in board)\n      result = not flat.count('.')\n      if not result and False: # for DEBUG\n          print '-' * 20\n          print R, C, M\n          print '\n'.join(''.join(line) for line in _board)\n          print '-' * 20\n      assert flat.count('*') == M\n      return result\n  \n  \n  def solve(R, C, M):\n      board = [['.'] * C for row in range(R)]\n      board[0][0] = 'c'\n      row = R\n      col = C\n      mine = M\n  \n      while mine:\n          if 0 < row <= col and mine >= row:\n              for r in range(row):\n                  board[row - r - 1][col - 1] = '*'\n              mine -= row\n              col -= 1\n          elif 0 < col <= row and mine >= col:\n              for c in range(col):\n                  board[row - 1][col - c - 1] = '*'\n              mine -= col\n              row -= 1\n          else:\n              break\n  \n      if mine:\n          while mine and row > 2:\n              for r in range(min(mine, row - 2)):\n                  board[row - r - 1][col - 1] = '*'\n                  mine -= 1\n              col -= 1\n          while mine and col > 2:\n              for c in range(min(mine, col - 2)):\n                  board[row - 1][col - c - 1] = '*'\n                  mine -= 1\n              row -= 1\n  \n      if mine:\n          if mine:\n              board[1][1] = '*'\n              mine -= 1\n          if mine:\n              board[1][0] = '*'\n              mine -= 1\n          if mine:\n              board[0][1] = '*'\n              mine -= 1\n  \n      assert mine == 0\n      return '\n'.join(''.join(line) for line in board) if check(R, C, M, board) else 'Impossible'\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          R, C, M = map(int, IN.readline().split())\n          OUT.write('Case #%d:\n%s\n' % (index + 1, solve(R, C, M)))\n  \n  \n  def makesample(maxSize=5, T=230):\n      print T\n      for index in range(T):\n          R = random.randint(1, maxSize)\n          C = random.randint(1, maxSize)\n          print R, C, random.randint(0, R * C - 1)\n  \n  \n  def makesample():\n      pattern = []\n      for R in range(1, 5+1):\n          for C in range(1, 5+1):\n              for M in range(R * C):\n                  pattern.append((R, C, M))\n      print len(pattern)\n      for R, C, M in pattern:\n          print R, C, M\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n", "substitutes": {"R": ["Rh", "A", "N", "Y", "Row", "TR", "GR", "Rs", "Range", "P", "MR", "CR", "RH", "Re", "E", "G", "H", "SR", "RM", "W", "RO", "RF", "K", "X", "Right", "Q", "DR", "RS", "BR", "Br", "I", "B", "RP", "AR", "D", "F", "RC", "RG", "IR", "O", "S", "RR", "V", "NR", "Line", "L", "U", "RA"], "C": ["N", "NC", "Y", "SC", "CNN", "Cs", "P", "VC", "DC", "CM", "CR", "U", "E", "G", "CE", "H", "W", "YC", "K", "X", "Sc", "Co", "CB", "CA", "CC", "CW", "I", "B", "Cu", "CI", "D", "Cr", "F", "GC", "CP", "O", "CT", "S", "CL", "EC", "MC", "CU", "CN", "A", "L", "V"], "M": ["N", "Y", "MD", "OK", "FM", "P", "MS", "Man", "MO", "DC", "CM", "Ms", "VM", "MT", "E", "H", "G", "MX", "MI", "RM", "W", "DM", "X", "MU", "NM", "Mo", "Q", "CC", "I", "B", "MF", "D", "F", "NO", "LM", "m", "O", "S", "MA", "MN", "ME", "Z", "NUM", "MC", "V", "A", "L", "U"], "_board": [" theboarding", " theboards", "ingboard", "ingboarding", " _control", " _Board", "ingboards", " theboard", "_boards", "_boarding", "_control", "_Board", "_block", "ingclock", "_line", " theclock", "_clock"], "board": ["game", "engine", "model", "stream", "feed", "coll", "head", "position", "plan", "boarding", "length", "ide", "cell", "case", "video", "bug", "deck", "object", "card", "core", "store", "que", "stroke", "list", "reader", "loop", "buffer", "clean", "custom", "pool", "panel", "p", "block", "check", "back", "form", "rank", "point", "cart", "word", "flow", "lane", "che", "code", "control", "table", "body", "ward", "bar", "style", "view", "lay", "frame", "queue", "layout", "foot", "comment", "room", "data", "hub", "database", "menu", "ack", "draw", "home", "bo", "post", "channel", "flo", "Board", "sync", "lock", "sequence", "base", "hole", "boards", "player", "node", "bank", "design"], "line": ["inline", "log", "model", "nee", "ge", "len", "cle", "coll", "position", "unit", "source", "ded", "call", "plan", "cell", "case", "LINE", "layer", "object", "ze", "l", "change", "n", "lc", "store", "li", "du", "po", "que", "lo", "list", "ke", "p", "block", "lines", "point", "se", "word", "code", "ile", "lane", "day", "el", "group", "pe", "ync", "style", "lf", "frame", "do", "d", "ne", "comment", "f", "lined", "e", "liner", "string", "ner", "side", "o", "co", "sync", "file", "lock", "base", "entry", "lin", "link", "Line", "live", "page"], "pos": ["ps", "part", "all", "bug", "e", "neg", "ack", "res", "pl", "object", "l", " position", "slice", "n", "ind", "cond", "up", "cache", "post", "os", "feed", "po", "Pos", "o", "offset", "body", "at", "POS", "list", "len", "Position", "loop", "val", "position", "unit", " positions", "out", "pose", "source", "p", "plan", "pid", "block", "diff", "lines", "iter", "plus", "none", "loc", "point", "pro", "data", "port"], "row": ["v", "low", "area", "run", "feed", "old", "week", "coll", "head", "rc", "uu", "range", "m", "roll", "length", "auto", "rot", "k", "cell", "hour", "pull", "bug", "our", "chrom", "n", "xy", "rock", "ram", "ha", "how", "container", "ou", "round", "cr", "value", "micro", "keep", "sc", "name", "roc", "num", "rows", "ry", "rib", "ra", "p", "block", "ride", "arrow", "full", "scale", "re", "_", "rank", "flow", "rr", "uc", "user", "ru", "che", "q", "day", "month", "order", "group", "ward", "off", "hop", "raw", "oct", "mod", "y", "max", "view", "u", "rs", "tr", "ver", "each", "d", "box", "um", "cur", "oy", "f", "port", "record", "x", "Row", "e", "key", "ack", "ko", "ro", "right", "post", "w", "rh", "o", "co", "h", "arch", "ow", "reg", "column", "ore", "year", "entry", "rid", "rect", "node", "loc", "pr", "page"], "col": ["ail", "err", "sec", "character", "area", "cond", "ca", "term", "old", "ref", "collection", "coll", "rc", "win", "cm", "roll", "length", "rot", "cell", "k", "bug", "cat", "l", "n", "xy", "cal", "lc", "core", "container", "round", "cr", "keep", "cycle", "zip", "num", "left", "large", "il", "con", "p", "block", "COL", "fc", "full", "ct", "cor", "ac", "th", "all", "tab", "dc", "q", "day", "table", "pixel", "month", "ell", "el", "Col", "section", "rel", "fl", "y", "max", "cf", "ci", "view", "yl", "ch", "box", "mot", "foot", "oy", "f", "port", "x", "min", "key", "kil", "pl", "patch", "child", "ro", "ill", "w", "ec", "co", "path", "flo", "ract", "i", "val", "file", "reg", "column", "lib", "year", "entry", "int", "rem", "cy", "cl", "cp", "loc", "io", "page"], "neighbor": ["nwwaybour", "anneighbour", "neighthbors", "annechebors", "newayner", "geilbors", "neivbor", "neumbor", "nwighner", "neumbour", "nexbors", "annechebor", "neilbors", "neearbor", "anneighbor", " neearbour", "necheor", "geilbor", "geighbour", "nwighbor", "geilbour", "geighroot", "neilbour", "nwwayner", "neighthbour", "neilroot", "neivbour", "anneighor", "neboror", "neborbors", "nexbour", "anneighbors", "neighthroot", "nwwaybor", " neighbors", "neumner", "neighner", "neearbors", "neighroot", "newaybour", "nechebors", "nexbor", "newaybors", "nwighbors", "neearbour", "geighbors", "neumbors", "neborbor", "neborbour", "geighbor", " neearbor", "newaybor", "annecheor", "neighor", "annechebour", "geilroot", " neearbors", "neighthbor", "neighbour", "neivbors", "neivner", "neilbor", "nwighbour", " neighbour", "neighbors", "nexroot", "nechebour", "nechebor", "nwwaybors"], "r": ["x", "j", "mr", "v", "fr", "rr", "err", "e", "yr", "rf", "ri", "br", "ru", "l", "n", "ro", "t", "rd", "q", "right", "w", "dr", "rt", "rh", "un", "o", "lr", "rec", "cr", "g", "s", "ir", "h", "ar", "nr", "rc", "sr", "range", "ur", "hr", "m", "rb", "u", "rs", "tr", "cm", "b", "p", "d", "z", "rg", "cur", "re", "k", "f", "er", "rn", "pr"], "c": ["v", "nc", "t", "ca", "ce", "cu", "coll", "arc", "rc", "cn", "xc", "m", "cm", "chain", "k", "cell", "l", "n", "lc", "core", "cr", "sc", "ach", "roc", "con", "p", "fc", "ct", "a", "orc", "cor", "ac", "uc", "cs", "dc", "q", "rec", "s", "ar", "enc", "y", "cf", "ci", "u", "mc", "vc", "b", "ch", "d", "cc", "f", "x", "e", "pc", "unc", "oc", "w", "ec", "co", "g", "h", "i", "cd", "z", "cy", "cl", "cp", "loc"], "count": ["part", "id", "all", "err", "code", "carry", "n", "low", "area", "core", "cond", "html", "catch", "handle", "cache", "comp", "const", "where", "offset", "old", "group", "frac", "match", "conn", "len", "type", "list", "coll", "cd", "counter", "sum", "depth", "name", "agg", "limit", "total", "size", "ac", "max", "find", "val", "start", "num", "lead", "cmp", "close", "base", "found", "call", "last", "length", "check", "every", "cc", "now", "age", "Count", "case", "content", "number", "weight", "loc"], "flat": ["layer", "bug", "fast", "inline", "plane", "cat", "planes", "atom", "vert", "np", "fat", "multiple", "sat", "nat", "atten", "format", "feed", "fin", "dat", "at", "atted", "kat", "frac", "normal", "dim", "fit", "float", "fl", "unit", "zip", "lat", "static", "pat", "clean", "live", "fill", "single", "fab", "base", " flattened", "ant", "found", "layout", "plan", "buff", "feat", "full", "plain", "bits", "iter", "f", "dot", "op", "mat"], "result": ["x", "all", "root", "res", "Result", "compl", "score", "array", "changes", "ner", "success", "n", "final", "format", "status", "width", "group", "match", "math", "ge", "list", "section", "mate", "counter", "unit", "ret", "num", "source", "acc", "function", "the", "block", "results", "df", "d", "response", "new", "diff", "length", "particip", "error", "rate", "int", "pack", "comment", "now", "re", "true", "case", "data", "weight", "number", "work", "f", "direction", "page", "inc", "test"], "mine": ["aim", "rise", "omin", "area", "iny", "ize", "ruby", "gone", "rub", "match", "die", "ge", "mark", "wine", "ni", "ample", "m", "ute", "mix", "umber", "INE", "ide", "grave", "rage", "dom", "iron", " Mine", "rule", "charge", "ram", "core", "have", "drive", "mean", "ign", "que", "ise", "hide", "gin", "frac", "value", "see", "elect", "fine", "cale", "use", "mie", "num", "gate", "duty", "rib", "inate", "domain", "ride", "are", "scale", "brown", "misc", "rank", "ose", "foo", "route", "dust", "itime", "late", "ril", "rain", "rag", "ine", "select", "present", "na", "fall", "mn", "init", "mes", "update", "mate", "many", "race", "mage", "mile", "fill", "pose", "ini", "write", "do", "pm", "tom", "um", "nil", "ne", "gender", "min", "draw", "grade", "play", "roy", "tile", "nat", "wm", "width", "me", "gage", "flo", "fe", "date", "make", "dan", "rug", "ore", "when", "Mine", "lin", "dm", "main", "node", "design"]}}
{"code": " \n  \n  \n  def solve(arrange):\n      board, row = arrange[0]\n      before = board[row - 1]\n      board, row = arrange[1]\n      after = board[row - 1]\n      dup = set(before) & set(after)\n      if len(dup) == 1:\n          return dup.pop()\n      elif len(dup) >= 2:\n          return 'Bad magician!'\n      else:\n          return 'Volunteer cheated!'\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          arrange = []\n          for n in range(2):\n              row = int(IN.readline())\n              board = []\n              for line in range(4):\n                  board.append(map(int, IN.readline().split()))\n              arrange.append((board, row))\n          OUT.write('Case #%d: %s\n' % (index + 1, solve(arrange)))\n  \n  \n  def makesample(T=100):\n      print T\n      for index in range(T):\n          for n in range(2):\n              print random.randint(1, 4)\n              board = list(range(1, 16+1))\n              random.shuffle(board)\n              while board:\n                  print ' '.join(map(str, board[:4]))\n                  board = board[4:]\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n", "substitutes": {"arrange": [" arranch", "dranged", "arrayride", "arranch", "arrayanch", "arrone", "strrange", "dranne", "errrage", "Arase", "arrase", "appange", "arranne", "irrange", "apprage", "arrayanges", "arrage", "arrayanged", "irone", "arranges", "errone", "drrange", "arase", "irrage", "arrace", "aranne", "earrange", "earride", "strange", "strrage", "strace", "earange", "aranged", "arrrange", "drange", " arrrange", " arranges", "arange", "arranged", "earanne", "apprange", "arride", "irange", "arrayrange", "Arange", "arrayange", " arrice", "errrange", "arrrage", "aranges", "Arice", "arrice", "aranch", "arice", "arace", " arrase", "errange", "arrride", "arrayanne", "appace", "arone", "Arrange"], "board": ["game", "id", "poll", "model", "ck", "feed", "col", "coll", "head", "range", "roll", "boarding", "length", "ide", "case", "bug", "deck", "object", "down", "rule", "array", "slice", "card", "core", "stroke", "one", "list", "loop", "buffer", "out", "clean", "message", "rows", "function", "block", "ride", "back", "form", "cart", "word", "flow", "uc", "bow", "lane", "code", "che", " clipboard", "control", "table", "up", "where", "body", "group", "ward", "ban", "bar", " loop", "raw", "wheel", "view", "frame", "b", "layout", "box", "pos", "comment", "room", "data", " block", "menu", "ack", "draw", "ro", "home", "bo", "bc", "post", "channel", "o", "flo", "Board", "batch", "sequence", "hole", "boards", "node", "off", "design", "test"], "row": ["step", "x", "flow", "id", "bug", "Row", "key", "user", "ro", "end", "slice", "run", "right", "server", "month", "pri", "post", "r", "feed", "col", "order", "where", "offset", "group", "round", "ward", "one", "value", "batch", "head", "rc", "sync", "ow", "num", "range", "column", "view", "rows", "ry", "tr", "roll", "block", "pos", "length", "year", "error", "rot", "cell", "form", "rank", "number", "off", "port", "page"], "before": ["above", "slice", "table", "right", "around", "self", "info", "head", "below", "size", "start", "left", "range", "view", "prev", "between", "Before", "p", "length", "false", "back", "now", "front", "data", "none", "here", "off", "pre"], "after": ["step", "all", "version", "until", "above", "string", "end", "model", "run", "right", "post", "around", "on", "round", "module", "head", "size", "future", "left", "range", "out", "later", "between", "p", "d", "when", "last", "length", "option", "next", "data", "After", "off", "pre"], "dup": [" dups", "DuP", "Dup", "dupr", "diep", "udP", "duping", " depr", " dupr", " deping", "dc", "dpe", "dupe", "dP", " duping", "Dups", " dep", "Duping", "udc", "dop", " deps", "udps", "diepe", "udpe", "dps", "dups", "duc", "dp", "tripe", "trips", " duP", "udp", "trip", "Dupr", "duP", "doc", "tric", "udping", "dops", "dope", "diec", "dieP"], "IN": ["MIN", "EN", "OU", "AC", "UL", "UID", "AN", "GO", "Input", "INS", "Reader", "DL", "INT", "DATA", "ins", "LIN", "Out", "PIN", "OSS", "out", "inner", "STR", "GEN", "IND", "Client", "NG", "IL", "CON", "CL", "MN", "String", "FILE", "FS", "URL", "MC", "In", "READ", "WIN", "FIN", "IM", "HTTP", "RAW", "IO", "LINE", "URI"], "OUT": ["GER", "OU", "TEXT", "UL", "END", "TF", "DC", "INS", "Output", "APP", "BL", "OS", "INT", "PUT", "DATA", "TER", "Out", "EXT", "outer", "Q", "TABLE", "OSS", "out", "STR", "DIR", "STDOUT", "IL", "FILE", "FS", "In", "READ", "AL", "NAME", "RAW", "IO", "LINE", "UN", "EX", "NG"], "T": ["N", "Y", "Row", "TN", "t", "P", "Index", "TH", "time", "TF", "TS", "E", "H", "G", "W", "K", "X", "Time", "type", "R", "TC", "TW", "total", "size", "Q", "SIZE", "I", "B", "D", "F", "sequence", "O", "S", "TT", "C", "length", "V", "_", "number", "M", "A", "L", "U"], "index": ["instance", "x", "prefix", "id", "insert", "t", "Index", "slice", "end", "ind", "table", "site", "order", "offset", "match", "type", "i", "section", "word", "pattern", "outer", "head", "toc", "name", "loop", "size", "position", "tc", "unit", "num", "range", "input", "ci", "ini", "rows", "null", "block", "pos", "length", "int", "axis", "foot", "iter", "case", "number", "point", "loc", "page", "test"], "n": ["N", "ns", "nc", "l", "ner", "dn", "na", "nb", "r", "un", "o", "c", "len", "i", "en", "nt", "nor", "num", "nd", "an", "m", "u", "nn", "ln", "b", "non", "p", "nin", "z", "lin", "nan", "nw", "f", "rn"], "line": ["x", "inline", "code", "l", "ner", "li", "un", "col", "len", "name", "size", "sync", "num", "range", "out", "nd", "non", "block", "length", "lines", "obj", "lin", "Line", "blank", "number"]}}
{"code": " \n  \n  def neighbours(grid, (i, j), n, m):\n      for a in range(max(i-1, 0), min(i+2, n)):\n          for b in range(max(j-1, 0), min(j+2, m)):\n              if (a != i or b != j):\n                  yield (a, b)\n  \n  def isGridCorrect(grid):\n      g = list(grid)\n      n = len(g)\n      m = len(g[0])\n      queue = [(0, 0)]\n  \n      while queue:\n          v = queue.pop(0)\n          g[v[0]][v[1]] = 'r'\n          bomb = False\n          for (i, j) in neighbours(g, v, n, m):\n              if g[i][j] == '*':\n                  bomb = True\n          if not bomb:\n              for (i, j) in neighbours(g, v, n, m):\n                  if g[i][j] != 'r':\n                      queue.append((i, j))\n  \n      for i in range(n):\n          for j in range(m):\n              if g[i][j] != 'r' and g[i][j] != '*':\n                  return 'WRONG'\n  \n      return 'Right'\n  \n  def createGrid(R, C, s):\n      field = []\n      for i in range(R):\n          field.append([s] * C)\n      field[0][0] = 'c'\n      return field\n  \n  def draw(grid):\n      s = \"\"\n      for row in grid:\n          s += \"\n\" + ''.join(row)\n      return s\n  \n  def reduceRows(grid, k, l, M):\n      if k <= 2:\n          return (grid, k, l, M)\n      \n  \n      for j in range(l):\n          grid[k-1][j] = '*'\n      k -= 1\n      M -= l\n      return (grid, k, l, M)\n  \n  def reduceCols(grid, k, l, M):\n      if l <= 2:\n          return (grid, k, l, M)\n      \n  \n      for i in range(k):\n          grid[i][l-1] = '*'\n      l -= 1\n      M -= k\n      return (grid, k, l, M)\n  \n  def solve(R, C, M):\n      mp = M\n      if M == 0:\n          f = createGrid(R, C, '.')\n          return draw(f)\n      elif M == R*C - 1:\n          f = createGrid(R, C, '*')\n          return draw(f)\n      elif (R == 2 or C == 2) and (M % 2 == 1 or M == R*C - 2):\n          return \"\n\" + 'Impossible' #+ '1: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\n      elif R > 2 and C > 2 and (M == R*C - 2 or M == R*C - 3 or M == R*C - 5 or M == R*C - 7):\n          return \"\n\" + 'Impossible' #+ '2: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\n      else:\n          grid = createGrid(R, C, '.')\n  \n  \n          k = R\n          l = C\n  \n          while (M >= l and k > 2) or (M >= k and l > 2):\n              if l >= k:\n                  (grid, k, l, M) = reduceCols(grid, k, l, M)\n              elif k > l:\n                  (grid, k, l, M) = reduceRows(grid, k, l, M)\n  \n  \n          if M == 0:\n              return draw(grid)\n          if M < l - 1 and k > 2:\n              for j in range(l - M, l):\n                  grid[k-1][j] = '*'\n          elif M < k - 1 and l > 2:\n              for i in range(k - M, k):\n                  grid[i][l-1] = '*'\n          elif l > 3 and k > 3:\n              for i in range(2, k):\n                  grid[i][l-1] = '*'\n              M -= k - 2\n              for j in range(l - M - 1, l - 1):\n                  grid[k-1][j] = '*'\n          else:\n              return \"\n\" + 'Impossible' #+ '3: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\n  \n          return draw(grid)\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          [R, C, M] = [int(x) for x in sys.stdin.readline().rstrip().split()]\n  \n          result = solve(R, C, M)\n          print (\"Case #%s:%s\" % (i+1, result))\n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"grid": ["remote", "game", "id", "cli", "model", "gu", "spec", "div", "storage", "ge", "window", "magic", "unit", "gap", "chain", "cell", "age", "house", "db", "Grid", "dom", "layer", "bug", "gui", "rule", "array", "slice", "ga", "card", "site", "edge", "xml", "connection", "list", "zip", "panel", "cube", "block", "flat", "csv", "form", "contact", "cart", "ht", "multi", "query", "parse", "code", "q", "table", "server", "group", "module", "update", "filter", "mod", "input", "uri", "u", "frame", "layout", "d", "line", "client", "graph", "data", "record", "draw", "grade", "play", "cache", "json", "c", "dim", "gm", "sync", "file", "lock", "gae", "column", "node", "live"], "n": ["e", "ns", "nc", "np", "t", "q", "r", "w", "un", "o", "on", "mn", "sn", "c", "len", "h", "en", "nt", "size", "y", "num", "an", "ni", "u", "ln", "p", "d", "z", "nm", "ne"], "m": ["ym", "min", "e", "im", "mi", "r", "mm", "w", "o", "mn", "c", "ms", "h", "dim", "en", "om", "size", "y", "an", "fm", "cm", "u", "mc", "p", "sm", "d", "pm", "z", "tm", "nm"], "a": ["A", "am", "e", "sa", "ap", "asa", "ga", "area", "ca", "fa", "na", "af", "ak", "ae", "c", "aa", "ar", "alpha", "au", "ad", "y", "an", "u", "pa", "ai", "p", "da", "d", "aj", "ab", "ax", "ma", "ac", "ia", "ba", "va"], "b": ["bp", "am", "e", "bi", "ga", "nb", "r", "w", "ob", "o", "body", "aaa", "beta", "bf", "c", "bd", "h", "aa", "bs", "bb", "sb", "mb", "y", "B", "eb", "ib", "u", "lb", "rb", "bis", "wb", "p", "fb", "d", "z", "ab", "abb", "ba", "be"], "g": ["gg", "game", "e", "play", "ga", "q", "gr", "r", "w", "gu", "erg", "G", "group", "cfg", "bg", "c", "ge", "h", "gi", "gm", "msg", "gh", "y", "item", "reg", "gae", "gs", "u", "gp", "go", "og", "p", "d", "vg", "sg", "ig", "gb", "rg", "graph", "gas"], "queue": ["worker", "layer", "parent", "menu", "all", "gui", "stage", "cli", "array", "q", "server", "cache", "complete", "event", "status", "order", "que", "group", "match", "ping", "module", "list", "update", "progress", "master", "seq", "Q", "file", "ue", "buffer", "config", "wait", "out", "manager", "enabled", "message", "load", "live", "sequence", "job", "delay", "pool", "p", "block", "line", "stack", "force", "chain", "graph", "main", "buf", "Queue", "foo"], "v": ["e", "vs", "vv", "t", "vd", "q", "dev", "qv", "r", "w", "li", "ve", "o", "vin", "c", "h", "vm", "nv", "val", "vi", "y", "lv", "vp", "uv", "u", "ver", "sv", "p", "d", "vg", "av", "z", "ev", "iv", "ov", "video", "va", "V"], "bomb": ["controller", "prefix", "bug", "bi", "flash", "timeout", "atom", "charge", " bombs", "osion", "bo", "bang", "bad", "moon", "rocket", "attack", "Bomb", "hack", "aaa", "ball", "body", "riot", "zone", "aa", "pattern", "blog", "pill", "storm", "rupt", "unit", "az", "mass", "fail", "bird", "critical", "null", "clone", "leaf", "enemy", "less", "broken", "ash", "error", "bell", "secret", "blank", " Bomb", "beat", "foo"], "i": ["ji", "id", "ui", "ii", "e", "ri", "bi", "ik", "im", "ip", "mi", "ei", "xi", "yi", "li", "iu", "ki", "it", "o", "lo", "c", "h", "gi", "qi", "ie", "ti", "info", "y", "si", "vi", "I", "eni", "ori", "ni", "ci", "il", "ini", "u", "ai", "p", "d", "z", "ix", "pi", "int", "ij", "iv", "di", "zi", "api", "io", "ia"], "j": ["ji", "e", "ii", "fr", "im", "je", "br", "q", "J", "jj", "xi", "r", "li", "jc", "el", "o", "js", "c", "ie", "sh", "qi", "h", "name", "oj", "jp", "kj", "y", "jl", "ci", "adj", "jo", "u", "p", "jet", "d", "aj", "z", "ion", "false", "ch", "note", "ne", "ja", "ij", "obj", "ol", "kl", "em", "uj", "L"], "R": ["Rh", "A", "all", "id", "T", "Rs", "P", "add", "end", "J", "r", "url", "format", "E", "G", "H", "SR", "W", "K", "X", "c", "Right", "join", "Q", "RS", "I", "B", "D", "F", "str", "S", "RR", "V", "Res", "_", " r", "L", "U"], "C": ["T", "Cs", "P", "DC", "CR", "CF", "E", "CE", "G", "W", " c", "K", "X", "c", "CC", "Q", "CS", "I", "B", "D", "F", "Ch", "CT", "S", "Z", "d", "V", "A", "L", "U"], "s": ["ps", "comments", "e", "ns", "us", "summary", "ds", "cs", "string", "t", "slice", "q", "su", "fields", "r", "w", "spec", "sym", "G", "secondary", "settings", "o", "sets", "ing", "c", "series", "sc", "h", "conf", "sb", "ws", "y", "si", "gs", "strings", "ss", "sequence", "rows", "u", "S", "sv", "p", "fs", "details", "d", "sg", "z", "states", "ed", "lines", "es", "csv", "_", "sf", "sq"], "field": ["layer", "id", "key", "object", "rule", "string", "patch", "array", "slice", "card", "end", "model", "fields", "w", "format", "FIELD", "group", "match", "div", "c", "type", "element", "sum", "file", "Field", "input", "column", "load", "source", "str", "function", "p", "d", "box", "block", "z", "line", "force", "condition", "cell", "form", "_", "data", "record"], "row": ["instance", "Row", "key", "object", "draw", "string", "query", "array", "slice", "card", "q", "model", "server", "r", "feed", "col", "group", "round", "sc", "raw", "item", "range", "input", "column", "rows", "cube", "page", "block", "line", "entry", "cell", "form", "data", "record"], "k": ["id", "e", "key", "ik", "ky", "ko", "t", "q", "ok", "r", "w", "ki", "ak", "ck", "kk", "o", "K", "c", "h", "sh", "kn", "ke", "y", "dk", "sk", "u", "p", "d", "ch", "z", "kw", "mk", "kl", "work", "ka", "ks", "ek"], "l": ["ail", "e", "dl", "pl", "t", "lc", "q", "lu", "r", "li", "ell", "nl", "el", "o", "ll", "c", "h", "y", "ul", "ml", "lp", "yl", "il", "u", "ln", "p", "d", "z", "ls", "ol", "kl", "lin", "ly", "al", "sl", "L"], "M": ["Y", "MD", "T", "FM", "P", "MS", "MR", "J", "CM", "MB", "mm", "E", "SM", "H", "G", "W", "DM", "AM", "K", "X", "NM", "Q", "TM", "ML", "I", "B", "OM", "MF", "D", "F", "GM", "LM", "JM", "MM", "EM", "cm", "O", "S", "Mi", "Z", "MN", "MC", "V", "IM", "A", "L", "U"]}}
{"code": " \n  \n  def solve(row1, row2):\n      common = [x for x in row1 if x in row2]\n      num_common = len(common)\n      if num_common == 0:\n          return 'Volunteer cheated!'\n      elif num_common > 1:\n          return 'Bad magician!'\n      else:\n          return common[0]\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          row_index1 = int(sys.stdin.readline())\n          row1 = list()\n          for j in range(4):\n              if row_index1 == j + 1:\n                  row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          row_index2 = int(sys.stdin.readline())\n          row2 = list()\n          for j in range(4):\n              if row_index2 == j + 1:\n                  row2 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          result = solve(row1, row2)\n          print (\"Case #%s: %s\" % (i+1, result))\n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"row1": ["column31", " rowone", "modone", "col1", "row31", "col3", "columnone", "rowsone", "rowOne", " row31", "feedOne", "Row2", "mod1", "rows1", "feed2", " rowOne", "arrow1", "rowsOne", "RowOne", "rowone", "colOne", "Row1", "row3", "feed1", "ward2", "ward1", "rows3", "column1", "arrow31", " row3", "col2", "mod2", "arrowone", "ward3", "rows2"], "row2": ["elementsecond", "arrow2", "owtwo", "rowcel", "element2", "row4", "entryTwo", "Row02", "arrowtwo", "elementTwo", " rowtwo", "element4", "Row4", "rowsTwo", "rowTwo", " rowcel", "entry2", "rowsecond", " rowTwo", "Row2", "owTwo", "rows4", "ow2", "rows1", "RowTwo", "rows02", "owcel", " rowsecond", "arrow1", "arrowcel", "page2", " row4", "rowtwo", "Row1", "entrytwo", "ow1", " row02", "pagesecond", "row02", "pageTwo", "page4", "entry1", "rows2"], "common": ["Common", "valid", "fast", "http", "summary", "generic", "specific", "shared", "local", "core", "lc", "www", "compatible", "complex", " Common", "known", "basic", "standard", "record", "public", "match", "normal", "connection", "conf", "desc", "num", "similar", "general", "custom", "con", "unique", "rows", "cm", "norm", "diff", "new", "small", "client", "cloud", "obj", "a", "dist", "work", "data", "central", "loc", "media", "union", "fun"], "x": ["opt", "id", "v", "t", "ck", "ux", "xc", "cent", "m", "ph", "ax", "xs", "sex", "k", "rx", "l", "n", "xy", "xxx", "oint", "X", "ex", "xp", "num", "out", "xt", "ext", "p", "xf", "ix", "check", "plus", "ctx", "com", "word", "index", "xb", "px", "code", "q", "www", "xi", "na", "pe", "sw", "max", "y", "ci", "plex", "dx", "b", "d", "cross", "f", "xx", "e", "draw", "tx", "yp", "fx", "w", "co", "c", "h", "xes", "ww", "exc", "row", "qu", "z", "int", "wx", "work", "lex", "test"], "num_common": [" num_found", "num__common", "nb_specific", "nb_common", "num_central", "num2specific", " num_general", "num_found", " num_compatible", "nb_total", "num2common", "num2total", "num_general", " num_central", "num_compatible", "num_total", "num_specific", "num_Common", "num2connection", "num__found", " num_Common", "nb_connection", "num_connection", "num__Common"], "N": ["Y", "ns", " n", "NS", "P", "n", "NB", "J", "NN", "Num", "NI", "K", "X", "NM", "R", "NT", "Q", "size", "Ns", "I", "B", "F", "ni", "O", "Ni", "S", "Z", "C", "Ne", "NR", "number", "M", "network", "L", "V"], "i": ["ji", "id", "ii", "e", "bi", "ri", "index", "ip", "l", "n", "slice", "phi", "ind", "J", "xi", "jit", "yi", "li", "iu", "on", "ti", "ie", "gi", "chi", "jp", "y", "si", "I", "uri", "ci", "jo", "ini", "p", "d", "z", "ix", "pi", "int", "a", "ij", "mini", "di", "zi", "f", "ui"], "row_index1": ["row_indexon", "row_id0", "row_Index4", "row_length1", "row_num3", "row_num1", "row_length3", "row_width4", "row_width1", "row_id1", "row_length4", "row_Index0", "row_index4", "row_id3", "row_widthon", "row_num4", "row_index3", "row_id4", "row_index0", "row_Index1", "row_width0", "row_Indexon", "row_idon"], "j": ["ji", "v", "e", "l", "dj", "n", "end", "t", "ind", "q", "J", "jj", "r", "w", "jc", "el", "o", "g", "c", "h", "jp", "jam", "jl", "y", "row", "max", "I", "num", "job", "out", "m", "b", "p", "d", "z", "int", "ja", "k", "_", "f", "uj"], "row_index2": ["row_count5", "row_shapetwo", "rowxcount1", "row_ind0", "row_indextwo", "row_num5", "row_index5", "rowxindex5", "rowxindex1", "row_num1", "rowxindex2", "rowxcount2", "row_num2", "row_ind2", "row_count1", "row_shape2", "row_indtwo", "row_Index0", "row_shape02", "row_Indextwo", "row_index0", "row_index02", "row_count2", "row_Index2", "rowxcount5", "row_ind02", "row_Index02", "row_shape0"], "result": ["valid", "err", "res", "Result", "grade", "report", "product", "default", "compl", "success", "final", "output", "complete", "r", "func", "match", "dict", "value", "date", "name", "msg", "val", "row", "ret", "out", "message", "found", "ver", "df", "results", "response", "diff", "obj", "error", "rect", "comment", "data", "test"]}}
{"code": "CACHE = {(1, 1, 0): ['c'],\n   (1, 2, 0): ['c.'],\n   (1, 2, 1): ['*c'],\n   (1, 3, 0): ['c..'],\n   (1, 3, 1): ['*.c'],\n   (1, 3, 2): ['**c'],\n   (1, 4, 0): ['c...'],\n   (1, 4, 1): ['*.c.'],\n   (1, 4, 2): ['**.c'],\n   (1, 4, 3): ['***c'],\n   (1, 5, 0): ['c....'],\n   (1, 5, 1): ['*.c..'],\n   (1, 5, 2): ['**.c.'],\n   (1, 5, 3): ['***.c'],\n   (1, 5, 4): ['****c'],\n   (2, 1, 0): ['c', '.'],\n   (2, 1, 1): ['*', 'c'],\n   (2, 2, 0): ['c.', '..'],\n   (2, 2, 1): None,\n   (2, 2, 2): None,\n   (2, 2, 3): ['**', '*c'],\n   (2, 3, 0): ['c..', '...'],\n   (2, 3, 1): None,\n   (2, 3, 2): ['*.c', '*..'],\n   (2, 3, 3): None,\n   (2, 3, 4): None,\n   (2, 3, 5): ['***', '**c'],\n   (2, 4, 0): ['c...', '....'],\n   (2, 4, 1): None,\n   (2, 4, 2): ['*.c.', '*...'],\n   (2, 4, 3): None,\n   (2, 4, 4): ['**.c', '**..'],\n   (2, 4, 5): None,\n   (2, 4, 6): None,\n   (2, 4, 7): ['****', '***c'],\n   (2, 5, 0): ['c....', '.....'],\n   (2, 5, 1): None,\n   (2, 5, 2): ['*.c..', '*....'],\n   (2, 5, 3): None,\n   (2, 5, 4): ['**.c.', '**...'],\n   (2, 5, 5): None,\n   (2, 5, 6): ['***.c', '***..'],\n   (2, 5, 7): None,\n   (2, 5, 8): None,\n   (2, 5, 9): ['*****', '****c'],\n   (3, 1, 0): ['c', '.', '.'],\n   (3, 1, 1): ['*', '.', 'c'],\n   (3, 1, 2): ['*', '*', 'c'],\n   (3, 2, 0): ['c.', '..', '..'],\n   (3, 2, 1): None,\n   (3, 2, 2): ['**', '..', 'c.'],\n   (3, 2, 3): None,\n   (3, 2, 4): None,\n   (3, 2, 5): ['**', '**', '*c'],\n   (3, 3, 0): ['c..', '...', '...'],\n   (3, 3, 1): ['*.c', '...', '...'],\n   (3, 3, 2): None,\n   (3, 3, 3): ['***', '...', 'c..'],\n   (3, 3, 4): None,\n   (3, 3, 5): ['***', '*..', '*.c'],\n   (3, 3, 6): None,\n   (3, 3, 7): None,\n   (3, 3, 8): ['***', '***', '**c'],\n   (3, 4, 0): ['c...', '....', '....'],\n   (3, 4, 1): ['*.c.', '....', '....'],\n   (3, 4, 2): ['**.c', '....', '....'],\n   (3, 4, 3): ['*.c.', '*...', '*...'],\n   (3, 4, 4): ['****', '....', 'c...'],\n   (3, 4, 5): None,\n   (3, 4, 6): ['****', '*...', '*.c.'],\n   (3, 4, 7): None,\n   (3, 4, 8): ['****', '**..', '**.c'],\n   (3, 4, 9): None,\n   (3, 4, 10): None,\n   (3, 4, 11): ['****', '****', '***c'],\n   (3, 5, 0): ['c....', '.....', '.....'],\n   (3, 5, 1): ['*.c..', '.....', '.....'],\n   (3, 5, 2): ['**.c.', '.....', '.....'],\n   (3, 5, 3): ['***.c', '.....', '.....'],\n   (3, 5, 4): ['**.c.', '*....', '*....'],\n   (3, 5, 5): ['*****', '.....', 'c....'],\n   (3, 5, 6): ['**.c.', '**...', '**...'],\n   (3, 5, 7): ['*****', '*....', '*.c..'],\n   (3, 5, 8): None,\n   (3, 5, 9): ['*****', '**...', '**.c.'],\n   (3, 5, 10): None,\n   (3, 5, 11): ['*****', '***..', '***.c'],\n   (3, 5, 12): None,\n   (3, 5, 13): None,\n   (3, 5, 14): ['*****', '*****', '****c'],\n   (4, 1, 0): ['c', '.', '.', '.'],\n   (4, 1, 1): ['*', '.', 'c', '.'],\n   (4, 1, 2): ['*', '*', '.', 'c'],\n   (4, 1, 3): ['*', '*', '*', 'c'],\n   (4, 2, 0): ['c.', '..', '..', '..'],\n   (4, 2, 1): None,\n   (4, 2, 2): ['**', '..', 'c.', '..'],\n   (4, 2, 3): None,\n   (4, 2, 4): ['**', '**', '..', 'c.'],\n   (4, 2, 5): None,\n   (4, 2, 6): None,\n   (4, 2, 7): ['**', '**', '**', '*c'],\n   (4, 3, 0): ['c..', '...', '...', '...'],\n   (4, 3, 1): ['*.c', '...', '...', '...'],\n   (4, 3, 2): ['*.c', '*..', '...', '...'],\n   (4, 3, 3): ['***', '...', 'c..', '...'],\n   (4, 3, 4): ['***', '*..', '..c', '...'],\n   (4, 3, 5): None,\n   (4, 3, 6): ['***', '***', '...', 'c..'],\n   (4, 3, 7): None,\n   (4, 3, 8): ['***', '***', '*..', '*.c'],\n   (4, 3, 9): None,\n   (4, 3, 10): None,\n   (4, 3, 11): ['***', '***', '***', '**c'],\n   (4, 4, 0): ['c...', '....', '....', '....'],\n   (4, 4, 1): ['*.c.', '....', '....', '....'],\n   (4, 4, 2): ['**.c', '....', '....', '....'],\n   (4, 4, 3): ['**.c', '*...', '....', '....'],\n   (4, 4, 4): ['****', '....', 'c...', '....'],\n   (4, 4, 5): ['****', '*...', '..c.', '....'],\n   (4, 4, 6): ['****', '**..', '...c', '....'],\n   (4, 4, 7): ['****', '*...', '*.c.', '*...'],\n   (4, 4, 8): ['****', '****', '....', 'c...'],\n   (4, 4, 9): None,\n   (4, 4, 10): ['****', '****', '*...', '*.c.'],\n   (4, 4, 11): None,\n   (4, 4, 12): ['****', '****', '**..', '**.c'],\n   (4, 4, 13): None,\n   (4, 4, 14): None,\n   (4, 4, 15): ['****', '****', '****', '***c'],\n   (4, 5, 0): ['c....', '.....', '.....', '.....'],\n   (4, 5, 1): ['*.c..', '.....', '.....', '.....'],\n   (4, 5, 2): ['**.c.', '.....', '.....', '.....'],\n   (4, 5, 3): ['***.c', '.....', '.....', '.....'],\n   (4, 5, 4): ['***.c', '*....', '.....', '.....'],\n   (4, 5, 5): ['*****', '.....', 'c....', '.....'],\n   (4, 5, 6): ['*****', '*....', '..c..', '.....'],\n   (4, 5, 7): ['*****', '**...', '...c.', '.....'],\n   (4, 5, 8): ['*****', '***..', '....c', '.....'],\n   (4, 5, 9): ['*****', '**...', '*..c.', '*....'],\n   (4, 5, 10): ['*****', '*****', '.....', 'c....'],\n   (4, 5, 11): ['*****', '**...', '**.c.', '**...'],\n   (4, 5, 12): ['*****', '*****', '*....', '*.c..'],\n   (4, 5, 13): None,\n   (4, 5, 14): ['*****', '*****', '**...', '**.c.'],\n   (4, 5, 15): None,\n   (4, 5, 16): ['*****', '*****', '***..', '***.c'],\n   (4, 5, 17): None,\n   (4, 5, 18): None,\n   (4, 5, 19): ['*****', '*****', '*****', '****c'],\n   (5, 1, 0): ['c', '.', '.', '.', '.'],\n   (5, 1, 1): ['*', '.', 'c', '.', '.'],\n   (5, 1, 2): ['*', '*', '.', 'c', '.'],\n   (5, 1, 3): ['*', '*', '*', '.', 'c'],\n   (5, 1, 4): ['*', '*', '*', '*', 'c'],\n   (5, 2, 0): ['c.', '..', '..', '..', '..'],\n   (5, 2, 1): None,\n   (5, 2, 2): ['**', '..', 'c.', '..', '..'],\n   (5, 2, 3): None,\n   (5, 2, 4): ['**', '**', '..', 'c.', '..'],\n   (5, 2, 5): None,\n   (5, 2, 6): ['**', '**', '**', '..', 'c.'],\n   (5, 2, 7): None,\n   (5, 2, 8): None,\n   (5, 2, 9): ['**', '**', '**', '**', '*c'],\n   (5, 3, 0): ['c..', '...', '...', '...', '...'],\n   (5, 3, 1): ['*.c', '...', '...', '...', '...'],\n   (5, 3, 2): ['*.c', '*..', '...', '...', '...'],\n   (5, 3, 3): ['***', '...', 'c..', '...', '...'],\n   (5, 3, 4): ['***', '*..', '..c', '...', '...'],\n   (5, 3, 5): ['***', '*..', '*.c', '...', '...'],\n   (5, 3, 6): ['***', '***', '...', 'c..', '...'],\n   (5, 3, 7): ['***', '***', '*..', '..c', '...'],\n   (5, 3, 8): None,\n   (5, 3, 9): ['***', '***', '***', '...', 'c..'],\n   (5, 3, 10): None,\n   (5, 3, 11): ['***', '***', '***', '*..', '*.c'],\n   (5, 3, 12): None,\n   (5, 3, 13): None,\n   (5, 3, 14): ['***', '***', '***', '***', '**c'],\n   (5, 4, 0): ['c...', '....', '....', '....', '....'],\n   (5, 4, 1): ['*.c.', '....', '....', '....', '....'],\n   (5, 4, 2): ['**.c', '....', '....', '....', '....'],\n   (5, 4, 3): ['**.c', '*...', '....', '....', '....'],\n   (5, 4, 4): ['****', '....', 'c...', '....', '....'],\n   (5, 4, 5): ['****', '*...', '..c.', '....', '....'],\n   (5, 4, 6): ['****', '**..', '...c', '....', '....'],\n   (5, 4, 7): ['****', '**..', '*..c', '....', '....'],\n   (5, 4, 8): ['****', '****', '....', 'c...', '....'],\n   (5, 4, 9): ['****', '****', '*...', '..c.', '....'],\n   (5, 4, 10): ['****', '****', '**..', '...c', '....'],\n   (5, 4, 11): ['****', '****', '*...', '*.c.', '*...'],\n   (5, 4, 12): ['****', '****', '****', '....', 'c...'],\n   (5, 4, 13): None,\n   (5, 4, 14): ['****', '****', '****', '*...', '*.c.'],\n   (5, 4, 15): None,\n   (5, 4, 16): ['****', '****', '****', '**..', '**.c'],\n   (5, 4, 17): None,\n   (5, 4, 18): None,\n   (5, 4, 19): ['****', '****', '****', '****', '***c'],\n   (5, 5, 0): ['c....', '.....', '.....', '.....', '.....'],\n   (5, 5, 1): ['*.c..', '.....', '.....', '.....', '.....'],\n   (5, 5, 2): ['**.c.', '.....', '.....', '.....', '.....'],\n   (5, 5, 3): ['***.c', '.....', '.....', '.....', '.....'],\n   (5, 5, 4): ['***.c', '*....', '.....', '.....', '.....'],\n   (5, 5, 5): ['*****', '.....', 'c....', '.....', '.....'],\n   (5, 5, 6): ['*****', '*....', '..c..', '.....', '.....'],\n   (5, 5, 7): ['*****', '**...', '...c.', '.....', '.....'],\n   (5, 5, 8): ['*****', '***..', '....c', '.....', '.....'],\n   (5, 5, 9): ['*****', '***..', '*...c', '.....', '.....'],\n   (5, 5, 10): ['*****', '*****', '.....', 'c....', '.....'],\n   (5, 5, 11): ['*****', '*****', '*....', '..c..', '.....'],\n   (5, 5, 12): ['*****', '*****', '**...', '...c.', '.....'],\n   (5, 5, 13): ['*****', '*****', '***..', '....c', '.....'],\n   (5, 5, 14): ['*****', '*****', '**...', '*..c.', '*....'],\n   (5, 5, 15): ['*****', '*****', '*****', '.....', 'c....'],\n   (5, 5, 16): ['*****', '*****', '**...', '**.c.', '**...'],\n   (5, 5, 17): ['*****', '*****', '*****', '*....', '*.c..'],\n   (5, 5, 18): None,\n   (5, 5, 19): ['*****', '*****', '*****', '**...', '**.c.'],\n   (5, 5, 20): None,\n   (5, 5, 21): ['*****', '*****', '*****', '***..', '***.c'],\n   (5, 5, 22): None,\n   (5, 5, 23): None,\n   (5, 5, 24): ['*****', '*****', '*****', '*****', '****c']}\n  \n  \n  T = int(input())\n  for i in range(T):\n  \tR, C, M = map(int, input().split())\n  \tprint('Case #{}:'.format(i + 1))\n  \ttry:\n  \t\tprint('\n'.join(CACHE[(R, C, M)]))\n  \texcept:\n  \t\tprint('Impossible')\n", "substitutes": {"CACHE": ["HEACHHE", "CASCH", "CACHK", "CAGES", "HEACES", "CACCH", "CACHCH", "CACHES", "HEACHCH", "HEACHK", "CACHHE", "CASES", "CASHE", "CASK", "HEACCH", "CAGCH", "CAGK", "HEACK", "HEACHES", "CACK", "HEACHE", "CACES", "CAGHE"]}}
{"code": "T = int(input())\n  \n  for i in range(T):\n      a1 = int(input())\n      mat1 = [list(map(int, input().split())) for k in range(4)]\n      a2 = int(input())\n      mat2 = [list(map(int, input().split())) for k in range(4)]\n      final_set = set(mat1[a1 - 1]) & set(mat2[a2 - 1])\n      if not len(final_set):\n          s = 'Volunteer cheated!'\n      elif len(final_set) > 1:\n          s = 'Bad magician!'\n      else:\n          s = list(final_set)[0]\n      print('Case #{}: {}'.format(i + 1, s))\n", "substitutes": {"T": ["N", "Y", "Total", "TN", "t", "P", "n", "TI", "U", "Num", "H", "G", "W", "K", "X", "Time", "R", "Q", "I", "B", "num", "D", "F", "WT", "O", "S", "Z", "C", "M", "A", "L", "V"], "i": ["x", "id", "j", "v", "ii", "e", "key", "bi", "ik", "im", "ip", "t", "l", "n", "index", "phi", "ind", "q", "xi", "iu", "li", "c", "ti", "type", "chi", "gi", "y", "si", "I", "ci", "u", "ai", "p", "d", "z", "pi", "int", "a", "mini", "f"], "a1": ["alpha3", "alphaone", "A1", " a01", "A2", "aone", " aone", "p2", "a11", "p3", "Aone", "a01", "alpha2", " a3", "a3", "p11", "alpha11", " a11", "alpha01", "A01", "p1", "alpha1"], "mat1": ["ha1", "match3", "aOne", "mat3", "aone", "Mat1", "mapup", "map0", "ha0", "maOne", "ha3", "ma2", "Matone", "map1", "maone", "mat0", "matOne", "ma1", "map3", "match0", "matone", "haup", "match1", "MatOne", "Mat2", "matchup", "matup"], "k": ["king", "unk", "j", "kil", "n", "km", "get", "q", "ok", "kk", "ak", "w", "it", "ck", "un", "g", "K", "ku", "c", "kn", "ke", "kt", "ked", "sk", "b", "p", "kin", "kw", "_", "work", "ka", "ks"], "a2": ["wa2", "Asecond", "A1", "A2", "A4", "wa4", "A256", "a256", "ai1", " asecond", "asecond", "aisecond", "wa256", "a4", " a4", " a256", "ai2"], "mat2": ["na2", "wa2", " mat4", "Mat4", "a0", "Mat1", "Matl", "mat4", "na0", "wa4", "wa1", "na1", "wa0", "na4", "mat0", " matl", "a4", "Mat2", "al", "matl"], "final_set": ["finalaccase", " final_case", "final_sett", "finalestype", "finalessett", "last_sc", "last_list", "final_sample", "total_set", "final_sc", " final_type", "finalescase", " final_sett", " final_sets", "total_SET", "last_match", "finalfulsample", "final_list", "total_case", "finalfulcase", "finalfulsets", "final_type", "final_case", "final_sets", "total_test", "last_set", " final_sample", "finalactest", "final_test", "finalesset", "finalacSET", "finalacset", "final_match", "final_SET", "finalfulset"], "s": ["comments", "e", "v", "ns", "summary", "string", "ds", "l", "t", "sin", "south", "n", "sort", "side", "su", "site", "sym", "w", "spec", "status", "o", "space", "g", "c", "sq", "ssl", "set", "name", "title", "ses", "sb", "sync", "ws", "sing", "si", "y", "single", "strings", "ss", "source", "sign", "str", "rs", "S", "sv", "p", "session", "d", "sg", "ls", "new", "a", "comment", "f", "sf", "sl", "se"]}}
