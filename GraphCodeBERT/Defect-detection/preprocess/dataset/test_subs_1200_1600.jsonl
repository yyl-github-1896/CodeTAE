{"project": "FFmpeg", "commit_id": "83c285f88016b087c2f0f4b9ef356ad8ef12d947", "target": 1, "func": "static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size)\n\n{\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n    while(buf + 48 <= buf_end) {\n\n        int dir_length, name_size, first_sector, depth;\n\n        uint64_t file_length;\n\n        const uint8_t *name;\n\n        if (ff_guidcmp(buf, dir_entry_guid)) {\n\n            av_log(s, AV_LOG_ERROR, \"unknown guid \"FF_PRI_GUID\", expected dir_entry_guid; \"\n\n                   \"remaining directory entries ignored\\n\", FF_ARG_GUID(buf));\n\n            break;\n\n        }\n\n        dir_length  = AV_RL16(buf + 16);\n\n        file_length = AV_RL64(buf + 24);\n\n        name_size   = 2 * AV_RL32(buf + 32);\n\n        if (buf + 48 + name_size > buf_end) {\n\n            av_log(s, AV_LOG_ERROR, \"filename exceeds buffer size; remaining directory entries ignored\\n\");\n\n            break;\n\n        }\n\n        first_sector = AV_RL32(buf + 40 + name_size);\n\n        depth        = AV_RL32(buf + 44 + name_size);\n\n\n\n        /* compare file name; test optional null terminator */\n\n        name = buf + 40;\n\n        if (name_size >= filename_size &&\n\n            !memcmp(name, filename, filename_size) &&\n\n            (name_size < filename_size + 2 || !AV_RN16(name + filename_size)))\n\n            return wtvfile_open_sector(first_sector, file_length, depth, s);\n\n\n\n        buf += dir_length;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12273, "substitutes": {"s": ["context", "h", "i", "fs", "rs", "sn", "n", "sb", "serv", "z", "ses", "S", "os", "c", "sv", "ps", "p", "sys", "es", "socket", "r", "ls", "aws", "gs", "b", "js", "ims", "sp", "spec", "sts", "sq", "sw", "ex", "acs", "t", "ds", "self", "se", "cs", "ts", "is", "a", "south", "sm", "v", "f", "stats", "obj", "w", "ns", "ss"], "buf": ["pkg", "xff", "orig", "bc", "gz", "ait", "pool", "np", "cp", "cb", "r", "ptr", "pb", "read", "fb", "pg", "cv", "Buffer", "offset", "ob", "emb", "que", "uf", "cache", "prop", "end", "bar", "tmp", "alloc", "br", "word", "txt", "next", "vec", "img", "rc", "buffer", "loop", "cf", "cap", "msg", "bp", "cmd", "ab", "length", "doc", "bytes", "bt", "bf", "rb", "off", "begin", "uv", "err", "batch", "cam", "cast", "block", "data", "seq", "proc", "aw", "front", "var", "queue", "ff", "ref", "n", "cur", "desc", "raw", "buff", "port", "b", "window", "db", "box", "iter", "ctx", "um", "act", "ctr", "aka", "v", "wb", "obj", "shift"], "buf_size": ["bufipsize", "buf__scale", "buf8num", "buf_Size", "buff_ize", "dir_space", "buf__space", "buf8size", "dir__space", "bufipindex", "buf64size", "buf_num", "dir_size", "buf64ize", "dir__size", "buf8Size", "buf_index", "buff8ize", "buf8ize", "dir_scale", "buf__index", "dir__index", "buff_num", "buff_size", "bufipscale", "buf64Size", "buff_Size", "buf_ize", "bufipspace", "buf__size", "buf_scale", "dir__scale", "buf64num", "buff8Size", "buf_space", "buff8num", "buff8size", "dir_index"], "filename": ["Filename", "fp", "prefix", "package", "n", "png", "nam", "Name", "tmp", "subject", "txt", "bf", "ames", "title", "NAME", "nu", "nm", "nil", "println", "buffer", "fn", "ename", "path", "size", "description", "username", "file", "vr", "ame", "metadata", "v", "f", "text", "length", "uri", "folder"], "filename_size": ["filename_num", "name_weight", " filename_type", "filename_space", "filenameptdimension", "filenameablemax", "filename5space", "username_Size", "title_type", "filename_number", "filename_weight", " filename_offset", "Filename_unit", "Filename_Size", "filename5type", "username_size", " filename_space", "name_length", "filename_len", "filename5offset", "filenameptunit", "filename_max", "filenameableweight", "Filename_size", "username_len", "filename_length", "title_num", "filename_offset", "title_size", "filename_Size", "filenameablesize", "filename5size", "filenameptsize", "filename_dimension", "name_max", "filename_unit", "title_number", "filenameptSize", "username_length", "filename_type", "filenameablelength", "Filename_dimension"], "buf_end": [" buf_ends", "uf_END", "buff_END", "buff_stop", "buf_END", "buf_ended", " buf_ended", "bufxest", "buff_end", "bufxended", "bufxends", "uf_end", "buf_start", " buf_est", "buf2start", "buf2end", "bufxend", "buff_start", "buf_ends", "buf_est", "buf_stop", "buf2END", "buf2stop"], "dir_length": ["diritylong", "dir__length", "dir_len", "diritylength", "diritysize", "dirityloc", "dir__len", "dir_size", "file_len", "dir__size", " dir_len", " dir_long", "dir_loc", " dir_pad", "dir_position", " dir_size", "file_size", " dir_loc", "dir_pad", "file_position", "dir_long", "dir__position"], "name_size": [" name_count", "nameitysize", "file_body", "string____size", "NAME_see", "nameaxyscore", "name_time", "name____Size", "NAME_error", "NAME_size", "name____loss", "name_body", " name_spec", " name_index", "NAME_offset", "nameityoffset", "name_length", "name_Size", "name_score", " name_time", "name_loss", "string_Size", "name_SIZE", "file_score", "name_offset", "nameaxylength", "title_size", "name_count", "title_length", "nameitylength", "nameitySize", "title_ize", "name_see", "string_size", "name____size", "string____Size", "string____loss", "NAME_SIZE", "name_error", "name_spec", "name_index", "NAME_Size", "name_ize", "nameaxybody", "nameaxysize", "file_size", " name_length", "string_loss", "NAME_length"], "first_sector": ["initial_owner", "First_ector", "initial_sector", "firstairowner", "First_reader", "first_ector", " first_section", "initial_area", "first_area", "first_reader", " first_component", "initialairowner", "First_sector", "initialairector", "firstairector", "initialairsector", "initialairarea", "first_component", "initial_ector", "firstairsector", "first_owner", "First_section", "first_section", " first_ector", "firstairarea"], "depth": ["context", "device", "dist", "rank", "version", "direction", "time", "DEP", "level", "progress", "history", "priority", "Depth", "scale", "root", "position", "height", "ptr", " depths", "push", "dim", "trace", "window", "count", "deep", "distance", "volume", "path", "index", "der", "dir", "size", "dep", "mode", "fine", "offset", "max", "driver", "dq", "debug", "scope", "length"], "file_length": ["name_type", "fileitylength", "name_location", "file_shape", "dir_size", "file_len", "dir_shape", " file_size", "file_count", "dir_stream", "file_type", "name_length", "fileitysize", " file_len", "file_location", " file_count", "fileityshape", "file_size", "file_stream", "fileitystream"], "name": ["cache", "prefix", "version", "type", "end", "parent", "n", "image", "Name", "nam", "orig", "word", "format", "title", "local", "NAME", "root", "alias", "nm", "key", "mem", "window", "names", "buffer", "len", "path", "id", "size", "str", "cap", "num", "data", "max", "comment", "order", "file", "ame", "all", "text", "base", "var", "length", "term", "w", "label"]}}
{"project": "FFmpeg", "commit_id": "527f89e05922e840083ac6d49eeb838b1e350dd4", "target": 1, "func": "static void stereo_processing(PSContext *ps, INTFLOAT (*l)[32][2], INTFLOAT (*r)[32][2], int is34)\n\n{\n\n    int e, b, k;\n\n\n\n    INTFLOAT (*H11)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H11;\n\n    INTFLOAT (*H12)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H12;\n\n    INTFLOAT (*H21)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H21;\n\n    INTFLOAT (*H22)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H22;\n\n    int8_t *opd_hist = ps->opd_hist;\n\n    int8_t *ipd_hist = ps->ipd_hist;\n\n    int8_t iid_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t icc_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t ipd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t opd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t (*iid_mapped)[PS_MAX_NR_IIDICC] = iid_mapped_buf;\n\n    int8_t (*icc_mapped)[PS_MAX_NR_IIDICC] = icc_mapped_buf;\n\n    int8_t (*ipd_mapped)[PS_MAX_NR_IIDICC] = ipd_mapped_buf;\n\n    int8_t (*opd_mapped)[PS_MAX_NR_IIDICC] = opd_mapped_buf;\n\n    const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20;\n\n    TABLE_CONST INTFLOAT (*H_LUT)[8][4] = (PS_BASELINE || ps->icc_mode < 3) ? HA : HB;\n\n\n\n    //Remapping\n\n    if (ps->num_env_old) {\n\n        memcpy(H11[0][0], H11[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[0][0][0]));\n\n        memcpy(H11[1][0], H11[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[1][0][0]));\n\n        memcpy(H12[0][0], H12[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[0][0][0]));\n\n        memcpy(H12[1][0], H12[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[1][0][0]));\n\n        memcpy(H21[0][0], H21[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[0][0][0]));\n\n        memcpy(H21[1][0], H21[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[1][0][0]));\n\n        memcpy(H22[0][0], H22[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[0][0][0]));\n\n        memcpy(H22[1][0], H22[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[1][0][0]));\n\n    }\n\n\n\n    if (is34) {\n\n        remap34(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1);\n\n        remap34(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1);\n\n        if (ps->enable_ipdopd) {\n\n            remap34(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n            remap34(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n        }\n\n        if (!ps->is34bands_old) {\n\n            map_val_20_to_34(H11[0][0]);\n\n            map_val_20_to_34(H11[1][0]);\n\n            map_val_20_to_34(H12[0][0]);\n\n            map_val_20_to_34(H12[1][0]);\n\n            map_val_20_to_34(H21[0][0]);\n\n            map_val_20_to_34(H21[1][0]);\n\n            map_val_20_to_34(H22[0][0]);\n\n            map_val_20_to_34(H22[1][0]);\n\n            ipdopd_reset(ipd_hist, opd_hist);\n\n        }\n\n    } else {\n\n        remap20(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1);\n\n        remap20(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1);\n\n        if (ps->enable_ipdopd) {\n\n            remap20(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n            remap20(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n        }\n\n        if (ps->is34bands_old) {\n\n            map_val_34_to_20(H11[0][0]);\n\n            map_val_34_to_20(H11[1][0]);\n\n            map_val_34_to_20(H12[0][0]);\n\n            map_val_34_to_20(H12[1][0]);\n\n            map_val_34_to_20(H21[0][0]);\n\n            map_val_34_to_20(H21[1][0]);\n\n            map_val_34_to_20(H22[0][0]);\n\n            map_val_34_to_20(H22[1][0]);\n\n            ipdopd_reset(ipd_hist, opd_hist);\n\n        }\n\n    }\n\n\n\n    //Mixing\n\n    for (e = 0; e < ps->num_env; e++) {\n\n        for (b = 0; b < NR_PAR_BANDS[is34]; b++) {\n\n            INTFLOAT h11, h12, h21, h22;\n\n            h11 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][0];\n\n            h12 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][1];\n\n            h21 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][2];\n\n            h22 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][3];\n\n\n\n            if (!PS_BASELINE && ps->enable_ipdopd && b < NR_IPDOPD_BANDS[is34]) {\n\n                //The spec say says to only run this smoother when enable_ipdopd\n\n                //is set but the reference decoder appears to run it constantly\n\n                INTFLOAT h11i, h12i, h21i, h22i;\n\n                INTFLOAT ipd_adj_re, ipd_adj_im;\n\n                int opd_idx = opd_hist[b] * 8 + opd_mapped[e][b];\n\n                int ipd_idx = ipd_hist[b] * 8 + ipd_mapped[e][b];\n\n                INTFLOAT opd_re = pd_re_smooth[opd_idx];\n\n                INTFLOAT opd_im = pd_im_smooth[opd_idx];\n\n                INTFLOAT ipd_re = pd_re_smooth[ipd_idx];\n\n                INTFLOAT ipd_im = pd_im_smooth[ipd_idx];\n\n                opd_hist[b] = opd_idx & 0x3F;\n\n                ipd_hist[b] = ipd_idx & 0x3F;\n\n\n\n                ipd_adj_re = AAC_MADD30(opd_re, ipd_re, opd_im, ipd_im);\n\n                ipd_adj_im = AAC_MSUB30(opd_im, ipd_re, opd_re, ipd_im);\n\n                h11i = AAC_MUL30(h11,  opd_im);\n\n                h11  = AAC_MUL30(h11,  opd_re);\n\n                h12i = AAC_MUL30(h12,  ipd_adj_im);\n\n                h12  = AAC_MUL30(h12,  ipd_adj_re);\n\n                h21i = AAC_MUL30(h21,  opd_im);\n\n                h21  = AAC_MUL30(h21,  opd_re);\n\n                h22i = AAC_MUL30(h22,  ipd_adj_im);\n\n                h22  = AAC_MUL30(h22,  ipd_adj_re);\n\n                H11[1][e+1][b] = h11i;\n\n                H12[1][e+1][b] = h12i;\n\n                H21[1][e+1][b] = h21i;\n\n                H22[1][e+1][b] = h22i;\n\n            }\n\n            H11[0][e+1][b] = h11;\n\n            H12[0][e+1][b] = h12;\n\n            H21[0][e+1][b] = h21;\n\n            H22[0][e+1][b] = h22;\n\n        }\n\n        for (k = 0; k < NR_BANDS[is34]; k++) {\n\n            LOCAL_ALIGNED_16(INTFLOAT, h, [2], [4]);\n\n            LOCAL_ALIGNED_16(INTFLOAT, h_step, [2], [4]);\n\n            int start = ps->border_position[e];\n\n            int stop  = ps->border_position[e+1];\n\n            INTFLOAT width = Q30(1.f) / ((stop - start) ? (stop - start) : 1);\n\n#if USE_FIXED\n\n            width <<= 1;\n\n#endif\n\n            b = k_to_i[k];\n\n            h[0][0] = H11[0][e][b];\n\n            h[0][1] = H12[0][e][b];\n\n            h[0][2] = H21[0][e][b];\n\n            h[0][3] = H22[0][e][b];\n\n            if (!PS_BASELINE && ps->enable_ipdopd) {\n\n            //Is this necessary? ps_04_new seems unchanged\n\n            if ((is34 && k <= 13 && k >= 9) || (!is34 && k <= 1)) {\n\n                h[1][0] = -H11[1][e][b];\n\n                h[1][1] = -H12[1][e][b];\n\n                h[1][2] = -H21[1][e][b];\n\n                h[1][3] = -H22[1][e][b];\n\n            } else {\n\n                h[1][0] = H11[1][e][b];\n\n                h[1][1] = H12[1][e][b];\n\n                h[1][2] = H21[1][e][b];\n\n                h[1][3] = H22[1][e][b];\n\n            }\n\n            }\n\n            //Interpolation\n\n            h_step[0][0] = AAC_MSUB31_V3(H11[0][e+1][b], h[0][0], width);\n\n            h_step[0][1] = AAC_MSUB31_V3(H12[0][e+1][b], h[0][1], width);\n\n            h_step[0][2] = AAC_MSUB31_V3(H21[0][e+1][b], h[0][2], width);\n\n            h_step[0][3] = AAC_MSUB31_V3(H22[0][e+1][b], h[0][3], width);\n\n            if (!PS_BASELINE && ps->enable_ipdopd) {\n\n                h_step[1][0] = AAC_MSUB31_V3(H11[1][e+1][b], h[1][0], width);\n\n                h_step[1][1] = AAC_MSUB31_V3(H12[1][e+1][b], h[1][1], width);\n\n                h_step[1][2] = AAC_MSUB31_V3(H21[1][e+1][b], h[1][2], width);\n\n                h_step[1][3] = AAC_MSUB31_V3(H22[1][e+1][b], h[1][3], width);\n\n            }\n\n            ps->dsp.stereo_interpolate[!PS_BASELINE && ps->enable_ipdopd](\n\n                l[k] + start + 1, r[k] + start + 1,\n\n                h, h_step, stop - start);\n\n        }\n\n    }\n\n}\n", "idx": 12278, "substitutes": {"ps": ["fps", "bs", "pkg", "jp", "changes", "points", "ops", "checks", "os", "pa", "ips", "als", "px", "pers", "cp", "eps", "p", "s", "pre", "outs", "vs", "Ps", "ms", "gs", "pps", "mp", "ports", "js", "sp", "vals", "caps", "aps", "proc", "ds", "ns", "pse", "times", "cs", "ts", "pt", "pr", "pp", "plays", "PS", "stats", "ping", "parts", "posts"], "l": ["i", "dl", "lp", "n", "lt", "sl", "z", "lc", "c", "q", "li", "loc", "p", "pl", "kl", "m", "ls", "lo", "ln", "g", "j", "L", "el", "ol", "ll", "o", "le", "v", "f"], "r": ["h", "d", "rs", "n", "x", "rb", "re", "ar", "c", "q", "er", "p", "m", "R", "rx", "ry", "rd", "rc", "rr", "g", "rn", "t", "rt", "cr", "v", "w"], "is34": ["is3", "is33", "Is33", "Is36", "IS33", "ISp", "Is3", "IS36", "is36", " ISp", " IS3", " IS33", " IS36", "Isp", "isp", "IS3"], "e": ["i", "d", "E", "n", "pe", "oe", "c", "u", "er", "ei", "p", "et", "g", "me", "ie", "ec", "t", "ea", "o", "a", "be", "f", "v", "le", "y", "w"], "b": ["bs", "i", "n", "bt", "bc", "bf", "rb", "c", "cb", "p", "fb", "eb", "db", "bb", "g", "j", "B", "nb", "bp", "a", "y", "v", "bi", "be", "ab", "f", "ba"], "k": ["i", "n", "z", "ck", "tk", "c", "q", "u", "p", "s", "m", "key", "kk", "kh", "sk", "g", "j", "ka", "ke", "km", "ik", "ak", "kid", "o", "K", "v", "y", "w"], "opd_hist": ["opd_graph", "opdo_pred", "opdo_progress", "opd_state", "opdo_history", "opd_history", "opd5hist", "opdo_hist", "opd5graph", "opd5history", "opd5pred", "opdo_graph", "opd_progress", "opd_pred", "opdo_state"], "ipd_hist": ["ipd__history", "ipdo_txt", "ipd_high", "ipdo_best", "ipd___high", "ipn_high", "ipd__best", "ipd_hp", "ipd__txt", "ipd___history", "ipn_history", "ipd_history", "ipd___hist", "ipd___hp", "ipn_hist", "ipd__hist", "ipdo_hist", "ipn_hp", "ipd_best", "ipdo_history", "ipd_txt"], "iid_mapped_buf": ["iid_mapper_buf", "iid_mapped2buff", "iid_mapper_buff", "iid_mapped2buffer", "iid_mapped_desc", "iid_mapper_cv", "iid_mapped2buf", "iid_mapper_buffer", "iid_mapped_cv", "iid_mapped_buff", "iid_maped_buffer", "iid_maped_desc", "iid_mapped2cv", "iid_mapped_buffer", "iid_maped_buf"], "PS_MAX_NUM_ENV": ["PS_MAX_NUM_EnVC", "PS_MAX_NUM_PNVER", "PS_MAX_NUMINGENGVs", "PS_MAX_NUM_INVC", "PS_MAX_NUM_INVS", "PS_MAX_NUM_ENH", "PS_MAX_NUM_ENGVS", "PS_MAX_NUMINGENGV", "PS_MAX_NUM__INVER", "PS_MAX_NUM_enVEL", "PS_MAX_NUM__ENVER", "PS_MAX_NUMINGENVs", "PS_MAX_NUM_PNVEL", "PS_MAX_NUM_EnF", "PS_MAX_NUM_enVS", "PS_MAX_NUM_enX", "PS_MAX_NUM_ENGQ", "PS_MAX_NUM__ENIV", "PS_MAX_NUM_EXTv", "PS_MAX_NUM_INH", "PS_MAX_NUM_ENVS", "PS_MAX_NUM_EnQ", "PS_MAX_NUM_EnVER", "PS_MAX_NUM_ENF", "PS_MAX_NUM2ENF", "PS_MAX_NUM_EXTVS", "PS_MAX_NUM2EnVER", "PS_MAX_NUM__ENVS", "PS_MAX_NUM_EnVs", "PS_MAX_NUM_INVER", "PS_MAX_NUM_INQ", "PS_MAX_NUM_enH", "PS_MAX_NUM__INv", "PS_MAX_NUM2ENVER", "PS_MAX_NUMINGENGVS", "PS_MAX_NUM_EnV", "PS_MAX_NUM__EnVS", "PS_MAX_NUM_PNv", "PS_MAX_NUM2EnV", "PS_MAX_NUM__EnIV", "PS_MAX_NUM_INVs", "PS_MAX_NUM_EXTV", "PS_MAX_NUM__INVS", "PS_MAX_NUM2EnVS", "PS_MAX_NUM_ENVs", "PS_MAX_NUM_INV", "PS_MAX_NUM_ENIV", "PS_MAX_NUM2ENV", "PS_MAX_NUM__INV", "PS_MAX_NUM__EnV", "PS_MAX_NUM__ENv", "PS_MAX_NUM__EnH", "PS_MAX_NUM_INv", "PS_MAX_NUM_ETV", "PS_MAX_NUM_EnVS", "PS_MAX_NUM_INF", "PS_MAX_NUM__ENH", "PS_MAX_NUM_ENVC", "PS_MAX_NUM_PNX", "PS_MAX_NUM_PNVS", "PS_MAX_NUM_enVC", "PS_MAX_NUM_Env", "PS_MAX_NUM_ETVEL", "PS_MAX_NUMINGENVS", "PS_MAX_NUM_ENVEL", "PS_MAX_NUM_EnIV", "PS_MAX_NUM_PNVs", "PS_MAX_NUM_env", "PS_MAX_NUM__ENV", "PS_MAX_NUM_enVER", "PS_MAX_NUM2ENVS", "PS_MAX_NUM_PNV", "PS_MAX_NUM_ENQ", "PS_MAX_NUM_ENv", "PS_MAX_NUMINGENV", "PS_MAX_NUMINGENQ", "PS_MAX_NUM_EXTVs", "PS_MAX_NUMINGENGQ", "PS_MAX_NUM_ETX", "PS_MAX_NUM_ENGV", "PS_MAX_NUM2EnF", "PS_MAX_NUM_EnH", "PS_MAX_NUM_enV", "PS_MAX_NUM_enIV", "PS_MAX_NUM_ENGVs", "PS_MAX_NUM_ENX", "PS_MAX_NUM_ENVER", "PS_MAX_NUM_ETv"], "icc_mapped_buf": ["icc_mapping_window", "icc_mapping_buffer", "icc_mapped_str", "icc_mapped__str", "icc_maped_queue", "icc_mapped__buffer", "icc_mapped_queue", "icc_mapped_buff", "icc_mapped_window", "icc_maped_str", "icc_maped_buf", "icc_mapped_buffer", "icc_mapped__buf", "icc_mapping_buf", "icc_maped_buffer", "icc_mapping_buff", "icc_mapped__queue"], "ipd_mapped_buf": ["ipd_mapper_buff", "ipd_mappedlyimg", "ipd_mapping_uf", "ipd_mapped__uf", "ipd_mapped__buf", "ipd_mapping_buf", "ipd_mapped_uf", "ipd_mappedlybuf", "ipd_mappedlybuffer", "ipd_mapped_buffer", "ipd_mapped2img", "ipd_mapped2uf", "ipd_mapped_img", "ipd_mapping_buffer", "ipd_mapper_uf", "ipd_mapped_buff", "ipd_mapped__buff", "ipd_mapper_buf", "ipd_mapper_buffer", "ipd_mapped__buffer", "ipd_mapped2buffer", "ipd_mapping_img", "ipd_mapped2buf", "ipd_mappedlyuf"], "opd_mapped_buf": ["opd_mapped2uf", "opd_mapper_buff", "opd_mapper_buffer", "opd_mapped_buffer", "opd_mapper_buf", "opd_mapped2buff", "opd_mapped2buf", "opd_mapped_uf", "opd_mapper_uf", "opd_mapped2buffer", "opd_mapped_buff"], "iid_mapped": ["iid_comuted", "iid_Mapped", "iid_mmapped", "iid_mmaped", "iid_muted", "iid_Muted", "iid_comapping", "iid_mmapping", "iid_maped", "iid_comaped", "iid_comapped", "iid_Mapping", "iid_mmuted", "iid_Maped", "iid_mapping"], "icc_mapped": ["icc_mmapping", "icc_sammitted", "icc_mmitted", "icc_samapped", "icc_samigrated", "icc_mmapped", "icc_migrated", "icc_mapping", "icc_memigrated", "icc_samapping", "icc_memapped", "icc_mmmitted", "icc_memmitted", "icc_memapping", "icc_mmigrated"], "ipd_mapped": ["ipd_mmocked", "ipd_smapping", "ipd_mapper", "ipd_Mapped", "ipd_Mapping", "ipd_mmapped", "ipd_Mapper", "ipd_mmapper", "ipd_Mocked", "ipd_mmapping", "ipd_smapped", "ipd_smocked", "ipd_mocked", "ipd_mapping", "ipd_smapper"], "opd_mapped": ["opd_capper", "opd_mmapped", "opd_mrapped", "opd_mrashed", "opd_manned", "opd_capped", "opd_mapper", "opd_cashed", "opd_canned", "opd_mmashed", "opd_mashed", "opd_mmapper", "opd_mrapper", "opd_mmanned", "opd_mranned"], "INTFLOAT": ["INTFLOOAT", "INTPLOATT", "INTFLOBATS", "INTFLoATT", "INTFLOLATER", "INTFLOLATT", "INTFLOBATT", "INTFLOAN", "INTFLOAR", "INTFLLOAT", "INTPLOBATER", "INTFLLOAN", "INTPLOANT", "INTPLOOATION", "INTFLOBANT", "INTFLOOATS", "INTFLOOATION", "INTPLOATION", "INTFLOLATION", "INTFLoAN", "INTPLONAT", "INTPLOOATS", "INTPLOBAR", "INTPLOAT", "INTFROBATER", "INTFLOATION", "INTFLPOATION", "INTFLOOATT", "INTFLOBATER", "INTFLOANT", "INTPLOAN", "INTFROATT", "INTFROOATT", "INTFROBATS", "INTFLOLANT", "INTPLOBANT", "INTPLOATS", "INTFROBAT", "INTPLONAN", "INTPLOBAT", "INTFLOOAN", "INTFROATER", "INTPLONATS", "INTFROATS", "INTFLPOATS", "INTFLOBAR", "INTFLOLATS", "INTFLoAT", "INTFLONANT", "INTFLOATER", "INTFLPOATT", "INTFLOLAT", "INTFROOAT", "INTFLoATS", "INTFROAT", "INTFLOOAR", "INTFLONATS", "INTPLONANT", "INTFROAR", "INTFROBATT", "INTFROOATS", "INTPLOAR", "INTFLONAN", "INTFLOBAT", "INTFLOLAR", "INTFLLOATS", "INTFLONAT", "INTFLOOANT", "INTFLPOATER", "INTFLLOANT", "INTFLOOATER", "INTFLPOAT", "INTFLOATS", "INTFROOAR", "INTFLONATT", "INTFLOATT", "INTPLOATER", "INTFLPOAR", "INTPLOOAT", "INTFLoAR", "INTPLOOATT"]}}
{"project": "qemu", "commit_id": "04f8c053cca9c329eebb761f3a1ffef3d349b84c", "target": 1, "func": "static void handle_qmp_command(JSONMessageParser *parser, QList *tokens)\n\n{\n\n    int err;\n\n    QObject *obj;\n\n    QDict *input, *args;\n\n    const mon_cmd_t *cmd;\n\n    Monitor *mon = cur_mon;\n\n    const char *cmd_name, *info_item;\n\n\n\n    args = NULL;\n\n\n\n    obj = json_parser_parse(tokens, NULL);\n\n    if (!obj) {\n\n        // FIXME: should be triggered in json_parser_parse()\n\n        qerror_report(QERR_JSON_PARSING);\n\n        goto err_out;\n\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, \"object\");\n\n        qobject_decref(obj);\n\n        goto err_out;\n\n    }\n\n\n\n    input = qobject_to_qdict(obj);\n\n\n\n    mon->mc->id = qdict_get(input, \"id\");\n\n    qobject_incref(mon->mc->id);\n\n\n\n    obj = qdict_get(input, \"execute\");\n\n    if (!obj) {\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n\n    } else if (qobject_type(obj) != QTYPE_QSTRING) {\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\", \"string\");\n\n\n    }\n\n\n\n    cmd_name = qstring_get_str(qobject_to_qstring(obj));\n\n\n\n    if (invalid_qmp_mode(mon, cmd_name)) {\n\n        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n    }\n\n\n\n    /*\n\n     * XXX: We need this special case until we get info handlers\n\n     * converted into 'query-' commands\n\n     */\n\n    if (compare_cmd(cmd_name, \"info\")) {\n\n        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n    } else if (strstart(cmd_name, \"query-\", &info_item)) {\n\n        cmd = monitor_find_command(\"info\");\n\n        qdict_put_obj(input, \"arguments\",\n\n                      qobject_from_jsonf(\"{ 'item': %s }\", info_item));\n\n    } else {\n\n        cmd = monitor_find_command(cmd_name);\n\n        if (!cmd || !monitor_handler_ported(cmd)) {\n\n            qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n        }\n\n    }\n\n\n\n    obj = qdict_get(input, \"arguments\");\n\n    if (!obj) {\n\n        args = qdict_new();\n\n\n\n\n    } else {\n\n        args = qobject_to_qdict(obj);\n\n        QINCREF(args);\n\n    }\n\n\n\n    QDECREF(input);\n\n\n\n    err = monitor_check_qmp_args(cmd, args);\n\n    if (err < 0) {\n\n        goto err_out;\n\n    }\n\n\n\n    if (monitor_handler_is_async(cmd)) {\n\n        qmp_async_cmd_handler(mon, cmd, args);\n\n    } else {\n\n        monitor_call_handler(mon, cmd, args);\n\n    }\n\n    goto out;\n\n\n\nerr_input:\n\n    QDECREF(input);\n\nerr_out:\n\n    monitor_protocol_emitter(mon, NULL);\n\nout:\n\n    QDECREF(args);\n\n}", "idx": 12281, "substitutes": {"parser": ["reader", "arser", "util", "loader", "processor", "document", "builder", "Parser", "er", "message", "p", "ner", "pd", "parse", "der", "inner", "manager", "sq", "php", "handler", "part", "policy", "command", "ping", "native", "pair"], "tokens": ["Targelines", "topleens", "Targkens", "Targen", "tobkens", "tokelines", " toplekens", "toykens", "toyens", " topleens", " tokkens", "targelines", " tokENS", "toplekens", "targings", "tobings", "tocen", "tocelines", "Token", "toyelines", "topleENS", "tokkens", "Tokens", "Tokelines", "tocens", "topleings", " tokings", "toyen", "Targens", "tobENS", "targens", "tobens", "tokings", " topleENS", "token", "Tokkens", " topleings", "targkens", "targENS", "targen", "tockens", "tokENS"], "err": ["erer", "i", " len", "type", "Error", " score", "score", "error", "out", "buf", "c", "cb", "er", "arr", "r", "ach", "m", "e", "count", "rr", "str", "attr", " Err", "fer", "val", "y", "v", "or"], "obj": ["pkg", "orig", "art", "bj", "tk", "cmp", "np", "oid", "canon", "att", "js", "instance", "rect", "it", "ex", "expr", "snap", "pt", "ob", "nex", "vo", "Obj", "con", "tmp", "objects", "ck", "txt", "os", "def", "img", "oj", "ot", "j", "msg", "conn", "t", "po", "opp", "resp", "oc", "ind", "adj", "opt", "utt", "app", "gm", "comm", "arr", "ent", "nt", "object", "op", "ct", "typ", "o", "onet", "oss", "ref", "dict", "elt", "out", "bo", "buff", "ctx", "cont", "str", "og", "act", "obo", "ox", "inst", "attr", "Object", "obs"], "input": ["context", "view", "info", "ref", "select", "dict", "image", "orig", "hidden", "tmp", "json", "history", "local", "out", "ip", "init", "q", " inputs", "conf", "xml", "interface", "def", "ahead", "check", "list", "start", "from", "add", "qa", "img", "valid", "raw", "PUT", "storage", "update", "in", "att", "window", "initial", "buffer", "active", "index", "path", "import", "inner", "cont", "str", "act", "amount", "data", "joined", "conn", "mm", "arg", "Input", "get", "config", "source", "head", "all", "text", "base", "table", "form", "doc", "up", "output"], "args": ["rs", "extra", "ks", "keys", "json", "flags", "out", "files", "headers", "ams", "fields", "arr", "atts", "options", "gs", "pos", "in", "js", "names", "ctx", "tags", "vals", "data", "arg", "attr", "actions", "cs", "ts", "items", "types", "ins", "qs", "parts", "Args", "ns", "params"], "cmd": ["pkg", "bind", "ind", "ch", "req", "norm", "dict", "nd", "ck", "txt", "cli", "cur", "cmp", "col", "cat", "cy", "init", "c", "cp", "cb", "comm", "cn", "exec", "def", "urg", "cfg", "mk", "md", "nt", "ctx", "quit", "fun", "cont", "cf", "act", "msg", "conn", "cl", "ct", "dq", "Cmd", "pat", "ctr", "func", "quick", "crit", "phy", "cond", "resp", "ph", "command", "cd", "qt", "call", "chan"], "mon": ["on", "mun", "dm", "om", " monitor", "tem", "dom", "serv", "monitor", "local", "util", "comm", "rain", "wat", "admin", "conf", "mut", "mc", "m", "sam", "monkey", "von", "mn", "mem", "mate", "my", "por", "Mon", "mint", "MON", "ann", "dir", "mind", "manager", "demon", "num", "mx", "conn", "mons", "den", "mt", "mm", "non", "mitter", "mit", "self", "mos", "mi", "man", "master", "onet", "stat", "mat", "sm", "mont", "mu"], "cmd_name": ["cmd_ame", "cmd_not", "cmdptno", " cmd_item", "cmd23Name", "cbLEName", "cmp_base", "cmdNamedata", "cmdLEname", "procptno", " cmd_not", "cbLElocal", "procptname", "cmdmynew", "cmd_names", "cbLEname", "batch_name", "cmd23named", "cmd_new", "batch_new", "cb_name", "cmdLEnames", "cmd_data", " cmd_no", "cmd_local", "cmd_named", "msg_name", "cmd_base", "cmp_name", "cmdptame", "cmp_item", "cmdLElocal", "cmp_data", "cmdmyvalue", "cmd_value", "batch_comment", "cmd_key", "proc_name", "cmdLEName", "cb_names", " cmd_id", "cmd_id", "procptame", " cmd_Name", "batch_value", "cmdNamebase", "cmd2Name", "cmd23name", "cmdNameitem", "cb_local", "cmdptname", "msg_key", "cmd_Name", "proc_ame", "cmd2no", "cb_Name", "cmd_no", "msg_Name", "cmdMcomment", "cmd23not", " cmd_named", "msg_no", "cmdMvalue", "cmd_item", "cmdmyname", "cmdmycomment", "cmdMnew", "cmd_comment", "cmd2name", "cbLEnames", "cmdMname", "proc_no", "cmdNamename"], "info_item": ["infoableid", " info_value", " info_id", " info_items", " info_Item", "infomyitems", "info_id", "info_items", "info_Item", "infomyid", "info2Item", "infoableitems", "info2items", "info_value", "infoablevalue", "infomyvalue", "info2item", " info_msg", "info_msg", "infoableitem", "infomyitem"]}}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int idcin_decode_init(AVCodecContext *avctx)\n\n{\n\n    IdcinContext *s = avctx->priv_data;\n\n    int i, j, histogram_index = 0;\n\n    unsigned char *histograms;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_PAL8;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    /* make sure the Huffman tables make it */\n\n    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  Id CIN video: expected extradata size of %d\\n\", HUFFMAN_TABLE_SIZE);\n\n        return -1;\n\n    }\n\n\n\n    /* build the 256 Huffman decode trees */\n\n    histograms = (unsigned char *)s->avctx->extradata;\n\n    for (i = 0; i < 256; i++) {\n\n        for(j = 0; j < HUF_TOKENS; j++)\n\n            s->huff_nodes[i][j].count = histograms[histogram_index++];\n\n        huff_build_tree(s, i);\n\n    }\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 12305, "substitutes": {"avctx": [" avjac", "avercontext", " avcmp", "awcontext", "abcontext", "awtx", "wavcontext", "avtx", "apctl", "Avctx", "vrcontext", "avcfg", "cvctx", " avcontext", "apcontext", "awctx", "apctx", " avca", "cvjac", "avca", "cvcontext", "vertx", "abpkg", "vercontext", "afcontext", "avcmd", "afctl", "verconn", "avpkg", "vrtx", "averctx", "apcfg", "aftx", "avejac", "avectx", "avjp", "afca", "afctx", "abconn", "aptx", " avpkg", " avconn", "abtx", "avjac", "abjac", "verctx", "AVcontext", "AVctx", "avcontext", "avercmd", "avejp", "abctx", "avecontext", "awcfg", "Avcontext", "afcmd", "wavpkg", "Avcmp", "avcmp", "wavtx", " avcmd", "vrctx", " avcfg", "apjp", "avetx", "averca", "avctl", " avctl", " avtx", "wavctx", "wavjac", "AVtx", "avconn", "aveconn", "afcfg", "cvtx", "vrcfg", "Avtx", "wavjp", "AVcmp"], "s": ["bs", "details", "fs", "rs", "sb", "n", "sl", "ses", "ies", "ears", "S", "os", "bes", "als", "c", "sv", "q", "ps", "ss", "comm", "p", "set", "ess", "sys", "ssl", "ls", "sports", "vs", "us", "hs", "ms", "aws", "gs", "ats", "b", "its", "js", "as", "ims", "w", "ags", "g", "sq", "sw", "aps", "less", "acs", "t", "ares", "ds", "states", "cs", "ts", "sc", "tests", "is", "source", "comments", "v", "stats", "ins", "qs", "sync", "parts", "scl", "ns", "tes", "sts"], "i": ["iq", "ind", "ai", "ii", "ji", "n", "gi", "k", "status", "z", "di", "point", "x", "ij", "ip", "iy", "u", "ti", "q", "li", "\u0438", "I", "p", "ei", "si", "from", "m", "ri", "key", "us", "asi", "name", "im", "multi", "in", "e", "ami", "my", "ims", "index", "iu", "id", " ii", "at", "it", "me", "g", "ci", "ie", "xi", "ex", "ic", "ki", "ik", "phi", "zi", "ix", "mi", "is", "o", "iri", "pi", "y", "v", "ui", "ini", "by", "bi"], "j": ["h", "ind", "jp", "l", "adj", "ii", "ji", "n", "aj", "k", "z", "json", "br", "x", "bj", "ij", "jo", "c", "q", "p", "jj", "jump", "m", "oj", "key", "mn", "bo", "kh", "b", "att", "ja", "js", "ng", "no", "index", "g", "job", "it", "uj", "fr", "dj", "jas", "kj", "J", "jc", "pt", "pr", "kid", "v", "y", "bi", "obj", "jl", "on", "jit"], "histograms": ["hashograms", " histoids", " histores", " histogram", " histobs", "historyograms", "historyogram", "digores", "histensions", "histots", "Histensions", "hots", " histensions", " histometers", "historyobs", "Histrices", "digrices", "histoids", "hashories", "digograms", "memometers", "memoids", "digensions", "hobs", "histogram", "hashoids", "historyots", "Histograms", "histobs", " histrices", "histrices", " histories", "Histores", "hogram", "histores", "hashometers", " histots", "hograms", "histories", "memograms", "memories", "histometers"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static void find_best_solid_area(VncState *vs, int x, int y, int w, int h,\n\n                                 uint32_t color, int *w_ptr, int *h_ptr)\n\n{\n\n    int dx, dy, dw, dh;\n\n    int w_prev;\n\n    int w_best = 0, h_best = 0;\n\n\n\n    w_prev = w;\n\n\n\n    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {\n\n\n\n        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);\n\n        dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);\n\n\n\n        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {\n\n            break;\n\n        }\n\n\n\n        for (dx = x + dw; dx < x + w_prev;) {\n\n            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);\n\n\n\n            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {\n\n                break;\n\n            }\n\n            dx += dw;\n\n        }\n\n\n\n        w_prev = dx - x;\n\n        if (w_prev * (dy + dh - y) > w_best * h_best) {\n\n            w_best = w_prev;\n\n            h_best = dy + dh - y;\n\n        }\n\n    }\n\n\n\n    *w_ptr = w_best;\n\n    *h_ptr = h_best;\n\n}\n", "idx": 12307, "substitutes": {"vs": ["bs", "fps", "aunts", "vc", "fs", "rs", "verts", "ops", "ses", "os", "views", "sv", "ps", "otes", "ails", "sys", "court", "vg", "atts", "ls", "xs", "vp", "hs", "gs", "js", "VS", "blogs", "vt", "lbs", "Vs", "vals", "values", "ds", "vr", "cs", "ts", "ils", "iffs", "v", "stats", "forces", "ins", "ns", "lists", "sts"], "x": ["fx", "i", "dl", "d", "xp", "l", "ax", "z", "tx", "px", "c", "xc", "xf", "p", "xt", "r", "m", "xa", "rx", "xs", "dr", "xy", "index", "xd", "at", "xxx", "sw", "row", "xi", "ex", "el", "ox", "t", "axis", "X", "ix", "wx", "v", "wd", "yx", "xx", "on"], "y": ["wy", "i", "ey", "ch", "py", "ye", "l", "ly", "yd", "yi", "vy", "ty", "z", "ies", "iy", "cy", "c", "asy", "er", "p", "uy", "sy", "height", "ym", "ish", "ry", "b", "yer", "xy", "my", "ay", "j", "yt", "ya", "gy", "ys", "yl", "axy", "ic", "oy", "t", "yy", "yr", "hy", "o", "Y", "sky", "v", "by", "yx", "ny"], "w": ["wl", "i", "d", "l", "ow", "nw", "z", "wi", "hw", "weight", "p", "wp", "m", "ww", "wr", "window", "W", "wa", "wt", "ew", "sw", "wn", "iw", "t", "fw", "rw", "wx", "v", "wh", "wb", "wd"], "h": ["ch", "l", "hd", "n", "th", "k", "ha", "hash", "him", "c", "q", "bh", "his", "hi", "H", "p", "s", "height", "m", "hr", "zh", "ish", "hs", "kh", "b", "ah", "count", "hl", "ih", "he", "sh", "hp", "t", "oh", "hei", "hm", "v", "wh", "ph", "hh", "ht"], "color": ["cycle", "role", "blue", "channel", "type", "kw", "or", "parent", "category", "image", "theme", "status", "style", "olor", "format", "value", "draw", "hash", "state", "col", "background", "c", "resource", "message", "country", "action", "cell", "colored", "light", "Color", "font", "size", "red", "comment", "attr", "COLOR", "actor", "white", "pixel", "fc", "colour", "function", "var", "term", "gb", "alpha"], "w_ptr": ["w_prop", "w_map", "wqptr", "wa_ptr", "w_best", "wmmbest", "wa_best", "w__best", " w__best", "wqper", " w_best", "w_rel", "wqbest", "wmmper", "wa_prop", " w__ptr", " w_per", "wmmrel", "wmmptr", " w__per", " w__rel", " w_rel", "w_per", "wa_map", "w__rel", "wqrel", "w__ptr", "w__per"], "h_ptr": ["h_addr", "h_____pad", "hw_addr", "hoxexpr", "hm_ptr", "hm_pad", "h_pad", "h_cur", "hw_ptr", "h_push", "hoxpad", "h_____ptr", "hw_rev", "hUaddr", "hw_cur", "h_____expr", "hUptr", "hoxpush", "h_____push", "h_rev", "hm_push", "h_expr", "hoxptr", "hm_expr", "hUcur", "hUrev"], "dx": ["wy", "fx", "dl", "d", "xp", "ax", "ady", "dt", "dp", "tx", "tex", "lat", "draw", "qt", "px", "iy", "addr", "did", "dra", "dr", "xs", "DX", "dim", "tp", "xy", " ax", "ctx", "dial", "xd", "index", "dd", "ay", "dj", "mx", "xi", "ex", "dq", "ox", "coord", "ds", "zi", "du", " xx", "ix", "wx", "eddy", "wd", "yx", "cd", "xx", "zx"], "dy": ["wy", "dn", "ey", "dl", "d", "py", "hh", "idy", "ii", "dm", "ady", "dt", "vy", "ty", "fy", "aily", "yi", "die", "di", "iy", "cy", "elly", "did", "hi", "ei", "uy", "sy", "dyl", "zy", "height", "ym", "zh", "addy", "ne", "ry", "dim", "yer", "xy", "delay", "my", "dial", "des", "dd", "dir", "ay", "dies", " Dy", "dj", "gy", "axy", "dq", "wed", "yl", "oy", "try", "phi", "ds", "tile", "yy", "ury", "phy", "eddy", "yx", "south", "ht", "ny"], "dw": ["dnw", "tdwh", "sdwd", "dwt", "ddw", "dew", "Dws", "dwidth", " dwt", "rdw", "ddwe", "rdwe", "ddms", " dwp", "ddwp", "ddl", " dwe", " dwidth", "adw", "sdy", "idwa", "indw", "sdw", "adh", "dnms", "tdwa", "sdwh", "dnl", "djwt", "indwidth", "dwa", "dws", "ddws", "tdwd", "Dw", "idw", "dms", "dl", "adwe", " dms", "sdW", "rdsw", "idwd", "rdwt", " dl", "dwe", "dW", "ddwidth", "Dl", "dnwp", "ddW", "tdw", "dsw", " dW", "sdl", "ddwt", "Dh", "dwp", "dwd", "adW", "dwh", "Dwe", "sdwa", "ddew", "DW", "ddh", "Dy", "indwt", "djwe", "djsw", "idwh", " dsw", "djw", " dws", " dew", "indew"], "dh": ["dn", "wy", "dl", "d", " Dh", "hd", "dm", "yi", "dt", "hhhh", "dp", "di", "olor", "him", "hz", "addr", "bh", "hw", "hi", "kl", "dyl", "ssl", "ptr", "zh", "idth", "dr", "vp", "health", "hs", "dim", "kh", "pd", "tp", "hor", "harm", "hl", "ih", "dial", "eth", "vt", "html", "sh", "hp", "dj", "ouch", "DH", "dq", "phi", "ds", "sth", "phy", "hm", "ph", "td", "cd", "hh", "ht"], "w_prev": ["w_pre", "w_iter", "h__rev", "w2next", "wp5ptr", "wd_pred", "wp_ptr", "w_rev", "sw_prev", "wJpred", "w___obj", "h__best", "w__inv", "w___orig", "fw___obj", "w2prev", "wd__next", "w2ptr", "w_attr", "w___prev", "kw_prev", "wd_prev", "w5ptr", "wp5iter", "w__prev", "w00prev", "kw_rev", "h_prev", "w00Prev", "wp_iter", "w__rev", "wd__prev", "w__next", "w_inv", "wJprev", "sw_best", "w2best", "sw_last", "w_last", "w5prev", "wd_attr", "wd_next", "w_Prev", "w2iter", "h_cmp", "w__ptr", "wp5best", "h_pre", "w_best", "wp_prev", "w_pred", "wJattr", "fw_obj", "wp_best", "w__cmp", "h__prev", "w_cmp", "h_rev", "w00attr", "h_best", "w00pred", "kw_last", "w5best", "fw___prev", "fw_prev", "wd_Prev", "wp5prev", "fw___orig", "sw_inv", "w5iter", "w_orig", "w__best", "w_next", "fw_orig", "h__cmp", "wd__best", "wd__ptr", "kw_best", "w_obj", "fw___pre", "w___pre", "wd_ptr", "wJPrev", "wd_best", "w__last", "fw_pre"]}}
{"project": "qemu", "commit_id": "43771539d4666cba16298fc6b0ea63867425277c", "target": 0, "func": "static RAMBlock *qemu_get_ram_block(ram_addr_t addr)\n\n{\n\n    RAMBlock *block;\n\n\n\n    /* The list is protected by the iothread lock here.  */\n\n    block = ram_list.mru_block;\n\n    if (block && addr - block->offset < block->max_length) {\n\n        goto found;\n\n    }\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        if (addr - block->offset < block->max_length) {\n\n            goto found;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Bad ram offset %\" PRIx64 \"\\n\", (uint64_t)addr);\n\n    abort();\n\n\n\nfound:\n\n    ram_list.mru_block = block;\n\n    return block;\n\n}\n", "idx": 12314, "substitutes": {"addr": ["ord", "ref", "prefix", "req", "address", "rs", "art", " addresses", "Address", "alloc", "tx", " ip", "node", "ress", "hash", "ip", "sha", "hw", "dh", " tid", "adr", " tx", "loc", "arr", "err", "start", "add", "ptr", "dr", "name", " r", "pos", "mem", " dst", "len", "ctx", "eth", "ack", "active", "to", "id", "size", "url", "kt", "act", "ad", "res", "range", "offset", "amp", "msg", "max", " fmt", "inter", " address", "mt", "nl", " mac", " x", "attr", "order", "arg", "net", "align", "ix", "link", "ace", "cmd", "arp", " err", "obj", " add"], "block": ["BL", "map", "image", "bl", "space", "check", "blocks", "instance", "unit", "record", "blocking", "snap", "Block", "base", "sync", "event", "bar", "join", "alloc", "word", "group", "hash", "number", "def", "set", "bus", "an", "zero", "name", "buffer", "commit", "loop", "sp", "line", "open", "broad", "file", "link", "part", "length", "type", "prefix", "condition", "x", "node", "byte", "batch", "empty", "key", "in", "field", "object", "op", "lock", "data", "mask", "ref", "address", "null", "point", "tx", "out", "local", "ip", "new", "p", "list", "raw", "bo", "b", "window", "chain", "box", "none", "load", "row", "cl", "self", "obj", "label"]}}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "static int usbnet_can_receive(VLANClientState *nc)\n\n{\n\n    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n\n\n    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)\n\n        return 1;\n\n\n\n    return !s->in_len;\n\n}\n", "idx": 12320, "substitutes": {"nc": ["oc", "psc", "n", "pc", "nz", "nd", "bc", "nw", "ck", "unc", "gn", "dc", "np", "c", "cb", "cn", "mc", "nm", "ne", "nt", "cc", "isc", "ng", "ctx", "nr", "gc", "cv", "cus", "rn", "nn", "nic", "NC", "ct", "anc", "nec", "nl", "ec", "cs", "uc", "NT", "ns"], "s": ["bs", "i", "h", "rs", "sol", "sb", "n", "sl", "z", "ses", "S", "os", "als", "sv", "has", "ps", "ss", "comm", "sys", "ess", "ls", "sports", "xs", "hs", "aws", "gs", "ats", "js", "iss", "ims", "sp", "j", "sq", "sw", "less", "ds", "states", "cs", "ts", "is", "stats", "sis", "qs", "ns", "sts"]}}
{"project": "qemu", "commit_id": "333d50fe3d9a1ff0a6a1a44ef42a0d3a2a7f2abe", "target": 0, "func": "static int scsi_disk_emulate_mode_sense(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    int page, dbd, buflen, page_control;\n\n    uint8_t *p;\n\n    uint8_t dev_specific_param;\n\n\n\n    dbd = req->cmd.buf[1]  & 0x8;\n\n    page = req->cmd.buf[2] & 0x3f;\n\n    page_control = (req->cmd.buf[2] & 0xc0) >> 6;\n\n    DPRINTF(\"Mode Sense(%d) (page %d, len %d, page_control %d)\\n\",\n\n        (req->cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, len, page_control);\n\n    memset(outbuf, 0, req->cmd.xfer);\n\n    p = outbuf;\n\n\n\n    if (bdrv_is_read_only(s->bs)) {\n\n        dev_specific_param = 0x80; /* Readonly.  */\n\n    } else {\n\n        dev_specific_param = 0x00;\n\n    }\n\n\n\n    if (req->cmd.buf[0] == MODE_SENSE) {\n\n        p[1] = 0; /* Default media type.  */\n\n        p[2] = dev_specific_param;\n\n        p[3] = 0; /* Block descriptor length.  */\n\n        p += 4;\n\n    } else { /* MODE_SENSE_10 */\n\n        p[2] = 0; /* Default media type.  */\n\n        p[3] = dev_specific_param;\n\n        p[6] = p[7] = 0; /* Block descriptor length.  */\n\n        p += 8;\n\n    }\n\n\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n\n    if ((~dbd) & nb_sectors) {\n\n        if (req->cmd.buf[0] == MODE_SENSE) {\n\n            outbuf[3] = 8; /* Block descriptor length  */\n\n        } else { /* MODE_SENSE_10 */\n\n            outbuf[7] = 8; /* Block descriptor length  */\n\n        }\n\n        nb_sectors /= s->cluster_size;\n\n        if (nb_sectors > 0xffffff)\n\n            nb_sectors = 0;\n\n        p[0] = 0; /* media density code */\n\n        p[1] = (nb_sectors >> 16) & 0xff;\n\n        p[2] = (nb_sectors >> 8) & 0xff;\n\n        p[3] = nb_sectors & 0xff;\n\n        p[4] = 0; /* reserved */\n\n        p[5] = 0; /* bytes 5-7 are the sector size in bytes */\n\n        p[6] = s->cluster_size * 2;\n\n        p[7] = 0;\n\n        p += 8;\n\n    }\n\n\n\n    if (page_control == 3) { /* Saved Values */\n\n        return -1; /* ILLEGAL_REQUEST */\n\n    }\n\n\n\n    switch (page) {\n\n    case 0x04:\n\n    case 0x05:\n\n    case 0x08:\n\n    case 0x2a:\n\n        p += mode_sense_page(req, page, p, page_control);\n\n        break;\n\n    case 0x3f:\n\n        p += mode_sense_page(req, 0x08, p, page_control);\n\n        p += mode_sense_page(req, 0x2a, p, page_control);\n\n        break;\n\n    default:\n\n        return -1; /* ILLEGAL_REQUEST */\n\n    }\n\n\n\n    buflen = p - outbuf;\n\n    /*\n\n     * The mode data length field specifies the length in bytes of the\n\n     * following data that is available to be transferred. The mode data\n\n     * length does not include itself.\n\n     */\n\n    if (req->cmd.buf[0] == MODE_SENSE) {\n\n        outbuf[0] = buflen - 1;\n\n    } else { /* MODE_SENSE_10 */\n\n        outbuf[0] = ((buflen - 2) >> 8) & 0xff;\n\n        outbuf[1] = (buflen - 2) & 0xff;\n\n    }\n\n    if (buflen > req->cmd.xfer)\n\n        buflen = req->cmd.xfer;\n\n    return buflen;\n\n}\n", "idx": 12326, "substitutes": {"req": ["pkg", "requ", "ind", "usr", "ref", "jp", "rs", "prefix", "esp", "tx", "sim", "gz", "compl", "reg", "http", "src", "Requ", "q", "rpm", "comm", "conf", "Request", "org", "r", "err", "urg", "ux", "pro", "desc", "rx", "nil", "push", "good", "qq", "eq", "md", "hawk", "dev", "rr", "rez", "rh", "ctx", "request", "spec", "res", "j", "sq", "uj", "range", "msg", "fr", "seq", "dq", "proc", "attr", "quest", "expr", "crit", "gr", "resp", "wx", "cmd", "inv", "wcs", "rec", "qs", "aux", "qt"], "outbuf": ["outputbuf", "inbuffer", " outimg", "outimg", " outbuffer", "inBuff", "inbuff", "outputbuffer", "outputbag", "inbuf", " outBuff", " outqueue", " outbuff", "outqueue", "Outbuffer", "Outbuff", "outbuffer", "outputBuff", "Outbag", "outbag", "outputqueue", "Outbuf", "outputbuff", "inbag", "outbuff", "inqueue", "outputimg", "inimg", "outBuff"], "s": ["bs", "requ", "fs", "bl", "ps", "r", "js", "g", "sd", "se", "y", "_", "h", "d", "sb", "er", "def", "m", "sp", "j", "sr", "t", "is", "query", "ns", "rs", "S", "session", "c", "q", "sys", "ls", "hs", "sq", "ts", "a", "qs", "sts", "ss", "i", "n", "ctl", "conf", "sam", "gs", "b", "spec", "cont", "ds", "v", "stats"], "nb_sectors": ["nb_seectors", "nb_geors", "nb_vectors", "nb_vector", "nb_shels", "nb_tegments", "nb_curctors", "nb_temvers", "nb_vevers", "nb_vexes", "nb_vellers", "nb_perseors", "nb_comicas", "nb_beters", "nb_vecers", "nb_SEvers", "nb_velements", "nb_temcers", "nb_gecs", "nb_persectors", "nb_spegments", "nb_bevers", "nb_temors", "nb_veters", "nb_SEllers", "nb_neors", "nb_persevers", "nb_eleicas", "nb_secers", "nb_teors", "nb_sector", "nb_SEctors", "nb_vecs", "nb_seels", "nb_curlements", "nb_nevers", "nb_selements", "nb_eleors", "nb_segments", "nb_gectors", "nb_veors", "nb_spevers", "nb_temctors", "nb_specers", "nb_specs", "nb_SEors", "nb_elexes", "nb_sexes", "nb_shors", "nb_secs", "nb_comxes", "nb_shlements", "nb_speors", "nb_shctors", "nb_comors", "nb_comctors", "nb_seters", "nb_tectors", "nb_seors", "nb_vegments", "nb_bectors", "nb_seeors", "nb_nellers", "nb_curors", "nb_veicas", "nb_veels", "nb_sellers", "nb_electors", "nb_curels", "nb_gector", "nb_becs", "nb_tevers", "nb_spectors", "nb_begments", "nb_seecs", "nb_severs", "nb_beors", "nb_perseters", "nb_seicas", "nb_seector", "nb_nectors"], "page": ["i", "device", " len", "ref", "channel", "power", "lp", "address", "server", "pages", "node", "next", "frame", "number", "pid", "col", "sel", "pen", "pl", "age", "position", "key", "port", "pos", "window", "db", "field", "count", "block", "len", "sp", "index", "loop", "pg", "pointer", "size", "me", "limit", "line", "offset", "num", "row", "seq", "proc", "order", "net", "Page", "pp", "pi", "base", "table", "length"], "dbd": ["bbid", "bdd", " dbp", "dpd", "bbend", "dbdim", "bdds", " dbbd", "bdend", "bdp", "dbp", "DBdo", "ddd", "bdid", "dpbd", "DBn", " dbds", "dbbd", " dbdo", " dbn", "ddds", "dbend", "bdbd", " dbid", "dbid", "bddim", " dbdim", "ddbd", "dddim", " dbend", "dbn", "bbd", "dpdo", "dbds", "dbdo", "DBbd", "dpn", "DBd", "bbp"], "buflen": [" bullens", "buglens", "buglen", "bullun", " buflength", " bullength", "buglength", "buflun", "buplen", " bullun", "buplun", " buflun", "buglun", "buflens", "bullens", "bullength", "buplength", "bullen", " buflens", "buflength", " bullen", "buplens"], "page_control": ["pageflightcontrol", " page_ctrl", "page_controller", "page_length", " page_controller", " page_critical", "pageflightcritical", "pageflightctrl", " page_length", "pageflightlength", "page_ctrl", "page_controlled", " page_controlled", "page_critical"], "p": ["pkg", "i", "h", "d", "cache", "jp", "fp", "rep", "lp", "l", "power", "n", "pc", "pe", "app", "status", "progress", "dp", "point", "x", "out", "pa", "ip", "np", "c", "q", "cp", "ps", "pid", "ap", "u", "pre", "r", "wp", "m", "pb", "vp", "port", "b", "att", "e", "tp", "mp", "sp", "op", "P", "g", "it", "at", "j", "after", "php", "t", "pt", "pr", "part", "o", "pad", "pp", "pi", "v", "f", "perm", "a", "ping", "w", "post", "up", "pm"], "dev_specific_param": ["dev_specific_num", "dev_general_num", "dev_specific_config", "dev_general_index", "dev_specificitypar", "dev_general_info", "dev_Specific_param", "dev_specific_conf", "dev_general_const", "dev_general_config", "dev_dependent_conf", "dev_dependent_tag", "dev_general_par", "dev_specific_par", "dev_specific_tag", "dev_Specific_par", "dev_specificityp", "dev_general_param", "dev_dependent_param", "dev_specificityparam", "dev_specificitynum", "dev_specificityconst", "dev_Specific_p", "dev_specific_p", "dev_dependent_comment", "dev_specific_comment", "dev_specific_info", "dev_specific_index", "dev_specific_const"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "void tcg_add_target_add_op_defs(const TCGTargetOpDef *tdefs)\n\n{\n\n    TCGOpcode op;\n\n    TCGOpDef *def;\n\n    const char *ct_str;\n\n    int i, nb_args;\n\n\n\n    for(;;) {\n\n        if (tdefs->op == (TCGOpcode)-1)\n\n            break;\n\n        op = tdefs->op;\n\n        assert((unsigned)op < NB_OPS);\n\n        def = &tcg_op_defs[op];\n\n#if defined(CONFIG_DEBUG_TCG)\n\n        /* Duplicate entry in op definitions? */\n\n        assert(!def->used);\n\n        def->used = 1;\n\n#endif\n\n        nb_args = def->nb_iargs + def->nb_oargs;\n\n        for(i = 0; i < nb_args; i++) {\n\n            ct_str = tdefs->args_ct_str[i];\n\n            /* Incomplete TCGTargetOpDef entry? */\n\n            assert(ct_str != NULL);\n\n            tcg_regset_clear(def->args_ct[i].u.regs);\n\n            def->args_ct[i].ct = 0;\n\n            if (ct_str[0] >= '0' && ct_str[0] <= '9') {\n\n                int oarg;\n\n                oarg = ct_str[0] - '0';\n\n                assert(oarg < def->nb_oargs);\n\n                assert(def->args_ct[oarg].ct & TCG_CT_REG);\n\n                /* TCG_CT_ALIAS is for the output arguments. The input\n\n                   argument is tagged with TCG_CT_IALIAS. */\n\n                def->args_ct[i] = def->args_ct[oarg];\n\n                def->args_ct[oarg].ct = TCG_CT_ALIAS;\n\n                def->args_ct[oarg].alias_index = i;\n\n                def->args_ct[i].ct |= TCG_CT_IALIAS;\n\n                def->args_ct[i].alias_index = oarg;\n\n            } else {\n\n                for(;;) {\n\n                    if (*ct_str == '\\0')\n\n                        break;\n\n                    switch(*ct_str) {\n\n                    case 'i':\n\n                        def->args_ct[i].ct |= TCG_CT_CONST;\n\n                        ct_str++;\n\n                        break;\n\n                    default:\n\n                        if (target_parse_constraint(&def->args_ct[i], &ct_str) < 0) {\n\n                            fprintf(stderr, \"Invalid constraint '%s' for arg %d of operation '%s'\\n\",\n\n                                    ct_str, i, def->name);\n\n                            exit(1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        /* TCGTargetOpDef entry with too much information? */\n\n        assert(i == TCG_MAX_OP_ARGS || tdefs->args_ct_str[i] == NULL);\n\n\n\n        /* sort the constraints (XXX: this is just an heuristic) */\n\n        sort_constraints(def, 0, def->nb_oargs);\n\n        sort_constraints(def, def->nb_oargs, def->nb_iargs);\n\n\n\n#if 0\n\n        {\n\n            int i;\n\n\n\n            printf(\"%s: sorted=\", def->name);\n\n            for(i = 0; i < def->nb_oargs + def->nb_iargs; i++)\n\n                printf(\" %d\", def->sorted_args[i]);\n\n            printf(\"\\n\");\n\n        }\n\n#endif\n\n        tdefs++;\n\n    }\n\n\n\n#if defined(CONFIG_DEBUG_TCG)\n\n    i = 0;\n\n    for (op = 0; op < tcg_op_defs_max; op++) {\n\n        const TCGOpDef *def = &tcg_op_defs[op];\n\n        if (def->flags & TCG_OPF_NOT_PRESENT) {\n\n            /* Wrong entry in op definitions? */\n\n            if (def->used) {\n\n                fprintf(stderr, \"Invalid op definition for %s\\n\", def->name);\n\n                i = 1;\n\n            }\n\n        } else {\n\n            /* Missing entry in op definitions? */\n\n            if (!def->used) {\n\n                fprintf(stderr, \"Missing op definition for %s\\n\", def->name);\n\n                i = 1;\n\n            }\n\n        }\n\n    }\n\n    if (i == 1) {\n\n        tcg_abort();\n\n    }\n\n#endif\n\n}\n", "idx": 12329, "substitutes": {"tdefs": ["tdevls", "tsdefares", "tdescinitions", "tdefaultins", "tdefinedins", "vtdefacs", "tdefls", "mtdefaultins", "wdeclds", "tservds", "tdeclls", "tdevs", "tdeveds", "tdefeds", "tdefaultls", "tdefcs", "tdecls", "tsdefeds", "wdefs", "tsdfeds", "tdescacs", "mtdefls", "tsdfs", "tdefds", "tsdefs", "tserveds", "tsdfares", "wdeclls", "tdefineds", "tconfacs", "mtdefaultls", "tconfs", "tconfinitions", "wdefds", "tdevds", "wdecls", "vtconfcs", "vtconfacs", "tdefinitions", "vtdefs", "tdefins", "vtconfs", "tdfds", "tdefacs", "tdfs", "tdefares", "tdefinedls", "tconfcs", "wdefls", "tdesacs", "tdevares", "vtdefinitions", "tdess", "tdescs", "tdefaults", "mtdefins", "vtdefcs", "tservs", "mtdefs", "tdeclins", "tsdfds", "tdfeds", "tdfares", "tdefinedds", "tdesinitions", "vtconfinitions", "tdeclds", "tservares", "tsdefds", "mtdefaults", "tdesccs"], "op": [" pat", "oe", "cmp", "hop", "cop", "cp", " operator", "ap", "pos", "oop", " operation", "it", "sc", "ob", "operation", "info", "ops", " ip", "init", " cop", " dep", "operator", "tag", "code", "omp", "ot", "sp", "cod", " comp", "num", " clip", " chop", "opp", " fe", "cmd", "oc", "jp", "type", "opt", "pop", "x", "top", "ext", "loc", "pl", "pre", "mp", "field", "gen", "bit", "OP", "arg", " expr", "o", "pp", " hop", "co", " pos", " Op", "comp", "ip", " cp", "p", "oper", "ok", "id", "Op", "um", " co", " prev", " pop", "obj", "iat"], "def": ["rel", "Def", "dl", "d", "info", "ref", "diff", "prop", "req", "eval", "defined", "and", "hd", "die", "tx", "task", "feed", "init", "buf", "conf", "elf", "del", "df", "vec", "pass", "ma", "list", "DE", "pro", "desc", "raw", "push", "dev", "db", "nt", "Decl", "block", "no", "decl", "spec", "de", "id", "dep", "feat", "act", "range", "data", "define", "el", "det", "ef", "func", "arg", "ds", "du", "vol", "lib", "cond", "DEF", "val", "cmd", "lit", "f", "obj", "form", "definition", "da", "call"], "ct_str": ["capt_str", "ctolystr", "ct_enc", "ct2buf", "ctl_cur", "sectDef", "ct64string", "sectdef", "het64string", "het_part", "artolycoll", "cent64stri", "ct8string", "ct7enc", "het7enc", "ctvalstring", "ct7n", "capt_Str", "capt7Str", "CT_str", "ct_tr", "het64stream", "ct64STR", "art_url", "ct_Str", "CT_buf", "actDef", "captdef", "ct_cur", "ctvalstr", "ct64str", "ct7arr", "ct64stri", "ct_st", "ct_buf", "ctpycur", "art_coll", "cent_stri", "ct7part", "het7part", "het_str", "apt_string", "ct_err", "ctlpyst", "ct___conv", "art_str", "ctdef", "ct_url", "het_enc", "ct2arr", "ct_part", "ct8syn", "cent64syn", "ct___str", "het_n", "ct_STR", "ctpystring", "ctolyurl", "ct_var", "cent_syn", "ct8str", "cent64str", "het_seq", "ct7buf", "ct2str", "het64STR", "capt7buf", "ct_arr", "ct7coll", "ct3str", "het_string", "art_err", "CT_char", "ctl_str", "het7str", "cent_str", "ct3conv", "ct8stri", "het_var", "captDef", "ct_syn", "cent64string", "ct_string", "het_STR", "ct_coll", "ctmatn", "ctolycoll", "artolystr", "ct_char", "ctpyst", "ctlpystring", "CT_string", "ct_br", "CT_st", "ct_conv", "ct_exp", "het64str", "ct___string", "ctmatpart", "ctpystr", "apt_exp", "het7n", "ct3string", "capt7arr", "ct7url", "ctl_string", "apt_tr", "artolyurl", "ctl_st", "ct64syn", "ct_n", "ctlpycur", "ct_stri", "ct_stream", "ct7str", "ct_seq", "ctolyerr", "ctlpystr", "ct3buf", "ctvalcur", "CT_conv", "ctmatstr", "ctvalst", "apt_str", "ctDef", "capt_buf", "actdef", "ct___buf", "het_stream", "capt_arr", "ct64stream", "ctmatenc", "ct2Str", "cent_string", "ct7err", "ct7Str", "CT_br", "artolyerr", "capt7str"], "i": ["qi", "h", "ind", "info", "ai", "ii", "ji", "n", "gi", "io", "status", "z", "di", "point", "x", "sim", "go", "ij", "ip", "cli", "ti", "li", "hi", "\u0438", "I", "ei", "p", "this", "list", "si", "batch", "m", "ri", "s", "ir", "im", "e", "multi", "in", "ims", "fi", "index", "iu", "to", "id", " ii", "it", "g", "j", "me", "ci", "xi", "ic", "ki", "ik", "t", "phi", "zi", "ix", "mi", "is", "o", "pi", "y", "v", "bi", "ini", "ui", "uri", " ti"], "nb_args": ["no_args", "nb2args", "NB2args", "nb67args", "NB2gs", "nbJobs", "nb2files", "NB_args", "nb67gs", "NB2arg", "NB2files", "NB_files", "nb2items", "nbJargs", "no_mus", "nbJmus", "nbJitems", "nb_mus", "NB_items", "nb67items", "nb_gs", "no_items", "no_obs", "nb_files", "nb___args", "nb_obs", "nb67arg", "NB_gs", "nb2gs", "NB_arg", "nb___items", "nb_items", "nb___mus", "nb_arg", "nb___obs", "nb2arg"], "oarg": ["oaag", "oiarr", "oArg", "boarg", " oArg", "oarow", "oaitem", "osarm", "aoinc", "oarr", "oakey", "oargument", "oag", "oass", "oedge", "oarc", "oiitem", "offref", "oargs", "osref", "oivar", "osargument", "osarg", "autoarg", "aoarg", "oiarg", "ooass", "osagg", "boargument", "Oarg", "autoargument", "oainc", " oarc", "iag", "oskey", "aoref", "oinc", "autoass", "ooargument", "offarg", "osedge", "osarr", "iarm", " oarr", "osArg", "boref", " oargs", "iarg", "poarg", "oitem", "oaarr", "osarn", "oaarg", "autoarc", "noarg", "offargument", " oass", "oaedge", "icoargument", "iArg", "osag", "noargument", "pokey", " orow", "icoarr", "noarn", "oaargument", "aoitem", "oavar", "oarm", "poargument", "ooarg", "okey", "Oargs", "offagg", "oaargs", "noarr", " oitem", "oaref", " oag", "oarn", " ovar", "boagg", "osinc", "ovar", "oref", "orow", "oagg", "icoarg", "poedge", " oarm", "Orow", "Oag", " oargument", "ositem", "icoarn", "ooarc"]}}
{"project": "qemu", "commit_id": "06ac27f683c52890a6d174adba8c92354fa1eceb", "target": 1, "func": "void AUD_vlog (const char *cap, const char *fmt, va_list ap)\n\n{\n\n    if (conf.log_to_monitor) {\n\n        if (cap) {\n\n            monitor_printf(default_mon, \"%s: \", cap);\n\n        }\n\n\n\n        monitor_vprintf(default_mon, fmt, ap);\n\n    }\n\n    else {\n\n        if (cap) {\n\n            fprintf (stderr, \"%s: \", cap);\n\n        }\n\n\n\n        vfprintf (stderr, fmt, ap);\n\n    }\n\n}\n", "idx": 12347, "substitutes": {"cap": ["shape", "ch", "rep", "card", "map", "bc", "ck", "fac", "spe", "sim", "cas", "ctrl", "lat", "cmp", "cat", "clip", "c", "cp", "cu", "cn", "comm", "pl", "ape", "sam", "cell", "CAP", "san", "mac", "tc", "mp", "tap", "com", "spec", "Cap", "car", "ce", "cont", "caps", "cf", "cod", "feat", "cl", "ct", "broad", "capt", "attr", "test", "lip", "ca", "snap", "acc", "sc", "pan", "ac", "var", "can", "co", "pac"], "fmt": ["vtm", " Firm", "pprintf", "Firm", "pmt", "vMT", "ptm", "fformat", "Fprintf", "Fmt", "ftm", " Fmt", "firm", "Ftm", " Ftm", " Fformat", " ftm", "fMT", "vmt", "vformat", "Fformat", " firm", " fMT", "pMT", " fformat"], "ap": [" op", "and", " map", "ash", "apt", "map", "app", "hap", "pa", "ip", "pool", " p", "ar", " cp", "ps", " sap", "p", "ape", "list", "AP", " pc", " format", "att", "array", "tap", "ipp", "al", "sp", "op", "aps", " db", "gap", " ab", "rap", "capt", "ep", "lip", "bp", "snap", "api", " app", "ac", " tap", " sp", "arp", "ab", " heap", "pac"]}}
{"project": "FFmpeg", "commit_id": "59c6178a54c414fd19e064f0077d00b82a1eb812", "target": 0, "func": "static int ogg_build_flac_headers(const uint8_t *extradata, int extradata_size,\n\n                                  OGGStreamContext *oggstream, int bitexact)\n\n{\n\n    const char *vendor = bitexact ? \"ffmpeg\" : LIBAVFORMAT_IDENT;\n\n    uint8_t *p;\n\n    if (extradata_size != 34)\n\n        return -1;\n\n    oggstream->header_len[0] = 51;\n\n    oggstream->header[0] = av_mallocz(51); // per ogg flac specs\n\n    p = oggstream->header[0];\n\n    bytestream_put_byte(&p, 0x7F);\n\n    bytestream_put_buffer(&p, \"FLAC\", 4);\n\n    bytestream_put_byte(&p, 1); // major version\n\n    bytestream_put_byte(&p, 0); // minor version\n\n    bytestream_put_be16(&p, 1); // headers packets without this one\n\n    bytestream_put_buffer(&p, \"fLaC\", 4);\n\n    bytestream_put_byte(&p, 0x00); // streaminfo\n\n    bytestream_put_be24(&p, 34);\n\n    bytestream_put_buffer(&p, extradata, 34);\n\n    oggstream->header_len[1] = 1+3+4+strlen(vendor)+4;\n\n    oggstream->header[1] = av_mallocz(oggstream->header_len[1]);\n\n    p = oggstream->header[1];\n\n    bytestream_put_byte(&p, 0x84); // last metadata block and vorbis comment\n\n    bytestream_put_be24(&p, oggstream->header_len[1] - 4);\n\n    bytestream_put_le32(&p, strlen(vendor));\n\n    bytestream_put_buffer(&p, vendor, strlen(vendor));\n\n    bytestream_put_le32(&p, 0); // user comment list length\n\n    return 0;\n\n}\n", "idx": 12353, "substitutes": {"extradata": ["extravatum", "xtracATA", "extradatum", "xtradata", "extracATA", "extredatum", "extracada", "integradatum", "extrarATA", "extravata", "extredata", "extredATA", "extrandATA", "xtracova", "integredata", "extraratum", "xtradATA", "extrandata", "extracova", "xtracata", "extracata", "xtracatum", "extrarata", "extrandatum", "extradova", "xtradova", "extrandada", "extredada", "integradada", "extrarova", "extracatum", "extravATA", "extradATA", "xtradatum", "integradATA", "integredada", "extradada", "extravova", "integredatum", "integradata", "integredATA"], "extradata_size": ["extraddata_SIZE", "extraddata_Size", "extradata_length", "extraddata_size", "extradata_SIZE", "extraddata_length", "extradata_Size"], "oggstream": ["qusream", "oglog", "qusStream", "oggdriver", "bbdriver", "ikStream", "awkstream", "ggconsole", "angstream", "ggstream", "oggream", "agglog", "angsystem", "oggsocket", "ikcollection", "oggstyle", "obbstream", "ogstream", "oggload", "ikstream", "owstream", "voicestyle", "orbStream", "gglog", "ggStream", "oggStream", "qusstream", "orbstream", "ggdraw", "awklog", "ggload", "ggcontext", "bblog", "voiceconsole", "ggwrapper", "obbdraw", "anglog", "angdraw", "bbcontext", "awkcontext", "aggproc", "ogglog", "orbream", "ogsocket", "awkload", "voicestream", "ggdriver", "oggconsole", "owwrapper", "qusdraw", "obbsystem", "ikream", "obbcollection", "ogconsole", "obbcontext", "obbwrapper", "oggdraw", "oggwrapper", "ogcontext", "orbdraw", "obbdriver", "ogstyle", "owcontext", "ogload", "livstream", "livconsole", "voicesocket", "oggcollection", "ggcollection", "aggstream", "obbStream", "livsocket", "owream", "obblog", "oggsystem", "ggproc", "ggsystem", "obbproc", "bbstream", "ggream", "oggcontext", "bbStream", "obbream", "bbconsole", "oggproc", "livstyle", "aggsystem"], "bitexact": ["bitenexACT", "biterexacts", " bitextract", "bitenexacts", " bitexract", "ibexract", "biterexract", "bitextACT", "ibexact", "ibeexract", "bitenexract", "biteexract", " bitextacts", "biteexACT", "bitextacts", "biterexact", " bitextact", "bitenexact", "ibexACT", "bitexacts", "ibexacts", " bitexacts", " bitexACT", "ibeexacts", "ibeexACT", "bitexACT", "bitextract", "ibeexact", " bitextACT", "bitexract", "biterexACT", "biteexact", "biteexacts", "bitextact"], "vendor": ["envender", "variendor", "invendor", "vian", "verendor", "ivender", "avocolate", "ivian", "hacio", "avian", "variavor", "vender", "avendor", "veristor", " virus", "ivistor", "vistor", "ivirus", "invender", " vender", " vavor", "ivendor", "avender", "avirus", "vavor", "ivocolate", "variacio", "vocolate", " vocolate", "avoter", "virus", "invoter", "verirus", "havor", "avistor", "vacio", "envendor", "variirus", "verender", "invistor", "hendor", "voter", "envirus", "ivoter", " vian", " vacio", "envistor", "hirus"], "p": ["pkg", "h", "i", "d", "jp", "l", "rep", "lp", "fp", "prop", "n", "pc", "pe", "art", "pers", "progress", "dp", "point", "br", "x", "pa", "ip", "np", "c", "cp", "q", "ps", "new", "ap", "pid", "er", "pre", "wp", "r", "m", "pb", "gp", "vp", "port", "pn", "b", "tp", "parse", "mp", "sp", "P", "g", "it", "at", "j", "php", "proc", "t", "self", "bp", "pr", "pt", "part", "o", "pp", "pi", "v", "y", "f", "ping", "w", "post", "up", "params"]}}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void put_subframe(DCAEncContext *c, int subframe)\n\n{\n\n    int i, band, ss, ch;\n\n\n\n    /* Subsubframes count */\n\n    put_bits(&c->pb, 2, SUBSUBFRAMES -1);\n\n\n\n    /* Partial subsubframe sample count: dummy */\n\n    put_bits(&c->pb, 3, 0);\n\n\n\n    /* Prediction mode: no ADPCM, in each channel and subband */\n\n    for (ch = 0; ch < c->fullband_channels; ch++)\n\n        for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n            put_bits(&c->pb, 1, 0);\n\n\n\n    /* Prediction VQ address: not transmitted */\n\n    /* Bit allocation index */\n\n    for (ch = 0; ch < c->fullband_channels; ch++)\n\n        for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n            put_bits(&c->pb, 5, c->abits[band][ch]);\n\n\n\n    if (SUBSUBFRAMES > 1) {\n\n        /* Transition mode: none for each channel and subband */\n\n        for (ch = 0; ch < c->fullband_channels; ch++)\n\n            for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n                put_bits(&c->pb, 1, 0); /* codebook A4 */\n\n    }\n\n\n\n    /* Scale factors */\n\n    for (ch = 0; ch < c->fullband_channels; ch++)\n\n        for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n            put_bits(&c->pb, 7, c->scale_factor[band][ch]);\n\n\n\n    /* Joint subband scale factor codebook select: not transmitted */\n\n    /* Scale factors for joint subband coding: not transmitted */\n\n    /* Stereo down-mix coefficients: not transmitted */\n\n    /* Dynamic range coefficient: not transmitted */\n\n    /* Stde information CRC check word: not transmitted */\n\n    /* VQ encoded high frequency subbands: not transmitted */\n\n\n\n    /* LFE data: 8 samples and scalefactor */\n\n    if (c->lfe_channel) {\n\n        for (i = 0; i < DCA_LFE_SAMPLES; i++)\n\n            put_bits(&c->pb, 8, quantize_value(c->downsampled_lfe[i], c->lfe_quant) & 0xff);\n\n        put_bits(&c->pb, 8, c->lfe_scale_factor);\n\n    }\n\n\n\n    /* Audio data (subsubframes) */\n\n    for (ss = 0; ss < SUBSUBFRAMES ; ss++)\n\n        for (ch = 0; ch < c->fullband_channels; ch++)\n\n            for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n                    put_subframe_samples(c, ss, band, ch);\n\n\n\n    /* DSYNC */\n\n    put_bits(&c->pb, 16, 0xffff);\n\n}\n", "idx": 12357, "substitutes": {"c": ["abc", "oc", "cal", "vc", "d", "cache", "con", "comp", "pc", "bc", "content", "lc", "conv", "dc", "etc", "cur", "cm", "xc", "cp", "cu", "cb", "conf", "cn", "comm", "p", "mc", "this", "err", "cam", "C", "tc", "e", "chain", "cc", "rc", "com", "ctx", "gc", "cv", "ce", "cont", "cod", "cf", "coll", "ci", "cl", "ct", "enc", "anc", "ic", "ec", "t", "self", "nc", "cs", "fc", "ca", "config", "sc", "ac", "cr", "v", "f", "rec", "cd", "call", "co"], "subframe": ["SubFrame", "Subpixel", " subpixel", "Subframe", "subframes", "subFrame", " subframes", "firstframe", "firstpixel", "firstFrame", "subpixel", "Subframes", "firstframes", " subFrame"], "i": ["qi", "iq", "ind", "ai", "ii", "n", "gi", "di", "x", "cli", "ij", "ip", "u", "ti", "li", "hi", "\u0438", "I", "p", " j", "ei", "si", "m", "oi", "ri", "ish", "b", "e", "multi", "chain", "in", "ami", "iu", "ni", " ii", "it", "j", "ci", "xi", "ic", "ki", "phi", "zi", "ix", "mi", "is", "o", "pi", "v", "y", "ui", "ini", "io", "PI"], "band": ["bind", "low", "art", "iff", "sch", "cm", "bd", "ann", "display", "den", "mm", "chrom", "pair", "d", "and", "power", "prop", "bar", "dom", "nd", "br", "word", "group", "slot", "boot", "bridge", "filter", "tag", "bus", "through", "bright", "beam", "sp", "kt", "line", "j", "disk", "ud", "broad", "net", " Band", "part", "link", "cmd", "by", "f", "command", "lag", "length", "chan", "ind", "channel", "type", "ble", "uch", "di", "x", "st", "Band", "batch", "key", "field", "light", "bolt", "block", "no", "mode", "bit", "range", "stage", "binary", "bed", "work", "pp", "be", "io", "point", "way", "lay", "bound", "bo", "port", "b", "chain", "db", "slice", "ng", "gain", "path", "dd", "mid", "back", "rad", "bin", "bart", "bat", "plot", "cd", "brand"], "ss": ["bs", "mys", "sn", "rs", "SS", "serv", "nd", "sch", "tx", "ress", "sv", "st", "ps", "s", "sys", "ess", "si", "socket", "us", "ser", "ms", "iss", "sat", "rss", "ng", "sp", "dd", "sd", "sw", "sq", "ys", "css", "mm", "ness", "ds", "pse", "tt", "se", "sex", "cs", "ts", "sc", "stats", "oss", "ass", "hess", "ns"], "ch": ["cor", "atch", "sch", "history", "cm", "cp", "cb", "ach", "Ch", "et", "att", "hl", "ann", "bal", "sh", "mot", "ci", "sc", "qu", "itch", "cr", "y", "chrom", "ht", "rem", "h", "vc", "ck", "br", "client", "through", "zh", "height", "any", "hr", "cgi", "mk", "kh", "chron", "ot", "j", "conn", "CH", "command", "or", "chan", "ind", "channel", "ble", "uch", "che", "q", "not", "err", "batch", "cc", "count", "arch", "chn", "tch", "bit", "strong", "ka", "ct", "cht", "sky", "be", "high", "ph", "can", "chip", "th", "cz", "ich", "col", "ver", "gh", "chain", "yet", "cho", "watch", "cl", "ech", "el", "ctr", "och", "bat", "wh", "cd"]}}
{"project": "FFmpeg", "commit_id": "11b47038135442ec546dc348f2411e52e47549b8", "target": 0, "func": "static void decode_gray_bitstream(HYuvContext *s, int count)\n\n{\n\n    int i;\n\n\n\n    count/=2;\n\n\n\n    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {\n\n        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    } else {\n\n        for(i=0; i<count; i++){\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    }\n\n}\n", "idx": 12362, "substitutes": {"s": ["bs", "h", "fs", "aunts", "rs", "changes", "sb", "n", "ses", "S", "os", "session", "als", "c", "sv", "comm", "p", "sys", "r", "ess", "sam", "ls", "vs", "erences", "hs", "aws", "ms", "gs", "b", "e", "ats", "js", "events", "its", "as", "ims", "sts", "w", "bis", "g", "sq", "less", "t", "ds", "times", "cs", "ts", "comments", "is", "a", "v", "stats", "ins", "qs", "parts", "ns", "ss"], "count": ["h", "ount", "ch", "cache", "sum", "ind", "type", "n", "th", "page", "Count", "z", "counter", "number", "result", "c", "conf", "check", "list", "batch", "cast", "empty", "bound", "any", "now", "b", "code", "common", "cc", "nt", "len", "total", "buffer", "index", "size", "limit", "range", "num", "amount", "max", "ct", "scroll", "ctr", "nb", "t", "found", "more", "body", "mount", "all", "length", "hold", "current"], "i": ["status", "ski", "cli", "this", "oi", "my", " m", " ii", "it", "ci", "ki", "zi", "mi", "y", "uri", "ii", "ji", "series", "sql", "ij", "init", "hi", "client", " pi", "m", "ri", "multi", "to", "ni", "at", "j", "xi", "t", "ix", "print", "ui", "ini", "docker", "qi", "ind", "l", "ai", "page", "di", "x", "c", " bi", "ti", "li", "\u0438", "I", "si", "batch", "uni", "key", "im", "in", "ims", "index", "token", "phi", "pi", "bi", "iq", "n", "gi", "point", "sim", "ip", "ei", "p", " j", "e", "chain", "iter", "ami", " index", "iu", "um", "me", "php", "ic", "v", " ti"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int start_auth_vencrypt_subauth(VncState *vs)\n\n{\n\n    switch (vs->vd->subauth) {\n\n    case VNC_AUTH_VENCRYPT_TLSNONE:\n\n    case VNC_AUTH_VENCRYPT_X509NONE:\n\n       VNC_DEBUG(\"Accept TLS auth none\\n\");\n\n       vnc_write_u32(vs, 0); /* Accept auth completion */\n\n       vnc_read_when(vs, protocol_client_init, 1);\n\n       break;\n\n\n\n    case VNC_AUTH_VENCRYPT_TLSVNC:\n\n    case VNC_AUTH_VENCRYPT_X509VNC:\n\n       VNC_DEBUG(\"Start TLS auth VNC\\n\");\n\n       return start_auth_vnc(vs);\n\n\n\n    default: /* Should not be possible, but just in case */\n\n       VNC_DEBUG(\"Reject auth %d\\n\", vs->vd->auth);\n\n       vnc_write_u8(vs, 1);\n\n       if (vs->minor >= 8) {\n\n           static const char err[] = \"Unsupported authentication type\";\n\n           vnc_write_u32(vs, sizeof(err));\n\n           vnc_write(vs, err, sizeof(err));\n\n       }\n\n       vnc_client_error(vs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12365, "substitutes": {"vs": ["bs", "vc", "fs", "lines", "rs", "changes", "ks", "ops", "ads", "ses", "checks", "views", "hz", "sv", "heads", "eps", "ps", "otes", "sys", "es", "atts", "outs", "ls", "vp", "xs", "hs", "ms", "gs", "ports", "js", "its", "VS", "blogs", "vt", "lv", "sts", "lbs", "ims", "Vs", "vals", "values", "nets", "qv", "ys", "mr", "ds", "vv", "bp", "vr", "cs", "ts", "is", "bits", "wcs", "inv", "v", "ins", "qs", "obj", "vd", "vm", "obs", "docs", "ns", "lists", "ss"], "err": ["h", "usr", "ch", "Error", "lp", "die", "txt", "br", "error", "out", "gz", "buf", "result", "addr", "er", "sys", "arr", "r", "ptr", "e", "rc", "rr", "erd", "aaa", "der", "exc", "ocr", "html", "res", "str", "it", "msg", "fr", "data", "mr", "t", "attr", "fee", "body", "pr", "resp", "cmd", "kr", "cr", "errors", "v", "lr", "Er"]}}
{"project": "qemu", "commit_id": "1dde716ed6719c341c1bfa427781f0715af90cbc", "target": 0, "func": "iscsi_unmap_cb(struct iscsi_context *iscsi, int status,\n\n                     void *command_data, void *opaque)\n\n{\n\n    IscsiAIOCB *acb = opaque;\n\n\n\n    if (acb->canceled != 0) {\n\n        return;\n\n    }\n\n\n\n    acb->status = 0;\n\n    if (status < 0) {\n\n        error_report(\"Failed to unmap data on iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        acb->status = -EIO;\n\n    }\n\n\n\n    iscsi_schedule_bh(acb);\n\n}\n", "idx": 12367, "substitutes": {"iscsi": ["iscsc", "ircsc", "uscdi", "ircdi", "scsie", "iscdi", "ircsim", "iscsim", "scdi", "uscsie", "isksim", "uscsc", "ircsie", "ircsi", "uscsim", "isksi", "uscsi", "scsc", "isksie", "isksc", "scsi", "iscsie"], "acb": ["accb", " acrb", "acbd", "ocbar", "rcrb", "accfb", "abb", "sacr", "accbb", "ocbd", "saccb", "rcbd", "acbar", "acrb", "akb", " lacb", " lacba", "acba", "occb", "acccb", "ocsb", "acr", " laccb", "abba", " acn", "abbb", "acsb", "sacn", "amfb", " acsb", "ancb", "ambb", "accn", "ocba", " acr", "rcb", "amrb", "absb", "rcsb", "acbb", "accr", " cacb", "amb", " lacbar", "accrb", " cacba", " caccb", "aksb", "acfb", " acbb", "akba", " accb", "ancbb", "sacb", "ocrb", "acn", "ancsb", "akbb", " acbd", "ancba", " acfb", "ocb", " cacbar"]}}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static void virtio_notify(struct subchannel_id schid)\n\n{\n\n    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);\n\n}\n", "idx": 12376, "substitutes": {"schid": ["chid", "choid", "chpid", "khname", "khoid", "Schid", "chId", " schId", "Schoid", "schId", "khpid", " schname", "schpid", "Schname", "schname", "khid", "schoid", "chname", "SchId", "Schpid", " schoid"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)\n\n{\n\n    struct kvm_x86_mce mce = {\n\n        .bank = 9,\n\n        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN\n\n                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S\n\n                  | 0xc0,\n\n        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,\n\n        .addr = paddr,\n\n        .misc = (MCM_ADDR_PHYS << 6) | 0xc,\n\n    };\n\n\n\n    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);\n\n    kvm_mce_broadcast_rest(env);\n\n}\n", "idx": 12377, "substitutes": {"env": ["context", "h", "req", "end", "sb", "pe", "stack", "server", "buf", "nv", "sv", "hw", "conf", "er", "enter", "environment", " environment", "uv", "m", "vs", "vp", "te", "viron", "ah", "e", "window", "dev", "entry", "shell", "buffer", "vt", "ctx", "erd", "cv", "ce", "ev", "ew", "engine", "en", "conn", "proc", "gear", "ec", "ef", "esc", "v", "scope", "gov", "obj", "w", "vm"], "paddr": [" parp", "paddress", " paddress", " Pres", "tattr", "tarp", " Paddress", "Pres", "parp", " pattr", "bpaddr", " Paddr", "Padd", "pattr", " Padd", "taddr", "tptr", "bpattr", " padd", "bparp", "bpptr", "padd", "pres", " pres", "Paddress", " pptr", "Paddr", "pptr"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lm32_evr_init(QEMUMachineInitArgs *args)\n\n{\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem =  get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq *cpu_irq, irq[32];\n\n    ResetInfo *reset_info;\n\n    int i;\n\n\n\n    /* memory map */\n\n    target_phys_addr_t flash_base  = 0x04000000;\n\n    size_t flash_sector_size       = 256 * 1024;\n\n    size_t flash_size              = 32 * 1024 * 1024;\n\n    target_phys_addr_t ram_base    = 0x08000000;\n\n    size_t ram_size                = 64 * 1024 * 1024;\n\n    target_phys_addr_t timer0_base = 0x80002000;\n\n    target_phys_addr_t uart0_base  = 0x80006000;\n\n    target_phys_addr_t timer1_base = 0x8000a000;\n\n    int uart0_irq                  = 0;\n\n    int timer0_irq                 = 1;\n\n    int timer1_irq                 = 3;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = cpu_lm32_init(cpu_model);\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    reset_info->flash_base = flash_base;\n\n\n\n    memory_region_init_ram(phys_ram, \"lm32_evr.sdram\", ram_size);\n\n    vmstate_register_ram_global(phys_ram);\n\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* Spansion S29NS128P */\n\n    pflash_cfi02_register(flash_base, NULL, \"lm32_evr.flash\", flash_size,\n\n                          dinfo ? dinfo->bdrv : NULL, flash_sector_size,\n\n                          flash_size / flash_sector_size, 1, 2,\n\n                          0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    /* create irq lines */\n\n    cpu_irq = qemu_allocate_irqs(cpu_irq_handler, env, 1);\n\n    env->pic_state = lm32_pic_init(*cpu_irq);\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    sysbus_create_simple(\"lm32-uart\", uart0_base, irq[uart0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init();\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, ELF_MACHINE, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n", "idx": 12378, "substitutes": {"args": ["fs", "arms", "limits", "ants", "GS", "settings", "points", "objects", "GV", "flags", "checks", "ars", "amps", "units", "words", "comm", "ams", "yes", "arr", "atts", "aws", "ms", "gs", "js", "locks", "ctx", "ags", "eds", "vals", "aps", "roots", "ras", "authors", "ians", "arg", "apps", "actions", "cs", "ts", "bits", "cmd", "lang", "doc", "parts", "Args", "ns", "params"], "cpu_model": ["cpuptmodel", "cpu_package", "cpu_domain", "cpujmodel", "pu_link", "processor_mode", "processor_package", "pu_models", "cpuptmove", "processor_model", "cpujlink", "cpu_models", "cpujdomain", "pu_model", "cpu__name", "pu_brand", "cpuptgrid", "cpu_type", "pu_mode", "cpu_mode", "cpu__type", "pu_name", "cpu_link", "cpu__models", "cpu_filename", "cpu_move", "cpu_file", "cpuptmode", "pu_type", "pu_file", "pu_grid", "cpujmode", "pu_domain", "cpu__model", "cpu_grid", "processor_filename", "cpu_name", "pu_move", "cpu_brand"], "kernel_filename": ["kernelpomaximum", "kernelacfilename", "kernelacname", "network_file", "kernel___maximum", "ernel_file", "kernel_file", "ernel_maximum", "kernelacmode", "kernel_mode", "networkacmode", "kernelpopackage", "kernel_package", "network_filename", "kernel_name", "kernel_maximum", "networkacfilename", "kernelpofile", "network_mode", "ernel_package", "kernelacfile", "networkacname", "kernel___package", "kernel___filename", "kernelpofilename", "ernel_filename", "networkacfile", "kernel___file", "network_name"], "cpu": ["pkg", "context", "clock", "cache", "frame", "pc", "gpu", "memory", "node", "cli", "os", "cum", "init", "pu", "nu", "np", "processor", "cp", "hw", "core", "cu", "cn", "physical", "p", "sys", "cam", "linux", "gp", "bench", "ota", "pai", "target", "mem", "mac", "boot", "home", "tp", "arch", "ctx", "gc", "cv", "ce", "hog", "lock", "conn", "ka", "proc", "aco", "CPU", "phys", "prof", "net", "cmd", "stat", "vm", "base", "obj", "process", "uu", "mu", "chip"], "env": ["context", "ve", "egg", "map", "priv", "server", "world", "buf", "state", "ern", "nv", "np", "init", "eng", "conf", "er", "core", "environment", "except", "org", "uv", "ext", "vs", "mn", "viron", "mem", "e", "dev", "window", "vt", "ctx", "ev", "iv", "disk", "conn", "en", "den", "enc", "gear", "ec", "ef", "em", "eas", "net", "vert", "Environment", "config", "equ", "v", "ework", "vm"], "dinfo": [" dInfo", "dsstate", "ddinformation", " dfo", "dntype", "dbinformation", "dfo", "dinformation", "rInfo", "linformation", "rtype", "bdstate", "bdinf", "linfo", "dstate", "dsinfo", "dbfo", "dninformation", "dsinformation", "ddfo", " dinf", "ddinfo", "bdinformation", "ddInfo", " dtype", "dninfo", "rinfo", " dinformation", "dtype", "lInfo", "bdinfo", "dninf", "dnfo", "dbinfo", "dInfo", "dinf", "dbinf", "dnInfo", " dstate", "lfo", "rinformation", "dsinf"], "address_space_mem": ["address_Space_mem", "address_system_memory", "address_system_mem", "address_Space_memory", "address_space_memory", "address_Space_ram", "address_space_ram", "address_system_ram"], "phys_ram": ["phys2memory", "phys_rom", "phys_mem", "phys_rb", " phys_rom", " phys_mem", "phys2gram", "phys_memory", "physical_cam", "phy_rom", "phy_ram", "phy_memory", "phys2ram", "physical_mem", "phys_cam", "phys2mem", "phys_gram", "phy_rb", " phys_memory", "phy_gram", "physical_ram", "physical_rom", "phy_mem"], "cpu_irq": ["cpu_pirQ", "cpu_iterqs", "cpu_pirqs", "cpu_pirquire", "cpu_irQ", "cpu_iterquire", "cpu_ireq", "cpu_pirq", "cpu_ireQ", "cpu_irqs", "cpu_ireqs", "cpu_iterQ", "cpu_irquire", "cpu_irequire", "cpu_iterq"], "irq": ["iriqu", "pirq", "irqq", "pirqs", "pirqu", " irqs", "irqu", "pirqq", "irqs", "iriqs", "iriqq", " irqu", " irqq", "iriq"], "reset_info": ["resetgrdata", "repair_info", "reset___fo", "resetPrevent", "hardPrreport", "hard_info", "reset___data", "report___fo", "reset_data", " reset_information", "reset___info", "reset_fo", "reset_information", "hardPrinfo", "repair_information", "report_event", "reset_init", "resetallevent", "resetallreport", "hardPrInfo", "reset_report", "report_data", "report___data", "reset___event", "report_fo", "report_info", " reset_type", "report___event", "resettinfo", "resetPrinfo", "resetPrInfo", "resetgrevent", "hard_Info", "resetgrfo", "resetgrinfo", "reset_event", "repair_init", "hard_event", "resettinit", "resetallinfo", "hardPrevent", "reset_Info", "reset_type", "resettinformation", "resetPrreport", "hard_report", "report___info", "resetallInfo"], "i": ["l", "ii", "n", "z", "ip", " bi", "I", "p", "ei", " j", "set", "si", "m", "ia", "e", " v", "iu", "id", " ii", "j", "ie", "t", "o", "a", "v", "f", "io", "ta"]}}
{"project": "qemu", "commit_id": "075a1fe788d36b271ec25507466c30b9a90b5d54", "target": 0, "func": "static void gen_msa_branch(CPUMIPSState *env, DisasContext *ctx, uint32_t op1)\n\n{\n\n    uint8_t df = (ctx->opcode >> 21) & 0x3;\n\n    uint8_t wt = (ctx->opcode >> 16) & 0x1f;\n\n    int64_t s16 = (int16_t)ctx->opcode;\n\n\n\n    check_msa_access(ctx);\n\n\n\n    if (ctx->insn_flags & ISA_MIPS32R6 && ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        generate_exception_end(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n    switch (op1) {\n\n    case OPC_BZ_V:\n\n    case OPC_BNZ_V:\n\n        {\n\n            TCGv_i64 t0 = tcg_temp_new_i64();\n\n            tcg_gen_or_i64(t0, msa_wr_d[wt<<1], msa_wr_d[(wt<<1)+1]);\n\n            tcg_gen_setcondi_i64((op1 == OPC_BZ_V) ?\n\n                    TCG_COND_EQ : TCG_COND_NE, t0, t0, 0);\n\n            tcg_gen_trunc_i64_tl(bcond, t0);\n\n            tcg_temp_free_i64(t0);\n\n        }\n\n        break;\n\n    case OPC_BZ_B:\n\n    case OPC_BZ_H:\n\n    case OPC_BZ_W:\n\n    case OPC_BZ_D:\n\n        gen_check_zero_element(bcond, df, wt);\n\n        break;\n\n    case OPC_BNZ_B:\n\n    case OPC_BNZ_H:\n\n    case OPC_BNZ_W:\n\n    case OPC_BNZ_D:\n\n        gen_check_zero_element(bcond, df, wt);\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, bcond, bcond, 0);\n\n        break;\n\n    }\n\n\n\n    ctx->btarget = ctx->pc + (s16 << 2) + 4;\n\n\n\n    ctx->hflags |= MIPS_HFLAG_BC;\n\n    ctx->hflags |= MIPS_HFLAG_BDS32;\n\n}\n", "idx": 12383, "substitutes": {"env": ["pkg", "map", "pe", "tmp", "txt", "init", "setup", "buf", "cur", "hw", "st", "environment", "ei", "ptr", "te", "viron", "e", "dev", "ev", "sh", "sw", "en", "ec", "test", "sc", "scope", "obj", "ee"], "ctx": ["pkg", "bc", "tk", "cmp", "px", "cm", "np", "addr", "cp", "cb", "this", "warn", "ptr", "ork", "parse", "cv", "utils", "ca", "sc", "qu", "context", "kw", "tmp", "ck", "txt", "alloc", "ctrl", "util", "cpu", "Context", "cu", "mc", "jac", "cfg", "tc", "sp", "gc", "kt", "cf", "msg", "conn", "anc", "tm", "resp", "cmd", "kb", "jp", "req", "asm", "unc", "x", "cas", "exec", "loc", "sys", "nt", "cc", "index", "ka", "ct", "work", "xp", "tx", "lc", "ctl", "setup", "xc", "hw", "conf", "xs", "act", "mom", "func", "crit", "nc", "config", "wx", "obj", "iat"], "op1": ["Op1", "oper2", " op3", "hop01", "OP0", "Op2", "oper1", " opt0", "OP1", "opOne", "op0", " opt1", "top7", "OPOne", "op2", "op01", " op01", "Op3", " op0", "OP01", " opt3", " op2", "top0", " opOne", "Op0", "op3", "op7", "oper7", "hop2", "hopOne", " opt2", "oper0", "hop1", "top1", "OP7", "top2", "OP2"]}}
{"project": "qemu", "commit_id": "65c0f1e9558c7c762cdb333406243fff1d687117", "target": 0, "func": "static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)\n\n{\n\n    QObject *token, *ret;\n\n    QList *working = qlist_copy(*tokens);\n\n\n\n    token = qlist_pop(working);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    qobject_decref(token);\n\n    QDECREF(*tokens);\n\n    *tokens = working;\n\n\n\n    return ret;\n\n\n\nout: \n\n    qobject_decref(token);\n\n    QDECREF(working);\n\n\n\n    return NULL;\n\n}\n", "idx": 12384, "substitutes": {"ctxt": ["ctld", "CTtx", "CTxt", "ecttx", "ctert", "curert", "CTtxt", "ectxt", "ecttxt", "cttxt", "curld", "curtx", "ectert", "CTld", "curxt", "ctxtx", "CTert", "ctxtxt", "curtxt", "cttx", "ctxld", "ctxxt"], "tokens": ["tokenotypes", "targened", "tokents", "stokened", "topentials", "toksentials", "wokets", "tocents", "wokens", "stokets", "wokened", "topkens", "fokenotypes", "fokenens", "stopets", "tokskens", "fokotypes", "toyens", "stopens", "tokenened", "tokenenes", "fokened", "toyenes", "toksenes", "toksotypes", "topents", "targents", "tokentials", "todens", "todentials", "tocets", "tokotypes", "stokentials", "tokened", "fokens", "fokenes", "targets", "tokets", "topens", "tokkens", "tocens", "stokens", "todets", "toyened", "toyotypes", "fokenened", "toksened", "stopentials", "topets", "fokenenes", "todkens", "wargens", "wargkens", "targkens", "wargened", "stopents", "tokenes", "stopened", "tocened", "stokkens", "stokents", "wargets", "tokenens", "wokkens", "tockens", "topened", "toksens", "toksets", "stopkens", "targens"], "token": ["tn", "status", "header", "ski", "tk", "error", "resource", "tree", "message", "scan", "rule", "initial", "KEN", "tar", "trigger", "forward", "term", "pair", "operation", "event", "context", "info", "component", "txt", "complete", "word", "temp", "next", "atom", "number", "processor", "tag", "operator", "start", "tf", "statement", "target", "buffer", "final", "single", "t", "template", "source", "prototype", "oken", "parser", "channel", "type", "node", "value", "session", "language", "batch", "key", "Token", "field", "note", "object", "variable", "iterator", "item", "data", "normal", "piece", "character", "typ", "tool", "o", "training", "null", "json", "local", "result", "document", "p", "tower", "false", "handle", "none", "twitter", "attribute", "spec", "ok", "termin", "row", "span", "table", "reset"], "ret": ["uf", "rel", "ft", "jp", "ref", "RET", "elt", "lt", "tmp", "pret", "txt", "out", "re", "reg", "cat", "Ret", "result", "pas", " RET", "def", "arr", "r", "tr", "mb", "ry", "flag", "mem", "repl", "alt", "nt", "att", "ert", "it", "res", "j", "rot", "rm", "bool", "mt", "det", "gt", "try", "t", "unt", "ll", "rets", " Ret", "rt", "cmd", "val", "print", "rest", "lit", "obj", "rem"], "working": ["packing", "moving", "depending", "worker", "ring", "standing", "being", "starting", "tmp", "padding", "worked", "tx", "processing", "pool", "joining", "global", "ing", "border", "using", "based", "wild", "getting", "existing", "workers", "works", "ending", "calling", "looking", "loading", "acting", "opening", "including", "changing", "going", "watching", "ki", "work", "ordering", "Working", "running", "picking", "playing", "locking", "checking", "testing", "walking", "saving"]}}
{"project": "FFmpeg", "commit_id": "892bbbcdc171ff0d08d69636a240ffb95f54243c", "target": 0, "func": "static av_cold int vaapi_encode_config_attributes(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext *ctx = avctx->priv_data;\n\n    VAStatus vas;\n\n    int i, n, err;\n\n    VAProfile    *profiles    = NULL;\n\n    VAEntrypoint *entrypoints = NULL;\n\n    VAConfigAttrib attr[] = {\n\n        { VAConfigAttribRTFormat        },\n\n        { VAConfigAttribRateControl     },\n\n        { VAConfigAttribEncMaxRefFrames },\n\n    };\n\n\n\n    n = vaMaxNumProfiles(ctx->hwctx->display);\n\n    profiles = av_malloc_array(n, sizeof(VAProfile));\n\n    if (!profiles) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    vas = vaQueryConfigProfiles(ctx->hwctx->display, profiles, &n);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Failed to query profiles: %d (%s).\\n\",\n\n               vas, vaErrorStr(vas));\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n    for (i = 0; i < n; i++) {\n\n        if (profiles[i] == ctx->va_profile)\n\n            break;\n\n    }\n\n    if (i >= n) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Encoding profile not found (%d).\\n\",\n\n               ctx->va_profile);\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n\n\n    n = vaMaxNumEntrypoints(ctx->hwctx->display);\n\n    entrypoints = av_malloc_array(n, sizeof(VAEntrypoint));\n\n    if (!entrypoints) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    vas = vaQueryConfigEntrypoints(ctx->hwctx->display, ctx->va_profile,\n\n                                   entrypoints, &n);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Failed to query entrypoints for \"\n\n               \"profile %u: %d (%s).\\n\", ctx->va_profile,\n\n               vas, vaErrorStr(vas));\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n    for (i = 0; i < n; i++) {\n\n        if (entrypoints[i] == ctx->va_entrypoint)\n\n            break;\n\n    }\n\n    if (i >= n) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Encoding entrypoint not found \"\n\n               \"(%d / %d).\\n\", ctx->va_profile, ctx->va_entrypoint);\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n\n\n    vas = vaGetConfigAttributes(ctx->hwctx->display,\n\n                                ctx->va_profile, ctx->va_entrypoint,\n\n                                attr, FF_ARRAY_ELEMS(attr));\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to fetch config \"\n\n               \"attributes: %d (%s).\\n\", vas, vaErrorStr(vas));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(attr); i++) {\n\n        if (attr[i].value == VA_ATTRIB_NOT_SUPPORTED) {\n\n            // Unfortunately we have to treat this as \"don't know\" and hope\n\n            // for the best, because the Intel MJPEG encoder returns this\n\n            // for all the interesting attributes.\n\n            continue;\n\n        }\n\n        switch (attr[i].type) {\n\n        case VAConfigAttribRTFormat:\n\n            if (!(ctx->va_rt_format & attr[i].value)) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Surface RT format %#x \"\n\n                       \"is not supported (mask %#x).\\n\",\n\n                       ctx->va_rt_format, attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            ctx->config_attributes[ctx->nb_config_attributes++] =\n\n                (VAConfigAttrib) {\n\n                .type  = VAConfigAttribRTFormat,\n\n                .value = ctx->va_rt_format,\n\n            };\n\n            break;\n\n        case VAConfigAttribRateControl:\n\n            if (!(ctx->va_rc_mode & attr[i].value)) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Rate control mode %#x \"\n\n                       \"is not supported (mask: %#x).\\n\",\n\n                       ctx->va_rc_mode, attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            ctx->config_attributes[ctx->nb_config_attributes++] =\n\n                (VAConfigAttrib) {\n\n                .type  = VAConfigAttribRateControl,\n\n                .value = ctx->va_rc_mode,\n\n            };\n\n            break;\n\n        case VAConfigAttribEncMaxRefFrames:\n\n        {\n\n            unsigned int ref_l0 = attr[i].value & 0xffff;\n\n            unsigned int ref_l1 = (attr[i].value >> 16) & 0xffff;\n\n\n\n            if (avctx->gop_size > 1 && ref_l0 < 1) {\n\n                av_log(avctx, AV_LOG_ERROR, \"P frames are not \"\n\n                       \"supported (%#x).\\n\", attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            if (avctx->max_b_frames > 0 && ref_l1 < 1) {\n\n                av_log(avctx, AV_LOG_ERROR, \"B frames are not \"\n\n                       \"supported (%#x).\\n\", attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n        }\n\n        break;\n\n        default:\n\n            av_assert0(0 && \"Unexpected config attribute.\");\n\n        }\n\n    }\n\n\n\n    err = 0;\n\nfail:\n\n    av_freep(&profiles);\n\n    av_freep(&entrypoints);\n\n    return err;\n\n}\n", "idx": 12395, "substitutes": {"avctx": ["cvcontext", " avcmp", "cvdc", "AVcontext", "avtx", "AVctx", "avcontext", "hwctx", " avcontext", "cvctx", "vatx", " avtx", "hwcmp", "vacontext", "AVtx", "vadc", "cvtx", "vactx", "avdc", " avdc", "hwtx", "hwcontext", "avcmp", "AVcmp"], "ctx": ["pkg", "bc", "conv", "tk", "gz", "cmp", "px", "cm", "np", "addr", "cp", "cb", "check", "kl", "qa", "pause", "pg", "fn", "cv", "grad", "pt", "td", "context", "that", "kw", "tmp", "ck", "txt", "cu", "cn", "def", "jac", "cfg", "timeout", "tc", "gc", "cf", "kt", "cpp", "conn", "anc", "tm", "resp", "cmd", "abc", "fx", "ind", "jp", "prefix", "req", "pc", "unc", "cas", "etc", "comm", "ppo", "nt", "cc", "ka", "ct", "proc", " cx", "typ", "lex", "work", "github", "wcs", "wd", "xp", "comp", "tx", "lc", "ctl", " cp", "xc", " context", "xs", "desc", "act", "cl", "inst", "func", "nc", "config", "wx", "obj", "wordpress", "iat"], "vas": ["conv", " cac", "las", "ps", " stats", "ports", "js", "VS", "na", "vals", "caps", "cats", " canvas", "vers", " Vas", " va", "cache", "png", "txt", "draw", "als", " tv", "cu", "bridge", "pas", " sav", "jac", "vid", "ja", "as", " vers", "gc", "aaa", "paste", "cus", "pres", "jas", "css", "van", " oval", "docker", "eas", "axe", "ns", "rus", "jp", "jpg", "vre", "quer", "cas", "buf", " ans", "browser", "cam", " vac", "vs", " vo", "cape", "ims", "mas", " aval", "boxes", "va", "stage", "ts", "wcs", " vis", "wiki", "ras", "sts", " vantage", "uses", "kit", "BA", "pages", " cu", "aus", "scale", " canv", "us", "nas", "gs", "box", "VA", "um", "vis", "roots", " cs", "cs", "aka", "nexus", "mouse"], "i": ["ski", "cli", "gu", "u", "this", "oi", " ii", "it", "g", "ci", "ie", "ki", "zi", "mi", "y", "eu", "info", "ii", "ji", "ij", "init", "hi", "m", "cgi", "ri", "multi", "to", "ni", "j", "iii", "xi", "t", "ix", "is", "by", "ui", "ini", "qi", "ind", "ai", "di", "x", "q", " bi", "ti", "li", "\u0438", "I", "si", "ori", "im", "in", "ims", "index", "phi", "pi", "bi", "io", "iq", "gi", " ni", "sim", "ip", "ei", "p", " j", " I", "us", "dr", "e", "ami", "iu", "me", "v", " ti"], "n": ["dn", "un", "d", "sn", "l", "nos", " N", "norm", "z", "gn", "out", "nan", "nu", "np", "number", "c", "nv", "cn", "p", "an", "m", "nm", "any", "mn", "ne", "N", "ren", "pn", "pos", "ln", "nas", "nt", "names", "len", "ng", "fn", "nr", "na", "no", "to", "ni", "size", "g", "rn", "j", "nn", "nets", "num", "nor", "en", "conn", "nia", "nl", "nb", "t", "non", "ll", "net", "nc", "o", "all", "y", "v", "w", "on", "ns"], "err": ["erer", "rel", "usr", "Er", "rs", "req", "elt", "dt", "die", "txt", "br", "rb", "error", "cli", "gz", "buf", "hz", "conf", "er", "ei", "arr", "r", "urg", "ptr", "dr", "cfg", "alt", "rev", "rr", "iter", "aaa", "der", "rn", "ev", "msg", "fr", "mr", "css", "try", "late", "typ", "fee", "gr", "pr", "resp", "inv", "kr", "cr", "drm", "lr", "eas", "notice", "ns"], "profiles": ["permilities", "propelines", "profileiles", "philes", "propels", "prediles", "protabilities", "propiles", "phabilities", "predports", "protels", "protiles", "sequports", "facensions", "sequiles", "profilities", "facabilities", "profels", "profilies", "profileilers", "phensions", "propiled", "profiling", "protiling", "profelines", "predilers", "permerences", "spiles", "Profilities", "Profilers", "profils", "profilers", "Profilies", "Profiles", "spilers", "protensions", "permilers", "protelines", "facelines", "permiles", "profensions", "Profils", "predilities", "faciled", "predils", "predilies", "sequils", "profabilities", "Proferences", "spilities", "profports", "faciling", "sperences", "facels", " profports", " profilities", "profiled", "protiled", "proferences", "profileils", " profils", "philing", "profileilies", "sequilities", "faciles"], "entrypoints": [" entrypointers", " entrypages", "entrypins", "terlines", "cellpointers", "enterPoints", "enterlists", "interpins", "rypins", " entrylines", " entrylists", "enterpoint", "ryfaces", "rypoints", "ryports", "entrypoint", " entrypins", "enterports", "interpoints", "entryports", "checkpoints", " entryfaces", "cellports", "rylists", "interfaces", "ryparts", "cellparts", "enterparts", "entrylines", "enterlines", "entrylists", "entrypointers", "terpoints", "entrypages", "rypoint", "interports", "checkPoints", "entryPoints", "rypointers", "terpointers", "enterpointers", "terpages", " entryports", "cellpoints", "checklines", "entryparts", "checkpoint", "rylines", "enterpoints", "ryPoints", "entryfaces", "enterpages"], "attr": ["rel", "cache", "ref", "prop", "rs", "type", "req", "opt", "txt", "format", "tab", "Att", "def", "sys", "r", "desc", "att", "attribute", "spec", "str", "num", "msg", " att", "proc", "param", "class", "obj", "label"]}}
{"project": "FFmpeg", "commit_id": "be00ec832c519427cd92218abac77dafdc1d5487", "target": 0, "func": "static int targa_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                              const AVFrame *p, int *got_packet)\n\n{\n\n    int bpp, picsize, datasize = -1, ret;\n\n    uint8_t *out;\n\n\n\n    if(avctx->width > 0xffff || avctx->height > 0xffff) {\n\n        av_log(avctx, AV_LOG_ERROR, \"image dimensions too large\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    picsize = av_image_get_buffer_size(avctx->pix_fmt,\n\n                                       avctx->width, avctx->height, 1);\n\n    if ((ret = ff_alloc_packet(pkt, picsize + 45)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* zero out the header and only set applicable fields */\n\n    memset(pkt->data, 0, 12);\n\n    AV_WL16(pkt->data+12, avctx->width);\n\n    AV_WL16(pkt->data+14, avctx->height);\n\n    /* image descriptor byte: origin is always top-left, bits 0-3 specify alpha */\n\n    pkt->data[17] = 0x20 | (avctx->pix_fmt == AV_PIX_FMT_BGRA ? 8 : 0);\n\n\n\n    switch(avctx->pix_fmt) {\n\n    case AV_PIX_FMT_GRAY8:\n\n        pkt->data[2]  = TGA_BW;     /* uncompressed grayscale image */\n\n        pkt->data[16] = 8;          /* bpp */\n\n        break;\n\n    case AV_PIX_FMT_RGB555LE:\n\n        pkt->data[2]  = TGA_RGB;    /* uncompresses true-color image */\n\n        pkt->data[16] = 16;         /* bpp */\n\n        break;\n\n    case AV_PIX_FMT_BGR24:\n\n        pkt->data[2]  = TGA_RGB;    /* uncompressed true-color image */\n\n        pkt->data[16] = 24;         /* bpp */\n\n        break;\n\n    case AV_PIX_FMT_BGRA:\n\n        pkt->data[2]  = TGA_RGB;    /* uncompressed true-color image */\n\n        pkt->data[16] = 32;         /* bpp */\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Pixel format '%s' not supported.\\n\",\n\n               av_get_pix_fmt_name(avctx->pix_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n    bpp = pkt->data[16] >> 3;\n\n\n\n    out = pkt->data + 18;  /* skip past the header we just output */\n\n\n\n    /* try RLE compression */\n\n    if (avctx->coder_type != FF_CODER_TYPE_RAW)\n\n        datasize = targa_encode_rle(out, picsize, p, bpp, avctx->width, avctx->height);\n\n\n\n    /* if that worked well, mark the picture as RLE compressed */\n\n    if(datasize >= 0)\n\n        pkt->data[2] |= 8;\n\n\n\n    /* if RLE didn't make it smaller, go back to no compression */\n\n    else datasize = targa_encode_normal(out, p, bpp, avctx->width, avctx->height);\n\n\n\n    out += datasize;\n\n\n\n    /* The standard recommends including this section, even if we don't use\n\n     * any of the features it affords. TODO: take advantage of the pixel\n\n     * aspect ratio and encoder ID fields available? */\n\n    memcpy(out, \"\\0\\0\\0\\0\\0\\0\\0\\0TRUEVISION-XFILE.\", 26);\n\n\n\n    pkt->size   = out + 26 - pkt->data;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 12402, "substitutes": {"avctx": [" avjac", "avercontext", "avreq", "avercp", " avcmp", "averconn", "wavcontext", "avtx", "avecfg", "navctl", "navcp", " avreq", "avcfg", "avcpu", "wavcp", " avcontext", "wavsys", "avecp", "avwcs", "averwcs", "avconfig", "ajtx", "avereq", "savpkg", "avewcs", "ajctx", "averconfig", "wavcmd", "avepkg", "navtx", "avcmd", "savcmd", "averctl", "afctl", "avpkg", "navctx", "averctx", "aftx", "avejac", "avectx", " avconf", " avcp", "afctx", "savjac", "avsys", " avpkg", "navcfg", "ajjac", "navsys", "aveconf", "avjac", "navcmd", "aveconfig", "averconf", "AVcontext", "AVctx", "avcontext", "avercmd", "AVcfg", "avercfg", "savctx", "avecontext", "wavpkg", "averreq", "averpkg", "ajcontext", "ajconf", "avcmp", "wavtx", "averjac", " avcmd", "savconn", "avcp", " avconfig", "savcfg", "ajcpu", "wavconf", "afconf", " avcfg", "ajconfig", "ajcp", "wavconfig", "avetx", "avctl", " avtx", "wavctx", "avertx", "avectl", "avecmd", "avecmp", "wavwcs", "avconf", "avconn", "aveconn", "wavcpu", "aversys", "avercpu", "AVcmp"], "pkt": ["pkg", "cpct", "promkt", "formkt", "patacket", " pmit", "opkg", "pfeat", " pet", "paymsg", "persixie", "repitt", "persmit", "opacket", "patkt", "wkt", "pelt", "pet", "phpman", " pwd", " pcht", "spkt", " pconn", "partkt", "portcht", "presacket", "pingcat", "pwk", "payshot", "pixie", " pmsg", "Pnt", "pingux", "presman", "pitt", " pshot", "presett", "dkt", "formvert", " pfeat", " pnt", "opmsg", "spkg", "presixie", "pingkt", "promfeat", " pkg", "Packet", "formmit", "pempt", "patwd", "cpkg", "promett", "perskt", " pett", "cpkt", "opet", " pct", "expkt", "pvert", "pwd", "spct", "wacket", "expvert", "pingacket", " pempt", "phpett", "promitt", "phpitt", "formfeat", "pman", " pman", "opct", "payacket", "payelt", "repfeat", "wet", "expmit", "paykt", "pett", "paycht", "payconn", "persshot", "formempt", "presitt", "cpconn", "partcat", "repacket", "wpacket", "poch", "pcat", "wmsg", "partitt", "repvert", "persacket", "pnt", "formitt", " pux", "pmit", "pingkg", "persempt", "wpkt", "repkt", "repcat", " pelt", "paycat", "dnt", "pingelt", "pcht", "portmit", "pconn", "wpoch", "persmsg", " packet", " pitt", "expempt", "partwk", "portkt", "repmit", "Pct", "formux", " pixie", "formacket", "repwk", "cpacket", "Pkt", "repempt", "formkg", "spacket", "repett", "dct", " pcat", "pshot", "phpkt", "opkt", "packet", " pwk", "patoch", "wpwd", " poch", "pct", "pingconn", "pmsg", "paymit", "opconn", "portacket", "preskt", "dacket", "presempt", "pux"], "p": ["h", "i", "d", "jp", "fp", "rep", "n", "pc", "pa", "np", "c", "q", "cp", "r", "m", "pb", "b", "tp", "P", "g", "j", "t", "pt", "o", "pp", "v", "f", "w"], "got_packet": ["got_packed", "got2packacket", "got2packed", "got_presets", "got_presed", "got_pets", "got2packets", "got_acket", "got_pet", "got_presacket", "got2pets", "got_ackacket", "got_ped", "got2packet", "got_preset", "got_ackets", "got_packacket", "got_packets", "got_acked", "got2ped", "got2pet"], "bpp": ["bpps", "bpe", "abpps", "tpps", " bpps", "ppe", "bbpp", " bps", "pmp", "abpp", "ppps", "bpl", "abpl", "tpp", " bpl", "bmp", "bbpe", "bbmp", "bps", "abps", "bbpps", "ppp", " bmp", " bpe", "tpl", "tps"], "picsize": ["pisize", "picsIZE", "picize", "picksization", "picource", "picIZE", "pissize", "picssize", "npicIZE", " picssize", "pipsource", "picksized", " picsization", "npicsiz", "picsource", "npicize", "npicsized", "Picsource", " piciz", "npicized", "pisiz", "picksIZE", "picsiz", "npicsize", "Pickssize", "picization", "pidisized", "pipsize", "picksource", "pidisIZE", "Picksize", " picsiz", "Picksource", "pipsiz", " picization", "Picssize", "pisization", "Picsiz", "Picsize", "picsized", "npiciz", "picsization", "Picksiz", "pidisiz", "pipssize", "piciz", "pickssize", "npicsIZE", "pidisize", "picksiz", "picized", " picize", "picksize"], "ret": ["rel", "ft", "ref", "RET", "dt", "tmp", "last", "txt", "re", "reply", "ern", "reg", "value", "Ret", "result", "def", "err", "r", "tf", "empty", "alt", "mem", "nt", "len", "fi", "fun", "cont", "res", "j", "back", "after", "mt", "det", "gt", "fail", "t", "ll", "fin", "rets", " Ret", "resp", "rt", "mel", "val", "f", "reset", "rem"], "out": ["ch", "n", "tmp", "conv", "buf", "c", "new", "OUT", "u", "set", "in", "b", "Out", "g", "res", "j", "msg", "bin", "gt", "t", "o", "v", "f", "obj", "w", "io", "output"]}}
{"project": "qemu", "commit_id": "7ef8cf9a0861b6f67f5e57428478c31bfd811651", "target": 1, "func": "static int scsi_req_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    cmd->xfer = scsi_cdb_length(buf);\n\n    switch (buf[0]) {\n\n    case TEST_UNIT_READY:\n\n    case REWIND:\n\n    case START_STOP:\n\n    case SET_CAPACITY:\n\n    case WRITE_FILEMARKS:\n\n    case WRITE_FILEMARKS_16:\n\n    case SPACE:\n\n    case RESERVE:\n\n    case RELEASE:\n\n    case ERASE:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case SEEK_10:\n\n    case SYNCHRONIZE_CACHE:\n\n    case SYNCHRONIZE_CACHE_16:\n\n    case LOCATE_16:\n\n    case LOCK_UNLOCK_CACHE:\n\n    case SET_CD_SPEED:\n\n    case SET_LIMITS:\n\n    case WRITE_LONG_10:\n\n    case UPDATE_BLOCK:\n\n    case RESERVE_TRACK:\n\n    case SET_READ_AHEAD:\n\n    case PRE_FETCH:\n\n    case PRE_FETCH_16:\n\n    case ALLOW_OVERWRITE:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case VERIFY_10:\n\n    case VERIFY_12:\n\n    case VERIFY_16:\n\n        if ((buf[1] & 2) == 0) {\n\n            cmd->xfer = 0;\n\n        } else if ((buf[1] & 4) == 1) {\n\n            cmd->xfer = 1;\n\n        }\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case MODE_SENSE:\n\n        break;\n\n    case WRITE_SAME_10:\n\n    case WRITE_SAME_16:\n\n        cmd->xfer = dev->blocksize;\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        cmd->xfer = 8;\n\n        break;\n\n    case READ_BLOCK_LIMITS:\n\n        cmd->xfer = 6;\n\n        break;\n\n    case SEND_VOLUME_TAG:\n\n        /* GPCMD_SET_STREAMING from multimedia commands.  */\n\n        if (dev->type == TYPE_ROM) {\n\n            cmd->xfer = buf[10] | (buf[9] << 8);\n\n        } else {\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case WRITE_6:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case WRITE_10:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case READ_10:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case READ_12:\n\n    case READ_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case FORMAT_UNIT:\n\n        /* MMC mandates the parameter list to be 12-bytes long.  Parameters\n\n         * for block devices are restricted to the header right now.  */\n\n        if (dev->type == TYPE_ROM && (buf[1] & 16)) {\n\n            cmd->xfer = 12;\n\n        } else {\n\n            cmd->xfer = (buf[1] & 16) == 0 ? 0 : (buf[1] & 32 ? 8 : 4);\n\n        }\n\n        break;\n\n    case INQUIRY:\n\n    case RECEIVE_DIAGNOSTIC:\n\n    case SEND_DIAGNOSTIC:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    case READ_CD:\n\n    case READ_BUFFER:\n\n    case WRITE_BUFFER:\n\n    case SEND_CUE_SHEET:\n\n        cmd->xfer = buf[8] | (buf[7] << 8) | (buf[6] << 16);\n\n        break;\n\n    case PERSISTENT_RESERVE_OUT:\n\n        cmd->xfer = ldl_be_p(&buf[5]) & 0xffffffffULL;\n\n        break;\n\n    case ERASE_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* MMC command GET PERFORMANCE.  */\n\n            cmd->xfer = scsi_get_performance_length(buf[9] | (buf[8] << 8),\n\n                                                    buf[10], buf[1] & 0x1f);\n\n        }\n\n        break;\n\n    case MECHANISM_STATUS:\n\n    case READ_DVD_STRUCTURE:\n\n    case SEND_DVD_STRUCTURE:\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* BLANK command of MMC */\n\n            cmd->xfer = 0;\n\n        } else {\n\n            cmd->xfer = ata_passthrough_12_xfer_size(dev, buf);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_16:\n\n        cmd->xfer = ata_passthrough_16_xfer_size(dev, buf);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12409, "substitutes": {"cmd": ["pkg", "bind", "ch", "ind", "req", "send", "term", "opt", "nd", "txt", "cli", "init", "cmp", "cat", "addr", "exec", "comm", "conf", "ext", "del", "check", "def", "batch", "urg", "add", "host", "rend", "cfg", "desc", "mk", "handle", "good", "controller", "news", "md", "nt", "kick", "ctx", "quit", "cont", "dep", "cod", "job", "act", "help", "auth", "msg", "conn", "ct", "det", "Cmd", "dq", "ctr", "control", "quick", "crit", "config", "resp", "head", "text", "command", "obj", "form", "query", "call"], "dev": ["device", "info", "dem", "ve", "DEV", "serv", "priv", "app", "server", "task", "go", "serial", "devices", "nv", "addr", "hw", "conf", "ver", "develop", "def", "sys", "scan", "cam", "Device", "mem", "md", "nt", "db", "des", "Dev", "env", "w", "ctx", "spec", "de", "dep", "ev", "ad", "data", "conn", "det", "proc", "debug", "vol", "v", "var", " device", "adv", "doc"], "buf": ["uf", "pkg", "bs", "queue", "ff", "cache", "ref", "prop", "packed", "bytes", "bl", "bc", "txt", "br", "conv", "rb", "go", "Buff", "tab", "hz", "cb", "comm", "bh", "vec", "batch", "img", "cam", "pb", "desc", "raw", "buff", "bag", "mem", "b", "window", "db", "box", "buffer", "block", "iter", "ctx", "cv", "ev", "Buffer", "str", "cap", "msg", "lim", "bin", "seq", "proc", "pack", "bp", "grad", "config", "aka", "pad", "deg", "v", "emb", "var", "aux", "doc", "dat"]}}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static void qdm2_init(QDM2Context *q) {\n\n    static int inited = 0;\n\n\n\n    if (inited != 0)\n\n        return;\n\n    inited = 1;\n\n\n\n    qdm2_init_vlc();\n\n    ff_mpa_synth_init(mpa_window);\n\n    softclip_table_init();\n\n    rnd_table_init();\n\n    init_noise_samples();\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"init done\\n\");\n\n}\n", "idx": 12412, "substitutes": {"q": ["qi", "iq", "queue", "ch", "z", "tx", "Q", " qu", "c", "p", "qa", "qq", "cc", "ctx", "w", "cv", "g", "sq", " sq", "dq", "ct", "t", " c", "qu", "v", "qs", "qt", "query"]}}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int encode_frame(FlacEncodeContext *s)\n\n{\n\n    int ch, count;\n\n\n\n    count = count_frame_header(s);\n\n\n\n    for (ch = 0; ch < s->channels; ch++)\n\n        count += encode_residual_ch(s, ch);\n\n\n\n    count += (8 - (count & 7)) & 7; // byte alignment\n\n    count += 16;                    // CRC-16\n\n\n\n    return count >> 3;\n\n}\n", "idx": 12429, "substitutes": {"s": ["bs", "fs", "rs", "sb", "n", "ses", "S", "als", "os", "c", "sv", "ps", "comm", "p", "sys", "ess", "an", "es", "ls", "hs", "gs", "b", "ats", "its", "js", "ims", "sts", "w", "bis", "sq", "less", "t", "ds", "cs", "ts", "is", "a", "f", "ins", "qs", "ns", "ss"], "ch": ["i", "h", "ind", "channel", "ble", "uch", "th", " Ch", "k", "bt", "bc", "z", "sch", "br", "x", "go", "ich", "col", "c", "q", "cp", "chu", "mut", "client", "batch", "ach", "zh", "Ch", "cell", "kh", "code", "b", "att", "ih", "sk", "chn", "g", "tch", "sh", "j", "bit", "cho", "msg", "ech", "el", "ex", " chunk", "cht", " c", "och", "ca", "pt", "cs", "bot", "qu", "CH", "ac", "unk", "y", "v", "wh", "ph", "chrom", "ht", "gb", "chan"], "count": ["ount", "status", "history", "counter", "message", "check", "ach", "add", "offset", "amount", "found", "scroll", "report", "all", "base", "hold", "current", "h", "must", "and", "cache", "d", "last", "Count", "hash", "number", "force", "code", "buffer", "size", "at", "limit", "num", "comment", "nb", "t", "cmd", "f", "command", "length", "sum", "ind", "l", "c", "q", "err", "cast", "trace", "nt", "total", "index", "max", "ct", "more", "a", "n", "time", "th", "z", "state", "result", "find", "p", "list", "now", "port", "len", "cont", "mount", "table"]}}
{"project": "qemu", "commit_id": "7df9381b7aa56c897e344f3bfe43bf5848bbd3e0", "target": 0, "func": "static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos)\n\n{\n\n    PCIDevice *pdev = &vdev->pdev;\n\n    uint8_t cap_id, next, size;\n\n    int ret;\n\n\n\n    cap_id = pdev->config[pos];\n\n    next = pdev->config[pos + PCI_CAP_LIST_NEXT];\n\n\n\n    /*\n\n     * If it becomes important to configure capabilities to their actual\n\n     * size, use this as the default when it's something we don't recognize.\n\n     * Since QEMU doesn't actually handle many of the config accesses,\n\n     * exact size doesn't seem worthwhile.\n\n     */\n\n    size = vfio_std_cap_max_size(pdev, pos);\n\n\n\n    /*\n\n     * pci_add_capability always inserts the new capability at the head\n\n     * of the chain.  Therefore to end up with a chain that matches the\n\n     * physical device, we insert from the end by making this recursive.\n\n     * This is also why we pre-calculate size above as cached config space\n\n     * will be changed as we unwind the stack.\n\n     */\n\n    if (next) {\n\n        ret = vfio_add_std_cap(vdev, next);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    } else {\n\n        /* Begin the rebuild, use QEMU emulated list bits */\n\n        pdev->config[PCI_CAPABILITY_LIST] = 0;\n\n        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;\n\n        vdev->emulated_config_bits[PCI_STATUS] |= PCI_STATUS_CAP_LIST;\n\n    }\n\n\n\n    /* Use emulated next pointer to allow dropping caps */\n\n    pci_set_byte(vdev->emulated_config_bits + pos + PCI_CAP_LIST_NEXT, 0xff);\n\n\n\n    switch (cap_id) {\n\n    case PCI_CAP_ID_MSI:\n\n        ret = vfio_msi_setup(vdev, pos);\n\n        break;\n\n    case PCI_CAP_ID_EXP:\n\n        vfio_check_pcie_flr(vdev, pos);\n\n        ret = vfio_setup_pcie_cap(vdev, pos, size);\n\n        break;\n\n    case PCI_CAP_ID_MSIX:\n\n        ret = vfio_msix_setup(vdev, pos);\n\n        break;\n\n    case PCI_CAP_ID_PM:\n\n        vfio_check_pm_reset(vdev, pos);\n\n        vdev->pm_cap = pos;\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    case PCI_CAP_ID_AF:\n\n        vfio_check_af_flr(vdev, pos);\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    default:\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        error_report(\"vfio: %04x:%02x:%02x.%x Error adding PCI capability \"\n\n                     \"0x%x[0x%x]@0x%x: %d\", vdev->host.domain,\n\n                     vdev->host.bus, vdev->host.slot, vdev->host.function,\n\n                     cap_id, size, pos, ret);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12434, "substitutes": {"vdev": ["vclink", "vpay", "uvpay", " vdevice", "vstore", " vcast", "voldev", "vstat", "pcam", "vutil", " vDev", "svdb", "penv", "pobj", " vstream", "pserver", "vhost", "pdevice", "pdes", "svdev", "vmdevice", "vcpay", " vpay", "jdevice", "vw", "volpriv", " vlink", "vself", "vvar", "hcast", "vdes", "vmblock", " vserver", "pself", "uvdev", "svstream", "ppay", "vmdev", "svdevice", "volhost", "pDev", "plink", "svenv", "pblock", "vmcam", "uvdevice", "vDev", "vccast", "pdb", "vstream", "vserial", "pstream", "vlink", "vdb", "wDev", "vcutil", "vcdevice", "hdev", "vcDev", "svself", "tdev", " vw", "pdef", "vcserver", " venv", "vcdev", "vcast", " vstore", "vobj", "vserver", " vcam", "jvar", "svserial", "uvhost", "vblock", "vdevice", "wdev", "venv", " vself", "pstore", "tdevice", "uvpriv", "uvutil", "pstat", "ppriv", "hDev", "jdef", "tvar", "vcdes", "pvar", "vpriv", " vstat", "wdevice", " vdb", "hcam", "tdef", "ww", "phost", "vmdes", "pserial", "hstat", "svstore", " vserial", "hpay", "vdef", "vccam", "hutil", "vcblock", "vmDev", "jdev", "vcam", "voldevice", "pw", "vmobj", "hdevice", "vcobj"], "pos": ["pool", "prot", "ps", "unit", "Pos", "offset", "rot", "POS", "snap", "pt", "base", "tmp", "alloc", "os", "slot", "init", "pid", "def", "position", "tag", "client", "start", "set", "zero", "pro", "name", "to", "at", "num", "pres", "pat", "po", "resp", "part", "length", "form", "doc", "ind", "type", "parent", "pc", "trans", "top", "loc", "mut", "pose", "pre", "key", "nt", "gen", "no", "block", "index", "bit", "max", "axis", "cond", "o", "pi", "oss", "params", "ref", "point", "out", "state", "col", "new", "p", "list", "neg", "port", "len", "pointer", "spec", "row", "body", "post"], "pdev": ["ppDev", "pdiv", "predev", "vdo", "vdata", "kdevice", "PDev", "psys", "Pdevice", "pserver", "kDev", "prodevice", " pDEV", "wpDEV", "pdevice", "kdev", "vconn", "predevice", " pdiv", "wpdevice", " papi", "vdiv", "vDEV", "vany", "powerdev", "powerserver", "mdev", "ppany", "pany", "prodef", "cpdev", "vsys", "pDev", "vDev", "preDev", "powerdevice", "pdata", "wpdef", "tconn", "cpdevice", "hdev", "mDev", "mdevice", "pev", "tdev", "vev", "prodev", " pdevice", "pdef", " pany", "powerdiv", "cpconn", "vserver", "vapi", "Pdef", " pdata", " pdef", "vdevice", "cpDev", " psys", "tdevice", " pserver", "tDev", "pDEV", "kev", " pdo", "hDev", "proDev", "pconn", "ppdev", "hev", "Pdev", "predata", "pdo", " pDev", "tapi", "vdef", "msys", "papi", "ppdo", "hdevice", "wpdev"], "cap_id": ["capxtype", "capJinfo", "cap_bid", "cap___ide", "cap0url", "cap_len", "cap_ide", "capitysid", "cap___bid", "var___ide", "cap___id", " cap_info", "cap_info", "cap0id", "cap___type", "var_bid", " cap_try", "capameaid", "cap_ID", "capameID", "cap2id", "capameid", "cap2len", " cap_type", "cap_mid", "capJid", "cap2sid", " cap_def", " cap_aid", "cap_Id", "capxaid", "capxid", "cap_try", " cap_mid", "cap2Id", "clip_sid", "capityid", "var___type", "cap___Id", "cap_url", " cap_Id", "cap___mid", "var_id", "var_ide", "clip_len", "cap_aid", "cap_sid", "capJtry", " cap_url", "clip_id", "capametype", "cap0info", " cap_ID", "capxID", "var___id", "clip_Id", "var_type", "var___bid", "capJdef", "capityId", "cap_def", "cap0Id", "capitylen", "cap_type"], "next": ["ref", "jp", "end", "elt", "tmp", "last", "nd", "then", "success", "status", "txt", "buf", "new", "li", "Next", "append", "set", "list", "start", "ptr", "key", "any", "ner", "sent", "mk", "ne", "big", "entry", "chain", "sec", "ng", "gen", "len", "path", "index", "done", "after", "primary", "max", "seq", "nl", "prev", "more", "net", "body", "link", "config", "future", "gov", "first", "current"], "size": ["shape", "ize", "sum", "l", "sn", "type", "send", "SIZE", "z", "format", "full", "small", "space", "city", "scale", "set", "s", "empty", "sent", "name", "min", "mem", "dim", "big", "news", "box", "count", "len", "total", "sp", "spec", "unit", "loss", "g", "sh", "limit", "large", "sw", "grow", "cap", "msg", "sym", "max", "zone", "fee", "body", "Size", "scope", "length", "form", "fit"], "ret": ["status", "success", "re", "Ret", "mem", "att", "rect", "it", "ter", "rets", "verified", "gb", "rem", "details", " alt", "dt", "last", "txt", "hash", "full", "xt", "def", "jump", "tr", "mb", "flag", "repl", "res", "after", "bool", "try", "t", "net", "get", "resp", "print", "rel", "sum", "RET", "pret", "summary", "format", "ext", "arr", "err", "Return", "alt", "nt", "red", "rm", "mt", "det", "gt", "arg", "grain", "rt", "val", "ft", "ref", "elt", "out", "reg", "result", "desc", "rev", "box", "iter", "len", "fun", "cont", "back", "ll", " Ret", "lit", "rest", "reset", "backed"]}}
{"project": "qemu", "commit_id": "fb9fb692312a84ebc6e9c10da6f374c5871ff7b0", "target": 0, "func": "int cpu_exec(CPUState *env1)\n\n{\n\n#define DECLARE_HOST_REGS 1\n\n#include \"hostregs_helper.h\"\n\n    int ret, interrupt_request;\n\n    TranslationBlock *tb;\n\n    uint8_t *tc_ptr;\n\n    unsigned long next_tb;\n\n\n\n    if (cpu_halted(env1) == EXCP_HALTED)\n\n        return EXCP_HALTED;\n\n\n\n    cpu_single_env = env1;\n\n\n\n    /* first we save global registers */\n\n#define SAVE_HOST_REGS 1\n\n#include \"hostregs_helper.h\"\n\n    env = env1;\n\n\n\n#if defined(TARGET_I386)\n\n    /* put eflags in CPU temporary format */\n\n    CC_SRC = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n    DF = 1 - (2 * ((env->eflags >> 10) & 1));\n\n    CC_OP = CC_OP_EFLAGS;\n\n    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n#elif defined(TARGET_SPARC)\n\n#elif defined(TARGET_M68K)\n\n    env->cc_op = CC_OP_FLAGS;\n\n    env->cc_dest = env->sr & 0xf;\n\n    env->cc_x = (env->sr >> 4) & 1;\n\n#elif defined(TARGET_ALPHA)\n\n#elif defined(TARGET_ARM)\n\n#elif defined(TARGET_PPC)\n\n#elif defined(TARGET_MICROBLAZE)\n\n#elif defined(TARGET_MIPS)\n\n#elif defined(TARGET_SH4)\n\n#elif defined(TARGET_CRIS)\n\n#elif defined(TARGET_S390X)\n\n    /* XXXXX */\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n    env->exception_index = -1;\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    for(;;) {\n\n        if (setjmp(env->jmp_env) == 0) {\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n            /* if an exception is pending, we execute it here */\n\n            if (env->exception_index >= 0) {\n\n                if (env->exception_index >= EXCP_INTERRUPT) {\n\n                    /* exit request from the cpu execution loop */\n\n                    ret = env->exception_index;\n\n                    if (ret == EXCP_DEBUG)\n\n                        cpu_handle_debug_exception(env);\n\n                    break;\n\n                } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n                    /* if user mode only, we simulate a fake exception\n\n                       which will be handled outside the cpu execution\n\n                       loop */\n\n#if defined(TARGET_I386)\n\n                    do_interrupt_user(env->exception_index,\n\n                                      env->exception_is_int,\n\n                                      env->error_code,\n\n                                      env->exception_next_eip);\n\n                    /* successfully delivered */\n\n                    env->old_exception = -1;\n\n#endif\n\n                    ret = env->exception_index;\n\n                    break;\n\n#else\n\n#if defined(TARGET_I386)\n\n                    /* simulate a real cpu exception. On i386, it can\n\n                       trigger new exceptions, but we do not handle\n\n                       double or triple faults yet. */\n\n                    do_interrupt(env->exception_index,\n\n                                 env->exception_is_int,\n\n                                 env->error_code,\n\n                                 env->exception_next_eip, 0);\n\n                    /* successfully delivered */\n\n                    env->old_exception = -1;\n\n#elif defined(TARGET_PPC)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_MIPS)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_SPARC)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_ARM)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_SH4)\n\n\t\t    do_interrupt(env);\n\n#elif defined(TARGET_ALPHA)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_CRIS)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_M68K)\n\n                    do_interrupt(0);\n\n#endif\n\n                    env->exception_index = -1;\n\n#endif\n\n                }\n\n            }\n\n\n\n            if (kvm_enabled()) {\n\n                kvm_cpu_exec(env);\n\n                longjmp(env->jmp_env, 1);\n\n            }\n\n\n\n            next_tb = 0; /* force lookup of first TB */\n\n            for(;;) {\n\n                interrupt_request = env->interrupt_request;\n\n                if (unlikely(interrupt_request)) {\n\n                    if (unlikely(env->singlestep_enabled & SSTEP_NOIRQ)) {\n\n                        /* Mask out external interrupts for this step. */\n\n                        interrupt_request &= ~(CPU_INTERRUPT_HARD |\n\n                                               CPU_INTERRUPT_FIQ |\n\n                                               CPU_INTERRUPT_SMI |\n\n                                               CPU_INTERRUPT_NMI);\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n\n                        env->exception_index = EXCP_DEBUG;\n\n                        cpu_loop_exit();\n\n                    }\n\n#if defined(TARGET_ARM) || defined(TARGET_SPARC) || defined(TARGET_MIPS) || \\\n\n    defined(TARGET_PPC) || defined(TARGET_ALPHA) || defined(TARGET_CRIS) || \\\n\n    defined(TARGET_MICROBLAZE)\n\n                    if (interrupt_request & CPU_INTERRUPT_HALT) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_HALT;\n\n                        env->halted = 1;\n\n                        env->exception_index = EXCP_HLT;\n\n                        cpu_loop_exit();\n\n                    }\n\n#endif\n\n#if defined(TARGET_I386)\n\n                    if (interrupt_request & CPU_INTERRUPT_INIT) {\n\n                            svm_check_intercept(SVM_EXIT_INIT);\n\n                            do_cpu_init(env);\n\n                            env->exception_index = EXCP_HALTED;\n\n                            cpu_loop_exit();\n\n                    } else if (interrupt_request & CPU_INTERRUPT_SIPI) {\n\n                            do_cpu_sipi(env);\n\n                    } else if (env->hflags2 & HF2_GIF_MASK) {\n\n                        if ((interrupt_request & CPU_INTERRUPT_SMI) &&\n\n                            !(env->hflags & HF_SMM_MASK)) {\n\n                            svm_check_intercept(SVM_EXIT_SMI);\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_SMI;\n\n                            do_smm_enter();\n\n                            next_tb = 0;\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                                   !(env->hflags2 & HF2_NMI_MASK)) {\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_NMI;\n\n                            env->hflags2 |= HF2_NMI_MASK;\n\n                            do_interrupt(EXCP02_NMI, 0, 0, 0, 1);\n\n                            next_tb = 0;\n\n\t\t\t} else if (interrupt_request & CPU_INTERRUPT_MCE) {\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_MCE;\n\n                            do_interrupt(EXCP12_MCHK, 0, 0, 0, 0);\n\n                            next_tb = 0;\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                                   (((env->hflags2 & HF2_VINTR_MASK) && \n\n                                     (env->hflags2 & HF2_HIF_MASK)) ||\n\n                                    (!(env->hflags2 & HF2_VINTR_MASK) && \n\n                                     (env->eflags & IF_MASK && \n\n                                      !(env->hflags & HF_INHIBIT_IRQ_MASK))))) {\n\n                            int intno;\n\n                            svm_check_intercept(SVM_EXIT_INTR);\n\n                            env->interrupt_request &= ~(CPU_INTERRUPT_HARD | CPU_INTERRUPT_VIRQ);\n\n                            intno = cpu_get_pic_interrupt(env);\n\n                            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"Servicing hardware INT=0x%02x\\n\", intno);\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n                            do_interrupt(intno, 0, 0, 0, 1);\n\n                            /* ensure that no TB jump will be modified as\n\n                               the program flow was changed */\n\n                            next_tb = 0;\n\n#if !defined(CONFIG_USER_ONLY)\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_VIRQ) &&\n\n                                   (env->eflags & IF_MASK) && \n\n                                   !(env->hflags & HF_INHIBIT_IRQ_MASK)) {\n\n                            int intno;\n\n                            /* FIXME: this should respect TPR */\n\n                            svm_check_intercept(SVM_EXIT_VINTR);\n\n                            intno = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_vector));\n\n                            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"Servicing virtual hardware INT=0x%02x\\n\", intno);\n\n                            do_interrupt(intno, 0, 0, 0, 1);\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_VIRQ;\n\n                            next_tb = 0;\n\n#endif\n\n                        }\n\n                    }\n\n#elif defined(TARGET_PPC)\n\n#if 0\n\n                    if ((interrupt_request & CPU_INTERRUPT_RESET)) {\n\n                        cpu_reset(env);\n\n                    }\n\n#endif\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        ppc_hw_interrupt(env);\n\n                        if (env->pending_interrupts == 0)\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_HARD;\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    if ((interrupt_request & CPU_INTERRUPT_HARD)\n\n                        && (env->sregs[SR_MSR] & MSR_IE)\n\n                        && !(env->sregs[SR_MSR] & (MSR_EIP | MSR_BIP))\n\n                        && !(env->iflags & (D_FLAG | IMM_FLAG))) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_MIPS)\n\n                    if ((interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                        (env->CP0_Status & env->CP0_Cause & CP0Ca_IP_mask) &&\n\n                        (env->CP0_Status & (1 << CP0St_IE)) &&\n\n                        !(env->CP0_Status & (1 << CP0St_EXL)) &&\n\n                        !(env->CP0_Status & (1 << CP0St_ERL)) &&\n\n                        !(env->hflags & MIPS_HFLAG_DM)) {\n\n                        /* Raise it */\n\n                        env->exception_index = EXCP_EXT_INTERRUPT;\n\n                        env->error_code = 0;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_SPARC)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        if (cpu_interrupts_enabled(env) &&\n\n                            env->interrupt_index > 0) {\n\n                            int pil = env->interrupt_index & 0xf;\n\n                            int type = env->interrupt_index & 0xf0;\n\n\n\n                            if (((type == TT_EXTINT) &&\n\n                                  cpu_pil_allowed(env, pil)) ||\n\n                                  type != TT_EXTINT) {\n\n                                env->exception_index = env->interrupt_index;\n\n                                do_interrupt(env);\n\n                                next_tb = 0;\n\n                            }\n\n                        }\n\n\t\t    } else if (interrupt_request & CPU_INTERRUPT_TIMER) {\n\n\t\t\t//do_interrupt(0, 0, 0, 0, 0);\n\n\t\t\tenv->interrupt_request &= ~CPU_INTERRUPT_TIMER;\n\n\t\t    }\n\n#elif defined(TARGET_ARM)\n\n                    if (interrupt_request & CPU_INTERRUPT_FIQ\n\n                        && !(env->uncached_cpsr & CPSR_F)) {\n\n                        env->exception_index = EXCP_FIQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n                    /* ARMv7-M interrupt return works by loading a magic value\n\n                       into the PC.  On real hardware the load causes the\n\n                       return to occur.  The qemu implementation performs the\n\n                       jump normally, then does the exception return when the\n\n                       CPU tries to execute code at the magic address.\n\n                       This will cause the magic PC value to be pushed to\n\n                       the stack if an interrupt occured at the wrong time.\n\n                       We avoid this by disabling interrupts when\n\n                       pc contains a magic address.  */\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && ((IS_M(env) && env->regs[15] < 0xfffffff0)\n\n                            || !(env->uncached_cpsr & CPSR_I))) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_SH4)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_ALPHA)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_CRIS)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && (env->pregs[PR_CCS] & I_FLAG)) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_NMI\n\n                        && (env->pregs[PR_CCS] & M_FLAG)) {\n\n                        env->exception_index = EXCP_NMI;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_M68K)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && ((env->sr & SR_I) >> SR_I_SHIFT)\n\n                            < env->pending_level) {\n\n                        /* Real hardware gets the interrupt vector via an\n\n                           IACK cycle at this point.  Current emulated\n\n                           hardware doesn't rely on this, so we\n\n                           provide/save the vector when the interrupt is\n\n                           first signalled.  */\n\n                        env->exception_index = env->pending_vector;\n\n                        do_interrupt(1);\n\n                        next_tb = 0;\n\n                    }\n\n#endif\n\n                   /* Don't use the cached interupt_request value,\n\n                      do_interrupt may have updated the EXITTB flag. */\n\n                    if (env->interrupt_request & CPU_INTERRUPT_EXITTB) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n\n                        /* ensure that no TB jump will be modified as\n\n                           the program flow was changed */\n\n                        next_tb = 0;\n\n                    }\n\n                }\n\n                if (unlikely(env->exit_request)) {\n\n                    env->exit_request = 0;\n\n                    env->exception_index = EXCP_INTERRUPT;\n\n                    cpu_loop_exit();\n\n                }\n\n#ifdef CONFIG_DEBUG_EXEC\n\n                if (qemu_loglevel_mask(CPU_LOG_TB_CPU)) {\n\n                    /* restore flags in standard format */\n\n#if defined(TARGET_I386)\n\n                    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);\n\n                    log_cpu_state(env, X86_DUMP_CCOP);\n\n                    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n#elif defined(TARGET_ARM)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_SPARC)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_PPC)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_M68K)\n\n                    cpu_m68k_flush_flags(env, env->cc_op);\n\n                    env->cc_op = CC_OP_FLAGS;\n\n                    env->sr = (env->sr & 0xffe0)\n\n                              | env->cc_dest | (env->cc_x << 4);\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_MIPS)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_SH4)\n\n\t\t    log_cpu_state(env, 0);\n\n#elif defined(TARGET_ALPHA)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_CRIS)\n\n                    log_cpu_state(env, 0);\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n                }\n\n#endif\n\n                spin_lock(&tb_lock);\n\n                tb = tb_find_fast();\n\n                /* Note: we do it here to avoid a gcc bug on Mac OS X when\n\n                   doing it in tb_find_slow */\n\n                if (tb_invalidated_flag) {\n\n                    /* as some TB could have been invalidated because\n\n                       of memory exceptions while generating the code, we\n\n                       must recompute the hash index here */\n\n                    next_tb = 0;\n\n                    tb_invalidated_flag = 0;\n\n                }\n\n#ifdef CONFIG_DEBUG_EXEC\n\n                qemu_log_mask(CPU_LOG_EXEC, \"Trace 0x%08lx [\" TARGET_FMT_lx \"] %s\\n\",\n\n                             (long)tb->tc_ptr, tb->pc,\n\n                             lookup_symbol(tb->pc));\n\n#endif\n\n                /* see if we can patch the calling TB. When the TB\n\n                   spans two pages, we cannot safely do a direct\n\n                   jump. */\n\n                if (next_tb != 0 && tb->page_addr[1] == -1) {\n\n                    tb_add_jump((TranslationBlock *)(next_tb & ~3), next_tb & 3, tb);\n\n                }\n\n                spin_unlock(&tb_lock);\n\n\n\n                /* cpu_interrupt might be called while translating the\n\n                   TB, but before it is linked into a potentially\n\n                   infinite loop and becomes env->current_tb. Avoid\n\n                   starting execution if there is a pending interrupt. */\n\n                if (!unlikely (env->exit_request)) {\n\n                    env->current_tb = tb;\n\n                    tc_ptr = tb->tc_ptr;\n\n                /* execute the generated code */\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n                    next_tb = tcg_qemu_tb_exec(tc_ptr);\n\n                    env->current_tb = NULL;\n\n                    if ((next_tb & 3) == 2) {\n\n                        /* Instruction counter expired.  */\n\n                        int insns_left;\n\n                        tb = (TranslationBlock *)(long)(next_tb & ~3);\n\n                        /* Restore PC.  */\n\n                        cpu_pc_from_tb(env, tb);\n\n                        insns_left = env->icount_decr.u32;\n\n                        if (env->icount_extra && insns_left >= 0) {\n\n                            /* Refill decrementer and continue execution.  */\n\n                            env->icount_extra += insns_left;\n\n                            if (env->icount_extra > 0xffff) {\n\n                                insns_left = 0xffff;\n\n                            } else {\n\n                                insns_left = env->icount_extra;\n\n                            }\n\n                            env->icount_extra -= insns_left;\n\n                            env->icount_decr.u16.low = insns_left;\n\n                        } else {\n\n                            if (insns_left > 0) {\n\n                                /* Execute remaining instructions.  */\n\n                                cpu_exec_nocache(insns_left, tb);\n\n                            }\n\n                            env->exception_index = EXCP_INTERRUPT;\n\n                            next_tb = 0;\n\n                            cpu_loop_exit();\n\n                        }\n\n                    }\n\n                }\n\n                /* reset soft MMU for next block (it can currently\n\n                   only be set by a memory fault) */\n\n            } /* for(;;) */\n\n        }\n\n    } /* for(;;) */\n\n\n\n\n\n#if defined(TARGET_I386)\n\n    /* restore flags in standard format */\n\n    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);\n\n#elif defined(TARGET_ARM)\n\n    /* XXX: Save/restore host fpu exception state?.  */\n\n#elif defined(TARGET_SPARC)\n\n#elif defined(TARGET_PPC)\n\n#elif defined(TARGET_M68K)\n\n    cpu_m68k_flush_flags(env, env->cc_op);\n\n    env->cc_op = CC_OP_FLAGS;\n\n    env->sr = (env->sr & 0xffe0)\n\n              | env->cc_dest | (env->cc_x << 4);\n\n#elif defined(TARGET_MICROBLAZE)\n\n#elif defined(TARGET_MIPS)\n\n#elif defined(TARGET_SH4)\n\n#elif defined(TARGET_ALPHA)\n\n#elif defined(TARGET_CRIS)\n\n#elif defined(TARGET_S390X)\n\n    /* XXXXX */\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n\n\n    /* restore global registers */\n\n#include \"hostregs_helper.h\"\n\n\n\n    /* fail safe : never use cpu_single_env outside cpu_exec() */\n\n    cpu_single_env = NULL;\n\n    return ret;\n\n}\n", "idx": 12451, "substitutes": {"env1": [" env001", "eve6", "eve2", "en2", "environment001", "env0", "env001", "v1", " env0", "environment2", "en0", "en1", "nv3", "en3", "ev2", " env3", "ev1", "ev3", "v0", "eve1", "ev0", "env2", "env6", " env6", "nv1", "environment1", "eve001", " env2", "nv2", "nv0", "v2", "v3", "env3", "environment6"], "ret": ["rel", "ft", "req", "RET", "elt", "dt", "status", "txt", "out", "re", "reply", "result", "Ret", "er", " RET", "def", "xt", "tf", "tr", "flag", "Return", "mem", "alt", "nt", "len", "over", "eth", "res", "data", "inter", "mt", "det", "el", "try", "t", "arg", "ter", "resp", "rt", "val", "reset"], "interrupt_request": ["interrupt_thread", "interruptingthread", "interror_proc", "interror_thread", "interruptingproc", "interror_request", "interruptingreq", "interruptingrequest", "interrupt_proc", "interror_req", "interrupt_req"], "tb": ["ttbl", "trmb", " tbl", "tbe", "ttb", "ttbe", "ttmb", " tbe", " tmb", "trbe", "trbl", "tmb", "tbl", "trb"], "tc_ptr": ["TC_ptr", "tc_tr", "TC_bp", "TC_tr", "tc__tr", "tc__ptr", "TC_pointer", "tc__pointer", "tc_bp", "tc__bp", "tc_pointer"], "next_tb": ["next_newbuf", "next_tbuf", "next_lb", "next_lbuf", "next_lib", "next_tib", "next_newb", "next_newib"]}}
{"project": "qemu", "commit_id": "42a6686b2f6199d086a58edd7731faeb2dbe7c14", "target": 0, "func": "void HELPER(v7m_msr)(CPUARMState *env, uint32_t maskreg, uint32_t val)\n\n{\n\n    /* We're passed bits [11..0] of the instruction; extract\n\n     * SYSm and the mask bits.\n\n     * Invalid combinations of SYSm and mask are UNPREDICTABLE;\n\n     * we choose to treat them as if the mask bits were valid.\n\n     * NB that the pseudocode 'mask' variable is bits [11..10],\n\n     * whereas ours is [11..8].\n\n     */\n\n    uint32_t mask = extract32(maskreg, 8, 4);\n\n    uint32_t reg = extract32(maskreg, 0, 8);\n\n\n\n    if (arm_current_el(env) == 0 && reg > 7) {\n\n        /* only xPSR sub-fields may be written by unprivileged */\n\n        return;\n\n    }\n\n\n\n    switch (reg) {\n\n    case 0 ... 7: /* xPSR sub-fields */\n\n        /* only APSR is actually writable */\n\n        if (!(reg & 4)) {\n\n            uint32_t apsrmask = 0;\n\n\n\n            if (mask & 8) {\n\n                apsrmask |= XPSR_NZCV | XPSR_Q;\n\n            }\n\n            if ((mask & 4) && arm_feature(env, ARM_FEATURE_THUMB_DSP)) {\n\n                apsrmask |= XPSR_GE;\n\n            }\n\n            xpsr_write(env, val, apsrmask);\n\n        }\n\n        break;\n\n    case 8: /* MSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->v7m.other_sp = val;\n\n        } else {\n\n            env->regs[13] = val;\n\n        }\n\n        break;\n\n    case 9: /* PSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->regs[13] = val;\n\n        } else {\n\n            env->v7m.other_sp = val;\n\n        }\n\n        break;\n\n    case 16: /* PRIMASK */\n\n        env->v7m.primask[env->v7m.secure] = val & 1;\n\n        break;\n\n    case 17: /* BASEPRI */\n\n        env->v7m.basepri[env->v7m.secure] = val & 0xff;\n\n        break;\n\n    case 18: /* BASEPRI_MAX */\n\n        val &= 0xff;\n\n        if (val != 0 && (val < env->v7m.basepri[env->v7m.secure]\n\n                         || env->v7m.basepri[env->v7m.secure] == 0)) {\n\n            env->v7m.basepri[env->v7m.secure] = val;\n\n        }\n\n        break;\n\n    case 19: /* FAULTMASK */\n\n        env->v7m.faultmask = val & 1;\n\n        break;\n\n    case 20: /* CONTROL */\n\n        /* Writing to the SPSEL bit only has an effect if we are in\n\n         * thread mode; other bits can be updated by any privileged code.\n\n         * switch_v7m_sp() deals with updating the SPSEL bit in\n\n         * env->v7m.control, so we only need update the others.\n\n         */\n\n        if (!arm_v7m_is_handler_mode(env)) {\n\n            switch_v7m_sp(env, (val & R_V7M_CONTROL_SPSEL_MASK) != 0);\n\n        }\n\n        env->v7m.control &= ~R_V7M_CONTROL_NPRIV_MASK;\n\n        env->v7m.control |= val & R_V7M_CONTROL_NPRIV_MASK;\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"Attempt to write unknown special\"\n\n                                       \" register %d\\n\", reg);\n\n        return;\n\n    }\n\n}\n", "idx": 12452, "substitutes": {"env": ["ey", "timer", "esm", "image", "server", "nv", "addr", "np", "cb", "eng", "org", "ptr", "et", "pg", "door", "cv", "engine", "sw", "den", "esc", "man", "vm", "event", "context", "h", "worker", "info", "cache", "end", "sb", "serv", "tmp", "esp", "here", "txt", "peer", "init", "er", "enter", "set", "operator", "client", "m", "vp", "ah", "code", "vt", "eh", "erd", "era", "ten", "iv", "en", "conn", "msg", "enc", "em", "net", "tm", "cmd", "policy", "doc", "query", "ee", "req", "menu", "ve", "app", "die", "rb", "ext", "uv", "err", "vs", "te", "console", "ent", "ev", "ew", "eni", "gate", "proc", "ec", "var", "queue", "runner", "extra", "state", "hw", "conf", "environment", "desc", "ner", "port", "entry", "e", "dev", "window", "db", "remote", "estate", "ctx", "exc", "manager", "erb", "act", "gear", "ped", "self", "equ", "v", "gov", "obj", "w"], "maskreg": ["cleareng", "maskr", "missr", "maskmem", "clearreg", "mapreg", "askmem", "mapReg", "askReg", "mapmem", "clearReg", "askREG", "askeng", "askr", "mapeng", "askregister", "missreg", "holdREG", "maskeng", " maskmem", "holdr", " maskr", "maskREG", "mapREG", "holdregister", "askreg", "maskReg", "maskregister", "missregister", "missREG", "mapr", " maskReg", "clearREG", "holdreg"], "val": ["ey", "ch", "eval", "bl", "addr", "valid", "Value", "pos", "mem", "ret", "it", "vals", "pt", "pr", "prop", "serv", "slot", "def", "vec", "tag", "m", "buffer", "vt", "res", "num", "msg", "try", "fail", "resp", "ind", "l", "pol", "pret", "x", "value", "buf", "pl", "arr", "err", "key", "alt", "al", "index", "bit", "values", "item", "data", "arg", "var", "rec", "cal", "Val", "ref", "elt", "z", "tx", "cur", "reg", "sel", "conf", "ver", "p", "VAL", "dev", "xy", "ctx", "str", "pal", "bin", "el", "func", "test", "vol", "crit", "v", "obj"]}}
{"project": "qemu", "commit_id": "d7651f150d61936344c4fab45eaeb0716c606af2", "target": 0, "func": "static bool migrate_caps_check(bool *cap_list,\n\n                               MigrationCapabilityStatusList *params,\n\n                               Error **errp)\n\n{\n\n    MigrationCapabilityStatusList *cap;\n\n    bool old_postcopy_cap;\n\n\n\n    old_postcopy_cap = cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM];\n\n\n\n    for (cap = params; cap; cap = cap->next) {\n\n        cap_list[cap->value->capability] = cap->value->state;\n\n    }\n\n\n\n#ifndef CONFIG_LIVE_BLOCK_MIGRATION\n\n    if (cap_list[MIGRATION_CAPABILITY_BLOCK]) {\n\n        error_setg(errp, \"QEMU compiled without old-style (blk/-b, inc/-i) \"\n\n                   \"block migration\");\n\n        error_append_hint(errp, \"Use drive_mirror+NBD instead.\\n\");\n\n        return false;\n\n    }\n\n#endif\n\n\n\n    if (cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]) {\n\n        if (cap_list[MIGRATION_CAPABILITY_COMPRESS]) {\n\n            /* The decompression threads asynchronously write into RAM\n\n             * rather than use the atomic copies needed to avoid\n\n             * userfaulting.  It should be possible to fix the decompression\n\n             * threads for compatibility in future.\n\n             */\n\n            error_setg(errp, \"Postcopy is not currently compatible \"\n\n                       \"with compression\");\n\n            return false;\n\n        }\n\n\n\n        /* This check is reasonably expensive, so only when it's being\n\n         * set the first time, also it's only the destination that needs\n\n         * special support.\n\n         */\n\n        if (!old_postcopy_cap && runstate_check(RUN_STATE_INMIGRATE) &&\n\n            !postcopy_ram_supported_by_host()) {\n\n            /* postcopy_ram_supported_by_host will have emitted a more\n\n             * detailed message\n\n             */\n\n            error_setg(errp, \"Postcopy is not supported\");\n\n            return false;\n\n        }\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 12470, "substitutes": {"cap_list": ["caps2local", "cap_lists", "act_list", "cap8local", "cap_collection", "act_listed", "cap2local", "cap_pair", "caps_lower", "conn_out", "cap_LIST", "conn_collection", "caps_local", "caps_List", "CAP_lists", "caps_map", "capixlower", "cap0out", "caps2list", "caps_list", "capixLIST", "cap__map", "caps_LIST", "cap_map", "caps2List", "cap2list", "cap8List", "cap0list", "conn_chain", "cap_local", "cap__local", "ip_listed", "act_pair", "act_str", "cap0chain", "ip_List", "caps2map", "CAP_list", "cap8map", "cap_str", "cap2map", "capixlist", "cap_List", "CAP_def", "conn_list", "cap2List", "cap__list", "caps_lists", "cap_lower", "cap__List", "cap8list", "cap_chain", "cap_listed", "capixlists", "ip_lists", "ip_list", "cap0collection", "cap_out", "cap_def"], "params": ["abilities", "rs", "changes", "cms", "spe", "amps", "pool", "cmp", "cp", "conf", "ams", "ps", "pas", "sys", "scan", "list", "args", "users", "ports", "js", "names", "members", "ctx", "sp", "spec", "mas", "caps", "pins", "aps", "pres", "param", "attr", "phys", "properties", "actions", "cs", "par", "stats", "parts", "headers"], "errp": ["attrpat", "rrphp", "ierphp", "errphp", "corphp", "ererp", "eorpkg", "derpat", "rerpre", " errP", "eorphp", "arrphp", "arrp", "arrping", " errpa", "rerphp", "errcp", " errpb", "corpkg", "errpad", " erp", "derp", "derpkg", "timerpkg", "dercp", "errpb", "errP", "ererpb", "corp", "eorp", "attrp", "rrp", "corpm", "ierpm", "diepad", "rrpre", "ierpkg", "attrpkg", "errping", "timerp", "rerping", "arrpre", "rerp", "ererP", "ererpad", "errpm", "rrpa", "errpat", "ierp", " erpa", "errpa", "rrping", " erpre", "timercp", "errpre", "diep", "diepb", "timerpat", "errpkg", "dieP", " errpre", "attrcp", "eorpm", " errpad"], "cap": ["shape", "rip", "prop", "av", "map", "serv", "bc", "save", "fac", "lat", "ctrl", "cas", "ip", "buf", "cmp", "clip", "cat", "c", "cp", "comm", "bridge", "ap", "ps", "pl", "p", "pen", "core", "cam", "ach", "cast", "sam", "cfg", "CAP", "port", "mp", "parse", "ctx", "sp", "cv", "Cap", "ann", "op", "caps", "cf", "act", "cod", "aps", "watch", "cl", "ct", "copy", "pack", "capt", "lip", "aw", "ca", "acc", "snap", "sc", "pan", "feature", "cmd", "ac", "pp", "v", "var", "ship", "can"], "old_postcopy_cap": ["old_postcopy2cap", "old_postcop_cap", "old_postcap_caps", "old_postcap_CAP", "old_postcopy2ap", "old_postcop_ip", "old_postcopy__port", "old_postcopy_cp", "old_postcopy2caps", "old_postcopy_CAP", "old_postcopy_ip", "old_postcopy__caps", "old_postcopy__cmp", "old_postcopy_ap", "old_postcop_cp", "old_postcop_caps", "old_postcopy_port", "old_postcopy_caps", "old_postcopy__cap", "old_postcopy2CAP", "old_postcopy_cmp", "old_postcap_ap", "old_postcopyedcaps", "old_postcap_cap", "old_postcopyedport", "old_postcopyedcap", "old_postcopyedcmp"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,\n\n    bool is_read)\n\n{\n\n    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);\n\n    VirtIOBlock *s = req->dev;\n\n\n\n    if (action == BLOCK_ERROR_ACTION_STOP) {\n\n        req->next = s->rq;\n\n        s->rq = req;\n\n    } else if (action == BLOCK_ERROR_ACTION_REPORT) {\n\n        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);\n\n        block_acct_done(bdrv_get_stats(s->bs), &req->acct);\n\n        virtio_blk_free_request(req);\n\n    }\n\n\n\n    bdrv_error_action(s->bs, action, is_read, error);\n\n    return action != BLOCK_ERROR_ACTION_IGNORE;\n\n}\n", "idx": 12477, "substitutes": {"req": ["pkg", "requ", "ind", "jp", "ref", "rs", "comp", "sol", "tmp", "progress", "ck", "txt", "tx", "next", "gz", "compl", "reg", "result", "Requ", "q", "comm", "ps", "ext", "p", "r", "err", "urg", "pro", "rx", "desc", "good", "qq", "rd", "md", "js", "mp", "rr", "rss", "ctx", "request", "decl", "each", "ret", "index", "ack", "res", "j", "sq", "msg", "fr", "seq", "dq", "prev", "self", "quest", "crit", "gr", "resp", "wx", "cmd", "inv", "cr", "rw", "rec", "obj", "aux", "qt", "query", "rem"], "error": ["event", "detail", "entity", "ror", "info", "type", "Error", "address", "problem", "status", "success", "style", "re", "ion", "state", "anger", "result", "resource", "terror", "er", " Error", "change", "err", "r", "action", "timeout", "code", "danger", "attribute", "ack", "instance", "mode", "exclusive", "offset", "rage", "ity", "comment", "iso", "bug", "order", " ERROR", "ERROR", "debug", "option", "command", "failed", "or", "owner"], "is_read": ["isTruerequired", "ispErequired", "isp_full", " is_readable", "is__read", "is_full", "ispEreading", "isTrueread", " is_reader", "isEread", "isTruefull", "is_reads", " is_connect", "is_required", "is_write", "isEfull", "isp_reading", "is_reader", "is__write", "is_reading", "is__connect", "isTruereading", "ispEfull", " is_write", "is_readable", "isp_required", "is_connect", "isEreading", "isErequired", "is__readable", "isp_read", "ispEread", " is_reads"], "s": ["bs", "h", "l", "rs", "sb", "sl", "ies", "S", "os", "sv", "q", "c", "ps", "comm", "conf", "sub", "p", "sys", "ess", "es", "r", "m", "ls", "vs", "hs", "ms", "gs", "b", "js", "sp", "spec", "sts", "bis", "g", "res", "j", "sq", "less", "gets", "t", "self", "ds", "se", "cs", "ts", "is", "bits", "y", "ins", "v", "qs", "ns", "ss"]}}
{"project": "FFmpeg", "commit_id": "45198477de19ccb00729b7eec07d81494f0353e0", "target": 1, "func": "static inline void FUNC(idctRowCondDC_extrashift)(int16_t *row, int extra_shift)\n\n#else\n\nstatic inline void FUNC(idctRowCondDC)(int16_t *row, int extra_shift)\n\n#endif\n\n{\n\n    int a0, a1, a2, a3, b0, b1, b2, b3;\n\n\n\n#if HAVE_FAST_64BIT\n\n#define ROW0_MASK (0xffffLL << 48 * HAVE_BIGENDIAN)\n\n    if (((AV_RN64A(row) & ~ROW0_MASK) | AV_RN64A(row+4)) == 0) {\n\n        uint64_t temp;\n\n        if (DC_SHIFT - extra_shift >= 0) {\n\n            temp = (row[0] * (1 << (DC_SHIFT - extra_shift))) & 0xffff;\n\n        } else {\n\n            temp = ((row[0] + (1<<(extra_shift - DC_SHIFT-1))) >> (extra_shift - DC_SHIFT)) & 0xffff;\n\n        }\n\n        temp += temp * (1 << 16);\n\n        temp += temp * ((uint64_t) 1 << 32);\n\n        AV_WN64A(row, temp);\n\n        AV_WN64A(row + 4, temp);\n\n        return;\n\n    }\n\n#else\n\n    if (!(AV_RN32A(row+2) |\n\n          AV_RN32A(row+4) |\n\n          AV_RN32A(row+6) |\n\n          row[1])) {\n\n        uint32_t temp;\n\n        if (DC_SHIFT - extra_shift >= 0) {\n\n            temp = (row[0] * (1 << (DC_SHIFT - extra_shift))) & 0xffff;\n\n        } else {\n\n            temp = ((row[0] + (1<<(extra_shift - DC_SHIFT-1))) >> (extra_shift - DC_SHIFT)) & 0xffff;\n\n        }\n\n        temp += temp * (1 << 16);\n\n        AV_WN32A(row, temp);\n\n        AV_WN32A(row+2, temp);\n\n        AV_WN32A(row+4, temp);\n\n        AV_WN32A(row+6, temp);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    a0 = (W4 * row[0]) + (1 << (ROW_SHIFT + extra_shift - 1));\n\n    a1 = a0;\n\n    a2 = a0;\n\n    a3 = a0;\n\n\n\n    a0 += W2 * row[2];\n\n    a1 += W6 * row[2];\n\n    a2 -= W6 * row[2];\n\n    a3 -= W2 * row[2];\n\n\n\n    b0 = MUL(W1, row[1]);\n\n    MAC(b0, W3, row[3]);\n\n    b1 = MUL(W3, row[1]);\n\n    MAC(b1, -W7, row[3]);\n\n    b2 = MUL(W5, row[1]);\n\n    MAC(b2, -W1, row[3]);\n\n    b3 = MUL(W7, row[1]);\n\n    MAC(b3, -W5, row[3]);\n\n\n\n    if (AV_RN64A(row + 4)) {\n\n        a0 +=   W4*row[4] + W6*row[6];\n\n        a1 += - W4*row[4] - W2*row[6];\n\n        a2 += - W4*row[4] + W2*row[6];\n\n        a3 +=   W4*row[4] - W6*row[6];\n\n\n\n        MAC(b0,  W5, row[5]);\n\n        MAC(b0,  W7, row[7]);\n\n\n\n        MAC(b1, -W1, row[5]);\n\n        MAC(b1, -W5, row[7]);\n\n\n\n        MAC(b2,  W7, row[5]);\n\n        MAC(b2,  W3, row[7]);\n\n\n\n        MAC(b3,  W3, row[5]);\n\n        MAC(b3, -W1, row[7]);\n\n    }\n\n\n\n    row[0] = (a0 + b0) >> (ROW_SHIFT + extra_shift);\n\n    row[7] = (a0 - b0) >> (ROW_SHIFT + extra_shift);\n\n    row[1] = (a1 + b1) >> (ROW_SHIFT + extra_shift);\n\n    row[6] = (a1 - b1) >> (ROW_SHIFT + extra_shift);\n\n    row[2] = (a2 + b2) >> (ROW_SHIFT + extra_shift);\n\n    row[5] = (a2 - b2) >> (ROW_SHIFT + extra_shift);\n\n    row[3] = (a3 + b3) >> (ROW_SHIFT + extra_shift);\n\n    row[4] = (a3 - b3) >> (ROW_SHIFT + extra_shift);\n\n}\n", "idx": 12493, "substitutes": {"row": ["rank", "server", "error", "re", "pool", "check", "r", "scan", "ptr", "ry", "OW", "ward", "pos", "sur", "rect", "record", "rows", "rot", "scroll", "sc", "ob", "sync", "term", "uu", "pair", "cache", "word", "draw", "zero", "store", "tr", "name", "rc", "buffer", "loop", "ack", "each", "ro", "res", "line", "try", "mod", "roll", "copy", "order", "rw", "link", "form", "Row", "rs", "prefix", "req", "ow", "page", "node", "tab", "batch", "cell", "ser", "lo", "block", "index", "job", "range", "item", "lock", "proc", "pixel", "wrapper", "ows", "var", "rec", "co", "ref", "th", "cur", "col", "result", "list", "dr", "raw", "bo", "entry", "window", "iter", "spec", "dd", "ok", "rown", "bug", "table", "user", "obj", "post"], "extra_shift": ["extra_since", "dirtypttimeout", "extra00switch", "foreign_shock", "extraTimeshift", "encrypted_batch", "dirtyptmagic", "extra_pull", "extra67update", "Extra_pad", "extra_set", "extra10transfer", "Extra_shift", "extreme___hift", "extra7batch", "extreme___shift", "encrypted_shift", "extra11transfer", "extra67hift", "adding_switch", "expected_part", "extra_transform", "Extra_switch", "adding_pull", "extreme_hift", "extra00pad", "extra00update", "extraTimepull", "extraptmagic", "extra67gap", "extra00transform", "extrapthelp", "extra_magic", "extra00shift", "total_shift", "foreign11shift", "expectedptpull", "adding_shift", "extra_update", "encryptedTimebatch", "extra67shr", "expectedptpart", "extra7switch", "expected_pull", " extra_transform", "extraptpull", "foreign_shift", "adding_shr", "encryptedTimeshift", "extrajtimeout", "extraopmagic", "dirtypthelp", "extra___hift", "extraoptimeout", "extra67timeout", "expected_timeout", "extra11shock", "extra_part", "adding67shr", "expectedptshift", "extra67shift", "extreme___gap", "extra_hift", "extrapttimeout", "extraptshift", "extra_help", "extrajshift", "extra_timeout", "extra7shift", "adding67pull", " extra_update", "extra67part", "adding67shift", "extrajpull", "expectedpttimeout", "extra11shift", "extra10shock", "total_hift", "extra_pad", "extra_transfer", "expected_shift", "extra_batch", "extra_shr", "foreign_transfer", "extra00hift", "encryptedTimeswitch", "extra67transform", "total_since", "adding_shock", "extra___shift", "extra_gap", "extraTimeswitch", "extra67pull", "foreign11shock", "extreme_gap", "extra_shock", "extraTimebatch", "extrajpart", "extra_switch", "encryptedTimepull", "dirty_shift", "extreme_shift", "dirtyptshift", "dirty_help", "adding_set", "Extra_hift", "extreme___magic", "encrypted_switch", "extreme_magic", "dirty_timeout", "encrypted_pull", "extra10shift", "extra___magic", "foreign11transfer", "extra7pull", "extra67magic", "extraptpart", "extra___gap", "extraophelp", "dirty_magic", "extraopshift"], "a0": ["ea00", "ea0", "aa0", "ea2", "aa1", "ea1", "a00", "aa00", "aa2", " a00"], "a1": [" a11", "b11", "A1", "A01", "a11", "A2", "A11", "a01", "b01", " a01"], "a2": ["an3", "an02", " a256", "A2", "an256", "a256", "an2", "A3", "A02", "a02", "A256", " a02"], "a3": ["an3", "athree", "an4", "A2", "Athree", " athree", " a4", "A3", "A4", "a4", "an2", "anthree"], "b0": ["B3", "bb2", "bb3", "B1", "B2", "bb1", "B0", "bb0"], "b1": ["B01", "bb01", "bb2", "B1", "B2", "bb1", "a01", "B0", "b01", "bb0"], "b2": ["bb2", " b02", "B1", "bb02", "B2", "B02", "bb1", "b02"], "b3": ["B3", "c2", "c03", "B2", "B03", "c3", "b03", " b03"], "temp": ["timer", "orig", "tem", "status", "memory", "sequence", "pool", "EMP", "tree", "prime", "ptr", "storage", "tip", "mem", "method", "ret", "unit", "mm", "perature", "pt", "option", "term", "current", "wait", "rem", "ta", "cache", "tmp", "txt", " tmp", "Temperature", "tim", "cu", "tr", "timeout", "tc", "buffer", "final", "loop", "Temp", "mod", "copy", "t", "template", "em", "tm", "perm", "length", "delay", "fake", "sum", "prefix", " temperature", "type", "condition", "fac", "thread", "format", "cum", "pre", "cell", "alt", "trace", "mp", "total", "mint", "stem", "variable", "var", "phrase", "emp", "time", "level", "json", "sim", "result", "porary", "now", "iter", "unt", "attr", "test", "tt", "v", "dat", "output"]}}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,\n\n                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],\n\n                omap_clk fclk, omap_clk iclk)\n\n{\n\n    struct omap_mmc_s *s = (struct omap_mmc_s *)\n\n            g_malloc0(sizeof(struct omap_mmc_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->clk = fclk;\n\n    s->lines = 4;\n\n    s->rev = 2;\n\n\n\n    omap_mmc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, \"omap.mmc\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    /* Instantiate the storage */\n\n    s->card = sd_init(bd, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];\n\n    sd_set_cb(s->card, NULL, s->cdet);\n\n\n\n    return s;\n\n}\n", "idx": 12499, "substitutes": {"ta": ["ra", "eta", "fa", "tu", "tx", "la", "pa", "ga", "ata", "ti", "dra", "TA", "ma", "tr", "ota", "te", "ada", "oa", "tta", "tp", "tap", "sa", "wa", "era", "ao", "ka", "Ta", "mt", "t", "tm", "ca", "ts", "mi", "pha", "ista", "da", "ba"], "bd": ["gd", "bs", "d", "hd", "dm", "dt", "bl", "bt", "bc", "bf", "br", "dc", " BD", "dh", "vd", "md", "pd", "b", "db", "bb", "dd", "fd", "sd", "dis", "BD", "ds", "bp", "ld", "kb", "BT", "cd", "td", "ded", "bg", "bm", "da", "gb", "ba"], "irq": ["iraqu", "irqq", "pirqu", "IrQ", "arqu", "iraQ", "irqu", "mirv", "arv", "mirqu", "pirQ", "iraq", "arqs", " irqs", "Irqu", " irqu", "pirq", "mirq", "mirqs", "iraqq", "pirqq", "pirqs", "irv", "Irq", "Irqq", "pirv", "arq", "irqs", " irv", "irQ"], "dma": ["Dma", "ppa", "Dms", "amdmas", "mmm", "dpa", " dms", "Dmas", "dme", " dmp", "mpa", "dmp", "pmp", " dmas", " dmm", "amdmp", "Dmm", "amdpa", "dmm", "mms", "mmas", "mdma", "mme", "mdmas", "amdma", " dpa", "mma", "pma", "dmas", "pme", " dme", "mmp", "dms", "mdmp", "mdpa"], "fclk": ["fflks", "fcolks", "fflq", "fflck", "fclck", "fplkg", "fclkg", " fclck", "fcolk", " fclks", " fplck", " fplks", " fclq", "fflkg", "fplk", "fclq", " fclkg", "fplck", " fplkg", "fplks", "fcolck", " fplk", "fcolkg", "fflk", "fclks", "fplq"], "iclk": ["icllke", "icplck", "icllk", " icclck", " iclkt", "icclke", " icclke", " iclke", "icplkt", "icplk", "icplke", "iclke", "icclk", "icclkt", "icclck", "icllkt", "iclck", "iclkt", "icllck", " icclkt", " icclk", " iclck"], "s": ["bs", "fs", "esm", "status", "space", "pers", "ps", "r", "args", "ms", "ports", "js", "sa", "g", "services", "sd", "sw", "gets", "se", "tests", "sc", "ins", "sync", "details", "h", "changes", "sb", "os", "als", "sv", "has", "set", "store", "m", "sports", "ers", "as", "tags", "j", "t", " is", "states", "source", "is", "f", "su", "ns", "l", "rs", "sl", "save", "ies", "S", "c", "comm", "sys", "ls", "vs", "uploads", "hs", "ats", "its", "ims", "sq", "ts", "o", "a", "bits", "params", "ss", "sts", "i", "search", "n", "settings", "ses", "conf", "p", "es", "sam", "aws", "gs", "b", "e", "spec", "less", "ds", "cs", "sort", "v", "stats", "obj", "w"]}}
{"project": "qemu", "commit_id": "dca6eeed8c2a1c131d161139428dd18a35e58b03", "target": 0, "func": "static void calxeda_init(MachineState *machine, enum cxmachines machine_id)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    DeviceState *dev = NULL;\n\n    SysBusDevice *busdev;\n\n    qemu_irq pic[128];\n\n    int n;\n\n    qemu_irq cpu_irq[4];\n\n    qemu_irq cpu_fiq[4];\n\n    MemoryRegion *sysram;\n\n    MemoryRegion *dram;\n\n    MemoryRegion *sysmem;\n\n    char *sysboot_filename;\n\n\n\n    if (!cpu_model) {\n\n        switch (machine_id) {\n\n        case CALXEDA_HIGHBANK:\n\n            cpu_model = \"cortex-a9\";\n\n            break;\n\n        case CALXEDA_MIDWAY:\n\n            cpu_model = \"cortex-a15\";\n\n            break;\n\n        }\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        ObjectClass *oc = cpu_class_by_name(TYPE_ARM_CPU, cpu_model);\n\n        Object *cpuobj;\n\n        ARMCPU *cpu;\n\n        Error *err = NULL;\n\n\n\n        if (!oc) {\n\n            error_report(\"Unable to find CPU definition\");\n\n            exit(1);\n\n        }\n\n\n\n        cpuobj = object_new(object_class_get_name(oc));\n\n        cpu = ARM_CPU(cpuobj);\n\n\n\n        /* By default A9 and A15 CPUs have EL3 enabled.  This board does not\n\n         * currently support EL3 so the CPU EL3 property is disabled before\n\n         * realization.\n\n         */\n\n        if (object_property_find(cpuobj, \"has_el3\", NULL)) {\n\n            object_property_set_bool(cpuobj, false, \"has_el3\", &err);\n\n            if (err) {\n\n                error_report_err(err);\n\n                exit(1);\n\n            }\n\n        }\n\n\n\n        if (object_property_find(cpuobj, \"reset-cbar\", NULL)) {\n\n            object_property_set_int(cpuobj, MPCORE_PERIPHBASE,\n\n                                    \"reset-cbar\", &error_abort);\n\n        }\n\n        object_property_set_bool(cpuobj, true, \"realized\", &err);\n\n        if (err) {\n\n            error_report_err(err);\n\n            exit(1);\n\n        }\n\n        cpu_irq[n] = qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ);\n\n        cpu_fiq[n] = qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ);\n\n    }\n\n\n\n    sysmem = get_system_memory();\n\n    dram = g_new(MemoryRegion, 1);\n\n    memory_region_allocate_system_memory(dram, NULL, \"highbank.dram\", ram_size);\n\n    /* SDRAM at address zero.  */\n\n    memory_region_add_subregion(sysmem, 0, dram);\n\n\n\n    sysram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram(sysram, NULL, \"highbank.sysram\", 0x8000,\n\n                           &error_fatal);\n\n    memory_region_add_subregion(sysmem, 0xfff88000, sysram);\n\n    if (bios_name != NULL) {\n\n        sysboot_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (sysboot_filename != NULL) {\n\n            if (load_image_targphys(sysboot_filename, 0xfff88000, 0x8000) < 0) {\n\n                hw_error(\"Unable to load %s\\n\", bios_name);\n\n            }\n\n            g_free(sysboot_filename);\n\n        } else {\n\n           hw_error(\"Unable to find %s\\n\", bios_name);\n\n        }\n\n    }\n\n\n\n    switch (machine_id) {\n\n    case CALXEDA_HIGHBANK:\n\n        dev = qdev_create(NULL, \"l2x0\");\n\n        qdev_init_nofail(dev);\n\n        busdev = SYS_BUS_DEVICE(dev);\n\n        sysbus_mmio_map(busdev, 0, 0xfff12000);\n\n\n\n        dev = qdev_create(NULL, \"a9mpcore_priv\");\n\n        break;\n\n    case CALXEDA_MIDWAY:\n\n        dev = qdev_create(NULL, \"a15mpcore_priv\");\n\n        break;\n\n    }\n\n    qdev_prop_set_uint32(dev, \"num-cpu\", smp_cpus);\n\n    qdev_prop_set_uint32(dev, \"num-irq\", NIRQ_GIC);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, MPCORE_PERIPHBASE);\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        sysbus_connect_irq(busdev, n, cpu_irq[n]);\n\n        sysbus_connect_irq(busdev, n + smp_cpus, cpu_fiq[n]);\n\n    }\n\n\n\n    for (n = 0; n < 128; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    dev = qdev_create(NULL, \"sp804\");\n\n    qdev_prop_set_uint32(dev, \"freq0\", 150000000);\n\n    qdev_prop_set_uint32(dev, \"freq1\", 150000000);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xfff34000);\n\n    sysbus_connect_irq(busdev, 0, pic[18]);\n\n    sysbus_create_simple(\"pl011\", 0xfff36000, pic[20]);\n\n\n\n    dev = qdev_create(NULL, \"highbank-regs\");\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xfff3c000);\n\n\n\n    sysbus_create_simple(\"pl061\", 0xfff30000, pic[14]);\n\n    sysbus_create_simple(\"pl061\", 0xfff31000, pic[15]);\n\n    sysbus_create_simple(\"pl061\", 0xfff32000, pic[16]);\n\n    sysbus_create_simple(\"pl061\", 0xfff33000, pic[17]);\n\n    sysbus_create_simple(\"pl031\", 0xfff35000, pic[19]);\n\n    sysbus_create_simple(\"pl022\", 0xfff39000, pic[23]);\n\n\n\n    sysbus_create_simple(\"sysbus-ahci\", 0xffe08000, pic[83]);\n\n\n\n    if (nd_table[0].used) {\n\n        qemu_check_nic_model(&nd_table[0], \"xgmac\");\n\n        dev = qdev_create(NULL, \"xgmac\");\n\n        qdev_set_nic_properties(dev, &nd_table[0]);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff50000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[77]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[78]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[79]);\n\n\n\n        qemu_check_nic_model(&nd_table[1], \"xgmac\");\n\n        dev = qdev_create(NULL, \"xgmac\");\n\n        qdev_set_nic_properties(dev, &nd_table[1]);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff51000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[80]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[81]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[82]);\n\n    }\n\n\n\n    highbank_binfo.ram_size = ram_size;\n\n    highbank_binfo.kernel_filename = kernel_filename;\n\n    highbank_binfo.kernel_cmdline = kernel_cmdline;\n\n    highbank_binfo.initrd_filename = initrd_filename;\n\n    /* highbank requires a dtb in order to boot, and the dtb will override\n\n     * the board ID. The following value is ignored, so set it to -1 to be\n\n     * clear that the value is meaningless.\n\n     */\n\n    highbank_binfo.board_id = -1;\n\n    highbank_binfo.nb_cpus = smp_cpus;\n\n    highbank_binfo.loader_start = 0;\n\n    highbank_binfo.write_secondary_boot = hb_write_secondary;\n\n    highbank_binfo.secondary_cpu_reset_hook = hb_reset_secondary;\n\n    arm_load_kernel(ARM_CPU(first_cpu), &highbank_binfo);\n\n}\n", "idx": 12544, "substitutes": {"machine": ["computer", "device", "view", "power", "menu", "series", "monitor", "server", "history", "sim", "node", "connection", "space", "state", "frame", "managed", "achine", "alias", "mc", "check", "m", "host", "linux", "smart", "domain", "network", "instance", "mode", "module", "manager", "engine", "model", "money", "normal", "zone", "hard", "iso", "template", "handler", "keeper", "link", "command", "Machine", "process", "vm", "one"], "machine_id": ["machine_no", "node_ip", "node_id", "node_name", " machine_no", "machine_key", "machine_ip", "node_key", "machine_name", "machine_ids", " machine_pid", "machine_pid", " machine_ids"], "cpu_model": ["cpu_config", "pu_link", "pu_controller", "gpu_label", "processor_mode", "cpu_label", " cpu_machine", "processor_model", "gpu_type", "linuxtimemodel", "pu_model", "pu_brand", "cpu_controller", "cpu_Model", "gpu_model", "cpu_method", "cpu_type", "cpu_tag", "pu_mode", "cpu_mode", " cpu_type", "linuxtimemode", "linuxtimetag", "cpu_link", "cputimetag", "cputimemodel", "pu_Model", "pu_type", "cputimemode", "cpu_machine", "linux_tag", "linux_model", "processor_config", "processor_method", "linux_mode", "gpu_Model", "cpu_brand", " cpu_brand"], "kernel_filename": ["kernelityfilename", "system_file", "kernelityfile", "kernel_file", "proc_files", "kernel_license", "proc_source", "proc_filename", "kernel_source", "system_dll", "kernel_directory", "kernelitydll", "kernelitylicense", "system_license", "kernel_files", "proc_directory", "system_filename", "kernel_dll"], "kernel_cmdline": ["kernel_bindLine", "kernel_bindlines", "kernel_cmdLine", "kernel_commandpath", "kernel_cmdstring", "kernel_paypath", "kernel_payLine", "kernel_bindstring", "kernel_bindpath", "kernel_cmdpath", "kernel_deadline", "kernel_cmdlines", "kernel_commandLine", "kernel_deadstring", "kernel_bindline", "kernel_deadlines", "kernel_commandstring", "kernel_commandlines", "kernel_commandline", "kernel_payline"], "initrd_filename": ["initrr_files", "initrr_Filename", "initrd_fn", "initrb_fn", "initrd_location", "initrb_filename", "initrd_files", "initrd_Filename", "initrb_file", "initrd__location", "initrd__filename", "initrd__Filename", "initrr_filename", "initrd_file", "initrb_files", "initrr_location", "initrd__files"], "dev": ["device", "ch", "av", "DEV", "serv", "priv", "di", "hw", "conf", "def", "sys", "scan", "cam", "mem", "Dev", "env", "ev", "sd", "disk", "conn", "proc", "ds", "cmd", "kr", "obj", "w"], "busdev": ["bootDev", "bootinfo", "bootdevice", " busDev", "blockdev", " businfo", "blockDev", "busDev", "bootdev", " busdevice", "blockinfo", "businfo", "blockdevice", "busdevice"], "pic": [" nic", "pc", "picture", "mc", "mic", "pin", "si", "Pic", "mac", "fif", "sa", "sp", "gc", "str", "nic", "arc", "sta", "ic", "lib", "sc", "mi", "isi", "bi", "sync", "cow", "icc", "gb", "script"], "n": ["dn", "un", "i", "h", " len", "d", "sn", "con", " N", "tn", "k", "nw", "z", "x", "gn", "out", "nan", "nu", " p", "number", "yn", "c", "np", "cn", "p", " j", "an", "m", "mn", "ne", "N", "ln", "nt", "names", "count", "no", "ng", "len", " number", "na", "nr", "w", " m", "g", "ni", "j", "nn", " nu", "num", "nor", "wn", "en", " count", "nia", " ng", " num", "nb", "t", " c", "nc", " iter", "o", " k", "v", "y", " i", " fn", "ns", " ns"], "cpu_irq": ["cpu_rinue", "cpu_irz", "cpu_fiue", "cpu_iraQ", "cpu_rinp", "cpu__rinue", "cpu_irp", "cpu_mirqs", "cpu_irez", "cpu_iraue", "cpu_fiQ", "cpu__irqs", "cpu_mirq", "cpu__irq", "cpu_irms", "cpu_irQ", "cpu__irz", "cpu_rinms", "cpu_rinqs", "cpu_irue", "cpu__irms", "cpu_ireq", "cpu__rinq", "cpu__rinp", "cpu_mirp", "cpu_rinq", "cpu_rinz", "cpu__rinQ", "cpu_fims", "cpu_irqs", "cpu_irams", "cpu__rinz", "cpu_ireqs", "cpu__irue", "cpu_mirz", "cpu_irep", "cpu__rinms", "cpu__rinqs", "cpu_rinQ", "cpu_iraq", "cpu__irQ", "cpu__irp"], "cpu_fiq": ["cpu_fiue", "cpu_fiQ", "cpu_faq", "cpu_tiqs", "cpu_faqs", "cpu_irQ", "cpu_tiQ", "cpu_irue", "cpu_faQ", "cpu_fiqs", "cpu_irqs", "cpu_faue", "cpu_tiq", "cpu_tiue"], "sysram": ["syscpu", "sysgram", "yscpu", "Sysram", "ysmem", "systemmem", "systemgram", "Syscpu", "Sysmem", "systemcpu", "ysgram", "Sysgram", "systemram", "ysram"], "dram": ["dssam", "dsram", "ddram", "dsmem", "ydmem", "ddmem", "dgram", "ydgram", "ddsam", "ydsam", "dmem", "dsam", "ddgram", "ydram", "dsgram"], "sysmem": ["sysmi", "syscpu", "symem", "yscpu", "ysmem", "systemmem", "sycpu", "systemcpu", "systemmi", "symi", "ysmi"], "sysboot_filename": ["sysmem_location", "sysboot__filename", "sysboot__location", "sysboot__files", "sysboot__file", "sysmem_file", "sysmem_filename", "sysboot_location", "sysboot_files", "sysmem_files", "sysboot_file"], "oc": ["ocation", "voc", "pc", "alloc", "unc", "ock", "cot", "os", "dc", "yo", "oad", "oid", "ost", "oco", "ot", "oop", "ok", "toc", "orp", "ocr", "OC", "og", "nic", "ong", "arc", "soc", "aco", "ocon", "ic", "ec", "ico", "ox", "osc", "nc", "roc", "o", "ob", "ac", "oci", "AC", "or", "erc", "co"], "cpuobj": ["cuopt", " cpujs", "linuxarr", "cujs", " cpuopt", "cuinst", "pubj", "cubj", "cpuopt", "nicObj", "cpobj", "cpuact", "cputmp", "uuconn", "pixeltmp", "cpctr", "niccod", "linuxobject", "gpuObj", "cuproc", "cpucod", "cpuctr", "cuObj", "cpuproc", "cpuarr", "cpObj", "cpuObj", "linuxObj", "uuobj", "nicobject", " cpuctr", "puact", " cpuproc", "cpujs", "pixelObj", "linuxct", "puopt", "pixelobj", "puconn", "CPUarr", "puobj", "CPUObj", "cuconn", "linuxobj", "cutmp", " cpuact", "cpuobject", " cpuct", "gpucod", "linuxctr", " cpuObj", "cpuconn", "pixelconn", "uuinst", "pujs", "gpuobject", "CPUjs", "cpuinst", "puarr", "pixelbj", "cuobj", "cpobject", "cpuct", "puct", "putmp", "CPUobj", " cpuobject", "puinst", "pucod", "linuxjs", "cpubj", "puobject", "uuObj", "gpuobj", " cpuconn", "puproc", "nicobj", "puObj", "linuxact"], "cpu": ["uu", "clock", "cache", "pc", "gpu", "memory", "alloc", "cum", "util", "cmp", "pu", "nu", "np", "processor", "cp", "hw", "core", "cu", "cn", "ilo", "gp", "pro", "mem", "ctx", "gc", "cv", "ro", "nic", "aco", "proc", "CPU", "po", "prof", "rom", "obj", "process", "vm", "mu"], "err": ["usr", "norm", "req", "rs", "term", "priv", "virt", "die", "txt", "here", "cli", "error", "gz", "buf", "br", "hz", "cb", "conf", "er", "cer", "notice", "arr", "r", "ger", "rx", "dr", "cfg", "eric", "ner", "e", "rc", "rr", "iter", "erd", "aaa", "der", "exc", "ocr", "erm", "rn", "ev", "res", "str", "inner", "msg", "fr", "mr", "try", "ec", "order", "attr", "bug", "test", "fee", "later", "gr", "resp", "kr", "cr", "errors", "drm", "obj", "lr", "eas", "Er", "eor"]}}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "static int get_phys_addr_v5(CPUState *env, uint32_t address, int access_type,\n\n\t\t\t    int is_user, uint32_t *phys_ptr, int *prot)\n\n{\n\n    int code;\n\n    uint32_t table;\n\n    uint32_t desc;\n\n    int type;\n\n    int ap;\n\n    int domain;\n\n    uint32_t phys_addr;\n\n\n\n    /* Pagetable walk.  */\n\n    /* Lookup l1 descriptor.  */\n\n    table = get_level1_table_address(env, address);\n\n    desc = ldl_phys(table);\n\n    type = (desc & 3);\n\n    domain = (env->cp15.c3 >> ((desc >> 4) & 0x1e)) & 3;\n\n    if (type == 0) {\n\n        /* Section translation fault.  */\n\n        code = 5;\n\n        goto do_fault;\n\n    }\n\n    if (domain == 0 || domain == 2) {\n\n        if (type == 2)\n\n            code = 9; /* Section domain fault.  */\n\n        else\n\n            code = 11; /* Page domain fault.  */\n\n        goto do_fault;\n\n    }\n\n    if (type == 2) {\n\n        /* 1Mb section.  */\n\n        phys_addr = (desc & 0xfff00000) | (address & 0x000fffff);\n\n        ap = (desc >> 10) & 3;\n\n        code = 13;\n\n    } else {\n\n        /* Lookup l2 entry.  */\n\n\tif (type == 1) {\n\n\t    /* Coarse pagetable.  */\n\n\t    table = (desc & 0xfffffc00) | ((address >> 10) & 0x3fc);\n\n\t} else {\n\n\t    /* Fine pagetable.  */\n\n\t    table = (desc & 0xfffff000) | ((address >> 8) & 0xffc);\n\n\t}\n\n        desc = ldl_phys(table);\n\n        switch (desc & 3) {\n\n        case 0: /* Page translation fault.  */\n\n            code = 7;\n\n            goto do_fault;\n\n        case 1: /* 64k page.  */\n\n            phys_addr = (desc & 0xffff0000) | (address & 0xffff);\n\n            ap = (desc >> (4 + ((address >> 13) & 6))) & 3;\n\n            break;\n\n        case 2: /* 4k page.  */\n\n            phys_addr = (desc & 0xfffff000) | (address & 0xfff);\n\n            ap = (desc >> (4 + ((address >> 13) & 6))) & 3;\n\n            break;\n\n        case 3: /* 1k page.  */\n\n\t    if (type == 1) {\n\n\t\tif (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n\t\t    phys_addr = (desc & 0xfffff000) | (address & 0xfff);\n\n\t\t} else {\n\n\t\t    /* Page translation fault.  */\n\n\t\t    code = 7;\n\n\t\t    goto do_fault;\n\n\t\t}\n\n\t    } else {\n\n\t\tphys_addr = (desc & 0xfffffc00) | (address & 0x3ff);\n\n\t    }\n\n            ap = (desc >> 4) & 3;\n\n            break;\n\n        default:\n\n            /* Never happens, but compiler isn't smart enough to tell.  */\n\n            abort();\n\n        }\n\n        code = 15;\n\n    }\n\n    *prot = check_ap(env, ap, domain, access_type, is_user);\n\n    if (!*prot) {\n\n        /* Access permission fault.  */\n\n        goto do_fault;\n\n    }\n\n    *phys_ptr = phys_addr;\n\n    return 0;\n\ndo_fault:\n\n    return code | (domain << 4);\n\n}\n", "idx": 12545, "substitutes": {"env": ["context", "h", "esm", "end", "sb", "pe", "email", "server", "cur", "hw", "eng", "conf", "er", "enter", "environment", "set", "store", "ptr", "vs", "vp", "te", "ah", "e", "dev", "window", "shell", "entry", "erd", "estate", "ctx", "eh", "sp", "exc", "ev", "manager", "ew", "en", "conn", "gate", "ec", "esc", "self", "sc", "config", "equ", "cmd", "v", "vm"], "address": ["device", "entity", "image", "route", "email", "memory", "error", "password", "addr", "resource", "message", "add", "ptr", "application", "record", "description", "offset", "ace", "base", "term", "operation", "event", "Address", "word", "number", "alias", "position", "store", "host", " Address", "request", "size", "comment", "order", "command", "form", "location", "page", "value", "service", "adr", "interface", "controller", "trace", "array", "response", "reference", "index", "object", "gate", "ase", "a", "phrase", "ref", "point", "ip", "result", "document", "property", "action", "port", "entry", "chain", "network", "attribute", "pointer", "act", "date"], "access_type": ["privuretype", "accessopmode", "privuretypes", "priv_mode", "accessuretyp", "priv_typ", "accessuretype", "accessoptyp", "accessoptypes", "access_types", "accessuremode", "priv_type", "access_typ", "accessoptype", "privuretyp", "privuremode", "access_mode", "accessuretypes", "priv_types"], "is_user": [" is_valid", " is_uid", " is_used", "is_used", "is_uid", "is_valid"], "phys_ptr": ["phys_pad", "sys_ptr", "phys2ptr", "sys_addr", "phys_obj", "sys_pad", "phys2pad", "phys2obj", "phys2addr", "sys_obj"], "prot": ["ref", "prop", "next", "priority", "ip", "password", "addr", " proto", "ext", "pro", "port", "pos", "chain", "ocol", "eth", "security", " port", "seq", "ef", "typ", "test", "net", " seq", "policy", "Prot", "td", "ping", " protocol"], "code": ["cause", "second", "ch", "status", "content", "error", "sequence", "frame", "create", "message", "check", "close", "scene", "done", "use", "ci", "ie", "coe", "ode", "ter", "se", " error", "event", "cache", "component", "next", "force", "store", "ne", "rc", "size", "line", "zone", "try", "comment", "order", "fee", "ae", "pc", "page", "die", "c", "change", "err", "cast", "cc", "count", "index", "mode", "lock", "stay", "call", "co", "rate", "codes", "th", "time", "go", "out", "state", "xc", "age", "entry", "e", "reason", "id", "ce", "see", "ice", " count", "test", "nc", "cd", "cycle", "Code"], "table": ["cache", "ref", "angle", "container", "dict", "map", "bl", "page", "tmp", "point", "translation", "tab", "tree", "filter", "ape", "list", "store", "batch", "Table", "database", "tr", "console", "where", "port", "trace", "chain", "db", "count", "buffer", "plain", "array", "stable", "block", "index", "module", "record", "description", "entry", "TABLE", "comment", "binary", "t", "order", "able", "ca", "file", "body", "section", "base", "scope", "td", "term"], "desc": [" Desc", "ript", "error", "cmp", "password", "addr", "dest", "message", "ptr", "pb", "mem", "sec", "des", "done", "der", "dir", "dep", "description", "esc", "sc", "td", "term", "info", "dt", "txt", "word", "Desc", "def", "tag", "tr", "name", "flag", "rc", "size", "cod", "msg", "en", "comment", "order", "resp", "cmd", "length", "doc", "DES", "req", "adj", "page", "summary", "dc", "tab", "buf", "adr", "ext", "loc", "sub", "err", "disc", "empty", "ent", "total", "decl", "seq", "ec", "typ", "rec", "dist", "phrase", "ord", "dem", "dict", "deb", "asc", "progress", "col", "result", "usc", "entry", "md", "dev", "ctx", "cont", "str", "row", "attr", "config", "sort", "cd", "obj", "diff", "label"], "type": ["shape", "kind", "role", "rank", "version", "color", "term", "day", "pe", "ty", "time", "status", "style", "dt", "level", "format", "title", "group", "error", "state", "ver", "Type", "p", "currency", "country", "operator", "tag", "action", "key", "name", "port", "flag", "field", "count", "tp", "index", "ype", "unit", "id", "op", "size", "module", "range", "magic", "try", "class", "t", "typ", "order", "test", "part", "types", "function", "scope", "length", "ping", "TYPE"], "ap": ["apt", "rep", "adj", "map", "apped", "pc", "app", "ag", "art", "pa", "ip", "addr", "ar", "p", "ape", "wp", "ach", "ptr", "AP", "pos", "att", "mp", "tap", "db", "tp", "af", "sp", "op", "html", "at", "cod", "aps", "offset", "cap", "acl", "amp", "rap", "ep", "attr", "apa", "snap", "api", "pad", "ac", "arp", "ab", "or", "pac"], "domain": ["rank", "rate", "d", "channel", "prefix", "web", "angle", "page", "dom", "virt", "status", "server", "node", "value", "confirmed", "depth", "top", "addr", "root", "currency", "org", "country", "host", "origin", "tip", "port", "site", "flag", "chain", "db", "field", "index", "unit", "region", "dir", "id", "url", "module", "description", "range", "conn", "gate", "zone", "magic", "order", "net", "Domain", "lang", "base", "scope", "example"], "phys_addr": ["physacadd", "Phys_adr", "physicalegg", "phys2egg", "Phys__addr", "physacptr", "physmlstore", "physicalptr", " phys_address", "Phys__ptr", "phys_address", "physical_ptr", "Phys__adr", "phys_attr", "Phys_ptr", "phys2addr", "phys___ptr", "phys__ptr", " phys_egg", "physipptr", "physipaddress", "physicaladdr", "phys_egg", "physipadd", "phys__addr", "physical_store", "Phys_addr", "phys_adr", "physacaddr", "physipaddr", "physmlptr", "phys_store", "phys__address", "phys___adr", "phys_add", "physmladdr", "phys___addr", "physical_adr", "physical_address", "phys2ptr", "physacaddress", " phys_add", "phys__adr", "physmladdress", "phys__store", "physical_addr", " phys_attr"]}}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_mcast_filters(VMXNET3State *s)\n\n{\n\n    uint16_t list_bytes =\n\n        VMXNET3_READ_DRV_SHARED16(s->drv_shmem,\n\n                                  devRead.rxFilterConf.mfTableLen);\n\n\n\n    s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);\n\n\n\n    s->mcast_list = g_realloc(s->mcast_list, list_bytes);\n\n    if (!s->mcast_list) {\n\n        if (s->mcast_list_len == 0) {\n\n            VMW_CFPRN(\"Current multicast list is empty\");\n\n        } else {\n\n            VMW_ERPRN(\"Failed to allocate multicast list of %d elements\",\n\n                      s->mcast_list_len);\n\n        }\n\n        s->mcast_list_len = 0;\n\n    } else {\n\n        int i;\n\n        hwaddr mcast_list_pa =\n\n            VMXNET3_READ_DRV_SHARED64(s->drv_shmem,\n\n                                      devRead.rxFilterConf.mfTablePA);\n\n\n\n        pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);\n\n\n\n        VMW_CFPRN(\"Current multicast list len is %d:\", s->mcast_list_len);\n\n        for (i = 0; i < s->mcast_list_len; i++) {\n\n            VMW_CFPRN(\"\\t\" MAC_FMT, MAC_ARG(s->mcast_list[i].a));\n\n        }\n\n    }\n\n}\n", "idx": 12548, "substitutes": {"s": ["bs", "fs", "esm", "status", "http", "ps", "r", "args", "ports", "js", "services", "sw", "gets", "ex", "y", "details", "h", "d", "changes", "sb", "serv", "ops", "os", "als", "sv", "set", "store", "m", "sports", "events", "w", "t", "states", "is", "source", "stat", "south", "parts", "ns", "rs", "sl", "ies", "S", "so", "comm", "eps", "sys", "ls", "vs", "reads", "hs", "ats", "its", "ims", "sq", "https", "ts", "o", "qs", "ss", "sts", "n", "settings", "ses", "p", "es", "xs", "aws", "gs", "b", "spec", "less", "ds", "cs", "comments", "v", "stats", "obj"], "i": ["qi", "ind", "ai", "ii", "n", "gi", "di", "ski", "x", "cli", "sim", "ip", "init", "gu", "u", "ti", "li", "hi", "\u0438", "I", "ei", "err", "si", "m", "oi", "key", "us", "ri", "im", "multi", "in", "ami", "ims", "index", "iu", "g", "it", "j", "me", "ci", "xi", "ic", "ki", "t", "phi", "zi", "ix", "MI", "mi", "is", "a", "o", "pi", "y", "bi", "ini", "ui", "uri"]}}
{"project": "FFmpeg", "commit_id": "7546964f96168cd6ac819ef4c3212ee586619f1a", "target": 0, "func": "int ff_nvdec_decode_init(AVCodecContext *avctx, unsigned int dpb_size)\n\n{\n\n    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;\n\n\n\n    NVDECFramePool      *pool;\n\n    AVHWFramesContext   *frames_ctx;\n\n    const AVPixFmtDescriptor *sw_desc;\n\n\n\n    CUVIDDECODECREATEINFO params = { 0 };\n\n\n\n    int cuvid_codec_type, cuvid_chroma_format;\n\n    int ret = 0;\n\n\n\n    sw_desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);\n\n    if (!sw_desc)\n\n        return AVERROR_BUG;\n\n\n\n    cuvid_codec_type = map_avcodec_id(avctx->codec_id);\n\n    if (cuvid_codec_type < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported codec ID\\n\");\n\n        return AVERROR_BUG;\n\n    }\n\n\n\n    cuvid_chroma_format = map_chroma_format(avctx->sw_pix_fmt);\n\n    if (cuvid_chroma_format < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported chroma format\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->thread_type & FF_THREAD_FRAME)\n\n        dpb_size += avctx->thread_count;\n\n\n\n    if (!avctx->hw_frames_ctx) {\n\n        AVHWFramesContext *frames_ctx;\n\n\n\n        if (!avctx->hw_device_ctx) {\n\n            av_log(avctx, AV_LOG_ERROR, \"A hardware device or frames context \"\n\n                   \"is required for CUVID decoding.\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);\n\n        if (!avctx->hw_frames_ctx)\n\n            return AVERROR(ENOMEM);\n\n        frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n\n\n        frames_ctx->format            = AV_PIX_FMT_CUDA;\n\n        frames_ctx->width             = avctx->coded_width;\n\n        frames_ctx->height            = avctx->coded_height;\n\n        frames_ctx->sw_format         = AV_PIX_FMT_NV12;\n\n        frames_ctx->sw_format         = sw_desc->comp[0].depth > 8 ?\n\n                                        AV_PIX_FMT_P010 : AV_PIX_FMT_NV12;\n\n        frames_ctx->initial_pool_size = dpb_size;\n\n\n\n        ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error initializing internal frames context\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n    frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n\n\n    params.ulWidth             = avctx->coded_width;\n\n    params.ulHeight            = avctx->coded_height;\n\n    params.ulTargetWidth       = avctx->coded_width;\n\n    params.ulTargetHeight      = avctx->coded_height;\n\n    params.bitDepthMinus8      = sw_desc->comp[0].depth - 8;\n\n    params.OutputFormat        = params.bitDepthMinus8 ?\n\n                                 cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12;\n\n    params.CodecType           = cuvid_codec_type;\n\n    params.ChromaFormat        = cuvid_chroma_format;\n\n    params.ulNumDecodeSurfaces = dpb_size;\n\n    params.ulNumOutputSurfaces = 1;\n\n\n\n    ret = nvdec_decoder_create(&ctx->decoder_ref, frames_ctx->device_ref, &params, avctx);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    pool = av_mallocz(sizeof(*pool));\n\n    if (!pool) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    pool->dpb_size = dpb_size;\n\n\n\n    ctx->decoder_pool = av_buffer_pool_init2(sizeof(int), pool,\n\n                                             nvdec_decoder_frame_alloc, av_free);\n\n    if (!ctx->decoder_pool) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    return 0;\n\nfail:\n\n    ff_nvdec_decode_uninit(avctx);\n\n    return ret;\n\n}\n", "idx": 12556, "substitutes": {"avctx": [" avjac", "avercontext", "avstat", "ovcmp", "avercb", "wavdocument", "averconn", "ajstat", "wavcontext", "avtx", "ovjac", "ajconn", "cvctl", " avhandle", "devctl", "wavcrit", " avdoc", "avcfg", "avhandle", " avcontext", "cvctx", "avecb", "avwcs", "awcrit", "awctx", "averwcs", "navkl", "wavconn", "avegc", "savcontext", "ovtmp", "iverdoc", "avtmp", "avewcs", "ajctx", "cvcontext", "savtx", "vertx", " avgc", "avepkg", "avertmp", "afcontext", "vercontext", "ovctx", "averkl", "awkl", "avdoc", "averstat", "avermsg", "averctl", "afctl", "avecrit", "ovstat", "avpkg", "iverobj", "navctx", "averctx", "aftx", "devtx", "varcontext", "navtmp", "avectx", " avconf", "avjp", "afctx", "savjac", "avekl", "aftmp", "navkt", "ajwcs", "ajjac", "avdocument", " avconn", "aveconf", "avjac", " avstat", "ovctl", "afstat", "ajkl", "avobj", "averconf", "verctx", "avkt", "avergc", "avcontext", "avmsg", "wavstat", "avercfg", "avejp", "savctx", "wavmsg", "ajkt", "avecontext", "afmsg", "ivertx", "devcontext", "wavpkg", "wavkl", "aveobj", " avdocument", "ajcmp", "iverctx", " avobj", "wavcb", " avtxt", "vartx", "varjac", "averpkg", "ajcontext", "awconn", "avcmp", "wavtx", "avgc", "averjac", "averhandle", "avetmp", "ajtxt", "wavcmp", "avekt", "averjp", " avjp", "avcrit", "avtxt", "wavhandle", "avertxt", "avercrit", " avcfg", "avkl", "afpkg", "afjac", "devctx", "afcmp", "avetx", " avctl", "avctl", "wavcfg", " avtx", "ajgc", "wavctx", "avertx", "verjac", "avecmp", "avconf", "avconn", "ajtmp", "aveconn", "afcfg", "cvtx", "avedoc", "savdocument", "varctx", "avcb"], "dpb_size": ["dpb8count", "dpw_Size", "dpb8len", "dpw_count", "dpB_offset", "dpb_SIZE", "dpB_size", "dpb_count", "dpw_size", "dpb_Size", "dpb8Size", "dpb_offset", "dpw_len", "dpB_Size", "dpb_len", "dpb8size", "dpB_SIZE"], "ctx": ["pkg", "context", "kw", "tmp", "txt", "tx", "conv", "cas", "cmp", "xc", "cp", "cb", "hw", "conf", "jac", "cfg", " context", "tc", "cc", "cf", "act", "conn", "cl", "ct", " cx", "cond", "cmd", "obj"], "pool": [" pools", "pkg", "cache", "ref", "prefix", "parent", "tx", "buf", "col", "cpu", "ool", "cp", "p", "socket", "cam", "batch", "timeout", "port", "mem", "window", "chain", "box", "buffer", "Pool", "conn", "policy", " pooled"], "frames_ctx": ["frames_alloc", " frames_txt", "frames\u05bcpkg", "flows_kt", "framesettmp", " frames_tx", "frames\u05bcexp", "frames_pkg", "framesettx", "frames___tx", "banks_ctl", "frames_urg", "frames___kt", "frames_context", "frames_cu", " frames_tmp", "Frames_grad", "flows_ctx", " frames_kt", "frames___ctx", "Frames_ctx", "Frames_tx", "faces_pkg", "frames___cp", "faces_tc", "banks_tx", "Frames_urg", "framesETurg", "flows_tx", "framesETctx", "frames_tmp", "banks_ctx", "flows_cp", "frames_txt", "faces_context", "banks_cu", "framesETtx", " frames_alloc", "frames_grad", "frames_exp", "thumbnails_cp", "faces_ctx", "framesETgrad", "thumbnails_pkg", "framesetkt", "thumbnails_exp", "frames\u05bcctx", "frames_cp", "frames\u05bccp", "framesetctx", "frames_tx", "frames_ctl", "frames_tc", "frames_kt", "thumbnails_ctx"], "sw_desc": ["sw_tmp", " Sw_decl", " sw_cont", "sw_ds", " Sw_desc", "sw_decl", "sw2desc", "sw_conn", " sw_Desc", "swkttmp", " Sw_tmp", "sw_cont", "sw_Desc", " sw_conn", "sw2tmp", "swktdecl", "swktdesc", "sw_des", " sw_des", "sw2decl", " sw_ds"], "cuvid_codec_type": ["cuvid_codix_type", "cuvid_coddec_type", "cuvid_codec_id", "cuvid_codel_id", "cuvid_codec__name", "cuvid_codec_kind", "cuvid_codec__type", "cuvid_codec__Type", "cuvid_codel_name", "cuvid_coddec_name", "cuvid_codec__id", "cuvid_codec_class", "cuvid_codec_value", "cuvid_codel_type", "cuvid_coddec_id", "cuvid_codix_id", "cuvid_codel_kind", "cuvid_codec_Type", "cuvid_codec__class", "cuvid_codec__value", "cuvid_coddec_Type", "cuvid_codix_value", "cuvid_codix_class", "cuvid_codec_name"], "cuvid_chroma_format": ["cuvid_chromA_format", "cuvid_chroma_form", "cuvid_chromA_style", "cuvid_chromA_form", "cuvid_chroma00form", "cuvid_chroma2form", "cuvid_chroma2type", "cuvid_chroma00format", "cuvid_chroma__type", "cuvid_chromA_unit", "cuvid_chroma_style", "cuvid_chromA_type", "cuvid_chroma__form", "cuvid_chroma2unit", "cuvid_chroma_type", "cuvid_chroma2format", "cuvid_chroma_unit", "cuvid_chroma__format", "cuvid_chromA_fact", "cuvid_chroma00fact", "cuvid_chroma00type", "cuvid_chroma_fact", "cuvid_chroma__style"]}}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "void hmp_info_snapshots(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs, *bs1;\n\n    QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s;\n\n    int nb_sns, i, ret, available;\n\n    int total;\n\n    int *available_snapshots;\n\n\n\n    bs = find_vmstate_bs();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No available block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    nb_sns = bdrv_snapshot_list(bs, &sn_tab);\n\n    if (nb_sns < 0) {\n\n        monitor_printf(mon, \"bdrv_snapshot_list: error %d\\n\", nb_sns);\n\n        return;\n\n    }\n\n\n\n    if (nb_sns == 0) {\n\n        monitor_printf(mon, \"There is no snapshot available.\\n\");\n\n        return;\n\n    }\n\n\n\n    available_snapshots = g_malloc0(sizeof(int) * nb_sns);\n\n    total = 0;\n\n    for (i = 0; i < nb_sns; i++) {\n\n        sn = &sn_tab[i];\n\n        available = 1;\n\n        bs1 = NULL;\n\n\n\n        while ((bs1 = bdrv_next(bs1))) {\n\n            if (bdrv_can_snapshot(bs1) && bs1 != bs) {\n\n                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);\n\n                if (ret < 0) {\n\n                    available = 0;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (available) {\n\n            available_snapshots[total] = i;\n\n            total++;\n\n        }\n\n    }\n\n\n\n    if (total > 0) {\n\n        bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, NULL);\n\n        monitor_printf(mon, \"\\n\");\n\n        for (i = 0; i < total; i++) {\n\n            sn = &sn_tab[available_snapshots[i]];\n\n            bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, sn);\n\n            monitor_printf(mon, \"\\n\");\n\n        }\n\n    } else {\n\n        monitor_printf(mon, \"There is no suitable snapshot available\\n\");\n\n    }\n\n\n\n    g_free(sn_tab);\n\n    g_free(available_snapshots);\n\n\n\n}\n", "idx": 12558, "substitutes": {"mon": ["gor", "mun", "con", "dm", "meter", "mer", " monitor", "tem", "met", "dom", "monitor", "amon", "med", "sim", "tom", "util", "hon", "cat", "comm", "rain", "pen", "admin", "mut", "an", "mic", "m", "annot", "monkey", "von", "mn", "ren", "gran", "san", "chron", "my", "Mon", "plain", "unit", "MON", "ann", "form", "mas", "don", "demon", "hog", "num", "mx", "den", "mons", "dis", "mt", "mm", "det", "conn", "non", "gun", "ston", "net", "mi", "cmd", "man", "onet", "mat", "mont", "mu"], "qdict": [" qd", "Qict", "qict", "Qdir", "sqd", " qdir", "Qdict", "Qd", "sqict", "qdir", "sqdict", "qd", " qict", "sqdir"], "bs": ["bos", "bu", "fs", "sb", "bl", "aos", "bc", "os", "bes", "hz", "bh", "bn", "ps", "cb", "sys", "pb", "ls", "vs", "gs", "b", "its", "js", "lbs", "bles", "bb", "bis", "bas", "res", "cks", "ys", "bps", "bed", "BS", "ds", "ubs", "cs", "ts", "bits", "base", "stats", "bi", "ists", "obj", "bm", "obs", "ns"], "bs1": ["cs3", "absnew", "cks10", "cs1", "js1", "bs3", "bps01", "lbsOne", "bos0", "cks01", "lbs1", "cs2", "bsx", "bps11", "js11", "sb5", "ns2", "cksone", "bs9", "bsone", "bps1", "cks5", "bc1", "ps11", "bc01", "ps1", "bos9", "cks2", "ts10", "cs9", "bs0", "ns9", "ps2", "bcOne", "bs2", "jsOne", "bs01", "ns3", "ts11", "bps10", "lbs11", "cs0", "cksx", "cksnew", "ps0", "ts1", "bsOne", "bs5", "cks9", "sb2", "bhOne", "ns0", "bh1", "cs01", "bsnew", "bs10", "psOne", "BS2", "csOne", "bpsx", "cks1", "lbsone", "sb9", "bos1", "bpsone", "bh0", "ps3", "bc0", "BS9", "BS0", "psone", "bs11", "jsone", "ns1", "cs5", "abs01", "abs1", "bh01", "cks11", "BS1", "absx", "sb1", "bos2", "tsone", "bpsnew"], "sn_tab": ["sn__tmp", "SN_list", "pn_info", "sn__info", "SN_info", "sn_Tab", "sn2list", "sn2Tab", "snpttmp", "ns_info", "SN_bed", "sn2bag", "pn_tab", "sn_bed", "ns_tab", "sn_stab", "ns__tab", "ns_ct", "ns_Tab", "n_tab", "sn_ct", "ns__info", "ns__Tab", "sn__ct", "snpttab", "snptTab", "n_tmp", "sn2info", "sn_tmp", "sn__Tab", "n_Tab", "n__tmp", "pn_stab", "sn2tab", "ns__ct", "n__Tab", "n__tab", "SN_tab", "sn_bag", "pn_bag", "sn2stab", "sn__tab", "SN_Tab", "sn_list"], "sn": ["dn", "n", "Sn", "sb", "tn", "sl", "serv", "bl", "null", "txt", "gn", "sql", "nu", "np", "sv", "bn", "cn", "st", "p", "si", "nm", "sam", "ls", "syn", "nil", "pn", "ln", "nt", "SN", "fn", "sp", "nr", "sk", "sa", "ni", "nn", "sd", "sw", "sq", "sr", "nl", "nat", "snap", "sc", "stat", "sync", "ns"], "s": ["h", "fs", "rs", "n", "sb", "sl", "S", "sv", "c", "st", "ps", "p", "sys", "si", "m", "sam", "syn", "xs", "aws", "gs", "b", "js", "sa", "sp", "services", "sq", "t", "ds", "ts", "is", "sm", "v", "stats", "ns", "ss"], "sn_info": ["sn__stat", "sn_fo", "SN_tab", "syn_inf", "sn__info", "SN_info", "sn_stat", "syn_stat", "syn_info", "SN_fo", "sn__Info", "sn_inf", "sn_data", "SN_data", "syn_Info", "sn_Info", "sn__inf"], "nb_sns": ["nbjsds", "nb_lns", "nb2dxs", "nb_Sicks", "nb_jscs", "nb_nqs", "nb_ssprints", "nb_jsns", "nb_sqrees", "nb_sms", "nbjsnapcs", "nb_nsxs", "nb_sqlns", "nbjsnapocks", "nb_drees", "nbjsnapns", "nb_micks", "nb_Sms", "nb_syks", "nb_socks", "nb_synns", "nbjsocks", "nb_ncs", "nb_sqns", "nb_sockets", "nb_snapicks", "nb2srees", "nb_mprints", "nb_lizes", "nb_jsxs", "nb_nscs", "nb_sqxs", "nb_syncs", "nb_Sns", "nbjscs", "nb_mbs", "nb_nsks", "nb_sqlts", "nb_sks", "nb_sycs", "nb_snapcs", "nb_dns", "nb_lbs", "nb_nrees", "nb_nxs", "nb2sns", "nb_sqlites", "nb_sinns", "nb_snapocks", "nb_synds", "nb_syns", "nb2dcs", "nb_mizes", "nb2sxs", "nb_Sockets", "nb2drees", "nb_sprints", "nb_mockets", "nb_sxs", "nb_syocks", "nbjsns", "nb_nsites", "nb_scs", "nbjsnapds", "nb_nsns", "nb_nns", "nb_ssizes", "nb_sts", "nb_dcs", "nb_synocks", "nb_mcs", "nb_syites", "nb_dxs", "nb_sizes", "nb_sites", "nb_snapockets", "nb_ssbs", "nb_Sqs", "nb_sqlks", "nb2dns", "nb_sds", "nb_mns", "nb_nsockets", "nb_sinqs", "nb_sincs", "nb_lprints", "nb2scs", "nb_syts", "nb_syds", "nb_nms", "nb_sqs", "nb_snapns", "nb_snapds", "nb_srees", "nb_mms", "nb_sinms", "nb_nsts", "nb_sicks", "nb_sqcs", "nb_snapms", "nb_Scs", "nb_jsockets", "nb_sbs", "nb_ssns", "nb_mxs"], "i": ["cli", "gu", "oi", "it", "ci", "ie", "inter", "ki", "zi", "mi", "y", "uri", "info", "ii", "ji", "ij", "init", "hi", "er", "m", "ri", "multi", "at", "j", "xi", "t", "ix", "is", "print", "f", "ui", "ini", "qi", "ind", "l", "ai", "di", "x", "c", "ti", "li", "\u0438", "I", "si", "batch", "ori", "im", "in", "ims", "fi", "index", "phi", "pi", "bi", "io", "n", "gi", "point", "sim", "ip", "ei", "p", " I", "b", "e", "ami", "iu", "id", "me", "ic", "v"], "ret": ["info", "ref", "RET", "elt", "nz", "success", "out", "re", "reg", "Ret", "result", "true", "ne", "flag", "alt", "mem", "repl", "nt", "count", "len", "fun", "it", "res", "red", "back", "j", "rex", "num", "rm", "mt", "try", "gt", "found", "t", "arg", "net", "rets", "nat", "resp", "rt", "cmd", "val", "backed", "rem"], "available": ["accessible", "Available", "created", "usable", "unique", "released", "external", "util", "confirmed", "important", "balanced", "enabled", "selected", "sofar", "eligible", " unavailable", "ready", "annot", "provided", "played", "valid", "occupied", "empty", "loaded", "active", "stable", "volume", "published", "availability", "authorized", "missing", "ful", "public", "used", "found", "readable", "required", "able", "installed", "verified", "allowed", "checked", "visible", "filled", "initialized"], "total": ["details", "equal", "sum", "created", "menu", "unique", "eta", "parent", " tot", "last", "summary", "complete", "title", "next", "full", "confirmed", "local", "sequence", "result", " all", " done", "global", " complete", "set", "list", "m", "database", "played", "valid", "recent", "made", "trace", "count", "final", "no", "stable", "note", "active", "done", "to", "volume", "size", "it", "collection", "public", "max", "meta", "used", "t", "required", "net", " TOTAL", "all", "base", "checked", "table", "Total", "length", "otal", "current", "ta"], "available_snapshots": ["available_apshot", "available_namesprints", "available_namesots", "available_poolposts", "available_newsouts", "available_spets", "available_spshots", "available_snapaps", "available_synets", "available_snapets", "available_consshot", "available_blocksicas", "available_synouts", "available_captocks", "available_snapicas", "available_snapigs", "available_spshot", "available_poolots", "available_newsigs", "available_captets", "available_spocks", "available_hotsouts", "available_saps", "available_snapprints", "available_hotsshots", "available_poolshots", "available_consshots", "available_presshot", "available_sots", "available_potshots", "available_presicas", "available_apets", "available_consaps", "available_sshots", "available_sshot", "available_newsshots", "available_hotsets", "available_namesposts", "available_snapouts", "available_snapposts", "available_presots", "available_dataposts", "available_presshots", "available_synigs", "available_snapocks", "available_snapreenshots", "available_presreenshots", "available_dataprints", "available_poticas", "available_snapots", "available_synshots", "available_captshot", "available_newsets", "available_apocks", "available_apshots", "available_potots", "available_poolprints", "available_hotsigs", "available_blocksreenshots", "available_blocksots", "available_namesshots", "available_potreenshots", "available_snapshot", "available_datashots", "available_consots", "available_presaps", "available_captshots", "available_dataots", "available_blocksshots"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],\n\n                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],\n\n                        int i, int zero_nhood, int16_t qmul[2])\n\n{\n\n    uint8_t *token_prob = probs[i][zero_nhood];\n\n    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB\n\n        return 0;\n\n    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);\n\n}\n", "idx": 12585, "substitutes": {"c": ["h", "ch", "d", "l", "con", "n", "bc", "lc", "dc", "cmp", "cm", "cp", "cb", "cu", "p", "s", "mc", "r", "m", "C", "b", "e", "tc", "cc", "rc", "com", "gc", "ce", "g", "cf", "cl", "ct", "ec", "t", "ca", "cs", "fc", "sc", "ac", "cr", "v", "f", "cd", "co"], "block": ["channel", "type", "ref", "image", "time", "bl", "map", "bc", "word", "node", "out", "hash", "byte", "pool", "frame", "number", "bus", "list", "blocks", "pos", "chain", "box", "field", "array", "buffer", "index", "object", "bit", "load", "range", "lock", "row", "bin", "board", "data", "model", "cl", "config", "Block", "base", "label"], "probs": [" Progs", "prgs", "Provs", "provs", "Probes", "rops", "prob", " prob", " probes", "prps", " provs", "robs", " Provs", " progs", "Props", " Prob", " Probs", "Prob", "prbes", "props", "Progs", " props", "prbs", "robes", "Probs", "progs", "probes", "rob"], "i": ["ind", "l", "ai", "ii", "n", "k", "z", "di", "x", "ij", "u", "ti", "li", "I", "p", "r", "si", "ori", "m", "oi", "key", "b", "e", "index", "id", "it", "j", "ci", "xi", "ic", "ki", "t", "zi", "mi", "o", "a", "iri", "pi", "v", "y", "bi", "f"], "zero_nhood": ["zero_nigh", "zero_dhood", "zero_nood", "zero_most", "zero_mhood", "zero_dood", "zero_Nhood", "zero_Nith", "zero_nith", "zero_Noh", "zero_noh", "zero_snigh", "zero_Nigh", "zero_nost", "zero_snhood", "zero_Nood", "zero_snost", "zero_dith", "zero_snoh", "zero_migh", "zero_digh", "zero_moh", "zero_Nost"], "qmul": [" qrmuli", "qnmuli", " qmult", "qmtUL", "qrmult", "qmUL", "qnmUL", "qnmul", "qrmaj", "qMuli", "qmtult", "qMUL", "qcmul", " qrmul", "qmult", "qmuli", "qmtul", " qmaj", "qrmul", "qmaj", " qrmUL", "qrmUL", " qmUL", "qcmult", " qmuli", "qmtaj", "qcmUL", "qcmaj", "qMul", " qrmult", "qnmult", "qrmuli", " qrmaj", "qMult"], "token_prob": ["token_Proz", "token_robs", "token_probs", "token_priz", "token2prog", "token_Probe", "token_rog", "token_prebe", "token_pribs", "token_prbs", "token_preb", "token_Probs", "token_Prob", "token2prob", "token2probs", "token_prog", "token_prig", "token_Prop", "token2Probe", "token_probe", "token_prb", "token_rop", "token2Probs", "token_preg", "token_prop", "token_prg", "token_prbe", "token2Prob", "token_prib", "token_Prog", "token_proz", "token2probe", "token2Prog", "token_prebs", "token_rob"]}}
{"project": "qemu", "commit_id": "913a87885f589d263e682c2eb6637c6e14538061", "target": 1, "func": "static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)\n\n{\n\n    cirrus_fill_t rop_func;\n\n\n\n    if (blit_is_unsafe(s)) {\n\n        return 0;\n\n    }\n\n    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n\n    rop_func(s, s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\n             s->cirrus_blt_dstpitch,\n\n             s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n\t\t\t     s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n\t\t\t     s->cirrus_blt_height);\n\n    cirrus_bitblt_reset(s);\n\n    return 1;\n\n}\n", "idx": 12596, "substitutes": {"s": ["bs", "fs", "ties", "ps", "r", "args", "ms", "ports", "js", "sw", "ex", "se", "y", "ins", "details", "h", "changes", "sb", "ops", "results", "os", "als", "sv", "set", "m", "events", "as", "ags", "t", "states", "is", "ains", "south", "parts", "ns", "mods", "l", "rs", "ies", "S", "c", "st", "comm", "eps", "sys", "ls", "vs", "hs", "ats", "in", "its", "ims", "sq", "ts", "a", "bits", "wcs", "qs", "ss", "sts", "i", "aunts", "n", "z", "ses", "state", "aus", "conf", "p", "es", "aws", "gs", "bis", "less", "ds", "cs", "v", "stats"], "blt_rop": ["blt_op", "bltCop", "blt_ro", "blt__crop", "blrt__ro", "blrt__op", "blt__ro", "blrt__prop", "blt__wp", "blrt_wp", "blt_wp", "blt__op", "blt__rop", "blt__prop", "blrt__rop", "blrt_rop", "bltCrop", "bltCro", "blt_crop", "blrt_ro", "blt_prop", "blrt_op", "blrt_crop", "bltCprop", "blrt_prop"], "rop_func": ["rop2func", "rop2fc", "grab_unc", "rop2unc", "prop_fun", "grab2unc", "rop_imp", "grab2function", "grab2func", "prop_fac", "grab_fc", " crop_func", "grab_function", "grab2fc", " crop_imp", "rop_unc", " crop_val", "prop_func", "rop2function", "rop_val", "rop_fc", "grab_func", "rop_fun", "rop_fac", "rop_function"]}}
{"project": "FFmpeg", "commit_id": "f5be84cfbc9c132a867ae8a8c0e0de26ed1a4e88", "target": 1, "func": "static int load_ipmovie_packet(IPMVEContext *s, AVIOContext *pb,\n\n    AVPacket *pkt) {\n\n\n\n    int chunk_type;\n\n\n\n    if (s->audio_chunk_offset) {\n\n\n\n\n\n\n\n\n        /* adjust for PCM audio by skipping chunk header */\n\n        if (s->audio_type != CODEC_ID_INTERPLAY_DPCM) {\n\n            s->audio_chunk_offset += 6;\n\n            s->audio_chunk_size -= 6;\n\n\n\n\n        avio_seek(pb, s->audio_chunk_offset, SEEK_SET);\n\n        s->audio_chunk_offset = 0;\n\n\n\n        if (s->audio_chunk_size != av_get_packet(pb, pkt, s->audio_chunk_size))\n\n            return CHUNK_EOF;\n\n\n\n        pkt->stream_index = s->audio_stream_index;\n\n        pkt->pts = s->audio_frame_count;\n\n\n\n        /* audio frame maintenance */\n\n        if (s->audio_type != CODEC_ID_INTERPLAY_DPCM)\n\n            s->audio_frame_count +=\n\n            (s->audio_chunk_size / s->audio_channels / (s->audio_bits / 8));\n\n        else\n\n            s->audio_frame_count +=\n\n                (s->audio_chunk_size - 6) / s->audio_channels;\n\n\n\n        av_dlog(NULL, \"sending audio frame with pts %\"PRId64\" (%d audio frames)\\n\",\n\n                pkt->pts, s->audio_frame_count);\n\n\n\n        chunk_type = CHUNK_VIDEO;\n\n\n\n    } else if (s->decode_map_chunk_offset) {\n\n\n\n        /* send both the decode map and the video data together */\n\n\n\n        if (av_new_packet(pkt, s->decode_map_chunk_size + s->video_chunk_size))\n\n            return CHUNK_NOMEM;\n\n\n\n        if (s->has_palette) {\n\n            uint8_t *pal;\n\n\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n\n                                          AVPALETTE_SIZE);\n\n            if (pal) {\n\n                memcpy(pal, s->palette, AVPALETTE_SIZE);\n\n                s->has_palette = 0;\n\n\n\n\n\n        pkt->pos= s->decode_map_chunk_offset;\n\n        avio_seek(pb, s->decode_map_chunk_offset, SEEK_SET);\n\n        s->decode_map_chunk_offset = 0;\n\n\n\n        if (avio_read(pb, pkt->data, s->decode_map_chunk_size) !=\n\n            s->decode_map_chunk_size) {\n\n            av_free_packet(pkt);\n\n            return CHUNK_EOF;\n\n\n\n\n        avio_seek(pb, s->video_chunk_offset, SEEK_SET);\n\n        s->video_chunk_offset = 0;\n\n\n\n        if (avio_read(pb, pkt->data + s->decode_map_chunk_size,\n\n            s->video_chunk_size) != s->video_chunk_size) {\n\n            av_free_packet(pkt);\n\n            return CHUNK_EOF;\n\n\n\n\n        pkt->stream_index = s->video_stream_index;\n\n        pkt->pts = s->video_pts;\n\n\n\n        av_dlog(NULL, \"sending video frame with pts %\"PRId64\"\\n\", pkt->pts);\n\n\n\n        s->video_pts += s->frame_pts_inc;\n\n\n\n        chunk_type = CHUNK_VIDEO;\n\n\n\n    } else {\n\n\n\n        avio_seek(pb, s->next_chunk_offset, SEEK_SET);\n\n        chunk_type = CHUNK_DONE;\n\n\n\n\n\n\n    return chunk_type;\n", "idx": 12607, "substitutes": {"s": ["bs", "fs", "esm", "status", "http", "ps", "args", "ms", "ports", "js", "g", "sw", "se", "y", "ins", "sis", "details", "h", "changes", "sb", "series", "ops", "results", "als", "os", "sv", "set", "m", "sports", "events", "as", "ags", "is", "south", "parts", "ns", "tes", "mods", "l", "rs", "sl", "ies", "S", "c", "eps", "comm", "sys", "ess", "ls", "vs", "uploads", "hs", "ats", "its", "ims", "sq", "sets", "https", "ts", "bits", "qs", "sts", "ss", "i", "ans", "n", "ants", "ses", "state", "conf", "p", "es", "xs", "aws", "gs", "e", "spec", "bis", "less", "ds", "cs", "comments", "v", "stats", "ists", "w"], "pb": ["pkg", "uf", "bs", "jp", "fp", "lp", "sb", "asm", "pc", "conv", "tk", "rb", "pa", "buf", "px", "pool", "np", "lb", "cp", "cb", "patch", "pl", "p", "wp", "sys", "tf", "vp", "tc", "b", "tp", "mp", "apy", "pg", "ctx", "dial", "bb", "cv", "kt", "PB", "proc", "func", "phys", "bp", "pt", "phy", "pan", "cmd", "pp", "wb", "td"], "pkt": ["pkg", "wpix", "wpkt", "wpct", "paykg", "paykt", "punk", "pingck", " pix", "spgt", "pckt", "wpkg", "pcacket", "pwt", "pingkt", " pck", "pix", " pet", "tpkt", " ptxt", "ptx", "pcix", "prkg", "payow", " pkg", "pcmd", " packet", "Packet", "pinget", "pingfet", "pfet", "wpacket", "pet", "prct", "pck", "pcgt", "payunk", "tpwt", "pingtx", "payct", "pracket", "tpcmd", " pwt", "prkt", " pct", "Pet", "Pkt", " pfet", "pcow", "Ptx", "spkt", "pctxt", "ptxt", "spct", "paycmd", "pgt", "spacket", "spow", "paygt", "payfet", " ptx", "packet", "pingacket", "pct", "payck", " pcmd", "tpkg", "spunk", "pingct", "payacket", " punk", "paywt", "wptxt"], "chunk_type": ["chunkingTYPE", "chunk_style", "chunkingset", "chunkingid", "chunktypestyle", "chunks_tag", "chunktypetype", "chunks_type", "chunk_set", "chunkingtype", "chunk_TYPE", "chunk_id", "chunk_name", "chunktypetag", "chunks_style", "chunk_tag", "chunks_name", "chunktypename"], "pal": ["cal", "stal", "py", "color", "cel", "pol", "wal", "fac", "local", "phal", "face", "pillar", "Pal", "col", "dal", "ps", "ul", "ap", " Pal", "pl", "p", "kl", "arr", "isal", "cam", "pill", "batch", "pro", "cell", "buff", "qq", "mem", "pard", "sal", "ele", "al", "font", "hal", "data", "bin", "quant", "el", "pat", "phil", "pixel", "mel", "pp", "val", "par", "ph", "mat", "ass", "dat"]}}
{"project": "FFmpeg", "commit_id": "f21cf2b38365caaa8a130a32521c2648600c3f50", "target": 0, "func": "static int encode_hq_slice(AVCodecContext *avctx, void *arg)\n\n{\n\n    SliceArgs *slice_dat = arg;\n\n    VC2EncContext *s = slice_dat->ctx;\n\n    PutBitContext *pb = &slice_dat->pb;\n\n    const int slice_x = slice_dat->x;\n\n    const int slice_y = slice_dat->y;\n\n    const int quant_idx = slice_dat->quant_idx;\n\n    const int slice_bytes_max = slice_dat->bytes;\n\n    uint8_t quants[MAX_DWT_LEVELS][4];\n\n    int p, level, orientation;\n\n\n\n    avpriv_align_put_bits(pb);\n\n    skip_put_bytes(pb, s->prefix_bytes);\n\n    put_bits(pb, 8, quant_idx);\n\n\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n\n    for (level = 0; level < s->wavelet_depth; level++)\n\n        for (orientation = !!level; orientation < 4; orientation++)\n\n            quants[level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0);\n\n\n\n    /* Luma + 2 Chroma planes */\n\n    for (p = 0; p < 3; p++) {\n\n        int bytes_start, bytes_len, pad_s, pad_c;\n\n        bytes_start = put_bits_count(pb) >> 3;\n\n        put_bits(pb, 8, 0);\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n\n            for (orientation = !!level; orientation < 4; orientation++) {\n\n                encode_subband(s, pb, slice_x, slice_y,\n\n                               &s->plane[p].band[level][orientation],\n\n                               quants[level][orientation]);\n\n            }\n\n        }\n\n        avpriv_align_put_bits(pb);\n\n        bytes_len = (put_bits_count(pb) >> 3) - bytes_start - 1;\n\n        if (p == 2) {\n\n            int len_diff = slice_bytes_max - (put_bits_count(pb) >> 3);\n\n            pad_s = FFALIGN((bytes_len + len_diff), s->size_scaler)/s->size_scaler;\n\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n\n        } else {\n\n            pad_s = FFALIGN(bytes_len, s->size_scaler)/s->size_scaler;\n\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n\n        }\n\n        pb->buf[bytes_start] = pad_s;\n\n        flush_put_bits(pb);\n\n        skip_put_bytes(pb, pad_c);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12616, "substitutes": {"avctx": ["vrcfg", "savctx", "savcontext", "avcontext", "vrcontext", " avcfg", "vrctl", "vrctx", "avcfg", "savcfg", "savctl", " avcontext", " avctl", "avctl"], "arg": ["event", "ark", "ref", "ax", "ag", "reg", "ar", "argument", "arr", "args", "cell", "ang", "slice", "ng", "ctx", "agg", "g", "ay", "rg", "og", "ad", "arc", "Arg", "conn", "gate", "anc", "param", "attr", "ray", "vol", "ary", "ig", "cmd", "val", "v", "arp", "doc", "call"], "slice_dat": ["slice2ann", "sliceGdates", "sliceptdat", "sliceobjdata", "slicemmdat", "slice_at", "tile2dt", "angle_dec", "slicemyat", "sliceptann", " slice_data", "sliceobjgrad", "copy_dat", "plot_at", "tile2dat", "slice_dt", "slicemmdata", "tile_dat", "sliceobjdat", "tile_dt", "slice_data", "sliceaxydef", "slice_def", " slice_dates", "sliceGdat", "slicemynit", "sliceaxyat", "slice_np", "angle_dat", "slice_ann", " slice_nat", "slice_note", "sliceptnote", "tile2note", " slice_iat", "slice___pat", "slice_reg", "copy_pat", "sliceGnat", "slice___ann", "copy_iat", " slice_reg", "slice_grad", "slice___rat", "slice_nit", "slice_rat", "angle_np", "sliceptdt", "slice_dates", "sliceabledec", "slice2dat", "angle_grad", "sliceobjrat", "tile_note", "plot_nit", "sliceobjdates", "slice___dat", "sliceobjnp", "slice2note", "slice___iat", "slice_iat", "plot_dat", "slice___dates", "slicemydef", "slice_nat", "sliceGdata", "slicemmiat", "slice2dt", "sliceablegrad", "sliceaxydat", "sliceaxyann", "sliceaxyiat", "slicemmreg", "slice___data", "sliceaxynit", "slicemydat", "tile2ann", "sliceablenp", "sliceaxypat", "tile_ann", " slice_rat", "slice_pat", "plot_def", "slice_dec", "copy_ann", "sliceobjdec", "sliceabledat"], "s": ["bs", "i", "h", "fs", "l", "rs", "sg", "sb", "sl", "ses", "S", "os", "als", "c", "sv", "ps", "comm", "sys", "r", "es", "ssl", "m", "ls", "vs", "sam", "hs", "aws", "ms", "gs", "b", "ats", "js", "sa", "ctx", "sp", "sts", "spec", "ims", "g", "sq", "sd", "less", "t", "ds", "self", "se", "cs", "ts", "sc", "is", "a", "v", "stats", "f", "sis", "y", "ins", "qs", "obj", "ns", "ss"], "pb": ["pkg", "uf", "bs", "stab", "jp", "fp", "lp", "sb", "asm", "pc", "tmp", "dp", "bj", "rb", "tk", "pa", "peer", "buf", "pool", "tab", "px", "np", "lb", "cp", "cb", "bh", "patch", "ps", "pl", "wp", "sys", "tg", "tf", "gp", "vp", "tc", "pd", "fb", "tp", "pg", "mp", "buffer", "vt", "ctx", "sp", "bb", "cv", "gc", "erb", "cpp", "PB", "proc", "nb", "bps", "pack", "func", "bp", "snap", "pt", "resp", "cmd", "pp", "wb", "emb", "td", "pause", "vm", "gb", "pm", "ub"], "quants": ["constants", "QUants", "constANT", "requANT", "quands", "squants", "equands", " quands", "quANT", "requands", " quats", "equant", "QUents", "constant", "QUant", " quant", "requats", "quant", "equants", "requents", "squents", "requants", "quats", "QUANT", "QUands", "quents", "QUats", "squands", "equANT", "constands", "requant", "squats", " quANT"], "MAX_DWT_LEVELS": ["MAX_DWT_LEPEPS", "MAX_DWT_LEPSLS", "MAX_DWT_LOVELPS", "MAX_DWT_LEPSPS", "MAX_DWT_LEPELS", "MAX_DWT_LOPEPS", "MAX_DWT_LEPSVS", "MAX_DWT_LEVELPS", "MAX_DWT_LOVELS", "MAX_DWT_LEPEVS", "MAX_DWT_LOPES", "MAX_DWT_LEVELLS", "MAX_DWT_LEPSS", "MAX_DWT_LELEPS", "MAX_DWT_LELEVS", "MAX_DWT_LEPES", "MAX_DWT_LOPELS", "MAX_DWT_LOPEVS", "MAX_DWT_LELELS", "MAX_DWT_LEVELVS", "MAX_DWT_LOVELLS", "MAX_DWT_LOVELVS", "MAX_DWT_LELES"], "p": ["pkg", "i", "h", "d", "ind", "jp", "l", "prop", "lp", "power", "n", "pc", "pe", "k", "point", "x", "local", "pa", "ip", "depth", "pid", "pers", "q", "cp", "c", "ps", "ap", "pl", "pre", "r", "m", "pro", "vp", "port", "pn", "pos", "b", "e", "pg", "tp", "sp", "per", "P", "g", "at", "j", "pod", "press", "pat", "ep", "t", "po", "pr", "pt", "part", "o", "pp", "pi", "perm", "par", "f", "v", "ping", "post"], "level": ["low", "status", "padding", "what", "priority", "ps", "kl", "vel", "L", "all", "stack", "peer", "group", "half", "levels", "family", "tag", "zero", "pro", "member", "loop", "loss", "Level", "limit", "cost", "zone", "broad", "roll", "po", "print", "f", "length", "ping", "location", "rel", "role", "ind", "l", "ble", "type", "version", "pri", "condition", "pe", "pc", "summary", "impact", "thread", "compl", "loc", "pl", "key", "where", "lo", "trace", "count", "no", "al", "volume", "index", "mode", "op", "coll", "variable", "stage", "fl", "layer", "cond", "val", "pp", "high", "call", "goal", "quality", "fall", "point", "lc", "go", "local", "state", "col", "depth", "global", "scale", "lay", "lvl", "window", "per", "pal", "tier", "row", "el", "VEL", "vol", "le", "scope", "v", "diff", "label"], "orientation": ["projectation", "anchation", "rientational", " orientication", "iterATION", "projectaton", "anchization", " orientification", "roturation", "iterational", "designotation", "elongation", "rotization", "designification", "anchion", " orientacion", "transformation", "elongication", "rientotation", "iterication", "transformication", "orientotation", "collation", "orientity", "portication", "projectication", "rientization", "designization", "elongization", " orientization", "orientication", "collion", "directionacion", "collATION", "orientization", "portacion", "rientation", "layoutization", "orienturation", "designation", "elongration", "anchATION", "orientational", "orientATION", "horration", "designator", "horization", "layoutator", "iteration", "directionication", "designATION", "iterization", " orientity", "rotation", "collization", "directionration", "elongacion", "directionization", "rotacion", "rientity", "layoutotation", "orientator", "transformration", "transformotation", "rientator", "rientication", "elongational", "portation", "orientification", "orientaton", "orientration", "designity", "rotator", "designration", "oriention", "elongATION", "rientification", "orientacion", " orienturation", "directionation", "horotation", "rientATION", "layoutation", "rotity", "rienturation", "horation", " orientator", "riention", "rotication", " orientATION", "projectacion", "rotATION", "elongaton", "transformization", "portaton", "directionuration"], "bytes_start": ["bytes5first", " bytes_origin", " bytesxend", "tes_len", "bits_len", "bytesxorigin", "bits_iter", "bytesxstart", "bits_start", " bytesxorigin", "bytes_first", "bits_begin", "bytes__len", "bytes2len", "bytes_iter", "bytes5begin", "bytes__iter", "bytes5len", "bytesxiter", " bytes_iter", "bytes2start", "tes_start", "bytes5start", "tes_begin", "bytes2first", " bytesxstart", " bytesxiter", "bytes_origin", "bytes__begin", "bytesxend", "bytes_begin", " bytes_end", "tes_first", "bytes__start", "bytes_end", "bytes2begin"], "bytes_len": ["bytes10del", " bytes32win", "bytes5diff", "bytes64lon", "bytes_diff", "bytes64lim", "bytes_rel", "Bytes_Len", "tes_", " bytes64rel", "bytes32del", "bytes_win", " bytes_del", " bytes64len", "Bytes_lon", " bytes32del", " bytes64lim", "bytes64rel", "bytes5len", "bytes64Len", "cells_", " bytes32diff", " bytes_diff", " bytes2", "bytes_lon", " bytes_", "tes2", "bytes_lim", "bytes10win", "Bytes_start", "bytes32win", " bytes_rel", "bytes32len", "bytes5rel", "bytes64start", "bytes5win", "bytes_del", "bytes5start", " bytes64start", "bytes_", "bytes10len", "Bytes_len", "bytes10diff", "bytes5del", " bytes_win", " bytes_lim", "bytes5lim", " bytes32len", "bytes64len", "bytes32diff", "bytes2", "cells2", "bytes_Len"], "pad_s": ["padajsam", "padablesam", "padpts", "pad_sl", "padajs", "padajsi", "pad_sam", "pod_s", "padptin", "padablers", "pad_v", "pad_in", "pad_n", "pad___in", "pen_si", "penablers", "penablesam", "pod_v", "pad_rs", "padables", "penablesi", "pen_rs", "padding_s", "pad___s", "padajrs", "padptsl", "padding_n", "pen_s", "padding_c", "pod_sl", "pad_y", "pad___v", "padptv", "pod_in", "pad___sl", "pad_si", "pen_sam", "padding_y", "penables", "padablesi"], "pad_c": ["pad_cs", "pod67c", "pad67pc", "pad_i", "pad67m", "quoteurerc", "pad_pc", "quoteurec", "quote_c", "pad__mc", "pad__c", "padurec", "pad67c", "pod67m", "padurecs", "pad__m", "quote_cs", "quoteurei", "pad_rc", "padMemc", "quote_rc", "pad__pc", "padMemm", "pod67pc", "pod_mc", "quoteurecs", "pod_m", "padurerc", "pad67mc", "pad_mc", "pod_c", "pad_m", "padMemmc", "padMempc", "padurei", "pod_pc", "quote_i", "pod67mc"]}}
{"project": "qemu", "commit_id": "2e061a7c86d77c599676d89c3461f8efe9c275b1", "target": 0, "func": "static void do_info_commands(Monitor *mon, QObject **ret_data)\n\n{\n\n    QList *cmd_list;\n\n    const mon_cmd_t *cmd;\n\n\n\n    cmd_list = qlist_new();\n\n\n\n    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {\n\n        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&\n\n            !compare_cmd(cmd->name, \"info\")) {\n\n            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));\n\n        }\n\n    }\n\n\n\n    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {\n\n        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {\n\n            char buf[128];\n\n            snprintf(buf, sizeof(buf), \"query-%s\", cmd->name);\n\n            qlist_append_obj(cmd_list, get_cmd_dict(buf));\n\n        }\n\n    }\n\n\n\n    *ret_data = QOBJECT(cmd_list);\n\n}\n", "idx": 12624, "substitutes": {"mon": ["mun", "con", "dem", "dm", "om", "serv", "tem", "dom", "met", "monitor", "pers", "comm", "wat", "mut", "sam", "my", "Mon", "fn", "MON", "num", "bin", "mx", "mons", "mm", "mi", "man", "stat", "mu"], "ret_data": ["ret_list", "req_DATA", "ret_cache", "retrowlist", "return_list", "req_cache", "ret2da", "req_da", "ret2data", "retrowdata", "return_da", "retrowda", "ret_da", "req_data", "ret_DATA", "return_data", "ret2list"], "cmd_list": ["Cmd_lists", "commtspec", "comm_list", "cmd2l", "check_list", "Cmd_List", "check_table", "cmd7li", "comm_cache", " cmd2List", "cmdtspec", "cmd_lists", "cmd_single", "check_li", " cmd_single", "cmd_table", "cmd_li", "cmd2table", " cmd_status", "commtlist", "cmd_block", "cmd_info", "Cmd_block", "check_info", "Cmd_list", "cmd2li", "cmdlistspec", "cmd7info", "cmdtlist", "comm_spec", " cmd2list", "commtcache", "cmd_cache", "cmd2List", "cmd_status", "cmd_spec", "cmdtcache", "cmd_List", "cmd2info", "cmd7table", " cmd2l", " cmd_l", "cmd_l", "cmd2list", " cmd_List", "cmdlsingle", "cmd7list", "cmdlstatus", "cmdlistcache", "cmdlistlist", "cmdllist", "cmdlList"], "cmd": ["pkg", "bind", "ch", "norm", "send", "orig", "cli", "cmp", "cat", "addr", "cp", "cb", "check", "canon", "add", "urg", "method", "quit", "ann", "dep", "help", "Cmd", "pt", "prop", "serv", "component", "nd", "txt", "ctrl", "init", "del", "def", "cfg", "mk", "name", "good", "cod", "kt", "cf", "msg", "conn", "coord", "phy", "resp", "command", "form", "kind", "ind", "req", "om", "miss", "c", "exec", "comm", "ext", "sys", "batch", "nt", "kick", "gen", "op", "job", "normal", "unknown", "ct", "dq", "proc", "gt", "mt", "cond", "call", "go", "cur", "col", "nm", "desc", "raw", "qq", "md", "ctx", "cont", "act", "ctr", "crit", "config", "cd", "obj", "qt"], "buf": ["uf", "bs", "iq", "queue", "ff", "ref", "bar", "bytes", "xff", "tmp", "bc", "txt", "br", "tx", "rb", "out", "temp", "Buff", "cur", "result", "tab", "new", "cb", "cp", "bh", "vec", "err", "arr", "batch", "img", "pb", "raw", "buff", "mem", "b", "fb", "window", "box", "iter", "buffer", "ctx", "cv", "str", "Buffer", "cap", "msg", "data", "seq", "pad", "burst", "text", "var", "obj", "hold"]}}
{"project": "qemu", "commit_id": "f1c2dc7c866a939c39c14729290a21309a1c8a38", "target": 0, "func": "static void spapr_msi_write(void *opaque, hwaddr addr,\n\n                            uint64_t data, unsigned size)\n\n{\n\n    sPAPRPHBState *phb = opaque;\n\n    int ndev = addr >> 16;\n\n    int vec = ((addr & 0xFFFF) >> 2) | data;\n\n    uint32_t irq = phb->msi_table[ndev].irq + vec;\n\n\n\n    trace_spapr_pci_msi_write(addr, data, irq);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));\n\n}\n", "idx": 12635, "substitutes": {"opaque": ["ipane", "boaque", "ipaque", "OPen", " opatile", "opsaque", "OPa", "opa", "OPaque", "opsatile", "ropen", "opsaques", "ropaque", " opaques", "opane", "ropa", "boque", "opque", "boa", "open", "opsane", "opatile", "opaques", "ropque", "OPque", " opane", "boen", "ipatile", "ipaques"], "addr": ["ord", "ref", "rs", "address", "trans", "tx", " ip", "x", "off", "hash", "ip", "hop", "src", "np", "hw", "adr", "loc", "arr", "r", "err", "add", "ptr", "host", "dr", "handle", "name", "pos", "mem", "mac", "seek", "rc", "rr", " dst", "len", "ctx", "ack", "id", "url", "rn", "act", "ad", "at", "res", "offset", "inter", " address", "mt", "coord", "attr", "align", "ix", "pad", "cmd", "inv", "arp", "lr", "adv", "obj", "on"], "data": ["device", "d", "type", " DATA", "bytes", "n", "Data", "padding", "DATA", "tx", "format", "out", "hash", " Data", "buf", "ata", "def", "p", "zero", "r", "batch", "empty", "action", "any", "da", "raw", "name", "pos", "mem", "window", "dev", "buffer", "al", "len", "block", "to", "res", "str", "ad", "msg", "bin", "t", "pad", "text", "length", "w", "dat", "mu"], "size": ["shape", "h", "ize", " len", " n", "type", "address", "n", "SIZE", "z", "weight", "s", "name", " length", "mem", "e", "count", "len", "id", "offset", "num", " count", "cmd", "Size", "length", "w"], "phb": [" phbb", "mphb", "phc", "mphwb", " sshbb", " php", " sshb", " pha", "aphc", "aphwb", " ssha", "php", " haa", "mphc", " phwb", " hab", " hap", " habb", " phc", "pha", "phbb", "aphb", " sshp", "phwb"]}}
{"project": "qemu", "commit_id": "2a1639291bf9f3c88c62d10459fedaa677536ff5", "target": 0, "func": "static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;\n\n    if (addr > s->pm_base + PCMD31) {\n\n        /* Special case: PWRI2C registers appear in the same range.  */\n\n        pxa2xx_i2c_write(s->i2c[1], addr, value);\n\n        return;\n\n    }\n\n    addr -= s->pm_base;\n\n\n\n    switch (addr) {\n\n    case PMCR:\n\n        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);\n\n        s->pm_regs[addr >> 2] |= value & 0x15;\n\n        break;\n\n\n\n    case PSSR:\t/* Read-clean registers */\n\n    case RCSR:\n\n    case PKSR:\n\n        s->pm_regs[addr >> 2] &= ~value;\n\n        break;\n\n\n\n    default:\t/* Read-write registers */\n\n        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {\n\n            s->pm_regs[addr >> 2] = value;\n\n            break;\n\n        }\n\n\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n}\n", "idx": 12642, "substitutes": {"opaque": ["opssolete", "opose", "opsaque", "oopaque", "opsplex", "oppaque", "oppois", "opois", "oppsolete", "ropaque", "opponymous", " opaques", "opsolete", "ropaques", "oopose", "oppose", "roponymous", " opois", "opsose", "oponymous", "oopplex", "oppplex", "oopsolete", "opaques", "opplex", "ropois", " oponymous", "oppaques"], "addr": ["pkg", "rank", "ash", "map", "ag", "status", "lat", "cmp", "np", "sha", "r", "add", "ptr", "urg", "arm", "pos", "mem", "eq", "hl", "sw", "offset", "inter", "aro", "ak", "expr", "grad", "ace", "usr", "dt", "Address", "alloc", "here", "peer", "hash", "atom", "alias", "tag", "host", "tr", "ne", "tz", "env", "eth", "ack", "sp", "kt", "res", "msg", "conn", "coord", "nl", "order", "ix", "align", "link", "cmd", "req", "adj", "rs", "asm", "added", "x", "off", "dh", "adr", "loc", "arr", "err", "alt", "seek", "index", "ad", "amp", "gate", " address", "mt", "gt", "work", "rt", "a", "arp", "ord", "ref", "address", "elt", "z", "tx", "ip", "confirmed", "ar", "hw", "nm", "bound", "dr", "handle", "desc", "md", "rev", "db", "iter", "len", "ctx", "dd", "id", "str", "act", "arity", "attr", "pad", "ac", "obj", "w"], "value": [" Value", "type", "version", "address", "style", "hello", "json", "memory", "format", "state", "number", "new", "weight", "tree", "property", "p", "VAL", "message", "tag", "position", "operator", "key", "vp", "Value", "name", "code", "field", "buffer", "vt", "total", "attribute", "unit", "index", "ay", "size", "see", "values", "VALUE", "variable", "description", "data", "comment", "widget", "test", "fee", " val", "ue", "val", "function", "v", "length", "w", "current", "pair"], "s": ["bs", "fs", "ears", "space", "http", "ps", "ms", "ports", "js", "sa", "services", "g", "sh", "sw", "utils", "ares", "se", "sm", "y", "sync", "details", "h", "sol", "sb", "serv", "als", "sv", "store", "ssl", "sp", "j", "states", "is", "source", "ns", "rs", "sl", "ies", "S", "so", "service", "c", "comm", "eps", "sys", "ls", "vs", "reads", "hs", "ats", "ims", "sq", "acs", "ts", "bits", "qs", "params", "ss", "sts", "ses", "conf", "p", "es", "sam", "aws", "gs", "b", "spec", "bis", "less", "self", "ds", "stats"]}}
{"project": "qemu", "commit_id": "9c605cb13547a5faa5cb1092e3e44ac8b0d0b841", "target": 0, "func": "CPUX86State *cpu_x86_init(void)\n\n{\n\n    CPUX86State *env;\n\n    int i;\n\n    static int inited;\n\n\n\n    cpu_x86_tblocks_init();\n\n\n\n    env = malloc(sizeof(CPUX86State));\n\n    if (!env)\n\n        return NULL;\n\n    memset(env, 0, sizeof(CPUX86State));\n\n    /* basic FPU init */\n\n    for(i = 0;i < 8; i++)\n\n        env->fptags[i] = 1;\n\n    env->fpuc = 0x37f;\n\n    /* flags setup */\n\n    env->eflags = 0;\n\n\n\n    /* init various static tables */\n\n    if (!inited) {\n\n        inited = 1;\n\n        optimize_flags_init();\n\n    }\n\n    return env;\n\n}\n", "idx": 12645, "substitutes": {"env": ["export", "map", "server", "EN", "oe", "nv", "addr", "ape", "ptr", "et", "js", "hl", "cv", "caps", "ef", "esc", "inv", "emb", "event", "context", "worker", "end", "bar", "tmp", "here", "txt", "next", "init", "sv", "er", "forge", "def", "ah", "code", "ja", "rc", "buffer", "vt", "erd", "cap", "era", "msg", "en", "conn", "cmd", "policy", "doc", "ee", "ve", "buf", "ext", "uv", "err", "vs", "ent", "viron", "ev", "ew", "data", "proc", "ec", "var", "da", "dict", "priv", "V", "cur", "state", "global", "environment", "desc", "port", "entry", "e", "window", "dev", "db", "ctx", "manager", "ov", "el", "gear", "chart", "ped", "v", "obj", "up"], "i": ["qi", "ind", "ai", "ii", "ji", "n", "gi", "k", "di", "x", "sim", "cli", "ij", "ip", " bi", "ti", "li", "hi", "\u0438", "I", "p", " j", " I", "ei", "si", "client", "m", "oi", "asi", "im", "multi", "chain", "in", " v", "fi", "iu", "id", " ii", "it", "j", "me", "ci", "ie", "xi", "ic", "ki", " x", "phi", "zi", "ix", "mi", "pi", "v", " k", "bi", "ini", "y", "ui", "f", " ti", "PI"], "inited": ["inated", "innended", "innated", "intitted", "inended", " initialized", "Initialized", "init", " ininitialized", "INit", "Init", " initted", "initted", "ininitialized", "Inited", "INated", "INinitialized", "Initted", "INitialized", "intended", "innitted", "INitted", "Ininitialized", "intated", "INited", "innited", " init", "INended", "initialized", "intited"]}}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "void readline_show_prompt(ReadLineState *rs)\n\n{\n\n    monitor_printf(rs->mon, \"%s\", rs->prompt);\n\n    monitor_flush(rs->mon);\n\n    rs->last_cmd_buf_index = 0;\n\n    rs->last_cmd_buf_size = 0;\n\n    rs->esc_state = IS_NORM;\n\n}\n", "idx": 12663, "substitutes": {"rs": ["bs", "ks", "ck", "ars", "rb", "rings", "rpm", "ps", "cons", "Rs", "r", "ls", "vs", "dr", "xs", "hs", "ry", "rates", "rd", "acks", "ats", "ms", "its", "js", "rc", "rr", "as", "rh", "ims", "sts", "lbs", "rss", "ack", "res", "rl", "rows", "rm", "sr", "mr", "ys", "ctr", "RS", "ds", "ubs", "times", "cs", "rys", "ts", "rw", "rt", "gs", "ics", "ins", "ros", "ris", "qs", "ths", "ras", "obs", "ns", "ss"]}}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int parallel_parse(const char *devname)\n\n{\n\n    static int index = 0;\n\n    char label[32];\n\n\n\n    if (strcmp(devname, \"none\") == 0)\n\n        return 0;\n\n    if (index == MAX_PARALLEL_PORTS) {\n\n        fprintf(stderr, \"qemu: too many parallel ports\\n\");\n\n        exit(1);\n\n    }\n\n    snprintf(label, sizeof(label), \"parallel%d\", index);\n\n    parallel_hds[index] = qemu_chr_new(label, devname, NULL);\n\n    if (!parallel_hds[index]) {\n\n        fprintf(stderr, \"qemu: could not connect parallel device\"\n\n                \" to character backend '%s'\\n\", devname);\n\n        return -1;\n\n    }\n\n    index++;\n\n    return 0;\n\n}\n", "idx": 12667, "substitutes": {"devname": ["camName", "devicename", "devName", "evno", "evnam", " devlen", "evnames", "devlen", "camnames", "deviceno", " devnam", "devnames", "camnam", "devicelen", " devnames", "camname", " devName", "devno", "DevName", "Devname", "deviceName", "evname", "evlen", "Devno", "evName", "devnam"], "label": ["dl", "role", "ind", "kind", "l", "type", "child", "prefix", "color", "style", "summary", "node", "local", "slot", "group", "value", "tab", "alias", "loc", "tag", "list", "key", "cell", "desc", "lab", "name", "field", "block", "Label", "len", "loop", "member", "id", "str", "line", " Label", "layout", "msg", "data", "leader", "bool", "el", "comment", "binary", "abel", "LAB", "control", "leaf", "link", "sort", "val", "base", "mask", "delay"], "index": ["context", "i", "search", "ind", "version", "address", "ax", "n", "image", "level", "page", "success", "status", "point", "x", "thread", "connection", "ion", "draw", "value", "state", "number", "connected", "find", "connect", "available", "position", "capacity", "zero", "set", "Index", "batch", "check", "key", "scan", "list", "timeout", "name", "port", "pos", "seek", "count", "iter", "loop", "instance", "collection", "id", "total", "size", "j", "IND", "localhost", "offset", "num", "lock", "row", "max", "ex", "scroll", "order", "axis", "ix", "mount", "link", "length", "process", "location", "current"]}}
{"project": "qemu", "commit_id": "a9e1c28ddaae5a48415fec1f336b5560eb85d3e1", "target": 0, "func": "START_TEST(qfloat_destroy_test)\n\n{\n\n    QFloat *qf = qfloat_from_double(0.0);\n\n    QDECREF(qf);\n\n}\n", "idx": 12668, "substitutes": {"qf": ["qfac", "dqt", " queryf", "sqF", " queryfr", "qut", "qF", "dqfr", "quf", "qufr", "dqf", "sqt", "sqf", "qufac", "quF", "qfr", "dqfac", " queryt", "queryrf", "sqrf", " queryfac", "qurf", "queryF", "qrf", "queryf", "queryt", "qt"]}}
{"project": "qemu", "commit_id": "b97400caef60ccfb0bc81c59f8bd824c43a0d6c8", "target": 0, "func": "static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)\n\n{\n\n    int err;\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    err =  lstat(rpath(fs_ctx, path, buffer), stbuf);\n\n    if (err) {\n\n        return err;\n\n    }\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        /* Actual credentials are part of extended attrs */\n\n        uid_t tmp_uid;\n\n        gid_t tmp_gid;\n\n        mode_t tmp_mode;\n\n        dev_t tmp_dev;\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.uid\", &tmp_uid,\n\n                    sizeof(uid_t)) > 0) {\n\n            stbuf->st_uid = tmp_uid;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.gid\", &tmp_gid,\n\n                    sizeof(gid_t)) > 0) {\n\n            stbuf->st_gid = tmp_gid;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.mode\",\n\n                    &tmp_mode, sizeof(mode_t)) > 0) {\n\n            stbuf->st_mode = tmp_mode;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.rdev\", &tmp_dev,\n\n                        sizeof(dev_t)) > 0) {\n\n                stbuf->st_rdev = tmp_dev;\n\n        }\n\n    }\n\n    return err;\n\n}\n", "idx": 12672, "substitutes": {"fs_ctx": ["fps_tx", "fs_cc", "fsptctx", "fs_conn", "ns_ctx", "fs_func", "fs___ctx", "fs__ca", "fw___ctx", "ps_ctx", "cs_ctx", "cs_obj", "fs_cas", "fw_func", "ns_context", "fs_jp", "fs__tx", "fw_desc", "fsptconn", "fs_cur", "fw___jp", "fsgdesc", "ns_tx", "fsaccontext", "cs_tx", "fw___desc", "fsgctx", "fs_ctl", "fsaccur", "fs__cur", "fw_ctx", "fspttx", "fspthw", "fs_cmp", "fsacctx", "fs__ct", "ps_context", "fsacct", "rets_desc", "fs_obj", "ps_ct", "fs_context", "ps__ct", "fw_jp", "fs_tx", "ps_cur", "fs__ctx", "cs_cas", "fs_hw", "rets_cc", "ns_ca", "fs_ct", "qs_conn", "fs___desc", "fs___jp", "fps_hw", "rets_conn", "rets_ctx", "ps__cur", "ps__context", "fs_desc", "fsgjp", "ps__ctx", "fw___func", "qs_cmp", "fps_ctx", "fs__context", "qs_ctx", "fs_ca", "fs___func", "fps_conn", "fsgfunc", "qs_ctl"], "fs_path": ["fs2ctx", " fs_th", "fs_context", "cs_Path", " fs_pred", "cs_path", "cs_ctx", "fs2context", "fs2Path", " fs_cont", "cs_context", "fs_pred", "fs_th", "fs2path", "fs_Path", "fs_cont"], "stbuf": [" stbr", "astcv", "astbuff", "ostbuff", "restuf", "stdbuf", "ostuf", " stcv", "stBuff", "stduf", "putbr", " stbar", "Stbuff", "stdbuffer", "estcv", "lbuf", "ostcv", "stbuff", "stbuffer", "ostbuf", "Stbuf", " stbuff", "stbar", "stdbuff", "putbuff", "stdBuff", "restbuff", "astbuffer", "Stbuffer", "restbuffer", "stcv", " stbuffer", "estbuf", "putbuf", "stbr", "lcv", "stcb", "restbar", "stdbr", "restBuff", " stcb", "lcb", "astbuf", "ostbuffer", "putbuffer", "ostbr", "ostBuff", "restbuf", "Stbar", "stuf", "estcb"], "err": ["ch", " cr", " len", "timer", "cli", "error", "gz", "cp", "cb", "warn", "r", " ec", "ptr", " rc", "valid", "rr", "der", "it", "pr", "fer", " error", "cr", "Er", "gb", "h", "usr", "end", " wr", "here", "txt", "init", "er", "cer", "code", "rc", "aaa", "msg", "fr", "try", "coord", "order", "fee", "resp", "cmd", "kr", "or", "eas", "notice", "ns", "l", "req", " score", "die", "rb", "off", "buf", "c", " er", "arr", "count", " resp", "ev", "mr", " Err", "eor", "Error", "n", "priv", "state", "result", "conf", "ner", "e", "iter", "inner", " arr", "str", " count", " intr", "attr", "test", "obj"], "buffer": ["context", "bind", "queue", "phrase", "cache", "channel", "type", "directory", "package", "map", "extra", "stack", "header", "history", "temp", "format", "byte", "buf", "cp", "document", "alias", "message", "check", "filter", "append", "batch", "ptr", "cast", "empty", "raw", "callback", "buff", "read", "mem", "b", "code", "seek", "array", "iter", "block", "commit", "pointer", "index", "gc", "seed", "Buffer", "limit", "transform", "window", " Buffer", "comment", "binary", "template", "file", "pad", "base", "table", "command", "text", "length", "stream", "button"], "path": ["pkg", "context", "kind", "cache", "ref", "prefix", "prop", "end", "package", "PATH", "th", "route", "priv", "history", "temp", "node", "value", "full", "buf", "format", "error", "has", "cp", "patch", "core", "root", "alias", "p", "def", "ptr", "key", "binding", "walk", "raw", "empty", "port", "name", "trace", "chain", "method", "pattern", "com", "ctx", "pointer", "Path", "dir", "url", "str", "transform", "data", "ex", "doc", "order", "template", "test", "axis", "file", "pt", "mount", "part", "cmd", "text", "policy", "ath", "w", "stream"], "tmp_uid": [" tmp_eu", "tmp___edu", " tmp_uo", "tmp___user", " tmp_user", "tmp_user", "temp_edu", "tmp_chu", "mp_uid", "tmp_edu", "tmp_eu", "temp_uid", "tmp___chu", "temp_chu", "mp_uu", "mp_UID", "temp_user", "tmp_UID", "tmp_uo", "mp_user", "tmp___uid", "tmp_uu"], "tmp_gid": ["tmp_pgId", "tmp_guids", "tmp_egids", "tmp_gids", "tmp_Gids", "tmp_pgids", "tmp_gupid", "tmp_gno", "tmp_grouppid", "tmp_groupids", "tmp_pgno", "tmp_gId", "tmp_Gpid", "tmp_egid", "tmp_gurid", "tmp_guid", "tmp_gID", "tmp_ggpid", "tmp_ggid", "tmp_Gid", "tmp_cpid", "tmp_grid", "tmp_egno", "tmp_pgid", "tmp_groupId", "tmp_groupID", "tmp_gpid", "tmp_egId", "tmp_cid", "tmp_groupid", "tmp_cID", "tmp_ggID", "tmp_ggids", "tmp_Grid", "tmp_groupno", "tmp_ggrid"], "tmp_mode": ["tmp__command", "tmp_command", "tmpjdevice", "tmpjmode", "mp_de", "tmptmode", "mp_mode", " tmp_env", "tmp__device", "tmpjenv", "tmptmd", " tmp_device", "mp_device", "tmpjde", "mp_command", "tmp__de", " tmp_mean", "tmp10command", "tmp10mode", "tmp_de", "tmp_env", "tmp__mode", " tmp_cmd", "mp__de", "tmp10de", "tmpjcommand", "tmp_device", "tmptdevice", " tmp_md", "tmp10device", "tmpjmean", "tmp_mean", "tmpjcmd", "mp__device", "tmp_md", "tmp_cmd", "mp__command", "tmptdev", "mp__mode"], "tmp_dev": ["tmp2ver", "tmp2dev", "img_ev", " tmp_ver", " tmp_device", "tmptdriver", "tmp2mem", "tmp2device", "temp_dev", "tmptev", "tmp_ev", " tmp_mem", "temp_ev", "tmp_mem", "img_driver", "tmp_device", "tmptver", "temp_device", "tmp_ver", "tmp_Dev", "img_dev", "temp_Dev", "img_ver", "tmp_driver", "tmptdev"]}}
{"project": "qemu", "commit_id": "becf8217deb2afc347d5172d9f30c8a8964b8b27", "target": 0, "func": "void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,\n\n                                     uintptr_t retaddr)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    int t;\n\n\n\n    cs->exception_index = EXCP_PGM;\n\n    env->int_pgm_code = excp;\n\n\n\n    /* Use the (ultimate) callers address to find the insn that trapped.  */\n\n    cpu_restore_state(cs, retaddr);\n\n\n\n    /* Advance past the insn.  */\n\n    t = cpu_ldub_code(env, env->psw.addr);\n\n    env->int_pgm_ilen = t = get_ilen(t);\n\n    env->psw.addr += t;\n\n\n\n    cpu_loop_exit(cs);\n\n}\n", "idx": 12686, "substitutes": {"env": ["esm", "server", "oe", "nv", "cp", "cb", "eng", "org", "et", "cv", "engine", "ef", "esc", "expr", "sc", "vm", "context", "eu", "worker", "end", "sb", "esp", "here", "sv", "er", "enter", " environment", "vp", "ne", "kh", "ah", "vt", "sp", "era", "en", "conn", "enc", "Environment", "cmd", "ve", "nw", "st", "vs", "te", "console", "viron", "ent", "shell", "ev", "ew", "eni", "proc", "ec", "runner", "hw", "environment", "ei", "ner", "desc", "entry", "e", "window", "dev", "db", "network", "ctx", "estate", "ce", "ds", "nc", "config", "equ", "v", "scope", "obj", "pee", "qt"], "excp": ["despc", "ExCP", "desctx", "excmp", "despir", "Excp", "expc", " exCP", "EXp", "usctx", "expir", "pexcp", "EXcmp", "exctx", "descp", " excmp", "EXCP", "pexpc", "uspc", "uspir", "exCP", "uscp", "Excmp", "Exp", "pexpir", "pexctx", "EXcp"], "retaddr": [" retAddress", "Retaddr", "retptr", "Retaddress", "retaddress", " retaddress", "retattr", " retattr", "retsaddr", "retsAddress", "Retptr", "retsptr", "RetAddress", "retsaddress", "Retattr", " retptr", "retAddress", "retsattr"], "cs": ["bs", "fs", " CS", "rs", "CS", "ks", "ck", "cas", "ces", "c", "cp", "ps", "cons", "cn", "core", "cer", "s", "ls", "vs", "TS", " cons", "cc", "js", "rc", "ctx", "gc", "cv", "cus", "cf", "act", "Cs", "kt", "cks", "ys", "css", "acs", "ec", "ds", "nc", "ts", "sc", "ca", "wcs", "qs", "ns", "sts"], "t": ["i", "h", "d", "l", "n", "dt", "tu", " ot", "txt", "x", "temp", "title", " p", "c", "u", "ti", "tree", "p", "tg", "m", "T", "et", "tr", "ptr", "te", "ent", "tc", "b", "ot", "tp", "ert", "vt", "total", "ret", "to", "g", "at", "it", "wt", "str", "ant", "token", "mt", "tt", "tm", " mt", "pt", "ts", " T", "o", "rt", "a", "v", "y", "f", "text", "w", "iat", " ti", "ta"]}}
{"project": "qemu", "commit_id": "a277c3e094d5e9f653ccc861f59e07c94c7fe6c7", "target": 0, "func": "static int usb_host_init(void)\n\n{\n\n    const struct libusb_pollfd **poll;\n\n    int i, rc;\n\n\n\n    if (ctx) {\n\n        return 0;\n\n    }\n\n    rc = libusb_init(&ctx);\n\n    if (rc != 0) {\n\n        return -1;\n\n    }\n\n    libusb_set_debug(ctx, loglevel);\n\n\n\n    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,\n\n                                usb_host_del_fd,\n\n                                ctx);\n\n    poll = libusb_get_pollfds(ctx);\n\n    if (poll) {\n\n        for (i = 0; poll[i] != NULL; i++) {\n\n            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);\n\n        }\n\n    }\n\n    free(poll);\n\n    return 0;\n\n}\n", "idx": 12701, "substitutes": {"poll": ["select", "pool", "np", "cp", "check", "wp", "ptr", "pb", "push", "news", "pause", "hook", "oll", "my", "pod", "scroll", "sleep", "pull", "pt", "ob", "sync", "look", "wait", "d", "cache", "partial", "ck", "txt", "ul", "zip", "host", "tick", "loop", "hp", "roll", "lib", "resp", "cmd", "stat", "query", "delay", "oc", "dl", "pop", "pol", "pc", "maybe", "unc", "x", "claim", "vote", "exec", "loc", "batch", "ready", "update", "fd", "olls", "data", "proc", "lex", "pipe", "bot", "items", "archive", "call", "queue", "search", "json", "ock", "ctl", "col", "p", "Poll", "list", "ux", "buff", "ctx", "ok", "download", " polled", "row", "ll", "body"], "i": ["qi", " li", "iq", "ind", "ai", "ii", "n", "gi", " di", " ni", "z", "di", "x", "cli", "sim", "ij", "ip", "c", " bi", "ti", "li", "hi", "\u0438", "I", "ei", " j", "mc", "s", "si", "batch", "m", "ri", "oi", "asi", "im", "multi", "ami", "my", "fi", "index", "iu", " ii", "it", "j", "me", "ci", "xi", "ic", "ki", "t", "phi", "zi", " c", "ix", "mi", "pi", "v", "y", "bi", "ini", "ui", "uri", " ti"], "rc": ["context", "iq", "oc", "rs", "ra", "rin", "pc", "inc", "bc", "ck", "success", "cas", "dc", "init", "cmp", "cur", "result", "src", "c", "cb", "r", "rx", "ry", "tc", "isc", "cc", "rr", "ctx", "gc", "ack", "ok", "ro", "cont", "rn", "res", "coll", "ci", "arc", "row", "ic", "ctr", "ec", "nc", "cs", "fc", "sc", "rt", "roc", "cr", "rec", "sync", "RC"]}}
{"project": "qemu", "commit_id": "2dfb4c033f2f8fbad252bed1ba3e0fed112cbb7c", "target": 0, "func": "SnapshotInfo *qmp_blockdev_snapshot_delete_internal_sync(const char *device,\n\n                                                         bool has_id,\n\n                                                         const char *id,\n\n                                                         bool has_name,\n\n                                                         const char *name,\n\n                                                         Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockBackend *blk;\n\n    AioContext *aio_context;\n\n    QEMUSnapshotInfo sn;\n\n    Error *local_err = NULL;\n\n    SnapshotInfo *info = NULL;\n\n    int ret;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n\n                  \"Device '%s' not found\", device);\n\n        return NULL;\n\n    }\n\n\n\n    aio_context = blk_get_aio_context(blk);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (!has_id) {\n\n        id = NULL;\n\n    }\n\n\n\n    if (!has_name) {\n\n        name = NULL;\n\n    }\n\n\n\n    if (!id && !name) {\n\n        error_setg(errp, \"Name or id must be provided\");\n\n        goto out_aio_context;\n\n    }\n\n\n\n    if (!blk_is_available(blk)) {\n\n        error_setg(errp, \"Device '%s' has no medium\", device);\n\n        goto out_aio_context;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_INTERNAL_SNAPSHOT_DELETE, errp)) {\n\n        goto out_aio_context;\n\n    }\n\n\n\n    ret = bdrv_snapshot_find_by_id_and_name(bs, id, name, &sn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out_aio_context;\n\n    }\n\n    if (!ret) {\n\n        error_setg(errp,\n\n                   \"Snapshot with id '%s' and name '%s' does not exist on \"\n\n                   \"device '%s'\",\n\n                   STR_OR_NULL(id), STR_OR_NULL(name), device);\n\n        goto out_aio_context;\n\n    }\n\n\n\n    bdrv_snapshot_delete(bs, id, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out_aio_context;\n\n    }\n\n\n\n    aio_context_release(aio_context);\n\n\n\n    info = g_new0(SnapshotInfo, 1);\n\n    info->id = g_strdup(sn.id_str);\n\n    info->name = g_strdup(sn.name);\n\n    info->date_nsec = sn.date_nsec;\n\n    info->date_sec = sn.date_sec;\n\n    info->vm_state_size = sn.vm_state_size;\n\n    info->vm_clock_nsec = sn.vm_clock_nsec % 1000000000;\n\n    info->vm_clock_sec = sn.vm_clock_nsec / 1000000000;\n\n\n\n    return info;\n\n\n\nout_aio_context:\n\n    aio_context_release(aio_context);\n\n    return NULL;\n\n}\n", "idx": 12704, "substitutes": {"device": ["kind", "address", "package", "directory", "image", "DEV", "component", "ident", "server", "node", "connection", "product", "serial", "resource", "document", "family", "android", "DE", "database", "handle", "Device", "controller", "application", "dev", "domain", "network", "buffer", "block", "instance", "remote", "path", "project", "mode", "ide", "spec", "display", "module", "volume", "description", "disk", "pod", "model", "driver", " Device", "hid", "test", "plugin", "development", "link", "scope", "command", "location", "folder"], "has_id": ["has__ids", "Has_type", "has_type", "has_ids", "has__ID", "has_ID", "has___ident", "has___name", "Has_ident", "has___id", "Has_name", "has__id", "has__name", "Has_ids", "has___type", "has_ident", "Has_id", "Has_ID"], "id": ["event", "i", "h", "d", "ord", "type", "end", "address", "bid", "and", "n", "parent", "ids", "time", "created", "ident", "x", "only", "sid", "ip", "pid", "addr", " ID", " tid", "root", "admin", "alias", "ID", "p", "oid", "tag", "create", "uid", "key", "iden", "aid", "vid", "md", "in", "dev", "db", "no", "path", "index", "mid", "ide", "url", "it", "act", "ad", "data", "rid", "try", "iso", "Id", "hid", "test", "debug", "kid", "is", "f", "user", "est"], "has_name": ["have_names", "have_name", "has_error", "Has_description", "Has_name", "have_error", "Has_names", "have_description", "has_description", "has_names", "Has_id"], "name": ["event", "ment", "and", "version", "type", "prefix", "end", "package", "n", "image", "Name", "nam", "time", "word", "error", "title", "local", "NAME", "number", "resource", "new", "alias", "create", "named", "p", "ext", "tag", "nm", "key", "mem", "common", "dev", "names", "none", "no", "len", "instance", "stable", "path", "spec", "note", "size", "description", "data", "normal", "comment", "mod", "filename", "test", "file", "part", "ame", "source", "base", "length", "term", "ns", "label"], "errp": ["dieps", " errP", "errpress", " errps", "diepa", "errpad", "confp", "errP", "derpress", "errorv", "ererpa", " errpress", "derper", "eorpoint", "rrpa", "errpat", "rrps", "confpc", "derpad", "orderpad", "derpoint", "errpoint", "derpat", " errpp", "lerpc", "tracepa", "erP", "errps", "rrpp", "rerP", "ererpoint", "errorP", "derpa", "rrp", "ererpc", "aerpress", "eorpat", " errpat", "errorp", "aerpoint", "ererper", "rerpad", "diepp", "errpp", "ererp", "aerp", "rerpc", "erp", " errpa", " errpc", "rerpa", "orderp", "attrP", "eorp", "lerpa", "aerpad", "lerper", "rerp", "ererpad", "rerpat", "errpa", "attrpress", "attrv", "orderpat", "errorpress", "tracep", "errv", "ererpress", "arrpa", "arrp", "ererpat", " errv", "derp", "erpc", "errpc", "attrp", "lerp", "arrpc", "orderP", "eorpad", "confP", "arrpad", "tracepc", "errper", "diep", "derpc", "tracepad", " errpad"], "bs": ["bos", "fs", "sb", "bl", "bt", "bc", "bes", "hz", "bh", "ps", "bn", "bd", "sys", "outs", "pb", "vs", "ls", "blocks", "gs", "b", "its", "js", "db", "eb", "lbs", "ctx", "bles", "bb", "locks", "bis", "bas", "boxes", "cks", "bps", "bed", "BS", "ds", "ubs", "bp", "cs", "ts", "bits", "base", "bi", "bm", "obs", "ns"], "blk": ["blak", "btk", "Blck", "bleK", "BLak", "slck", "BLke", "BLk", " blak", "clk", "blkg", "blck", "plck", " blj", "brkt", "blj", "bk", " bltk", "bleck", "blke", "clck", " blke", "clkt", "clkg", "bellkt", "brck", "bleke", "bellck", " blkg", "Blak", "brk", "brak", "plk", "bkt", "bellk", "bellkg", "Blk", "blek", " blck", "plj", "bltk", "blkt", "slj", "BLck", "slak", "plak", " blK", "bletk", "blK", "blekt", "bck", "bleak", "BlK", " blkt", "slk"], "aio_context": ["a8opcontext", "aioopContext", "a8_Context", "a8opContext", "a8_condition", "aio_ctx", "aio__Context", "aio_cache", "aio_condition", "aioopcontext", "aioopctx", "aioopcondition", "a8_context", "aIO_ctx", "aio__client", "aio__data", "aIO_cache", "aIO_context", "aIO_connection", "a8opctx", "a8_ctx", "aio_connection", "a8opcondition", "aio_Context", "aio_client", "aio__context", "aio_data"], "sn": [" sd", " sc", "ii", " sys", " si", "Sn", "sb", "tn", " sr", "sl", "n", "sol", " su", "gn", " sh", "sv", " sk", "bn", " sap", "cn", " ss", "st", " shr", "si", " sw", "sam", "syn", "ser", " esc", "nt", "SN", "fn", "sp", "sk", "nr", " sidx", " Sn", "sh", " nu", "nn", "sw", "rn", " ssh", "sr", "fl", "nl", "sc", " np", "sm", "su", " sl", "ns", " scr"], "local_err": ["locallygz", "native_init", " local_mr", "local_try", "local____cmd", "local_init", "local_iter", "localisederr", " local_cmd", " local_errors", "locallyorder", "localityerr", "uniquepytry", "local____er", "uniquepyfee", "unique_fee", "nativepyerr", "localingfee", "localMer", "localingtry", "locallyobj", "global_er", "localpyerr", "global_Er", "localisedcore", "global_order", "localpyobj", "localityerrors", "locallyiter", "local_gz", "native_error", "global_gz", "local_error", "local_core", "local_Er", " local_obj", "local_errors", "localpyerror", "localMEr", "local_fee", "localityinit", " local_init", "localMorder", "unique_try", "locallyerr", "local_cmd", "nativepyiter", "localingerr", "local_order", "localitymr", "localpyiter", "native_iter", "localpyinit", "locallytry", "native_err", "localpyfee", "unique_core", "global_err", "unique_err", "local____mr", "localpytry", "nativepyerror", "local____init", "locallyer", "local_obj", "local____errors", " local_try", "localingcore", "localpyer", "uniquepyerr", "localisedtry", "local_mr", "uniquepycore", "nativepyinit", "localpycore", "local_er", "local____err", " local_er", "localityer", "localMerr", "locallyEr", "global_iter", "localisedfee", "localitycmd"], "info": ["ani", "i", "inf", "ii", "json", "txt", "tx", "ip", "INFO", "new", "ti", "def", "Info", "fo", "si", "dev", "fi", "op", "res", "ci", "data", "ki", "fw", "o", "rt", "pi", "ui", "obj"], "ret": ["uf", "ft", " alt", "RET", "elt", "lt", "nz", "status", "success", "ber", "br", "out", "re", "full", "ern", "cat", "__", "Ret", "result", "selected", " RET", "def", "true", "arr", "err", "ptr", "tr", "Return", "alt", "mem", "nt", "sat", "ert", "cont", "res", "back", "det", "mt", "gt", "t", "ll", "net", "rets", " Ret", "resp", "rt", "val", "lit", "aux", "Alt", "backed", "rem"]}}
{"project": "qemu", "commit_id": "3eff1f46f08a360a4ae9f834ce9fef4c45bf6f0f", "target": 0, "func": "static void virtio_scsi_complete_req(VirtIOSCSIReq *req)\n\n{\n\n    VirtIOSCSI *s = req->dev;\n\n    VirtQueue *vq = req->vq;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);\n\n    if (req->sreq) {\n\n        req->sreq->hba_private = NULL;\n\n        scsi_req_unref(req->sreq);\n\n    }\n\n    virtio_scsi_free_req(req);\n\n    virtio_notify(vdev, vq);\n\n}\n", "idx": 12710, "substitutes": {"req": ["pkg", "requ", "gz", "cmp", "ps", "org", "r", "urg", "nil", "eq", "rr", "dep", "require", "quest", "expr", "grad", "inv", "cr", "needed", "wait", "rem", "that", "alloc", "txt", "pro", "tek", "good", "rss", "request", "ack", "res", "fr", "msg", "coord", "resp", "rw", "cmd", "query", "rel", "ind", "jp", "compl", "tab", "q", "exec", "comm", "ext", "err", "decl", "range", "seq", "dq", "required", "wcs", "pp", "rec", "aux", "call", "ref", "comp", "progress", "tx", "task", "reg", "rx", "desc", "raw", "qq", "md", "ctx", "ctr", "rol", "crit", "gr", "wx", "rest", "qt"], "s": ["i", "fs", "d", "l", "rs", "sg", "sb", "n", "serv", "ses", "S", "os", "sv", "q", "c", "ps", "p", "sys", "es", "si", "ls", "gs", "ats", "b", "js", "sa", "w", "g", "sd", "sq", "t", "ds", "cs", "ts", "is", "a", "v", "ns", "ss"], "vq": ["invreq", "vdq", "vrdq", "cvdq", "svqu", "svdq", "vqs", "cvqu", "svqt", "svql", "vqu", " vqq", "jue", "jqueue", "bq", " vqs", "viq", "vch", "bqt", "bqueue", " vqt", "vrqu", " vqueue", "svqs", "vqt", "biq", "invqq", "bue", "vrq", "vql", "jiq", "sviq", "svue", "vrql", " vreq", "svqueue", "bch", "bqs", "jqq", "invq", "cvq", "vqueue", "svch", "vue", "invqueue", "jq", "jreq", "vreq", "svq", "vqq", " vch", "cvql"], "vdev": ["vDEV", " vdevice", "vhw", "wev", "vrdev", "vrDEV", " vhw", "tpad", "vpad", "tDEV", "vrev", "vod", "vrod", "vrdevice", "vrhw", " vod", " vev", "wod", "vdevice", " vDEV", "wdev", "whw", " vpad", "vrpad", "tdevice", "tdev", "vev"]}}
{"project": "qemu", "commit_id": "978f2205c791de0e02c8802a645bea657408abfd", "target": 0, "func": "bool timer_pending(QEMUTimer *ts)\n\n{\n\n    QEMUTimer *t;\n\n    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {\n\n        if (t == ts) {\n\n            return true;\n\n        }\n\n    }\n\n    return false;\n\n}\n", "idx": 12724, "substitutes": {"ts": ["bs", "h", "fs", "tv", "tl", "tn", "ks", "terms", "als", "tle", "tim", "ps", "Ts", "sys", "s", "tr", "tis", "TS", "te", "hs", "tz", "ms", "gs", "tick", "ats", "tc", "js", "tp", "uts", "ims", "sts", "g", "vals", "j", "aps", "mt", "ds", "tt", "times", "cs", "pt", "stats", "ins", "td", "qs", "ns", "tes", "ss"], "t": ["lat", "tree", "att", "tp", "g", "it", "wt", "pt", "y", "td", "term", "ht", "ta", "d", "dt", "tmp", "txt", "title", "er", "tg", "m", "T", "tf", "tr", "target", "tc", "ot", "w", "to", "at", "kt", "j", "tm", "f", "or", "l", "type", "ty", "x", "off", "c", "st", "ext", "te", "ent", "trace", "of", "nt", "mint", "ant", "ct", "mt", "token", "typ", "rt", "a", "o", "tl", "n", "lt", "z", "task", "out", "new", "p", "b", "test", "tt", "v", "obj", "qt"]}}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static int av_cold libopus_encode_init(AVCodecContext *avctx)\n\n{\n\n    LibopusEncContext *opus = avctx->priv_data;\n\n    const uint8_t *channel_mapping;\n\n    OpusMSEncoder *enc;\n\n    int ret = OPUS_OK;\n\n    int coupled_stream_count, header_size, frame_size;\n\n\n\n    coupled_stream_count = opus_coupled_streams[avctx->channels - 1];\n\n    opus->stream_count   = avctx->channels - coupled_stream_count;\n\n    channel_mapping      = libav_libopus_channel_map[avctx->channels - 1];\n\n\n\n    /* FIXME: Opus can handle up to 255 channels. However, the mapping for\n\n     * anything greater than 8 is undefined. */\n\n    if (avctx->channels > 8)\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Channel layout undefined for %d channels.\\n\", avctx->channels);\n\n\n\n    if (!avctx->bit_rate) {\n\n        /* Sane default copied from opusenc */\n\n        avctx->bit_rate = 64000 * opus->stream_count +\n\n                          32000 * coupled_stream_count;\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"No bit rate set. Defaulting to %d bps.\\n\", avctx->bit_rate);\n\n    }\n\n\n\n    if (avctx->bit_rate < 500 || avctx->bit_rate > 256000 * avctx->channels) {\n\n        av_log(avctx, AV_LOG_ERROR, \"The bit rate %d bps is unsupported. \"\n\n               \"Please choose a value between 500 and %d.\\n\", avctx->bit_rate,\n\n               256000 * avctx->channels);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    frame_size = opus->opts.frame_duration * 48000 / 1000;\n\n    switch (frame_size) {\n\n    case 120:\n\n    case 240:\n\n        if (opus->opts.application != OPUS_APPLICATION_RESTRICTED_LOWDELAY)\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"LPC mode cannot be used with a frame duration of less \"\n\n                   \"than 10ms. Enabling restricted low-delay mode.\\n\"\n\n                   \"Use a longer frame duration if this is not what you want.\\n\");\n\n        /* Frame sizes less than 10 ms can only use MDCT mode, so switching to\n\n         * RESTRICTED_LOWDELAY avoids an unnecessary extra 2.5ms lookahead. */\n\n        opus->opts.application = OPUS_APPLICATION_RESTRICTED_LOWDELAY;\n\n    case 480:\n\n    case 960:\n\n    case 1920:\n\n    case 2880:\n\n        opus->opts.packet_size =\n\n        avctx->frame_size      = frame_size * avctx->sample_rate / 48000;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid frame duration: %g.\\n\"\n\n               \"Frame duration must be exactly one of: 2.5, 5, 10, 20, 40 or 60.\\n\",\n\n               opus->opts.frame_duration);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (avctx->compression_level < 0 || avctx->compression_level > 10) {\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Compression level must be in the range 0 to 10. \"\n\n               \"Defaulting to 10.\\n\");\n\n        opus->opts.complexity = 10;\n\n    } else {\n\n        opus->opts.complexity = avctx->compression_level;\n\n    }\n\n\n\n    if (avctx->cutoff) {\n\n        switch (avctx->cutoff) {\n\n        case  4000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_NARROWBAND;\n\n            break;\n\n        case  6000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_MEDIUMBAND;\n\n            break;\n\n        case  8000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_WIDEBAND;\n\n            break;\n\n        case 12000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_SUPERWIDEBAND;\n\n            break;\n\n        case 20000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_FULLBAND;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"Invalid frequency cutoff: %d. Using default maximum bandwidth.\\n\"\n\n                   \"Cutoff frequency must be exactly one of: 4000, 6000, 8000, 12000 or 20000.\\n\",\n\n                   avctx->cutoff);\n\n            avctx->cutoff = 0;\n\n        }\n\n    }\n\n\n\n    enc = opus_multistream_encoder_create(avctx->sample_rate, avctx->channels,\n\n                                          opus->stream_count,\n\n                                          coupled_stream_count,\n\n                                          channel_mapping,\n\n                                          opus->opts.application, &ret);\n\n    if (ret != OPUS_OK) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Failed to create encoder: %s\\n\", opus_strerror(ret));\n\n        return ff_opus_error_to_averror(ret);\n\n    }\n\n\n\n    ret = libopus_configure_encoder(avctx, enc, &opus->opts);\n\n    if (ret != OPUS_OK) {\n\n        ret = ff_opus_error_to_averror(ret);\n\n        goto fail;\n\n    }\n\n\n\n    header_size = 19 + (avctx->channels > 2 ? 2 + avctx->channels : 0);\n\n    avctx->extradata = av_malloc(header_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!avctx->extradata) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to allocate extradata.\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    avctx->extradata_size = header_size;\n\n\n\n    opus->samples = av_mallocz(frame_size * avctx->channels *\n\n                               av_get_bytes_per_sample(avctx->sample_fmt));\n\n    if (!opus->samples) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to allocate samples buffer.\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    ret = opus_multistream_encoder_ctl(enc, OPUS_GET_LOOKAHEAD(&avctx->delay));\n\n    if (ret != OPUS_OK)\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Unable to get number of lookahead samples: %s\\n\",\n\n               opus_strerror(ret));\n\n\n\n    libopus_write_header(avctx, opus->stream_count, coupled_stream_count,\n\n                         opus_vorbis_channel_map[avctx->channels - 1]);\n\n\n\n    ff_af_queue_init(avctx, &opus->afq);\n\n\n\n    opus->enc = enc;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    opus_multistream_encoder_destroy(enc);\n\n    av_freep(&avctx->extradata);\n\n    return ret;\n\n}\n", "idx": 12730, "substitutes": {"avctx": [" avjac", "avercontext", "ajcu", "avercb", "avercp", " avcmp", "abcontext", "abcp", "avtx", "avecfg", "verkl", "ajcf", "ajpkg", "avcfg", " avcontext", "avcf", "afcb", "averheight", "avct", "ajtx", " avdyl", "verctl", " avcf", "avtmp", " avcv", "avert", "vantx", "ajctx", "vanctx", "avepkg", "vertx", "savtx", "abpkg", "avertmp", "afcontext", "avparams", "ovctx", "avecu", "averkl", "abcmd", "avedl", "avcmd", "afcv", "avernp", "averctl", "averpop", "ajrt", "avpkg", "averctx", "averct", "aftx", "avejac", "averkt", "verpkg", "avectx", "afctx", "avekl", "avsys", "ravdl", "ovtxt", "abtx", "avjac", "ravctx", "avedyl", "avcu", "avkt", "afcu", "verctx", "vanpop", "avrt", "afrt", "savdyl", " avct", "avenp", "aveparams", "avcontext", "avercmd", "afcf", "avercfg", "savctx", "ovdyl", "ajkt", "avecontext", "savparams", "abctx", "ravcontext", "avecv", "afdyl", "savheight", "ovcmd", "avdyl", " avdl", "ajcmp", "afpop", "ajcfg", "ajcmd", " avkl", "averpkg", "avnp", "ajcontext", "avcmp", " avcmd", "avetmp", "afconn", "ajtxt", "savconn", "vertmp", "avercf", "avdl", "avekt", "avcp", "savcfg", "aveheight", "avtxt", "afsys", "avercmp", "avertxt", " avcfg", "avkl", "afpkg", "averparams", "vercfg", "ajcp", "avetx", "avctl", "ravjac", " avtx", "ajct", "avecmd", "avertx", "avectl", "vancb", " avnp", "avecmp", "avcv", "avconn", "avheight", "aveconn", "afcfg", "averdyl", "ajdyl", "avect", "avpop", "ajsys", "aversys", "avecf", "avcb", " avkt"], "opus": ["ivo", "music", "voc", "av", "jack", "avin", "liv", "conv", "amps", "apache", "np", "cop", "oos", "biology", "photos", "capt", "username", "itch", "ophon", "vo", "profile", "audio", "voice", "oxy", "phones", "join", "photo", "ops", "addin", "avi", "root", "vp", "upload", "paste", "orp", "aval", "soc", "ave", "mit", "apa", "apo", "au", "Flickr", "fps", "operative", "offic", "avan", "wikipedia", "pop", "aic", "oscope", "oga", "picture", "aud", "ipper", "pheus", "uploads", "verb", "volume", "phot", "op", "album", "amp", "iop", "umi", "pp", "opl", "archive", "osa", "userc", "opa", "ip", "aus", "ahi", "ost", "us", "oper", "tumblr", "ctx", "bis", "ocr", "bank", "oster", "oops", "ais", "uo", "wordpress", "alph"], "channel_mapping": ["channel_mapper", "channel_bmapter", "channel_smapping", "channel_smapper", "channel_bmapping", "channel_mapappings", "channel_mapter", "channel_bmapper", "channel_Mapter", "channel_Mapping", "channel_Mappings", "channel_mapapper", "channel_mapapping", "channel_mappings", "channel_Mapper", "channel_smapter"], "enc": ["vc", "ch", "con", "oder", "txt", "conv", "cmp", "ENC", "eng", "vec", "ent", "ack", "op", "Enc", "ev", "cod", "act", "res", "auth", "conn", "proc", "ic", "ec", "fc", "ac", "rec", "obj"], "coupled_stream_count": ["coupled_length_size", "coupled_stream2length", "coupled_stream_length", "coupled_length_count", "coupled_stream2counter", "coupled_channel_Count", "coupled_stream_size", "coupled_channel_data", "coupled_channel_counter", "coupled_stream_counter", "coupled_channel_length", "coupled_length_length", "coupled_stream_data", "coupled_channel_count", "coupled_stream_Count", "coupled_channel_size", "coupled_stream2count"], "header_size": ["line_count", "header_count", "line_size", "line_shape", "header_SIZE", "line_SIZE", "header_shape"], "frame_size": ["draw_rate", "frameetyresolution", " frame_offset", "frameetyno", " frame_count", "frame_count", "frame_no", "frame\u05bcsize", "face_Size", "header_rate", "frame67size", "frame_resolution", "frame_length", "framelyunit", "draw_owner", "facelyunit", "facelySize", "frameetyindex", "frameetycolor", "header\u05bcresolution", "drawlysize", "framelystatus", "drawlyowner", "frame_owner", "framelyindex", "face_size", "facelystatus", "frame\u05bcrate", " frame_no", "frame_index", "frame\u05bccolor", "header_resolution", "frame_Size", " frame_index", "framelyowner", "frame67Size", "frame_rate", "framelyno", "face_unit", "header\u05bcrate", "facelysize", "framelysize", "face_status", "framelylength", "frame_color", "frame_status", "draw_length", "frame_offset", "framelyrate", "frame67unit", "header\u05bccolor", "framelySize", "drawlyrate", "frameetysize", "frameetyrate", "frame67status", "drawlylength", "header\u05bcsize", "frame_unit", "draw_size", " frame_length", "frame\u05bcresolution", "header_color"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_rt_frame(int sig, struct emulated_sigaction *ka, \n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUX86State *env)\n\n{\n\n\tstruct rt_sigframe *frame;\n\n\tint err = 0;\n\n\n\n\tframe = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\n\t\tgoto give_sigsegv;\n\n#endif\n\n\n\n\terr |= __put_user((/*current->exec_domain\n\n\t\t    \t   && current->exec_domain->signal_invmap\n\n\t\t    \t   && sig < 32\n\n\t\t    \t   ? current->exec_domain->signal_invmap[sig]\n\n\t\t\t   : */sig),\n\n\t\t\t  &frame->sig);\n\n\terr |= __put_user((target_ulong)&frame->info, &frame->pinfo);\n\n\terr |= __put_user((target_ulong)&frame->uc, &frame->puc);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Create the ucontext.  */\n\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\n\terr |= __put_user(0, &frame->uc.uc_link);\n\n\terr |= __put_user(/*current->sas_ss_sp*/ 0, &frame->uc.uc_stack.ss_sp);\n\n\terr |= __put_user(/* sas_ss_flags(regs->esp) */ 0,\n\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\n\terr |= __put_user(/* current->sas_ss_size */ 0, &frame->uc.uc_stack.ss_size);\n\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,\n\n\t\t\t        env, set->sig[0]);\n\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb8, (char *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_rt_sigreturn, (int *)(frame->retcode+1));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+5));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n", "idx": 12741, "substitutes": {"sig": ["Sigma", "sigen", "jsIG", "sign", "stsig", "lsigs", "lsigen", "stsigs", "isigma", "testsig", "testsIG", "isig", "psig", " sIG", "sigma", "dsigen", "sigs", "Sigen", "dsig", "jsig", "sigm", "testsigma", " sigs", "psich", " sign", "stsich", "dsign", " sigen", "jsigen", "sich", "lsign", "isIG", "testsiger", "stsign", "sIG", "lsig", "Sig", "psigs", "isiger", "dsigs", " sigm", "SIG", "psign", "Siger", " sich", "siger", "jsigm", "Sigs", "Sign"], "ka": ["kw", "eta", "ama", "ku", "ko", "k", "ck", "ha", "ski", "tk", "Ka", "uma", "pa", "ker", "ema", "ken", "hw", "arma", "kl", "ma", "qa", "kas", "ja", "tp", "ami", "sa", "ica", "sk", "ena", "kt", "KA", "kj", "ke", "km", "ki", "ak", "apa", "sama", "ket", "kat", "aka", "kan", "kr", "gha", "ta"], "info": ["details", "i", "inf", "type", "ii", "dict", "priv", "status", "summary", "txt", "history", "local", "out", "error", "tab", "jo", "init", "isu", "about", "INFO", "ist", "ti", "information", "conf", "hi", "ext", "loc", "def", "si", "fo", "Info", "recent", "name", "news", "mem", "obi", "nt", "rc", "sa", "fi", "ctx", "id", "ro", "it", " fi", "auth", "ci", "data", "conn", "meta", " inf", "os", "ki", "iso", "prof", "is", "stat", "metadata", "text", "f", "ui", "user", " INFO", "doc", "io", "ta"], "set": ["ch", "Set", "end", "ut", "send", "map", "setup", "init", "state", "session", "sche", " Set", "st", "pen", "tree", "ext", "check", "loc", "store", "si", "from", "add", "setting", "et", "update", "push", "site", "eq", "window", "block", "sa", "ctx", "sp", "spec", "sett", "to", "it", "sh", "use", "reset", "msg", "data", "en", "step", "ex", "open", "pack", "t", "test", "se", "get", "sc", "section", "up", "call", "SET"], "env": ["context", "eu", "usr", "esm", "end", "ote", "ut", "server", "here", "buf", "setup", "init", "nv", "addr", "state", "hw", "eng", "cb", "er", "environment", "loc", "org", "ape", "ptr", "vs", "et", "te", "viron", "eq", "code", "e", "dev", "window", "mem", "vt", "ctx", "cv", "va", "ev", "ew", "ten", "en", "stage", "enc", "ec", "ef", "esc", "net", "sc", "v", "gov", "obj", "doc"], "frame": ["cause", "send", "image", "header", "error", "sequence", "face", "message", "close", "scene", "fb", "method", "rule", "feature", "function", "base", "term", "profile", "event", "join", "component", "style", "Frame", "word", "connection", "draw", "next", "init", "force", "def", "flow", "tick", "factor", "code", "request", "cf", "line", "fr", "zone", "t", "po", "file", "link", "cmd", "f", "command", "doc", "role", "channel", "type", "version", "condition", "page", "node", "session", "err", "ma", "rame", "trace", "response", "block", "fi", "shot", "frames", "data", "lock", "stage", "step", "process", "call", "ref", "dict", "point", "out", "local", "state", "list", "ence", "e", "window", "iter", "remote", "ce", "module", "feat", "me", "row", "ke", "scope", "user", "reset", "ze"]}}
{"project": "qemu", "commit_id": "f2001a7e0555b66d6db25a3ff1801540814045bb", "target": 0, "func": "static void tcp_chr_telnet_init(QIOChannel *ioc)\n\n{\n\n    char buf[3];\n\n    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */\n\n    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n}\n", "idx": 12777, "substitutes": {"ioc": ["iot", "fiocent", "iocl", "iocy", "iocent", "uoc", "uiocy", "ciocon", "iioc", "uiocent", "iios", " ioco", "lios", " iot", "uiocl", "fiocy", "kioci", " iocy", "piocy", "iiocal", "cioc", "liocl", "uioci", "Iocon", "cioca", "uocy", " ioca", "cioci", "kiog", "lioci", "pioci", " iog", "kioc", "pioc", "Iot", "liocent", "uios", "ciot", "kioca", "lioc", "liocal", "iog", "ioci", "iocal", "fioc", "ciog", " ioci", "liocy", "fioci", "uioc", "ioca", "Ioc", "iiocl", "uoco", "iocon", "Ioco", "pioco", "ioco", " iocon", "uoci", "cioco", "uiocal"], "buf": ["pkg", "map", "xff", "history", "conv", "ait", "pool", "cat", "cb", "eng", "bh", "urg", "ptr", "pb", "fb", "cv", "ann", "Buffer", "text", " vec", "uf", "usr", "kw", "package", "tmp", "br", "temp", " buff", "Buff", "vec", "img", " buffer", "vp", "tr", "good", "rc", "buffer", "cap", "msg", "coord", "cmd", "burst", "bu", "fac", "off", "etc", "comm", "batch", "bag", "block", "agg", "data", "seq", "BU", "proc", "fw", "var", "queue", "cur", "nm", "desc", "raw", "buff", "b", "window", "box", "db", "iter", "font", "ctx", "um", "str", "row", "ctr", "func", "aka", "v", "pend", "w"]}}
{"project": "qemu", "commit_id": "1606e4cf8a976513ecac70ad6642a7ec45744cf5", "target": 1, "func": "static void blk_delete(BlockBackend *blk)\n\n{\n\n    assert(!blk->refcnt);\n\n    assert(!blk->name);\n\n    assert(!blk->dev);\n\n\n\n\n    if (blk->root) {\n\n        blk_remove_bs(blk);\n\n\n    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));\n\n    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));\n\n    QTAILQ_REMOVE(&block_backends, blk, link);\n\n    drive_info_del(blk->legacy_dinfo);\n\n    block_acct_cleanup(&blk->stats);\n\n    g_free(blk);\n", "idx": 12780, "substitutes": {"blk": ["Blb", "plck", "milunk", "blew", "glm", " blm", " blz", "brounk", "Blak", "blockak", "boke", " blb", "grk", "blz", "blkt", "blunk", "brk", " blkt", "blockk", "blockck", "pld", " blak", "relck", "broak", "blck", "glck", "bleck", "plb", "brock", "grak", " blkg", " bld", "replck", "grkt", "Blk", "replunk", "blekt", "lnak", "bleb", "blak", "Blkt", "BLak", "BLk", "bld", "bow", "clb", "plkt", "lnk", "brkt", "blockm", "glak", "clck", " blunk", "brokt", "grunk", "bok", "blb", "blek", "milk", "relak", "brokg", "BLck", "blw", "BLkt", "lnw", "boak", "blm", "lnke", "Blck", "blkg", "clk", "clak", "relkt", "blke", "replak", "bleke", "brck", "brak", "plk", "blez", " blck", "replk", "brok", "brz", "milck", "milkg", "plak", "glk", "bleak", "brod", "relk"]}}
{"project": "qemu", "commit_id": "bb16172c52ac18742f3df156912c169904e92147", "target": 1, "func": "static int gdbserver_open(int port)\n\n{\n\n    struct sockaddr_in sockaddr;\n\n    int fd, val, ret;\n\n\n\n    fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n#ifndef _WIN32\n\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n\n\n    /* allow fast reuse */\n\n    val = 1;\n\n    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));\n\n\n\n    sockaddr.sin_family = AF_INET;\n\n    sockaddr.sin_port = htons(port);\n\n    sockaddr.sin_addr.s_addr = 0;\n\n    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n\n        return -1;\n\n    }\n\n    ret = listen(fd, 0);\n\n    if (ret < 0) {\n\n        perror(\"listen\");\n\n\n        return -1;\n\n    }\n\n    return fd;\n\n}", "idx": 12785, "substitutes": {"port": ["type", "version", "direction", "address", "page", "server", "padding", "format", "priority", "number", "Port", "PORT", "pid", "ort", "message", "interface", "position", "family", "p", "socket", "host", "ptr", "et", "timeout", "eport", "ports", "count", "path", "index", "pport", "size", "localhost", "limit", "ORT", "test", "file", "pt", "print", "v", "pi", "length"], "sockaddr": ["socksadr", "sckadd", "Sockaddress", "sysopt", "sysaddr", "sigptr", "socksoa", "jsysorder", "songmap", "Sckaddress", " sckadd", " sckptr", "songattr", "sockadd", "sckaddress", "sipopt", " songopt", "sockoa", "sipaddress", " sipattr", " sipaddr", "sysattr", "sipptr", "socopt", "sackattr", " sockadd", "sockdir", "socksaddr", "songopt", "sessadd", " sckadr", "jsysattr", "sckattr", "socksadd", "sackopt", "sOCKdir", "sessattr", "sckptr", "sinkdir", " sckoa", "Sockadd", " sockmap", "sckaddr", "sackorder", "sinkopt", "jsockopt", " sckattr", " sockattr", "sockopt", "sockaddress", "songaddr", "Sckadd", "sinkadd", "sockorder", "sinkaddr", " songaddr", "sOCKadd", "socattr", " sockopt", "jsockorder", "sipadd", "socksattr", " sockdir", "Sockptr", " sockptr", " sinkdir", "sackmap", "sckadr", "sockattr", "jsockattr", "sackaddr", "sigaddress", "sOCKoa", " songmap", "jsysaddr", "sysorder", "socksptr", "jsysopt", " sinkaddr", "sipaddr", " sockadr", "sysadd", "sOCKadr", " sipadd", "socmap", " sipopt", "sessopt", " sockoa", "sipattr", " sckaddr", "sysptr", " songattr", "sckoa", "sockmap", " sinkadd", "sigadd", "sinkattr", "sigaddr", "sOCKaddr", "sessaddr", "jsockaddr", "sckdir", "sockadr", "Sckptr", "socaddr", "Sckaddr", "Sockaddr", "sinkorder", "sockptr"], "fd": ["uf", "i", "ff", "dl", "d", "ind", "fp", "fs", "hd", "fm", "elt", "dt", " fid", "bf", "unc", "FD", "draw", "ctl", "pid", "bd", "df", "ptr", "da", "handle", "flag", " df", "fb", "pd", "ln", "db", "window", "in", "ffff", "fi", "fn", "ctx", "dd", "dir", "id", "cf", "sd", "fr", "disk", "ud", " ff", "fl", "func", "ds", "fin", "fed", "file", "fc", "ld", "f", "td", "dat", "stream"], "val": ["cal", "vc", "ind", "sil", "Val", "ref", "eval", "sol", "elt", "serv", "pol", "sl", "txt", "tx", "x", "value", "reg", "col", "sel", "p", "VAL", "def", "key", "valid", "mem", "sec", "len", "vt", "al", "ctx", "index", "fi", "bal", "it", "vals", "res", "cho", "el", "fl", "test", "il", "fee", "vol", "rol", "pt", "v", "f", "var"], "ret": ["ft", "ref", "RET", "opt", "dt", "elt", "bf", "ben", "alf", "re", "reply", "prot", "Ret", "result", "cb", "ext", "del", "def", "not", "arr", "err", "tr", "desc", "leg", "flag", "mem", "alt", "att", "nt", "cert", "final", "vt", "fi", "len", "fun", "it", "res", "rect", "back", "cont", "after", "url", "rm", "bool", "inter", "det", "mt", "gt", "try", "func", "nl", "mail", "fin", "rets", "get", "nat", "resp", "rt", "deg", "cmd", "print", "reset", "backed", "rem"]}}
{"project": "qemu", "commit_id": "280503ee9d7833a793770d732dda5358659825e9", "target": 1, "func": "static void spapr_nvram_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);\n\n\n\n    k->realize = spapr_nvram_realize;\n\n    k->devnode = spapr_nvram_devnode;\n\n    k->dt_name = \"nvram\";\n\n    k->dt_type = \"nvram\";\n\n    k->dt_compatible = \"qemu,spapr-nvram\";\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->props = spapr_nvram_properties;\n\n    dc->vmsd = &vmstate_spapr_nvram;\n\n\n\n}", "idx": 12786, "substitutes": {"klass": ["Klasses", " kasso", "tklasses", " kls", "tkls", "Kls", " klasses", "Kasso", "ikklass", "ikkcl", "tklass", "kls", "klf", "kcl", "kasso", "Klf", "ikkls", "tklf", "klasses", "Klass", "tkasso", "Kcl", " kcl", "ikklasses", " klf"], "data": [" sd", "device", "kind", "d", "cache", " DATA", "Data", "di", "DATA", "json", " d", "value", " Data", "result", "ata", "def", "bus", "key", "name", "dev", "rc", "module", "res", "bin", "w", "dat", "mu"], "dc": ["oc", "d", "kw", "dm", "iac", "dt", "pc", "nz", "bc", "dp", "DC", "di", "lc", "cca", "cm", "c", "cp", "dh", "core", "cu", "mc", "dk", "disc", " DC", "md", "tc", "db", "cc", "rc", "gc", "ec", "nc", "fc", "ca", "ac", "cr", "cd", "td", "ga"], "k": ["pkg", "kind", "kw", "kn", "ku", "ko", "ks", "ck", "tk", "wk", "ikk", "c", "p", "kl", "dk", "key", "kk", "mk", "kar", "kh", "kick", "sk", "ijk", "ack", "ok", "uk", "g", "kt", "j", "it", "max", "ka", "kj", "km", "ki", "ik", "ek", "ak", "work", "K", "kr", "kan", "ac", "unk"]}}
{"project": "qemu", "commit_id": "aedbe19297907143f17b733a7ff0e0534377bed1", "target": 1, "func": "static void cpu_handle_ioreq(void *opaque)\n\n{\n\n    XenIOState *state = opaque;\n\n    ioreq_t *req = cpu_get_ioreq(state);\n\n\n\n    handle_buffered_iopage(state);\n\n    if (req) {\n\n        ioreq_t copy = *req;\n\n\n\n        xen_rmb();\n\n        handle_ioreq(state, &copy);\n\n        req->data = copy.data;\n\n\n\n        if (req->state != STATE_IOREQ_INPROCESS) {\n\n            fprintf(stderr, \"Badness in I/O request ... not in service?!: \"\n\n                    \"%x, ptr: %x, port: %\"PRIx64\", \"\n\n                    \"data: %\"PRIx64\", count: %u, size: %u, type: %u\\n\",\n\n                    req->state, req->data_is_ptr, req->addr,\n\n                    req->data, req->count, req->size, req->type);\n\n            destroy_hvm_domain(false);\n\n            return;\n\n        }\n\n\n\n        xen_wmb(); /* Update ioreq contents /then/ update state. */\n\n\n\n        /*\n\n         * We do this before we send the response so that the tools\n\n         * have the opportunity to pick up on the reset before the\n\n         * guest resumes and does a hlt with interrupts disabled which\n\n         * causes Xen to powerdown the domain.\n\n         */\n\n        if (runstate_is_running()) {\n\n            if (qemu_shutdown_requested_get()) {\n\n                destroy_hvm_domain(false);\n\n            }\n\n            if (qemu_reset_requested_get()) {\n\n                qemu_system_reset(VMRESET_REPORT);\n\n                destroy_hvm_domain(true);\n\n            }\n\n        }\n\n\n\n        req->state = STATE_IORESP_READY;\n\n        xenevtchn_notify(state->xce_handle,\n\n                         state->ioreq_local_port[state->send_vcpu]);\n\n    }\n\n}\n", "idx": 12787, "substitutes": {"opaque": [" opaco", "posit", " opatile", "OPaque", "Oplation", "Opaco", "oposter", "Opatile", "poster", "OPaco", "pque", " oplation", "oplation", "opque", "OPatile", "OPosit", "OPlation", "OPoster", "paque", "opatile", "opaco", "OPque", "Opque", "Oposit", "Opaque", "oposit", "Oposter"], "state": ["view", "cor", "status", "history", "sequence", "pool", "addr", "resource", "core", "close", "pos", "mem", "rule", "instance", "offset", "release", "debug", "base", "powered", "context", "info", "cache", "color", "power", "bar", "component", "style", "connection", "ion", "hash", "init", "root", "tag", "store", "start", "name", "code", "ot", "buffer", "loop", "size", "res", "msg", "conn", "try", "t", "State", "states", "stat", "print", "length", "type", "version", "value", "session", "st", "change", "STATE", "controller", "in", "trace", "count", "com", "al", "index", "mode", "range", "data", "class", "roy", "head", "master", "area", "address", "runner", "level", "progress", "tx", "local", "out", "list", "action", "handle", "port", "now", "estate", "ctx", "spec", "id", "lease", "see", "we", "test", "config", "scope", "stats", "post"], "req": ["pkg", "low", "requ", "need", "reply", "clip", "patch", "org", "r", "urg", "ptr", "push", "mem", "parse", "rr", "tar", "require", "quest", "expr", "inv", "needed", "info", "rep", "esp", "subject", "txt", "alloc", "next", "init", "good", "repl", "rss", "request", "res", "msg", "fr", "conn", "copy", "resp", "cmd", "query", "ind", "jp", "q", "exec", "ext", "err", "sq", "range", "data", "seq", "dq", "proc", "required", "prev", "rt", "rec", "var", "aux", "call", "dist", "ref", "comp", "progress", "tx", "task", "desc", "qq", "ctx", "fresh", "grab", "ctr", "attr", "quick", "crit", "config", "wx", "obj", "qt"]}}
{"project": "qemu", "commit_id": "846424350b292f16b732b573273a5c1f195cd7a3", "target": 1, "func": "static bool scsi_target_emulate_inquiry(SCSITargetReq *r)\n\n{\n\n    assert(r->req.dev->lun != r->req.lun);\n\n    if (r->req.cmd.buf[1] & 0x2) {\n\n        /* Command support data - optional, not implemented */\n\n        return false;\n\n    }\n\n\n\n    if (r->req.cmd.buf[1] & 0x1) {\n\n        /* Vital product data */\n\n        uint8_t page_code = r->req.cmd.buf[2];\n\n        r->buf[r->len++] = page_code ; /* this page */\n\n        r->buf[r->len++] = 0x00;\n\n\n\n        switch (page_code) {\n\n        case 0x00: /* Supported page codes, mandatory */\n\n        {\n\n            int pages;\n\n            pages = r->len++;\n\n            r->buf[r->len++] = 0x00; /* list of supported pages (this page) */\n\n            r->buf[pages] = r->len - pages - 1; /* number of pages */\n\n            break;\n\n        }\n\n        default:\n\n            return false;\n\n        }\n\n        /* done with EVPD */\n\n        assert(r->len < sizeof(r->buf));\n\n        r->len = MIN(r->req.cmd.xfer, r->len);\n\n        return true;\n\n    }\n\n\n\n    /* Standard INQUIRY data */\n\n    if (r->req.cmd.buf[2] != 0) {\n\n        return false;\n\n    }\n\n\n\n    /* PAGE CODE == 0 */\n\n    r->len = MIN(r->req.cmd.xfer, 36);\n\n    memset(r->buf, 0, r->len);\n\n    if (r->req.lun != 0) {\n\n        r->buf[0] = TYPE_NO_LUN;\n\n    } else {\n\n        r->buf[0] = TYPE_NOT_PRESENT | TYPE_INACTIVE;\n\n        r->buf[2] = 5; /* Version */\n\n        r->buf[3] = 2 | 0x10; /* HiSup, response data format */\n\n        r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */\n\n        r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */\n\n        memcpy(&r->buf[8], \"QEMU    \", 8);\n\n        memcpy(&r->buf[16], \"QEMU TARGET     \", 16);\n\n        pstrcpy((char *) &r->buf[32], 4, qemu_get_version());\n\n    }\n\n    return true;\n\n}\n", "idx": 12789, "substitutes": {"r": ["art", "error", "re", "resource", "this", "R", "ren", "ry", "rd", "rr", "rect", "url", "it", "g", "rar", "pr", "all", "y", "cr", "rem", "h", "usr", "d", "render", "br", "er", "m", "hr", "tr", "rc", "rh", "request", "ro", "res", "j", "after", "fr", "sr", "vr", "rw", "kr", "or", "rel", "l", "rs", "req", "ur", "rb", "rf", "q", "adr", "err", "ir", "response", "rn", "item", "rm", "mr", "rt", "rec", "var", "rate", "ref", "reader", "runner", "z", "result", "ar", "p", "rx", "dr", "e", "rev", "nr", "rg", "rl", "rer", "attr", "self", "gr", "rest", "obj", "lr", "w", "reset"], "pages": ["books", "codes", " instances", "bytes", "page", "points", "keys", "devices", "files", "next", "ips", "units", " p", "planes", "heads", "ps", "inks", "p", "links", "start", "posts", "users", " Pages", "blocks", "pos", "modules", "pg", "count", "names", " page", "pdf", "total", "tags", "pointers", "rows", "values", "pins", "hops", "num", "data", "cats", "steps", "resources", "ages", "days", "apps", "prev", "images", "times", "packages", "items", "pp", "types", "ins", "Pages", "lines", "params"]}}
{"project": "qemu", "commit_id": "de82815db1c89da058b7fb941dab137d6d9ab738", "target": 1, "func": "int qcow2_expand_zero_clusters(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table = NULL;\n\n    uint64_t nb_clusters;\n\n    uint8_t *expanded_clusters;\n\n    int ret;\n\n    int i, j;\n\n\n\n    nb_clusters = size_to_clusters(s, bs->file->total_sectors *\n\n                                   BDRV_SECTOR_SIZE);\n\n    expanded_clusters = g_malloc0((nb_clusters + 7) / 8);\n\n\n\n    ret = expand_zero_clusters_in_l1(bs, s->l1_table, s->l1_size,\n\n                                     &expanded_clusters, &nb_clusters);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Inactive L1 tables may point to active L2 tables - therefore it is\n\n     * necessary to flush the L2 table cache before trying to access the L2\n\n     * tables pointed to by inactive L1 entries (else we might try to expand\n\n     * zero clusters that have already been expanded); furthermore, it is also\n\n     * necessary to empty the L2 table cache, since it may contain tables which\n\n     * are now going to be modified directly on disk, bypassing the cache.\n\n     * qcow2_cache_empty() does both for us. */\n\n    ret = qcow2_cache_empty(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        int l1_sectors = (s->snapshots[i].l1_size * sizeof(uint64_t) +\n\n                BDRV_SECTOR_SIZE - 1) / BDRV_SECTOR_SIZE;\n\n\n\n        l1_table = g_realloc(l1_table, l1_sectors * BDRV_SECTOR_SIZE);\n\n\n\n        ret = bdrv_read(bs->file, s->snapshots[i].l1_table_offset /\n\n                BDRV_SECTOR_SIZE, (void *)l1_table, l1_sectors);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        for (j = 0; j < s->snapshots[i].l1_size; j++) {\n\n            be64_to_cpus(&l1_table[j]);\n\n        }\n\n\n\n        ret = expand_zero_clusters_in_l1(bs, l1_table, s->snapshots[i].l1_size,\n\n                                         &expanded_clusters, &nb_clusters);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\n\n\nfail:\n\n    g_free(expanded_clusters);\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n", "idx": 12799, "substitutes": {"bs": ["bos", "fps", "fs", "rs", "ashes", "sb", "bl", "aos", "bc", "ses", "stones", "blog", "os", "bes", "aus", "ubis", "hz", "lb", "bh", "sys", "outs", "pb", "vs", "ls", "hs", "aws", "blocks", "gs", "b", "its", "js", "lbs", "locks", "bles", "sts", "bis", "boxes", "cks", "acs", "bps", "BS", "ds", "ubs", "bp", "cs", "ts", "bits", "oss", "bm", "obs", "ns", "ss"], "s": ["h", "fs", "abilities", "rs", "sn", "changes", "sb", "sl", "settings", "ops", "ses", "ies", "S", "os", "space", "als", "bes", "sv", "c", "ps", "ss", "comm", "p", "sys", "es", "ssl", "args", "ls", "vs", "irs", "hs", "ms", "aws", "gs", "b", "ats", "its", "js", "as", "locks", "ims", "spec", "bis", "sq", "sw", "less", "steps", "ds", "states", "cs", "ts", "is", "a", "bits", "plays", "stats", "ins", "qs", "parts", "ns", "sts"], "l1_table": ["l14PTable", "l41_table", "l1tentity", "l1_entity", "l1__table", "l1zbuffer", "l2_table", "l1_cache", "l1_tab", "l1zable", "l1__tree", "l2_tab", "l1pytable", "l1_tree", "l1_buffer", "l1_entry", "l14_table", "l14Ptable", "l2_TABLE", "l1_TABLE", "l41_bl", "l1PTable", "l1zcontainer", "l1ztable", "l1actable", "l4_t", "l4_table", "l1__tab", "l14_array", "l2_Table", "l14_Table", "l2_cache", "l1tbuffer", "l4tbuffer", "l1_array", "l15_container", "l1tt", "l2_entity", "l1scache", "l1Pquery", "l1__cache", "l1stab", "l2_buffer", "l4tt", "l15_buffer", "l1_bl", "l1pyentity", "l1acquery", "l15_able", "l1_header", "l1_query", "l1stree", "l1_t", "l1pytab", "l4ttab", "l4ttable", "l1Ptable", "l1_able", "l2_header", "l41_buffer", "l1pybuffer", "l14Parray", "l4_tab", "l4_buffer", "l15_table", "l1ttable", "l14_query", "l1ttab", "l1acarray", "l14Pquery", "l1_container", "l1Parray", "l1stable", "l41_entry", "l2_tree", "l1acTable", "l1_Table"], "nb_clusters": ["nb_descuster", "nb10occuations", "nb2chusters", "nb_clocations", "nb_decluster", "nb2chients", "nb_glanks", "nb_clients", "nb_lusters", "nb_clusues", "nb_lanks", "nb_chores", "nblcluster", "nb_clusows", "nb_declocations", "nb_Clients", "nbldescows", "nb_Clusters", "nb_luster", "nb_lroups", "nb_clords", "nb_critusters", "nb10clusters", "nb_regurs", "nb2clients", "nb_cluations", "nb_cousters", "nb10cluations", "nb_occuations", "nb10occusters", "nb10occords", "nb_descusters", "nb_blients", "nb_glues", "nb_clows", "nb_pluster", "nb_critocations", "nb10occurs", "nb2chores", "nb_blanks", "nb_clues", "nb_lores", "nb_critanks", "nb2clanks", "nb2clores", "nb_clurs", "nb_Clroups", "nb_glows", "nb_regords", "nb_couations", "nb_glusters", "nb_glocations", "nbldescues", "nb_plients", "nb_occords", "nb_chients", "nb_Cluster", "nb_declusters", "nblclows", "nb_chanks", "nb_crituster", "nb_blusters", "nb_clores", "nbldescuster", "nb_descues", "nb2clusters", "nb2chanks", "nblclusters", "nb10clurs", "nb_cours", "nb_cluster", "nb_clroups", "nb_regusters", "nb_plusters", "nbldescusters", "nb_descows", "nb_clususters", "nb_lients", "nb_chusters", "nb_reguations", "nblclues", "nb_clanks", "nb_plroups", "nb_blores", "nb_clususter", "nb_occusters", "nb10clords", "nb_declanks", "nb_coords", "nb_occurs", "nb_gluster"], "expanded_clusters": ["expanded_bliques", "expanded_clinators", "expanded_Clocations", "expanded_glodes", "expanded_blopes", "expanded_captiques", "expandedlychusters", "expandededdecessions", "expanded_blessions", "expanded_glusters", "expanded_clessions", "expanded_decessions", "expandededdecusters", "expanded___cluster", "expandedlyclusters", "expanded_", "expanded_cluster", "expanded___commiques", "expandedlyclocations", "expanded_Clusters", "expanded_gliques", "expanded_closures", "expanded_conusters", "expanded_decancers", "expanded_commiques", "expanded_decopes", "expanded_bluster", "expanded_clodes", "expanded_Closures", "expoved_", "expanded_relers", "expanded_conanks", "expanded_coniques", "expanded_Clers", "expanded_relancers", "expanded_decusters", "expandedlychosures", "expanded_clancers", "expandedlyclosures", "expanded_relusters", "expanded___commuster", "expanded_blinators", "expanded_chocations", "expanded_blancers", "expandededclopes", "expandededclusters", "expanded_gluster", "expanded___commusters", "repanded_", "expanded_clers", "expanded_relopes", "expanded___clodes", "expanded_chosures", "expanded_relocations", "expanded_chers", "expandedlyclers", "expanded_clopes", "expanded_relessions", "expanded_commuster", "expanded___clusters", "expandedlychocations", "expanded_blodes", "expanded_captinators", "expandededclessions", "expaped_", "expanded_relosures", "expanded_cliques", "expanded_clocations", "expandededdecopes", "expandedlychers", "expanded_blusters", "expanded_blanks", "expanded_captanks", "expanded___commodes", "expributed_", "expanded_captusters", "expandededdecancers", "expanded_commodes", "expanded_coninators", "expanded_chusters", "expanded_commusters", "expandededclancers", "expanded___cliques", "expanded_clanks", "repributed_"], "ret": ["usr", "ft", "ref", "jp", "RT", "RET", "elt", "lt", "dt", "nz", "status", "success", "out", "re", "reply", "compl", "cat", "Ret", "result", "ort", "ext", "del", "def", "r", "err", "tf", "tr", "ry", "flag", "alt", "att", "nt", "cert", "vet", "ert", "len", "rev", "sat", "gc", "fun", "cont", "it", "res", "red", "back", "at", "after", "rm", "mt", "det", "gt", "try", "t", "ll", "ter", "net", "rets", "get", " Ret", "resp", "rt", "cmd", "val", "print", "deg", "mat", "reset", "rem"], "i": ["h", "iq", "ind", "info", "l", "ai", "ii", "ji", "n", "gi", "status", "di", "history", "x", "sim", "out", "ij", "ip", "init", "u", "ti", "li", "hi", "\u0438", "I", "p", "this", "list", "si", "batch", "m", "ri", "name", "ia", "b", "e", "multi", "im", "in", "ami", "remote", "ims", "index", "iu", "to", "id", " ii", "it", "um", "me", "ci", "ie", "xi", "ex", "ic", "ki", "zi", "ix", "mi", "o", "pi", "v", "f", "bi", "ini", "ui", "uri", "io"], "j": ["ind", "jp", "l", "adj", "ji", "n", "aj", "k", "z", "json", "br", "x", "bj", "ij", "jo", "col", "c", "q", "p", "jj", "jump", "m", "oj", "key", "us", "tr", " dj", "bo", "b", "att", "ja", "js", "index", "job", "it", "str", "je", "ev", "uj", "fr", "dj", "other", "kj", "J", "jc", "pr", "pt", "o", "v", "y", "f", "obj", "jl", "on", "jit"]}}
{"project": "qemu", "commit_id": "12848bfc5d719bad536c5448205a3226be1fda47", "target": 1, "func": "static int local_open2(FsContext *fs_ctx, const char *path, int flags,\n\n        FsCred *credp)\n\n{\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(rpath(fs_ctx, path), credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    return fd;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(rpath(fs_ctx, path));\n\n    errno = serrno;\n\n    return err;\n\n}\n", "idx": 12805, "substitutes": {"fs_ctx": [" fs_cb", "fs_conn", "sys_cv", "fs_addr", " fs_context", " fs_pkg", "fs_gz", "cs_ctx", " fs_cmp", " fs_conn", "retstgz", "fstctx", "cs_jp", "ims_tx", "fsplctx", "fs_cv", "fs_jp", "oss_obj", "fs_jac", "fstgz", "ims_cp", "cs_jac", "fsamepkg", "oss_ctx", "fs_cb", "fs_cp", "fscalcv", "fsplobj", "fsamejac", "rets_gz", "fsttx", "fstconn", "fsplcp", "fs_cmp", "fs_obj", "fs_context", "fs_pkg", "fs_tx", "fsamejp", "fscalctx", " fs_obj", "fsamectx", "ims_addr", "cs_pkg", "sys_cmp", "rets_tx", "sys_ctx", "retstconn", "ims_ctx", "rets_conn", "rets_ctx", "oss_conn", "retstctx", "sys_tx", "fs_tmp", "fsplconn", "fscalcmp", "retsttx", " fs_tmp", "oss_cp", "fscaltx"], "path": ["pkg", "context", "kind", "ref", "prefix", "prop", "PATH", "th", "priv", "route", "present", "txt", "history", "format", "full", "c", "has", "patch", "alias", "root", "p", "m", "empty", "key", "host", "binding", "handle", "name", "chain", "box", "pattern", "ATH", "ctx", "pointer", "Path", "eth", "spec", "dir", "cont", "rect", "str", "transform", "anc", "ex", "pat", "filename", "test", "file", "pt", "mount", "part", "cmd", "pi", "f", "mat", "policy", "ath", "length"], "flags": ["fps", "lines", "hours", "doms", "limits", "settings", "status", "amps", "reports", "levels", "FLAG", "heads", "ps", "fields", "links", "weights", "args", "options", "opens", "mates", "flag", "features", "faces", "Flags", "pps", "ports", "members", "locks", "tags", "ags", "fd", "vals", "pins", "frames", "properties", "times", "cs", "acts", "bits", "wcs", "types", "cmd", "stats", "grades", "lag", "mask", "packages", "posts"], "credp": ["creedp", "cedP", "scrednp", "cEDP", "scedP", " cpredq", "cribnp", "crednp", "cribps", "cedp", "cEDp", " credq", "cednp", "cgedn", "credn", "credvp", "cledp", "credpr", "cribpa", "lcreedpid", "Credps", "Cldphp", "cbedn", "cpredp", "scedp", "Credpa", "Cldpa", "lcredp", "cromp", "scednp", "lcreedpr", "cribP", "Credphp", "cedn", "credP", "cprps", "credps", "cromvp", "Credjp", "cbedP", "cEDpa", "cribp", " credvp", "cbedps", "credq", "lcredP", "cEDjp", "Cldp", "creedpid", "cribjp", "creedP", "credphp", "CredP", "scredP", "lcreedp", "Cldjp", "cprP", " cpredvp", "cppedp", "cprp", "cledpid", "cppedP", "cbednp", "cprphp", "cribphp", "cribvp", "cldphp", "lcredpr", "scredjp", "cppedphp", "lcredpid", "scredn", "scedjp", "cldp", "Cldps", "cbedjp", "cgedp", " credphp", "cldP", "cpredq", "cledpr", " cpredp", "scedn", "cgedP", "cldjp", "cpredvp", "cedjp", "cedps", "scredps", "cppedps", "credjp", "CldP", "cribq", "cromphp", "cgedjp", "creedpr", "scedps", "cpredphp", "cbedp", "credpa", "Credp", "cldpa", "credpid", "cldps", " cpredphp", "cledP", "cromq", "lcreedP", "scredp"]}}
{"project": "FFmpeg", "commit_id": "221b804f3491638ecf2eec1302c669ad2d9ec799", "target": 1, "func": "static inline void yuv2packedXinC(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\n\n\t\t\t\t    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\n\n\t\t\t\t    uint8_t *dest, int dstW, int y)\n\n{\n\n\tint i;\n\n\tswitch(c->dstFormat)\n\n\t{\n\n\tcase PIX_FMT_BGR32:\n\n\tcase PIX_FMT_RGB32:\n\n\t\tYSCALE_YUV_2_RGBX_C(uint32_t)\n\n\t\t\t((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1];\n\n\t\t\t((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2];\n\n\t\t}\n\n\t\tbreak;\n\n\tcase PIX_FMT_RGB24:\n\n\t\tYSCALE_YUV_2_RGBX_C(uint8_t)\n\n\t\t\t((uint8_t*)dest)[0]= r[Y1];\n\n\t\t\t((uint8_t*)dest)[1]= g[Y1];\n\n\t\t\t((uint8_t*)dest)[2]= b[Y1];\n\n\t\t\t((uint8_t*)dest)[3]= r[Y2];\n\n\t\t\t((uint8_t*)dest)[4]= g[Y2];\n\n\t\t\t((uint8_t*)dest)[5]= b[Y2];\n\n\t\t\tdest+=6;\n\n\t\t}\n", "idx": 12809, "substitutes": {"c": ["h", "d", "ch", "l", "con", "n", "lc", "dc", "cp", "st", "p", "s", "cam", "m", "C", "tc", "e", "cc", "rc", "ctx", "cv", "ce", "cont", "cf", "ci", "ct", "t", "cs", "fc", "ac", "v", "f", "w", "co"], "lumFilter": ["lumFlag", " lutSort", " lumRef", " lutFlag", "lumaFilter", "lumaSort", "lutRef", "lutFilter", " lumFlag", "lutFlag", " lutRef", "lumSort", "lulFilter", " lumSort", "lulRef", " lutFilter", "lulSort", "lulFlag", "lumRef", "lumaRef", "lumaFlag", "lutSort"], "lumSrc": ["lumRessrc", "lumResRC", "lumSource", "lumPRC", "lumPsrc", "lumResrc", "lumPource", "lumSRC", "lumaSrc", "lumSsrc", "lumResource", "lumaSource", "lumaSRC", "lumPrc", "lumaSsrc"], "lumFilterSize": ["lumFilterSIZE", "lumMaskStyle", "lumBufferSize", "lamBufferLength", "lumBufferLength", "lumfilterSize", "lumfilterSIZE", "lumFilterStyle", "lamFilterSIZE", "lamFilterStyle", "lumfilterStyle", "lumMaskSIZE", "lumMaskSize", "lumfilterLength", "lumBufferStyle", "lamBufferSize", "lamFilterLength", "lamBufferStyle", "lumMaskLength", "lamBufferSIZE", "lamFilterSize", "lumFilterLength", "lumBufferSIZE"], "chrFilter": ["chmrContext", "CHrtFilter", "CHrtFil", "chrsFil", "chrtContext", "chrtTest", "chrtFilter", "chrTest", "chrContext", "CHrFilter", "chrsFilter", "chmrFilter", "chrtFil", "chrFil", "CHrtContext", "CHrContext", "CHrFil", "CHrTest", "chrsContext", "chrsTest", "chmrTest", "chmrFil", "CHrtTest"], "chrSrc": ["chrcSlra", "chrcSsrc", "chrcSrc", "chrNsrc", "chrSlrc", "chrcSlsrc", "chrcSlrc", "chrSlsrc", "chrSsrc", "chrcSRC", "chrNRC", "chrSlra", "chrcSlRC", "chrcSra", "chrSlRC", "chrNrc", "chrNra", "chrSRC", "chrSra"], "chrFilterSize": ["chrMaskScale", "chrcFilterSIZE", "chrcFilterSize", "chrcBufferScale", "chrcFilterScale", "chrcBufferSIZE", "chrcBufferSize", "chrBufferScale", "chrFilterSIZE", "chrcBufferLength", "chrFilterLength", "chrFilterScale", "chrBufferSize", "chrHandlerLength", "chrHandlerScale", "chrHandlerSize", "chrMaskSize", "chrMaskSIZE", "chrBufferLength", "chrMaskLength", "chrcFilterLength", "chrHandlerSIZE", "chrBufferSIZE"], "dest": ["orig", "status", "r", "ptr", "dim", "mem", "ports", "dep", "it", "usr", "d", "prop", "end", "std", "slave", "temp", "results", "pas", "del", "set", "good", "target", "EST", "msg", "coord", "source", "shape", "sum", "trans", "ident", "dc", "Dest", "src", "st", "loc", "err", "origin", "options", "alt", "decl", "max", "gate", "deg", "master", "params", "est", "dist", "priv", "out", "result", "global", "p", "list", "neg", "desc", "port", "e", "chain", "dev", "iter", "spec", "cont", "transform", "test", "config", "rest", "table", "v", "foreign", "w", "dat", "output", "shift"], "dstW": ["dstM", "DestWidth", "destW", "dndWidth", "DstH", "dndW", "destH", "DestH", "dstH", "DstM", "DstWidth", "ddestWidth", "dndM", "ddestH", "destWidth", "dndH", "ddestM", "ddestW", "DestW", "DstW", "destM", "dstWidth", "DestM"], "y": ["ch", "d", "py", "ly", "yi", "ty", "x", "ies", "iy", "dy", "p", "sy", "m", "ry", "b", "xy", "my", "yp", "ay", "j", "oy", "t", "yy", "Y", "w", "ny", "iny"], "i": ["d", "ii", "n", "di", "x", "ij", "I", "p", " j", "set", "si", "m", "im", "b", "count", " index", "index", "id", " ii", "it", "j", "ci", "t", "ix", "mi", "is", "pi", "v"]}}
{"project": "FFmpeg", "commit_id": "2fc9a3eb7a8c606bd403dc9fbdb8463144b243cf", "target": 1, "func": "static int write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    int ret, did_split;\n    if (s->output_ts_offset) {\n        AVStream *st = s->streams[pkt->stream_index];\n        int64_t offset = av_rescale_q(s->output_ts_offset, AV_TIME_BASE_Q, st->time_base);\n        if (pkt->dts != AV_NOPTS_VALUE)\n            pkt->dts += offset;\n        if (pkt->pts != AV_NOPTS_VALUE)\n            pkt->pts += offset;\n    }\n    if (s->avoid_negative_ts > 0) {\n        AVStream *st = s->streams[pkt->stream_index];\n        int64_t offset = st->mux_ts_offset;\n        int64_t ts = s->internal->avoid_negative_ts_use_pts ? pkt->pts : pkt->dts;\n        if (s->internal->offset == AV_NOPTS_VALUE && ts != AV_NOPTS_VALUE &&\n            (ts < 0 || s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO)) {\n            s->internal->offset = -ts;\n            s->internal->offset_timebase = st->time_base;\n        }\n        if (s->internal->offset != AV_NOPTS_VALUE && !offset) {\n            offset = st->mux_ts_offset =\n                av_rescale_q_rnd(s->internal->offset,\n                                 s->internal->offset_timebase,\n                                 st->time_base,\n                                 AV_ROUND_UP);\n        }\n        if (pkt->dts != AV_NOPTS_VALUE)\n            pkt->dts += offset;\n        if (pkt->pts != AV_NOPTS_VALUE)\n            pkt->pts += offset;\n        if (s->internal->avoid_negative_ts_use_pts) {\n            if (pkt->pts != AV_NOPTS_VALUE && pkt->pts < 0) {\n                av_log(s, AV_LOG_WARNING, \"failed to avoid negative \"\n                    \"pts %s in stream %d.\\n\"\n                    \"Try -avoid_negative_ts 1 as a possible workaround.\\n\",\n                    av_ts2str(pkt->dts),\n                    pkt->stream_index\n                );\n            }\n        } else {\n            av_assert2(pkt->dts == AV_NOPTS_VALUE || pkt->dts >= 0 || s->max_interleave_delta > 0);\n            if (pkt->dts != AV_NOPTS_VALUE && pkt->dts < 0) {\n                av_log(s, AV_LOG_WARNING,\n                    \"Packets poorly interleaved, failed to avoid negative \"\n                    \"timestamp %s in stream %d.\\n\"\n                    \"Try -max_interleave_delta 0 as a possible workaround.\\n\",\n                    av_ts2str(pkt->dts),\n                    pkt->stream_index\n                );\n            }\n        }\n    }\n    did_split = av_packet_split_side_data(pkt);\n    if (!s->internal->header_written) {\n        ret = s->internal->write_header_ret ? s->internal->write_header_ret : write_header_internal(s);\n        if (ret < 0)\n            goto fail;\n    }\n    if ((pkt->flags & AV_PKT_FLAG_UNCODED_FRAME)) {\n        AVFrame *frame = (AVFrame *)pkt->data;\n        av_assert0(pkt->size == UNCODED_FRAME_PACKET_SIZE);\n        ret = s->oformat->write_uncoded_frame(s, pkt->stream_index, &frame, 0);\n        av_frame_free(&frame);\n    } else {\n        ret = s->oformat->write_packet(s, pkt);\n    }\n    if (s->pb && ret >= 0) {\n        if (s->flush_packets && s->flags & AVFMT_FLAG_FLUSH_PACKETS)\n            avio_flush(s->pb);\n        if (s->pb->error < 0)\n            ret = s->pb->error;\n    }\nfail:\n    if (did_split)\n        av_packet_merge_side_data(pkt);\n    if (ret < 0) {\n        pkt->pts = pts_backup;\n        pkt->dts = dts_backup;\n    }\n    return ret;\n}", "idx": 12810, "substitutes": {"s": ["bs", "fs", "status", "cli", "space", "http", "ps", "r", "args", "ms", "ports", "js", "g", "services", "sw", "ex", "ares", "se", "tests", "ins", "details", "h", "changes", "sb", "series", "ops", "os", "als", "has", "sv", "set", "store", "m", "sports", "events", "ags", "t", "states", "is", "source", "f", "south", "parts", "ns", "rs", "ies", "S", "so", "service", "c", "comm", "eps", "sys", "ls", "vs", "hs", "ats", "its", "ims", "sq", "sets", "https", "these", "ts", "a", "bits", "qs", "ss", "sts", "aunts", "n", "settings", "ses", "state", "conf", "p", "es", "sam", "us", "aws", "gs", "b", "spec", "bis", "less", "ds", "self", "cs", "v", "stats", "rest", "obj", "w"], "pkt": ["pkg", "appcmd", "cpct", "permit", "pdu", "pcacket", "opkg", "pkgunct", "parmsg", "phpdu", "opacket", "ppkt", "appkg", "pcunct", "portunt", "expunt", "perant", "cpnt", "Pgt", "precmd", "tacket", " pmsg", "Pnt", "phpmsg", "pcnt", "tkt", "ipcmd", "dkt", "cacket", "opcmd", " pnt", "pckt", "portix", "expacket", "bpcmd", "pix", "phpunct", " pkg", "Packet", "cpdu", "cpkt", "expkg", "dkg", "pkat", "prekg", " pct", "bpkt", "expkt", "Pcmd", "nix", "bpkat", "ddu", "ckt", "opdu", " pdu", "pcant", "payunct", "nconn", "pkgkg", "ipkt", "appacket", "appix", "pkgdu", "paykt", "opnt", "portunct", " pgt", "cpkat", " pud", " pkat", "bpacket", "cnt", "pcmd", "ipkg", "perunct", "phpacket", " punct", "parunct", "ipgt", "tkg", "ccmd", "pracket", "parud", "pnt", "pgt", "ppacket", "pmit", "portconn", "nkt", "prent", "prnt", "portud", "opunct", "prekt", "parkt", "punct", "cdu", "appconn", "pconn", "pcmit", "pkgkt", "payant", " packet", "pant", "ppdu", "perkt", "Pkg", "portkt", "tcmd", "phpunt", "Pct", "Pkat", "portmsg", " punt", "punt", "cpacket", "pckat", "appkt", "prkt", "Pkt", "phpkg", "cpcmd", "phpkt", "opkt", "packet", "prunct", "preacket", "pct", "Pdu", "pmsg", " pcmd", "paymit", "pud", "prekat", "dacket", "ppcmd"], "ret": ["ft", " alt", "RET", "elt", " mem", "Ret", " ans", " RET", "et", "flag", "alt", " resp", "len", "offset", " fs", " fmt", " ref", "mt", " flag", "t", " Ret", " val", " res", "val", " af", " addr"], "did_split": ["did_break", "did2len", "done_split", "done2len", "did_len", "done2size", "did2break", "did2split", "did_size", "done_break", "done_size", "done2break", "did2size", "done2split", "done_len"], "st": ["ST", "h", "usr", "sn", "ut", "end", "std", "stop", "th", "St", "sl", "bt", "nd", "stack", "art", "z", "lat", "ast", "so", "ist", "sv", "src", "ste", "ost", "set", "sty", "start", "tz", "nt", "sa", "ctx", "sp", "stable", "sts", "kt", "str", "sh", "sw", "ad", "est", "stage", "step", "ct", "mt", "sta", "inst", "t", "tt", "se", "ts", "pt", "lib", "rt", "ld", "sm", "stat", "rest", "tra", "be", "td", "irst", "ss"]}}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static void read_sgi_header(ByteIOContext *f, SGIInfo *info)\n{\n    info->magic = (unsigned short) get_be16(f);\n    info->rle = get_byte(f);\n    info->bytes_per_channel = get_byte(f);\n    info->dimension = (unsigned short)get_be16(f);\n    info->xsize = (unsigned short) get_be16(f);\n    info->ysize = (unsigned short) get_be16(f);\n    info->zsize = (unsigned short) get_be16(f);\n#ifdef DEBUG\n    printf(\"sgi header fields:\\n\");\n    printf(\"  magic: %d\\n\", info->magic);\n    printf(\"    rle: %d\\n\", info->rle);\n    printf(\"    bpc: %d\\n\", info->bytes_per_channel);\n    printf(\"    dim: %d\\n\", info->dimension);\n    printf(\"  xsize: %d\\n\", info->xsize);\n    printf(\"  ysize: %d\\n\", info->ysize);\n    printf(\"  zsize: %d\\n\", info->zsize);\n#endif\n    return;\n}", "idx": 12814, "substitutes": {"f": ["uf", "i", "h", "inf", "d", "fs", "fp", "l", "ft", "fm", "fa", "fac", "bf", "out", "full", "c", "ed", "q", "er", "xf", "p", "df", "r", "fo", "m", "tf", "buff", "b", "fb", "e", "iter", "buffer", "fi", "af", "far", "fd", "g", "cf", "cont", "lf", "it", "um", "j", "fr", "sf", "ct", "ex", "ic", "t", "fed", "file", "fc", "ac", "v", "form", "w", "stream"], "info": ["status", "history", "error", "http", "information", "check", "Info", "add", "parse", "rule", "it", "help", "description", "show", "report", "debug", "all", "sync", "details", "event", "cache", "py", "ii", "style", "ion", "full", "init", "hi", "set", "start", "fo", "name", "request", "try", "comment", "copy", "link", "by", "ui", "doc", "notice", "query", "kind", "inf", "sum", "req", "app", "summary", "about", "exec", "pretty", "err", "update", "cell", "where", "trace", "count", "no", "fi", "note", "index", "auth", "control", "pi", "edit", "i", "time", "state", "INFO", "conf", "list", "desc", "now", "entry", "reason", "iter", "ok", "id", "inner", " inf", "iso", "test", "api", "config"]}}
{"project": "qemu", "commit_id": "e9ebead2b5c70890454e698d9ff174e3020ea861", "target": 1, "func": "static void pc_init1(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     int pci_enabled, const char *cpu_model)\n\n{\n\n    char buf[1024];\n\n    int ret, linux_boot, i;\n\n    ram_addr_t ram_addr, vga_ram_addr, bios_offset, vga_bios_offset;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size = 0;\n\n    int bios_size, isa_bios_size, vga_bios_size;\n\n    PCIBus *pci_bus;\n\n    int piix3_devfn = -1;\n\n    CPUState *env;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *i8259;\n\n    int index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BlockDriverState *fd[MAX_FD];\n\n\n\n    if (ram_size >= 0xe0000000 ) {\n\n        above_4g_mem_size = ram_size - 0xe0000000;\n\n        below_4g_mem_size = 0xe0000000;\n\n    } else {\n\n        below_4g_mem_size = ram_size;\n\n    }\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_X86_64\n\n        cpu_model = \"qemu64\";\n\n#else\n\n        cpu_model = \"qemu32\";\n\n#endif\n\n    }\n\n    \n\n    for(i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find x86 CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        if (i != 0)\n\n            env->halted = 1;\n\n        if (smp_cpus > 1) {\n\n            /* XXX: enable it in all cases */\n\n            env->cpuid_features |= CPUID_APIC;\n\n        }\n\n        qemu_register_reset(main_cpu_reset, env);\n\n        if (pci_enabled) {\n\n            apic_init(env);\n\n        }\n\n    }\n\n\n\n    vmport_init();\n\n\n\n    /* allocate RAM */\n\n    ram_addr = qemu_ram_alloc(0xa0000);\n\n    cpu_register_physical_memory(0, 0xa0000, ram_addr);\n\n\n\n    /* Allocate, even though we won't register, so we don't break the\n\n     * phys_ram_base + PA assumption. This range includes vga (0xa0000 - 0xc0000),\n\n     * and some bios areas, which will be registered later\n\n     */\n\n    ram_addr = qemu_ram_alloc(0x100000 - 0xa0000);\n\n    ram_addr = qemu_ram_alloc(below_4g_mem_size - 0x100000);\n\n    cpu_register_physical_memory(0x100000,\n\n                 below_4g_mem_size - 0x100000,\n\n                 ram_addr);\n\n\n\n    /* above 4giga memory allocation */\n\n    if (above_4g_mem_size > 0) {\n\n        ram_addr = qemu_ram_alloc(above_4g_mem_size);\n\n        cpu_register_physical_memory(0x100000000ULL,\n\n                                     above_4g_mem_size,\n\n                                     ram_addr);\n\n    }\n\n\n\n\n\n    /* allocate VGA RAM */\n\n    vga_ram_addr = qemu_ram_alloc(vga_ram_size);\n\n\n\n    /* BIOS load */\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    bios_size = get_image_size(buf);\n\n    if (bios_size <= 0 ||\n\n        (bios_size % 65536) != 0) {\n\n        goto bios_error;\n\n    }\n\n    bios_offset = qemu_ram_alloc(bios_size);\n\n    ret = load_image(buf, phys_ram_base + bios_offset);\n\n    if (ret != bios_size) {\n\n    bios_error:\n\n        fprintf(stderr, \"qemu: could not load PC BIOS '%s'\\n\", buf);\n\n        exit(1);\n\n    }\n\n\n\n    if (cirrus_vga_enabled || std_vga_enabled || vmsvga_enabled) {\n\n        /* VGA BIOS load */\n\n        if (cirrus_vga_enabled) {\n\n            snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, VGABIOS_CIRRUS_FILENAME);\n\n        } else {\n\n            snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, VGABIOS_FILENAME);\n\n        }\n\n        vga_bios_size = get_image_size(buf);\n\n        if (vga_bios_size <= 0 || vga_bios_size > 65536)\n\n            goto vga_bios_error;\n\n        vga_bios_offset = qemu_ram_alloc(65536);\n\n\n\n        ret = load_image(buf, phys_ram_base + vga_bios_offset);\n\n        if (ret != vga_bios_size) {\n\nvga_bios_error:\n\n            fprintf(stderr, \"qemu: could not load VGA BIOS '%s'\\n\", buf);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* setup basic memory access */\n\n    cpu_register_physical_memory(0xc0000, 0x10000,\n\n                                 vga_bios_offset | IO_MEM_ROM);\n\n\n\n    /* map the last 128KB of the BIOS in ISA space */\n\n    isa_bios_size = bios_size;\n\n    if (isa_bios_size > (128 * 1024))\n\n        isa_bios_size = 128 * 1024;\n\n    cpu_register_physical_memory(0x100000 - isa_bios_size,\n\n                                 isa_bios_size,\n\n                                 (bios_offset + bios_size - isa_bios_size) | IO_MEM_ROM);\n\n\n\n    {\n\n        ram_addr_t option_rom_offset;\n\n        int size, offset;\n\n\n\n        offset = 0;\n\n        if (linux_boot) {\n\n            option_rom_offset = qemu_ram_alloc(TARGET_PAGE_SIZE);\n\n            load_linux(phys_ram_base + option_rom_offset,\n\n                       kernel_filename, initrd_filename, kernel_cmdline);\n\n            cpu_register_physical_memory(0xd0000, TARGET_PAGE_SIZE,\n\n                                         option_rom_offset | IO_MEM_ROM);\n\n            offset = TARGET_PAGE_SIZE;\n\n        }\n\n\n\n        for (i = 0; i < nb_option_roms; i++) {\n\n            size = get_image_size(option_rom[i]);\n\n            if (size < 0) {\n\n                fprintf(stderr, \"Could not load option rom '%s'\\n\",\n\n                        option_rom[i]);\n\n                exit(1);\n\n            }\n\n            if (size > (0x10000 - offset))\n\n                goto option_rom_error;\n\n            option_rom_offset = qemu_ram_alloc(size);\n\n            ret = load_image(option_rom[i], phys_ram_base + option_rom_offset);\n\n            if (ret != size) {\n\n            option_rom_error:\n\n                fprintf(stderr, \"Too many option ROMS\\n\");\n\n                exit(1);\n\n            }\n\n            size = (size + 4095) & ~4095;\n\n            cpu_register_physical_memory(0xd0000 + offset,\n\n                                         size, option_rom_offset | IO_MEM_ROM);\n\n            offset += size;\n\n        }\n\n    }\n\n\n\n    /* map all the bios at the top of memory */\n\n    cpu_register_physical_memory((uint32_t)(-bios_size),\n\n                                 bios_size, bios_offset | IO_MEM_ROM);\n\n\n\n    bochs_bios_init();\n\n\n\n    cpu_irq = qemu_allocate_irqs(pic_irq_request, NULL, 1);\n\n    i8259 = i8259_init(cpu_irq[0]);\n\n    ferr_irq = i8259[13];\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, i8259);\n\n        piix3_devfn = piix3_init(pci_bus, -1);\n\n    } else {\n\n        pci_bus = NULL;\n\n    }\n\n\n\n    /* init basic PC hardware */\n\n    register_ioport_write(0x80, 1, 1, ioport80_write, NULL);\n\n\n\n    register_ioport_write(0xf0, 1, 1, ioportF0_write, NULL);\n\n\n\n    if (cirrus_vga_enabled) {\n\n        if (pci_enabled) {\n\n            pci_cirrus_vga_init(pci_bus,\n\n                                ds, phys_ram_base + vga_ram_addr,\n\n                                vga_ram_addr, vga_ram_size);\n\n        } else {\n\n            isa_cirrus_vga_init(ds, phys_ram_base + vga_ram_addr,\n\n                                vga_ram_addr, vga_ram_size);\n\n        }\n\n    } else if (vmsvga_enabled) {\n\n        if (pci_enabled)\n\n            pci_vmsvga_init(pci_bus, ds, phys_ram_base + vga_ram_addr,\n\n                            vga_ram_addr, vga_ram_size);\n\n        else\n\n            fprintf(stderr, \"%s: vmware_vga: no PCI bus\\n\", __FUNCTION__);\n\n    } else if (std_vga_enabled) {\n\n        if (pci_enabled) {\n\n            pci_vga_init(pci_bus, ds, phys_ram_base + vga_ram_addr,\n\n                         vga_ram_addr, vga_ram_size, 0, 0);\n\n        } else {\n\n            isa_vga_init(ds, phys_ram_base + vga_ram_addr,\n\n                         vga_ram_addr, vga_ram_size);\n\n        }\n\n    }\n\n\n\n    rtc_state = rtc_init(0x70, i8259[8]);\n\n\n\n    qemu_register_boot_set(pc_boot_set, rtc_state);\n\n\n\n    register_ioport_read(0x92, 1, 1, ioport92_read, NULL);\n\n    register_ioport_write(0x92, 1, 1, ioport92_write, NULL);\n\n\n\n    if (pci_enabled) {\n\n        ioapic = ioapic_init();\n\n    }\n\n    pit = pit_init(0x40, i8259[0]);\n\n    pcspk_init(pit);\n\n    if (!no_hpet) {\n\n        hpet_init(i8259);\n\n    }\n\n    if (pci_enabled) {\n\n        pic_set_alt_irq_func(isa_pic, ioapic_set_irq, ioapic);\n\n    }\n\n\n\n    for(i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], i8259[serial_irq[i]], 115200,\n\n                        serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {\n\n        if (parallel_hds[i]) {\n\n            parallel_init(parallel_io[i], i8259[parallel_irq[i]],\n\n                          parallel_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!pci_enabled || (nd->model && strcmp(nd->model, \"ne2k_isa\") == 0))\n\n            pc_init_ne2k_isa(nd, i8259);\n\n        else\n\n            pci_nic_init(pci_bus, nd, -1, \"ne2k_pci\");\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n\tif (index != -1)\n\n\t    hd[i] = drives_table[index].bdrv;\n\n\telse\n\n\t    hd[i] = NULL;\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1, i8259);\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            isa_ide_init(ide_iobase[i], ide_iobase2[i], i8259[ide_irq[i]],\n\n\t                 hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n        }\n\n    }\n\n\n\n    i8042_init(i8259[1], i8259[12], 0x60);\n\n    DMA_init(0);\n\n#ifdef HAS_AUDIO\n\n    audio_init(pci_enabled ? pci_bus : NULL, i8259);\n\n#endif\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        index = drive_get_index(IF_FLOPPY, 0, i);\n\n\tif (index != -1)\n\n\t    fd[i] = drives_table[index].bdrv;\n\n\telse\n\n\t    fd[i] = NULL;\n\n    }\n\n    floppy_controller = fdctrl_init(i8259[6], 2, 0, 0x3f0, fd);\n\n\n\n    cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device, hd);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n        i2c_bus *smbus;\n\n\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100, i8259[9]);\n\n        for (i = 0; i < 8; i++) {\n\n            smbus_eeprom_device_init(smbus, 0x50 + i, eeprom_buf + (i * 256));\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n\tint max_bus;\n\n        int bus, unit;\n\n        void *scsi;\n\n\n\n        max_bus = drive_get_max_bus(IF_SCSI);\n\n\n\n\tfor (bus = 0; bus <= max_bus; bus++) {\n\n            scsi = lsi_scsi_init(pci_bus, -1);\n\n            for (unit = 0; unit < LSI_MAX_DEVS; unit++) {\n\n\t        index = drive_get_index(IF_SCSI, bus, unit);\n\n\t\tif (index == -1)\n\n\t\t    continue;\n\n\t\tlsi_scsi_attach(scsi, drives_table[index].bdrv, unit);\n\n\t    }\n\n        }\n\n    }\n\n\n\n    /* Add virtio block devices */\n\n    if (pci_enabled) {\n\n        int index;\n\n        int unit_id = 0;\n\n\n\n        while ((index = drive_get_index(IF_VIRTIO, 0, unit_id)) != -1) {\n\n            virtio_blk_init(pci_bus, drives_table[index].bdrv);\n\n            unit_id++;\n\n        }\n\n    }\n\n\n\n    /* Add virtio balloon device */\n\n    if (pci_enabled)\n\n        virtio_balloon_init(pci_bus);\n\n\n\n    /* Add virtio console devices */\n\n    if (pci_enabled) {\n\n        for(i = 0; i < MAX_VIRTIO_CONSOLES; i++) {\n\n            if (virtcon_hds[i])\n\n                virtio_console_init(pci_bus, virtcon_hds[i]);\n\n        }\n\n    }\n\n}\n", "idx": 12828, "substitutes": {"ram_size": ["ram_SIZE", "ram_scale", "ram67size", "ram_num", "cpu_scale", "cam_size", "ram67name", "cpu_SIZE", "ram_length", "cam_free", "ramlistsize", "mem_addr", "gram_name", "gram_len", "ram67len", "ram_free", "ram_Size", "ramlistlen", "gram_width", "mem_offset", "ram_width", "ramlistaddr", "mem_size", "ram_offset", "cam_num", "mem_len", "cpu_size", "gram_size", "ram67width", "ram_name", "cpu_Size", "ramlistoffset", "ram_len", "cam_length"], "vga_ram_size": ["vga_mem_space", "vga_mem_device", "vga_mem_size", "vga_ram_space", "vga_mem_addr", "vga_ram_device"], "boot_device": ["bus_attribute", "bootdbdev", "bus_number", "bus_dev", "bus_device", "bootdbdevice", "bootdbnumber", "bootdbattribute", "bootingnumber", "boot_number", "boot_attribute", "boot_dev", "bootingdevice", "bootingattribute", "bootingdev"], "ds": ["bs", "fs", "rs", "dm", "dt", "ids", "ks", "dds", "ps", "eps", "bd", "Ds", "vs", "hs", "pd", "ded", "db", "des", "dd", "de", "eds", "sd", "ys", "du", "cs", "vd", "da", "DS", "sts"], "kernel_filename": ["kernel67filename", " kernel_path", "kerneliletitle", "kernel_file", "kernel67string", "proc_path", "kernel67path", "kernel_path", "kernelilefilename", " kernel_file", "kernel_network", "proc_filename", "proc_network", "kernelilepath", "kernel_title", "kernel_string", "kernelilefile", "kernel67network", " kernel_title", "proc_string"], "kernel_cmdline": ["kernel_cmdstyle", "kernel_cmdl", "kernel_authl", "kernel_authstyle", "kernel_cpstyle", "kernel_authline", "kernel_cpl", "kernel_cpline", "kernel_commandstyle", "kernel_commandline", "kernel_commandl"], "initrd_filename": ["initrd_sequence", "initrd_string", "initdirantname", "initrdrantfilename", "initrdrdsequence", "initrd_name", "initdi_name", "initrdrdfilename", "initdirantstring", "initrdrantname", "initdi_string", "initrdrdstring", "initdi_sequence", "initrdrantstring", "initdirantsequence", "initrdrdname", "initdirantfilename", "initdi_filename", "initrdrantsequence"], "pci_enabled": ["pic_enabled", "pci_activated", "pcu_online", "pci_enable", "pic_updated", "pic_disabled", "pciableupdated", "pciabledisabled", "pci_online", "pcu_activated", "pcu_enabled", "pci_disabled", "pic_enable", "pcu_disabled", "pciableenabled", "pci_updated", "pciableenable"], "cpu_model": [" cpu_module", " cpu_mode", "cpumyModel", "cpu_models", "cpu_Model", "gpu_model", "cpu_type", "cpu__link", "cpu_mode", "cpu__Model", "gpu_models", "cpumylink", " cpu_type", "CPU_size", " cpu_models", "gpu_link", "cpu_link", "cpumymodel", "cpu_module", "CPU_model", " cpu_Model", "cpu_map", "cpu__model", "CPU_link", "cpu_size", "cpumysize", "CPU_map", "CPU_Model", "cpu_base", "gpu_base", "cpu__map"], "buf": ["queue", "map", "page", "pool", "vec", "family", "batch", "ptr", "cast", " buffer", "raw", "buff", "flag", "code", "array", "count", "buffer", "block", "str", "Buffer", "cap", "data", "proc", "pack", "var", "length"], "ret": ["ref", "std", "RET", "status", "format", "out", "Ret", "ext", "def", "set", "sys", "ry", "flag", "read", "alt", "mem", "len", "fi", "j", "class", "net", "ea", "cmd", "lit", "val"], "linux_boot": ["linux__boot", "Linux_load", "ilo___host", "linux_build", "ilo___Boot", "linux_load", "linux_host", "linux_Boot", "Linux_bus", "ilo_host", "Linux_boot", "linux___host", "linux__build", "ilo___build", "ilo_boot", "linux___load", "linux___Boot", "ilo___boot", "linux_bus", "linux___boot", "ilo_Boot", "linux___bus", "Linux_Boot", "ilo_build", "linux__Boot", "linux__host", "linux___build"], "i": ["qi", "h", "ind", "info", "l", "ai", "ii", "n", "gi", "status", "di", "x", "sim", "cli", "ip", "gu", "c", "ti", "li", "hi", "I", "p", "ei", "si", "m", "ir", "b", "e", "multi", "im", "in", "iter", "ims", "fi", "iu", "id", "g", "it", "j", "me", "ci", "xi", "try", "t", "phi", "zi", "ix", "mi", "o", "a", "pi", "v", "f", "bi", "ini", "ui"], "ram_addr": ["rom_addr", "mem_addr", "rom_size", "mem_address", "ram_ptr", "ram_address", "mem_ptr", "rom_address"], "vga_ram_addr": ["vga_ram__addr", "vga_ram_ref", "vga_ram_address", "vga_mem_ptr", "vga_ram__ptr", "vga_mem_ref", "vga_ram__address", "vga_ram__ref", "vga_ram_ptr", "vga_mem_addr", "vga_mem_address"], "bios_offset": ["bios_start", "bio_start", "bio_offset", "bios_padding", "bio_address", "bio_padding", "bios_address"], "vga_bios_offset": ["vga_bio_offset", "vga_bio_size", "vga_bios_addr", "vga_bio_addr"], "below_4g_mem_size": ["below_4g_mem__Size", "below_4g_mem__size", "below_4g_ram_max", "below_4g_mem_Size", "below_4g_mem_max", "below_4g_ram_size", "below_4g_ram_name", "below_4g_mem__width", "below_4g_ram_SIZE", "below_4g_mem_width", "below_4g_mem_name", "below_4g_mem_set", "below_4g_mem_SIZE"], "bios_size": ["bio_SIZE", "bios_SIZE", "bio_number", "bio_offset", "bio_size", "bios_number"], "isa_bios_size": ["isa_bio_name", "isa_bios_SIZE", "isa_bio_size", "isa_bios_height", "isa_bios_name", "isa_bio_height", "isa_bio_SIZE"], "vga_bios_size": ["vga_bio_size", "vga_bios_storage", "vga_bio_storage", "vga_bios_SIZE", "vga_bio_SIZE"], "pci_bus": ["pci_board", "pci__board", "pci__boot", "pix_driver", "pci__driver", "pci_boot", "pix_bus", "pci__bus", "pix_boot", "pci_driver", "pix_board"], "env": ["event", "context", "h", "eu", "worker", "end", "tmp", "esp", "server", "here", "tx", "nv", "exec", "hw", "dh", "cb", "er", "eng", "environment", "enter", "err", "vs", "et", "vp", "cfg", "desc", "viron", "ent", "ah", "e", "dev", "db", "window", "entry", "code", "vt", "ctx", "door", "eh", "box", "ev", "manager", "ew", "engine", "era", "conn", "en", "enc", "proc", "ec", "ef", "func", "esc", "em", "vv", "ea", "Environment", "equ", "cmd", "v", "eddy", "obj", "vd", "vm", "ee"], "cpu_irq": ["cpu_pirQ", "cpu_mirqs", "cpu_irch", "cpu_mirq", "cpu_mirch", "cpu_drQ", "cpu_pirqs", "cpu_pirch", "cpu_irQ", "cpu_drq", "cpu_drch", "cpu_pirq", "cpu_irqs", "cpu_drqs", "cpu_mirQ"], "i8259": ["i8388", "i8192", " i4594", " i4259", "i4388", " i8388", " i8594", "i6192", "i4192", "i8594", "i6594", "i4594", "i15388", " i4192", "i6388", " i8192", "i4259", "i15192", " i4388", "i15594", "i15259", "i6259"], "index": ["context", "ind", "info", "type", "address", "thread", "error", "connection", "connected", "input", "connect", "interface", "si", "Index", "key", "valid", "loop", "fi", "id", "num", "open", "order", "axis", "config", "location", "label"], "hd": ["dn", "dl", "dist", "ck", "ha", "HD", "him", "hz", "dh", "bd", "df", "dr", "hs", "md", "pd", "rh", "hl", "xd", "dd", "sh", "hp", "hid", "rt", "ld", "hn", "kb", "cd", "vd", "ht"], "MAX_IDE_BUS": ["MAX_IDE_OUT", "MAX_ID_US", "MAX_ID_OUT", "MAX_ID_BUS", "MAX_IDEOPBS", "MAX_IDEOPOUT", "MAX_ID_BS", "MAX_IDE_US", "MAX_IDE_BS", "MAX_IDEOPBUS", "MAX_IDEOPUS"], "MAX_IDE_DEVS": ["MAX_IDE_DBS", "MAX_IDE_DRFS", "MAX_IDE_DPS", "MAX_IDE_DEBS", "MAX_IDE_DFS", "MAX_IDE_DVS", "MAX_IDE_DPPS", "MAX_IDE_DRBS", "MAX_IDE_DEPS", "MAX_IDE_DPVS", "MAX_IDE_DPBS", "MAX_IDE_DRVS", "MAX_IDE_DPFS", "MAX_IDE_DRPS", "MAX_IDE_DEFS"], "fd": ["ff", "dl", "fs", "fp", "fa", "dt", "FD", "pid", "bd", "df", "md", "fb", "fi", "dd", "dir", "id", "cf", "lf", "sd", "fr", "fl", "fin", "fc", "ld", "f", "cd", "fat", "td"], "MAX_FD": ["MIN_DIR", "MAX_HUD", "MAXIDFD", "MIN_HUD", "MAXIDDIR", "MIN_FD", "MAX_HD", "MIN_HD", "MAX_DIR", "MAXIDHUD", "MAXIDHD"]}}
{"project": "qemu", "commit_id": "0bed71edbc323de12ed1e5390a85a013f6a143f4", "target": 0, "func": "static int slirp_hostfwd(SlirpState *s, const char *redir_str,\n\n                         int legacy_format)\n\n{\n\n    struct in_addr host_addr = { .s_addr = INADDR_ANY };\n\n    struct in_addr guest_addr = { .s_addr = 0 };\n\n    int host_port, guest_port;\n\n    const char *p;\n\n    char buf[256];\n\n    int is_udp;\n\n    char *end;\n\n\n\n    p = redir_str;\n\n    if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (!legacy_format) {\n\n        if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n        if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n            goto fail_syntax;\n\n        }\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    host_port = strtol(buf, &end, 0);\n\n    if (*end != '\\0' || host_port < 1 || host_port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &guest_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    guest_port = strtol(p, &end, 0);\n\n    if (*end != '\\0' || guest_port < 1 || guest_port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (slirp_add_hostfwd(s->slirp, is_udp, host_addr, host_port, guest_addr,\n\n                          guest_port) < 0) {\n\n        error_report(\"could not set up host forwarding rule '%s'\",\n\n                     redir_str);\n\n        return -1;\n\n    }\n\n    return 0;\n\n\n\n fail_syntax:\n\n    error_report(\"invalid host forwarding rule '%s'\", redir_str);\n\n    return -1;\n\n}\n", "idx": 12846, "substitutes": {"s": ["h", "i", "fs", "rs", "sb", "S", "sv", "c", "ps", "st", "es", "r", "socket", "e", "sts", "g", "sq", "sw", "t", "ds", "ts", "is", "sm", "v", "w", "ss"], "redir_str": ["redir2br", "redirect_str", "redir_br", "reddir_br", "redir_Str", "redir2str", "redirect_Str", "redir2string", "redir2Str", "reddir_string", "redirect_string", "reddir_str", "redir_string", "redirect_br", "reddir_Str"], "legacy_format": ["legacy_Format", "legACY_Format", "legACY_form", "legacy_output", "legACY_version", "legacy_form", "legacy_version", "legACY_format", "legacy_mode"], "host_port": ["host_ort", "inner_phone", " host_name", "archive_pan", "host_phone", "hostablephone", "host_ports", "check_ports", "inner_port", "host_search", "check_person", "host_Port", "host_name", "hostableport", "hostablequeue", "hostablesearch", "archive_ort", "host_person", "check_port", "inner_search", "inner_queue", "host_pan", "archive_port", "host_post", "check_post", "host_queue", " host_Port", "host_line", "archive_line"], "guest_port": ["guest_component", "guess_ports", "guested_type", "guest__ports", "guest_ports", "guest_Port", "guest__port", "guest__component", "guest__PORT", "guested_ports", "guest_export", "guess_port", "guEST_PORT", "guess_component", "guEST_port", "guess_PORT", "guested_port", "guEST_ports", "guest_type", "guess_export", "guested_Port", "guest_PORT", "guess_Port", "guEST_component"], "p": ["pkg", "uf", "h", "i", "d", "cache", "jp", "prefix", "rep", "lp", "fp", "n", "prop", "pc", "pe", "k", "art", "padding", "point", "conv", "pa", "ip", "pid", "c", "cp", "q", "u", "ps", "np", "pre", "wp", "r", "start", "pass", "m", "ptr", "pb", "vp", "port", "pn", "buff", "pos", "b", "e", "pard", "tp", "pg", "buffer", "ctx", "sp", "per", "P", "g", "it", "str", "j", "proc", "pat", "t", "ep", "bp", "pt", "part", "pad", "a", "pp", "v", "f", "pend", "ping", "post"], "buf": ["pkg", "xff", "orig", "bc", "conv", "ait", "pool", "np", "cp", "cb", "eng", "pb", "mem", "pause", "pg", "cv", "Buffer", "pack", "que", "wait", "uf", "cache", "tmp", "txt", "br", "temp", "Buff", "img", " buffer", "vp", "tc", "buffer", "uffy", "paste", "cap", "msg", "bp", "rw", "cmd", "doc", "req", "bytes", "page", "bt", " buffers", "off", "rb", "q", "cam", "bag", "block", "data", "seq", "proc", "queue", "ff", "cur", "nm", "desc", "raw", "buff", "port", "b", "window", "box", "iter", "ctx", "str", "act", "aka", "pad", "v"], "is_udp": ["is_urh", "is_udps", "is_udpa", "is_adv", "is_uidp", "is_duh", "is_ugport", "is_udcp", "is_uidcp", "is_ducp", "is_hdv", "is_hdcp", "is_dup", "is_dupa", "is_udh", "is_adport", "is_uidport", "is_ugcp", "is_ugpa", "is_adcp", "is_duport", "is_hdp", "is_urps", "is_adp", "is_ddp", "is_uidpa", "is_dups", "is_udport", "is_urp", "is_ddcp", "is_duv", "is_urcp", "is_udv", "is_ddps", "is_hdport", "is_ugp", "is_ddh"], "end": ["event", "ff", "send", "stop", "last", "nd", "out", "next", "begin", "q", "st", "except", "append", "err", "start", "set", "add", "desc", "ent", "pos", "alt", "pard", "e", "chain", " End", "window", "hend", "id", "exc", "str", "help", "after", "offset", "ending", "ended", "en", "max", "gate", "enc", "comment", "pat", "ec", "conn", "END", "End", "pad", "all", "rest", "v", "pend", "obj", "w", "post", "est"]}}
{"project": "qemu", "commit_id": "e6eef7c221634c942e9f586df84aae623aa06cd5", "target": 0, "func": "int kvm_arch_put_registers(CPUState *cs, int level)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    CPUS390XState *env = &cpu->env;\n\n    struct kvm_sregs sregs;\n\n    struct kvm_regs regs;\n\n    struct kvm_fpu fpu;\n\n    int r;\n\n    int i;\n\n\n\n    /* always save the PSW  and the GPRS*/\n\n    cs->kvm_run->psw_addr = env->psw.addr;\n\n    cs->kvm_run->psw_mask = env->psw.mask;\n\n\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            cs->kvm_run->s.regs.gprs[i] = env->regs[i];\n\n            cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_GPRS;\n\n        }\n\n    } else {\n\n        for (i = 0; i < 16; i++) {\n\n            regs.gprs[i] = env->regs[i];\n\n        }\n\n        r = kvm_vcpu_ioctl(cs, KVM_SET_REGS, &regs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    /* Floating point */\n\n    for (i = 0; i < 16; i++) {\n\n        fpu.fprs[i] = env->fregs[i].ll;\n\n    }\n\n    fpu.fpc = env->fpc;\n\n\n\n    r = kvm_vcpu_ioctl(cs, KVM_SET_FPU, &fpu);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    /* Do we need to save more than that? */\n\n    if (level == KVM_PUT_RUNTIME_STATE) {\n\n        return 0;\n\n    }\n\n\n\n    /*\n\n     * These ONE_REGS are not protected by a capability. As they are only\n\n     * necessary for migration we just trace a possible error, but don't\n\n     * return with an error return code.\n\n     */\n\n    kvm_set_one_reg(cs, KVM_REG_S390_CPU_TIMER, &env->cputm);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_CLOCK_COMP, &env->ckc);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_TODPR, &env->todpr);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_GBEA, &env->gbea);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_PP, &env->pp);\n\n\n\n    if (cap_async_pf) {\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFTOKEN, &env->pfault_token);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFCOMPARE, &env->pfault_compare);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFSELECT, &env->pfault_select);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    if (cap_sync_regs &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            cs->kvm_run->s.regs.acrs[i] = env->aregs[i];\n\n            cs->kvm_run->s.regs.crs[i] = env->cregs[i];\n\n        }\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_ACRS;\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_CRS;\n\n    } else {\n\n        for (i = 0; i < 16; i++) {\n\n            sregs.acrs[i] = env->aregs[i];\n\n            sregs.crs[i] = env->cregs[i];\n\n        }\n\n        r = kvm_vcpu_ioctl(cs, KVM_SET_SREGS, &sregs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    /* Finally the prefix */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_PREFIX) {\n\n        cs->kvm_run->s.regs.prefix = env->psa;\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_PREFIX;\n\n    } else {\n\n        /* prefix is only supported via sync regs */\n\n    }\n\n    return 0;\n\n}\n", "idx": 12853, "substitutes": {"cs": ["bs", "vc", "fs", "rs", "CS", "pc", "cms", "cz", "ks", "checks", "cas", "ars", "ces", "els", "c", "cp", "cb", "ps", "ss", "cons", "cn", "otes", "s", "vs", "ls", "irs", "hs", "ms", "gs", "ats", "tc", "ports", "cc", "js", "rc", "ctx", "ims", "cv", "ce", "cus", "caps", "cf", "Cs", "aps", "cks", "ys", "css", "acs", "ec", "asks", "ctr", "ds", "ts", "sc", "acts", "ows", "wcs", "ics", "ins", "qs", "ras", "ns", "co", "sts"], "level": ["role", "info", "version", "type", "status", "style", "lc", "error", "local", "priority", "levels", "state", "depth", "top", "scale", "tag", "family", "where", "vel", "lvl", "code", "no", "loop", "index", "mode", "LE", "Level", "cost", "stage", "layer", "release", "VEL", "required", "print", "le", "high", "command", "scope", "location"], "cpu": ["uu", "clock", "runner", "pc", "gpu", "serv", "node", "session", "util", "setup", "cmp", "pu", "boot", "apache", "processor", "cp", "hw", "core", "cu", "client", "bench", "ne", "port", "ork", "mem", "common", "tp", "arch", "ctx", "instance", "gc", "nn", "conn", "ka", "ane", "proc", "anc", "upt", "CPU", "net", "nc", "wrapper", "process", "vm"], "env": ["esm", "outer", "export", "server", "nv", "addr", "cb", "eng", "org", "args", "et", "door", "engine", "den", "ef", "esc", "sc", "inv", "event", "context", "eu", "worker", "eve", "end", "serv", "esp", "stack", "here", "sv", "er", "client", "cfg", "era", "conn", "en", "enc", "exe", "net", "Environment", "docker", "doc", "ee", "menu", "ve", "pe", "app", "eps", "ext", "vs", "origin", "console", "viron", "shell", "agent", "ev", "ew", "eni", "stage", "proc", "ec", "ea", "queue", "runner", "extra", "hw", "conf", "environment", "ei", "desc", "ner", "port", "entry", "e", "dev", "window", "db", "ctx", "spec", "exc", "manager", "el", "gear", "v", "obj"], "sregs": ["srelments", "srels", "sregments", "srelts", "srelds", "sregts", "sregds"], "regs": ["REGls", "recS", "reggs", "retds", "recsi", "pris", " regts", "regos", "recns", "replts", "prs", "resds", "regis", "recgs", "gregs", "prls", "Regis", "egs", "ress", "Regts", "replos", "grs", "Regrs", "recs", "prds", "gregns", "regns", "grrs", "regr", " regrs", "regrs", "prts", "regS", "egS", " regls", "resr", "gregts", " regds", "recls", "replns", "regts", "REGns", "egls", " regsi", "retts", "Regos", "REGs", " reggs", "regds", " regis", "regls", "grsi", "REGS", "retls", "prrs", "recrs", "Regs", "grgs", "gregos", "rets", "Regls", "repls", "egns", "regsi", "rests", "Regds", "Regr", "prr", "Regns"], "fpu": ["vcpu", " fcu", "lfpc", "fpc", "Fpc", "frepc", "frecpu", "mcpu", " fpc", "Fpu", "xfpu", "bfpc", "fedcpu", "bfcpu", "frecu", "xfpc", "fpi", "Fpi", "vpu", "fcu", "bfcu", "fedpi", "vpc", "mcu", "frepu", "xfcpu", "Fcu", "mpc", "lfpu", "mpu", "fcpu", "fedpc", "fedpu", "fabcpu", "xfcu", "lfpi", " fcpu", "bfpu", "fabpc", "lfcpu", "fabpu", "fabcu", "vcu", "Fcpu"], "r": ["h", "ror", "rate", "d", "rank", "rs", "usr", "k", "radius", "br", "rb", "error", "re", "result", "ar", "c", "q", "adr", "er", "p", "arr", "err", "ri", "m", " rc", "R", "dr", "hr", "tr", "ry", "rd", "entry", "rc", "rr", "response", "rh", "nr", "rg", "it", "record", "res", "str", "rar", "fr", "rm", "sr", "mr", "attr", "ter", "debug", "vr", "pr", "rt", "kr", "cr", "v", "rec", " err", "lr", "or", "w"], "i": ["k", "status", "cli", "gu", "u", "this", "oi", " ii", "it", "ci", "ex", "ki", "zi", "mi", "y", "uri", "h", "info", "ii", "ji", "ij", "init", "client", "m", "ri", "multi", "ni", "j", "xi", "t", "ix", "ui", "ini", "qi", "ind", "ai", "di", "x", "q", "ti", "li", "\u0438", "I", "si", "batch", "key", "in", " v", "ims", "index", "phi", "o", "pi", "bi", "iq", "gi", "point", "sim", "ip", " l", "ei", "p", " j", "list", "us", "dr", "chain", "ami", "slice", "remote", "iu", "id", "me", "ic", "v", " ti"]}}
{"project": "qemu", "commit_id": "ffbb1705a33df8e2fb12b24d96663d63b22eaf8b", "target": 0, "func": "static void spapr_hotplug_req_event(uint8_t hp_id, uint8_t hp_action,\n\n                                    sPAPRDRConnectorType drc_type,\n\n                                    uint32_t drc)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());\n\n    struct hp_log_full *new_hp;\n\n    struct rtas_error_log *hdr;\n\n    struct rtas_event_log_v6 *v6hdr;\n\n    struct rtas_event_log_v6_maina *maina;\n\n    struct rtas_event_log_v6_mainb *mainb;\n\n    struct rtas_event_log_v6_hp *hp;\n\n\n\n    new_hp = g_malloc0(sizeof(struct hp_log_full));\n\n    hdr = &new_hp->hdr;\n\n    v6hdr = &new_hp->v6hdr;\n\n    maina = &new_hp->maina;\n\n    mainb = &new_hp->mainb;\n\n    hp = &new_hp->hp;\n\n\n\n    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6\n\n                               | RTAS_LOG_SEVERITY_EVENT\n\n                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED\n\n                               | RTAS_LOG_OPTIONAL_PART_PRESENT\n\n                               | RTAS_LOG_INITIATOR_HOTPLUG\n\n                               | RTAS_LOG_TYPE_HOTPLUG);\n\n    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)\n\n                                       - sizeof(new_hp->hdr));\n\n\n\n    spapr_init_v6hdr(v6hdr);\n\n    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);\n\n\n\n    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);\n\n    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));\n\n    mainb->subsystem_id = 0x80; /* External environment */\n\n    mainb->event_severity = 0x00; /* Informational / non-error */\n\n    mainb->event_subtype = 0x00; /* Normal shutdown */\n\n\n\n    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);\n\n    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));\n\n    hp->hdr.section_version = 1; /* includes extended modifier */\n\n    hp->hotplug_action = hp_action;\n\n    hp->hotplug_identifier = hp_id;\n\n\n\n    switch (drc_type) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;\n\n        if (hp->hotplug_action == RTAS_LOG_V6_HP_ACTION_ADD) {\n\n            spapr_hotplug_set_signalled(drc);\n\n        }\n\n        break;\n\n    case SPAPR_DR_CONNECTOR_TYPE_LMB:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_MEMORY;\n\n        break;\n\n    case SPAPR_DR_CONNECTOR_TYPE_CPU:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_CPU;\n\n        break;\n\n    default:\n\n        /* we shouldn't be signaling hotplug events for resources\n\n         * that don't support them\n\n         */\n\n        g_assert(false);\n\n        return;\n\n    }\n\n\n\n    if (hp_id == RTAS_LOG_V6_HP_ID_DRC_COUNT) {\n\n        hp->drc.count = cpu_to_be32(drc);\n\n    } else if (hp_id == RTAS_LOG_V6_HP_ID_DRC_INDEX) {\n\n        hp->drc.index = cpu_to_be32(drc);\n\n    }\n\n\n\n    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp, true);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->xics, spapr->check_exception_irq));\n\n}\n", "idx": 12887, "substitutes": {"hp_id": ["hp_controller", "hp___controller", "phy_mid", "hp_type", "phy_controller", "hpttype", "hptcontroller", "hp_mid", "hp___id", "hptmid", "hptid", "hp___mid", "hp___type", "phy_id", "phy_type"], "hp_action": ["hp_type", "rh__id", "rh_action", "hp_data", "rh__action", "hp__type", "rh_id", "rh_data", "hp__id", "hp__data", "rh__data", "rh_type", "rh__type", "hp__action"], "drc_type": ["drs_method", "drs_type", "drcetytype", "drcetytypes", "drc_file", "drs_types", "drcetymethod", "drs_file", "drcetyfile", "drc_types", "drc_method"], "drc": [" drd", "bdrt", " dRC", "bdRC", "hdrc", " drt", "dRC", "hdrd", "bdrc", "hdRC", "drd", "bdrd", "hdrt", "drt"], "spapr": ["spapsr", "spapprar", " spaprar", " spipr", "spaprar", "spappr", " spapR", " spiprs", "spappR", "spapsrs", "spapprs", "spaprs", " spaprs", "spapsR", " spiprar", "spipr", " spipR", "spapsrar", "spapR", "spipR", "spiprar", "spiprs"], "new_hp": ["newtphys", "new2phys", "new2phy", "news_gp", "original0hl", "new___gp", "news_php", "newjphy", "newJph", "old__h", "news_eh", "new_ip", "NEW___phy", "news_hyper", "new_h", "new___rh", "next_html", "newsJph", "newsJeh", "NEW_rh", "new___ph", "NEW___phys", "newpthop", "newJih", "newsJhp", "new0cp", "NEW_phys", "newjrh", "new_gp", "newthp", "newjeh", "old_gp", "newsJgp", "old__hp", "original_ph", "new___hop", "fresh_hyper", "new_eh", "new___phi", "next_ih", "old_phy", "newJgp", "fresh_ip", "newerhyper", "new_hyper", "newJphi", "new0hp", "new__hp", " new_rh", "old_h", "next_hp", "newjphi", "new_html", "new___hp", "new_phy", "NEW_hp", "new___phy", "next___hp", "old__phy", "next___html", "new_hl", "fresh_phys", " new_phi", "newtip", "new0hl", "new___html", "new_cp", "new_ph", "news_ph", "fresh_hop", "newptphys", "old_hp", "newptip", "new___h", "next___phi", "new2rh", "new_phys", "freshpthp", "freshpthop", "news_phy", " new_eh", "new___cp", "new___hl", "freshptphys", "new___phys", "next_phi", "newthop", "newJhp", "newJhtml", "newerphy", "new0ph", "newerhtml", "NEW___hp", "newpthp", "new2hp", "new__phy", "new__h", "original0hp", "newjphys", "NEW_phy", "new_phi", "newjhp", "fresh_hp", "new_php", "new_hop", "original0cp", "new__gp", "newerhp", "fresh_phy", "new_rh", "original0ph", "freshptip", "old__gp", "news_hp", "new___ip", "original_hl", "newJeh", "next___ih", "new_ih", "new___ih", "original_cp", "NEW___rh", "original_hp", "fresh_html"], "hdr": ["Hpar", "ehDR", " hpar", "chrd", "hld", "hild", "hmdr", "khld", "Hiler", "hdrop", "shld", "ehiler", "hDR", "phder", "khDR", " hrs", "hhdr", "chdr", "hendor", "hhDR", "ehdr", " hrd", " hDR", "ohDR", "hiler", "hidr", "hpar", "ohendor", "shDR", "shtr", " hdrop", "htr", "Hder", " hiler", " hheader", "vDR", "ehheader", "hhpar", "hhrs", "phendor", " hld", "shrr", "harp", "Hendor", "oharp", "hrr", "ohder", "Harp", "HDR", "shdr", "thtr", "hirid", "hhdrop", "hmDR", "chrid", "vrs", "vdrop", "thdr", "chld", "thld", " htr", "hrs", "hheader", "Hdr", "hmheader", "hird", "khdr", "phdr", "hhld", " hrr", "ohheader", " hrid", "khheader", "vdr", "ohdr", "shheader", "hrid", "thrr", "phDR", "hrd", "Hld", "Hheader", "hder", "hmarp"], "v6hdr": ["v6harg", "v6Hld", "v6ihld", "v6pharg", "v6vrs", "v6kharp", "v6khDR", "v4Harg", "v4harp", "v6ohr", "v4hld", "v4Hbr", "v6hbr", "v6phdr", "v6ohbr", "v6hDR", "v6hrs", "v6harp", "v6iharg", "v6vder", "v6hld", "v6ihDR", "v6hr", "v6Harp", "v6ihdr", "v6Hder", "v6harc", "v4Harc", "v6hhr", "v6Hdr", "v6hmarp", "v4hdr", "v6hhDR", "v6Hrs", "v4harg", "v6ihrs", "v4Hdr", "v6Harg", "v4hder", "v6ohdr", "v6Hbr", "v6Hr", "v4hr", "v6ohDR", "v4Hr", "v6hmDR", "v4hrs", "v6vdr", "v4hbr", "v6vDR", "v6hder", "v4Hrs", "v6kharc", "v4Harp", "v6phDR", "v4HDR", "v4hDR", "v4Hder", "v6hmdr", "v6HDR", "v6phld", "v4Hld", "v6khdr", "v6Harc", "v6hmarc", "v6ihder", "v6hhdr", "v4harc", "v6hhbr"], "maina": ["minb", "Mainae", "masterp", "mainae", "Mainla", "centralsa", "Mainea", "mana", "Mainca", "manb", "sideA", "masterA", "plainla", "manca", "mainA", "mainla", "plainae", "masterca", " mainsa", " mainA", "Mainb", "plainb", "mainea", "mainsa", "Maina", "mainp", " mainla", "centralA", "minA", "plaina", " mainae", "centrala", "masterea", "MainA", "centralb", "masterb", "sidep", "mina", "mastera", "manea", "minp", "mainca", "sidea", "sideb", "Mainsa"], "mainb": ["minb", "centerab", "mainab", "storea", "Mainb", " mainend", "mainba", "Mainp", "minj", "masterB", "masterend", "mina", "mainB", " mainfb", "Mainw", "mainn", "sideb", "masterp", "centera", "centerb", "masterc", "sidec", "mainend", "mainbe", "MainB", "primaryb", "Maina", " mainB", "masterbe", "masterba", " mainw", "masterb", " mainba", "sidea", "mainw", " mainp", "storeb", "mainfb", " mainc", " mainbe", "storec", " mainj", "centerc", "centerj", "mainp", "centerbe", "storeba", "masterh", "mainh", "sidee", "primaryfb", "Mainbe", " mainh", " mainab", "Mainh", "masterab", "mainc", "masterw", "primaryend", "centere", " maine", "mainj", " mainn", "maine", "mine", "Mainn", "masterfb", "mastera", "mastern"], "hp": ["pkg", "h", "xp", "HP", "jp", "hd", "lp", "hess", "nih", "hap", "dp", "history", "ip", "ips", "prot", "hop", "np", "hz", "physical", "cp", "http", "ps", "dh", "hw", "addr", "p", "wp", "ptr", "gp", "vp", "health", "hs", "tp", "rh", "ih", "hl", "eh", "eth", "html", "hops", "php", "dq", "phi", "phys", "prof", "oh", "phy", "pr", "pt", "pha", "hm", "pp", "ph", "drm", "ht", "chip"]}}
{"project": "qemu", "commit_id": "3393bc105d58e1f4a27d9a8e7062da9cef260cc3", "target": 0, "func": "static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)\n\n{\n\n    USBHubPort *port;\n\n    USBDevice *dev;\n\n    int i, ret;\n\n\n\n    for(i = 0; i < NUM_PORTS; i++) {\n\n        port = &s->ports[i];\n\n        dev = port->port.dev;\n\n        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {\n\n            ret = usb_handle_packet(dev, p);\n\n            if (ret != USB_RET_NODEV) {\n\n                return ret;\n\n            }\n\n        }\n\n    }\n\n    return USB_RET_NODEV;\n\n}\n", "idx": 12894, "substitutes": {"s": ["bs", "h", "fs", "rs", "n", "sb", "sl", "ses", "os", "S", "c", "sv", "ps", "set", "es", "sys", "ls", "gs", "ats", "b", "ports", "js", "sts", "spec", "sp", "services", "j", "sq", "t", "ds", "se", "ts", "is", "v", "qs", "ns", "ss"], "p": ["pkg", "h", "jp", "fp", "pc", "pe", "pa", "c", "cp", "ps", "ap", "wp", "pre", "m", "pb", "pro", "vp", "now", "b", "tp", "P", "pod", "press", "pat", "t", "phy", "pt", "part", "a", "pp", "v", "w", "post"], "port": ["device", "channel", "type", "ve", "address", "pc", "page", "pe", "th", "serv", "component", "point", "server", "peer", "connection", "ip", "tab", "state", "pool", "group", "PORT", "Port", "service", "cp", "ort", "bridge", "ported", "pl", "interface", "bus", "client", "tag", "cam", "host", "socket", "key", "gp", "pro", "handle", "eport", "ports", "buffer", "project", "sp", "unit", "per", "P", "porter", "pod", "public", "driver", "t", "test", "file", "phy", "pt", "pr", "ace", "link", "pi", "policy", "var", "table", "profile"], "dev": ["dn", "home", "device", "d", "ch", "dem", "ve", "av", "priv", "DEV", "app", "nd", "serv", "go", "off", "out", "local", "buf", "gu", "addr", "hw", "ver", "develop", "def", "cam", "ach", "tech", "pro", "desc", "any", "raw", "mem", "md", "pub", "db", "nt", "att", "des", "Dev", "stable", "w", "mobile", "dd", "de", "ev", "ad", "sd", "cho", "window", "iv", "data", "bin", "conn", "normal", "driver", "det", "test", "development", "pad", "val", "v", "be", "obj", "doc", "vo", "build", "rem"], "i": ["qi", " li", "ind", "info", "ai", "ii", "ji", " si", "gi", " di", " ni", "di", "x", "sim", "ij", "ip", "init", " bi", "ti", "li", "I", " j", " I", "si", "ori", " pi", "m", "key", "us", "oi", "ri", "im", "e", "multi", "in", " v", "ims", "index", "iu", "fi", "id", " m", " ii", "it", "g", "j", "uri", "me", "ci", "ie", "xi", "ex", "ic", "ki", "phi", " is", " mi", "ix", " iter", "mi", "pi", "y", "print", "bi", " err", "ini", "ui", " multi", " ti", "f"], "ret": ["rel", "ft", "RET", "elt", "pret", "status", "txt", "out", "re", "reply", "our", "reg", "cat", "Ret", "result", "pas", "def", "not", "arr", "err", "set", "tr", "ne", "flag", "alt", "rev", "nt", "vet", "cert", "plain", "fun", "cont", "it", "res", "red", "back", "str", "rm", "det", "mt", "gt", "try", "ll", "ter", "rets", " Ret", "resp", "rt", "lit", "print", "val", "reset", "rem"]}}
{"project": "qemu", "commit_id": "c6d2283068026035a6468aae9dcde953bd7521ac", "target": 1, "func": "BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,\n\n                                  QEMUIOVector *qiov, int nb_sectors,\n\n                                  BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bs->read_only)\n\n        return NULL;\n\n    if (bdrv_check_request(bs, sector_num, nb_sectors))\n\n        return NULL;\n\n\n\n    if (bs->dirty_tracking) {\n\n        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);\n\n    }\n\n\n\n    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,\n\n                               cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\tbs->wr_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 12916, "substitutes": {"bs": ["bos", "fs", "rs", "sb", "aos", "ks", "bc", "blog", "als", "bes", "aus", "hz", "ubis", "bh", "bn", "ps", "bd", "sys", "outs", "pb", "ls", "vs", "hs", "ms", "gs", "b", "ats", "its", "js", "lbs", "locks", "sts", "bb", "bis", "bas", "boxes", "cks", "css", "acs", "bps", "BS", "ds", "ubs", "pse", "bp", "bsp", "cs", "ts", "bits", "ics", "base", "qs", "bm", "obs", "ns", "ss"], "sector_num": ["ser_num", " sector_mon", "sectoretypos", "sector_number", "sectoretycon", "ser_number", "sector_con", "ector_no", "sectorablenum", "sectorableno", "section_pos", "sectorablemon", "sectoretynum", " sector_sym", "section_num", "sectoritypos", "sectoretynumber", "ector_number", "sector_sym", "ector_num", "sector_Num", "ser_sym", "sectoritynum", "sectorablesym", "sectoretyindex", "sector_mon", "ector_Num", "ser_con", "sector_no", "sectoritynumber", "sector_pos", "sectoretysym", "sector_index", " sector_no", "section_index", "sectorityindex", "section_number"], "qiov": [" qiour", "qiol", "sqiev", "viov", "Qiev", " qiol", " qiop", "Qiov", " qiev", "sqiour", "sqiov", "Qveh", "Qiop", "qiop", "Qiour", "qiour", "Qiol", "viour", "qiev", "sqiop", "vveh", " qveh", "qveh", "viol"], "nb_sectors": ["nb_seectors", "nb_asevers", "nb_veors", "nb_vectors", "nb_seeors", "nb_pevers", "nb_spevers", "nb_nellers", "nb_segments", "nb_beriers", "nb_aseors", "nb_veories", "nb_vevers", "nb_peors", "nb_sellers", "nb_specs", "nb_peories", "nb_seriers", "nb_vellers", "nb_pecs", "nb_aseories", "nb_negments", "nb_asectors", "nb_seories", "nb_pegments", "nb_secs", "nb_spectors", "nb_vecs", "nb_speors", "nb_vegments", "nb_seevers", "nb_nectors", "nb_speriers", "nb_necs", "nb_pectors", "nb_seecs", "nb_pellers", "nb_severs", "nb_beors", "nb_spellers", "nb_bevers", "nb_seors", "nb_bectors"], "cb": ["bt", "bc", "ck", "bf", "unc", "rb", "ctrl", "conv", "lb", "c", "cp", "pb", "cfg", "callback", "tc", "b", "db", "cc", "obb", "eb", "rc", "fn", "ctx", "bb", "cv", "fun", "job", "cf", "ctr", "func", "nb", "bp", "nc", "fc", "cmd", "ob", "CB", "cd", "Callback", "gb"], "opaque": [" opserver", "OPpty", "opppty", " opatile", "oppty", "porque", "OPaque", "oppaque", "porserver", "oppatile", "compula", "poratile", "Opserver", "poraque", "opserver", "Opatile", "opque", "OPatile", "opatile", "OPula", " opque", "oppula", "compaque", "Opque", "opula", "Opaque", "comppty", "compatile"], "drv": ["drmvr", " drm", "crf", "derv", "drvs", "drf", "crvr", "drw", " drf", "derw", "srvr", " drva", "drvr", "srve", "vrvc", "crv", "srvs", "vrV", "drva", "drmV", "srw", "derva", "drmw", "derm", "vrvr", " drvs", "crvs", "vrv", " drvr", " drV", "drive", "drmm", "srf", "srv", " drvc", "drV", "drvc", "drif", "drmvc", "drmv", "drve", " drve", "drmva", "drm", "driw", "driv", " drw"], "ret": ["usr", "ft", "ref", "jp", "RET", "elt", "lt", "tmp", "last", "status", "success", "txt", "temp", "out", "re", "reg", "Ret", "result", "addr", "pas", " RET", "def", "arr", "err", "tr", "nil", "leg", "flag", "alt", "rev", "nt", "cert", "final", "real", "len", "gc", "cont", "res", "red", "back", "rm", "bool", "mt", "det", "gt", "t", "report", "ll", "ter", "rets", "verified", " Ret", "resp", "rt", "val", "print", "lit", "obj", "got", "reset", "backed", "rem"], "wr_ops": ["write_outs", "write_times", "write_ops", "write_bytes", "wr_outs", "wr_times", "wr_bytes"]}}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_dct_init_x86(DCTContext *s)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_SSE(cpu_flags))\n\n        s->dct32 = ff_dct32_float_sse;\n\n    if (EXTERNAL_SSE2(cpu_flags))\n\n        s->dct32 = ff_dct32_float_sse2;\n\n    if (EXTERNAL_AVX(cpu_flags))\n\n        s->dct32 = ff_dct32_float_avx;\n\n}\n", "idx": 12927, "substitutes": {"s": ["bs", "fs", "rs", "sb", "settings", "ops", "S", "os", "als", "sv", "c", "ps", "ss", "conf", "sys", "r", "an", "set", "ls", "hs", "aws", "ms", "gs", "sac", "ats", "its", "js", "ims", "sq", "sets", "ares", "ds", "cs", "ts", "sc", "is", "ins", "qs", "ns", "sts"]}}
{"project": "FFmpeg", "commit_id": "5ecabd3c54b7c802522dc338838c9a4c2dc42948", "target": 1, "func": "static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,\n\n                             GetByteContext *gb)\n\n{\n\n    unsigned char rle_code;\n\n    unsigned char extra_byte, odd_pixel;\n\n    unsigned char stream_byte;\n\n    unsigned int pixel_ptr = 0;\n\n    int row_dec = pic->linesize[0];\n\n    int row_ptr = (avctx->height - 1) * row_dec;\n\n    int frame_size = row_dec * avctx->height;\n\n    int i;\n\n\n\n    while (row_ptr >= 0) {\n\n        if (bytestream2_get_bytes_left(gb) <= 0) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"MS RLE: bytestream overrun, %d rows left\\n\",\n\n                   row_ptr);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        rle_code = stream_byte = bytestream2_get_byteu(gb);\n\n        if (rle_code == 0) {\n\n            /* fetch the next byte to see how to handle escape code */\n\n            stream_byte = bytestream2_get_byte(gb);\n\n            if (stream_byte == 0) {\n\n                /* line is done, goto the next one */\n\n                row_ptr -= row_dec;\n\n                pixel_ptr = 0;\n\n            } else if (stream_byte == 1) {\n\n                /* decode is done */\n\n                return 0;\n\n            } else if (stream_byte == 2) {\n\n                /* reposition frame decode coordinates */\n\n                stream_byte = bytestream2_get_byte(gb);\n\n                pixel_ptr += stream_byte;\n\n                stream_byte = bytestream2_get_byte(gb);\n\n                row_ptr -= stream_byte * row_dec;\n\n            } else {\n\n                // copy pixels from encoded stream\n\n                odd_pixel =  stream_byte & 1;\n\n                rle_code = (stream_byte + 1) / 2;\n\n                extra_byte = rle_code & 0x01;\n\n                if (row_ptr + pixel_ptr + stream_byte > frame_size ||\n\n                    bytestream2_get_bytes_left(gb) < rle_code) {\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"MS RLE: frame/stream ptr just went out of bounds (copy)\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                for (i = 0; i < rle_code; i++) {\n\n                    if (pixel_ptr >= avctx->width)\n\n                        break;\n\n                    stream_byte = bytestream2_get_byteu(gb);\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n\n                    pixel_ptr++;\n\n                    if (i + 1 == rle_code && odd_pixel)\n\n                        break;\n\n                    if (pixel_ptr >= avctx->width)\n\n                        break;\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n\n                    pixel_ptr++;\n\n                }\n\n\n\n                // if the RLE code is odd, skip a byte in the stream\n\n                if (extra_byte)\n\n                    bytestream2_skip(gb, 1);\n\n            }\n\n        } else {\n\n            // decode a run of data\n\n            if (row_ptr + pixel_ptr + stream_byte > frame_size) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"MS RLE: frame ptr just went out of bounds (run)\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            stream_byte = bytestream2_get_byte(gb);\n\n            for (i = 0; i < rle_code; i++) {\n\n                if (pixel_ptr >= avctx->width)\n\n                    break;\n\n                if ((i & 1) == 0)\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n\n                else\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n\n                pixel_ptr++;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* one last sanity check on the way out */\n\n    if (bytestream2_get_bytes_left(gb)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"MS RLE: ended frame decode with %d bytes left over\\n\",\n\n               bytestream2_get_bytes_left(gb));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12940, "substitutes": {"avctx": ["averjac", "avercontext", " avcmd", "ajctx", "avreq", "avesys", "ravcmp", "avercpp", " avcmp", "awcpp", "AVcontext", "AVcam", "avtx", "AVctx", "avcontext", "avcmd", "avercmd", "awreq", "avfunc", " avcontext", "averctx", " avctl", "avctl", "avcmp", "avcpp", " avtx", "svctx", "avejac", "avectx", "vacontext", "avertx", "ravcontext", "vafunc", "vacmp", "awctx", "ajcpp", "AVtx", "ajreq", "ajctl", "avcam", "awjac", "avsys", " avcam", "vactx", "ravfunc", "avercam", "svcontext", "svctl", "aversys", "ajjac", "ajsys", "ajtx", " avfunc", "averreq", "svcmd", "avereq", "ajcontext", "avjac", "svtx", "ravctx"], "pic": ["py", "jp", "jpg", "iac", "pc", "pol", "photo", "png", "pa", "px", "np", "cp", "ps", "media", "picture", "pl", "p", "pict", "pin", "cam", "Pic", "img", "jac", "sci", "Picture", "pg", "ctx", "pdf", "sp", "gc", "g", "photos", "proc", "ic", "piece", "phys", "fc", "pt", "lib", "pan", "pi", "peg", "doc", "icc"], "gb": ["gd", "uf", "GB", "jpg", "sg", "sb", "bytes", "pc", "hub", "bc", "gm", "bf", "rb", "gz", "gg", "px", "ubis", "cb", "sys", "yg", "vg", "uv", "tg", "cgi", "pb", "cfg", "mb", "storage", "gs", "fb", "gam", "db", "pg", "eb", "ctx", "gin", "gc", "cv", "eg", "csv", "rg", "g", "html", "erb", "gnu", "hog", "gy", "gt", "nb", "tm", "lib", " rgb", "phy", "gif", "kb", "wb", "bg", "gram", "vm", "Gb"], "rle_code": ["rlee_byte", "rler_mode", "rle2num", "rLE_num", "rle__codes", "rLE_coe", "rLE_no", "rlePcode", "rle8codes", "rle_mode", "rle2code", "rle8coe", "rle2mode", "rLE_codes", "rler2error", "rle_no", "rLE_Code", "rle_channel", "rlee_code", "rle_Code", "rle_bit", "rlee_channel", "rle_page", "rle_create", "rlePmessage", "rle_cod", "rle_message", "rLE_length", "rler2mode", "rle8page", "rle_text", "rler2co", "rle_codes", "rle__text", "rLE_create", "rLE_page", "rle2error", "rlePcoe", "rLE_byte", "rle8code", "rle_length", "rle2co", "rLE_error", "rler_error", "rLE_message", "rle_co", "rle_coe", "rle2length", "rlePno", "rle2byte", "rlee_cod", "rler2code", "rler_code", "rle_num", "rle__code", "rle__bit", "rle_byte", "rler_co", "rle_error", "rLE_code"], "extra_byte": ["extra___bytes", "extra_bytes", "extra___byte", " extra_char", "extra_word", " extra_bit", "extra___word", "extra_char", " extra_word", "extra___char", "extra___field", "extra_bit", "extra_field", " extra_field", " extra_bytes", "extra___bit"], "odd_pixel": ["odd___pixel", "odd_picture", "odd67pixel", "odd_sample", " odd_channel", "odd___image", " odd_picture", "odd___picture", " odd_image", "odd_image", "even_sample", "odd_channel", "odd67channel", "odd67sample", "odd___channel", "even_pixel", "even_channel"], "stream_byte": ["entityletbyte", "stream5result", "entity_byte", "streamlymem", "stream_note", "emptyjno", "strJchar", "stream___byte", "http_relation", " stream_pixel", "pipe_buffer", "publiclybyte", "REAM_buffer", "streamsbyte", "pipeletbuffer", "row_bit", "streamtmem", "streamingbyte", "stream_mem", "streamJbytes", "iteratoritybyte", "streamletby", "empty_code", "stream_no", "streamjcode", "browserstwo", "browsersbyte", "streamingtwo", "stream_second", "entity_by", "streamletelement", "stream___member", "stream5second", "stream_fine", "streamjno", "stream_result", "strJbytes", "streamstwo", "streamitybyte", "stream5fine", "streamtbyte", "stream_pixel", "stream_link", "streamitystatus", "streamtindex", "stream_pair", "stream_block", "publiclyrule", "pipeletbyte", "streamitymember", "entityletbinary", "pipe_byte", "stream___name", "browser_result", "pipe_element", " stream_string", "streamptrelation", "http_fine", "stream___bytes", " stream_char", "stream5element", "public_rule", "iterator_status", "stream_bit", "browser_two", " stream_pair", "streamlyrule", "str_ptr", "streamJchar", "streamtrule", "streamsresult", "pipe_link", "iteratoritymember", "stream_name", "http_byte", "stream___code", "streamletbuffer", "REAM_byte", "streamlybyte", "stream_by", " stream_bytes", "streamjbyte", "streamitycode", "stream_char", "streamtbinary", "stream5byte", "streamlyindex", "streamptsecond", "publiclymem", "iterator_member", "browsersresult", "streamingelement", "streamJptr", "entity_binary", "str_char", "browserselement", "streamsmember", "stream___status", "browser_byte", "entityletby", "stream_bytes", "stream_buffer", "iteratoritycode", "streamletbyte", " stream_name", "public_index", "stream_num", "streamselement", "browser_element", "stream_code", " stream_buffer", "http_second", "iterator_byte", "row_byte", "streamletlink", "stream_relation", "stream___char", "strJptr", "stream_two", "streamtnote", "row_bytes", "pipeletelement", "streamletnote", "streamingresult", "streamtby", "str_bytes", "entityletnote", "stream_member", "empty_no", "iteratoritystatus", "public_byte", "row_buffer", "streamJbyte", " stream_block", "stream_index", "str_byte", "emptyjcode", "empty_byte", "emptyjbyte", "stream_element", "public_mem", "pipeletlink", "stream_string", "stream_status", " stream_no", "entity_note", "streamsstatus", "stream_binary", "REAM_bit", "publiclyindex", "streamptfine", "strJbyte", "streamletbinary", "REAM_element", "stream5relation", "streamptbyte", "stream_ptr", "streamscode", "stream5two", "row_num", "row_note", "stream_rule", "iterator_code"], "i": ["qi", "ind", "l", "ai", "ii", " si", "n", "gi", " di", "k", " e", " ni", "di", "sim", "cli", "x", "init", "c", "u", " bi", "ti", "li", "hi", "I", "p", " j", "ei", "r", "si", "batch", " pi", "oi", "m", "us", "im", "e", "multi", "in", "b", "uli", "index", "iu", "id", " ii", "it", "g", "j", "me", "ci", "xi", "ic", "ki", "t", "phi", "zi", " mi", "ix", "mi", "o", "a", "pi", "v", "f", "bi", "ini", "ui", " multi", " ti"], "pixel_ptr": ["pixel_dr", "row_addr", "component_pr", "pixel64addr", "pixel64ptr", " pixel_src", "component_ptr", "client_addr", "pixel2pointers", "row_pointer", "pixel_pr", "pixel_inter", "pixel2src", "client64pointer", "pixel____perm", "pixel____addr", "pixel2pointer", "pixel_perm", "pixelptpend", "component_Ptr", "pixel_loc", "row_Ptr", "pixel64pointer", "pixel____pointer", "pixel__Ptr", "client_dr", " pixel_pointers", "client64addr", "pixel_pointer", "client64dr", "pixel__ptr", " pixel_rect", "client_pointer", "pixel_addr", "row_address", "row_loc", "row_perm", "pixel_src", "pixelptrect", "pixelptPtr", "pixel_pend", "pixel__inter", "pixel_pointers", "component_inter", "pixelptptr", " pixel_pointer", "client64ptr", "pixel_rect", " pixel_pend", "pixel64dr", "pixel_Ptr", "pixel__pr", "pixel_address", "pixel____ptr", "client_ptr", " pixel_Ptr", "row_ptr", "pixel2ptr"]}}
{"project": "qemu", "commit_id": "068593deea6cc61b06243a33c7fcfadb1650b654", "target": 1, "func": "void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n\n{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    } else {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if (dest != (src + 1)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version crossing pages with byte accesses */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n", "idx": 12946, "substitutes": {"env": ["dn", "context", "h", "pkg", "worker", "info", "con", "outer", "ener", "end", "dt", "server", "EN", "En", "buf", "him", "nv", "cb", "er", "enter", "environment", "org", "err", "et", "vs", "ner", "desc", "vp", "viron", "code", "e", "window", "dev", "ah", "ami", "shell", "vt", "ctx", "eh", "erd", "estate", "cv", "ev", "erb", "ew", "manager", "msg", "en", "conn", "gate", "ager", "gear", "param", "ef", "ec", "rc", "esc", "attr", "vv", "ter", "net", "Environment", "config", "cmd", "v", "obj", "w", "vm"], "l": ["h", "dl", "d", "lp", "ly", "n", "tl", "level", "sl", "k", "lc", "x", "local", "lb", "c", "lin", "ul", "li", "loc", "p", "pl", "vl", "r", "list", "kl", "m", "s", "ls", " L", "lo", "ln", "b", "shell", "len", "hl", "al", "loop", "g", "size", "j", "line", "L", "lock", "el", "fl", "nl", "layer", "t", "ll", "source", "lang", "lit", "ld", "v", "le", "y", "all", "length", "lr", "w"], "dest": ["orig", "route", "success", "cat", "addr", "np", "resource", "cp", "tif", "r", "ptr", "pos", "mem", "sur", "dep", "it", "usr", "d", "prop", "end", "std", "tmp", "temp", "next", "pas", "del", "tr", "pro", "site", "target", "sp", "to", "comb", "coord", "t", "source", "rel", "parent", "trans", "nw", "win", "x", "Dest", "dc", "st", "loc", "pl", "sys", "err", "origin", "nt", "home", " dst", "gen", "nom", "decl", "index", "gate", "proc", "gt", "deg", "master", "est", "dist", "them", "th", "priv", "null", "go", "out", "result", "p", "desc", "port", "dev", "iter", "remote", "spec", "test", "lit", "v", "wb", "rest", "obj", "w", "dat", "output"], "src": ["sn", "tn", "orig", "conv", "cli", "gz", "addr", "np", "r", "scan", "from", "ptr", "nil", "sur", "sec", "url", "filename", "sc", "ins", "sync", "usr", "std", "sb", "inc", "tmp", "txt", "set", "start", "img", "site", "target", "rc", "sp", "iv", "sr", "source", "RC", "rel", "ind", "rs", "pri", "sl", "trans", "ident", "rb", "via", "SOURCE", "st", "loc", "sub", "sys", "err", "syn", "ser", "origin", "in", "sq", "supp", "proc", "typ", "rt", "dist", "comp", "th", "cur", "input", "sel", "s", "desc", "iter", "slice", "spec", "inner", "cont", "str", "rl", "inst", "ctr", "attr", "sort", "lit", "rest"], "i": ["qi", "iq", "ind", "ai", "ii", "ji", "gi", "status", "di", "x", "sim", "cli", "ij", "ip", "init", "wi", "c", "q", "ti", "u", "li", "hi", "\u0438", "I", "p", " j", " I", "r", "si", "ei", "m", "ri", "b", "im", "multi", "in", "ami", "iter", "index", "iu", "id", " ii", "it", "me", "j", "ci", "ie", "xi", "ic", "ki", "t", " x", "phi", "zi", "ix", "MI", "mi", "is", "pi", "v", "y", "bi", "ini", "ui", "w", "f"]}}
{"project": "qemu", "commit_id": "0d2cd785ef1282b14687f9f7f4b63ae4a2430be3", "target": 1, "func": "static void test_properties(const char *path, bool recurse)\n\n{\n\n    char *child_path;\n\n    QDict *response, *tuple;\n\n    QList *list;\n\n    QListEntry *entry;\n\n\n\n    g_test_message(\"Obtaining properties of %s\", path);\n\n    response = qmp(\"{ 'execute': 'qom-list',\"\n\n                   \"  'arguments': { 'path': %s } }\", path);\n\n    g_assert(response);\n\n\n\n    if (!recurse) {\n\n        return;\n\n    }\n\n\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    list = qobject_to_qlist(qdict_get(response, \"return\"));\n\n    QLIST_FOREACH_ENTRY(list, entry) {\n\n        tuple = qobject_to_qdict(qlist_entry_obj(entry));\n\n        bool is_child = strstart(qdict_get_str(tuple, \"type\"), \"child<\", NULL);\n\n        bool is_link = strstart(qdict_get_str(tuple, \"type\"), \"link<\", NULL);\n\n\n\n        if (is_child || is_link) {\n\n            child_path = g_strdup_printf(\"%s/%s\",\n\n                                         path, qdict_get_str(tuple, \"name\"));\n\n            test_properties(child_path, is_child);\n\n            g_free(child_path);\n\n        } else {\n\n            const char *prop = qdict_get_str(tuple, \"name\");\n\n            g_test_message(\"Testing property %s.%s\", path, prop);\n\n            response = qmp(\"{ 'execute': 'qom-get',\"\n\n                           \"  'arguments': { 'path': %s,\"\n\n                           \"                 'property': %s } }\",\n\n                           path, prop);\n\n            /* qom-get may fail but should not, e.g., segfault. */\n\n            g_assert(response);\n\n        }\n\n    }\n\n}\n", "idx": 12949, "substitutes": {"path": ["pkg", "context", "kind", "ref", "prefix", "type", "package", "PATH", "th", "route", "history", "format", "node", "value", "full", "resource", "patch", "root", "tree", "message", "p", "property", "alias", "pred", "host", "key", "binding", "name", "target", "trace", "method", "chain", "pattern", "pointer", "Path", "request", "index", "dir", "url", "str", "module", "transform", "item", "data", "pat", "template", "test", "self", "pr", "mount", "link", "cmd", "print", "text", "policy", "ath", "term", "call"], "recurse": ["recurry", "respurry", "Recurses", "Recurse", "cursion", "recursion", "recursed", "Recursion", " recurry", "curse", " recursed", "recursive", " recursive", "discurse", "discurry", "discursed", "respurse", "respursed", " recursion", "recurses", "cursive", " recurses", "Recursive", "curses", "respursion", "discursion"], "child_path": ["childingpath", "childingpart", "child_link", "childlypath", "childfulstream", "child___Path", "child___path", "friendfulath", "friendfulstream", "child_ath", "child_url", "childjlink", "parent_column", "childlyclean", "childrenath", "child___column", "child2path", "child___key", "friendfulpath", "childfulpart", "childfulath", "childingclean", "leaf_url", "parent_path", "child_Path", "child_column", "child_stream", "friend_ath", "child_part", "child_key", "childjpath", "leaf_path", "leaf_part", "childrenpart", "childingurl", "child_dir", "leaf_clean", "childjdir", "parent_dir", "childrenstream", "friend_path", "child2Path", "child2dir", "childfulpath", "parent_Path", "friend_part", "childrenpath", "child_clean", "child2link", "childlyurl", "friendfulpart", "friend_stream", "parent_key", "childjPath", "parent_link", "childlypart"], "response": ["context", "view", "info", "version", "child", "render", "send", "image", "present", "page", "success", "server", "json", "answer", "summary", "connection", "next", "reply", "sequence", "value", "frame", "error", "result", "service", "os", "document", "respons", "tree", "message", "def", "yes", "xml", "pos", "application", "trace", "profile", "array", "chain", "block", "reference", "remote", "request", "pointer", "collection", "object", "respond", "res", "line", "description", "given", "data", "Response", "vector", "found", "python", "report", "body", "resp", "function", "nexus", "relation", "example", "output", "roads", "onse"], "tuple": ["tue", "tskeleton", "atrick", "attensor", "mutuple", "mutensor", " tples", "touched", "tsup", "tdkeleton", "tested", " tkeleton", "attouch", "tmuple", "atples", "nrie", "nurtle", "tsple", "tsuple", " tple", "ttrie", "tenples", " tilde", " try", "tilde", " tue", "mutouched", "tsrix", "attrie", "tples", "tmensor", "atilde", "ttry", "try", "tkeleton", "ttensor", "tenrick", "atuple", "tensor", "tenuple", "nouch", "tsue", "tturtle", " tensor", "enturtle", " trix", "attuple", "entuple", "trie", "tdple", " touched", "mutested", " turtle", " trie", "entouch", "nuple", "tenilde", "ttrix", "tup", "tsurtle", "ttue", "tple", "attry", "ttuple", "trix", "trick", "turtle", " trick", "atturtle", "tduple", "tmouched", "tmested", " tup", " tested", "tdup", "touch", "entrie"], "list": ["l", "dict", "parent", "n", "map", "join", "level", "null", "json", "lat", "local", "sequence", "out", "pool", "result", "ist", "document", "st", "li", "tree", "xml", "p", "set", "batch", "e", "array", "none", "LIST", "collection", "load", "range", "layout", "limit", "L", "joined", "data", "flat", "t", "part", "source", "listed", "all", "library", "table", "v", "List", "lists"], "entry": ["context", "cue", "entity", "search", "info", "child", "image", "word", "result", "def", "add", "key", "cell", "ent", "ry", "element", "e", "match", "nt", "member", "instance", "attribute", "index", "import", "Entry", "it", "record", "line", "see", "RY", "item", "row", "data", "ie", "ex", "inter", "se", "ary", "link", "table", "obj", "query", "pair"], "prop": ["pkg", "rel", "info", "rep", "comp", "priv", "tmp", "cmp", "col", "pid", "ps", "pred", "property", "def", "p", "key", "pro", "desc", "pos", "op", "str", "feat", "item", "msg", "data", "proc", "bug", "attr", "arg", "test", " props", "properties", "acc", "pr", "Prop", "val", "cmd", "obj", "term", " Prop"]}}
{"project": "FFmpeg", "commit_id": "482ee63641f4fa50f017538af384aadbceee7a18", "target": 1, "func": "static int thp_read_header(AVFormatContext *s,\n\n                           AVFormatParameters *ap)\n\n{\n\n    ThpDemuxContext *thp = s->priv_data;\n\n    AVStream *st;\n\n    AVIOContext *pb = s->pb;\n\n    int i;\n\n\n\n    /* Read the file header.  */\n\n                           avio_rb32(pb); /* Skip Magic.  */\n\n    thp->version         = avio_rb32(pb);\n\n\n\n                           avio_rb32(pb); /* Max buf size.  */\n\n                           avio_rb32(pb); /* Max samples.  */\n\n\n\n    thp->fps             = av_d2q(av_int2float(avio_rb32(pb)), INT_MAX);\n\n    thp->framecnt        = avio_rb32(pb);\n\n    thp->first_framesz   = avio_rb32(pb);\n\n                           avio_rb32(pb); /* Data size.  */\n\n\n\n    thp->compoff         = avio_rb32(pb);\n\n                           avio_rb32(pb); /* offsetDataOffset.  */\n\n    thp->first_frame     = avio_rb32(pb);\n\n    thp->last_frame      = avio_rb32(pb);\n\n\n\n    thp->next_framesz    = thp->first_framesz;\n\n    thp->next_frame      = thp->first_frame;\n\n\n\n    /* Read the component structure.  */\n\n    avio_seek (pb, thp->compoff, SEEK_SET);\n\n    thp->compcount       = avio_rb32(pb);\n\n\n\n    /* Read the list of component types.  */\n\n    avio_read(pb, thp->components, 16);\n\n\n\n    for (i = 0; i < thp->compcount; i++) {\n\n        if (thp->components[i] == 0) {\n\n            if (thp->vst != 0)\n\n                break;\n\n\n\n            /* Video component.  */\n\n            st = avformat_new_stream(s, NULL);\n\n            if (!st)\n\n                return AVERROR(ENOMEM);\n\n\n\n            /* The denominator and numerator are switched because 1/fps\n\n               is required.  */\n\n            avpriv_set_pts_info(st, 64, thp->fps.den, thp->fps.num);\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            st->codec->codec_id = CODEC_ID_THP;\n\n            st->codec->codec_tag = 0;  /* no fourcc */\n\n            st->codec->width = avio_rb32(pb);\n\n            st->codec->height = avio_rb32(pb);\n\n            st->codec->sample_rate = av_q2d(thp->fps);\n\n            thp->vst = st;\n\n            thp->video_stream_index = st->index;\n\n\n\n            if (thp->version == 0x11000)\n\n                avio_rb32(pb); /* Unknown.  */\n\n        } else if (thp->components[i] == 1) {\n\n            if (thp->has_audio != 0)\n\n                break;\n\n\n\n            /* Audio component.  */\n\n            st = avformat_new_stream(s, NULL);\n\n            if (!st)\n\n                return AVERROR(ENOMEM);\n\n\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            st->codec->codec_id = CODEC_ID_ADPCM_THP;\n\n            st->codec->codec_tag = 0;  /* no fourcc */\n\n            st->codec->channels    = avio_rb32(pb); /* numChannels.  */\n\n            st->codec->sample_rate = avio_rb32(pb); /* Frequency.  */\n\n\n\n            avpriv_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n\n\n            thp->audio_stream_index = st->index;\n\n            thp->has_audio = 1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12951, "substitutes": {"s": ["bs", "h", "fs", "rs", "sb", "n", "S", "c", "sv", "ps", "p", "sys", "r", "m", "ls", "hs", "aws", "ms", "gs", "ats", "e", "b", "js", "in", "sa", "sts", "sp", "g", "t", "ds", "cs", "ts", "sc", "is", "a", "v", "f", "ins", "stats", "ns", "ss"], "ap": ["am", "map", "pe", "pa", "ip", " p", " cp", "ar", "cp", "ps", " sap", "pl", "ape", "att", "mp", "tap", "al", "sp", "op", "aps", "cap", "amp", "ep", "pp", "ac", " af", " sp", " mp"], "thp": ["ithping", "thanp", "ithcp", "rahp", " thping", "trcp", "THpkg", " thl", "therps", " thsp", "othf", "headl", "thpr", "heartpid", "ithport", "ithg", "therf", "althP", "thapm", "thaping", "thf", "ethop", "ithm", "THp", "rahpp", "khl", "headpid", "terpi", "trpre", "thpe", "thapkg", "footp", " thpa", "ithpad", "thl", "othpm", "THg", "thcp", "authp", "ethpr", "THop", "htnp", "therP", "thaps", "therpid", "thapad", "thasp", "khtip", "thm", "authpp", "thtip", "othlp", "terl", "thpt", "thsp", "ethpad", "ethm", "hearttip", "ithpid", "thaop", "thpp", "htp", "rahnp", "othpp", "ttp", " thm", " thps", "thapr", "footport", "tercp", "therlp", "ethpi", "headp", "thps", "htping", "althm", "footpp", "htpa", "handp", "terps", " thP", " thg", "thapa", "thv", "othping", "othm", "ethcp", "authps", "thaP", " thpre", "ithf", "ethpre", "ithpm", "khpi", "terpp", "trg", "handps", "ithp", "ethpm", " thpe", "ithnp", "footop", "thpa", "thalp", "ethp", "hrpa", "ethlp", "thnp", "ithP", "ithv", "thpi", "trp", "ethpkg", "ithop", "authpid", " thpi", "althp", "thg", "ethpp", "ttpi", " thcp", "thpre", "thpad", "thpid", "therping", "othp", "thapt", "khpp", "ethP", "thop", "headpp", "hrp", "ithpr", "ithl", "htop", "thP", "ithlp", "rahcp", "thape", " thnp", "althnp", "othpa", "htv", "othport", "ethl", "othnp", "ethnp", "thpm", "othcp", "therpa", "othop", "ethps", "handpa", "ttpid", "htpm", "othpt", "ethg", "heartp", "ithpp", "thport", "ithpre", "thpkg", "khp", " thlp", "ethpa", "thap", "handpp", "ethping", "therp", " thpt", "tttip", "hrpe", "terp", "heartpi", "thapre", "ithps", "khpid", "therpp", "thacp", "hrsp", "terpa", "thag", "thping", "othP", "tham", "htm", "othv", "thlp", "therpm"], "st": ["ST", "h", "must", "usr", "ft", "sn", "ut", "std", "stop", "utt", "th", "St", "art", "nd", "bt", "stack", "tmp", "z", "etc", "ast", "ist", "src", "ste", "ost", "set", "ust", "start", "et", "mont", "nt", "no", "sp", "sts", "stable", "cont", "it", "str", "sh", "sw", "fr", "stage", "cl", "ct", "mt", "sta", "inst", "t", "sth", "tt", "net", "pt", "sc", "stru", "rt", "put", "stat", "rest", "first", "spect", "obj", "td", "stream", "irst", "est"], "pb": ["pkg", "conv", "tk", "bj", "pool", "cmp", "np", "cp", "cb", "wp", "fb", "pause", "pg", "tp", "cv", "PB", "snap", "pt", "pr", "ob", "emb", "td", "vm", "gb", "uf", "py", "sb", "tmp", "dp", "txt", "peer", "pid", "tg", "vp", "mb", "vt", "bb", "gc", "cod", "nb", "tm", "bp", "resp", "ab", "stab", "jp", "req", "asm", "pc", "rb", "pa", "buf", "tab", "pl", "mp", "amp", "proc", "mt", "typ", "bot", "pp", "fp", "lp", "rpm", "lb", "conf", "p", "gp", "buff", "eb", "db", "ctx", "um", "erb", "func", "span", "wb", "pm"], "i": ["qi", "ind", "info", "ai", "ii", "ji", " si", "gi", " di", "status", " ni", "di", "x", "sim", "cli", "ip", " p", "u", " bi", "ti", "li", "hi", "\u0438", "I", "p", " j", " I", "si", "ei", "m", " pi", "ri", "name", "im", "multi", "in", " index", "ims", "index", "iu", " m", " ii", "it", "g", "me", "j", "ci", " count", "xi", "ex", "ic", " my", "ki", " x", "zi", " mi", "ix", " iter", "mi", "is", "pi", "y", "bi", " err", "ini", "ui", " multi", " ti", " pos"]}}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "static int rdma_add_block(RDMAContext *rdma, const char *block_name,\n\n                         void *host_addr,\n\n                         ram_addr_t block_offset, uint64_t length)\n\n{\n\n    RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n    RDMALocalBlock *block;\n\n    RDMALocalBlock *old = local->block;\n\n\n\n    local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));\n\n\n\n    if (local->nb_blocks) {\n\n        int x;\n\n\n\n        if (rdma->blockmap) {\n\n            for (x = 0; x < local->nb_blocks; x++) {\n\n                g_hash_table_remove(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset);\n\n                g_hash_table_insert(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset,\n\n                                    &local->block[x]);\n\n            }\n\n        }\n\n        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);\n\n        g_free(old);\n\n    }\n\n\n\n    block = &local->block[local->nb_blocks];\n\n\n\n    block->block_name = g_strdup(block_name);\n\n    block->local_host_addr = host_addr;\n\n    block->offset = block_offset;\n\n    block->length = length;\n\n    block->index = local->nb_blocks;\n\n    block->src_index = ~0U; /* Filled in by the receipt of the block list */\n\n    block->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;\n\n    block->transit_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);\n\n    block->unregister_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);\n\n    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));\n\n\n\n    block->is_ram_block = local->init ? false : true;\n\n\n\n    if (rdma->blockmap) {\n\n        g_hash_table_insert(rdma->blockmap, (void *) block_offset, block);\n\n    }\n\n\n\n    trace_rdma_add_block(block_name, local->nb_blocks,\n\n                         (uintptr_t) block->local_host_addr,\n\n                         block->offset, block->length,\n\n                         (uintptr_t) (block->local_host_addr + block->length),\n\n                         BITS_TO_LONGS(block->nb_chunks) *\n\n                             sizeof(unsigned long) * 8,\n\n                         block->nb_chunks);\n\n\n\n    local->nb_blocks++;\n\n\n\n    return 0;\n\n}\n", "idx": 12968, "substitutes": {"rdma": ["drmo", "ridsm", "drma", "rtmar", "rtma", "ardma", "ridmar", "rrmo", "rnm", "rodama", "rdmar", "rdmm", "rodmar", "rownama", "drmma", "rdda", "rodda", "redma", "ridma", "ardmar", "rdmon", "rama", "rdama", "rdca", "rtmm", "rtsm", "rdsm", "rrmm", "rnmo", "rda", "rwma", "rtmc", "drca", "rownca", "rwmar", "rtmac", "redpa", "rrm", "rodma", "ddmar", "rrmc", "rdmma", "ridpa", "rwpa", "rdmac", "rownmma", "ridmm", "rtmma", "drmon", "rdmc", "ddama", "rnmon", "rrmac", "rrmon", "ddma", "redmar", "rwmc", "ddda", "drama", "rdmo", "rtama", "rtca", "rdm", "rdpa", "rmar", "rma", "rownma", "redmm", "drm", "ardmm", "ardsm", "rwmac", "rnma", "rrma", "rwmm"], "block_name": ["isk_name", "iskityname", "buffer_no", "blocklistName", "buffer_number", "buffer_name", "block_Name", "bufferernumber", "block_ident", "lock_ref", "isk_offset", "block_data", "blockername", "blockityoffset", "block_no", "block__name", "isk_data", "blockitydata", "block__number", "lock_Name", "buffererno", "iskityoffset", "blocknameoffset", "block_ref", "blocknameName", "block__Name", "blocklistref", "buffererName", "isk_Name", "iskityName", "lock_ident", "blocklistident", "blocklistname", "blockerno", "blockityName", "blockerName", "lock_name", "blockityname", "buffer_Name", "iskitydata", "blocknamedata", "block__no", "block_number", "blockernumber", "bufferername", "blocknamename"], "host_addr": ["port_offset", "hostdoffset", "host_id", "host_arch", "server_hash", "host_loc", "portdnum", "hostingaddress", "hostdloc", "port_num", "hostockarch", "hostwaddr", "hostenhash", "hostameoffset", " host_address", "hostockaddr", "server_add", "portdoffset", "hostwaddress", "hostameaddr", "host2add", "hostingid", "hostenaddress", "hostdnum", "hostdaddr", "portdloc", "host_address", " host_pos", "portdaddr", "hostingaddr", "hostinghash", "server_addr", "host_hash", "host2addr", "hostwarch", "host_add", "port_loc", " host_arch", "hostamenum", "hostwpos", "host_offset", "host_pos", "hostenaddr", "hostockaddress", "hostenid", "server_address", "server_id", "hostockpos", "hostameloc", "port_addr", "host2address", "host_num"], "block_offset": ["block___address", "block5addr", "block___offset", "lock_delay", "block___pointer", "isk___pointer", "isk_addr", "isk_offset", "isk_address", "isk_pointer", "lock_addr", "block5offset", "block___addr", "isk___offset", "isk___address", "block_pointer", "block_address", "lock_offset", "lock_name", "isk___addr", "block_delay", "block5name", "block5delay", "block_addr"], "length": ["shape", "h", " len", "l", "type", "end", "address", "bytes", "SIZE", "Length", "padding", "history", "sequence", "value", " l", "depth", "ength", "enth", " Length", "available", "message", "position", "capacity", "family", "height", "pieces", "frequency", "ENGTH", "count", "len", "total", "index", "buffer", "size", "load", "limit", "duration", "offset", "description", "lock", "amount", "range", "ob", "form", "location"], "local": ["info", "cache", "l", "unique", "parent", "ard", "present", "save", "null", "tx", "shared", "ion", "external", "small", "one", "full", "state", "specific", "global", "admin", "loc", "def", "this", "store", "list", "ma", "private", "same", "raw", "valid", "where", "name", "common", "initial", "as", "al", "remote", "my", "active", "standard", "instance", "inner", " locally", "localhost", "primary", "pal", "lock", "public", "data", "el", "single", "self", "installed", "file", "part", "link", "master", "all", "base", "table", "val", "lang", "var", "location", "current", "alpha", "Local"], "block": ["device", "BL", "view", "map", "image", "bl", "art", "error", "check", "blocks", "method", "instance", "unit", "record", "pack", "snap", "inv", "Block", "man", "base", "all", "sync", "cache", "ban", "unique", "join", "word", "group", "full", "number", "bridge", "def", "set", "bus", "tag", "client", "position", "zero", "name", "buffer", "commit", "loop", "line", "model", "comment", "single", "file", "mix", "link", "part", "command", "type", "prefix", "version", "condition", "node", "value", "byte", "session", "batch", "key", "field", "book", "no", "volume", "object", "bit", "lock", "data", "unknown", "piece", "plugin", "call", "address", "point", "out", "ip", "global", "new", "p", "list", "raw", "bo", "b", "chain", "box", "none", "window", "remote", "module", "load", "row", "bin", "cl", "self", "table", "scope", "label"], "old": ["own", "low", "before", "lower", "ind", "and", "l", "ref", "ard", "orig", "tmp", "last", "told", "null", "off", "small", "global", "new", "ul", "loc", "pre", "p", "set", " orig", "from", "valid", "same", "Old", "fold", "common", "al", "existing", "inner", "OLD", "at", "back", "after", "lock", "row", "other", "olds", "hard", "original", "used", "test", "older", "ld", "all", "base", "v", "var", "user", "high", "or", "hold", "current", "reset"], "x": ["fx", "i", "ey", "xp", "ax", "dx", "ross", "tx", "xxxx", "xxxxxxxx", "px", "xc", "ext", "xf", " tx", "xt", "check", "batch", "ux", "key", "rx", "xs", "xa", "any", "upload", "xes", "xy", " ax", "index", "w", "inx", "exclusive", " y", "ay", "act", "j", "xxx", "sw", "mx", "xi", "ex", "cross", "ox", "step", "t", " cx", "lex", "X", "ix", " xx", "mix", "wx", "nex", "y", "v", " i", "yx", " dx", "xx"], "nb_blocks": ["nb__blocks", "nb__events", "nb_headers", "nb__items", "nb___images", "num_images", "nb___frames", "num_frames", "num_events", "nb_orders", "unique_blocks", "nb__locks", "NR_block", "nb_checks", "nw_blocks", "nb_plugins", "ni__classes", "ni_items", "unique_items", "uniqueBLblocks", "np_frames", "np_orders", "nb_times", "unique_times", "nb___orders", "nb_classes", "nbBLchecks", "unique_checks", "nbBLtimes", "ni__items", "ni__blocks", "nbBLitems", "nb_items", "np_blocks", "nb_events", "nb___events", "nw_headers", "nw_frames", "nb__frames", "NR_objects", "nb_objects", "np_images", "nw_objects", "ni_locks", "nb__images", "nbBLblocks", "uniqueBLitems", "ni__locks", "NR_plugins", "ni_classes", "nb_images", "nb_locks", "nb___blocks", "nb__classes", "uniqueBLtimes", "nb_frames", "NR_blocks", "num_blocks", "ni_blocks", "uniqueBLchecks", "nb_block"]}}
{"project": "qemu", "commit_id": "65f82df0d7a71ce1b10cd4c5ab08888d176ac840", "target": 1, "func": "process_tx_desc(E1000State *s, struct e1000_tx_desc *dp)\n\n{\n\n    uint32_t txd_lower = le32_to_cpu(dp->lower.data);\n\n    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);\n\n    unsigned int split_size = txd_lower & 0xffff, bytes, sz, op;\n\n    unsigned int msh = 0xfffff, hdr = 0;\n\n    uint64_t addr;\n\n    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;\n\n    struct e1000_tx *tp = &s->tx;\n\n\n\n    if (dtype == E1000_TXD_CMD_DEXT) {\t// context descriptor\n\n        op = le32_to_cpu(xp->cmd_and_length);\n\n        tp->ipcss = xp->lower_setup.ip_fields.ipcss;\n\n        tp->ipcso = xp->lower_setup.ip_fields.ipcso;\n\n        tp->ipcse = le16_to_cpu(xp->lower_setup.ip_fields.ipcse);\n\n        tp->tucss = xp->upper_setup.tcp_fields.tucss;\n\n        tp->tucso = xp->upper_setup.tcp_fields.tucso;\n\n        tp->tucse = le16_to_cpu(xp->upper_setup.tcp_fields.tucse);\n\n        tp->paylen = op & 0xfffff;\n\n        tp->hdr_len = xp->tcp_seg_setup.fields.hdr_len;\n\n        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);\n\n        tp->ip = (op & E1000_TXD_CMD_IP) ? 1 : 0;\n\n        tp->tcp = (op & E1000_TXD_CMD_TCP) ? 1 : 0;\n\n        tp->tse = (op & E1000_TXD_CMD_TSE) ? 1 : 0;\n\n        tp->tso_frames = 0;\n\n        if (tp->tucso == 0) {\t// this is probably wrong\n\n            DBGOUT(TXSUM, \"TCP/UDP: cso 0!\\n\");\n\n            tp->tucso = tp->tucss + (tp->tcp ? 16 : 6);\n\n        }\n\n        return;\n\n    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {\n\n        // data descriptor\n\n        if (tp->size == 0) {\n\n            tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8;\n\n        }\n\n        tp->cptse = ( txd_lower & E1000_TXD_CMD_TSE ) ? 1 : 0;\n\n    } else {\n\n        // legacy descriptor\n\n        tp->cptse = 0;\n\n    }\n\n\n\n    if (vlan_enabled(s) && is_vlan_txd(txd_lower) &&\n\n        (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) {\n\n        tp->vlan_needed = 1;\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header),\n\n                      le16_to_cpup((uint16_t *)(s->mac_reg + VET)));\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header + 2),\n\n                      le16_to_cpu(dp->upper.fields.special));\n\n    }\n\n        \n\n    addr = le64_to_cpu(dp->buffer_addr);\n\n    if (tp->tse && tp->cptse) {\n\n        hdr = tp->hdr_len;\n\n        msh = hdr + tp->mss;\n\n        do {\n\n            bytes = split_size;\n\n            if (tp->size + bytes > msh)\n\n                bytes = msh - tp->size;\n\n\n\n            bytes = MIN(sizeof(tp->data) - tp->size, bytes);\n\n            pci_dma_read(&s->dev, addr, tp->data + tp->size, bytes);\n\n            if ((sz = tp->size + bytes) >= hdr && tp->size < hdr)\n\n                memmove(tp->header, tp->data, hdr);\n\n            tp->size = sz;\n\n            addr += bytes;\n\n            if (sz == msh) {\n\n                xmit_seg(s);\n\n                memmove(tp->data, tp->header, hdr);\n\n                tp->size = hdr;\n\n            }\n\n        } while (split_size -= bytes);\n\n    } else if (!tp->tse && tp->cptse) {\n\n        // context descriptor TSE is not set, while data descriptor TSE is set\n\n        DBGOUT(TXERR, \"TCP segmentaion Error\\n\");\n\n    } else {\n\n\n        pci_dma_read(&s->dev, addr, tp->data + tp->size, split_size);\n\n        tp->size += split_size;\n\n    }\n\n\n\n    if (!(txd_lower & E1000_TXD_CMD_EOP))\n\n        return;\n\n    if (!(tp->tse && tp->cptse && tp->size < hdr))\n\n        xmit_seg(s);\n\n    tp->tso_frames = 0;\n\n    tp->sum_needed = 0;\n\n    tp->vlan_needed = 0;\n\n    tp->size = 0;\n\n    tp->cptse = 0;\n\n}", "idx": 12984, "substitutes": {"bytes": ["bs", "keys", "flags", "pages", "files", "units", "ips", "words", "eps", "vs", "xs", "reads", "seconds", "ms", "blocks", "gs", "its", "ims", "rows", "frames", "bps", "ds", "times", "items", "bits", "ows", "types", "ns"], "sz": ["xsld", "dsld", " szi", "xsq", "xsz", "szi", "dsz", "sq", "sld", "dsq", " sq", " sld", "xszi", "dszi"], "op": ["oc", "info", " Op", "jp", "comp", "opt", "pop", "app", "ops", "error", "out", "ip", "init", "cmp", "hop", "top", "cop", "cp", "ps", " OP", "ap", "p", "OPER", "operator", "batch", "tf", "empty", "dr", "push", "pos", "omp", "oper", "oop", "ot", "mp", "block", "deep", "sp", "ok", "Op", "osp", "it", "bit", "sw", "offset", "num", "rot", "OP", "arg", "attr", "typ", "opp", "pixel", "feature", "o", "cmd", "pp", "ob", "perm", "lit", "obj", "post", "operation"], "addr": ["rel", "ord", "ref", "address", "asm", "Address", "alloc", "added", "hash", "src", "dh", "aud", "oad", "add", "ptr", "alt", "code", "arch", "ack", "res", " address", "ctr", "class", "order", "align", "link", "arp", "obj"], "xp": ["fps", "fx", "wy", "mph", "pkg", "fp", "XP", "jp", "lp", "elt", "nz", "xff", "esp", "dp", "txt", "tx", "xe", "px", "rpm", "xc", "cp", "hw", "eps", "ept", "xf", "xt", "wp", "imp", "gp", "vp", "xs", "yk", "omp", "pps", "ipp", "xy", "ctx", "yp", "xd", "inx", "orp", "xon", "hp", "xi", "bps", "lex", "expr", "apa", "bp", "wx", "pp", "wordpress", "isp"], "tp": ["pkg", "pot", "tn", "bl", "conv", "tk", "transfer", "xe", "prot", "cmp", "cp", "ps", "tif", "wp", "ptr", "pb", "tip", "tar", "wt", "ssh", "pt", "_", "td", "ht", "ta", "apt", "dt", "tmp", "dp", "txt", "peer", "pas", "def", "tg", "tf", "vp", "ot", "orp", "at", "hp", "t", "tm", "bp", "phy", "ipt", "cmd", "TP", "jp", "pc", "top", "exec", "tap", "tch", "mt", "gt", "typ", "ts", "rt", "pp", "arp", "fp", "lp", "tl", "elt", "p", "gp", "port", "tt", "iat", "dat"]}}
{"project": "qemu", "commit_id": "9a4c0e220d8a4f82b5665d0ee95ef94d8e1509d5", "target": 0, "func": "static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)\n\n{\n\n    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&vinput->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    /* force virtio-1.0 */\n\n    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;\n\n    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", errp);\n\n}\n", "idx": 13001, "substitutes": {"vpci_dev": ["vpci_device", "vpci_Dev", "vpci_def", "vpci___ev", "vpiti42Dev", "vpiti42dev", "vpiti42def", "vpci__desc", "vpci___dev", "vpci42dev", "vpiti_Dev", "vppc_ev", "vppc_dev", "vppc___device", "vpci___serv", "vpio_dev", "vpcit_dev", "vpiti_desc", "vpci__Dev", "vpio_serv", "vpci___desc", "vpce_Dev", "vpci_priv", "vpci42def", "vpci_bus", "vpci__def", "vpci_loc", "vpci___device", "vpci42desc", "vpiti_def", "vpci_ev", "vpce_device", "vpiti_dev", "vpce_dev", "vpce_bus", "vpci_desc", "vppc___ev", "vppc_device", "vpci42Dev", "vppc_desc", "vppc___desc", "vpio_device", "vpci__dev", "vppc___dev", "vpcit_loc", "vpiti42desc", "vpci_serv", "vpcit_priv"], "errp": ["errpp", "derpat", " errpp", "warnP", " errP", "erpa", " errps", "erP", "warnpa", "erp", " Errpp", " errpa", "derp", "errps", "errP", "warnps", "erps", "warnp", " errpat", " Errp", "derpp", "errpat", "errpa", "derps", " Errps", " Errpat"], "vinput": ["voncut", "evinstall", "vyput", "vonput", "evinput", "pinput", "cinPut", "vystall", "vinputer", "vinPut", "vycut", "cinputer", "cinput", "vincut", "tinPut", "tinput", "vonstall", "vinstall", "pinputer", "pinPut", "evincut", "tinputer"], "vdev": ["mprop", " vdiv", " vdevice", "svev", " vdata", "pver", "vdata", "mdev", "Vdevice", " vDev", "ddata", "mev", "svdata", "pDev", "lvdev", "svdiv", "ddev", "Vprop", "pdev", "mver", "vDev", "pdevice", "dev", "vptr", "svdev", "mde", " vev", " vptr", "lvptr", "vdevice", " vde", "vde", " vprop", "ddiv", "Vev", "mDev", "mptr", "mdevice", "Vdev", "lvdevice", "vdiv", "vev", "vver", "lvde", " vver", "vprop"]}}
{"project": "qemu", "commit_id": "3f66f764ee25f10d3e1144ebc057a949421b7728", "target": 0, "func": "static void test_visitor_out_string(TestOutputVisitorData *data,\n\n                                    const void *unused)\n\n{\n\n    char *string = (char *) \"Q E M U\";\n\n    Error *err = NULL;\n\n    QObject *obj;\n\n\n\n    visit_type_str(data->ov, &string, NULL, &err);\n\n    g_assert(!err);\n\n\n\n    obj = qmp_output_get_qobject(data->qov);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QSTRING);\n\n    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);\n\n\n\n    qobject_decref(obj);\n\n}\n", "idx": 13002, "substitutes": {"data": ["device", "rel", "d", "info", "defined", "map", "join", "route", "image", "Data", "di", "DATA", "format", "out", "ata", "dal", "rew", "message", "mu", "def", "check", "zero", "batch", "da", "valid", "att", "dev", "window", "none", "pattern", "query", "mode", "dump", "ad", "step", "open", "ds", "debug", "aw", "o", "table", "command", "call", "dat", "output", "accept"], "unused": [" unchecked", "unuse", "unavailable", " unuse", "UNavailable", "sunuse", "UNchecked", " unavailable", "sunchecked", "UNuse", "unchecked", "UNused", "sunused", "sunavailable"], "err": ["usr", "ch", "rank", "req", "Error", "n", "null", "die", "txt", "oe", "error", "buf", "result", "conf", "er", "sys", "arr", "r", "ptr", "e", "rev", "dev", "rr", "iter", "erd", "exc", "str", "rn", "ev", "res", "coll", "msg", "fr", "ex", "proc", "ec", "attr", "expr", "gr", "resp", "cmd", "kr", "cr", "v", "errors", "Er"], "obj": ["bs", "pkg", "orig", "bj", "ole", "tk", "np", "bh", "oid", "org", "js", "instance", "rect", "it", "expr", "snap", "pt", "pr", "ob", "vo", "Obj", "tmp", "txt", "oj", "ot", "cod", "j", "res", "iv", "t", "po", "opp", "vr", "resp", "cmd", "oc", "rel", "adj", "opt", "buf", "src", "ist", "arr", "ent", "nt", "object", "o", "onet", "stick", "ref", "elt", "null", "json", "out", "hw", "p", "impl", "bo", "buff", "oa", "none", "od", "xy", "ctx", "cont", "str", "og", "act", "obo", "inst", "attr", "v", "obs"]}}
{"project": "qemu", "commit_id": "d1048bef9df0aacde9a54bf9b5b97a6e10950d8c", "target": 0, "func": "static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    pcms->vmport = value;\n\n}\n", "idx": 13012, "substitutes": {"obj": ["pkg", "ref", "elt", "tmp", "ck", "objects", "txt", "cmp", "ist", "bh", "hw", "org", "bo", "att", "nt", "js", "ot", "xy", "ctx", "object", "cont", "og", "act", "obo", "ie", "inst", "iso", "typ", "po", "attr", "o", "cmd", "onet", "ob", "gov", "obs", "Obj"], "value": ["type", "present", "status", "node", "local", "state", "apache", "enabled", "create", "property", "p", "set", "position", "key", "update", "vp", "valid", "bo", "Value", "rue", "b", "rule", "block", "values", "VALUE", "show", "unknown", "open", "comment", "widget", "work", "file", "feature", "ue", "val", "function", "v", "w", "current", "label"], "errp": ["erp", "rrp", "errr", "errsp", "rrsp", " errr", " errsp", " errP", "err", "rrP", "ersp", "errP", "rrr", "erP"], "pcms": ["pcmers", " pcmes", "pxmx", "cpmes", "cpms", "vcms", " pcmers", "pnmers", "cpmx", "pxm", " pcm", "pcmes", " pcmx", " pcoms", "pcm", "vcmers", "pcmx", "vcmes", "pnmes", "pnms", "pxmes", "pnoms", "cpm", "vcoms", "pcoms", "pxms"]}}
{"project": "FFmpeg", "commit_id": "5763f675024765df8f256d8b5b01926a5fbd997d", "target": 1, "func": "static int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    int ret;\n\n\n\n    st = avformat_new_stream(c->fc, NULL);\n\n    if (!st) return AVERROR(ENOMEM);\n\n    st->id = c->fc->nb_streams;\n\n    sc = av_mallocz(sizeof(MOVStreamContext));\n\n    if (!sc) return AVERROR(ENOMEM);\n\n\n\n    st->priv_data = sc;\n\n    st->codec->codec_type = AVMEDIA_TYPE_DATA;\n\n    sc->ffindex = st->index;\n\n\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n\n        return ret;\n\n\n\n    /* sanity checks */\n\n    if (sc->chunk_count && (!sc->stts_count || !sc->stsc_count ||\n\n                            (!sc->sample_size && !sc->sample_count))) {\n\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n\n               st->index);\n\n        return 0;\n\n    }\n\n\n\n    fix_timescale(c, sc);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, sc->time_scale);\n\n\n\n    mov_build_index(c, st);\n\n\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n\n        MOVDref *dref = &sc->drefs[sc->dref_id - 1];\n\n        if (mov_open_dref(&sc->pb, c->fc->filename, dref, &c->fc->interrupt_callback,\n\n            c->use_absolute_path, c->fc) < 0)\n\n            av_log(c->fc, AV_LOG_ERROR,\n\n                   \"stream %d, error opening alias: path='%s', dir='%s', \"\n\n                   \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\\n\",\n\n                   st->index, dref->path, dref->dir, dref->filename,\n\n                   dref->volume, dref->nlvl_from, dref->nlvl_to);\n\n    } else {\n\n        sc->pb = c->fc->pb;\n\n        sc->pb_is_copied = 1;\n\n    }\n\n\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if (!st->sample_aspect_ratio.num &&\n\n            (st->codec->width != sc->width || st->codec->height != sc->height)) {\n\n            st->sample_aspect_ratio = av_d2q(((double)st->codec->height * sc->width) /\n\n                                             ((double)st->codec->width * sc->height), INT_MAX);\n\n        }\n\n\n\n#if FF_API_R_FRAME_RATE\n\n        if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))\n\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,\n\n                      sc->time_scale, sc->stts_data[0].duration, INT_MAX);\n\n#endif\n\n    }\n\n\n\n    // done for ai5q, ai52, ai55, ai1q, ai12 and ai15.\n\n    if (!st->codec->extradata_size && st->codec->codec_id == AV_CODEC_ID_H264 &&\n\n        TAG_IS_AVCI(st->codec->codec_tag)) {\n\n        ret = ff_generate_avci_extradata(st);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    switch (st->codec->codec_id) {\n\n#if CONFIG_H261_DECODER\n\n    case AV_CODEC_ID_H261:\n\n#endif\n\n#if CONFIG_H263_DECODER\n\n    case AV_CODEC_ID_H263:\n\n#endif\n\n#if CONFIG_MPEG4_DECODER\n\n    case AV_CODEC_ID_MPEG4:\n\n#endif\n\n        st->codec->width = 0; /* let decoder init width/height */\n\n        st->codec->height= 0;\n\n        break;\n\n    }\n\n\n\n    /* Do not need those anymore. */\n\n    av_freep(&sc->chunk_offsets);\n\n    av_freep(&sc->stsc_data);\n\n    av_freep(&sc->sample_sizes);\n\n    av_freep(&sc->keyframes);\n\n    av_freep(&sc->stts_data);\n\n    av_freep(&sc->stps_data);\n\n    av_freep(&sc->elst_data);\n\n    av_freep(&sc->rap_group);\n\n\n\n    return 0;\n\n}\n", "idx": 13024, "substitutes": {"c": ["abc", "oc", "vc", "cor", "cache", "l", "con", "pc", "k", "bc", "lc", "unc", "dc", "etc", "cur", "cmp", "cm", "xc", "cp", "cu", "conf", "cb", "cn", "p", "mc", "m", "C", "tc", "b", "chain", "cc", "rc", "com", "ctx", "ce", "cont", "g", "cf", "ci", "arc", "cl", "ct", "enc", "ic", "anc", "ec", "t", "nc", "cs", "fc", "uc", "config", "ca", "ac", "cr", "v", "f", "rec", "cd", "can", "icc", "call", "co"], "pb": ["uf", "pkg", "bs", "stab", "fp", "jp", "ref", "lp", "py", "sb", "pc", "bc", "dp", "bf", "tk", "rb", "bj", "pa", "pool", "tab", "np", "lb", "pac", "cp", "cb", "ap", "pl", "p", "wp", "repl", "plan", "pro", "vp", "mb", "tc", "fb", "b", "tp", "pg", "mp", "eb", "db", "ctx", "sp", "vt", "cv", "PB", "soc", "nb", "bps", "typ", "apa", "bp", "fc", "pp", "ob", "wb", "emb", "td", "ab", "ub"], "atom": [" orb", "ch", "om", "asm", "tmp", "x", "ar", "ata", "orm", "xml", "p", "from", "m", "nm", "ym", "oms", "raw", " exc", "name", "b", " canon", " cmd", "ot", "com", "al", "tar", "to", "op", "at", "um", "orb", "item", "msg", "OM", "typ", "attr", "tm", "mol", "o", "cmd", "base", "y", "mat", "f", "or", " symb"], "st": ["ST", "must", "stab", "ft", "usr", "sn", "ut", "std", "stop", "St", "th", "sl", "stra", "nd", "ast", "so", "ist", "src", "sv", "ste", "stan", "ost", "set", "ust", "store", "start", "et", "nt", "sp", "stable", "sts", "str", "sh", "kt", "sw", "est", "cl", "ct", "mt", "sta", "inst", "t", "sth", "tt", "se", "ts", "pt", "rt", "stat", "rest", "td", "obj", "irst", "ss"], "sc": ["must", "psc", "sb", "pc", "asc", "esp", "bc", "sch", "lc", "ctl", "dc", "scrib", "sv", "sche", "cu", "cons", "exec", "sub", "cer", "mc", "zero", "scan", "cam", "cgi", "desc", "sci", "sic", "irc", "sac", "usc", "tc", "isc", "cc", "rc", "sec", "ctx", "sp", "gc", "cv", "decl", "sh", "sw", "ci", "ka", "cl", "Sc", "soc", "anc", "enc", "ec", "capt", "esc", "osc", "scl", "nc", "cs", "fc", "uc", "ac", "cr", "scope", "sync", " subsc", "SC", "co", "ss"], "ret": ["ft", "ref", " alt", "RET", "nz", "status", "ber", "ben", "out", "re", "value", "ern", "reg", "result", "Ret", "def", "not", "r", "zero", "tf", "tr", "alt", "mem", "nt", "len", "no", "it", "res", "j", "back", "rm", "inter", "mt", "det", "gt", "try", "t", "ll", "rets", " Ret", "resp", "rt", "mel", "val", "print", "ral", "ez", "reset", "fit", "rem"], "dref": ["nref", "faddr", "drRef", " dRef", "dataddr", "Def", "dbref", "dbalf", "Dref", "bdreference", "bdterm", "nrel", "preference", "fref", "darev", " def", "dalf", "drev", "fmem", "didref", "nRef", " drev", "DRef", "freference", "def", "pRef", " dmem", "daRef", "datchange", "didaddr", "fterm", "bdref", " dreference", "Drep", "datreference", "bdRef", "dbRef", "drreference", "dareference", "didreference", "Dreference", "drrep", "frep", "nalf", "didchange", "dreference", "pref", "fRef", "dmem", " dalf", "dataRef", "dataef", "datareference", "frev", "dterm", "daddr", "drep", "datref", "didRef", " dterm", "drref", "daref", "fchange", "dRef", "dataref", " drel", "dbrel", "dchange", "didmem", "drel"]}}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static int buffer_empty(Buffer *buffer)\n\n{\n\n    return buffer->offset == 0;\n\n}\n", "idx": 13031, "substitutes": {"buffer": ["queue", "view", "cache", "channel", "address", "bar", "map", "page", "bc", "null", "header", "out", "byte", "buf", "face", "input", "bridge", "message", "interface", "batch", "empty", "buff", "b", "window", "db", "block", "bb", "index", "display", "Buffer", "line", "data", "board", "comment", "file", "text", "f", "command", "output"]}}
{"project": "qemu", "commit_id": "b0d768c35e08d2057b63e8e77e7a513c447199fa", "target": 1, "func": "static gboolean pty_chr_timer(gpointer opaque)\n\n{\n\n    struct CharDriverState *chr = opaque;\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (s->connected) {\n\n        goto out;\n\n    }\n\n\n\n    /* Next poll ... */\n\n    pty_chr_update_read_handler(chr);\n\n\n\nout:\n\n    s->timer_tag = 0;\n\n    return FALSE;\n\n}\n", "idx": 13035, "substitutes": {"opaque": ["obeno", "popient", "popacity", "iopacity", "obacity", "OPaques", "Openo", "obaque", "OPaque", "popeno", "Oplation", "obque", " opaques", "obient", "iopque", "iopient", "Opacity", "openo", "Opaques", " oplation", "oplation", "opque", "iopaque", "popaque", "OPlation", "opacity", "iopeno", "opaques", "Opque", "opient", "Opaque"], "chr": ["ChR", "chR", " chR", " chre", "echr", " chrb", "Chrb", " chrs", "chrs", "Chrl", "chear", "cher", "echrs", "chorl", "Char", "chrb", "choar", "chrl", "chre", "Chrs", "chorb", "echR", "Chre", "Chr", "echrb", "cherb", "chor", "chere", " chrl"], "s": ["bs", "h", "fs", "rs", "sb", "n", "ies", "S", "os", "als", "so", "sv", "c", "ps", "ss", "p", "sys", "set", "socket", "ssl", "m", "ls", "gs", "ats", "b", "js", "g", "j", "sq", "less", "ys", "t", "self", "ds", "cs", "ts", "is", "a", "v", "ins", "stats", "sis", "qs", "ns", "sts"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void h263_encode_init(MpegEncContext *s)\n\n{\n\n    static int done = 0;\n\n\n\n    if (!done) {\n\n        done = 1;\n\n\n\n        init_uni_dc_tab();\n\n\n\n        init_rl(&rl_inter);\n\n        init_rl(&rl_intra);\n\n        init_rl(&rl_intra_aic);\n\n        \n\n        init_uni_mpeg4_rl_tab(&rl_intra, uni_mpeg4_intra_rl_bits, uni_mpeg4_intra_rl_len);\n\n        init_uni_mpeg4_rl_tab(&rl_inter, uni_mpeg4_inter_rl_bits, uni_mpeg4_inter_rl_len);\n\n\n\n        init_uni_h263_rl_tab(&rl_intra_aic, NULL, uni_h263_intra_aic_rl_len);\n\n        init_uni_h263_rl_tab(&rl_inter    , NULL, uni_h263_inter_rl_len);\n\n\n\n        init_mv_penalty_and_fcode(s);\n\n    }\n\n    s->me.mv_penalty= mv_penalty; //FIXME exact table for msmpeg4 & h263p\n\n    \n\n    s->intra_ac_vlc_length     =s->inter_ac_vlc_length     = uni_h263_inter_rl_len;\n\n    s->intra_ac_vlc_last_length=s->inter_ac_vlc_last_length= uni_h263_inter_rl_len + 128*64;\n\n    if(s->h263_aic){\n\n        s->intra_ac_vlc_length     = uni_h263_intra_aic_rl_len;\n\n        s->intra_ac_vlc_last_length= uni_h263_intra_aic_rl_len + 128*64;\n\n    }\n\n    s->ac_esc_length= 7+1+6+8;\n\n\n\n    // use fcodes >1 only for mpeg4 & h263 & h263p FIXME\n\n    switch(s->codec_id){\n\n    case CODEC_ID_MPEG4:\n\n        s->fcode_tab= fcode_tab;\n\n        s->min_qcoeff= -2048;\n\n        s->max_qcoeff=  2047;\n\n        s->intra_ac_vlc_length     = uni_mpeg4_intra_rl_len;\n\n        s->intra_ac_vlc_last_length= uni_mpeg4_intra_rl_len + 128*64;\n\n        s->inter_ac_vlc_length     = uni_mpeg4_inter_rl_len;\n\n        s->inter_ac_vlc_last_length= uni_mpeg4_inter_rl_len + 128*64;\n\n        s->luma_dc_vlc_length= uni_DCtab_lum_len;\n\n        s->chroma_dc_vlc_length= uni_DCtab_chrom_len;\n\n        s->ac_esc_length= 7+2+1+6+1+12+1;\n\n        s->y_dc_scale_table= ff_mpeg4_y_dc_scale_table;\n\n        s->c_dc_scale_table= ff_mpeg4_c_dc_scale_table;\n\n\n\n        if(s->flags & CODEC_FLAG_GLOBAL_HEADER){\n\n\n\n            s->avctx->extradata= av_malloc(1024);\n\n            init_put_bits(&s->pb, s->avctx->extradata, 1024);\n\n            \n\n            mpeg4_encode_visual_object_header(s);\n\n            mpeg4_encode_vol_header(s, 0, 0);\n\n\n\n//            ff_mpeg4_stuffing(&s->pb); ?\n\n            flush_put_bits(&s->pb);\n\n            s->avctx->extradata_size= (put_bits_count(&s->pb)+7)>>3;\n\n        }\n\n        \n\n        break;\n\n    case CODEC_ID_H263P:\n\n        if(s->umvplus)\n\n            s->fcode_tab= umv_fcode_tab;\n\n        if(s->modified_quant){\n\n            s->min_qcoeff= -2047;\n\n            s->max_qcoeff=  2047;\n\n        }else{\n\n            s->min_qcoeff= -127;\n\n            s->max_qcoeff=  127;\n\n        }\n\n        break;\n\n        //Note for mpeg4 & h263 the dc-scale table will be set per frame as needed later \n\n    case CODEC_ID_FLV1:\n\n        if (s->h263_flv > 1) {\n\n            s->min_qcoeff= -1023;\n\n            s->max_qcoeff=  1023;\n\n        } else {\n\n            s->min_qcoeff= -127;\n\n            s->max_qcoeff=  127;\n\n        }\n\n        s->y_dc_scale_table=\n\n        s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n        break;\n\n    default: //nothing needed default table allready set in mpegvideo.c\n\n        s->min_qcoeff= -127;\n\n        s->max_qcoeff=  127;\n\n        s->y_dc_scale_table=\n\n        s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n    }\n\n}\n", "idx": 13040, "substitutes": {"s": ["bs", "fs", "sg", "styles", "views", "pers", "ps", "ms", "ports", "js", "des", "services", "g", "gets", "se", "tests", "ins", "details", "h", "changes", "sb", "ops", "terms", "results", "os", "als", "sv", "ches", "m", "ges", "sports", "ers", "ags", "t", "states", "is", "parts", "ns", "tes", "mods", "rs", "ads", "ies", "S", "c", "eps", "sys", "ls", "vs", "hs", "ats", "in", "its", "ims", "sq", "sets", "ts", "a", "qs", "ss", "sts", "i", "ses", "bes", "p", "es", "aws", "gs", "b", "bis", "eds", "less", "ds", "cs", "comments", "stats", "w"]}}
{"project": "qemu", "commit_id": "fdfab37dfeffefbd4533b4158055c9b82d7c3e69", "target": 0, "func": "static int check_oflag_copied(BlockDriverState *bs, BdrvCheckResult *res,\n\n                              BdrvCheckMode fix)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l2_table = qemu_blockalign(bs, s->cluster_size);\n\n    int ret;\n\n    uint64_t refcount;\n\n    int i, j;\n\n\n\n    for (i = 0; i < s->l1_size; i++) {\n\n        uint64_t l1_entry = s->l1_table[i];\n\n        uint64_t l2_offset = l1_entry & L1E_OFFSET_MASK;\n\n        bool l2_dirty = false;\n\n\n\n        if (!l2_offset) {\n\n            continue;\n\n        }\n\n\n\n        ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,\n\n                                 &refcount);\n\n        if (ret < 0) {\n\n            /* don't print message nor increment check_errors */\n\n            continue;\n\n        }\n\n        if ((refcount == 1) != ((l1_entry & QCOW_OFLAG_COPIED) != 0)) {\n\n            fprintf(stderr, \"%s OFLAG_COPIED L2 cluster: l1_index=%d \"\n\n                    \"l1_entry=%\" PRIx64 \" refcount=%\" PRIu64 \"\\n\",\n\n                    fix & BDRV_FIX_ERRORS ? \"Repairing\" :\n\n                                            \"ERROR\",\n\n                    i, l1_entry, refcount);\n\n            if (fix & BDRV_FIX_ERRORS) {\n\n                s->l1_table[i] = refcount == 1\n\n                               ? l1_entry |  QCOW_OFLAG_COPIED\n\n                               : l1_entry & ~QCOW_OFLAG_COPIED;\n\n                ret = qcow2_write_l1_entry(bs, i);\n\n                if (ret < 0) {\n\n                    res->check_errors++;\n\n                    goto fail;\n\n                }\n\n                res->corruptions_fixed++;\n\n            } else {\n\n                res->corruptions++;\n\n            }\n\n        }\n\n\n\n        ret = bdrv_pread(bs->file, l2_offset, l2_table,\n\n                         s->l2_size * sizeof(uint64_t));\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR: Could not read L2 table: %s\\n\",\n\n                    strerror(-ret));\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n\n\n        for (j = 0; j < s->l2_size; j++) {\n\n            uint64_t l2_entry = be64_to_cpu(l2_table[j]);\n\n            uint64_t data_offset = l2_entry & L2E_OFFSET_MASK;\n\n            QCow2ClusterType cluster_type = qcow2_get_cluster_type(l2_entry);\n\n\n\n            if ((cluster_type == QCOW2_CLUSTER_NORMAL) ||\n\n                ((cluster_type == QCOW2_CLUSTER_ZERO) && (data_offset != 0))) {\n\n                ret = qcow2_get_refcount(bs,\n\n                                         data_offset >> s->cluster_bits,\n\n                                         &refcount);\n\n                if (ret < 0) {\n\n                    /* don't print message nor increment check_errors */\n\n                    continue;\n\n                }\n\n                if ((refcount == 1) != ((l2_entry & QCOW_OFLAG_COPIED) != 0)) {\n\n                    fprintf(stderr, \"%s OFLAG_COPIED data cluster: \"\n\n                            \"l2_entry=%\" PRIx64 \" refcount=%\" PRIu64 \"\\n\",\n\n                            fix & BDRV_FIX_ERRORS ? \"Repairing\" :\n\n                                                    \"ERROR\",\n\n                            l2_entry, refcount);\n\n                    if (fix & BDRV_FIX_ERRORS) {\n\n                        l2_table[j] = cpu_to_be64(refcount == 1\n\n                                    ? l2_entry |  QCOW_OFLAG_COPIED\n\n                                    : l2_entry & ~QCOW_OFLAG_COPIED);\n\n                        l2_dirty = true;\n\n                        res->corruptions_fixed++;\n\n                    } else {\n\n                        res->corruptions++;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        if (l2_dirty) {\n\n            ret = qcow2_pre_write_overlap_check(bs, QCOW2_OL_ACTIVE_L2,\n\n                                                l2_offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"ERROR: Could not write L2 table; metadata \"\n\n                        \"overlap check failed: %s\\n\", strerror(-ret));\n\n                res->check_errors++;\n\n                goto fail;\n\n            }\n\n\n\n            ret = bdrv_pwrite(bs->file, l2_offset, l2_table,\n\n                              s->cluster_size);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"ERROR: Could not write L2 table: %s\\n\",\n\n                        strerror(-ret));\n\n                res->check_errors++;\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_vfree(l2_table);\n\n    return ret;\n\n}\n", "idx": 13050, "substitutes": {"bs": ["bos", "fs", "rs", "ashes", "sb", "bl", "aos", "bc", "ses", "blog", "os", "als", "bes", "aus", "ubis", "hz", "bh", "ps", "sys", "outs", "vs", "ls", "hs", "ms", "aws", "gs", "b", "its", "js", "lbs", "locks", "sts", "bb", "bis", "bas", "boxes", "bps", "BS", "ds", "ubs", "bp", "cs", "ts", "bits", "bi", "bm", "obs", "ns", "ss"], "res": ["details", "rel", "usr", "resolution", "sum", "rs", "req", "sol", "progress", "terms", "history", "ber", "sim", "results", "re", "ress", "reg", "result", "resource", "cons", "ps", "pas", "def", "sys", "r", "err", "ms", "news", "rev", "rc", "rr", "rez", "des", "rss", "ack", "response", "windows", "der", "RES", "ro", "red", "vals", "resh", "pres", "resources", "rek", "expr", "vol", "gr", "cs", "pr", "rys", "resp", "Res", "wcs", "rest", "scope", "ins", "aux", "ns", "reset", "rem"], "fix": ["fx", "gem", "prefix", " def", "tx", "clear", " patch", "init", "patch", "conf", "def", "check", "set", "err", " repair", "add", "fixes", "update", " edit", "raw", " update", " pack", " Fix", "db", " prefix", "commit", "block", "bit", " diff", "use", "Fix", " exec", "bin", "FIX", "fail", "issue", "pack", "bug", "get", "ix", "mix", "make", "dot", " fixing", " err", "diff", "xx", "mask", "call", "edit", " pos"], "s": ["details", "h", "fs", "rs", "sn", "sb", "series", "sl", "ops", "ses", "S", "als", "bes", "http", "sv", "c", "comm", "ss", "ps", "eps", "p", "sys", "ess", "es", "ssl", "args", "vs", "ls", "xs", "hs", "aws", "ms", "gs", "ats", "b", "its", "js", "ports", "as", "ims", "sp", "spec", "bis", "services", "sq", "https", "less", "ds", "cs", "ts", "is", "bits", "stats", "ins", "qs", "parts", "ns", "sts"], "l2_table": ["l3_offset", "l2actree", "l2actable", "l1_cache", "l2__entry", "l2_offset", "l1_tab", "l2__tab", "l2acoffset", "l2__table", "l2__cache", "l2_cache", "l2acentry", "l2_entry", "l2_tab", "l3_table", "l3_entry", "l1_entry", "l3_tree", "l2_tree", "l1_table"], "ret": ["re", "reply", "cat", "Ret", "addr", "cb", "tif", "r", "ptr", "et", "ry", "att", "it", "inter", "ter", "expr", "rets", "pt", "got", "rem", "modified", "usr", "dt", "del", "def", "tr", "mb", "flag", "final", "try", "t", "net", "resp", "cmd", "print", "jp", "RET", "pret", "ber", "ext", "arr", "err", "Return", "alt", "nt", "count", "mt", "det", "gt", "rt", "deg", "val", "ft", "ref", "elt", "nz", "out", "result", "rev", "len", "fun", "cont", "back", "magic", "ll", " Ret", "reset", "backed"], "refcount": ["refcode", "reflength", "RefCount", " refname", "refcond", "REFount", "diffcond", "referencelength", "colcode", "difflength", "reqname", "Refount", "memlength", " refc", "Refcounter", "referenceCount", "diffcount", "memcount", "reqcount", " reflength", "argcounter", "refc", "colcounter", "refount", "colCount", "referenceount", "argcount", "memount", "reqlength", " refcounter", "REFcond", "argCount", "referencecount", "colcount", "referencename", "Refc", " refcode", "referencec", "REFcount", "diffount", " refount", "refCount", "reqCount", "memcond", "refname", "referencecounter", "refcounter", "Refcount", " refCount", "REFlength", "referencecode"], "i": ["qi", "iq", "ind", "l", "ai", "ii", "n", "gi", "di", "point", "x", "sim", "local", "ij", "ip", "init", "c", "q", "u", "ti", "li", "\u0438", "I", "p", "r", "si", "batch", "m", "ri", "oi", "us", "key", "ori", "name", "im", "e", "multi", "chain", "in", "remote", "ims", "index", "iu", "id", " ii", "it", "me", "ci", "ie", "xi", "ex", "ic", "ki", "phi", "zi", "ix", "mi", "is", "a", "pi", "y", "v", "bi", "ini", "ui", "uri"], "j": ["ind", "ch", "jp", "l", "ji", "n", "aj", "k", "z", "json", "br", "bj", "x", "ij", "c", "q", "p", "jj", "jump", "r", "batch", "m", "oj", "tr", "b", "e", "js", "index", "job", "it", "g", "uj", "fr", "dj", "max", "jas", "kj", "J", "jc", "ix", "pr", "pt", "kid", "o", "v", "y", "obj", "jl", "ns"], "check_errors": [" check_error", "check_docs", "check_rors", "check___error", "check___errors", "check_error", "check___rors", " check_comments", " check_rors", "check___docs", " check_docs", "check_comments"], "corruptions_fixed": ["corruptions___locked", "corruptions___fixed", "corruptions_locked", "corruptures_checked", "corruptions___checked", "corruptures_locked", "corruptures_fixes", "corruptions_checked", "corruptures_fixed", "corruptions_fixes", "corruptions___fixes"], "corruptions": ["Corruptures", "Corruptions", "corricturations", "Corruptedures", "corruptedions", "corrupteditions", "corruptedurations", "corruptitions", "corrictures", "corstructurations", "corruptures", "corstructures", "corrictions", "corruptedures", "corrictitions", "Corruptedurations", "Corrupturations", "corstructions", "Corrupteditions", "corstructitions", "Corruptedions", "corrupturations", "Corruptitions"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void mainstone_common_init(MemoryRegion *address_space_mem,\n\n                                  MachineState *machine,\n\n                                  enum mainstone_model_e model, int arm_id)\n\n{\n\n    uint32_t sector_len = 256 * 1024;\n\n    hwaddr mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 };\n\n    PXA2xxState *mpu;\n\n    DeviceState *mst_irq;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    int be;\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    const char *cpu_model = machine->cpu_model;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa270-c5\";\n\n\n\n    /* Setup CPU & memory */\n\n    mpu = pxa270_init(address_space_mem, mainstone_binfo.ram_size, cpu_model);\n\n    memory_region_init_ram(rom, NULL, \"mainstone.rom\", MAINSTONE_ROM,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    /* There are two 32MiB flash devices on the board */\n\n    for (i = 0; i < 2; i ++) {\n\n        dinfo = drive_get(IF_PFLASH, 0, i);\n\n        if (!dinfo) {\n\n            if (qtest_enabled()) {\n\n                break;\n\n            }\n\n            fprintf(stderr, \"Two flash images must be given with the \"\n\n                    \"'pflash' parameter\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        if (!pflash_cfi01_register(mainstone_flash_base[i], NULL,\n\n                                   i ? \"mainstone.flash1\" : \"mainstone.flash0\",\n\n                                   MAINSTONE_FLASH,\n\n                                   blk_bs(blk_by_legacy_dinfo(dinfo)),\n\n                                   sector_len, MAINSTONE_FLASH / sector_len,\n\n                                   4, 0, 0, 0, 0, be)) {\n\n            fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    mst_irq = sysbus_create_simple(\"mainstone-fpga\", MST_FPGA_PHYS,\n\n                    qdev_get_gpio_in(mpu->gpio, 0));\n\n\n\n    /* setup keypad */\n\n    pxa27x_register_keypad(mpu->kp, map, 0xe0);\n\n\n\n    /* MMC/SD host */\n\n    pxa2xx_mmci_handlers(mpu->mmc, NULL, qdev_get_gpio_in(mst_irq, MMC_IRQ));\n\n\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[0],\n\n            qdev_get_gpio_in(mst_irq, S0_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S0_CD_IRQ));\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[1],\n\n            qdev_get_gpio_in(mst_irq, S1_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S1_CD_IRQ));\n\n\n\n    smc91c111_init(&nd_table[0], MST_ETH_PHYS,\n\n                    qdev_get_gpio_in(mst_irq, ETHERNET_IRQ));\n\n\n\n    mainstone_binfo.kernel_filename = machine->kernel_filename;\n\n    mainstone_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    mainstone_binfo.initrd_filename = machine->initrd_filename;\n\n    mainstone_binfo.board_id = arm_id;\n\n    arm_load_kernel(mpu->cpu, &mainstone_binfo);\n\n}\n", "idx": 13051, "substitutes": {"address_space_mem": ["address_area_memory", "address_space2memory", "address_base2mem", "address_base2memory", "address_space2ram", "address_space2reg", "address_base_memory", "address_space2mem", "address_area_mem", "address_base2ram", "address_base_mem", "address_space_Mem", "address_base_ram", "address_base_reg", "address_base2reg", "address_space_reg", "address_space_memory", "address_area_Mem", "address_space_ram"], "machine": ["computer", "device", "power", "container", "image", "memory", "monitor", "node", "connection", "state", "cpu", "achine", "message", "mc", "m", "host", "mem", "domain", "shell", "network", "instance", "mode", "agent", "module", "manager", "engine", "disk", "money", "zone", "iso", "handler", "template", "policy", "Machine", "process", "vm"], "model": ["type", "map", "value", "cm", "core", "models", "ma", "m", "key", "name", "min", "dev", "pm", "lv", "index", "mode", "module", "mod", "mm", "ll", "link", "mi", "Model", "base", "brand", "grid", "bm", "label"], "arm_id": ["armUnum", "arm_name", "armUname", "arm_ref", "arm_num", "am_name", "armUid", "am_ref", "armjref", "armjid", "armjnum", "armjname", "am_id", "armUref", "am_num"], "mainstone_flash_base": ["mainstone_flash_cache", "mainstone_Flash_bas", "mainstone_flash2Base", "mainstone_Flash_buffer", "mainstone_flash2base", "mainstone_flash_Base", "mainstone_flash_block", "mainstone_flash_bas", "mainstone_flash2buffer", "mainstone_Flash_cache", "mainstone_flash2cache", "mainstone_Flash_Base", "mainstone_Flash_base", "mainstone_flash_buffer", "mainstone_Flash_block"], "mpu": ["mmu", "mpiu", "pmus", "mpus", "mti", "mmus", " mpui", "mtu", "mpui", "pmtu", "mmtu", "epcu", "mptu", "ppiu", "epi", "pmui", "mpcu", "ppus", "mmiu", "mpo", "mtui", "pmiu", "mtus", "pmU", "pmi", "mpi", "mto", "ppu", " mpU", "pptu", "pmcu", "mtU", "epo", "pmu", " mpus", "epu", "mtcu", "mpU", "pmo"], "mst_irq": ["mst_irQ", "mst_iq", "mst_pirq", "mst_prQ", "mst_mrQ", "mst_mrq", "mst_mrqs", "mst_pirqs", "mst_pirqu", "mst_mrqu", "mst_pirQ", "mst_irqu", "mst_prqu", "mst_prq", "mst_prqs", "mst_irqs", "mst_iQ", "mst_iqs"], "dinfo": [" dInfo", "dno", "linf", "bdfo", " dfo", " ddata", "Dno", "dfo", "lby", "Dby", "rInfo", "DInfo", "bdInfo", "sInfo", "bdinf", "dby", "lno", "linfo", " dby", "rfo", "sdata", "ddata", " dinf", " dno", "rinfo", "lInfo", "bdinfo", "sfo", "dInfo", "dinf", "rdata", "Dinf", "Dinfo", "sinfo", "lfo", "Dfo"], "i": ["qi", "h", "info", "l", "ai", "ii", " si", "n", "gi", " di", "k", "z", "di", "x", "sim", "go", "cli", "ip", "ij", "gu", "tim", "c", "u", "ti", " bi", "li", "hi", "I", "p", " j", "s", "r", "si", "m", " pi", "b", "multi", "im", "in", "e", " index", "fi", "index", "iu", "id", " ii", "it", "j", "ci", "ie", "xi", "ic", "ki", "t", "phi", "zi", "ix", "mi", "o", "pi", "v", "y", "bi", "ini", "ui", "f", " ti"], "be": ["zo", "ble", "ge", "ve", "ly", " ne", "end", "send", "abe", "ate", "brace", "z", "br", "bf", "oe", "bes", " pe", " se", "scale", "st", "ste", "pose", "ape", "te", "bo", "Be", "ne", "b", "e", "ine", "eb", "none", "he", "loop", "are", "to", "fe", "ce", "it", "bit", "use", "range", " je", "obe", "try", "ke", "zone", "we", "ode", "BE", "ose", "se", "beat", "ze", "is", "ue", "este", "by", "bi", "ere", " Be", "or", " BE", "ride", " b"], "rom": ["gem", "iam", "rep", "rs", "ra", "room", "serv", "dom", "reg", "cm", "cpu", "prom", "rain", "core", "ram", "ru", "ri", "ran", "arm", "dr", "mn", "roma", "irm", "mem", "im", "rob", "com", "rum", "rim", "ro", "rg", "red", "rn", "res", "prem", "rar", "rm", "sr", "mr", "mm", "rol", "cr", "drm", "ros", "chrom", "ROM", "bm", "gra", "rem"], "cpu_model": ["cpuurescope", " cpu_mode", "cpuetymodel", "cpuureModel", "cpu_models", "cpu_location", "cpuuremodel", "pu_model", "cpuetymode", "cpu_Model", "cpuetytype", "cpu_type", "pu_mode", "cpu_value", "cpu_mode", " cpu_type", " cpu_models", "cpu_link", "pu_location", "cpu_module", "cpuetylocation", "CPU_model", "pu_Model", "pu_type", " cpu_Model", "pu_scope", "cpu_scope", " cpu_value", "CPU_link", "CPU_Model", "CPU_module"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(vu9_to_vu12)(const uint8_t *src1, const uint8_t *src2,\n\n\t\t\tuint8_t *dst1, uint8_t *dst2,\n\n\t\t\tlong width, long height,\n\n\t\t\tlong srcStride1, long srcStride2,\n\n\t\t\tlong dstStride1, long dstStride2)\n\n{\n\n    long y,x,w,h;\n\n    w=width/2; h=height/2;\n\n#ifdef HAVE_MMX\n\n    asm volatile(\n\n\tPREFETCH\" %0\\n\\t\"\n\n\tPREFETCH\" %1\\n\\t\"\n\n\t::\"m\"(*(src1+srcStride1)),\"m\"(*(src2+srcStride2)):\"memory\");\n\n#endif\n\n    for(y=0;y<h;y++){\n\n\tconst uint8_t* s1=src1+srcStride1*(y>>1);\n\n\tuint8_t* d=dst1+dstStride1*y;\n\n\tx=0;\n\n#ifdef HAVE_MMX\n\n\tfor(;x<w-31;x+=32)\n\n\t{\n\n\t    asm volatile(\n\n\t\tPREFETCH\" 32%1\\n\\t\"\n\n\t        \"movq\t%1, %%mm0\\n\\t\"\n\n\t        \"movq\t8%1, %%mm2\\n\\t\"\n\n\t        \"movq\t16%1, %%mm4\\n\\t\"\n\n\t        \"movq\t24%1, %%mm6\\n\\t\"\n\n\t        \"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t        \"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t        \"movq\t%%mm4, %%mm5\\n\\t\"\n\n\t        \"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\t\"punpcklbw %%mm0, %%mm0\\n\\t\"\n\n\t\t\"punpckhbw %%mm1, %%mm1\\n\\t\"\n\n\t\t\"punpcklbw %%mm2, %%mm2\\n\\t\"\n\n\t\t\"punpckhbw %%mm3, %%mm3\\n\\t\"\n\n\t\t\"punpcklbw %%mm4, %%mm4\\n\\t\"\n\n\t\t\"punpckhbw %%mm5, %%mm5\\n\\t\"\n\n\t\t\"punpcklbw %%mm6, %%mm6\\n\\t\"\n\n\t\t\"punpckhbw %%mm7, %%mm7\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm7, 56%0\"\n\n\t\t:\"=m\"(d[2*x])\n\n\t\t:\"m\"(s1[x])\n\n\t\t:\"memory\");\n\n\t}\n\n#endif\n\n\tfor(;x<w;x++) d[2*x]=d[2*x+1]=s1[x];\n\n    }\n\n    for(y=0;y<h;y++){\n\n\tconst uint8_t* s2=src2+srcStride2*(y>>1);\n\n\tuint8_t* d=dst2+dstStride2*y;\n\n\tx=0;\n\n#ifdef HAVE_MMX\n\n\tfor(;x<w-31;x+=32)\n\n\t{\n\n\t    asm volatile(\n\n\t\tPREFETCH\" 32%1\\n\\t\"\n\n\t        \"movq\t%1, %%mm0\\n\\t\"\n\n\t        \"movq\t8%1, %%mm2\\n\\t\"\n\n\t        \"movq\t16%1, %%mm4\\n\\t\"\n\n\t        \"movq\t24%1, %%mm6\\n\\t\"\n\n\t        \"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t        \"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t        \"movq\t%%mm4, %%mm5\\n\\t\"\n\n\t        \"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\t\"punpcklbw %%mm0, %%mm0\\n\\t\"\n\n\t\t\"punpckhbw %%mm1, %%mm1\\n\\t\"\n\n\t\t\"punpcklbw %%mm2, %%mm2\\n\\t\"\n\n\t\t\"punpckhbw %%mm3, %%mm3\\n\\t\"\n\n\t\t\"punpcklbw %%mm4, %%mm4\\n\\t\"\n\n\t\t\"punpckhbw %%mm5, %%mm5\\n\\t\"\n\n\t\t\"punpcklbw %%mm6, %%mm6\\n\\t\"\n\n\t\t\"punpckhbw %%mm7, %%mm7\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm7, 56%0\"\n\n\t\t:\"=m\"(d[2*x])\n\n\t\t:\"m\"(s2[x])\n\n\t\t:\"memory\");\n\n\t}\n\n#endif\n\n\tfor(;x<w;x++) d[2*x]=d[2*x+1]=s2[x];\n\n    }\n\n#ifdef HAVE_MMX\n\n\tasm(\n\n\t\tEMMS\" \\n\\t\"\n\n\t\tSFENCE\" \\n\\t\"\n\n\t\t::: \"memory\"\n\n\t\t);\n\n#endif\n\n}\n", "idx": 13068, "substitutes": {"src1": ["sr2", "source3", "usr1", "source1", "rc2", "sr1", " srcOne", "srOne", "source7", " src3", "rcOne", "sourceOne", "src3", "usr2", "sr3", "srcOne", " src7", "rc3", "source2", " src01", "usr3", "rc1", "rc7", "src01", "usr01", "rc01", "src7"], "src2": [" src5", "sourcetwo", "source3", "source1", " src4", "rc2", "source4", "source5", "rstwo", " src3", "src3", "src5", "rc3", "source2", "rc5", "rc1", "rctwo", "rs1", "rs2", "rc4", "src4", "srctwo"], "dst1": ["dsrc0", "Dsts3", "Dsts2", "pdstore001", "dst001", "Dst3", "dcr001", "dstore001", "dstoreRad", "dst01", "pdst1", "Dst1", "dstRad", "dsts3", "dcrRad", "dest2", "Dst2", "dest1", "dst0", "pdstoreRad", "dcr1", "dgest1", "dgest01", "dgestRad", "pdstRad", "dgest001", "dsrc1", "dsrc3", "pdstore01", "dsrc2", "dest3", "dest0", "pdst01", "dsts1", "pdstore1", "dst3", "Dsts1", "pdst001", "dcr01", "dstore01", "Dst0", "Dsts0", "dstore1", "dsts2", "dsts0"], "dst2": ["dsrc0", "dst5", "dstr1", "Dest1", "Dst1", "dest02", "drc0", "Dest2", "Dest02", "dist02", "dest2", "sest02", "dest1", "dst0", "Dst2", "dstr02", "dist5", "sest0", "Dest5", "dst02", "dest5", "Dst5", "drc2", "dsrc1", "sst02", "dstr5", "dsrc2", "dest0", "sst0", "drc02", "sest1", "sst1", "drc1", "sest2", "sst2", "dsrc02", "dstr2", "Dst02", "dist2", "dist1"], "height": ["shape", "ch", "resolution", "angle", "th", "ty", "hub", "radius", "padding", "history", "draw", "frame", "depth", "density", "gh", "Height", "zh", "hang", "kh", "window", "count", "gravity", "he", "ih", "volume", "html", "size", "sh", "grow", "ity", "gy", "inches", "stroke", "bottom", "hei", "sky", "wh", "length", "ht", "headers"], "srcStride1": ["srcStrat1", "srcstride2", "srcStrat01", "srcstide01", "srcStrideOne", "srcStine2", "srcStide1", "srcStideName", "srcStrid1", "srcstride1", "srcStineOne", "srcstride12", "srcStride12", "srcStratName", "srcStide2", "srcStine1", "srcstide12", "srcstide1", "srcStack1", "srcStrid2", "srcStride10", "srcstideName", "srcStrideName", "srcStide10", "srcStrid12", "srcStack01", "srcStackName", "srcstride10", "srcStrat10", "srcstrideName", "srcStide12", "srcStideOne", "srcstideOne", "srcStratOne", "srcStrat2", "srcstide10", "srcstrideOne", "srcStide01", "srcStine12", "srcstride01", "srcStridOne", "srcStride01", "srcstide2", "srcStack2"], "srcStride2": ["srcStrride02", "srcstide6", "srcStrobe6", "srcstride2", "srcStrideTwo", "srcStrrideTwo", "srcStrib02", "srcStribTwo", "srcStide4", "srcStrobe4", "srcStide1", "srcStrib2", "srcStackTwo", "srcstride1", "srcStro1", "srcStrib1", "srcstide0", "srcStide6", "srcStide2", "srcStride02", "srcStride0", "srcStrobe1", "srcstride0", "srcStack1", "srcstide1", "srcStrobe2", "srcStideTwo", "srcstrideTwo", "srcStride4", "srcStrride1", "srcStrride2", "srcStend2", "srcStack0", "srcstide4", "srcStride6", "srcStide02", "srcStend0", "srcstride4", "srcstideTwo", "srcStendTwo", "srcStend1", "srcStro2", "srcStide0", "srcstride6", "srcStro4", "srcstide2", "srcStack2", "srcStro6"], "dstStride1": ["dstStrib4", "dstStrride1", "dstStrict01", "dstStrride4", "dstStrideId", "dstStrrideId", "dstSTrideOne", "dstStide4", "dstStide2", "dstSTripone", "dstStideId", "dstStripId", "dstStrictone", "dstStrip1", "dstSTrip1", "dstStrip4", "dstSTrideone", "dstStrride2", "dstStrib2", "dstSTride01", "dstStride01", "dstStride4", "dstStripOne", "dstSTrip01", "dstStrip2", "dstStriction01", "dstStrideone", "dstStrict1", "dstStrictionOne", "dstStrideOne", "dstStripone", "dstStriction1", "dstStribId", "dstStide1", "dstStrictOne", "dstSTripOne", "dstStrib1", "dstSTride1", "dstStrip01", "dstStrictionone"], "dstStride2": ["dstStide02", "dststride2", "dstStack_", "dststide1", "dstSlride_", "dstStide2", "dstStride3", "dstStride02", "dstStr02", "dstStride_", "dstStr3", "dststride3", "dstStrib2", "dstStr_", "dstStrib02", "dststide2", "dstStr2", "dststride02", "dstStide1", "dstStide3", "dstStrobe_", "dststide02", "dststride1", "dstStrib1", "dstStrib3", "dstSlrobe_", "dststide3", "dstStr1"], "y": ["wy", "i", "ey", "ch", "that", "py", "ye", "column", "ly", "yi", "ady", "vy", "ty", "fy", "kit", "z", "lat", "ies", "cy", "iy", "col", "dy", "yo", "hot", "asy", "p", "sys", "uy", "sy", "err", "icy", "m", "ym", "key", "any", "ish", "ry", "b", "yer", "e", "ot", "sat", "xy", "my", "g", "ay", "j", "at", "ny", "ya", "gy", "yl", "axy", "try", "ys", "oy", "t", "yy", "yr", "ery", "o", "Y", "sky", "by", "ley", "yx", "xx", "on", "yt"], "x": ["column", "ch", "status", "ross", "lat", "px", "xml", "check", "r", "xd", "sw", "ex", "X", "xx", "ax", "draw", "xt", "m", "name", "j", "en", "xi", "t", "ix", " xx", "f", "yx", "fx", "l", "page", "xxxx", "c", "ext", "xf", "batch", "key", "xes", "index", "inx", "xxx", "step", "ct", "lex", "axis", "o", "edit", "est", "i", "xp", "dx", "n", "time", "z", "tx", "xc", "p", "ux", "rx", "xs", "e", "xy", "exclusive", "id", "row", "ice", "el", "ox", "wx", "v", "on"], "w": ["wy", "wl", "l", "kw", "nw", "win", "wi", "Width", "wk", "q", "hw", "p", "wp", "r", "m", "wm", "ww", "wr", "window", "W", "wa", "wt", "ew", "wid", " W", "wn", "en", "ex", "iw", "t", "we", "fw", "wall", "aw", "rw", "wx", "wh", "wb", "v", "wd"], "h": ["i", "ch", "l", "hd", "n", "k", "z", "ha", "hash", "c", "q", "hw", "his", "hi", "H", "p", "r", "m", "hr", "zh", "hang", "ish", "hs", "kh", "b", "he", "ih", "hl", "g", "sh", "j", "hal", "en", "t", "oh", "hei", "hm", "v", "f", "ph", "length", "wh", "hh", "ht", "high"], "s1": [" s3", " s01", " s001", "s0", "s3", "ats1", "rs3", "ss0", "src3", "ats0", "ss2", " s0", "ss1", "rs0", "rs001", " s4", "s01", "src01", "rs1", "ats2", "ss3", "rs2", "s4", "rs01", "rs4", "s001", "src4", "ats001"], "d": ["i", "dl", "l", "dm", "dict", "n", "dx", "dt", "z", "di", "dp", "dc", "did", "c", "q", "dra", "p", "bd", "dL", "r", "s", "m", "dr", "b", "e", "pd", "db", "dd", "fd", "done", "D", "g", "j", "ad", "sd", "data", "dis", "dq", "t", "ds", "dos", "o", "ld", "v", "f", "ded", "dat", "da"], "s2": ["s4", "ss2", "s0", " s0", "ss1", "src0", " s4", "ss4", "ss0", "src4"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void puv3_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    CPUUniCore32State *env;\n\n    UniCore32CPU *cpu;\n\n\n\n    if (initrd_filename) {\n\n        error_report(\"Please use kernel built-in initramdisk\");\n\n        exit(1);\n\n    }\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"UniCore-II\";\n\n    }\n\n\n\n    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));\n\n    if (!cpu) {\n\n        error_report(\"Unable to find CPU definition\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    puv3_soc_init(env);\n\n    puv3_board_init(env, ram_size);\n\n    puv3_load_kernel(kernel_filename);\n\n}\n", "idx": 13077, "substitutes": {"machine": ["shape", "computer", "device", "power", "menu", "image", "series", "save", "hello", "server", "monitor", "history", "sim", "node", "connection", "space", "state", "frame", "managed", "achine", "alias", "human", "check", "m", "host", "chain", "parse", "domain", "network", "shell", "rule", "instance", "agent", "mode", "manager", "module", "me", "engine", "range", "model", "money", "gate", "zone", "iso", "template", "handler", "keeper", "link", "Machine", "process", "vm", "one"], "cpu_model": ["pu_value", "cpuNamecontroller", "cpuitycontroller", " cpu_mode", "cpuNameattribute", "moneyNamemodel", "money_model", "cpu_label", "pu_models", "moneyNameattribute", "cpu_models", "pu_label", "cpuitymodel", "pu_model", "pu_vector", "cpuitytype", "cpu_controller", "pu_string", "pu_base", "cpu_Model", "cpu_type", "money_controller", "cpu_value", "pu_mode", "cpu_mode", " cpu_type", "moneyNametype", "moneyNamecontroller", "cpu_string", "pu_Model", "cpuityattribute", "cpuNamemodel", "cpuNametype", "money_attribute", "cpu_attribute", "cpu_base", "money_type", "cpu_vector"], "kernel_filename": ["kernel_subject", "loader_subject", "kernellelayout", "loaderlogfilename", "loader_fn", "kernellefilename", "ernel_file", "kernelletitle", "kernel_file", "kernel_layout", "kernel___fn", "ernel_fn", "loader_tails", "proc_fn", "kernel___tails", "kernellogsubject", "proc_filename", "kernellogtails", "kernel___subject", "kernel_name", "ernel_name", "kernellogfilename", "kernellefn", "proc_layout", "loaderlogtails", "kernel_title", "proc_title", "kernel___filename", "loader_filename", "kernellogfn", "kernel_tails", "loaderlogsubject", "ernel_filename", "kernel_fn", "loaderlogfn"], "initrd_filename": ["initdretystring", "initdr_filename", "initrd_string", "initrd_fn", "initdretyfolder", "initrdistfilename", "initrd___filename", "initrb_fn", "initrd___string", "initrd_txt", "initrdetystring", "initrb_filename", "initrd___folder", "initrendisttxt", "initrdetyfolder", "initrend_txt", "initrd___txt", "initrb_Filename", "initrdisttxt", "initrd_Filename", "initrend_filename", "initrendistfile", "initrdistfn", "initrdetyfilename", "initrend_file", "initrd_file", "initrd_folder", "initdretyfilename", "initdr_string", "initrd___Filename", "initdretyFilename", "initrend_fn", "initdr_Filename", "initdr_folder", "initrb_uri", "initrd_uri", "initrd___fn", "initrdetyFilename", "initrdistfile", "initrendistfn", "initrendistfilename", "initrd___file"], "env": ["event", "context", "ve", "dict", "priv", "esp", "email", "stack", "server", "win", "init", "state", "session", "nv", "frame", "buf", "sv", "global", "eng", "conf", "er", "enter", "environment", "hw", "vs", "et", "mn", "te", "viron", "ent", "cookie", "mem", "entry", "e", "dev", "window", "db", "shell", "vt", "ctx", "erd", "ce", "ev", "me", "manager", "engine", "en", "conn", "gear", "proc", "ec", "doc", "wall", "net", "vert", "equ", "config", "cmd", "v", "scope", "obj", "w", "vm"], "cpu": ["computer", "clock", "cal", "goal", "cache", "jp", "comp", "runner", "frame", "gpu", "server", "alloc", "node", "cum", "cli", "util", "init", "pu", "nu", "np", "processor", "cp", "c", "core", "cu", "nice", "uart", "socket", "cam", "linux", "bench", "pai", "ne", "mem", "mac", "coin", "ctx", "gc", "cv", "na", "ce", "ni", "nic", "hog", "ola", "bean", "proc", "aco", "CPU", "net", "uda", "config", "base", "process", "vm", "cow", "mu", "current", "chip"]}}
{"project": "FFmpeg", "commit_id": "caa845851d790f894a2ccbe12580934f75545f92", "target": 0, "func": "static int output_data_internal(MLPDecodeContext *m, unsigned int substr,\n\n                                uint8_t *data, unsigned int *data_size, int is32)\n\n{\n\n    SubStream *s = &m->substream[substr];\n\n    unsigned int i, out_ch = 0;\n\n    int32_t *data_32 = (int32_t*) data;\n\n    int16_t *data_16 = (int16_t*) data;\n\n\n\n    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))\n\n        return -1;\n\n\n\n    for (i = 0; i < s->blockpos; i++) {\n\n        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {\n\n            int mat_ch = s->ch_assign[out_ch];\n\n            int32_t sample = m->sample_buffer[i][mat_ch]\n\n                          << s->output_shift[mat_ch];\n\n            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;\n\n            if (is32) *data_32++ = sample << 8;\n\n            else      *data_16++ = sample >> 8;\n\n        }\n\n    }\n\n\n\n    *data_size = i * out_ch * (is32 ? 4 : 2);\n\n\n\n    return 0;\n\n}\n", "idx": 13081, "substitutes": {"m": ["h", "d", "l", "dm", "n", "am", "asm", "k", "gm", "cm", "M", "c", "comm", "p", "mc", "r", "nm", "mn", "ms", "md", "b", "mp", "g", "j", "mt", "mm", "mr", "t", "em", "tm", "mi", "o", "sm", "hm", "v", "f", "y", "bm"], "substr": ["subbr", "singstr", "SubStr", "formstring", "singstring", "subStr", "formStr", "subSTR", " substem", "sqstring", "singSTR", " subbr", "Substring", "sqstem", " substring", "singStr", "Substr", "substring", "sqstr", "formSTR", "Substem", "Subbr", "SubSTR", "sqbr", "substem", "formstr"], "data": ["d", "cache", "n", "bytes", "map", "image", "Data", "DATA", "x", "results", "out", "value", "multiple", "input", "ata", "new", "message", "p", "zero", "batch", "empty", "any", "raw", "window", "dat", "none", "buffer", "block", "no", "done", "size", "values", "missing", "bin", "t", "all", "text", "table", "sample", "mu"], "data_size": [" data_Size", "data5send", "data_since", "data_SIZE", "data_count", "data_send", "data5since", "sample_since", " data_length", "DATA_size", "sample_size", " data_SIZE", "data5size", "DATA_SIZE", "data_length", "DATA_count", "data_Size", "sample_send", "data5SIZE", "DATA_length", "sample_SIZE"], "is32": ["iss32", "isl64", "isl31", "tis64", " is31", "iris32", " is40", "iris34", "iss64", "is34", "is31", "isl42", "is8", " is8", "is12", " is64", "tis42", "tis32", "is40", "is64", " is34", "is42", "tis40", "sis34", "sis12", "iris31", "sis8", "iss12", " is42", "isl32", " is12", "tis34", "sis32", "sis64", "iss8", "sis40", "tis31"], "s": ["h", "fs", "rs", "esm", "sb", "n", "serv", "sl", "settings", "ops", "z", "ses", "sim", "S", "os", "space", "state", "service", "sv", "c", "comm", "conf", "ps", "p", "sys", "set", "ssl", "ls", "hs", "ms", "gs", "b", "e", "js", "sa", "ims", "sp", "sts", "spec", "g", "sd", "sw", "sq", "t", "ds", "se", "cs", "ts", "is", "a", "sm", "v", "stats", "ins", "f", "ns", "sym", "ss"], "i": [" ki", "u", "r", " ii", "it", "g", "ci", "ki", "zi", " mi", " iter", "mi", "y", "uri", " li", "d", "ii", " si", " di", " Ai", "ij", "init", " pi", "ri", "multi", "to", "at", "j", "xi", "t", "ix", "f", "ui", "ini", "qi", "ind", "l", "ai", "di", "x", "c", "q", " bi", "ti", "li", "I", "si", "batch", "key", "im", "in", "index", "phi", "o", "a", "pi", "bi", "io", "n", " ni", "z", "sim", "go", "ip", "ei", "p", " j", "e", " index", "iu", "id", "me", " Xi", "ic", "v", " ti"], "data_32": ["step_12", "data_33", "message_34", "message_32", "message_152", "message_33", "data_152", "data_12", "data__32", "data_34", "data__8", "data__33", "step_8", "data_8", "data__152", "step_16", "data__34", "data__12", "step_32", "data__16"], "data_16": ["data_18", " data_24", " data_1024", "data_31", " data_31", " data_18", "data_180", "data___1024", "data_24", " data_180", "data_1024", "data___18", "data___32", "data___16"], "out_ch": ["in_ch", "outptch", " out_CH", "outChanchannel", "outptchannel", "outMemcom", "out___sh", "out_ech", "out_sh", "out_chi", "outChanCH", " out_chi", "out_com", "chain_ch", "out_batch", "out_Ch", "out___ch", "outptCH", "in_channel", "outChanch", "out_CH", "out___chan", "mat_batch", "outMemch", "outMemchi", " out_wh", "chain_ech", "outMemchan", "out_chn", "outMemCh", " out_chn", "mat_chan", "out_cho", "in_cho", "outChanchn", "in_chan", "out_wh", "out_ich", " out_Ch", "mat_ch", "out_char", "outMemcho", "out_chan", "out___channel", "in_com", "in_sh", "outMemwh", "outptchn", "chain_chn", "out_channel", "chain_ich", "mat_char", " out_channel"]}}
{"project": "qemu", "commit_id": "2ebafc854d109ff09b66fb4dd62c2c53fc29754a", "target": 1, "func": "static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,\n\n                                 uint64_t end_offset, void **p_feature_table,\n\n                                 Error **errp)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowExtension ext;\n\n    uint64_t offset;\n\n    int ret;\n\n\n\n#ifdef DEBUG_EXT\n\n    printf(\"qcow2_read_extensions: start=%ld end=%ld\\n\", start_offset, end_offset);\n\n#endif\n\n    offset = start_offset;\n\n    while (offset < end_offset) {\n\n\n\n#ifdef DEBUG_EXT\n\n        /* Sanity check */\n\n        if (offset > s->cluster_size)\n\n            printf(\"qcow2_read_extension: suspicious offset %lu\\n\", offset);\n\n\n\n        printf(\"attempting to read extended header in offset %lu\\n\", offset);\n\n#endif\n\n\n\n        ret = bdrv_pread(bs->file, offset, &ext, sizeof(ext));\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"qcow2_read_extension: ERROR: \"\n\n                             \"pread fail from offset %\" PRIu64, offset);\n\n            return 1;\n\n        }\n\n        be32_to_cpus(&ext.magic);\n\n        be32_to_cpus(&ext.len);\n\n        offset += sizeof(ext);\n\n#ifdef DEBUG_EXT\n\n        printf(\"ext.magic = 0x%x\\n\", ext.magic);\n\n#endif\n\n        if (ext.len > end_offset - offset) {\n\n            error_setg(errp, \"Header extension too large\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        switch (ext.magic) {\n\n        case QCOW2_EXT_MAGIC_END:\n\n            return 0;\n\n\n\n        case QCOW2_EXT_MAGIC_BACKING_FORMAT:\n\n            if (ext.len >= sizeof(bs->backing_format)) {\n\n                error_setg(errp, \"ERROR: ext_backing_format: len=%\" PRIu32\n\n                           \" too large (>=%zu)\", ext.len,\n\n                           sizeof(bs->backing_format));\n\n                return 2;\n\n            }\n\n            ret = bdrv_pread(bs->file, offset, bs->backing_format, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret, \"ERROR: ext_backing_format: \"\n\n                                 \"Could not read format name\");\n\n                return 3;\n\n            }\n\n            bs->backing_format[ext.len] = '\\0';\n\n#ifdef DEBUG_EXT\n\n            printf(\"Qcow2: Got format extension %s\\n\", bs->backing_format);\n\n#endif\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_FEATURE_TABLE:\n\n            if (p_feature_table != NULL) {\n\n                void* feature_table = g_malloc0(ext.len + 2 * sizeof(Qcow2Feature));\n\n                ret = bdrv_pread(bs->file, offset , feature_table, ext.len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: ext_feature_table: \"\n\n                                     \"Could not read table\");\n\n                    return ret;\n\n                }\n\n\n\n                *p_feature_table = feature_table;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            /* unknown magic - save it in case we need to rewrite the header */\n\n            {\n\n                Qcow2UnknownHeaderExtension *uext;\n\n\n\n                uext = g_malloc0(sizeof(*uext)  + ext.len);\n\n                uext->magic = ext.magic;\n\n                uext->len = ext.len;\n\n                QLIST_INSERT_HEAD(&s->unknown_header_ext, uext, next);\n\n\n\n                ret = bdrv_pread(bs->file, offset , uext->data, uext->len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: unknown extension: \"\n\n                                     \"Could not read data\");\n\n                    return ret;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n\n\n        offset += ((ext.len + 7) & ~7);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13097, "substitutes": {"bs": ["bos", "fps", "fs", "rs", "sb", "bytes", "aos", "bl", "bc", "ses", "bf", "blog", "als", "bes", "aus", "ubis", "hz", "bh", "ps", "bn", "sys", "outs", "pb", "ls", "vs", "hs", "aws", "gs", "b", "its", "js", "eb", "lbs", "sts", "bb", "bis", "bas", "boxes", "vals", "cks", "ox", "bps", "BS", "ds", "ubs", "bp", "bsp", "cs", "ts", "bits", "ins", "bi", "oss", "qs", "bm", "obs", "bing", "ns", "banks", "ss"], "start_offset": ["st_offset", "start_position", "first_size", "start_size", "start_Offset", "first_padding", "start_padding", "first_offset", "start_point", "st_position", " start_position", "first_pos", "start_pos", "st_Offset", "st_size", " start_point", " start_padding"], "end_offset": ["stop__location", "stop_size", " end_size", "end__size", "end___offset", " end_Offset", "end___op", "end__number", "stop__offset", "stop_offset", "end_Offset", "start_Offset", "stop_location", "endlysize", "stop__size", "end_length", "endlylocation", "end_pointer", "endlynumber", "start_op", " end_position", "stop_number", "end_op", "END_offset", "end___length", "end__location", "END_point", "end_number", "start_length", "end_size", "endlyoffset", "end___Offset", "end_position", "end__offset", "stop__number", "end_location", "END_pointer", "end_point", "END_Offset"], "p_feature_table": ["p_feature_Table", "pc_end", "p_feature_TABLE", "p____end", "p_image_list", "p_image_table", "p_image_Table", "p_end", "p_feature_list", "p_image_TABLE", "pc____end"], "errp": ["errg", "errpoint", "eorping", "warnP", "ererp", "lrpress", "lrpa", "aerp", " errP", "errorpress", "errpress", "rerpad", "errd", "warnpa", " errpa", "diepa", "errorpa", "aerg", "eorg", "aerper", "diepoint", "aerd", "lrp", "errpad", "derp", "rerpa", "dieping", "errpb", "errP", "eorp", "ererpb", "rerpress", "errorpb", "lrpad", "eorpa", "derd", "rrp", "warnp", "ererpa", "ererpos", "errping", "rrpb", "warnpos", "derper", "eorpoint", "errorpad", "rerp", "ererP", "derg", "rrpa", "errorp", "errpa", "rrping", "ererping", " errpos", "eord", "diep", "errorping", "eorper", "errper", "rrpoint", "errpos"], "s": ["h", "fs", "sn", "rs", "sb", "ses", "S", "os", "sv", "ps", "p", "es", "si", "ls", "vs", "xs", "aws", "gs", "b", "ats", "its", "js", "sa", "sp", "sts", "sq", "ds", "cs", "ts", "bits", "stats", "sis", "ns", "ss"], "ext": [" extrap", "orig", "art", "gz", "prot", "cb", "add", "ptr", "dim", "js", " extension", "EXT", "ex", "inter", "ef", "esc", "expr", "nex", "text", "ez", "rem", "ax", "esp", "txt", "temp", "xt", "def", "tf", " ex", "tr", " extent", "env", "imm", " Ext", "msg", "enc", "pat", "mod", "t", "ix", "lib", "resp", "cmd", "ind", "req", "opt", "bf", "off", "split", "external", "tab", " extr", "XT", "exec", "ort", " extend", "sub", "err", "sci", "alt", "im", "nt", "ev", "seq", "lex", "val", "aux", "dist", "let", "xp", "ord", " extract", "ref", "elt", "lt", "extra", "tx", "tex", "new", "ver", "p", "desc", "buff", "e", "ctx", "cont", "str", "orb", "el", "ox", "ect", "inst", "test", "wx", "v", "obj", "Ext"], "offset": ["padding", "error", "addr", "oid", "ptr", "et", "pos", "url", "scroll", "ob", "ta", "end", "esp", "Offset", "next", "slot", "alias", "set", "position", "store", "start", "timeout", "tz", "buffer", "offs", "sp", "size", "at", "coord", "t", "OFF", "align", "f", "lag", "length", "location", "adjusted", "off", "tab", "top", "batch", "key", "origin", "alt", "seek", "index", "op", "range", "item", "mt", "o", "area", "mask", "initialized", "online", "fp", "ref", "address", "point", "out", "bound", "handle", "now", "window", "slice", "len", "attribute", "pointer", "row", "iso", "pad", "section", "output", "reset", "shift"], "ret": ["status", "re", "reply", "cat", "Ret", "addr", "tif", "ptr", "et", "eq", "att", "inter", "ter", "expr", "rets", "rem", "usr", " alt", "dt", "tmp", " RET", "def", "set", "tf", "tr", "flag", "eth", "res", "after", "try", "t", "net", "get", "resp", "cmd", "print", "ere", "jp", "RT", "RET", "pret", "ber", "ort", "sys", "arr", "err", "ent", "Return", "alt", "nt", "cert", "mt", "gt", "arg", "il", "rt", "val", "ft", "ord", "ref", "elt", "nz", "lt", "out", "reg", "result", "new", "rev", "ert", "iter", "fun", "back", " Ret", "reset"]}}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, int dstWidth, const uint8_t *src1, const uint8_t *src2,\n\n                                   int srcW, int xInc, const int16_t *hChrFilter,\n\n                                   const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                   uint8_t *formatConvBuffer,\n\n                                   uint32_t *pal)\n\n{\n\n\n\n    src1 += c->chrSrcOffset;\n\n    src2 += c->chrSrcOffset;\n\n\n\n    if (c->chrToYV12) {\n\n        c->chrToYV12(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= formatConvBuffer+VOFW;\n\n    }\n\n\n\n    if (!c->hcscale_fast) {\n\n        c->hScale(dst     , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);\n\n    }\n\n\n\n    if (c->chrConvertRange)\n\n        c->chrConvertRange(dst, dstWidth);\n\n}\n", "idx": 13100, "substitutes": {"c": ["abc", "h", "cal", "vc", "d", "ch", "l", "con", "cache", "comp", "n", "pc", "bc", "lc", "unc", "dc", "etc", "cur", "cmp", "cm", "cp", "cb", "cu", "conf", "comm", "cn", "p", "mc", "s", "cam", "m", "C", "b", "e", "tc", "cc", "rc", "com", "chain", "ctx", "gc", "cv", "ce", "cont", "g", "cf", "ci", "ct", "anc", "enc", "ic", "ec", "t", "self", "nc", "cs", "fc", "sc", "ca", "ac", "cr", "v", "f", "cd", "can", "call", "co"], "dst": ["dosp", "ddSt", "deost", "sdld", "dSt", " dnd", "bnd", "gst", "delst", " dST", "bpt", "bst", "dnt", "delnt", "delld", "Dost", "ldest", "msrc", "Dest", "deST", "dsp", " dsrc", "dest", "dld", "mnd", " dest", "sdnt", "Dst", "dost", "dST", "ldnt", "deest", "Dsrc", "dsrc", "dond", "delSt", "gsp", " dost", "ldST", "dopt", "ddst", "DST", "Dnt", "ddnt", "Dnd", "mst", "bsp", "mest", "sdst", " dnt", "ldst", "dnd", "gnd", "sdSt", "dpt", "ddld", "gpt"], "dstWidth": ["dstFontSize", "DestWidth", "dspW", " destHeight", "dndW", "dndSize", "DstWidth", "dndHeight", "DmtHeight", " dSTwidth", "destSize", "dstHeight", "dmtFontSize", "dputHeight", "dspHTML", "dstwidth", " destWidth", "dwtHTML", "destW", "dspwidth", "dSTwidth", "dstSize", "DstFontSize", "dwtWidth", "DmtWidth", " dstHTML", "Dstwidth", "destLen", "DestSize", "DstSize", "destBW", "dSTWidth", "DestHeight", "destWidth", "DmtBW", "dSTLen", "DmtFontSize", "dstHTML", " dSTW", "destFontSize", "DstBW", "dSTHTML", "dntFontSize", "dmtHeight", "dntwidth", "dntWidth", "DstHeight", "dmtwidth", " dstSize", " dSTHTML", " dstwidth", " dSTWidth", " destSize", "dmtW", " dstHeight", "dspWidth", "dSTSize", "drcWidth", "DestW", "dmtBW", "dputBW", "dndWidth", "DmtW", "dwtwidth", "drcLen", " dstLen", "Dmtwidth", "drcSize", "dSTW", "dntHeight", "destwidth", "destHeight", "dwtW", "dmtWidth", "dSTHeight", " destLen", " dstW", "dputWidth", "dstLen", "dstBW", "drcHeight", "dstW", "DstW", "dputW"], "src1": ["rel2", "source1", "rc2", "rc001", "inst2", "inst1", " srcOne", " src3", "sc0", "rcOne", "sourceOne", "rel1", "scOne", "src3", "desc1", "desc001", "desc2", "srcOne", "instOne", "rc3", "rc0", "source2", " src001", " src01", "rel3", "rc1", "src01", " src0", "rc01", "rel01", "source0", "descOne", "src001", "inst001", "sc01", "sc1", "src0", "source01"], "src2": ["ser02", "loc02", "sr2", "source3", "src02", "rel2", "source1", " src4", "rc2", " src32", "source02", "sr1", "sr32", "usrTwo", "relTwo", "rc32", "txt02", "rel1", "src3", "usr2", "rc02", " src02", "loc2", "srcL", "rc3", "source2", "locTwo", "rc1", "ser2", "txt1", "ser1", "usr3", "rcL", "srcTwo", "rcTwo", " srcTwo", "rc4", "src32", "sourceTwo", " srcL", "relL", "txt2", "src4", "sr4"], "srcW": ["srcWidth", "ctrW", "sourceEW", "rcWidth", "srcEW", "rcw", "sr2", "sourcew", " srcV", "sec1", "syn1", "rc2", "synW", " srcEW", "rcV", "sourceV", "ctr1", "secWidth", " srcw", "secW", "pkgw", "pkgW", "secEW", "rcJ", " srcJ", "srw", "pkgWidth", "pkgEW", "source2", "synWidth", "rc1", "sourceWidth", "synEW", "sourceW", "rcEW", "ctrEW", "srcV", "srcw", "srcJ", "srJ", "srW", "rcW"], "xInc": ["xtInc", "xtInv", "xAdd", "dxIncre", "xIncre", " xINC", "xpInc", "exAdd", "yExc", "yInc", " xIncre", "xpINC", "xfinc", "xInv", "exIncre", "yInit", "dxInc", "yINC", "yIncre", "xtEnc", "xInit", " xAdd", "xtAdd", "exInc", "xINC", " xInit", "xfInv", "xfInc", "exEnc", "xExc", "xinc", "dxEnc", "xtinc", "xEnc", " xinc", "xpIncre", "xtIncre", " xInv", "yEnc", " xExc", "xfIncre", "dxExc", " xEnc", "xpInit"], "hChrFilter": ["hChrFocus", "hChrcFilter", "hChrMethod", "hScsrHash", "hCHnFormat", "hChrFormat", "hChsrFilter", "hChcTransform", "hChrSpec", "hChsrFocus", "hChrcFocus", "hChrtFilter", "hChrgFilter", "hChnTransform", "hChlSpec", "hChlTransform", "hChlProfile", "hCorcTransform", "hChrHash", "hChtTransform", "hCorcFilter", "hChrApply", "hChrbFormat", "hCHrFilter", "hCorrFilter", "hChnApply", "hChcProfile", "hCHnApply", "hChrtHash", "hCHnFilter", "hChnFilter", "hCorrTransform", "hChnFormat", "hChcSpec", "hCHrApply", "hCHrFormat", "hChlFilter", "hChrgProfile", "hScsrFocus", "hChsrMethod", "hScrHash", "hChrcMethod", "hChtFormat", "hChtApply", "hChrbTransform", "hChsrHash", "hChrcHash", "hChrProfile", "hScrMethod", "hChrbFilter", "hChrtMethod", "hScsrFilter", "hChtFilter", "hScrFilter", "hCHnTransform", "hChrtFocus", "hScrFocus", "hChcFilter", "hChrgTransform", "hChrbApply", "hCorcSpec", "hCorrProfile", "hChrgSpec", "hCHrTransform", "hCorcProfile", "hCorrSpec", "hChrTransform", "hScsrMethod"], "hChrFilterPos": ["hChcrFilterCond", "hChcrFormatpos", "hChcrFormatPos", "hChcFilterPos", "hChrFilterType", "hChrFormatCond", "hChrcfilterPos", "hChrPatternPos", "hChrFilterRef", "hChrCounterPos", "hChrFilterTrans", "hChrfilterpos", "hChrcFilterTrans", "hChrHandlerPosition", "hChcrFilterPos", "hChrfilterPosition", "hChcFilterpos", "hChrfilterCond", "hChrfilterRef", "hChrCounterRef", "hChrFilterPosition", "hChrFilterpos", "hChrfilterTrans", "hChcrFormatRef", "hChcrFormatCond", "hChrfilterType", "hChcrFilterRef", "hChrFormatpos", "hChrHandlerTrans", "hChrcfilterPosition", "hChrcfilterTrans", "hChrPatternpos", "hChrPatternType", "hChrBufferPosition", "hChrcFilterPosition", "hChrcFilterPos", "hChrCounterpos", "hChcFilterType", "hChrFormatRef", "hChrHandlerPos", "hChrCounterCond", "hChrBufferTrans", "hChrfilterPos", "hChrBufferPos", "hChrFormatPos", "hChrFilterCond", "hChcrFilterpos"], "hChrFilterSize": ["hChrFormatOffset", "hChrFilStats", "hChrFilS", "hChrlFieldOffset", "hChrMaskLen", "hChcFilterSize", "hChcFilterPos", "hChrBlockLen", "hChrFormatSize", "hChcFilterStyle", "hChrFilOffset", "hChrTransformCos", "hChrlFilterStats", "hChdrFilterSize", "hChrBufferStyle", "hChrFieldSize", "hChrBlockStyle", "hChdrFilterSIZE", "hChrHandlerLen", "hChrFieldStats", "hChcBufferPos", "hChcFilterLen", "hChrlFieldStats", "hChrHandlerSize", "hChrFilterLen", "hChrFieldOffset", "hChrFilterCos", "hChdrFilterLen", "hChdrTransformCos", "hChrHandlerStyle", "hChrMaskSize", "hChrBufferLen", "hChrTransformLen", "hChrlFieldSize", "hChrTransformSIZE", "hChrFilterSIZE", "hChrBufferSize", "hChdrFilterCos", "hChrMaskSIZE", "hChrBlockSize", "hChrlFilterS", "hChrlFilterSize", "hChrFilterStyle", "hChcBufferStyle", "hChrMaskCos", "hChrBlockPos", "hChdrTransformLen", "hChrlFilterOffset", "hChdrTransformSIZE", "hChrFormatS", "hChrFilterStats", "hChrFilSize", "hChcBufferSize", "hChcBufferLen", "hChrFilterS", "hChrlFieldS", "hChrFormatStats", "hChdrTransformSize", "hChrFilterOffset", "hChrHandlerPos", "hChrTransformSize", "hChrBufferPos", "hChrFieldS"], "formatConvBuffer": ["formatEnvertBuff", "formatConfComment", "formatConvertTable", "formatconvBlock", "formatConVbuffer", "formatconjbuffer", "formatConVMatrix", "formatConflBlock", "formatconjComment", "formatConjBlock", "formatConcvTable", "formatConvTable", "formatConjComment", "formatConvBlock", "formatConjBuff", "formatConVBuffer", "formatConVPtr", "formatConVBuff", "formatEnVTable", "formatConjBuffer", "formatconjPtr", "formatEnvMatrix", "formatConvComment", "formatConviBuff", "formatConviText", "formatConfBuffer", "formatConviSize", "formatConvertBuff", "formatconjBlock", "formatconvBuff", "formatConVTable", "formatConcvMatrix", "formatConVSize", "formatconvComment", "formatEnVMatrix", "formatconvSize", "formatConfBuff", "formatConvPtr", "formatEnvertBuffer", "formatConfTable", "formatconvTable", "formatEnVBuff", "formatconjBuffer", "formatConvertMatrix", "formatConVText", "formatConflbuffer", "formatConjbuffer", "formatConjPtr", "formatConjTable", "formatEnvTable", "formatconjTable", "formatconvbuffer", "formatConvbuffer", "formatConvertText", "formatEnvBuff", "formatConviTable", "formatConvertBuffer", "formatConVBlock", "formatConcvBuffer", "formatConflTable", "formatEnvertTable", "formatEnvText", "formatconjBuff", "formatConvSize", "formatConvText", "formatEnvBuffer", "formatconvPtr", "formatConvMatrix", "formatConjSize", "formatconjSize", "formatConflBuffer", "formatEnVBuffer", "formatConviPtr", "formatEnvertText", "formatConviBuffer", "formatconvBuffer", "formatConvBuff", "formatConflComment", "formatConcvBuff", "formatConflBuff"], "pal": ["cal", "theme", "color", "png", "pol", "style", "padding", "what", "local", "format", "Pal", "pid", "scale", "conf", "pen", "pl", "isal", "pill", "qq", "sal", " PAL", "buffer", "al", "font", "pattern", "sav", "offset", "quant", "pres", "el", "flat", "pack", "attr", "vol", "bat", "val", "ph", "mat", "ass", "dat", "alpha"]}}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void pl011_init(uint32_t base, qemu_irq irq,\n\n                CharDriverState *chr)\n\n{\n\n    int iomemtype;\n\n    pl011_state *s;\n\n\n\n    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));\n\n    iomemtype = cpu_register_io_memory(0, pl011_readfn,\n\n                                       pl011_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->chr = chr;\n\n    s->read_trigger = 1;\n\n    s->ifl = 0x12;\n\n    s->cr = 0x300;\n\n    s->flags = 0x90;\n\n    if (chr){ \n\n        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,\n\n                              pl011_event, s);\n\n    }\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 13114, "substitutes": {"base": ["bs", "bind", "h", "i", "birth", "bid", "l", "type", "ref", "Base", "address", "prefix", "parent", "k", "memory", "bf", "x", "out", "pa", "init", "state", "cpu", "c", "root", "p", "set", "start", "ma", "m", "mb", "handle", "pos", "b", "based", "e", " bases", "db", "buffer", "index", "id", "bas", "size", "use", "bit", "range", "max", " Base", "ase", "se", "file", "ca", "bp", "source", "kb", "pi", "y", "f", "v", "bi", "area", "reset"], "irq": [" firq", "iriqi", "ibrqu", "virqs", "ibrq", " firqu", "ibrqs", "iorq", "irch", "ircqu", "irqu", "ircqi", "virq", "iriqu", "virqi", " firdq", "iorque", " irqs", " firqs", " irqu", " srq", "pirq", "ibrqi", " srqs", "iriq", "ibrdq", "iorch", "irque", " srqu", "iorqi", "iriqs", "virqu", "pirch", "ircqs", "pirqi", " srdq", " irdq", "pirque", "irqi", "ibrch", "irqs", "ibrque", "ircq"], "chr": ["chnr", "ochrt", "chert", "cherrs", "cherr", "echdr", "chnrs", " chrect", "schdr", "chR", "chrect", "schr", "schrc", "echr", "schR", "schrt", " chrs", "chem", "Chrt", "chrs", "chnrect", "chnrt", "echrt", "Chrn", "chrn", "ochrs", "schrs", "cher", "Chdr", "cheR", "echrs", "clm", "clc", "cherc", "Char", "cherrn", " chrn", "clr", " chm", "cherar", "phr", " chrt", "phR", "chc", "ochr", "chm", "Chrs", "ochrect", "chdr", "chrt", "chec", "clrt", " chc", "Chr", "phrt", "phrc", "chrc"], "iomemtype": ["iomemtemplate", "iomomport", "iotymtype", "xiormtype", "iomomtype", "xiemType", "iomemstypes", "iomormcat", "iomemtypes", "iamomtypes", "xiemtype", "iomormport", "iomotortype", "iomitemTYPE", "iomitemtype", "iomimtemplate", "iometerType", "iamemtype", "iamomype", "iomemType", "iotemtemplate", "iomimTYPE", "iotemtype", "iotemTYPE", "iomitemtemplate", "iamemype", "iotymtemplate", "iamomType", "iomemport", "xiormcat", "iomymtemplate", "iotymType", "iomimtype", "iomemcat", "iomomtypes", "iomotorType", "iomemsype", "iomomType", "iometertype", "iomormType", "iomotorype", "iamemtypes", "xiemport", "iomemstype", "iometerport", "iomymType", "xiemcat", "iomomcat", "iomotortypes", "xiormport", "iomitemType", "iamemType", "iomemTYPE", "iometercat", "iomimType", "iomymtype", "iomymTYPE", "iotemType", "iomemype", "xiormType", "iamomtype", "iomormtype", "iotymTYPE", "iomemsType", "iomomype"], "s": ["details", "bs", "h", "i", "fs", "l", "rs", "changes", "n", "sb", "sl", "settings", "status", "z", "ops", "ses", "S", "os", "als", "so", "sv", "c", "q", "ps", "ss", "pers", "comm", "p", "sys", "r", "set", "store", "m", "ls", "vs", "sports", "ms", "gs", "b", "e", "ports", "js", "ats", "its", "sa", "ims", "locks", "spec", "g", "services", "j", "sq", "t", "ds", "actions", "se", "states", "cs", "ts", "is", "a", "sm", "o", "y", "stats", "f", "ins", "source", "w", "ns", "sts"]}}
{"project": "qemu", "commit_id": "dd09c36159858c66ab6e47c688e4177dd3912bf0", "target": 1, "func": "static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    gen_read_xer(cpu_gpr[gprn]);\n\n}\n", "idx": 13118, "substitutes": {"ctx": ["pkg", "context", "CC", "voc", "tmp", "txt", "tx", "px", "cmp", "cm", "np", "c", "cp", "xc", "cb", "conf", "hw", "Context", "mc", " context", "tc", "js", "cc", "conn", "ct", " cx", "ca", "wd", "obj"], "gprn": ["gstrn", "gpirnb", "gprt", " gprnr", "gprN", "mprn", "gsprnb", "msprn", "mprN", "msprN", " gprt", "gplm", " gpirn", "gstrnb", "mprm", "gplN", "gvrn", "gsprl", "gsprm", "gsprnr", "gstrt", "msprl", "gprm", "gpirt", "gprnr", "gpirnr", "gpln", "gprnb", "gvrN", "gstrnr", "msprm", "gpirn", " gpirnr", "gvrl", " gpirnb", " gpirt", "gvrm", " gprnb", "gsprn", "gsprN", "mprl", "gprl", "gpll", "gsprt"], "sprn": [" sprN", "svn", "prn", "prnm", " sprno", "svN", "prN", "sprnm", "sprno", "svnm", "svno", "prno", "sprN", " sprnm"]}}
{"project": "qemu", "commit_id": "f3c75d42adbba553eaf218a832d4fbea32c8f7b8", "target": 1, "func": "static int cpu_load_old(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    PowerPCCPU *cpu = opaque;\n\n    CPUPPCState *env = &cpu->env;\n\n    unsigned int i, j;\n\n    target_ulong sdr1;\n\n    uint32_t fpscr;\n\n    target_ulong xer;\n\n\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->gpr[i]);\n\n#if !defined(TARGET_PPC64)\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->gprh[i]);\n\n#endif\n\n    qemu_get_betls(f, &env->lr);\n\n    qemu_get_betls(f, &env->ctr);\n\n    for (i = 0; i < 8; i++)\n\n        qemu_get_be32s(f, &env->crf[i]);\n\n    qemu_get_betls(f, &xer);\n\n    cpu_write_xer(env, xer);\n\n    qemu_get_betls(f, &env->reserve_addr);\n\n    qemu_get_betls(f, &env->msr);\n\n    for (i = 0; i < 4; i++)\n\n        qemu_get_betls(f, &env->tgpr[i]);\n\n    for (i = 0; i < 32; i++) {\n\n        union {\n\n            float64 d;\n\n            uint64_t l;\n\n        } u;\n\n        u.l = qemu_get_be64(f);\n\n        env->fpr[i] = u.d;\n\n    }\n\n    qemu_get_be32s(f, &fpscr);\n\n    env->fpscr = fpscr;\n\n    qemu_get_sbe32s(f, &env->access_type);\n\n#if defined(TARGET_PPC64)\n\n    qemu_get_betls(f, &env->spr[SPR_ASR]);\n\n    qemu_get_sbe32s(f, &env->slb_nr);\n\n#endif\n\n    qemu_get_betls(f, &sdr1);\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->sr[i]);\n\n    for (i = 0; i < 2; i++)\n\n        for (j = 0; j < 8; j++)\n\n            qemu_get_betls(f, &env->DBAT[i][j]);\n\n    for (i = 0; i < 2; i++)\n\n        for (j = 0; j < 8; j++)\n\n            qemu_get_betls(f, &env->IBAT[i][j]);\n\n    qemu_get_sbe32s(f, &env->nb_tlb);\n\n    qemu_get_sbe32s(f, &env->tlb_per_way);\n\n    qemu_get_sbe32s(f, &env->nb_ways);\n\n    qemu_get_sbe32s(f, &env->last_way);\n\n    qemu_get_sbe32s(f, &env->id_tlbs);\n\n    qemu_get_sbe32s(f, &env->nb_pids);\n\n    if (env->tlb.tlb6) {\n\n        // XXX assumes 6xx\n\n        for (i = 0; i < env->nb_tlb; i++) {\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].pte0);\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].pte1);\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].EPN);\n\n        }\n\n    }\n\n    for (i = 0; i < 4; i++)\n\n        qemu_get_betls(f, &env->pb[i]);\n\n    for (i = 0; i < 1024; i++)\n\n        qemu_get_betls(f, &env->spr[i]);\n\n    ppc_store_sdr1(env, sdr1);\n\n    qemu_get_be32s(f, &env->vscr);\n\n    qemu_get_be64s(f, &env->spe_acc);\n\n    qemu_get_be32s(f, &env->spe_fscr);\n\n    qemu_get_betls(f, &env->msr_mask);\n\n    qemu_get_be32s(f, &env->flags);\n\n    qemu_get_sbe32s(f, &env->error_code);\n\n    qemu_get_be32s(f, &env->pending_interrupts);\n\n    qemu_get_be32s(f, &env->irq_input_state);\n\n    for (i = 0; i < POWERPC_EXCP_NB; i++)\n\n        qemu_get_betls(f, &env->excp_vectors[i]);\n\n    qemu_get_betls(f, &env->excp_prefix);\n\n    qemu_get_betls(f, &env->ivor_mask);\n\n    qemu_get_betls(f, &env->ivpr_mask);\n\n    qemu_get_betls(f, &env->hreset_vector);\n\n    qemu_get_betls(f, &env->nip);\n\n    qemu_get_betls(f, &env->hflags);\n\n    qemu_get_betls(f, &env->hflags_nmsr);\n\n    qemu_get_sbe32s(f, &env->mmu_idx);\n\n    qemu_get_sbe32(f); /* Discard unused power_mode */\n\n\n\n    return 0;\n\n}\n", "idx": 13130, "substitutes": {"f": ["uf", "fx", "h", "ff", "fs", "d", "l", "fp", "ft", "fm", "fa", "fac", "bf", "x", "full", "rf", "c", "q", "conf", "xf", "p", "fo", "tf", "fb", "b", "e", "of", "mac", "fi", "af", "fe", "fd", "um", "cf", "lf", "g", "fr", "sf", "ef", "t", "fw", "file", "fc", "ac", "v", "base", "y", "F", "form", "w"], "opaque": ["Opistine", "iopacity", "oplaque", " Opistine", "opcow", "cocow", "coaques", "coque", " Opaque", "Opacity", "pque", "pcow", "oplaques", "Opaques", "opque", "iopaque", "opistine", "paque", "oplcow", "opacity", "opaques", "oplque", "coaque", "paques", "iopaques", "iopistine", " Opacity", "Opaque", " Opaques"], "version_id": [" version_type", "version_type", "version_uid", "version_i", " version_i", " version_uid"], "cpu": ["device", "clock", "cache", "asus", "pc", "gpu", "uma", "alloc", "node", "pa", "util", "pool", "pu", "apache", " cp", "processor", "cp", "c", "cu", "core", "np", "p", "ram", "pb", "bench", "flow", "ork", "tp", "boot", "ctx", "gc", "nic", "ola", "conn", "anc", "proc", "aco", "CPU", "net", "rom", "stat", "process", "vm"], "env": ["ote", "server", "nv", "eng", "org", "et", "der", "engine", "den", "param", "ef", "esc", "inv", "ende", "vm", "event", "context", "worker", "end", "eve", "txt", "next", "er", "operator", "vp", "ah", "common", "vt", "eh", "erd", "w", "era", "ten", "disk", "conn", "en", "enc", "order", "eur", "Environment", "cmd", "policy", "doc", "eas", "req", "menu", "opt", "buf", "ext", "uv", "kernel", "vs", "console", "viron", "ent", "cookie", "agent", "ev", "ew", "eni", "stage", "ec", "ea", "goal", "runner", "extra", "cur", "ern", "global", "conf", "environment", "ei", "desc", "ner", "entry", "e", "dev", "window", "db", "network", "estate", "ctx", "spec", "manager", "el", "gear", "chart", "attr", "vv", "config", "equ", "v", "obj", "ener"], "i": [" ki", "k", "status", "ski", "cli", "gu", "this", "oi", "asi", "my", "uli", " ii", "it", "g", "ci", "ie", "ex", "ki", "zi", "mi", "y", " li", "info", "ii", " di", "ij", "init", "iy", "hi", "set", "m", "ri", "any", "name", "ia", "multi", "loop", "xi", "try", "t", "ix", "is", "ui", "ini", "qi", "ind", "l", "jp", "ai", "di", "x", "c", "q", " bi", "ti", "li", "you", "\u0438", "I", "err", "si", "batch", "key", "in", "ims", "index", "ity", "phi", "o", "pi", "bi", "io", "iq", "n", "gi", "z", "point", "sim", "ip", "depth", "ei", "p", "list", "us", "e", "chain", "ami", "iu", "id", "me", "ic", "span", "v", " ti"], "j": ["jp", "ii", "ji", "n", "k", "z", "ij", "q", "li", "p", "jj", "si", "m", "b", "ja", "js", "ni", "g", "it", "uj", "kj", "J", "jc", "o", "v", "bi", "jl"], "sdr1": ["tsDR2", "tsDR0", "shr01", "sDR2", "tsdr1", "SDr1", "SDr01", "Sdr01", "shr1", "slr0", "Sdr1", "sdr2", "slr1", "sDr01", "slr6", "sDR1", "sdr0", "sDR0", "sDr6", "sDR6", "Sdr2", "tsdr0", "sDr0", "sdr01", "slr2", "sdr6", "SDr2", "tsDR6", "shr2", "tsdr6", "tsDR1", "sDr2", "tsdr2", "sDr1"], "fpscr": ["bpscl", "bpssr", "mssr", "fpsCr", "fscl", "mscr", "interscr", "framesrc", "fscu", "interscl", "interscu", " fpskr", "fsci", "fpscu", "bpscd", "bpsdr", "framessr", "framespr", " fpssr", "fpsdr", "gradescd", "msCr", "fpskr", "bpsrc", "bpsci", "fpssr", "gradesrc", " fpsCr", "fscd", "fpspr", "framescr", "fpscl", "ampssr", "fpsci", "fscr", "bpscu", "gradescr", "bpskr", "ampsrc", "fsrc", "gradesci", "ampspr", "fpsrc", "fsdr", "bpspr", "bpscr", "fpscd", "ampscr", "bpsCr", "mskr", "intersdr"], "xer": ["ixer", "ixerer", " xeri", "xiner", "xe", " lexe", " lexeri", " xER", "Xor", "ixor", "lexiner", "xER", "plexer", "lexerer", "lexER", "xter", "plexiner", "ixiner", "xeri", "plexER", "uploade", "Xer", " xe", " lexER", " xter", "Xter", "ixER", "xor", "XER", " xor", "uploadER", "xerer", " lexer", "uploader", "lexer", "ixter", "plexerer", "uploaderi"], "u": ["uf", "eu", "l", "ut", "tu", "ou", "out", "util", "pu", "nu", "c", "hu", "cu", "ul", "q", "p", "uv", "uid", "us", "fu", "iu", "g", "um", " nu", "su", "ud", "lu", "U", "t", "du", "au", "uc", "o", "ue", "v", "ui", "user", "uu", "up", "mu"]}}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoul_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 13136, "substitutes": {"str": ["i", "ind", "stri", "end", "txt", "br", "out", "STR", "buf", "input", "st", "ext", "s", "arr", "r", "start", "list", "ptr", "tr", "Str", "pos", "b", "chain", "buffer", "len", "sp", "index", "g", "res", "fr", "data", "msg", "seq", "inst", "ctr", "t", "attr", "test", "gr", "source", "text", "f", "length", "doc"], "endptr": ["enderinst", "ENDpointer", "endedobj", "startinst", "endinst", "endref", "endpointer", "hendobj", " endcert", "enderref", " endpointer", "endedPtr", "Endpointer", "startref", "endedaddr", "endedcert", "startptr", "hendPtr", "hendcert", "enderpointer", "ENDptr", "hendptr", "enderptr", " endref", "Endptr", "ENDaddr", "EndPtr", "endPtr", "endedptr", "ENDPtr", "endcert", "endobj", "endedpointer", "Endaddr", " endobj", " endPtr", " endinst", "startpointer", "endaddr"], "err": ["i", "rel", "usr", " len", " cr", "Error", " wr", " ni", " ptr", "here", "br", "error", "cmp", " typ", " dist", "result", " er", "er", "arr", "r", " gr", "ptr", " rc", "tr", "dr", " r", " fr", "e", "rc", "rr", "iter", "nr", "der", " arr", "g", "res", "act", "fr", "msg", " intr", "proc", "attr", "gr", " terr", " Err", "pr", "resp", " res", "acc", "cmd", " error", "cr", "errors", "kr", "lr", "diff", "Er", "viol", " dr"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "static void avc_luma_midv_qrt_4w_msa(const uint8_t *src, int32_t src_stride,\n\n                                     uint8_t *dst, int32_t dst_stride,\n\n                                     int32_t height, uint8_t ver_offset)\n\n{\n\n    uint32_t loop_cnt;\n\n    v16i8 src0, src1, src2, src3, src4;\n\n    v16i8 mask0, mask1, mask2;\n\n    v8i16 hz_out0, hz_out1, hz_out2, hz_out3;\n\n    v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8;\n\n    v8i16 dst0, dst1, dst2, dst3, dst4, dst5, dst6, dst7;\n\n\n\n    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n\n\n    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src0, src1,\n\n                                                          mask0, mask1, mask2);\n\n    hz_out2 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3,\n\n                                                          mask0, mask1, mask2);\n\n\n\n    PCKOD_D2_SH(hz_out0, hz_out0, hz_out2, hz_out2, hz_out1, hz_out3);\n\n\n\n    hz_out4 = AVC_HORZ_FILTER_SH(src4, mask0, mask1, mask2);\n\n\n\n    for (loop_cnt = (height >> 2); loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src0, src1, src2, src3);\n\n        src += (4 * src_stride);\n\n        XORI_B4_128_SB(src0, src1, src2, src3);\n\n\n\n        hz_out5 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src0, src1,\n\n                                                              mask0, mask1,\n\n                                                              mask2);\n\n        hz_out7 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3,\n\n                                                              mask0, mask1,\n\n                                                              mask2);\n\n\n\n        PCKOD_D2_SH(hz_out5, hz_out5, hz_out7, hz_out7, hz_out6, hz_out8);\n\n\n\n        dst0 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out0, hz_out1, hz_out2,\n\n                                               hz_out3, hz_out4, hz_out5);\n\n        dst2 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out1, hz_out2, hz_out3,\n\n                                               hz_out4, hz_out5, hz_out6);\n\n        dst4 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out2, hz_out3, hz_out4,\n\n                                               hz_out5, hz_out6, hz_out7);\n\n        dst6 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5,\n\n                                               hz_out6, hz_out7, hz_out8);\n\n\n\n        if (ver_offset) {\n\n            dst1 = __msa_srari_h(hz_out3, 5);\n\n            dst3 = __msa_srari_h(hz_out4, 5);\n\n            dst5 = __msa_srari_h(hz_out5, 5);\n\n            dst7 = __msa_srari_h(hz_out6, 5);\n\n        } else {\n\n            dst1 = __msa_srari_h(hz_out2, 5);\n\n            dst3 = __msa_srari_h(hz_out3, 5);\n\n            dst5 = __msa_srari_h(hz_out4, 5);\n\n            dst7 = __msa_srari_h(hz_out5, 5);\n\n        }\n\n\n\n        SAT_SH4_SH(dst1, dst3, dst5, dst7, 7);\n\n\n\n        dst0 = __msa_aver_s_h(dst0, dst1);\n\n        dst1 = __msa_aver_s_h(dst2, dst3);\n\n        dst2 = __msa_aver_s_h(dst4, dst5);\n\n        dst3 = __msa_aver_s_h(dst6, dst7);\n\n\n\n        PCKEV_B2_SB(dst1, dst0, dst3, dst2, src0, src1);\n\n        XORI_B2_128_SB(src0, src1);\n\n\n\n        ST4x4_UB(src0, src1, 0, 2, 0, 2, dst, dst_stride);\n\n\n\n        dst += (4 * dst_stride);\n\n        hz_out0 = hz_out4;\n\n        hz_out1 = hz_out5;\n\n        hz_out2 = hz_out6;\n\n        hz_out3 = hz_out7;\n\n        hz_out4 = hz_out8;\n\n    }\n\n}\n", "idx": 13137, "substitutes": {"src": ["pkg", "dist", "usr", "rs", "sn", "comp", "std", "sb", "serv", "tmp", "sl", "txt", "lat", "cur", "depth", "input", "addr", "dest", "hz", "st", "sub", "loc", "s", "sys", "scan", "ptr", "img", "rx", "ser", "tr", "syn", "in", "seek", "sur", "rc", "sec", "tp", "hl", "rl", "sq", "supp", "iv", "sr", "seq", "inst", "ctr", "ix", "fc", "sc", "source", "rt", "stat", "ins", "sync", "RC", "ipl"], "src_stride": ["src_collride", "src_collice", "src_strpe", "src_slride", "src_STRice", "src_frpe", "src_STRider", "src_slider", "src_grope", "src_drider", "src_slision", "src_STRision", "src_divid", "src_grpe", "src_divide", "src_divride", "src_trice", "src_frope", "src_STRpe", "src_strride", "src_strope", "src_STRid", "src_strision", "src_strice", "src_bride", "src_STRide", "src_drice", "src_drision", "src_drade", "src_frride", "src_trride", "src_gride", "src_dride", "src_fride", "src_divice", "src_STRride", "src_collide", "src_collade", "src_tride", "src_drride", "src_strid", "src_trid", "src_strade", "src_strider", "src_STRope", "src_grride", "src_slide", "src_brice", "src_brade", "src_brride"], "dst": ["dest", "lsts", " dsts", "Dsts", "dsts", " dest", "Dst", "lest", " ddest", "lst", "ldest", "Dest", "ddest", "Ddest"], "dst_stride": ["dst_trend", "dst_trride", "dst_decate", "dst_brend", "dst_brate", "dst_tride", "dst_decride", "dst_strride", "dst_decide", "dst_trate", "dst_strate", "dst_decend", "dst_strend", "dst_bride", "dst_brride"], "height": ["shape", "h", "rank", "resolution", "kw", "angle", "th", "k", "radius", "padding", "history", "x", "hash", "headers", "depth", "density", "hz", "conf", "check", "capacity", "Height", "zh", "push", "flow", "read", "window", "chain", "count", "buffer", "block", "ctx", "size", "grow", "row", "scroll", "ctr", "bottom", "wcs", "y", "scope", "length", "w", "build"], "ver_offset": ["stream_offset", "ver2start", "verswstart", "ver2length", "ver_length", "stream_length", "verswlength", "ver_start", "ver2offset", "verswoffset", "stream_start"], "loop_cnt": ["loop_ctcount", "loop_rcount", "loop_rount", "loop_rcst", "loop2Cst", "loop_countcount", "loop_mcnt", "loop_cust", "loop_rnt", "loop_rst", "loop2Cct", "loop_rct", "loop_ctn", "loop_mcpt", "loop_Cst", "loop_cpt", "loop_Count", "loop_cNT", "loop_cn", "loop_Cct", "loop_Ccount", "loop2count", "loop_fcant", "loop2cant", "loop_mcant", "loop2Cpt", "loop2Count", "loop_rcnt", "loop_Cust", "loop_cant", "loop2cpt", "loop_Cant", "loop_count", "loop_fcNT", "loop_cct", "loop_fcpt", "loop_Cpt", "loop2cct", "loop_cst", "loop2cst", "loop_mcNT", "loop_rcct", "loop_ccount", "loop_ctnt", "loop2Cnt", "loop2cnt", "loop_Cn", "loop_CNT", "loop_Cnt", "loop_ctust", "loop2Cant", "loop_countust", "loop2cNT", "loop_countnt", "loop_fcnt", "loop_countn", "loop2CNT"], "src0": ["src00", "rc00", "source3", " src00", "source1", "rc2", "sr1", "source4", "sys2", "source5", "st2", "sys1", "st0", "src5", "sr0", "rc3", "rc0", "rc5", "source2", "rc1", "sys3", "st1", "sys0", "rc4", "st5", "source0", "sr00", "sr4"], "src1": ["sr2", "source3", "source1", "rc2", "sr11", "source11", "sr1", "source4", "sys2", "sys1", "sr01", "rc11", "sys4", "sr3", "rc3", "source2", "rc0", " src01", "rc1", "src01", "sys3", "rc01", "rc4", "src11", "source01", "source0", "sr4"], "src2": ["sr2", "source3", "src02", "ser6", "source1", "rc2", "sr1", "source4", "sys2", "source5", "srTwo", "source6", "src5", "sr02", "rc02", "sr3", "src6", "rc3", "source2", "rc5", "ser4", "ser1", "rc1", "ser2", "rc6", "sys3", "sys02", "rcTwo", "srcTwo", "rc4", "sourceTwo", "sr5", "sys1"], "src3": ["src43", "source03", "sr2", "source3", "source1", "rc2", "sr43", "rc03", "ser3", "src03", "source5", "sr03", "addrThree", "s", "addr03", " src03", "src5", "addr2", "sr3", "rc3", "source2", "rc5", "srcThree", "rc0", "source43", "rc1", "ser2", "ser03", "serThree", "rcThree", "rc43", "addr3", "source0", "_", "sr5"], "src4": ["sr14", "inst464", "sr2", "sr4", "source3", "source1", "rc2", "sub464", "sub54", "rc14", "src14", "source4", "src40", "sc2", "sub4", "source14", "rc54", "source40", " src40", "sc6", "sr3", "src6", "sc4", "rc3", "src54", "source2", "inst4", "rc44", "rc1", "inst44", "rc6", " src6", "src44", "rc40", "rc4", "src464", "rc464", "inst54", "sub44"], "mask0": ["map1", "Mask1", " mask5", "Mask2", "map0", " mask8", "Mask0", "map2", "mask5", "mark5", "key5", "ask8", "mark1", "key2", "ask1", "key0", "ask0", "Mask5", "ask2", "mark2", "map8", "mask8", "mark0", "key1", "ask5"], "mask1": ["miss3", "perm1", "perm0", "ask4", " mask3", "mark1", "ask1", "miss1", "ask0", "mask4", "missOne", "ask2", "mark2", "miss2", "mark3", "miss4", "ask3", "mark0", " maskOne", "permOne", "mask3", "perm2", "maskOne", "miss0", " mask4"], "mask2": ["miss3", " mask8", "mark4", "ask4", "ask8", " mask3", "ask1", "miss1", "ask0", "mask4", "ask2", "miss8", "mark2", "miss2", "mark3", "miss4", "ask3", "mask8", "mark0", "mask3", "miss0", " mask4"], "hz_out0": ["hz_over0", "hz_over1", "hz_off5", "hz_off0", "hz_OUT7", "hz_no7", "hz_in5", "hz_Out0", "hz_OUT5", "hz_in7", "hz_no1", "hz_in1", "hz_OUT3", "hz_over5", "hz_Out3", "hz_off1", "hz_no0", "hz_OUT0", "hz_in0", "hz_no3", "hz_OUT1", "hz_Out1", "hz_in3"], "hz_out1": ["hz_output7", "hz_bit2", "hz_in2", "hztoutput5", "hz_output5", "hz_in5", "hztout1", "hz_in7", "hztoutput1", "hztout3", "hz_in1", "hz_outable", "hz_group3", "hztoutput7", "hz_bitable", "hz_group7", "hz_group1", "hz_output3", "hztoutput3", "hztout7", "hz_in0", "hz_inable", "hz_bit0", "hz_bit1", "hz_output1", "hz_in3", "hz_group5", "hztout5"], "hz_out2": ["hz_outs1", "hz__out2", "hz_in2", "hz_op3", "hz_in5", "hz__out3", "hz_inall", "hz_outall", "hz_in1", "hz__out5", "hz_outsall", "hz_output3", "hz_inner1", "hz_clean5", "hz_back2", "hz__op5", "hz_op5", "hz__op32", "hz_output2", "hz_out32", "hz_off3", "hz_clean32", "hz_output02", "hz_offall", "hz__op2", "hz_op2", "hz_clean2", "hz__out32", "hz_outs2", "hz_back1", "hz_op32", "hz__op3", "hz_off02", "hz_inb", "hz_innerb", "hz_in3", "hz_inner2", "hz_off4", "hz_out02", "hz_clean3", "hz_back5", "hz_off2", "hz_outs3", "hz_outb", "hz_output4", "hz_inner5", "hz_off1", "hz_backb"], "hz_out3": ["hz_OUT7", "hz_no03", "hz_in5", "hz_OUT5", "hz_in7", "hz_in1", "hz_OUT3", "hz_out03", "hz_no5", "hz_OUT03", "hz_no3", "hz_OUT1", "hz_in03", "hz_in3"], "hz_out4": ["hz_con1", "hz_in2", "hz_off4", "hz_con3", "hz_in8", "hz_in1", "hz_off3", "hz_off2", "hz_OUT4", "hz_OUT8", "hz_OUT2", "hz_off1", "hz_OUT1", "hz_in4", "hz_con2", "hz_in3", "hz_con4"], "hz_out5": ["hz_off5", "hz_output7", "hz_off6", "hz_output5", "hz_output8", "hz_output6", "hz_off8", "hz_off7"], "hz_out6": ["hz_output7", "hz_over7", "hz_over6", "hz_output6", "hz_overSix", "hz_output2", "hz_outputSix", "hz_outSix", "hz_over2"], "hz_out7": ["hz_out9", "hz_output7", "hz_outr", "hz_output6", "hz_netr", "hz_net6", "hz_net7", "hz_output9", "hz_net9", "hz_outputr"], "hz_out8": ["hz_in7", "hz_in8", "hz_in6", "hz_int7", "hz_int6", "hz_int8"], "dst0": ["lst5", "dstop3", "lest0", "lst1", "lest3", "lst0", "dset5", "dest1", "dstop5", "dstop0", "dest5", "dset3", "dset0", "dest3", "dest0", "lst3", "dstop1", "dset1", "lest5", "lest1"], "dst1": ["dstr001", "dest001", "Dst001", "dstr1", "Dest1", "dst001", "Dest71", "Dst71", "Dst1", "ddist1", "dest1", "dest71", "Dest0", "dst71", "dest0", "Dest001", "dstr71", "ddist71", "dstr0", "ddist001", "ddist0", "Dst0"], "dst2": ["dset2", " dst02", " dset02", "dest02", "dest4", "dest2", "dna2", "dna4", "dset02", "dst02", "dset4", "dset0", "dest0", " dset4", "dna0", " dset2", "dna02", " dset0"], "dst3": ["drest23", "ddest3", "ddest2", "ddest23", "dest4", "dest23", " ddest4", "dest2", " ddest3", "drest3", "dst23", "drest4", " dst23", "ddest4", "dest3", " ddest23", " ddest2", "drest2"], "dst4": ["dstart2", "dst414", "dstore2", "ddest2", "dstCrit", " ddest4", "dstart4", " ddest414", "ddest414", "ddest4", " dst414", "dstore4", "ddestCrit", "dstoreCrit", " dstCrit", "dstart414", " ddestCrit", " ddest2", "dstore414", "dstartCrit"], "dst5": [" dsp8", "dST7", "dsp8", "dsp25", "dst25", "dstr7", "dST8", " dsp7", " dst8", "dst8", " dsp5", "dsp5", "dstr8", "dstr5", "dsp7", "dST25", "dST5", "dstr25", " dsp25", " dst25"], "dst6": ["dST6", "dST4", " dint8", "dest8", "dint4", "dest4", "dST12", "dST8", " dint4", " dint6", "dint12", "dest12", " dst8", " dst12", "dst8", "dst12", "dest6", " dint12", "dint8", "dint6"], "dst7": [" dsp8", "ddest07", "dsp8", " dsp1", "ddest8", "dest8", "dest07", " dsp7", "dest7", "dest1", " dsp07", "ddest7", " dst8", "dst8", "dsp07", " dst07", "dsp7", "dsp1", "dst07", "ddest1"]}}
{"project": "qemu", "commit_id": "afcf905cff7971324c2706600ead35a1f41f417a", "target": 1, "func": "static void aml_free(gpointer data, gpointer user_data)\n\n{\n\n    Aml *var = data;\n\n    build_free_array(var->buf);\n\n\n}", "idx": 13140, "substitutes": {"data": ["device", "d", "info", "ref", "type", "reader", "bytes", "map", "Data", "DATA", "buf", "ata", "mu", "p", "batch", "empty", "ptr", "name", "read", "dev", "array", "db", "window", "buffer", "instance", "str", "ad", "bin", "attr", "pad", "val", "all", "table", "rec", "obj", "user", "area", "dat", "da"], "user_data": [" useruserdat", " user_dat", " useruserdata", "user_dat", "useruserdat", " useruserbuffer", "useruserdata", "useruserbuffer", "user_buffer", " user_buffer"], "var": ["let", "type", "bar", "av", "map", "art", "node", "ars", "temp", "local", "buf", "tab", "cat", "ar", "ver", "p", "tag", "r", "store", " Var", "ptr", "cast", "star", "name", "vard", "array", "iter", "parse", "box", "nav", "variable", "row", "mod", " variable", "func", "pack", "attr", "live", "grad", "Var", "val", "v", "par", "obj"]}}
{"project": "qemu", "commit_id": "36b15c79aa1bef5fe7543f9f2629b6413720bbfb", "target": 0, "func": "static void virtio_scsi_handle_cmd(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    /* use non-QOM casts in the data path */\n\n    VirtIOSCSI *s = (VirtIOSCSI *)vdev;\n\n    VirtIOSCSICommon *vs = &s->parent_obj;\n\n\n\n    VirtIOSCSIReq *req;\n\n    int n;\n\n\n\n    while ((req = virtio_scsi_pop_req(s, vq))) {\n\n        SCSIDevice *d;\n\n        int out_size, in_size;\n\n        if (req->elem.out_num < 1 || req->elem.in_num < 1) {\n\n            virtio_scsi_bad_req();\n\n        }\n\n\n\n        out_size = req->elem.out_sg[0].iov_len;\n\n        in_size = req->elem.in_sg[0].iov_len;\n\n        if (out_size < sizeof(VirtIOSCSICmdReq) + vs->cdb_size ||\n\n            in_size < sizeof(VirtIOSCSICmdResp) + vs->sense_size) {\n\n            virtio_scsi_bad_req();\n\n        }\n\n\n\n        if (req->elem.out_num > 1 && req->elem.in_num > 1) {\n\n            virtio_scsi_fail_cmd_req(req);\n\n            continue;\n\n        }\n\n\n\n        d = virtio_scsi_device_find(s, req->req.cmd->lun);\n\n        if (!d) {\n\n            req->resp.cmd->response = VIRTIO_SCSI_S_BAD_TARGET;\n\n            virtio_scsi_complete_req(req);\n\n            continue;\n\n        }\n\n        req->sreq = scsi_req_new(d, req->req.cmd->tag,\n\n                                 virtio_scsi_get_lun(req->req.cmd->lun),\n\n                                 req->req.cmd->cdb, req);\n\n\n\n        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {\n\n            int req_mode =\n\n                (req->elem.in_num > 1 ? SCSI_XFER_FROM_DEV : SCSI_XFER_TO_DEV);\n\n\n\n            if (req->sreq->cmd.mode != req_mode ||\n\n                req->sreq->cmd.xfer > req->qsgl.size) {\n\n                req->resp.cmd->response = VIRTIO_SCSI_S_OVERRUN;\n\n                virtio_scsi_complete_req(req);\n\n                continue;\n\n            }\n\n        }\n\n\n\n        n = scsi_req_enqueue(req->sreq);\n\n        if (n) {\n\n            scsi_req_continue(req->sreq);\n\n        }\n\n    }\n\n}\n", "idx": 13149, "substitutes": {"vdev": [" vdiv", "vtech", " vdevice", "vcdev", "vmdev", "vcpad", "wdevice", "vctech", "wserial", "vmpad", " vtech", "vmtech", "vpad", "vmdiv", "avserv", "avserial", "vcdiv", "vserial", " vserial", "avdev", "wserv", "vdevice", "wdev", "vserv", " vserv", " vpad", "avdevice", "vdiv"], "vq": ["wreq", "veue", " vqi", "vQ", "vqs", "svreq", "veq", " vue", "Vq", "Vqi", " vqs", "veQ", "vqi", " vQ", "svqs", "wqueue", " vreq", "svqueue", "wqs", "vqueue", "vue", "VQ", "veqi", "vreq", "wq", "Vue", "svq", " vqueue"], "s": ["bs", "i", "h", "fs", "rs", "sb", "serv", "ses", "ies", "S", "os", "sv", "c", "ps", "p", "sys", "ess", "si", "r", "m", "ls", "hs", "ms", "news", "gs", "b", "dev", "js", "iss", "its", "sp", "spec", "sts", "g", "sq", "less", "ys", "gets", "t", "ds", "self", "cs", "ts", "is", "v", "y", "ns", "ss"], "vs": ["bs", "vc", "fs", "rs", "changes", "serv", "ops", "terms", "os", "ves", "views", "sv", "ps", "ires", "Rs", "sys", "obs", "ls", "vp", "outs", "xs", "ms", "gs", "news", "its", "js", "VS", "vt", "Vs", "vals", "caps", "values", "nets", "ys", "ds", "vr", "cs", "ils", "inv", "v", "stats", "var", "docs", "vm", "vo", "ns", "lists", "ss"], "req": ["pkg", "requ", "bj", "gz", "cmp", "cb", "org", "r", "urg", "ptr", "qa", "nil", "push", "eq", "rr", "Resp", "require", "quest", "expr", "inv", "all", "needed", "term", "rem", "rep", "tmp", "ck", "txt", "alg", "pro", "tek", "cfg", "good", "repl", "rss", "request", "ack", "sp", "res", "j", "msg", "fr", "resp", "cmd", "query", "rel", "ind", "jp", "prefix", "rb", "compl", "buf", "q", "exec", "comm", "ext", "err", "nt", " resp", "decl", "job", "range", "sq", "seq", "dq", "proc", "required", "prev", "cond", "wcs", "pp", "rec", "var", "aux", "call", "iq", "xp", "ref", "comp", "progress", "tx", "task", "reg", "rpm", "conf", "sel", "desc", "qq", "md", "ctx", "fresh", "grab", "ctr", "test", "quick", "crit", "gr", "wx", "qt"], "n": ["h", " len", "l", " N", "k", "z", "c", "p", "m", "nm", "ne", "N", "name", "b", "e", "count", "len", " nm", "g", " count", "nb", "t", "o", "v", "y", "ation", "w", "ns"], "d": ["dn", "gd", "h", "i", "ind", "l", "dm", "dx", "dom", "k", "z", "di", "x", "out", "c", "u", "did", "dh", "ed", "bd", "p", "r", "m", "dr", "b", "e", "dev", "db", "md", "des", "dd", "fd", "id", "D", "g", "j", "ad", "sd", "data", "dq", "t", "ds", "dos", "du", "o", "ld", "a", "v", "y", "f", "w", "dat"], "out_size": ["to64size", "out_storage", "to_Size", "out67weight", "outlenlen", "out64set", "outputxheight", "to64fee", "output_height", "output_length", "out_fee", "out_height", "out67length", "out_len", "out_length", "outxheight", "out67height", "to64set", "out_set", "out_Size", "out64size", "output_weight", "outlenSize", "to_size", "out0length", "out0height", "outputxsize", "in_storage", "outlensize", "outxweight", "outxsize", "to_set", "out67Size", "to_fee", "out67fee", "out64Size", "output_size", "out_weight", "to64Size", "out64fee", "outlenstorage", "outputxweight", "out67size", "out0size", "outxlength", "outputxlength", "out67set", "in_len", "in_Size", "out0weight"], "in_size": ["in_format", "in_SIZE", "inner64size", "in64cache", "inner_size", "in64name", "in67Size", "injsize", "in_name", "in67size", " in_len", " in_weight", "injspeed", " in_format", " in_sent", "inner_cache", "in64size", " in_SIZE", "inner64cache", "in_speed", "in68weight", "in68sent", "in64speed", "injname", "injcache", "in68size", "in67format", "in68SIZE", "in_weight", "inner_speed", " in_Size", "inner64speed", "in_cache", "inner_name", "in_sent", "inner64name", "in_len", "in_Size", "in67len"]}}
{"project": "qemu", "commit_id": "d82831dbc5471d72785c49b33710436af49bf9ca", "target": 0, "func": "CharDriverState *text_console_init(QemuOpts *opts)\n\n{\n\n    CharDriverState *chr;\n\n    QemuConsole *s;\n\n    unsigned width;\n\n    unsigned height;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    width = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (width == 0)\n\n        width = qemu_opt_get_number(opts, \"cols\", 0) * FONT_WIDTH;\n\n\n\n    height = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (height == 0)\n\n        height = qemu_opt_get_number(opts, \"rows\", 0) * FONT_HEIGHT;\n\n\n\n    if (width == 0 || height == 0) {\n\n        s = new_console(NULL, TEXT_CONSOLE);\n\n    } else {\n\n        s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE);\n\n    }\n\n\n\n    if (!s) {\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n\n\n    s->chr = chr;\n\n    s->g_width = width;\n\n    s->g_height = height;\n\n    chr->opaque = s;\n\n    chr->chr_set_echo = text_console_set_echo;\n\n    return chr;\n\n}\n", "idx": 13154, "substitutes": {"opts": ["OPs", "oppds", "prots", "oppouts", "optionts", "ioptx", "ott", "opnt", "opt", "iopts", "royt", "optps", "ops", "OPts", "opTS", "OPTS", "optds", "royts", "otTS", "ots", "optiontions", "OPouts", "OPnt", "optouts", "royTS", "opds", "options", "OPds", "optionnt", "optts", "protx", "prors", "oppts", "optvals", "otds", "royvals", "oprs", "optt", "iopps", "otts", "props", "opps", "optx", "opttx", "optTS", "OPtions", "optrs", "otvals", "optnt", "opouts", "ioprs", "opvals", "opttions"], "chr": ["cherr", "echrar", "cherrb", " chR", "chrd", "thrb", "chear", "cherp", "cher", "achrb", "echrs", "echar", "CHrb", "chro", "thrc", "tchrt", "Chp", "ichrar", " chrt", "achR", "cherner", "ichr", "shrd", "Chrc", "Chrb", " chner", "chrs", "chl", "echrc", "ichro", "chner", "thr", "schsr", "Char", "schrb", "achr", "chrar", "CHr", "chrt", "achro", "achrt", "shro", "schr", "echr", "tchrb", "achrd", " chrs", "echrt", "shrt", "Chner", " chrar", "achl", "chrb", "schar", "chsr", "ichrb", "CHR", "shr", "tchr", "Chr", "echrb", "Chsr", "chrc", " chp", "chp", "chR", " chrb", "tchrar", "cherc", " chrc", " chsr", "ichrc", "ichrd", "thsr", "chers", "achrc", " chl", "achrar", "CHl", "ichrt"], "s": ["bs", "h", "aunts", "fs", "i", "l", "rs", "sb", "n", "sl", "ops", "ses", "conv", "S", "als", "bes", "os", "sv", "c", "comm", "ps", "p", "sys", "r", "socket", "es", "ssl", "m", "ls", "sports", "vs", "hs", "aws", "ms", "gs", "ats", "b", "its", "js", "ims", "sts", "spec", "w", "bis", "g", "services", "sq", "https", "less", "gets", "acs", "t", "ds", "se", "cs", "ts", "is", "a", "o", "v", "ins", "stats", "qs", "f", "ns", "ss"], "height": ["details", "shape", "h", "rank", "ch", "resolution", "angle", "th", "ty", "SIZE", "style", "radius", "padding", "history", "holes", "lat", "above", "draw", "title", "hash", "strength", "depth", "density", "heads", "capacity", "Height", "through", "hang", "read", "dim", "window", "gravity", "count", "xy", "no", "total", "volume", "note", "buffer", "size", "it", "html", "rows", "help", " heights", "grow", "range", "row", "data", "inches", "stroke", "bottom", "hei", "ows", "sky", "y", "high", "table", "all", "length", "ht", "hold", "build", "yt", "alpha"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    EEPRO100State *s = opaque;\n\n\n\n    switch (size) {\n\n    case 1: return eepro100_read1(s, addr);\n\n    case 2: return eepro100_read2(s, addr);\n\n    case 4: return eepro100_read4(s, addr);\n\n    default: abort();\n\n    }\n\n}\n", "idx": 13155, "substitutes": {"opaque": ["operacity", " opatile", "OPaques", "OPaque", "opue", "Opane", " opaques", "opane", "iopatile", "iopque", "Opacity", "operaque", "Opue", "operue", "opque", "operane", "iopaque", "OPatile", "opacity", "opatile", " opacity", " opque", "opaques", "OPque", " opane", "iopaques", " opue", "Opaque"], "addr": ["h", "info", "ord", "rs", "address", "asm", "ag", "Address", "alloc", "added", "tx", "node", "hash", "gz", "state", "src", "hw", "dh", "adr", "p", "r", "add", "ptr", "host", "dr", "handle", "now", "name", "pos", "alt", "iter", "block", "arch", "ctx", "eth", "ack", "id", "at", "kt", "res", "ad", "offset", "msg", "data", "gate", " address", "mt", "coord", "phys", "grad", "ix", "pad", "cmd", "var", "arp"], "size": ["shape", "ize", "sum", "l", "type", "sn", "address", "n", "SIZE", "style", "format", "small", "state", "number", "dimension", "sha", "scale", "weight", "message", "capacity", "code", "count", "network", "len", "unit", "offset", "num", "grow", "ity", "zone", "fee", "align", "Size", "command", "scope", "length", "shift"], "s": ["i", "h", "fs", "rs", "sb", "n", "sl", "S", "os", "space", "ar", "c", "q", "sv", "st", "comm", "p", "set", "an", "es", "ssl", "m", "ls", "sam", "hs", "ms", "gs", "iss", "js", "al", "sts", "sp", "spec", "w", "g", "j", "sq", "sw", "less", "ex", "ds", "ts", "is", "a", "sm", "o", "y", "stat", "qs", "ns", "ss"]}}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "bool vring_should_notify(VirtIODevice *vdev, Vring *vring)\n\n{\n\n    uint16_t old, new;\n\n    bool v;\n\n    /* Flush out used index updates. This is paired\n\n     * with the barrier that the Guest executes when enabling\n\n     * interrupts. */\n\n    smp_mb();\n\n\n\n    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&\n\n        unlikely(!vring_more_avail(vdev, vring))) {\n\n        return true;\n\n    }\n\n\n\n    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {\n\n        return !(vring_get_avail_flags(vdev, vring) &\n\n                 VRING_AVAIL_F_NO_INTERRUPT);\n\n    }\n\n    old = vring->signalled_used;\n\n    v = vring->signalled_used_valid;\n\n    new = vring->signalled_used = vring->last_used_idx;\n\n    vring->signalled_used_valid = true;\n\n\n\n    if (unlikely(!v)) {\n\n        return true;\n\n    }\n\n\n\n    return vring_need_event(vring_used_event(&vring->vr), new, old);\n\n}\n", "idx": 13156, "substitutes": {"vdev": ["vdoc", "verDEV", "vDEV", "verdev", "vgo", "volcast", "verobj", " vdevice", "verhome", " vobj", "vcev", " vcast", "voldev", "vhome", "hde", "vcast", "svhome", "vcdev", "vmdev", "svde", "vermem", "verde", "vobj", "dde", "volgo", "ddev", "sveng", "dev", "hscan", "svdev", "vmscan", "svmem", "voleng", "vmdevice", "svDEV", "svdoc", "vscan", "svobj", "vmde", "veng", " vpro", " vev", "vev", "vdevice", " vmem", " vhome", "vde", " vDEV", "vcpro", "hdev", " vdoc", "vcde", "svcast", " vscan", "verdoc", " veng", "vmem", "hdevice", " vgo", "vpro", " vde", "svgo", "dpro"], "vring": ["vebinding", "Vding", " vreg", "quring", "vprefix", "Vreg", "formding", "varning", "Vring", " vRing", "avring", "lray", "vthread", "vvprefix", "veding", " vanting", "vining", "vvring", "nthread", " vng", "portstar", "varsetting", "VRing", "uvray", " vining", "vvanting", "uvring", "vram", "vbox", "vering", " vpacking", "Vram", "veray", "varbox", " vsetting", "svbinding", "verbinding", "portthread", "vsetting", "convng", "veanting", "formanting", "svbox", "uvpacking", "nstar", "vanting", "portring", "obinding", " vram", "convRing", "uvining", "portbinding", "verding", "lRing", "vstar", " vbox", "svring", "vbinding", " vbinding", "nring", "svding", "veprefix", " vthread", "qubinding", "lreg", " vray", "avining", "svning", "convring", "vning", "oRing", " vning", "avray", "convram", "varring", "vRing", "vpacking", "lram", " vding", "vng", "lding", "vray", "formring", "Vng", "vvray", "verning", " vprefix", "lring", "svsetting", "vreg", "oray", "lbinding", "vding", " vstar", "oring", "avpacking", "quray", "nbinding", "formbinding", "quRing", "verring"], "old": ["uf", "igh", "un", "before", "i", "d", "ind", "l", "lower", "low", "ard", "orig", "last", " org", "tmp", "x", "off", "local", "ar", "ed", " low", " orig", "r", "from", "bound", "same", "read", "Old", "md", " Old", "al", "no", "existing", "id", "OLD", "lf", "back", "missing", "offset", "row", "en", "other", "ov", "used", "original", "older", "oved", "ld", "ob", "o", "f", "val", "or", "hold", "ore"], "new": ["un", "d", "or", "n", "New", "x", "only", "out", "next", "re", "added", "sv", "er", "create", "p", "set", "r", "from", "add", "update", "valid", "recent", "ren", "now", "ne", "news", "b", "no", "index", "to", "fresh", "size", "j", "ew", "missing", "latest", "normal", "t", "aw", "val", "var", "on", "w", "NEW", "current"], "v": ["i", "h", "d", "l", "tv", "ve", "av", "n", "V", "k", "z", "x", "out", "sv", "u", "q", "c", "p", "s", "uv", "r", "m", "valid", "b", "rev", "vt", "lv", "cv", "g", "it", "ev", "j", "iv", "qv", "ov", "t", "vv", "vert", "ig", "o", "inv", "f", "y", "w"]}}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static int amr_nb_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                               const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    AMRContext *s = avctx->priv_data;\n\n    int written, ret;\n\n    int16_t *flush_buf = NULL;\n\n    const int16_t *samples = frame ? (const int16_t *)frame->data[0] : NULL;\n\n\n\n    if (s->enc_bitrate != avctx->bit_rate) {\n\n        s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);\n\n        s->enc_bitrate = avctx->bit_rate;\n\n    }\n\n\n\n    if ((ret = ff_alloc_packet(avpkt, 32))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");\n\n        return ret;\n\n    }\n\n\n\n    if (frame) {\n\n        if (frame->nb_samples < avctx->frame_size) {\n\n            flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));\n\n            if (!flush_buf)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(flush_buf, samples, frame->nb_samples * sizeof(*flush_buf));\n\n            samples = flush_buf;\n\n            if (frame->nb_samples < avctx->frame_size - avctx->delay)\n\n                s->enc_last_frame = -1;\n\n        }\n\n        if ((ret = ff_af_queue_add(&s->afq, frame)) < 0) {\n\n            av_freep(&flush_buf);\n\n            return ret;\n\n        }\n\n    } else {\n\n        if (s->enc_last_frame < 0)\n\n            return 0;\n\n        flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));\n\n        if (!flush_buf)\n\n            return AVERROR(ENOMEM);\n\n        samples = flush_buf;\n\n        s->enc_last_frame = -1;\n\n    }\n\n\n\n    written = Encoder_Interface_Encode(s->enc_state, s->enc_mode, samples,\n\n                                       avpkt->data, 0);\n\n    av_dlog(avctx, \"amr_nb_encode_frame encoded %u bytes, bitrate %u, first byte was %#02x\\n\",\n\n            written, s->enc_mode, frame[0]);\n\n\n\n    /* Get the next frame pts/duration */\n\n    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,\n\n                       &avpkt->duration);\n\n\n\n    avpkt->size = written;\n\n    *got_packet_ptr = 1;\n\n    av_freep(&flush_buf);\n\n    return 0;\n\n}\n", "idx": 13163, "substitutes": {"avctx": ["avercontext", "avercb", "avercp", "averconn", "wavcontext", "avtx", "avecfg", "ajconn", "navcp", "apctl", "vrcontext", "devctl", "avcfg", " avcontext", "wavctl", "avecb", "savcomp", "avcf", "avecp", "wavhistory", "apcontext", "wavconn", "vergc", "apctx", "avegc", "savcontext", "abctl", "savcp", " avcf", "avtmp", "savhistory", "avca", "ajctx", "avkw", "avepkg", "vertx", " avgc", "vercontext", "afcontext", "avertmp", "avecu", "averctl", "afctl", "avpkg", "savctl", "vrtx", "averctx", "navctx", "aftx", "devtx", "avhistory", "navtmp", "avectx", " avconf", " avcp", "afctx", "wavkw", "aptx", " avpkg", "navcfg", "vrcu", " avconn", "wavcomp", "abtx", "averconf", "verctx", "avcu", "avercu", "avercomp", "ajca", "AVctx", "avcontext", "AVcfg", "afcf", "avercfg", "savctx", "avecontext", "abctx", "savkw", "averkw", "ajcfg", "AVtmp", "avcomp", "abtmp", "ajcontext", "avgc", "avetmp", "savconn", "avcp", "vrctx", "wavconf", " avcfg", "aveca", "afpkg", "wavcu", "devctx", " avcu", "ajcp", "avetx", " avctl", "savcu", "avctl", "averca", " avtx", "wavctx", "devtmp", "avertx", "AVtx", "avconf", "avconn", "ajtmp", "aveconn", "averhistory", "ajcb", "avecf", "avcb"], "avpkt": ["avpskg", "AVpkt", " avpdu", "awpft", "AVpacket", "avpdu", "avipkt", "avnpett", "avnpacket", "AVnpkt", "avpctx", "avnpctx", "avnpdu", "avpcvc", "avnpwd", "avpett", "AVnpwd", "avmkt", "avnpkt", "avnpvc", "avwpvc", "avpsft", "avnpft", "avmet", "avwpacket", "awnpkt", "avpcacket", "avpcwd", "avpkg", "avnpkg", "avwpwd", "AVnpvc", "avmctx", "avipett", "avwpkt", "awpett", " avpctx", "awpkt", "avmdu", "avcet", "avpskt", " avcctx", "avcctx", "avpft", "AVpvc", "avpwd", "AVnpacket", "avckt", " avckt", "awpkg", "avnpet", "avpvc", "awnpft", "avpckt", " avcet", "AVpwd", "avpacket", "awnpett", "avipkg", "avpet", "avcdu", "avpsett", " avcdu", " avpet", "avipft", "awnpkg"], "frame": ["send", "image", "header", "sequence", "error", "face", "message", "from", "close", "scene", "fb", "show", "offset", "feature", "ace", "function", "profile", "event", "context", "info", "expected", "package", "component", "Frame", "word", "draw", "next", "video", "force", "flow", "code", "buffer", "request", "size", "cf", "line", "fr", "zone", "open", "t", "file", "cmd", "f", "command", "length", "channel", "ime", "rame", "trace", "response", "block", "range", "frames", "data", "normal", "fram", "process", "queue", "time", "point", "state", "new", "ence", "raw", "e", "window", "none", "remote", "fe", "ce", "module", "feat", "row", "iframe", " framed", "sample", "output", "reset"], "got_packet_ptr": ["got_packet2pointers", "got_packettptr", "got_packacket_handle", "got_packetthandle", "got_packacket_ptr", "got_packet2ptr", "got_packet_pointer", "got_packacket_pointer", "got_packet_handle", "got_packettpointers", "got_packet2pointer", "got_packet_pointers", "got_packet2handle", "got_packacket_pointers", "got_packettpointer"], "s": ["bs", "fs", "space", "ps", "r", "args", "ms", "ports", "js", "sa", "g", "services", "sh", "sw", "utils", "se", "sc", "sm", "y", "ins", "h", "changes", "sb", "os", "als", "sv", "set", "ssl", "as", "sp", "j", "t", "is", "f", "ns", "l", "rs", "sl", "S", "so", "c", "st", "sys", "ess", "ls", "vs", "hs", "ats", "its", "ims", "sq", "ts", "a", "qs", "ss", "sts", "i", "ants", "settings", "z", "ses", "ar", "conf", "p", "es", "sam", "gs", "b", "spec", "less", "self", "ds", "cs", "v", "stats", "obj"], "written": ["printed", "finished", "writing", "rote", "created", "wrote", "bytes", "n", "called", "worked", "started", "connected", "rew", "led", "sent", "writ", "generated", "loaded", "read", "writer", "held", "ritten", "db", "cooked", "done", "changed", "msg", "built", "Writ", "found", "recorded", "ll", "write", "assembled", "itted", "checked", "Written", "encrypted", "w", "output", "initialized"], "ret": ["finished", "rel", "ft", "ref", "RET", "wrote", "elt", "last", "status", "success", "temp", "out", "re", "reply", "format", "value", "reg", "run", "Ret", "result", "ext", "del", "def", "arr", "err", "tr", "sent", "read", "mem", "alt", "att", "nt", "rev", "len", "fun", "cont", "it", "res", "str", "back", "after", "rot", "rm", "det", "mt", "gt", "try", "t", "ll", "fin", "rets", "write", " Ret", "get", "resp", "rt", "mel", "val", "print", "mat", "got", "reset", "rem"], "flush_buf": ["flush_bag", "send_buff", "flush_fam", "flush55cb", "reset_iter", "flush_mu", "flush_iter", "rubxbuff", "usher_cb", "export64buf", "flush2cap", " flush_cmd", "rubximg", "sync_buffer", " flush_pkg", "flush67pkg", "flushorbg", "export64bag", "flush64buf", "flush_addr", "rubxbuf", "export_bag", "flushxbg", "flushtmu", "flush64bag", "flush0queue", "flush55uf", "rub_buf", "flush2uf", "ush_mu", "flushmmbag", "export_buf", "flush2buf", "rub_img", "flushablebuff", "flush55bin", "sync_addr", "send_cb", "ush_buff", "reset_buf", "usher_req", "export64block", "flush55fam", "flushmmbuf", "flushablefunc", "flushmybin", "export_block", "flush55seq", "flush_buff", "ush_buf", "export_cmd", "rubxbg", "flush_img", "flush_err", "flushximg", "flush_cap", "ush_buffer", "flushablebuf", "sync_buf", "ush_bin", "flush_func", "flushtbuffer", "flushmyfam", "export64cmd", "flush67cmd", "flush2buffer", "ush_fam", "flushtbuf", "flush55buf", "flush67err", "flush_cb", "flushtcb", "sync_buff", "ush_cb", "flush_queue", "ush_uf", "flush2queue", "usher55req", "flush_pkg", "flush_buffer", "usher55uf", "flushxbuff", " flush_err", "send_buf", "ush_vec", "usher_buf", "rub_buff", "flushablecb", "ush_seq", "flushorbuf", "flush64block", "flush_cmd", " flush_uf", "sync_queue", "flush_bg", "flush2func", "flush67buf", "flush55req", "reset_fac", "usher55cb", "sync_func", "flushmyseq", "flushorimg", "usher_uf", " flush_buffer", "usher55buf", "flush_req", "flush0addr", "flush_seq", "flush_block", "flush_bin", "flushmmcmd", "flush_fac", "reset_pkg", "flushxbuf", " flush_cap", "flush0buff", "flushmybuf", "flush0buf", "rub_bg", "flushorbuff", "send_func", "flush_vec", "flush64cmd", "flush_uf", "flushmmblock"], "samples": ["ssamp", "assicks", "Sales", "Samples", "assamples", "mamples", "mounds", "ments", "spaces", "Saves", "Saces", "stringsamps", " sounds", "Sents", " sicks", " saces", " samps", "sides", "sicks", "Sides", " sides", "ssaves", " saves", "Samps", "sents", "mamps", "ssamps", "sales", "stringsents", "asspaces", "stringsamples", " samp", "Samp", " sales", " sents", "Sounds", "stringsaces", "sounds", " spaces", "saves", "saces", "samps", "samp", "assamps", "ssamples"]}}
{"project": "qemu", "commit_id": "97f90cbfe810bb153fc44bde732d9639610783bb", "target": 0, "func": "void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,\n\n                          int is_asi, int size)\n\n{\n\n    CPUState *saved_env;\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n    qemu_log(\"Unassigned \" TARGET_FMT_plx \" wr=%d exe=%d\\n\",\n\n             addr, is_write, is_exec);\n\n    if (!(env->sregs[SR_MSR] & MSR_EE)) {\n\n        return;\n\n    }\n\n\n\n    if (is_exec) {\n\n        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    } else {\n\n        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    }\n\n}\n", "idx": 13172, "substitutes": {"addr": ["ref", "address", "Address", "alloc", "tx", "x", "hash", "ip", "src", "hw", "dh", "adr", "alias", "r", "add", "ptr", "host", "tr", "dr", "handle", "name", "oa", "ctx", "eth", "id", "at", "res", "kt", "ad", "act", "offset", "data", " address", "pat", "coord", "aro", "mt", "attr", "align", "rt", "ace", "cmd", "arp", "obj", "call"], "is_write": ["is_wr", "is___write", "is_writ", " is_read", "isopwriting", " is_writing", "is_read", " is_writ", "isopwrite", "is___wr", "isopwr", "is___writing", " is_wr", "isopread", "is___read", "is_writing"], "is_exec": ["is_ext", "isableexe", "is___exec", "isableinternal", " is_read", " is_ec", "is_execute", "is___exe", "is_read", " is_execute", "isableec", " is_ext", "is___ec", "is_ec", " is_exe", "is___internal", "is_exe", "is_internal", "isableexec", "is_Exec", " is_Exec", " is_internal"], "is_asi": ["is2ai", "is2asi", "is__ai", "is__asi", "Is_sa", "Is_data", "is__sa", "is_data", "is_ai", "is__data", "is_sa", "is2sa", "Is_ai", "is2data", "Is_asi"], "size": ["shape", "ize", "address", "send", "SIZE", "alloc", "sha", "scale", "loc", "args", "izes", "name", "mem", "count", "rc", "len", "ffff", "mode", "id", "offset", "data", "fee", "Size", "length", "area"], "saved_env": ["save_en", "saved_conn", "save_conn", "save_buf", "save_env", "saved_state", "saved_en", "saved_buf"]}}
{"project": "FFmpeg", "commit_id": "9340a99588c2bf6209b5c396df15b893c4b576b5", "target": 1, "func": "static int RENAME(swScale)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n\n\n\n\t/* load a few things into local vars to make the code more readable? and faster */\n\n\tconst int srcW= c->srcW;\n\n\tconst int dstW= c->dstW;\n\n\tconst int dstH= c->dstH;\n\n\tconst int chrDstW= c->chrDstW;\n\n\tconst int chrSrcW= c->chrSrcW;\n\n\tconst int lumXInc= c->lumXInc;\n\n\tconst int chrXInc= c->chrXInc;\n\n\tconst int dstFormat= c->dstFormat;\n\n\tconst int srcFormat= c->srcFormat;\n\n\tconst int flags= c->flags;\n\n\tconst int canMMX2BeUsed= c->canMMX2BeUsed;\n\n\tint16_t *vLumFilterPos= c->vLumFilterPos;\n\n\tint16_t *vChrFilterPos= c->vChrFilterPos;\n\n\tint16_t *hLumFilterPos= c->hLumFilterPos;\n\n\tint16_t *hChrFilterPos= c->hChrFilterPos;\n\n\tint16_t *vLumFilter= c->vLumFilter;\n\n\tint16_t *vChrFilter= c->vChrFilter;\n\n\tint16_t *hLumFilter= c->hLumFilter;\n\n\tint16_t *hChrFilter= c->hChrFilter;\n\n\tint32_t *lumMmxFilter= c->lumMmxFilter;\n\n\tint32_t *chrMmxFilter= c->chrMmxFilter;\n\n\tconst int vLumFilterSize= c->vLumFilterSize;\n\n\tconst int vChrFilterSize= c->vChrFilterSize;\n\n\tconst int hLumFilterSize= c->hLumFilterSize;\n\n\tconst int hChrFilterSize= c->hChrFilterSize;\n\n\tint16_t **lumPixBuf= c->lumPixBuf;\n\n\tint16_t **chrPixBuf= c->chrPixBuf;\n\n\tconst int vLumBufSize= c->vLumBufSize;\n\n\tconst int vChrBufSize= c->vChrBufSize;\n\n\tuint8_t *funnyYCode= c->funnyYCode;\n\n\tuint8_t *funnyUVCode= c->funnyUVCode;\n\n\tuint8_t *formatConvBuffer= c->formatConvBuffer;\n\n\tconst int chrSrcSliceY= srcSliceY >> c->chrSrcVSubSample;\n\n\tconst int chrSrcSliceH= -((-srcSliceH) >> c->chrSrcVSubSample);\n\n\tint lastDstY;\n\n        uint8_t *pal=NULL;\n\n\n\n\t/* vars whch will change and which we need to storw back in the context */\n\n\tint dstY= c->dstY;\n\n\tint lumBufIndex= c->lumBufIndex;\n\n\tint chrBufIndex= c->chrBufIndex;\n\n\tint lastInLumBuf= c->lastInLumBuf;\n\n\tint lastInChrBuf= c->lastInChrBuf;\n\n\t\n\n\tif(isPacked(c->srcFormat)){\n\n                pal= src[1];\n\n\t\tsrc[0]=\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= src[0];\n\n\t\tsrcStride[0]=\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= srcStride[0];\n\n\t}\n\n\tsrcStride[1]<<= c->vChrDrop;\n\n\tsrcStride[2]<<= c->vChrDrop;\n\n\n\n//\tprintf(\"swscale %X %X %X -> %X %X %X\\n\", (int)src[0], (int)src[1], (int)src[2],\n\n//\t\t(int)dst[0], (int)dst[1], (int)dst[2]);\n\n\n\n#if 0 //self test FIXME move to a vfilter or something\n\n{\n\nstatic volatile int i=0;\n\ni++;\n\nif(srcFormat==PIX_FMT_YUV420P && i==1 && srcSliceH>= c->srcH)\n\n\tselfTest(src, srcStride, c->srcW, c->srcH);\n\ni--;\n\n}\n\n#endif\n\n\n\n//printf(\"sws Strides:%d %d %d -> %d %d %d\\n\", srcStride[0],srcStride[1],srcStride[2],\n\n//dstStride[0],dstStride[1],dstStride[2]);\n\n\n\n\tif(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)\n\n\t{\n\n\t\tstatic int firstTime=1; //FIXME move this into the context perhaps\n\n\t\tif(flags & SWS_PRINT_INFO && firstTime)\n\n\t\t{\n\n\t\t\tav_log(c, AV_LOG_WARNING, \"SwScaler: Warning: dstStride is not aligned!\\n\"\n\n\t\t\t\t\t\"SwScaler:          ->cannot do aligned memory acesses anymore\\n\");\n\n\t\t\tfirstTime=0;\n\n\t\t}\n\n\t}\n\n\n\n\t/* Note the user might start scaling the picture in the middle so this will not get executed\n\n\t   this is not really intended but works currently, so ppl might do it */\n\n\tif(srcSliceY ==0){\n\n\t\tlumBufIndex=0;\n\n\t\tchrBufIndex=0;\n\n\t\tdstY=0;\t\n\n\t\tlastInLumBuf= -1;\n\n\t\tlastInChrBuf= -1;\n\n\t}\n\n\n\n\tlastDstY= dstY;\n\n\n\n\tfor(;dstY < dstH; dstY++){\n\n\t\tunsigned char *dest =dst[0]+dstStride[0]*dstY;\n\n\t\tconst int chrDstY= dstY>>c->chrDstVSubSample;\n\n\t\tunsigned char *uDest=dst[1]+dstStride[1]*chrDstY;\n\n\t\tunsigned char *vDest=dst[2]+dstStride[2]*chrDstY;\n\n\n\n\t\tconst int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input\n\n\t\tconst int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input\n\n\t\tconst int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input\n\n\t\tconst int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input\n\n\n\n//printf(\"dstY:%d dstH:%d firstLumSrcY:%d lastInLumBuf:%d vLumBufSize: %d vChrBufSize: %d slice: %d %d vLumFilterSize: %d firstChrSrcY: %d vChrFilterSize: %d c->chrSrcVSubSample: %d\\n\",\n\n// dstY, dstH, firstLumSrcY, lastInLumBuf, vLumBufSize, vChrBufSize, srcSliceY, srcSliceH, vLumFilterSize, firstChrSrcY, vChrFilterSize,  c->chrSrcVSubSample);\n\n\t\t//handle holes (FAST_BILINEAR & weird filters)\n\n\t\tif(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;\n\n\t\tif(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;\n\n//printf(\"%d %d %d\\n\", firstChrSrcY, lastInChrBuf, vChrBufSize);\n\n\t\tASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)\n\n\t\tASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)\n\n\n\n\t\t// Do we have enough lines in this slice to output the dstY line\n\n\t\tif(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample))\n\n\t\t{\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf < lastLumSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n//\t\t\t\tprintf(\"%d %d %d %d\\n\", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n//\t\t\t\tprintf(\"%d %d\\n\", lumBufIndex, vLumBufSize);\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->lumMmx2Filter, c->lumMmx2FilterPos, pal);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf < lastChrSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)\n\n\t\t\t\t//FIXME replace parameters through context struct (some at least)\n\n\n\n\t\t\t\tif(!(isGray(srcFormat) || isGray(dstFormat)))\n\n\t\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->chrMmx2Filter, c->chrMmx2FilterPos, pal);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t}\n\n\t\telse // not enough lines left in this slice -> load the rest in the buffer\n\n\t\t{\n\n/*\t\tprintf(\"%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\\n\",\n\n\t\t\tfirstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,\n\n\t\t\tlastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,\n\n\t\t\tvChrBufSize, vLumBufSize);*/\n\n\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf+1 < srcSliceY + srcSliceH)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->lumMmx2Filter, c->lumMmx2FilterPos, pal);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf+1 < (chrSrcSliceY + chrSrcSliceH))\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY < chrSrcSliceH)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)\n\n\n\n\t\t\t\tif(!(isGray(srcFormat) || isGray(dstFormat)))\n\n\t\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->chrMmx2Filter, c->chrMmx2FilterPos, pal);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t\tbreak; //we can't output a dstY line so let's try with the next slice\n\n\t\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t\tb5Dither= dither8[dstY&1];\n\n\t\tg6Dither= dither4[dstY&1];\n\n\t\tg5Dither= dither8[dstY&1];\n\n\t\tr5Dither= dither8[(dstY+1)&1];\n\n#endif\n\n\t    if(dstY < dstH-2)\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n#ifdef HAVE_MMX\n\n\t\tint i;\n\n            if(flags & SWS_ACCURATE_RND){\n\n                        for(i=0; i<vLumFilterSize; i+=2){\n\n                                lumMmxFilter[2*i+0]= (int32_t)lumSrcPtr[i  ];\n\n                                lumMmxFilter[2*i+1]= (int32_t)lumSrcPtr[i+(vLumFilterSize>1)];\n\n                                lumMmxFilter[2*i+2]=\n\n                                lumMmxFilter[2*i+3]= vLumFilter[dstY*vLumFilterSize + i    ]\n\n                                                + (vLumFilterSize>1 ? vLumFilter[dstY*vLumFilterSize + i + 1]<<16 : 0);\n\n                        }\n\n                        for(i=0; i<vChrFilterSize; i+=2){\n\n                                chrMmxFilter[2*i+0]= (int32_t)chrSrcPtr[i  ];\n\n                                chrMmxFilter[2*i+1]= (int32_t)chrSrcPtr[i+(vChrFilterSize>1)];\n\n                                chrMmxFilter[2*i+2]=\n\n                                chrMmxFilter[2*i+3]= vChrFilter[chrDstY*vChrFilterSize + i    ]\n\n                                                + (vChrFilterSize>1 ? vChrFilter[chrDstY*vChrFilterSize + i + 1]<<16 : 0);\n\n                        }\n\n            }else{\n\n\t\tfor(i=0; i<vLumFilterSize; i++)\n\n\t\t{\n\n\t\t\tlumMmxFilter[4*i+0]= (int32_t)lumSrcPtr[i];\n\n\t\t\tlumMmxFilter[4*i+1]= (uint64_t)lumSrcPtr[i] >> 32;\n\n\t\t\tlumMmxFilter[4*i+2]= \n\n\t\t\tlumMmxFilter[4*i+3]= \n\n\t\t\t\t((uint16_t)vLumFilter[dstY*vLumFilterSize + i])*0x10001;\n\n\t\t}\n\n\t\tfor(i=0; i<vChrFilterSize; i++)\n\n\t\t{\n\n\t\t\tchrMmxFilter[4*i+0]= (int32_t)chrSrcPtr[i];\n\n\n\t\t\tchrMmxFilter[4*i+2]= \n\n\t\t\tchrMmxFilter[4*i+3]= \n\n\t\t\t\t((uint16_t)vChrFilter[chrDstY*vChrFilterSize + i])*0x10001;\n\n\t\t}\n\n            }\n\n#endif\n\n\t\tif(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tRENAME(yuv2nv12X)(c,\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, dstW, chrDstW, dstFormat);\n\n\t\t}\n\n\t\telse if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12 like\n\n\t\t{\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t *lumBuf = lumPixBuf[0];\n\n\t\t\t\tint16_t *chrBuf= chrPixBuf[0];\n\n\t\t\t\tRENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW, chrDstW);\n\n\t\t\t}\n\n\t\t\telse //General YV12\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2yuvX)(c,\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, uDest, vDest, dstW, chrDstW);\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB\n\n\t\t\t{\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\t\t\t\tRENAME(yuv2packed1)(c, *lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, chrAlpha, dstFormat, flags, dstY);\n\n\t\t\t}\n\n\t\t\telse if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB\n\n\t\t\t{\n\n\t\t\t\tint lumAlpha= vLumFilter[2*dstY+1];\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n                                lumMmxFilter[2]=\n\n                                lumMmxFilter[3]= vLumFilter[2*dstY   ]*0x10001;\n\n                                chrMmxFilter[2]=\n\n                                chrMmxFilter[3]= vChrFilter[2*chrDstY]*0x10001;\n\n\t\t\t\tRENAME(yuv2packed2)(c, *lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, lumAlpha, chrAlpha, dstY);\n\n\t\t\t}\n\n\t\t\telse //General RGB\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2packedX)(c,\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, dstW, dstY);\n\n\t\t\t}\n\n\t\t}\n\n            }\n\n\t    else // hmm looks like we can't use MMX here without overwriting this array's tail\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\tif(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2nv12XinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, dstW, chrDstW, dstFormat);\n\n\t\t}\n\n\t\telse if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12\n\n\t\t{\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2yuvXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, vDest, dstW, chrDstW);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tyuv2packedXinC(c, \n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, dstW, dstY);\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n\t/* store changed local vars back in the context */\n\n\tc->dstY= dstY;\n\n\tc->lumBufIndex= lumBufIndex;\n\n\tc->chrBufIndex= chrBufIndex;\n\n\tc->lastInLumBuf= lastInLumBuf;\n\n\tc->lastInChrBuf= lastInChrBuf;\n\n\n\n\treturn dstY - lastDstY;\n\n}", "idx": 13204, "substitutes": {"c": ["abc", "vc", "ch", "cache", "l", "con", "comp", "pc", "bc", "lc", "conv", "unc", "dc", "etc", "cur", "cmp", "col", "cm", "ar", "cp", "xc", "cu", "cb", "cn", "conf", "comm", "p", "mc", "err", "cam", "C", "tc", "e", "b", "cc", "rc", "com", "chain", "ctx", "gc", "cv", "ce", "cont", "at", "g", "coll", "ci", "ct", "enc", "ic", "ec", "t", "ca", "cs", "fc", "sc", "nc", "config", "ac", "cr", "v", "f", "wcs", "cation", "w", "call", "co"], "src": ["sn", "sb", "serv", "sl", "conv", "cur", "st", "sel", "loc", "sub", "sys", "img", "ser", "usc", "rc", "seed", "sq", "sw", "iv", "sr", "inst", "ctr", "filename", "outh", "sc", "source", "stream"], "srcStride": ["rcRestride", "srcRestope", "srcRestride", "rcRestope", "rcStope", "rcStide", "srcShride", "srcSlide", "srcSlope", "rcRestide", "srcStide", "srcStope", "srcShope", "rcStride", "srcSlride", "srcRestide", "srcShide"], "srcSliceY": ["srcSlgeX", "srcSliceB", "srcSlgeW", "srcSlsliceX", "srcSlsliceW", "srcSlsliceB", "srcSlideY", "srcSlsliceY", "srcSlideW", "srcSlideB", "srcSlgeY", "srcSlideX", "srcSliceX", "srcSliceW", "srcSlgeB"], "srcSliceH": ["srcSlitchW", "srcSlitchH", "srcSlitchU", "srcSlitchY", "srcSlsliceW", "srcSliceU", "srcSlideY", "srcSlsliceY", "srcSlideW", "srcSlideH", "srcSlsliceH", "srcSlsliceU", "srcSlideU", "srcSliceW"], "dst": ["Dsl", "disst", "dissl", "disdest", "adst", "Dst", "dsc", "adsc", "adsl", "addest", "Dsc", "dsl", "ddest", "dissc", "Ddest"], "dstStride": ["dstrSlide", "dstrSlr", "dstSlrobe", "dststrobe", "dstRestrobe", "dststide", "dstStr", "dstRestide", "dstrSlrobe", "dstStrobe", "dstSlr", "dstSlide", "dststr", "dstStide", "dstrStr", "dstrStrobe", "dstrStride", "dstrStide", "dstSlride", "dstRestr", "dstrSlride", "dststride", "dstRestride"], "vLumFilterPos": ["vLumFilePos", "vLumBlockPos", "vLumFilterCol", "vLomFilterDef", "vLumBufferDef", "vLumBufferPos", "vLummFilterSp", "vLumFilterP", "vLumRuleSp", "vLumBlockLen", "vLummFilterP", "vLumFilterLen", "vLumFileCol", "vLumFieldSp", "vLumFieldLen", "vLummFieldSp", "vLomFilterCol", "vLumBlockSp", "vLumFilDef", "vLumRuleP", "vLummFieldLen", "vLomBufferCol", "vLumFilNeg", "vLumFileDef", "vLummFieldPos", "vLomBufferDef", "vLumRulePos", "vLumBufferCol", "vLumRuleLen", "vLummFieldP", "vLumBufferNeg", "vLumFilterNeg", "vLumFilterSp", "vLomBufferPos", "vLummFilterLen", "vLumFieldP", "vLumFileNeg", "vLumFilPos", "vLomBufferNeg", "vLummFilterPos", "vLomFilterNeg", "vLumFilCol", "vLumBlockP", "vLumFilterDef", "vLumFieldPos", "vLomFilterPos"], "vChrFilterPos": ["vChmFilterPos", "vChrProfileDir", "vChrFilterVol", "vChrManagerPos", "vChmControlNum", "vChrManagerVol", "vChrFilterDir", "vChmFilterNum", "vChrProfileVol", "vChrFilterNum", "vChmPatternVol", "vChmControlPos", "vChrFilPos", "vChrPatternPos", "vChmPatternDir", "vChrProfilePos", "vChrManagerPOS", "vChrProfilePOS", "vChrPatternPOS", "vChmFilterVol", "vChrHandlerDir", "vChrFilNum", "vChmControlDir", "vChrManagerDir", "vChrPatternVol", "vChrControlNum", "vChmPatternPos", "vChrControlPos", "vChrFilDir", "vChrHandlerNum", "vChrFilterPOS", "vChrPatternDir", "vChrControlDir", "vChmFilterPOS", "vChmPatternPOS", "vChrHandlerPos", "vChmFilterDir"], "hLumFilterPos": ["hLumbTransformDir", "hLumpControlPos", "hLumControlSec", "hLumFormatSec", "hLumTransformDef", "hLumpControlSec", "hLumpFilterObj", "hLumpFilterSec", "hLumListenerObj", "hLumbFilterPos", "hLumControlFix", "hLumFormatFix", "hLumFilterLoc", "hLumFilterDef", "hLumpControlFix", "hLumListenerPos", "hLumListenerSec", "hLumbTransformDef", "hLumFilterSec", "hLumbTransformLoc", "hLumTransformLoc", "hLumFormatObj", "hLumControlObj", "hLumListenerFix", "hLumFilterFix", "hLumpControlObj", "hLumFormatLoc", "hLumbFilterDir", "hLumFormatPos", "hLumpFilterPos", "hLumFilterObj", "hLumFormatDir", "hLumTransformPos", "hLumbFilterLoc", "hLumbFilterDef", "hLumControlPos", "hLumTransformDir", "hLumFilterDir", "hLumFormatDef", "hLumpFilterFix", "hLumbTransformPos"], "hChrFilterPos": ["hChrTransformSpec", "hChcTransformPos", "hChcFilterSize", "hChcFilterPos", "hChrSpiderSize", "hChrFilterRes", "hChrSpiderSpec", "hChrTransformPos", "hChrFilterSize", "hChrHandlerRes", "hChmFilterOpen", "hChcTransformSize", "hChrRulePos", "hChrRuleSize", "hChrChannelRes", "hChrTransformId", "hChcFilterSpec", "hChrFilterSpec", "hChrfilterOpen", "hChrFilterOpen", "hChmHandlerPos", "hChcTransformSpec", "hChmFilterPos", "hChrHandlerOpen", "hChmHandlerOpen", "hChrSpiderPos", "hChrfilterRes", "hChrChannelPos", "hChrFilterId", "hChrSpiderId", "hChmFilterRes", "hChmHandlerRes", "hChrChannelOpen", "hChrRuleId", "hChcFilterId", "hChrHandlerPos", "hChrTransformSize", "hChrfilterPos", "hChcTransformId", "hChrRuleSpec"], "vLumFilter": ["vLamTarget", "vLumfilter", "vLumafilter", "vLandumFormat", "vLomFormat", "vLumbTarget", "vLumTarget", "vLumbFilter", "vMumTarget", "vLumaFormat", "vLamFilter", "vLumaHandler", "vLumaSort", "vLumHandler", "vLumbfilter", "vMumaFilter", "vMumSort", "vLumbHandler", "vLandumHandler", "vLomFilter", "vMumaTarget", "vLumSort", "vLamSort", "vLumbSort", "vLandumaFormat", "vMumaSort", "vLomHandler", "vLandumaFilter", "vLumbFormat", "vLandumaHandler", "vLandumFilter", "vLomfilter", "vLumFormat", "vLandumfilter", "vLandumafilter", "vLumaTarget", "vMumFilter", "vLumaFilter"], "vChrFilter": ["vChrbfilter", "vComprFrame", "vChcrFil", "vChdrfilter", "vChrbFil", "vColmQuery", "vChmQuery", "vChrbFilter", "vColrFil", "vChdrFrame", "vChcrFilter", "vChcrQuery", "vCharFil", "vColrFilter", "vChuFrame", "vColmFilter", "vChmFilter", "vCharFilter", "vChdrFil", "vCharQuery", "vChdrFilter", "vComprFilter", "vCompuFilter", "vChrFil", "vChrFrame", "vChuFilter", "vChufilter", "vComprfilter", "vCompuFrame", "vChrQuery", "vCompufilter", "vChmFil", "vChrbFrame", "vCompuFil", "vComprFil", "vColrQuery", "vChuFil", "vChrfilter", "vColmFil"], "hLumFilter": ["hLumStream", "hElumQuery", "hLumaQuery", "hLoomFilter", "hILulChain", "hLulChain", "hLumChain", "hLomQuery", "hILumChain", "hILumFil", "hLulFil", "hLainChain", "hLainFil", "hLumaFilter", "hLumQuery", "hLomStream", "hILulRule", "hILumFilter", "hLulFilter", "hILumRule", "hILulFilter", "hElulFF", "hLainFilter", "hLumRule", "hLumaStream", "hElumStream", "hLumFil", "hLainRule", "hLulStream", "hElumFF", "hLoomChain", "hILulFil", "hElumFilter", "hElulFilter", "hLulQuery", "hLumFF", "hLulRule", "hElulStream", "hLumaFF", "hLomFilter", "hLomFF", "hLoomFil", "hLulFF", "hLoomRule", "hElulQuery"], "hChrFilter": ["hGruSort", "hChmHandler", "hChtSort", "hChrFormat", "hShrbFrame", "hShrFilter", "hChtHandler", "hGruFilter", "hChcrTransform", "hChrtFilter", "hShrFrame", "hChrtTransform", "hChmTransform", "hShrbFilter", "hShrbTransform", "hChtTransform", "hChrbFormat", "hShrFormat", "hChcrFrame", "hChrHandler", "hGruTransform", "hChrSort", "hChuHandler", "hChcrFormat", "hChrbTransform", "hChtFilter", "hGrrTransform", "hChrbFilter", "hChuTransform", "hChcrFilter", "hGrrHandler", "hGrrSort", "hChuSort", "hChrtFormat", "hGruHandler", "hChmFilter", "hChmSort", "hChrtFrame", "hShrbFormat", "hChrbFrame", "hGrrFilter", "hChuFilter", "hShrTransform", "hChrTransform", "hChrFrame"], "lumMmxFilter": ["lumMmnHandler", "lumMoxConfig", "lumMdrFilter", "lumRmmfilter", "lumRmmConfig", "lumRmmFormat", "lumMnzHash", "lumMixFilter", "lumBnzFilter", "lumMmxFil", "lumMdrHash", "lumBnzHash", "lumBmxHash", "lumMmmConfig", "lumMixfilter", "lumMmmFormat", "lumMixFormat", "lumMixConfig", "lumMmxfilter", "lumMmxFormat", "lumBnzHandler", "lumBmxFil", "lumMoxFormat", "lumMmmfilter", "lumMnzHandler", "lumRmxConfig", "lumRmmFilter", "lumMoxFilter", "lumMmxHandler", "lumBnzFil", "lumMnzFil", "lumMmmFilter", "lumRmxfilter", "lumMmnHash", "lumBmxHandler", "lumMdrFil", "lumMmxConfig", "lumBmxFilter", "lumMdrHandler", "lumMmxHash", "lumMnzFilter", "lumRmxFilter", "lumMmnFilter", "lumMmnFil", "lumMoxfilter", "lumRmxFormat"], "chrMmxFilter": ["chrMmmFil", "chrMMXTransform", "chrMemmxHandler", "chrMoxFilter", "chrMmacCheck", "chrMemmxFil", "chrMemmxTarget", "chrMssFil", "chrMmicFil", "chrEoxCheck", "chrMmmFilter", "chrMoxCheck", "chrEoxFilter", "chrMmxTarget", "chrMmmTarget", "chrMemmicTarget", "chrMmacFilter", "chrMemmicFil", "chrMmxTest", "chrMmxFil", "chrMMXFilter", "chrMmicHandler", "chrMssFilter", "chrMMXCheck", "chrMMXTest", "chrEoxTest", "chrMmxHandler", "chrMmacTest", "chrEmxFilter", "chrEmxTest", "chrMmmHandler", "chrMemmicHandler", "chrMmacTransform", "chrMmicTarget", "chrEoxTransform", "chrMoxTest", "chrEmxCheck", "chrMssTarget", "chrMssHandler", "chrMemmxFilter", "chrMmxCheck", "chrMemmicFilter", "chrMmxTransform", "chrMoxTransform", "chrMmicFilter", "chrEmxTransform"], "lumPixBuf": ["lumPixBrc", "lumPfxPrc", "lumPfxPuf", "lumPfxBuf", "lumPfxBrc", "lumPixCuf", "lumPixPuff", "lumPixPrc", "lumPixBuff", "lumPfxBuff", "lumPixBufferuf", "lumPfxBust", "lumPixCrc", "lumPixBufferbuf", "lumPixCust", "lumPixBust", "lumPixBufferuff", "lumPixCbuf", "lumPfxBbuf", "lumPixRbuf", "lumPfxPust", "lumPixCuff", "lumPixRust", "lumPixRuf", "lumPixPuf", "lumPfxPuff", "lumPixPust", "lumPixPbuf", "lumPixBbuf", "lumPfxPbuf", "lumPixRuff", "lumPixBufferrc"], "chrPixBuf": ["chrPxBuff", "chrPixDuff", "chrPxPust", "chrPfxPuff", "chrPixBux", "chrPfxBix", "chrPxBust", "chrPixBufferust", "chrPixPix", "chrPxPux", "chrPixCuf", "chrPixDuf", "chrPxBux", "chrPixBufferuf", "chrPfxBuff", "chrPixDix", "chrPixCuff", "chrPixPuf", "chrPixBust", "chrPixPuff", "chrPixCux", "chrPfxPix", "chrPixPust", "chrPixPux", "chrPixBufferux", "chrPfxPuf", "chrPxPuff", "chrPxPuf", "chrPxBuf", "chrPixCust", "chrPixBuff", "chrPfxBuf", "chrPixBufferuff", "chrPixBix"]}}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME(bgr24ToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_BGR24);\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        int b= src[i*3+0];\n\n        int g= src[i*3+1];\n\n        int r= src[i*3+2];\n\n\n\n        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);\n\n    }\n\n#endif /* COMPILE_TEMPLATE_MMX */\n\n}\n", "idx": 13205, "substitutes": {"dst": ["disST", "dist", "disst", "Dbl", "dests", " dST", "hst", "dsts", "bst", " dtr", "lest", "lst", "best", "ldest", "deST", "hdest", " dist", "dest", "ltr", " dest", "Dst", " ddest", "dST", "ddest", "Ddest", "dtr", " dsts", "destr", " dstr", " dbl", "dissts", "hbl", "dbl", "bdest", "dstr", "btr", "disstr", "hist", "Dist"], "src": ["bs", "view", "usr", "rs", "sn", "req", "sb", "sl", "ur", "txt", "spe", "rb", "via", "cur", "input", "np", "dest", "bh", "st", "sub", "s", "sys", "r", "scan", "loc", "img", "ptr", "impl", "syn", "ser", "ssl", "usc", "in", "sur", "rc", "ipp", "sec", "hl", "iter", "decl", "inner", "str", "rl", "sq", "sw", "supp", "iv", "sr", "stock", "seq", "inst", "proc", "ctr", "iro", "times", "lib", "sc", "source", "ins", "obj", "RC", "ipl"], "unused": ["Unuse", " unchecked", "unuse", "Unchecked", " unuse", "UNchecked", "Unused", "UNuse", "unchecked", "UNused"], "i": ["qi", "h", "info", "ind", "l", "ai", "ii", "ji", "n", "gi", "status", "z", "di", "point", "ski", "sim", "cli", "ij", "ip", "init", "ti", "li", "\u0438", "I", "p", " j", "ei", "r", "si", "batch", "m", "oi", "key", "ri", "ma", "asi", "port", "name", "im", "multi", "chain", "ami", "uli", "ims", "index", "iu", "id", "it", "j", "me", "ci", "xi", "ic", "ki", "t", "phi", "zi", "span", "ix", "mi", "is", "o", "pi", "v", "y", "bi", "ini", "ui", "f", "uri"]}}
{"project": "FFmpeg", "commit_id": "f78cd0c243b9149c7f604ecf1006d78e344aa6ca", "target": 1, "func": "void FUNC(ff_simple_idct)(DCTELEM *block)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 8; i++)\n\n        FUNC(idctRowCondDC)(block + i*8);\n\n\n\n    for (i = 0; i < 8; i++)\n\n        FUNC(idctSparseCol)(block + i);\n\n}\n", "idx": 13230, "substitutes": {"block": ["event", "context", "BL", "ref", "map", "bl", "bc", "ck", "point", "tx", "off", "group", "out", "ip", "byte", "check", "set", "def", "list", "client", "blocks", "b", "chain", "box", "window", "buffer", "hl", "instance", "commit", "no", "id", "j", "load", "lock", "row", "data", "cl", "proc", "mm", "pack", "link", "Block"], "i": ["cli", "oi", "asi", "ms", "mac", "my", "uli", " m", " ii", "it", "g", "ci", "ex", "ki", "zi", " mi", "mi", "y", " multi", " li", "ii", "ji", " si", " di", "ij", "init", "hi", "m", " pi", "ri", "multi", "ni", "at", "j", "xi", "try", "ix", "is", "print", "by", "ui", "ini", "qi", "ind", "l", "ai", "di", "x", "c", "q", "ti", " bi", "li", "\u0438", "I", "err", "si", "batch", "key", "im", "in", "ims", "fi", "index", "phi", "pi", "bi", "io", "iq", "gi", " ni", "sim", " wi", "ip", "ei", " j", " I", "s", "us", "e", "iu", "me", "ic", "span", "v", " err", " ti", "PI"]}}
{"project": "qemu", "commit_id": "f53c398aa603cea135ee58fd15249aeff7b9c7ea", "target": 1, "func": "static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)\n\n{\n\n    if (ohci->async_td &&\n\n        ohci->usb_packet.owner != NULL &&\n\n        ohci->usb_packet.owner->dev == dev) {\n\n        usb_cancel_packet(&ohci->usb_packet);\n\n        ohci->async_td = 0;\n\n    }\n\n}\n", "idx": 13236, "substitutes": {"ohci": ["ehcci", "oshli", "ohpi", "ouchli", "ohli", "oshcci", "ohco", "ohcu", "oshpi", "hdi", "ouchlc", "ihai", " ohcci", "hcu", "ihcci", "Ohcci", "okcci", "ihci", "hereci", "okci", "hrcci", "ohdi", "Ohci", "oshci", "hhci", "Ohli", "hcci", "herecci", "heredi", "ihpi", "hhpi", "ehai", " ohli", "ehpi", "ohcci", "ehci", "hlc", "hrci", " ohco", "ohlc", "ehli", " ohcont", "Ohpi", "hhai", "hci", "okcu", "ohai", "ehlc", "ouchdi", "ehdi", "okdi", "ohcont", " ohdi", "herecu", "ehco", "hrdi", "hrco", "hli", "hcont", "ehcont", "hhcci", "ouchci"], "dev": ["device", "rel", "d", "ch", "dem", "ve", "av", "DEV", "serv", "priv", "app", "go", "serial", "buf", "addr", "usb", "hw", "comm", "ver", "loc", "def", "cam", "tech", "pro", "desc", "raw", "Device", "mem", "md", "att", "nt", "des", "Dev", "od", "spec", "eth", "ev", "wid", "conn", "dis", "doc", "hid", "test", "tm", "val", "v", "adv", "obj", "w", "pub"]}}
{"project": "FFmpeg", "commit_id": "fd0f45e58b010c0d7049914a392c3e96a2223107", "target": 1, "func": "static int av_encode(AVFormatContext **output_files,\n\n                     int nb_output_files,\n\n                     AVFormatContext **input_files,\n\n                     int nb_input_files,\n\n                     AVStreamMap *stream_maps, int nb_stream_maps)\n\n{\n\n    int ret, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;\n\n    AVFormatContext *is, *os;\n\n    AVCodecContext *codec, *icodec;\n\n    AVOutputStream *ost, **ost_table = NULL;\n\n    AVInputStream *ist, **ist_table = NULL;\n\n    AVInputFile *file_table;\n\n    AVFormatContext *stream_no_data;\n\n    int key;\n\n\n\n    file_table= (AVInputFile*) av_mallocz(nb_input_files * sizeof(AVInputFile));\n\n    if (!file_table)\n\n        goto fail;\n\n\n\n    /* input stream init */\n\n    j = 0;\n\n    for(i=0;i<nb_input_files;i++) {\n\n        is = input_files[i];\n\n        file_table[i].ist_index = j;\n\n        file_table[i].nb_streams = is->nb_streams;\n\n        j += is->nb_streams;\n\n    }\n\n    nb_istreams = j;\n\n\n\n    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));\n\n    if (!ist_table)\n\n        goto fail;\n\n    \n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = av_mallocz(sizeof(AVInputStream));\n\n        if (!ist)\n\n            goto fail;\n\n        ist_table[i] = ist;\n\n    }\n\n    j = 0;\n\n    for(i=0;i<nb_input_files;i++) {\n\n        is = input_files[i];\n\n        for(k=0;k<is->nb_streams;k++) {\n\n            ist = ist_table[j++];\n\n            ist->st = is->streams[k];\n\n            ist->file_index = i;\n\n            ist->index = k;\n\n            ist->discard = 1; /* the stream is discarded by default\n\n                                 (changed later) */\n\n\n\n            if (ist->st->codec.rate_emu) {\n\n                ist->start = av_gettime();\n\n                ist->frame = 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* output stream init */\n\n    nb_ostreams = 0;\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        nb_ostreams += os->nb_streams;\n\n    }\n\n    if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n\n        fprintf(stderr, \"Number of stream maps must match number of output streams\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Sanity check the mapping args -- do the input files & streams exist? */\n\n    for(i=0;i<nb_stream_maps;i++) {\n\n        int fi = stream_maps[i].file_index;\n\n        int si = stream_maps[i].stream_index;\n\n        \n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > file_table[fi].nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find input stream #%d.%d\\n\", fi, si);\n\n            exit(1);\n\n        }\n\n    }\n\n    \n\n    ost_table = av_mallocz(sizeof(AVOutputStream *) * nb_ostreams);\n\n    if (!ost_table)\n\n        goto fail;\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = av_mallocz(sizeof(AVOutputStream));\n\n        if (!ost)\n\n            goto fail;\n\n        ost_table[i] = ost;\n\n    }\n\n    \n\n    n = 0;\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++) {\n\n            int found;\n\n            ost = ost_table[n++];\n\n            ost->file_index = k;\n\n            ost->index = i;\n\n            ost->st = os->streams[i];\n\n            if (nb_stream_maps > 0) {\n\n                ost->source_index = file_table[stream_maps[n-1].file_index].ist_index + \n\n                    stream_maps[n-1].stream_index;\n\n                    \n\n                /* Sanity check that the stream types match */\n\n                if (ist_table[ost->source_index]->st->codec.codec_type != ost->st->codec.codec_type) {\n\n                    fprintf(stderr, \"Codec type mismatch for mapping #%d.%d -> #%d.%d\\n\",\n\n                        stream_maps[n-1].file_index, stream_maps[n-1].stream_index,\n\n                        ost->file_index, ost->index);\n\n                    exit(1);\n\n                }\n\n                \n\n            } else {\n\n                /* get corresponding input stream index : we select the first one with the right type */\n\n                found = 0;\n\n                for(j=0;j<nb_istreams;j++) {\n\n                    ist = ist_table[j];\n\n                    if (ist->discard && \n\n                        ist->st->codec.codec_type == ost->st->codec.codec_type) {\n\n                        ost->source_index = j;\n\n                        found = 1;\n\n                    }\n\n                }\n\n                \n\n                if (!found) {\n\n                    /* try again and reuse existing stream */\n\n                    for(j=0;j<nb_istreams;j++) {\n\n                        ist = ist_table[j];\n\n                        if (ist->st->codec.codec_type == ost->st->codec.codec_type) {\n\n                            ost->source_index = j;\n\n                            found = 1;\n\n                        }\n\n                    }\n\n                    if (!found) {\n\n                        fprintf(stderr, \"Could not find input stream matching output stream #%d.%d\\n\",\n\n                                ost->file_index, ost->index);\n\n                        exit(1);\n\n                    }\n\n                }\n\n            }\n\n            ist = ist_table[ost->source_index];\n\n            ist->discard = 0;\n\n        }\n\n    }\n\n\n\n    /* for each output stream, we compute the right encoding parameters */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        ist = ist_table[ost->source_index];\n\n\n\n        codec = &ost->st->codec;\n\n        icodec = &ist->st->codec;\n\n\n\n        if (ost->st->stream_copy) {\n\n            /* if stream_copy is selected, no need to decode or encode */\n\n            codec->codec_id = icodec->codec_id;\n\n            codec->codec_type = icodec->codec_type;\n\n            codec->codec_tag = icodec->codec_tag;\n\n            codec->bit_rate = icodec->bit_rate;\n\n            switch(codec->codec_type) {\n\n            case CODEC_TYPE_AUDIO:\n\n                codec->sample_rate = icodec->sample_rate;\n\n                codec->channels = icodec->channels;\n\n                break;\n\n            case CODEC_TYPE_VIDEO:\n\n                codec->frame_rate = icodec->frame_rate;\n\n                codec->frame_rate_base = icodec->frame_rate_base;\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                break;\n\n            default:\n\n                av_abort();\n\n            }\n\n        } else {\n\n            switch(codec->codec_type) {\n\n            case CODEC_TYPE_AUDIO:\n\n                if (fifo_init(&ost->fifo, 2 * MAX_AUDIO_PACKET_SIZE))\n\n                    goto fail;\n\n                \n\n                if (codec->channels == icodec->channels &&\n\n                    codec->sample_rate == icodec->sample_rate) {\n\n                    ost->audio_resample = 0;\n\n                } else {\n\n                    if (codec->channels != icodec->channels &&\n\n                        icodec->codec_id == CODEC_ID_AC3) {\n\n                        /* Special case for 5:1 AC3 input */\n\n                        /* and mono or stereo output      */\n\n                        /* Request specific number of channels */\n\n                        icodec->channels = codec->channels;\n\n                        if (codec->sample_rate == icodec->sample_rate)\n\n                            ost->audio_resample = 0;\n\n                        else {\n\n                            ost->audio_resample = 1;\n\n                            ost->resample = audio_resample_init(codec->channels, icodec->channels,\n\n                                                        codec->sample_rate, \n\n                                                        icodec->sample_rate);\n\n\t\t\t    if(!ost->resample)\n\n\t\t\t      {\n\n\t\t\t\tprintf(\"Can't resample.  Aborting.\\n\");\n\n\t\t\t\tav_abort();\n\n\t\t\t      }\n\n                        }\n\n                        /* Request specific number of channels */\n\n                        icodec->channels = codec->channels;\n\n                    } else {\n\n                        ost->audio_resample = 1; \n\n                        ost->resample = audio_resample_init(codec->channels, icodec->channels,\n\n                                                        codec->sample_rate, \n\n                                                        icodec->sample_rate);\n\n\t\t\tif(!ost->resample)\n\n\t\t\t  {\n\n\t\t\t    printf(\"Can't resample.  Aborting.\\n\");\n\n\t\t\t    av_abort();\n\n\t\t\t  }\n\n                    }\n\n                }\n\n                ist->decoding_needed = 1;\n\n                ost->encoding_needed = 1;\n\n                break;\n\n            case CODEC_TYPE_VIDEO:\n\n                if (codec->width == icodec->width &&\n\n                    codec->height == icodec->height &&\n\n                    frame_topBand == 0 &&\n\n                    frame_bottomBand == 0 &&\n\n                    frame_leftBand == 0 &&\n\n                    frame_rightBand == 0)\n\n                {\n\n                    ost->video_resample = 0;\n\n                    ost->video_crop = 0;\n\n                } else if ((codec->width == icodec->width -\n\n                                (frame_leftBand + frame_rightBand)) &&\n\n                        (codec->height == icodec->height -\n\n                                (frame_topBand  + frame_bottomBand)))\n\n                {\n\n                    ost->video_resample = 0;\n\n                    ost->video_crop = 1;\n\n                    ost->topBand = frame_topBand;\n\n                    ost->leftBand = frame_leftBand;\n\n                } else {\n\n                    uint8_t *buf;\n\n                    ost->video_resample = 1;\n\n                    ost->video_crop = 0; // cropping is handled as part of resample\n\n                    buf = av_malloc((codec->width * codec->height * 3) / 2);\n\n                    if (!buf)\n\n                        goto fail;\n\n                    ost->pict_tmp.data[0] = buf;\n\n                    ost->pict_tmp.data[1] = ost->pict_tmp.data[0] + (codec->width * codec->height);\n\n                    ost->pict_tmp.data[2] = ost->pict_tmp.data[1] + (codec->width * codec->height) / 4;\n\n                    ost->pict_tmp.linesize[0] = codec->width;\n\n                    ost->pict_tmp.linesize[1] = codec->width / 2;\n\n                    ost->pict_tmp.linesize[2] = codec->width / 2;\n\n\n\n                    ost->img_resample_ctx = img_resample_full_init( \n\n                                      ost->st->codec.width, ost->st->codec.height,\n\n                                      ist->st->codec.width, ist->st->codec.height,\n\n                                      frame_topBand, frame_bottomBand,\n\n                                      frame_leftBand, frame_rightBand);\n\n                }\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n                break;\n\n            default:\n\n                av_abort();\n\n            }\n\n            /* two pass mode */\n\n            if (ost->encoding_needed && \n\n                (codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) {\n\n                char logfilename[1024];\n\n                FILE *f;\n\n                int size;\n\n                char *logbuffer;\n\n                \n\n                snprintf(logfilename, sizeof(logfilename), \"%s-%d.log\", \n\n                         pass_logfilename ? \n\n                         pass_logfilename : DEFAULT_PASS_LOGFILENAME, i);\n\n                if (codec->flags & CODEC_FLAG_PASS1) {\n\n                    f = fopen(logfilename, \"w\");\n\n                    if (!f) {\n\n                        perror(logfilename);\n\n                        exit(1);\n\n                    }\n\n                    ost->logfile = f;\n\n                } else {\n\n                    /* read the log file */\n\n                    f = fopen(logfilename, \"r\");\n\n                    if (!f) {\n\n                        perror(logfilename);\n\n                        exit(1);\n\n                    }\n\n                    fseek(f, 0, SEEK_END);\n\n                    size = ftell(f);\n\n                    fseek(f, 0, SEEK_SET);\n\n                    logbuffer = av_malloc(size + 1);\n\n                    if (!logbuffer) {\n\n                        fprintf(stderr, \"Could not allocate log buffer\\n\");\n\n                        exit(1);\n\n                    }\n\n                    fread(logbuffer, 1, size, f);\n\n                    fclose(f);\n\n                    logbuffer[size] = '\\0';\n\n                    codec->stats_in = logbuffer;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /* dump the file output parameters - cannot be done before in case\n\n       of stream copy */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n    }\n\n\n\n    /* dump the stream mapping */\n\n    fprintf(stderr, \"Stream mapping:\\n\");\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        fprintf(stderr, \"  Stream #%d.%d -> #%d.%d\\n\",\n\n                ist_table[ost->source_index]->file_index,\n\n                ist_table[ost->source_index]->index,\n\n                ost->file_index, \n\n                ost->index);\n\n    }\n\n\n\n    /* open each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            AVCodec *codec;\n\n            codec = avcodec_find_encoder(ost->st->codec.codec_id);\n\n            if (!codec) {\n\n                fprintf(stderr, \"Unsupported codec for output stream #%d.%d\\n\", \n\n                        ost->file_index, ost->index);\n\n                exit(1);\n\n            }\n\n            if (avcodec_open(&ost->st->codec, codec) < 0) {\n\n                fprintf(stderr, \"Error while opening codec for stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height\\n\", \n\n                        ost->file_index, ost->index);\n\n                exit(1);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* open each decoder */\n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = ist_table[i];\n\n        if (ist->decoding_needed) {\n\n            AVCodec *codec;\n\n            codec = avcodec_find_decoder(ist->st->codec.codec_id);\n\n            if (!codec) {\n\n                fprintf(stderr, \"Unsupported codec (id=%d) for input stream #%d.%d\\n\", \n\n                        ist->st->codec.codec_id, ist->file_index, ist->index);\n\n                exit(1);\n\n            }\n\n            if (avcodec_open(&ist->st->codec, codec) < 0) {\n\n                fprintf(stderr, \"Error while opening codec for input stream #%d.%d\\n\", \n\n                        ist->file_index, ist->index);\n\n                exit(1);\n\n            }\n\n            //if (ist->st->codec.codec_type == CODEC_TYPE_VIDEO)\n\n            //    ist->st->codec.flags |= CODEC_FLAG_REPEAT_FIELD;\n\n            ist->frame_decoded = 1;\n\n        }\n\n    }\n\n\n\n    /* init pts */\n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = ist_table[i];\n\n\tis = input_files[ist->file_index];\n\n        ist->pts = 0;\n\n        if (ist->decoding_needed) {\n\n            switch (ist->st->codec.codec_type) {\n\n            case CODEC_TYPE_AUDIO:\n\n                av_frac_init(&ist->next_pts, \n\n                             0, 0, is->pts_num * ist->st->codec.sample_rate);\n\n                break;\n\n            case CODEC_TYPE_VIDEO:\n\n                av_frac_init(&ist->next_pts, \n\n                             0, 0, is->pts_num * ist->st->codec.frame_rate);\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    \n\n    /* compute buffer size max (should use a complete heuristic) */\n\n    for(i=0;i<nb_input_files;i++) {\n\n        file_table[i].buffer_size_max = 2048;\n\n    }\n\n\n\n    /* open files and write file headers */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (av_write_header(os) < 0) {\n\n            fprintf(stderr, \"Could not write header for output file #%d (incorrect codec paramters ?)\\n\", i);\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n#ifndef CONFIG_WIN32\n\n    if ( !using_stdin )\n\n        fprintf(stderr, \"Press [q] to stop encoding\\n\");\n\n#endif\n\n    term_init();\n\n\n\n    stream_no_data = 0;\n\n    key = -1;\n\n\n\n    for(; received_sigterm == 0;) {\n\n        int file_index, ist_index;\n\n        AVPacket pkt;\n\n        uint8_t *ptr;\n\n        int len;\n\n        uint8_t *data_buf;\n\n        int data_size, got_picture;\n\n        AVPicture picture;\n\n        short samples[AVCODEC_MAX_AUDIO_FRAME_SIZE / 2];\n\n        void *buffer_to_free;\n\n        double pts_min;\n\n        \n\n    redo:\n\n        /* if 'q' pressed, exits */\n\n        if (!using_stdin) {\n\n            /* read_key() returns 0 on EOF */\n\n            key = read_key();\n\n            if (key == 'q')\n\n                break;\n\n        }\n\n\n\n        /* select the stream that we must read now by looking at the\n\n           smallest output pts */\n\n        file_index = -1;\n\n        pts_min = 1e10;\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            double pts;\n\n            ost = ost_table[i];\n\n            os = output_files[ost->file_index];\n\n            ist = ist_table[ost->source_index];\n\n            pts = (double)ost->st->pts.val * os->pts_num / os->pts_den;\n\n            if (!file_table[ist->file_index].eof_reached && \n\n                pts < pts_min) {\n\n                pts_min = pts;\n\n                file_index = ist->file_index;\n\n            }\n\n        }\n\n        /* if none, if is finished */\n\n        if (file_index < 0) {\n\n            break;\n\n        }\n\n\n\n        /* finish if recording time exhausted */\n\n        if (recording_time > 0 && pts_min >= (recording_time / 1000000.0))\n\n            break;\n\n\n\n        /* read a packet from it and output it in the fifo */\n\n        is = input_files[file_index];\n\n        if (av_read_packet(is, &pkt) < 0) {\n\n            file_table[file_index].eof_reached = 1;\n\n            continue;\n\n        }\n\n        if (!pkt.size) {\n\n            stream_no_data = is;\n\n        } else {\n\n            stream_no_data = 0;\n\n        }\n\n        if (do_hex_dump) {\n\n            printf(\"stream #%d, size=%d:\\n\", pkt.stream_index, pkt.size);\n\n            av_hex_dump(pkt.data, pkt.size);\n\n        }\n\n        /* the following test is needed in case new streams appear\n\n           dynamically in stream : we ignore them */\n\n        if (pkt.stream_index >= file_table[file_index].nb_streams)\n\n            goto discard_packet;\n\n        ist_index = file_table[file_index].ist_index + pkt.stream_index;\n\n        ist = ist_table[ist_index];\n\n        if (ist->discard)\n\n            goto discard_packet;\n\n\n\n        // printf(\"read #%d.%d size=%d\\n\", ist->file_index, ist->index, pkt.size);\n\n\n\n        len = pkt.size;\n\n        ptr = pkt.data;\n\n        while (len > 0) {\n\n            /* decode the packet if needed */\n\n            data_buf = NULL; /* fail safe */\n\n            data_size = 0;\n\n            if (ist->decoding_needed) {\n\n                /* NOTE1: we only take into account the PTS if a new\n\n                   frame has begun (MPEG semantics) */\n\n                /* NOTE2: even if the fraction is not initialized,\n\n                   av_frac_set can be used to set the integer part */\n\n                if (ist->frame_decoded) { \n\n                    /* If pts is unavailable -- we have to use synthetic one */\n\n                    if( pkt.pts != AV_NOPTS_VALUE )\n\n                    {\n\n                        ist->pts = ist->next_pts.val = pkt.pts;\n\n                    }\n\n                    else\n\n                    {\n\n                        ist->pts = ist->next_pts.val;\n\n                    }\n\n                    ist->frame_decoded = 0;\n\n                }\n\n\n\n                switch(ist->st->codec.codec_type) {\n\n                case CODEC_TYPE_AUDIO:\n\n                    /* XXX: could avoid copy if PCM 16 bits with same\n\n                       endianness as CPU */\n\n                    ret = avcodec_decode_audio(&ist->st->codec, samples, &data_size,\n\n                                               ptr, len);\n\n                    if (ret < 0)\n\n                        goto fail_decode;\n\n                    /* Some bug in mpeg audio decoder gives */\n\n                    /* data_size < 0, it seems they are overflows */\n\n                    if (data_size <= 0) {\n\n                        /* no audio frame */\n\n                        ptr += ret;\n\n                        len -= ret;\n\n                        continue;\n\n                    }\n\n                    data_buf = (uint8_t *)samples;\n\n\t\t    av_frac_add(&ist->next_pts, \n\n\t\t\t        is->pts_den * data_size / (2 * ist->st->codec.channels));\n\n                    break;\n\n                case CODEC_TYPE_VIDEO:\n\n                    {\n\n                        AVFrame big_picture;\n\n\n\n                        data_size = (ist->st->codec.width * ist->st->codec.height * 3) / 2;\n\n                        ret = avcodec_decode_video(&ist->st->codec, \n\n                                                   &big_picture, &got_picture, ptr, len);\n\n                        picture= *(AVPicture*)&big_picture;\n\n                        ist->st->quality= big_picture.quality;\n\n                        if (ret < 0) {\n\n                        fail_decode:\n\n                            fprintf(stderr, \"Error while decoding stream #%d.%d\\n\",\n\n                                    ist->file_index, ist->index);\n\n                            av_free_packet(&pkt);\n\n                            goto redo;\n\n                        }\n\n                        if (!got_picture) {\n\n                            /* no picture yet */\n\n                            ptr += ret;\n\n                            len -= ret;\n\n                            continue;\n\n                        }\n\n                        av_frac_add(&ist->next_pts, \n\n\t\t\t            is->pts_den * ist->st->codec.frame_rate_base);          \n\n                    }\n\n                    break;\n\n                default:\n\n                    goto fail_decode;\n\n                }\n\n            } else {\n\n                data_buf = ptr;\n\n                data_size = len;\n\n                ret = len;\n\n            }\n\n            ptr += ret;\n\n            len -= ret;\n\n\n\n            buffer_to_free = 0;\n\n            if (ist->st->codec.codec_type == CODEC_TYPE_VIDEO) {\n\n                pre_process_video_frame(ist, &picture, &buffer_to_free);\n\n            }\n\n\n\n            ist->frame_decoded = 1;\n\n\n\n            /* frame rate emulation */\n\n            if (ist->st->codec.rate_emu) {\n\n                int64_t pts = av_rescale((int64_t) ist->frame * ist->st->codec.frame_rate_base, 1000000, ist->st->codec.frame_rate);\n\n                int64_t now = av_gettime() - ist->start;\n\n                if (pts > now)\n\n                    usleep(pts - now);\n\n\n\n                ist->frame++;\n\n            }\n\n\n\n#if 0\n\n            /* mpeg PTS deordering : if it is a P or I frame, the PTS\n\n               is the one of the next displayed one */\n\n            /* XXX: add mpeg4 too ? */\n\n            if (ist->st->codec.codec_id == CODEC_ID_MPEG1VIDEO) {\n\n                if (ist->st->codec.pict_type != B_TYPE) {\n\n                    int64_t tmp;\n\n                    tmp = ist->last_ip_pts;\n\n                    ist->last_ip_pts  = ist->frac_pts.val;\n\n                    ist->frac_pts.val = tmp;\n\n                }\n\n            }\n\n#endif\n\n            /* transcode raw format, encode packets and output them */\n\n\n\n            for(i=0;i<nb_ostreams;i++) {\n\n                int frame_size;\n\n\n\n                ost = ost_table[i];\n\n                if (ost->source_index == ist_index) {\n\n                    os = output_files[ost->file_index];\n\n\n\n#if 0\n\n                    printf(\"%d: got pts=%f %f\\n\", i, pkt.pts / 90000.0, \n\n                           (ist->pts - ost->st->pts.val) / 90000.0);\n\n#endif\n\n                    /* set the input output pts pairs */\n\n                    ost->sync_ipts = (double)ist->pts * is->pts_num / \n\n                        is->pts_den;\n\n                    /* XXX: take into account the various fifos,\n\n                       in particular for audio */\n\n                    ost->sync_opts = ost->st->pts.val;\n\n                    //printf(\"ipts=%lld sync_ipts=%f sync_opts=%lld pts.val=%lld pkt.pts=%lld\\n\", ist->pts, ost->sync_ipts, ost->sync_opts, ost->st->pts.val, pkt.pts); \n\n\n\n                    if (ost->encoding_needed) {\n\n                        switch(ost->st->codec.codec_type) {\n\n                        case CODEC_TYPE_AUDIO:\n\n                            do_audio_out(os, ost, ist, data_buf, data_size);\n\n                            break;\n\n                        case CODEC_TYPE_VIDEO:\n\n                            /* find an audio stream for synchro */\n\n                            {\n\n                                int i;\n\n                                AVOutputStream *audio_sync, *ost1;\n\n                                audio_sync = NULL;\n\n                                for(i=0;i<nb_ostreams;i++) {\n\n                                    ost1 = ost_table[i];\n\n                                    if (ost1->file_index == ost->file_index &&\n\n                                        ost1->st->codec.codec_type == CODEC_TYPE_AUDIO) {\n\n                                        audio_sync = ost1;\n\n                                        break;\n\n                                    }\n\n                                }\n\n\n\n                                do_video_out(os, ost, ist, &picture, &frame_size, audio_sync);\n\n                                if (do_vstats && frame_size)\n\n                                    do_video_stats(os, ost, frame_size);\n\n                            }\n\n                            break;\n\n                        default:\n\n                            av_abort();\n\n                        }\n\n                    } else {\n\n                        AVFrame avframe;\n\n                                                \n\n                        /* no reencoding needed : output the packet directly */\n\n                        /* force the input stream PTS */\n\n                        \n\n                        memset(&avframe, 0, sizeof(AVFrame));\n\n                        ost->st->codec.coded_frame= &avframe;\n\n\t\t\tavframe.key_frame = pkt.flags & PKT_FLAG_KEY; \n\n                        \n\n                        av_write_frame(os, ost->index, data_buf, data_size);\n\n\t\t\tost->st->codec.frame_number++;\n\n\t\t\tost->frame_number++;\n\n                    }\n\n                }\n\n            }\n\n            av_free(buffer_to_free);\n\n        }\n\n    discard_packet:\n\n        av_free_packet(&pkt);\n\n        \n\n        /* dump report by using the output first video and audio streams */\n\n        print_report(output_files, ost_table, nb_ostreams, 0);\n\n    }\n\n    term_exit();\n\n\n\n    /* dump report by using the first video and audio streams */\n\n    print_report(output_files, ost_table, nb_ostreams, 1);\n\n\n\n    /* close each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            av_freep(&ost->st->codec.stats_in);\n\n            avcodec_close(&ost->st->codec);\n\n        }\n\n    }\n\n    \n\n    /* close each decoder */\n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = ist_table[i];\n\n        if (ist->decoding_needed) {\n\n            avcodec_close(&ist->st->codec);\n\n        }\n\n    }\n\n    \n\n\n\n    /* write the trailer if needed and close file */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        av_write_trailer(os);\n\n    }\n\n    /* finished ! */\n\n    \n\n    ret = 0;\n\n fail1:\n\n    av_free(file_table);\n\n\n\n    if (ist_table) {\n\n        for(i=0;i<nb_istreams;i++) {\n\n            ist = ist_table[i];\n\n            av_free(ist);\n\n        }\n\n        av_free(ist_table);\n\n    }\n\n    if (ost_table) {\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            if (ost) {\n\n                if (ost->logfile) {\n\n                    fclose(ost->logfile);\n\n                    ost->logfile = NULL;\n\n                }\n\n                fifo_free(&ost->fifo); /* works even if fifo is not\n\n                                          initialized but set to zero */\n\n                av_free(ost->pict_tmp.data[0]);\n\n                if (ost->video_resample)\n\n                    img_resample_close(ost->img_resample_ctx);\n\n                if (ost->audio_resample)\n\n                    audio_resample_close(ost->resample);\n\n                av_free(ost);\n\n            }\n\n        }\n\n        av_free(ost_table);\n\n    }\n\n    return ret;\n\n fail:\n\n    ret = -ENOMEM;\n\n    goto fail1;\n\n}\n", "idx": 13268, "substitutes": {"output_files": ["output_styles", "output_modules", "output_file", "input_styles", "outputCachemodules", "input_file", "outputCachefile", "outputCachefiles", "input_modules", "outputCachestyles"], "nb_output_files": ["nb_outputsfiles", "nb_output_names", "nb_outputsnames", "nb_outputsfile", "nb_input_file", "nb_input_names", "nb_output_file"], "input_files": ["input___file", "output_videos", "inputablemodules", "inputlicfile", "inputableworkers", "input_workers", "output_modules", "inputmopfile", "output_file", "inputmopdata", "input_videos", "input___workers", "input_Files", "inputlicworkers", "input___files", "inputablefile", "inputmopvideos", "inputlicfiles", "input_file", "output_workers", "input_modules", "output_Files", "inputlicFiles", "inputablefiles", "input_data", "inputmopfiles", "input___modules", "output_data"], "nb_input_files": ["nb_output_values", "nb_input_docs", "nb_output_uploads", "nb_input_scenes", "nb_input___jobs", "nb_input_file", "nb_output_docs", "nb_inputablejobs", "nb_inputablefs", "nb_output_scenes", "nb_output_jobs", "nb_inputablefiles", "nb_inputvefile", "nb_input_values", "nb_input___ports", "nb_inputvescenes", "nb_input_ports", "nb_output_ports", "nb_inputablefile", "nb_input___files", "nb_output_file", "nb_input_uploads", "nb_inputvedocs", "nb_output_fs", "nb_inputvefiles", "nb_input_jobs", "nb_input___fs", "nb_input_fs", "nb_input___file"], "stream_maps": ["fileitysets", "stream2sets", "file_maps", "fileitymaps", "streamityresults", "stream2maps", "streamitymap", "fileitymap", "stream_results", "streamitymaps", "streamitysets", "stream_sets", "fileityresults", "stream_map", "file_sets", "stream2map", "stream2results", "file_map", "file_results"], "nb_stream_maps": ["nb_stream_lists", "nb_stream_map", "nb_streamingsets", "nb_streamingmaps", "nb_Stream_lists", "nb_Stream_map", "nb_streamingmap", "nb_stream_sets", "nb_Stream_sets", "nb_streaminglists", "nb_Stream_maps"], "ret": ["jp", "RET", "status", "out", "re", "Ret", "result", "new", " RET", "err", "nil", "ry", "flag", "mem", "fi", "gc", "vals", "fail", "t", "ll", "resp", "val"], "i": ["status", "cli", "this", "oi", "g", "it", "ci", "ite", "ie", "mm", "ki", "zi", "mi", "y", "uri", "details", "h", "info", "ii", "ji", "ij", "init", "hi", "er", "m", "ri", "any", "name", "ia", "multi", "at", "iii", "xi", "try", "ik", "ix", "ui", "ini", "fire", "qi", "ind", "ai", "parent", "di", "x", "q", "ti", "li", "\u0438", "I", "si", "batch", "ma", "ir", "im", "in", "ims", "fi", "index", "phi", "o", "iri", "pi", "bi", "io", "gi", "sim", "ip", "ei", "p", " I", "us", "dr", "e", "chain", "ami", "remote", "iu", "id", "um", "me", "ic", "iso", "v"], "j": ["h", "jp", "l", "adj", "ji", "aj", "z", "json", "br", "bj", "ij", "next", "slot", "q", "p", "jj", "jump", "r", "m", "jac", "bo", "b", "ja", "js", "nr", "g", "it", "uj", "fr", "dj", "kj", "J", "jc", "pr", "o", "y", "v", "bi", "gov", "jl", "jit"], "k": ["kind", "ark", "kw", "kn", "ku", "ko", "ks", "z", "ck", "isk", "kit", "tk", "wk", "c", "q", "ask", "p", "kl", "dk", "m", "kk", "mk", "kh", "b", "kick", "sk", "ijk", "ok", "uk", "kt", "ka", "kj", "ke", "km", "ik", "ak", "ek", "ki", "kid", "o", "kr", "K", "v", "y", "unk"], "n": ["sn", "l", "nan", "nu", "np", "c", "q", "cn", "p", "nm", "m", "ne", "N", "nt", "no", "nr", "na", "ni", "g", "nn", "num", "nl", "nb", "ll", "o", "v", "ns"], "is": ["bs", "lis", "info", "fs", "ii", "orts", "ip", "isl", "ates", "init", "in", "has", "ps", "ires", "nis", "s", "sys", "es", "si", "ib", "ri", "ois", "vs", "us", "tis", "ism", "ms", "ir", "im", "its", "isc", "iss", "js", "IS", "isa", "ih", "ims", "are", "as", "id", "bis", "it", "vis", "iris", "Is", "iv", "ci", "ic", "phis", "iso", "was", "atis", "ais", "mos", "ils", "bits", "isi", "ins", "ui", "sis", "ris", "ists", "isin", "parts", "ports"], "os": ["bs", "OS", "oc", "ops", "Os", "out", "ps", "s", "sys", "es", "obs", "et", "us", "ms", "its", "ot", "ys", "ds", "cs", "ens", "o", "oses", "oss", "io"], "codec": ["formressor", "cdec", "formoc", "cdEC", "cdoc", " codrc", "codEC", "codressor", "Codec", "CodEC", "formec", "Codrc", "codrc", "Codressor", "chressor", "codoc", "formEC", "cdrc", "Codoc", "chec", " codEC", "choc", " codoc", "chEC"], "icodec": ["icodEC", "icondenc", "miccodec", "miccodEC", "micodenc", "icodef", "icondef", "icopEC", "icopec", "micodec", "icondec", "iccodenc", "micodef", "iccodec", "icodenc", "icopenc", "icondEC", "iccodEC", "iccodef", "miccodef", "icopef", "micodEC", "miccodenc"], "ost": ["oc", "ont", "voc", "art", "ast", "ort", "istor", "oid", "ust", "ilst", "ot", "od", "ous", "op", "iv", "ic", "ox", "tt", "ace", "ob", "rest", "oss", "obs", "irst", "est"], "ost_table": ["ost_trace", "ost_list", "ist_list", "ost_buffer", "ist_trace", "ist_buffer"], "ist": ["dist", "ont", "and", "ith", "pect", "art", "dit", "lat", "ress", "ip", "isl", "ast", "ort", "pas", "isting", "istor", "wp", "ust", "ess", "artist", "list", "et", "istant", "vest", "ird", "isted", "ism", "port", "ilst", "its", "exist", "ot", "ert", "pir", "elist", "op", "ict", "rust", "it", "act", "feat", "mot", "iest", "EST", "iste", "ic", "inst", "lect", "IST", "alist", "assert", "cript", "tt", "gest", "ace", "stat", "isi", "ista", "ists", "lda", "istance", "hist", "wordpress", "spect", "iat", "htt", "rest", "irst", "edit", "est"], "ist_table": ["elist_table", "ist___list", "elist___stable", "ist_Table", "ist___batch", "ist_tree", "ert_buffer", "ost_list", "ast_public", "istttree", "istPtree", "ost_tree", "istobjTable", "isttlist", "istobjbody", "ert_table", "istobjcount", "elist___list", "elist_list", "ist_tmp", "istttable", "istsstable", "ist___public", "istant_Table", "iststable", "ist_database", "istant_body", "ist___table", "elist_stable", "istobjtable", "ist_buffer", "ast_table", "ist___tmp", "ist___buffer", "istant_table", "elist___table", "ert_database", "ist_cache", "ist_batch", "isttcache", "istsbatch", "istPtable", "ast_buffer", "elist___batch", "istPdatabase", "istslist", "ost_cache", "istant_count", "elist_batch", "ist___stable", "ist_stable", "ist_list", "ert_tree", "ist_count", "istPbuffer", "ist_public", "ist_body", "ast_tmp"], "file_table": ["file_global", " file_tree", "pathletable", " file_TABLE", " file_chain", "file_cache", "file_tab", "file2table", "path_cache", " file_list", "file_template", "filesetbuffer", "fileletable", "file2buffer", "file2tab", "filesetchain", "filelecache", " file_info", "file_buffer", "filePtemplate", " file_tab", "filelemaster", "filePchain", " file_template", "pathlemaster", "filePinfo", "filesettemplate", "file_info", " file_global", "file2TABLE", "file_list", "path_master", "file2info", "filesettable", "pathlecache", "file_tree", "path_table", "path_TABLE", "fileleTABLE", "filePtab", "file_TABLE", "file_master", " file_buffer", "filePtable", "filePbuffer", "pathleTABLE", "file_chain"], "stream_no_data": ["stream_noopDATA", "stream_meta_error", "stream_meta_table", "stream_nooptable", "stream_no_error", "stream_nooperror", "stream_meta_data", "stream_meta_DATA", "stream_noopdata", "stream_no_DATA", "stream_no_table"], "key": ["ref", "kw", "version", "type", "parent", "keys", "x", "error", "value", "Key", "start", "ry", "flag", "code", "count", "pointer", "str", "num", "KEY", "param", "fee", "cond", "val", "base", "ree", "ee"], "file_index": ["port_ind", "file_id", "file_ind", "port_id", "file_key", "port_key", "port_index"], "ist_index": ["ist_Index", "st_Index", "st_id", "istopid", "istopaddress", "ist_id", "ist_address", "istopindex", "st_index", "st_address", "istopIndex"], "st": ["ST", "must", "dist", "ut", "end", "std", "stop", "St", "nd", "stack", "service", "src", "dest", "ste", "set", "ust", "sty", "start", "dr", "storage", "stable", "sp", "sts", "sh", "str", "sw", "stage", "cl", "ct", "step", "sta", "inst", "sth", "se", "sc", "stat", "rest", "be", "first", "irst", "est"], "frame": ["event", "second", "fps", "channel", "version", "point", "sequence", "error", "slot", "depth", "trace", "window", "chain", "block", "fd", "record", "offset", "frames", "fr", "step", "seq", "cond", "source", "base", "cycle", "sample", "reset", "shift"]}}
{"project": "FFmpeg", "commit_id": "f37b2d5a6884c7bea87a6c7454239381449bd637", "target": 1, "func": "int avpriv_mpeg4audio_get_config(MPEG4AudioConfig *c, const uint8_t *buf,\n                                 int bit_size, int sync_extension)\n{\n    GetBitContext gb;\n    int specific_config_bitindex;\n    init_get_bits(&gb, buf, bit_size);\n    c->object_type = get_object_type(&gb);\n    c->sample_rate = get_sample_rate(&gb, &c->sampling_index);\n    c->chan_config = get_bits(&gb, 4);\n    if (c->chan_config < FF_ARRAY_ELEMS(ff_mpeg4audio_channels))\n        c->channels = ff_mpeg4audio_channels[c->chan_config];\n    c->sbr = -1;\n    c->ps  = -1;\n    if (c->object_type == AOT_SBR || (c->object_type == AOT_PS &&\n        // check for W6132 Annex YYYY draft MP3onMP4\n        !(show_bits(&gb, 3) & 0x03 && !(show_bits(&gb, 9) & 0x3F)))) {\n        if (c->object_type == AOT_PS)\n            c->ps = 1;\n        c->ext_object_type = AOT_SBR;\n        c->sbr = 1;\n        c->ext_sample_rate = get_sample_rate(&gb, &c->ext_sampling_index);\n        c->object_type = get_object_type(&gb);\n        if (c->object_type == AOT_ER_BSAC)\n            c->ext_chan_config = get_bits(&gb, 4);\n    } else {\n        c->ext_object_type = AOT_NULL;\n        c->ext_sample_rate = 0;\n    }\n    specific_config_bitindex = get_bits_count(&gb);\n    if (c->object_type == AOT_ALS) {\n        skip_bits(&gb, 5);\n        if (show_bits_long(&gb, 24) != MKBETAG('\\0','A','L','S'))\n            skip_bits_long(&gb, 24);\n        specific_config_bitindex = get_bits_count(&gb);\n        if (parse_config_ALS(&gb, c))\n            return -1;\n    }\n    if (c->ext_object_type != AOT_SBR && sync_extension) {\n        while (get_bits_left(&gb) > 15) {\n            if (show_bits(&gb, 11) == 0x2b7) { // sync extension\n                get_bits(&gb, 11);\n                c->ext_object_type = get_object_type(&gb);\n                if (c->ext_object_type == AOT_SBR && (c->sbr = get_bits1(&gb)) == 1)\n                    c->ext_sample_rate = get_sample_rate(&gb, &c->ext_sampling_index);\n                if (get_bits_left(&gb) > 11 && get_bits(&gb, 11) == 0x548)\n                    c->ps = get_bits1(&gb);\n                break;\n            } else\n                get_bits1(&gb); // skip 1 bit\n        }\n    }\n    //PS requires SBR\n    if (!c->sbr)\n        c->ps = 0;\n    //Limit implicit PS to the HE-AACv2 Profile\n    if ((c->ps == -1 && c->object_type != AOT_AAC_LC) || c->channels & ~0x01)\n        c->ps = 0;\n    return specific_config_bitindex;\n}", "idx": 13273, "substitutes": {"c": ["abc", "oc", "cal", "ch", "cache", "l", "con", "comp", "pc", "bc", "content", "lc", "ctrl", "dc", "etc", "cur", "cmp", "cm", "cp", "cb", "cu", "conf", "cn", "xc", "p", "mc", "set", "err", "check", "C", "b", "tc", "chain", "cc", "rc", "com", "code", "ctx", "gc", "cv", "csv", "ce", "cont", "cod", "cf", "coll", "ci", "ct", "anc", "enc", "ic", "ec", "ca", "cs", "fc", "sc", "config", "nc", "ac", "cr", "v", "ae", "cd", "w", "can", "call", "co"], "buf": ["uf", "queue", "ref", "sb", "bytes", "xff", "tmp", "txt", "rb", "out", "Buff", "cb", "conf", "p", "r", "err", "img", "pb", "mb", "raw", "buff", "read", "mem", "b", "db", "rc", "box", "buffer", "block", "path", "cv", "Buffer", "msg", "data", "max", "cmd", "v", "f", "doc"], "bit_size": ["bit_rate", "bitvalsize", "batch_Size", "bit_index", "batch_size", "bitityrate", "bititystate", "batch_state", "bit_SIZE", "bit_state", "bit_Size", "bitvalSize", " bit_index", "bitvalindex", "bititySize", "bitvalSIZE", " bit_Size", " bit_SIZE", "bititysize", "batch_rate"], "sync_extension": ["sync_xtension", "sync_xtend", "sync_extend", "sync_EXTend", "sync_xtensions", "sync_Extended", "sync_Extension", "sync_Extensions", "sync_xtended", "sync_EXTensions", "sync_extended", "sync_extensions", "sync_EXTension", "sync_Extend", "sync_EXTended"], "gb": ["bs", "ch", "gpu", "bc", "px", "gu", "cb", "args", "pb", "storage", "cv", "g", "grow", "all", "_", "bg", "vm", "got", "ga", "gd", "uf", "py", "sb", "hub", "git", "sv", "bridge", "def", "ib", "vg", "tg", "img", "cfg", "mb", "good", "buffer", "gc", "bb", " db", "msg", "bool", "nb", "gif", "kb", "gem", "bytes", "pc", "gm", "bf", "rb", "ruby", " GB", "yg", "wm", "fi", "eg", "csv", "gom", "range", "gt", " rgb", "deg", "Gb", "GB", "ge", "gg", "new", "gh", "gp", "C", "gs", "db", "eb", "xy", "ctx", "gin", "rg", "um", "attr", "fc", "wb", "gov"], "specific_config_bitindex": ["specific_config_bytelength", "specific_config_byteindex", "specific_config_baseindex", "specific_config_bytetype", "specific_config_bitlength", "specific_config_bytestop", "specific_config_bindex", "specific_config_Bitposition", "specific_config_shortlength", "specific_config_byteposition", "specific_config_bittype", "specific_config_binindex", "specific_config_blength", "specific_config_bitstop", "specific_config_baseIndex", "specific_config_bintype", "specific_config_shortindex", "specific_config_bstop", "specific_config_Bittype", "specific_config_Bitindex", "specific_config_bposition", "specific_config_shortstop", "specific_config_basecount", "specific_config_bitposition", "specific_config_bandIndex", "specific_config_binposition", "specific_config_byteIndex", "specific_config_bytecount", "specific_config_bitIndex", "specific_config_binlength", "specific_config_bitcount", "specific_config_Bitlength", "specific_config_bandcount", "specific_config_bandindex", "specific_config_shortposition"]}}
{"project": "FFmpeg", "commit_id": "a52f443714b5c2a40ed272d8445f4c39220a4b69", "target": 1, "func": "static av_always_inline void vc1_apply_p_h_loop_filter(VC1Context *v, int block_num)\n\n{\n\n    MpegEncContext *s  = &v->s;\n\n    int mb_cbp         = v->cbp[s->mb_x - 1 - s->mb_stride],\n\n        block_cbp      = mb_cbp      >> (block_num * 4), right_cbp,\n\n        mb_is_intra    = v->is_intra[s->mb_x - 1 - s->mb_stride],\n\n        block_is_intra = mb_is_intra >> (block_num * 4), right_is_intra;\n\n    int idx, linesize  = block_num > 3 ? s->uvlinesize : s->linesize, ttblk;\n\n    uint8_t *dst;\n\n\n\n    if (block_num > 3) {\n\n        dst = s->dest[block_num - 3] - 8 * linesize;\n\n    } else {\n\n        dst = s->dest[0] + (block_num & 1) * 8 + ((block_num & 2) * 4 - 16) * linesize - 8;\n\n    }\n\n\n\n    if (s->mb_x != s->mb_width || !(block_num & 5)) {\n\n        int16_t (*mv)[2];\n\n\n\n        if (block_num > 3) {\n\n            right_cbp      = v->cbp[s->mb_x - s->mb_stride] >> (block_num * 4);\n\n            right_is_intra = v->is_intra[s->mb_x - s->mb_stride] >> (block_num * 4);\n\n            mv             = &v->luma_mv[s->mb_x - s->mb_stride - 1];\n\n        } else {\n\n            right_cbp      = (block_num & 1) ? (v->cbp[s->mb_x - s->mb_stride]      >> ((block_num - 1) * 4))\n\n                                             : (mb_cbp                              >> ((block_num + 1) * 4));\n\n            right_is_intra = (block_num & 1) ? (v->is_intra[s->mb_x - s->mb_stride] >> ((block_num - 1) * 4))\n\n                                             : (mb_is_intra                         >> ((block_num + 1) * 4));\n\n            mv             = &s->current_picture.motion_val[0][s->block_index[block_num] - s->b8_stride * 2 - 2];\n\n        }\n\n        if (block_is_intra & 1 || right_is_intra & 1 || mv[0][0] != mv[1][0] || mv[0][1] != mv[1][1]) {\n\n            v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n        } else {\n\n            idx = ((right_cbp >> 1) | block_cbp) & 5; // FIXME check\n\n            if (idx == 5) {\n\n                v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n            } else if (idx) {\n\n                if (idx == 1)\n\n                    v->vc1dsp.vc1_h_loop_filter4(dst + 4 * linesize, linesize, v->pq);\n\n                else\n\n                    v->vc1dsp.vc1_h_loop_filter4(dst,                linesize, v->pq);\n\n            }\n\n        }\n\n    }\n\n\n\n    dst -= 4;\n\n    ttblk = (v->ttblk[s->mb_x - s->mb_stride - 1] >> (block_num * 4)) & 0xf;\n\n    if (ttblk == TT_4X4 || ttblk == TT_4X8) {\n\n        idx = (block_cbp | (block_cbp >> 1)) & 5;\n\n        if (idx == 5) {\n\n            v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n        } else if (idx) {\n\n            if (idx == 1)\n\n                v->vc1dsp.vc1_h_loop_filter4(dst + linesize * 4, linesize, v->pq);\n\n            else\n\n                v->vc1dsp.vc1_h_loop_filter4(dst,                linesize, v->pq);\n\n        }\n\n    }\n\n}\n", "idx": 13311, "substitutes": {"v": ["h", "i", "vc", "view", "l", "tv", "ch", "ve", "av", "V", "conv", "x", "nv", "video", "sv", "c", "q", "ver", "p", "uv", "m", "vs", "vp", "b", "e", "verb", "vt", "vi", "lv", "cv", "mint", "env", "g", "um", "ev", "va", "vis", "values", "j", "iv", "data", "qv", "ov", "vector", "t", "nov", "vv", "vr", "get", "qu", "inv", "y", "f", "virtual", "w", "vm"], "block_num": ["Block_num", "sliceIDnum", "block4num", "sliceIDdec", "slice_num", "bridge_span", "block2digit", " block2num", "block_nom", "bridge_n", " block_sum", "blockprocmp", " block2number", "lock1prim", "batch10num", "Block_orig", "block__hom", "lock_mon", "block64nom", "blockixnumber", "blockIDnum", "batch10mat", "bool", "lock_typ", "blocking10num", "blocking_nom", "blockixhom", "block_Num", "block2number", "chain_num", "bridge_cmp", "lock_prim", "blockipcmp", "blocking_num", "block_norm", " block2nu", "block67nom", "blockprospan", "block1mat", "lock1NUM", "block1um", "block_orig", "block10norm", "lock_hom", "new", "switch_um", "lock1num", "block10um", "func", "block_type", "block1mon", "block_number", "switch_num", "blockPno", "block1nom", "Block_cum", "lock_num", "block8Num", "bl", "block_hom", "blockIDmat", "block1norm", " block_nom", "block_tim", "block1typ", "block67num", "block2nom", "blockipn", "blockPnum", " block2nom", "block__num", "bridgeprocmp", "block_dec", "slice_name", "block2NUM", "blockixtim", "block4NUM", "blocking10norm", "bridge_num", "lock_nom", "blocking_norm", "lock_nam", "chain_nom", " block2sum", "lock_tim", " block_NUM", "block_typ", "block10mon", "blocking10nom", "block_digit", "switch_sum", "switch_NUM", "bridgeprospan", " block_um", "lock_um", "lock1nom", "batch10um", "block10nom", "sliceIDname", " block_number", "block64num", "block_name", "block1type", "block2Num", " block2Num", "block__number", "block2num", "blockIDdec", "block_n", "switch_no", "block1nam", " block_Num", "blocking10type", "sliceIDmat", "lock1typ", "blockIDname", "block1NUM", "block_alph", "block__tim", "def", "switch_nom", "lock1mon", "block1prim", "block8num", "block10num", "block67nu", "blockixnum", " block2um", "block_um", " block_nu", "block64norm", "block4digit", "block_span", "block1dec", " block_digit", "block_nam", "Block_NUM", "co", "block_mat", "bridgepronum", "block_no", "block8sum", "lock_number", "blockipnum", "lock_NUM", "block2nu", "into", "block1name", "cmp", "blockPum", "blockPsum", "block67um", "block10mat", "blocking_type", "block8number", "blockPnom", "batch10mon", "block4Num", "block1num", "blockPalph", "chain_um", "block_cum", "block_mon", "blockipspan", "batch_mon", "block2sum", "slice_mat", "block_prim", "block2um", "batch_num", "block10type", "block_sum", "block64type", "chain_alph", "batch_um", "lock1nam", "block_NUM", "batch_mat", "block_cmp", "cont", "blockpron", "blockpronum", "block_nu", "slice_dec", "bridgepron"], "s": ["bs", "fs", "conv", "space", "ed", "ps", "ms", "js", "sa", "g", "sh", "sd", "sw", "ex", "se", "sc", "sm", "y", "sis", "h", "sb", "series", "sql", "os", "als", "sv", "has", "er", "an", "m", "sports", "as", "sp", "size", "j", "css", "t", "is", "stat", "f", "south", "ns", "rs", "sl", "x", "S", "session", "c", "comm", "sys", "si", "vs", "ls", "hs", "ats", "its", "al", "ims", "csv", "sq", "ts", "a", "bits", "qs", "ss", "sts", "i", "n", "z", "ses", "conf", "p", "es", "sam", "xs", "aws", "gs", "b", "dev", "spec", "bis", "less", "ds", "self", "cs", "stats", "w", "sym"], "right_cbp": ["right___gbf", "right_cbf", "right_sbp", "right_cpp", "right_cbpl", "right_cbm", "right_gbm", "right_rbm", "right_cbpoint", "right_wspre", "right_gbf", "right_ctrlpre", "right_cppop", "right_ctrlp", "right_rbf", "right_cbpop", "right_cppre", "right___cbpoint", "right_wsp", "right_rbp", "right_gbP", "right___cbf", "right___gbp", "right___gbm", "right_sbpoint", "right_wspop", "right___cbp", "right_cbpre", "right___gbP", "right_cvP", "right___cbm", "right_ctrlpl", "right_cppl", "right_cvpoint", "right_wspl", "right_gbpoint", "right_gbp", "right___gbpoint", "right_sbP", "right_cvm", "right_cvf", "right___cbP", "right_cvp", "right_cbP", "right_ctrlpop", "right_sbf"], "right_is_intra": ["right_is_itron", "right_is_istro", "right_is_indara", "right_is_indra", "right_is_instron", "right_is_itras", "right_is_itran", "right_is_instras", "right_is_istra", "right_is_interara", "right_is_intron", "right_is_indro", "right_is_interran", "right_is_instro", "right_is_instra", "right_is_itro", "right_is_istara", "right_is_interra", "right_is_intran", "right_is_interro", "right_is_instara", "right_is_itara", "right_is_intara", "right_is_itra", "right_is_interras", "right_is_indron", "right_is_intro", "right_is_intras", "right_is_interron", "right_is_instran", "right_is_istron"], "idx": ["ideex", "ridex", "ridx", "idX", " idX", "ridX", " idex", "idex", "ideX"], "ttblk": ["txtblK", "ttvj", "txtBLK", "ttvk", "ttBLn", "txtBLj", "ttBlK", "txtblj", "txtblk", "ttBLj", "ttvn", "ttBLK", "txtBLn", "ttvK", "ttBlj", "txtbln", "ttblK", "ttBLk", "txtBLk", "ttBlk", "ttbln", "ttBln", "ttblj"], "dst": ["delend", "bdst", "delsts", "delst", "rut", "bdut", "dsts", "bdput", " drc", "dput", "dest", " dest", "duest", "rend", " dput", "Dst", "delrc", "ddest", "rsts", "Ddest", "rst", " dsts", "rdest", "dubr", "dust", "bddest", "Dput", "rrc", " dend", "dbr", " dbr", "dut", "Dut", "rbr", "dend", "duput", "rest", "drc", "rput"], "mv": ["rmtv", "Mv", "mvs", " mvt", " mvs", "Mx", " mtv", "rmvc", "nv", "ntv", "mvt", " mx", "rmv", " mvc", "Mvs", "Mvc", "rx", "rvs", "rv", "mvc", "mtv", "mx", "nvt", "nvc", "rmvt", "rvc"]}}
{"project": "FFmpeg", "commit_id": "5afe1d27912be9b643ffb4ddc21f6d920260dbb0", "target": 1, "func": "static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    int len;\n\n\n\n    for(;;) {\n\n        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);\n\n        if (len != TS_PACKET_SIZE)\n\n            return len < 0 ? len : AVERROR_EOF;\n\n        /* check packet sync byte */\n\n        if ((*data)[0] != 0x47) {\n\n            /* find a new packet start */\n\n            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);\n\n            if (mpegts_resync(s) < 0)\n\n                return AVERROR(EAGAIN);\n\n            else\n\n                continue;\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 13316, "substitutes": {"s": ["bs", "i", "fs", "sg", "n", "sb", "ses", "als", "os", "S", "c", "sv", "ps", "conf", "st", "p", "sys", "r", "m", "hs", "ms", "aws", "gs", "ats", "b", "js", "tp", "as", "ctx", "sp", "g", "j", "sq", "sw", "t", "ds", "cs", "ts", "sc", "is", "a", "v", "f", "ins", "scl", "ns", "ss"], "buf": ["uf", "queue", "ref", "bytes", "tmp", "bc", "br", "rb", "Buff", " buff", "bh", "cb", "p", "img", "bound", " buffer", " bu", "buff", "read", "mem", "b", "window", "db", "box", "buffer", "cv", "Buffer", "cap", "msg", "lim", "seq", "bp", "pad", "v", "wb", "doc", "mu"], "raw_packet_size": ["raw_packets_area", "raw_packetewlen", "raw_packetewsize", "raw_packets_size", "raw_packetewarea", "raw_packetewSIZE", "raw_packet_len", "raw_packets_len", "raw_packet_SIZE", "raw_packets_SIZE", "raw_packet_area"], "data": ["d", "cache", " DATA", "bytes", "image", "map", "extra", "Data", "partial", "maybe", "n", "DATA", "trans", "format", "flags", "next", "ata", "p", "def", "batch", "empty", "any", "raw", "name", "read", "good", "mitted", "window", "buffer", "block", "no", "done", "size", "str", "load", "msg", "bin", "t", "aw", "kat", "a", "all", "text", "table", "length", "dat", "mu", "ns", "chan"], "pb": ["uf", "pkg", "bs", "jp", "fp", "lp", "sb", "pc", "bc", "dp", "tk", "bj", "rb", "pa", "xb", "px", "cm", "np", "lb", "cp", "cb", "bh", "pl", "p", "tg", "gp", "vp", "b", "tc", "pg", "tp", "mp", "buffer", "eb", "ctx", "db", "bb", "cv", "sp", "PB", "nb", "typ", "bp", "pt", "pan", "pp", "wb", "ab", "td", "pub", "gb", "pm", "ub"], "len": ["un", "dl", "l", "end", "lp", "tl", "n", "elt", "bytes", "sl", "Length", "z", "lc", "compl", "cmp", " l", "err", " clen", "ls", " bl", " le", " length", "pos", "ln", "e", "nt", "count", "lon", "hl", "sp", "ret", " el", "lic", "fun", "size", "str", "lf", "limit", "offset", "num", "L", "msg", "en", "seq", "el", "nl", "t", "ll", "fin", "il", "resp", "ld", "val", "all", "v", "Len", "f", "cmd", "length", "lit", "lan"]}}
{"project": "FFmpeg", "commit_id": "4381bddc9f93da34a44e683bdc4c05c6f061244e", "target": 0, "func": "int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)\n\n{\n\n    char *tail;\n\n    double srate = av_strtod(arg, &tail);\n\n    if (*tail || srate < 1 || (int)srate != srate) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Invalid sample rate '%s'\\n\", arg);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    *ret = srate;\n\n    return 0;\n\n}\n", "idx": 13339, "substitutes": {"ret": ["ft", "ref", "rep", "RET", "elt", "opt", "out", "re", "reg", "Ret", "result", "def", "arr", "r", "tr", "mem", "alt", "att", "rev", "nt", "rc", "repl", "res", "back", "fr", "mt", "gt", "report", "t", "ll", "rets", "rt", "val", "v", "f"], "arg": ["event", "oc", "cal", "ref", "ax", "inc", "ag", "asc", "alg", "reg", "claim", "ar", "argument", "pl", "p", "arr", "r", "tag", "args", "name", "target", "mac", "in", "match", "parse", "iter", "agg", "ack", "g", "str", "ad", "msg", "Arg", "enc", "param", "attr", "ary", "ig", "cmd", "val", "ac", "v", "var", "arp", "doc", "call"], "log_ctx": ["logctxcontext", "log_context", "logctxctx", "logctxtx", " log_lib", "log_lib", " log_ct", "log2kw", " log_kw", "logboxctx", "log2lib", "logctxct", "log_kw", "log2context", "log_tx", " log2ctx", " log2context", "log2ctx", "log_ct", " log2lib", " log2kw", "logboxcontext", "logboxkw", " log_context", " log_tx", "logboxlib"], "tail": ["foot", "wind", "sum", "l", "term", "lt", "tmp", "last", "ail", "ctl", "local", "temp", "col", "ul", "list", "ls", "bound", "alt", "iter", "len", "buffer", "lv", "index", "sp", "quit", "unit", "locked", "size", "tails", "limit", "offset", "lock", "gate", "det", "gt", "unt", "t", "pull", "ll", "il", "tt", "ts", "body", "head", "ld", "fat", "length", "got", "tailed"]}}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    int32_t op2;\n\n    int32_t r1;\n\n    uint32_t address;\n\n    TCGv temp;\n\n\n\n    r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n    address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n    op2 = MASK_OP_ABS_OP2(ctx->opcode);\n\n\n\n    temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n\n\n    switch (op2) {\n\n    case OPC2_32_ABS_ST_A:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);\n\n        break;\n\n    case OPC2_32_ABS_ST_D:\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);\n\n        break;\n\n    case OPC2_32_ABS_ST_DA:\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);\n\n        break;\n\n    case OPC2_32_ABS_ST_W:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);\n\n        break;\n\n\n\n    }\n\n    tcg_temp_free(temp);\n\n}\n", "idx": 13347, "substitutes": {"env": ["event", "map", "serv", "status", "stack", "txt", "node", "cur", "buf", "exec", "cb", "conf", "hw", "environment", "set", "impl", "cfg", "STATE", "viron", "dev", "ev", "en", "conn", "proc", "test", "cmd", "v", "scope"], "ctx": ["pkg", "bc", "history", "conv", "gz", "pool", "cmp", "cm", "np", "cp", "cb", "check", "kl", "mem", "js", "cv", "ann", "context", "info", "kw", "tmp", "txt", "Context", "cu", "except", "def", "mc", "jac", "cfg", "mk", "kh", "tc", "gc", "kt", "cf", "conn", "tm", "resp", "cmd", "shape", "kind", "jp", "req", "parent", "asm", "cas", "via", "etc", "exec", "loc", "sys", "cam", "cc", "ct", " cx", "work", "wcs", "xp", "json", "tx", "ctl", "setup", "xc", "hw", "conf", "xs", "desc", " context", "chain", "network", "act", "mom", "func", "crit", "config", "wx", "obj", "qt"], "op2": ["op6", " op6", " op02", "op4", "oper2", "Op2", "Op6", " op4", "OP5", "Op5", "r4", "opp4", "op02", "op5", "opt02", "r2", "Op4", "opp2", "OP4", "opp16", " opTwo", "opt2", "opp02", "oper16", "OP16", "oper02", " op5", "rTwo", "OP6", "oper4", "optTwo", "op16", "OP02", "opt4", "r02", "OP2", "opTwo"], "r1": ["r3", " r51", "r81", "l1", "kr1", " rMap", "nr1", " r3", "r2", "m2", "R1", "er001", "vrOne", " rOne", "l01", "row81", "r01", "ro01", "m1", "cr81", "rowOne", "rtName", "erOne", "ro001", "nr9", "rnFirst", "rName", "mrOne", "rangeOnce", "l81", "br51", "rtFirst", "srName", "ro1", "range1", "prFirst", "sr51", "R0", "vrMap", "R3", "pr51", "krMap", "vr1", "crMap", "rOne", "br001", "ro81", "r001", "sr1", "rt001", "rn1", "r51", "row51", "r9", "rt51", "nr001", "m3", "raj", "kraj", "srMap", "rn51", "range9", "rMap", "rt1", "l001", " r81", "r0", "range001", "sraj", "row1", "erMap", "R2", "brName", "nrOnce", "rOnce", "pr1", " r2", "mr81", "kr001", "mr1", "m0", "cr1", "cr01", "er9", " r0", "sr001", "cr001", "craj", "rFirst", "br1", "mr51", "er1", "erOnce"], "address": ["context", "shape", "i", "angle", "Address", "memory", "point", "padding", "word", "number", "addr", "alias", "interface", "message", "position", "capacity", "store", "ptr", "key", "port", "code", "trace", "reference", "buffer", "attribute", "block", "index", "path", "pointer", "size", "offset", "order", "ace", "a", "base", "table", "command", "length", "location", "output", "operation"], "temp": ["context", "sum", "fake", "timer", "tv", "emp", "cache", "time", "tem", "tmp", "level", "hum", "memory", "txt", "tx", "json", "cum", "draw", "local", "pool", "Temperature", "result", "tim", "EMP", "pretty", "p", "pre", "m", "porary", "ptr", "tr", "empty", "now", "mem", "tc", "trace", "iter", "buffer", "vt", "total", "mint", "index", "sp", "unit", "nom", "cont", "variable", "offset", "cap", "Temp", "max", "mod", "t", "perature", "template", "test", "unt", "tm", "pt", "v", "term", "w", "dat", "output", "current"]}}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_readdir(void *opaque)\n\n{\n\n    int32_t fid;\n\n    V9fsFidState *fidp;\n\n    ssize_t retval = 0;\n\n    size_t offset = 7;\n\n    uint64_t initial_offset;\n\n    int32_t count;\n\n    uint32_t max_count;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dqd\", &fid, &initial_offset, &max_count);\n\n\n\n    trace_v9fs_readdir(pdu->tag, pdu->id, fid, initial_offset, max_count);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        retval = -EINVAL;\n\n        goto out_nofid;\n\n    }\n\n    if (!fidp->fs.dir) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    if (initial_offset == 0) {\n\n        v9fs_co_rewinddir(pdu, fidp);\n\n    } else {\n\n        v9fs_co_seekdir(pdu, fidp, initial_offset);\n\n    }\n\n    count = v9fs_do_readdir(pdu, fidp, max_count);\n\n    if (count < 0) {\n\n        retval = count;\n\n        goto out;\n\n    }\n\n    retval = offset;\n\n    retval += pdu_marshal(pdu, offset, \"d\", count);\n\n    retval += count;\n\n    trace_v9fs_readdir_return(pdu->tag, pdu->id, count, retval);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, retval);\n\n}\n", "idx": 13357, "substitutes": {"opaque": ["oplaque", " opatile", "pvious", "obaque", "obatile", "obvious", "opvious", "obque", " opaques", "Opatile", "pque", "Opaques", "oplaques", "oplvious", "opque", "paque", "opatile", "obaques", " opque", "opaques", "oplque", "Opque", "paques", "Opaque"], "fid": ["fkid", "vname", "fId", "Fid", "gId", "Foid", "tfID", "gID", "efoid", " fname", "ifname", " faid", "faid", "ifid", "efId", "vid", "vpid", "tfoid", "foid", "ifpid", " foid", "gid", "tfId", "fID", "fname", "Faid", " fpid", "vkid", "fpid", "ifkid", " fID", " fkid", "gname", "vId", "efid", "FId", "vID", "tfname", " fId", "efaid", "tfid"], "fidp": ["flkeyp", " foidp", "fadphp", "fidentlp", "fIDb", "fpidp", "finp", "affidp", " fIdp", "fadp", "faidp", "fkeyps", " foidpe", "fbidphp", "flridpc", " fitp", "faidb", "fflagper", " fidpe", " fidper", "fidm", "finitper", "fitp", "fkeyphp", "fitpb", "fbidpos", "fidentpa", "foIDb", "foidm", "faidpost", "affidphp", "flkeypost", "fidentpos", "flidpost", "fadnp", "foidpe", "foidper", "fflaglp", "fidb", "affbidpa", "finitpb", "fpidpe", "flbidp", "foidps", "faidj", "fardper", "foidj", " fidm", "flkeyphp", "flridp", "fity", "faidps", "fIdpa", "flidpos", " fidy", "fidnp", "fIDpb", "flbidlp", "fIDy", " fIdpa", "fIDper", "fixp", "fardp", "fridphp", "affidpa", "finpe", "fkidnp", "fkidper", "fbidpa", "affbidphp", "fkeypost", "fidpost", "fIDp", "flidlp", " foidper", "fpidm", "fidpe", "foidphp", "flidnp", "fkidpc", " fidpa", "fbidper", "fpidper", "fidphp", "flidphp", "flbidpa", "flidp", "flidpa", "fbidp", "fridnp", "finitj", "fidlp", "finitpost", "flidpc", "fixphp", "affbidper", "fflagpa", "fidentp", "foidpost", "fidps", "fbidlp", "fridp", "fitper", "fIdper", "fidy", "finm", "fidpb", "fidpos", "flridnp", "affidper", "flridphp", "finper", "fflagp", "foIDpost", " fidpb", "affbidp", "finitp", "fixpa", "fIdp", "fixper", "flidps", " fitpb", "fkidp", "foIDp", "fardpa", "fflagpos", "fkidpa", "fkidphp", "fkeyp", " fIdper", "fridpc", "fIDpost", "flkeyps", "fidpa", "foidb", " fity", "foidp", "flbidpos", "fadpc", "fidper", "fidj", " fitper", "foIDj", "finitb", "fIDj", " foidm", "fidpc", "finity", "faidphp"], "initial_offset": ["initial_off", "initial__pos", "initial_len", "initialingoffset", "first_pos", "initiallyoffset", "initial_point", "Initial_length", "initial_count", "initial_Offset", " initial_off", "initial_pos", "first_off", "initial_index", "Initial_offset", "first_offset", " initial_pointer", "initialingpointer", "initial_range", "initialinglen", "initial__index", "initial_length", "initial__off", "Initial_Offset", " initial_len", "initial_pointer", " initial_range", " initial_count", " initial_point", "initialingOffset", "initial__offset", " initial_Offset", "initiallyoff", "initiallycount", "initiallyOffset", "initiallyrange", "initiallyindex", "first_index", "initiallypos"], "count": ["h", "ount", "sum", "cache", "l", "child", "ch", "type", "n", "time", "Count", "z", "counter", "error", "hash", "state", "depth", "number", "result", "c", "weight", "core", "force", "find", "currency", "list", "err", "start", "batch", "empty", "name", "read", "flag", "frequency", "code", "nt", "match", "cc", "len", "consider", "total", "buffer", "index", "iter", "size", "cont", "offset", "num", "amount", "max", "ct", "try", "comment", "found", "ctr", "nb", "order", "more", "cond", "cmd", "current", "all", "val", "command", "length", "process", "call"], "max_count": ["Max_Count", "maxJcount", "max32length", "max_state", " max_c", "max32c", "Max_count", "max_ctr", "max__c", "max32iter", " max_state", "max_iter", "max_result", "Max_sum", " max_iter", "maxJstate", " max_Count", " max_len", "max_Count", "max_c", "max_len", "Max_ctr", "maxJresult", "max__count", "max32count", " max_length", "max__length", "max_length", "max__iter", " max_result", "max_sum", "maxJCount"], "pdu": ["ptem", " puer", "yue", "prsu", "rdu", " pver", "opce", "fstat", " pdon", "repdu", "exptu", "reptu", "prdu", "vpuer", "ydu", "apda", "padu", " pcu", "expond", "mdu", "apcu", "funit", " pge", " pue", " pkt", "pdon", "pda", "pingcu", "pcdon", "expue", "repuu", "pcom", "pso", "pix", "ipce", "mkt", "ptu", "cpue", " pui", "preui", "psu", "cpdu", "opge", "pingde", "pretu", "mdef", "pptu", "pcdu", " ptem", "pde", "msu", "pcver", "perdu", "apdu", "punit", " pso", " pstat", "opdu", "iptu", "puu", "pingcom", " punit", "ipcu", "expdu", "pingud", "fdu", "ipkt", "perde", "pingso", "pingui", "pdef", " pix", " pud", "vpcom", "pingdu", " pce", "padon", "apge", "pcu", "ipdu", " pda", "ppui", "ppcu", "apde", " pond", "rstat", " pdef", "opuu", "apond", "paver", "apui", "cpge", "preue", "aptu", "repge", "pptem", "optu", " psu", "apue", "pstat", "cpcu", "perud", "paix", "runit", "vpso", "pver", " ptu", "pge", "apud", "pingsu", " pcom", "rcu", "pcix", "ytem", "pond", "perda", "ppdu", "predu", "pinguer", " pde", "fcu", "prdef", "pue", "vpdu", "pkt", "prkt", "apsu", " puu", "puer", "ycu", "pce", "pingtu", "opkt", "pingstat", "pui", "ipstat", "ppue", "pud"], "s": ["bs", "h", "i", "fs", "d", "rs", "n", "sb", "z", "os", "S", "session", "state", "c", "u", "sv", "ps", "p", "sys", "r", "set", "m", "ls", "gs", "b", "e", "js", "as", "ims", "sp", "g", "sq", "acs", "t", "ds", "ts", "is", "o", "v", "stats", "f", "ins", "w", "ns", "ss"]}}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    uint32_t cc = 0;\n\n    int old_exc = cs->exception_index;\n\n    uint64_t asc = env->psw.mask & PSW_MASK_ASC;\n\n    uint64_t ret;\n\n    int flags;\n\n\n\n    /* XXX incomplete - has more corner cases */\n\n    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {\n\n        program_interrupt(env, PGM_SPECIAL_OP, 2);\n\n    }\n\n\n\n    cs->exception_index = old_exc;\n\n    if (mmu_translate(env, addr, 0, asc, &ret, &flags)) {\n\n        cc = 3;\n\n    }\n\n    if (cs->exception_index == EXCP_PGM) {\n\n        ret = env->int_pgm_code | 0x80000000;\n\n    } else {\n\n        ret |= addr & ~TARGET_PAGE_MASK;\n\n    }\n\n    cs->exception_index = old_exc;\n\n\n\n    env->cc_op = cc;\n\n    return ret;\n\n}\n", "idx": 13363, "substitutes": {"env": ["pkg", "context", "h", "event", "worker", "esm", "req", "end", "sb", "esp", "nw", "server", "here", "cur", "nv", "sv", "hw", "eng", "st", "er", "cb", "environment", "forge", "org", " ens", "conf", "ptr", "vs", "et", "desc", "te", "console", "ah", "e", "dev", "window", "db", "cc", "sec", "vt", "ctx", "eh", "cv", "sp", "erd", "hl", "ev", "ew", "sw", "en", "conn", "enc", "proc", "ec", "esc", "ds", "nc", "Environment", "sc", "config", "cmd", "v", "obj", "qt", "vm"], "addr": ["wire", "usr", "ord", "ref", "rs", "address", "elt", "ag", "asc", "tx", "x", "off", "hash", "ip", "cmp", "src", "np", "ar", "hw", "dest", "adr", "alias", "oad", "loc", "arr", "r", "err", "add", "ptr", "host", "dr", "mb", "handle", "alt", "mem", "rc", "hl", "eth", "ack", "id", "size", "url", "res", "ad", "offset", "num", "msg", "mt", "gt", "coord", "nl", "arg", "attr", "net", "ix", "pad", "cmd", "arp", "obj"], "cs": ["bs", "fs", "rs", "CS", "cms", "ks", "ck", "checks", "cas", "ces", "c", "cp", "ps", "cons", "cer", "cn", "vs", "ls", "hs", "ms", "gs", "tc", "cc", "rc", "js", "ctx", "gc", "cv", "cus", "cf", "act", "Cs", "cks", "conn", "ys", "css", "acs", "ec", "ctr", "ds", "nc", "ts", "sc", "wcs", "ins", "qs", "obj", "ns", "sts"], "ret": ["ft", "ref", "rs", "end", "std", "RET", "elt", "nz", "txt", "x", "out", "re", "reg", "result", "Ret", "ext", " RET", "xt", "arr", "r", "ptr", "flag", "alt", "mem", "nt", "rev", "rc", "ert", "len", "url", "res", "str", "at", "back", "data", "mt", "try", "gt", "nl", "arg", "t", "test", "ll", "ter", "expr", "rets", "ts", " Ret", "resp", "rt", "val", "print", "lit"], "flags": ["fps", "fs", "mods", "kw", "rs", "ops", "files", "amps", "ps", "fields", "atts", "args", "bugs", "options", "ms", "flag", "gs", "acks", "Flags", "cc", "locks", "tags", "ags", "cf", "vals", "ents", "acs", "func", "ts", "acc", "cond", "acts", "bits", "wcs", "cmd", "comments", "stats", "lag", "mask"]}}
{"project": "qemu", "commit_id": "46181129eac9a56d9a948667282dd03d5015f096", "target": 0, "func": "static int bdrv_check_update_perm(BlockDriverState *bs, uint64_t new_used_perm,\n\n                                  uint64_t new_shared_perm,\n\n                                  BdrvChild *ignore_child, Error **errp)\n\n{\n\n    BdrvChild *c;\n\n    uint64_t cumulative_perms = new_used_perm;\n\n    uint64_t cumulative_shared_perms = new_shared_perm;\n\n\n\n    /* There is no reason why anyone couldn't tolerate write_unchanged */\n\n    assert(new_shared_perm & BLK_PERM_WRITE_UNCHANGED);\n\n\n\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n\n        if (c == ignore_child) {\n\n            continue;\n\n        }\n\n\n\n        if ((new_used_perm & c->shared_perm) != new_used_perm) {\n\n            char *user = bdrv_child_user_desc(c);\n\n            char *perm_names = bdrv_perm_names(new_used_perm & ~c->shared_perm);\n\n            error_setg(errp, \"Conflicts with use by %s as '%s', which does not \"\n\n                             \"allow '%s' on %s\",\n\n                       user, c->name, perm_names, bdrv_get_node_name(c->bs));\n\n            g_free(user);\n\n            g_free(perm_names);\n\n            return -EPERM;\n\n        }\n\n\n\n        if ((c->perm & new_shared_perm) != c->perm) {\n\n            char *user = bdrv_child_user_desc(c);\n\n            char *perm_names = bdrv_perm_names(c->perm & ~new_shared_perm);\n\n            error_setg(errp, \"Conflicts with use by %s as '%s', which uses \"\n\n                             \"'%s' on %s\",\n\n                       user, c->name, perm_names, bdrv_get_node_name(c->bs));\n\n            g_free(user);\n\n            g_free(perm_names);\n\n            return -EPERM;\n\n        }\n\n\n\n        cumulative_perms |= c->perm;\n\n        cumulative_shared_perms &= c->shared_perm;\n\n    }\n\n\n\n    return bdrv_check_perm(bs, cumulative_perms, cumulative_shared_perms, errp);\n\n}\n", "idx": 13365, "substitutes": {"bs": ["bos", "fs", "rs", "sb", "bytes", "bl", "aos", "bc", "bf", "blog", "os", "aus", "hz", "ubis", "bh", "ps", "bn", "sys", "s", "ib", "ls", "vs", "pb", "ms", "gs", "b", "its", "js", "db", "lbs", "ctx", "bis", "bas", "boxes", "res", "bps", "BS", "ds", "ubs", "bp", "cs", "ts", "bits", "bm", "obs", "ns"], "new_used_perm": ["new_zerofulpriv", "new_used67perm", "new_usedfulpriv", "new_use_attr", "new_use_pri", "new_usedfulmi", "new_used_req", "new_user_req", "new_use_priv", "new_used67attr", "new_used67req", "new_user_perm", "new_used_pixel", "new_used_attr", "new_used_prof", "new_use_prof", "new_zerofulperm", "new_used_pri", "new_used_priv", "new_use_per", "new_zerofulmi", "new_zero_mi", "new_zero_perm", "new_usedfulperm", "new_use_perm", "new_used_per", "new_used67pixel", "new_zero_priv", "new_used_mi", "new_user_attr", "new_user_pixel"], "new_shared_perm": ["new_sharedlyattr", "new_shared_ptr", "new_share_priv", "new_shared___perm", "new_shared_lim", "new_shared2attr", "new_sharedptperm", "new_shared_policy", "new_sharedptattr", "new_share_req", "new_shared___priv", "new_share_perm", "new_share_policy", "new_shared2mask", "new_shared___ptr", "new_sharedlyperm", "new_shared2perm", "new_share_mask", "new_sharedptpriv", "new_share_ptr", "new_shared2priv", "new_shared_req", "new_share_attr", "new_shared_priv", "new_shared_mask", "new_shared2req", "new_shared_attr", "new_shared___req", "new_sharedlylim", "new_sharedptpolicy"], "ignore_child": ["ignore_Child", "ignore_node", "ignore___node", "ignore___children", " ignore_node", "ignore___Child", " ignore_Child", "ignore___child", " ignore_parent", "ignore_parent", "ignore___parent", " ignore_children", "ignore_children"], "errp": ["errr", "ferps", " errP", " errps", "nerps", "dangerpkg", "rrr", "erP", "erp", "dangerpad", "errpad", "errps", "err", "rrP", "nerp", "ferpo", "ferpa", "errP", "dangerp", "rrp", "nerpa", "ierpkg", "errorps", "dangerpost", " errr", "errping", "rrpo", " errping", "nerpo", "errc", " errc", "errorpad", "errorpost", "rrc", "errpost", "errpo", "rrpa", "ierpad", "errorp", "errpa", "ierp", "errorpkg", "ierpost", "rrping", "ferp", "rrps", "errorping", "errpkg", "erc"], "c": ["ch", "k", "bc", "cm", "cp", "cb", "r", "cv", "g", "ci", "ca", "sc", "cr", "y", "vc", "cache", "con", "ctrl", "cu", "cn", "mc", "m", "tc", "common", "rc", "gc", "cus", "cf", "j", "anc", "enc", "t", "f", "abc", "l", "pc", "unc", "dc", "etc", "comm", "cam", "cc", "com", "ct", "ec", "o", "call", "co", "i", "container", "comp", "n", "lc", "cur", "col", "xc", "conf", "p", "C", "b", "e", "chain", "ctx", "ce", "cont", "cl", "cs", "fc", "config", "ac", "v", "cd", "w"], "user": ["device", "usr", "role", "info", "menu", "usable", "parent", "creator", "server", "word", "group", "util", "full", "password", "usage", "ip", "u", "browser", "er", "ver", "author", "admin", "human", "root", "client", "User", "from", "uid", "dirty", "us", "users", "valid", "student", "ser", "name", "dev", "home", "db", "per", "inner", "id", "um", "manager", "use", "me", "used", "usa", "class", "username", "actor", "prof", "file", "by", "USER", "or", "io", "owner"], "perm_names": ["permsauthors", "perm_strings", "perm_weights", "permmmlines", "gpmmtypes", "permlstrings", "permmmnas", "perm10names", "perm_nets", "permmmnames", "proc_names", "orig_strings", "gpmmnames", "per_chains", "permptnas", "perm32nets", "sym_states", "perm_authors", "permmatnets", "perm10authors", "proc_states", "orig3authors", "per_authors", "perm3nos", "provmmnets", "permmatAMES", "permlnames", "permmatdes", "permsnames", "perm_values", "perm8weights", "permmmdocs", "perm32AMES", "permmatns", "perm_ns", "gpmmnas", "perm_des", "per_names", "perm3authors", "gp_nas", "permptnames", "symmatns", "gp_lines", "proc_ames", "perm32docs", "perm_nas", "provmmAMES", "permmatames", "perm3names", "perm10values", "orig3names", "symmatdes", "sym_ns", "prov_names", "perm32names", "permmatlines", "provmmdocs", "perm_states", "permmattypes", "permmmAMES", "permsstrings", "perm8ames", "gp_names", "orig_authors", "orig_names", "permlnos", "orig3strings", "permmatnas", "perm_AMES", "perm_docs", "permlauthors", "permsnos", "perm_chains", "perm_ames", "permmatweights", "prov_AMES", "sym_des", "perm3strings", "permmmtypes", "perm10chains", "gpmmlines", "permmatnames", "sym_names", "permptlines", "perm_types", "orig3nos", "prov_docs", "permpttypes", "permmmnets", "permmatstates", "gp_types", "per_values", "proc_weights", "perm_nos", "prov_nets", "symmatnames", "perm8names", "provmmnames", "permmatdocs", "orig_nos", "perm8states", "perm_lines", "symmatstates"]}}
{"project": "qemu", "commit_id": "810f49b56a5d0cd6848856af51d3093ae9adc7b1", "target": 0, "func": "static void monitor_protocol_emitter(Monitor *mon, QObject *data)\n\n{\n\n    QDict *qmp;\n\n\n\n    qmp = qdict_new();\n\n\n\n    if (!monitor_has_error(mon)) {\n\n        /* success response */\n\n        if (data) {\n\n            assert(qobject_type(data) == QTYPE_QDICT);\n\n            qobject_incref(data);\n\n            qdict_put_obj(qmp, \"return\", data);\n\n        } else {\n\n            /* return an empty QDict by default */\n\n            qdict_put(qmp, \"return\", qdict_new());\n\n        }\n\n    } else {\n\n        /* error response */\n\n        qdict_put(mon->error->error, \"desc\", qerror_human(mon->error));\n\n        qdict_put(qmp, \"error\", mon->error->error);\n\n        QINCREF(mon->error->error);\n\n        QDECREF(mon->error);\n\n        mon->error = NULL;\n\n    }\n\n\n\n    if (mon->mc->id) {\n\n        qdict_put_obj(qmp, \"id\", mon->mc->id);\n\n        mon->mc->id = NULL;\n\n    }\n\n\n\n    monitor_json_emitter(mon, QOBJECT(qmp));\n\n    QDECREF(qmp);\n\n}\n", "idx": 13366, "substitutes": {"mon": ["jon", " monitor", "tem", "hon", "cat", "loader", "pers", "mn", "mem", "my", "Mon", "unit", "MON", "ann", "hog", "den", "mm", "mi", "man", "mu", "mond", "rem", "mun", "con", "serv", "dom", "util", "tim", "admin", "m", "annot", "monkey", "por", "num", "ten", "conn", "coord", "mit", "ston", "net", "cmd", "stat", "mat", "form", "zon", "tom", "about", "exec", "wat", "comm", "mut", "von", "min", "san", "trace", "mobile", "auth", "mons", "mt", "det", "proc", "non", "umi", "cond", "onet", "dm", "runner", "mor", "met", "monitor", "local", "ver", "sam", "mate", "mind", "don", "demon", "mitter", "mont", "dat"], "data": ["details", "rel", "d", "info", "cache", "type", "related", "parent", " DATA", "map", "present", "trans", "Data", "partial", "maybe", "content", "DATA", "join", "extra", "results", "what", "value", "full", "format", "hash", "result", "ata", "new", "wat", "rew", "p", "def", "zero", "batch", "m", "empty", "any", "valid", "raw", "name", "none", "buffer", "des", "instance", "no", "object", "done", "to", "id", "record", "res", "missing", "item", "unknown", "bin", "row", "normal", "snap", "some", "part", "o", "all", "text", "table", "obj", "dat", "query", "one"], "qmp": ["questtmp", "qep", "querycmp", "questmp", "iqpm", "querymet", "qmb", "qupp", " qomp", "quickmb", "qupm", "qpro", "qucmp", "qupro", " qtmp", "sqmp", "qumb", "qualpro", "questMP", "questomp", "qutmp", "quomp", "querymp", "qpm", "qcmp", " qpp", "querypp", "sqep", "querypro", "qpp", "quickcp", "qcp", "qomp", "quickpm", " qmb", "sqomp", "quickjp", "qujp", " qMP", "sqpp", "sqcomp", "qjp", "iqmp", "qtmp", "quMP", "sqcmp", "queryomp", "qmet", " qcp", "qualmet", "sqmet", "iqpp", "quickpp", " qcomp", "qumet", "sqcp", "qualcmp", "quep", "qMP", " qep", "quickmp", "sqjp", "qcomp", "qucp", "qualmp", "iqjp", "qucomp", "sqtmp", "qump", "querycp", "queryjp"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static inline int decode_vui_parameters(H264Context *h, SPS *sps)\n\n{\n\n    int aspect_ratio_info_present_flag;\n\n    unsigned int aspect_ratio_idc;\n\n\n\n    aspect_ratio_info_present_flag = get_bits1(&h->gb);\n\n\n\n    if (aspect_ratio_info_present_flag) {\n\n        aspect_ratio_idc = get_bits(&h->gb, 8);\n\n        if (aspect_ratio_idc == EXTENDED_SAR) {\n\n            sps->sar.num = get_bits(&h->gb, 16);\n\n            sps->sar.den = get_bits(&h->gb, 16);\n\n        } else if (aspect_ratio_idc < FF_ARRAY_ELEMS(pixel_aspect)) {\n\n            sps->sar = pixel_aspect[aspect_ratio_idc];\n\n        } else {\n\n            av_log(h->avctx, AV_LOG_ERROR, \"illegal aspect ratio\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else {\n\n        sps->sar.num =\n\n        sps->sar.den = 0;\n\n    }\n\n\n\n    if (get_bits1(&h->gb))      /* overscan_info_present_flag */\n\n        get_bits1(&h->gb);      /* overscan_appropriate_flag */\n\n\n\n    sps->video_signal_type_present_flag = get_bits1(&h->gb);\n\n    if (sps->video_signal_type_present_flag) {\n\n        get_bits(&h->gb, 3);                 /* video_format */\n\n        sps->full_range = get_bits1(&h->gb); /* video_full_range_flag */\n\n\n\n        sps->colour_description_present_flag = get_bits1(&h->gb);\n\n        if (sps->colour_description_present_flag) {\n\n            sps->color_primaries = get_bits(&h->gb, 8); /* colour_primaries */\n\n            sps->color_trc       = get_bits(&h->gb, 8); /* transfer_characteristics */\n\n            sps->colorspace      = get_bits(&h->gb, 8); /* matrix_coefficients */\n\n            if (sps->color_primaries >= AVCOL_PRI_NB)\n\n                sps->color_primaries = AVCOL_PRI_UNSPECIFIED;\n\n            if (sps->color_trc >= AVCOL_TRC_NB)\n\n                sps->color_trc = AVCOL_TRC_UNSPECIFIED;\n\n            if (sps->colorspace >= AVCOL_SPC_NB)\n\n                sps->colorspace = AVCOL_SPC_UNSPECIFIED;\n\n        }\n\n    }\n\n\n\n    /* chroma_location_info_present_flag */\n\n    if (get_bits1(&h->gb)) {\n\n        /* chroma_sample_location_type_top_field */\n\n        h->avctx->chroma_sample_location = get_ue_golomb(&h->gb) + 1;\n\n        get_ue_golomb(&h->gb);  /* chroma_sample_location_type_bottom_field */\n\n    }\n\n\n\n    sps->timing_info_present_flag = get_bits1(&h->gb);\n\n    if (sps->timing_info_present_flag) {\n\n        sps->num_units_in_tick = get_bits_long(&h->gb, 32);\n\n        sps->time_scale        = get_bits_long(&h->gb, 32);\n\n        if (!sps->num_units_in_tick || !sps->time_scale) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"time_scale/num_units_in_tick invalid or unsupported (%\"PRIu32\"/%\"PRIu32\")\\n\",\n\n                   sps->time_scale, sps->num_units_in_tick);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sps->fixed_frame_rate_flag = get_bits1(&h->gb);\n\n    }\n\n\n\n    sps->nal_hrd_parameters_present_flag = get_bits1(&h->gb);\n\n    if (sps->nal_hrd_parameters_present_flag)\n\n        if (decode_hrd_parameters(h, sps) < 0)\n\n            return AVERROR_INVALIDDATA;\n\n    sps->vcl_hrd_parameters_present_flag = get_bits1(&h->gb);\n\n    if (sps->vcl_hrd_parameters_present_flag)\n\n        if (decode_hrd_parameters(h, sps) < 0)\n\n            return AVERROR_INVALIDDATA;\n\n    if (sps->nal_hrd_parameters_present_flag ||\n\n        sps->vcl_hrd_parameters_present_flag)\n\n        get_bits1(&h->gb);     /* low_delay_hrd_flag */\n\n    sps->pic_struct_present_flag = get_bits1(&h->gb);\n\n\n\n    sps->bitstream_restriction_flag = get_bits1(&h->gb);\n\n    if (sps->bitstream_restriction_flag) {\n\n        get_bits1(&h->gb);     /* motion_vectors_over_pic_boundaries_flag */\n\n        get_ue_golomb(&h->gb); /* max_bytes_per_pic_denom */\n\n        get_ue_golomb(&h->gb); /* max_bits_per_mb_denom */\n\n        get_ue_golomb(&h->gb); /* log2_max_mv_length_horizontal */\n\n        get_ue_golomb(&h->gb); /* log2_max_mv_length_vertical */\n\n        sps->num_reorder_frames = get_ue_golomb(&h->gb);\n\n        get_ue_golomb(&h->gb); /*max_dec_frame_buffering*/\n\n\n\n        if (get_bits_left(&h->gb) < 0) {\n\n            sps->num_reorder_frames         = 0;\n\n            sps->bitstream_restriction_flag = 0;\n\n        }\n\n\n\n        if (sps->num_reorder_frames > 16U\n\n            /* max_dec_frame_buffering || max_dec_frame_buffering > 16 */) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Clipping illegal num_reorder_frames %d\\n\",\n\n                   sps->num_reorder_frames);\n\n            sps->num_reorder_frames = 16;\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n    if (get_bits_left(&h->gb) < 0) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"Overread VUI by %d bits\\n\", -get_bits_left(&h->gb));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13388, "substitutes": {"h": ["event", "ch", "cache", "l", "hh", "hd", "th", "history", "here", "x", "header", "ha", "hash", "http", "c", "q", "bh", "dh", "comm", "hw", "hz", "H", "p", "s", "m", "host", "hr", "handle", "hs", "kh", "ah", "b", "window", "her", "he", "ih", "eh", "hl", "rh", "sh", "hp", "help", "uh", "t", "oh", "hm", "v", "high", "ph", "y", "has", "w", "ht"], "sps": ["SPS", "isplays", " sists", "nsists", "jsps", "seps", "lspers", " sports", "asrs", "ispp", "eseps", "iseps", "spl", "asports", "asds", "Spers", "usiffs", " srs", "useps", " sposes", "esps", "sops", "sport", "iespoints", "asops", "spers", "iesposes", "nsps", " sp", "sds", "iesps", "nseps", "iesports", "jsops", "Srs", "isips", "iesplays", "lsports", " seps", "commplets", "portsiffs", "sips", "commpoints", "commports", "ispps", "lspp", "asists", "aspp", "sports", "jspers", "Spp", "spps", "siffs", "sp", "nsds", " sport", "isps", "commplays", "Spos", "ispos", "uspr", " spoints", "portseps", "insplets", "usips", "spr", "inspoints", "ispr", "usposes", "nsops", " sts", "insplays", " sips", "portsps", "usports", "commps", "unseps", " spp", "Sps", " spos", "asips", "atspps", " sops", "yesports", "nspers", "jsPS", "geseps", " splays", "sposes", "spose", "atspers", "uspps", "sists", " spers", "splets", "atsps", "iespps", "asps", "yesps", "isport", "asplays", "atsports", "gespers", "spos", " sds", "sts", "esports", "unsips", "commeps", "portsips", "aspoints", "gesps", "lsps", " sPS", "yespos", "sPS", " spl", "usps", " spose", "yespose", "asPS", "spp", " spps", "iesp", "gesops", "unsps", "asplets", "srs", "espr", "isports", "spoints", "splays", "ispers", "ispl", "insps", "unsiffs", "ists", "ispose"], "aspect_ratio_info_present_flag": ["aspect_ratio_info_Present_flags", "aspect_ratio_info_present_Flag", "aspect_ratio_info_Present_Flag", "aspect_ratio_info_present_flags", "aspect_ratio_info_present_log", "aspect_ratio_info_Present_flag", "aspect_ratio_info_Present_log", "aspect_ratio_info_Present_status", "aspect_ratio_info_present_status"], "aspect_ratio_idc": ["aspect_ratio_idz", "aspect_ratio_idex", "aspect_ratio_ridc", "aspect_ratio_cdc", "aspect_ratio_cdn", "aspect_ratio_idece", "aspect_ratio_idecos", "aspect_ratio2cdc", "aspect_ratio2idc", "aspect_ratio_idel", "aspect_ratio2cdl", "aspect_ratio_ridci", "aspect_ratio_sidcos", "aspect_ratio_idci", "aspect_ratio_ridl", "aspect_ratio_itl", "aspect_ratio_itn", "aspect_ratio_itz", "aspect_ratio_ridce", "aspect_ratio_Idx", "aspect_ratio_sidc", "aspect_ratio_idec", "aspect_ratio2cdn", "aspect_ratio_idn", "aspect_ratio_idl", "aspect_ratio_cdl", "aspect_ratio_itc", "aspect_ratio_sidx", "aspect_ratio_Idce", "aspect_ratio_Idc", "aspect_ratio_iden", "aspect_ratio_idcos", "aspect_ratio_idx", "aspect_ratio2idl", "aspect_ratio2idz", "aspect_ratio_sidn", "aspect_ratio_idce", "aspect_ratio2idn", "aspect_ratio_ridx", "aspect_ratio_Idci", "aspect_ratio_cdz", "aspect_ratio2cdz"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,\n\n                          const uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    int ret;\n\n\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (!drv->bdrv_write_compressed) {\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_check_request(bs, sector_num, nb_sectors);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);\n\n}\n", "idx": 13415, "substitutes": {"bs": ["bos", "fs", "bid", "rs", "sb", "bytes", "aos", "bc", "ses", "blog", "bes", "aus", "ubis", "hz", "bh", "ps", "sys", "es", "vs", "ls", "pb", "hs", "ms", "gs", "b", "its", "iss", "js", "uts", "isc", "lbs", "locks", "gc", "bis", "bas", "boxes", "cks", "bps", "BS", "ds", "ubs", "bp", "bsp", "cs", "ts", "bits", "qs", "bm", "obs", "ns", "sts"], "sector_num": ["sectorNameNum", "section_Num", "server_na", "section_no", "sector_no", "serverlyna", "sector_Num", " sector_pos", "server_sym", "sectorlyna", "sectoritynm", "section_num", " sector_nm", "serverlynum", "sectorNamena", "serverlyNum", "sectoritynumber", "sector_pos", "sector_nm", "sector_number", "serverlysym", "sectoritynum", "sectorlyNum", "sectoritypos", "sector_na", "sectorlynum", "sectorlysym", "server_num", " sector_number", "sectorNamenum", "sector_sym", "server_Num", "sectorNamesym", "section_number"], "buf": ["uf", "pkg", "queue", "map", "bytes", "alloc", "br", "next", "Buff", "result", "cb", "p", "vec", "batch", "pb", "raw", "buff", "bag", "mem", "b", "window", "box", "buffer", "block", "cv", "Buffer", "cap", "msg", "data", "seq", "BU", "proc", "enc", "pack", "func", "aka", "cmd", "text", "doc"], "nb_sectors": ["nb_seectors", "nb_beers", "nb_veors", "nb_seeors", "nb_vectors", "nb_veers", "nb_perseitors", "nb_veitors", "nb_veurers", "nb_seers", "nb_sergments", "nb_peors", "nb_SEors", "nb_SEctors", "nb_SEitors", "nb_seors", "nb_peurers", "nb_perseors", "nb_pegments", "nb_seurers", "nb_seitors", "nb_persegments", "nb_serers", "nb_begments", "nb_vegments", "nb_pectors", "nb_serors", "nb_SEgments", "nb_serctors", "nb_seeurers", "nb_beors", "nb_persectors", "nb_seegments", "nb_segments", "nb_bectors"], "drv": ["hrr", " drm", "driv", "rdve", "drvs", "drf", "drw", "DRm", "rdh", " drf", "darw", "srvr", "drvr", "vrm", "Drvc", "rdf", "srvs", "rdv", "drr", "DRf", "Drw", "hrh", "srw", "darvr", "hrve", "DRvr", "vrvr", "vrv", "hrv", "darv", "rdr", "Drvr", "DRvc", "drh", "rdw", " drr", "darvc", " drvr", "srv", "DRv", "drvc", " drh", "drif", "drivs", "Drv", "DRw", "Drf", "drve", "vrf", " drve", "drm", "driw", "rdvs", "srf", " drw"], "ret": ["ft", " alt", "RET", "elt", "lt", "pret", "status", "txt", "out", "re", "hash", "Ret", "result", "ext", "def", "arr", "zero", "err", "tr", "desc", "flag", "alt", "code", "nt", "rev", "cert", "len", "final", "fun", "cont", "res", "j", "num", "mt", "det", "gt", "ctr", "try", "t", "ter", "rets", " Ret", "resp", "rt", "deg", "val", "print", "cmd", "reset", "rem"]}}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int usb_host_handle_control(USBDevice *dev, USBPacket *p,\n\n               int request, int value, int index, int length, uint8_t *data)\n\n{\n\n    USBHostDevice *s = DO_UPCAST(USBHostDevice, dev, dev);\n\n    struct usbdevfs_urb *urb;\n\n    AsyncURB *aurb;\n\n    int ret;\n\n\n\n    /*\n\n     * Process certain standard device requests.\n\n     * These are infrequent and are processed synchronously.\n\n     */\n\n\n\n    /* Note request is (bRequestType << 8) | bRequest */\n\n    trace_usb_host_req_control(s->bus_num, s->addr, request, value, index);\n\n\n\n    switch (request) {\n\n    case DeviceOutRequest | USB_REQ_SET_ADDRESS:\n\n        return usb_host_set_address(s, value);\n\n\n\n    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\n\n        return usb_host_set_config(s, value & 0xff);\n\n\n\n    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:\n\n        return usb_host_set_interface(s, index, value);\n\n    }\n\n\n\n    /* The rest are asynchronous */\n\n\n\n    if (length > sizeof(dev->data_buf)) {\n\n        fprintf(stderr, \"husb: ctrl buffer too small (%d > %zu)\\n\",\n\n                length, sizeof(dev->data_buf));\n\n        return USB_RET_STALL;\n\n    }\n\n\n\n    aurb = async_alloc(s);\n\n    aurb->packet = p;\n\n\n\n    /*\n\n     * Setup ctrl transfer.\n\n     *\n\n     * s->ctrl is laid out such that data buffer immediately follows\n\n     * 'req' struct which is exactly what usbdevfs expects.\n\n     */\n\n    urb = &aurb->urb;\n\n\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n\n    urb->endpoint = p->devep;\n\n\n\n    urb->buffer        = &dev->setup_buf;\n\n    urb->buffer_length = length + 8;\n\n\n\n    urb->usercontext = s;\n\n\n\n    trace_usb_host_urb_submit(s->bus_num, s->addr, aurb,\n\n                              urb->buffer_length, aurb->more);\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n\n\n    DPRINTF(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n\n\n    if (ret < 0) {\n\n        DPRINTF(\"husb: submit failed. errno %d\\n\", errno);\n\n        async_free(aurb);\n\n\n\n        switch(errno) {\n\n        case ETIMEDOUT:\n\n            return USB_RET_NAK;\n\n        case EPIPE:\n\n        default:\n\n            return USB_RET_STALL;\n\n        }\n\n    }\n\n\n\n    return USB_RET_ASYNC;\n\n}\n", "idx": 13426, "substitutes": {"dev": ["device", "h", "d", "info", "dem", "ve", "av", "DEV", "priv", "app", "server", "devices", "serial", "out", "os", "go", "buf", "gu", "np", "addr", "hw", "conf", "ver", "def", "sys", "scan", "cam", "pro", "vp", "raw", "Device", "mem", "nt", "home", "des", "Dev", "ctx", "spec", "dd", "path", "de", "env", "g", "ev", "ad", "sd", "iv", "disk", "conn", "unknown", "normal", "proc", "det", "hid", "test", "self", "debug", "api", "pad", "o", "val", "v", " device", "obj", "adv", "w"], "p": ["pkg", "h", "i", "device", "d", "jp", "lp", "pc", "pe", "dp", "pa", "np", "c", "cp", "q", "ps", "pers", "ap", "patch", "wp", "r", "pre", "m", "pb", "vp", "pay", "b", "pd", "tp", "sp", "P", "g", "j", "press", "pat", "t", "phy", "pt", "o", "pp", "v", "par", "f", "ping", "w", "pm"], "request": ["event", "rank", "requ", "req", "version", "type", "select", "address", "direction", "condition", "task", "error", "frame", "input", "service", "begin", "q", "argument", "enter", "Request", "change", "set", "position", "push", "flag", "method", "seek", "response", "reason", "reference", "attribute", "each", "object", "mode", "access", "item", "param", "order", "quest", "feature", "cmd", "command", "mask", "query", "call", "reset"], "value": ["device", "version", "type", "address", "ve", "time", "success", "hello", "json", "server", "x", "local", "state", "number", "weight", "message", "change", "position", "set", "start", "key", "valid", "raw", "flow", "Value", "port", "name", "expression", "array", "count", "initial", "buffer", "field", "attribute", "total", "size", "see", "values", "VALUE", "variable", "max", "vector", "python", "widget", "fee", "ue", "val", "ceive", "v", "function", "wise", "current"], "index": ["event", "i", "device", "ind", "type", "address", "condition", "level", "insert", "success", "status", "point", "server", "x", "error", "ion", "frame", "number", "service", "connect", "interface", "position", "set", "start", "Index", "key", "timeout", "port", "pos", "seek", "count", "id", "size", "offset", "num", "lock", "row", "open", "vector", "order", "test", "axis", "val", "command", "location"], "length": ["shape", "h", "l", "end", "angle", "address", "stop", "expected", "type", "time", "ow", "Length", "hello", "padding", "format", "sequence", "full", "number", "ength", "enth", "maximum", "message", "bus", "capacity", "height", "ptr", "ish", "ENGTH", "count", "len", "buffer", "total", "loop", "size", "html", "duration", "load", "offset", "row", "max", "vector", "t", "all"], "data": ["device", "d", "end", "Data", "tu", "DATA", " d", "buf", "input", "ata", "def", "bus", " input", " buffer", "name", "buffer", "size", "bin", "val", "text", " device", "dat"], "s": ["bs", "fs", "sn", "ties", "space", "http", "ps", "r", "ms", "js", "sa", "g", "sh", "sd", "sw", "se", "y", "sis", "h", "d", "changes", "sb", "serv", "os", "sv", "set", "an", "store", "socket", "as", "sp", "j", "is", "f", "ns", "l", "rs", "sl", "S", "service", "c", "sys", "ess", "ls", "vs", "hs", "ats", "its", "ims", "sq", "ts", "a", "qs", "sts", "ss", "i", "n", "z", "ses", "es", "gs", "b", "e", "spec", "bis", "ds", "self", "cs", "stats", "w", "simple"], "urb": ["uf", "udi", "obl", "deb", "utt", " turb", "hum", "ur", "urus", "bf", "rib", "rb", "usb", "urbed", "cb", "conf", "aud", "impro", "urt", "ust", "ib", "aff", "urg", "uv", "ofer", "aur", "pb", "ug", "img", "abuse", "err", "obb", "eb", "ief", "urban", "zb", "uff", "ocr", "erb", "fine", "uj", "orb", "amb", "uh", "ud", "anim", "tur", "comment", "nb", "ury", "gob", "eur", "ub", "ob", "ruff", "uph", "aux", "orum", "rob"], "aurb": ["airnb", "urchab", "urda", "aurbd", "urchbs", "thurl", "urcha", "airf", "urchy", "augb", "aurbb", "aurba", "url", "aurabd", "urchbar", "thurf", "thurbe", "aurf", "auraba", "scarb", "thurbd", "urchnb", "thurbb", "airu", "urchend", "thuru", "aitb", "urbb", "aury", "aurab", "urchrb", "thurbs", "aurnb", "augba", "aurB", "thurB", "aurend", "urchf", "urchbe", "aitbar", "aurrb", "aurl", "urchl", "urchB", "aurbe", "aitB", "airB", "scara", "thurbar", "urdbb", "airb", "aucbs", "aucl", "thurba", "thura", "urdB", "thurb", "scarB", "thury", "thurnb", "ury", "thurend", "aurbs", "thurrb", "auru", "airbe", "augbd", "aitrb", "auraB", "aura", "urB", "urchbb", "aurbar", "aucend", "scarbb", "urchu", "augB", "aira", "urchb", "urdb", "urab", "aucb", "thurab"], "ret": ["ft", "ref", "RET", "elt", "lt", "nz", "x", "out", "re", "reply", "run", "Ret", "result", " RET", "not", "arr", "err", "r", "store", "tf", "tr", "flag", "alt", "nt", "rev", "cert", "ert", "len", "fun", "cont", "job", "res", "back", "det", "gt", "t", "arg", "ter", "rets", " Ret", "resp", "rt", "deg", "val", "rest", "encrypted", "reset", "rem"]}}
{"project": "FFmpeg", "commit_id": "6abc56e892c2c2500d1fc2698fa6d580b72f721b", "target": 1, "func": "static int dshow_read_header(AVFormatContext *avctx)\n\n{\n\n    struct dshow_ctx *ctx = avctx->priv_data;\n\n    IGraphBuilder *graph = NULL;\n\n    ICreateDevEnum *devenum = NULL;\n\n    IMediaControl *control = NULL;\n\n    IMediaEvent *media_event = NULL;\n\n    HANDLE media_event_handle;\n\n    HANDLE proc;\n\n    int ret = AVERROR(EIO);\n\n    int r;\n\n\n\n    CoInitialize(0);\n\n\n\n    if (!ctx->list_devices && !parse_device_name(avctx)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Malformed dshow input string.\\n\");\n\n        goto error;\n\n    }\n\n\n\n    ctx->video_codec_id = avctx->video_codec_id ? avctx->video_codec_id\n\n                                                : AV_CODEC_ID_RAWVIDEO;\n\n    if (ctx->pixel_format != AV_PIX_FMT_NONE) {\n\n        if (ctx->video_codec_id != AV_CODEC_ID_RAWVIDEO) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Pixel format may only be set when \"\n\n                              \"video codec is not set or set to rawvideo\\n\");\n\n            ret = AVERROR(EINVAL);\n\n            goto error;\n\n        }\n\n    }\n\n    if (ctx->framerate) {\n\n        r = av_parse_video_rate(&ctx->requested_framerate, ctx->framerate);\n\n        if (r < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Could not parse framerate '%s'.\\n\", ctx->framerate);\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    r = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,\n\n                         &IID_IGraphBuilder, (void **) &graph);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not create capture graph.\\n\");\n\n        goto error;\n\n    }\n\n    ctx->graph = graph;\n\n\n\n    r = CoCreateInstance(&CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,\n\n                         &IID_ICreateDevEnum, (void **) &devenum);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not enumerate system devices.\\n\");\n\n        goto error;\n\n    }\n\n\n\n    if (ctx->list_devices) {\n\n        av_log(avctx, AV_LOG_INFO, \"DirectShow video devices\\n\");\n\n        dshow_cycle_devices(avctx, devenum, VideoDevice, NULL);\n\n        av_log(avctx, AV_LOG_INFO, \"DirectShow audio devices\\n\");\n\n        dshow_cycle_devices(avctx, devenum, AudioDevice, NULL);\n\n        ret = AVERROR_EXIT;\n\n        goto error;\n\n    }\n\n    if (ctx->list_options) {\n\n        if (ctx->device_name[VideoDevice])\n\n            dshow_list_device_options(avctx, devenum, VideoDevice);\n\n        if (ctx->device_name[AudioDevice])\n\n            dshow_list_device_options(avctx, devenum, AudioDevice);\n\n        ret = AVERROR_EXIT;\n\n        goto error;\n\n    }\n\n\n\n    if (ctx->device_name[VideoDevice]) {\n\n        if ((r = dshow_open_device(avctx, devenum, VideoDevice)) < 0 ||\n\n            (r = dshow_add_device(avctx, VideoDevice)) < 0) {\n\n            ret = r;\n\n            goto error;\n\n        }\n\n    }\n\n    if (ctx->device_name[AudioDevice]) {\n\n        if ((r = dshow_open_device(avctx, devenum, AudioDevice)) < 0 ||\n\n            (r = dshow_add_device(avctx, AudioDevice)) < 0) {\n\n            ret = r;\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    ctx->mutex = CreateMutex(NULL, 0, NULL);\n\n    if (!ctx->mutex) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not create Mutex\\n\");\n\n        goto error;\n\n    }\n\n    ctx->event[1] = CreateEvent(NULL, 1, 0, NULL);\n\n    if (!ctx->event[1]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not create Event\\n\");\n\n        goto error;\n\n    }\n\n\n\n    r = IGraphBuilder_QueryInterface(graph, &IID_IMediaControl, (void **) &control);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media control.\\n\");\n\n        goto error;\n\n    }\n\n    ctx->control = control;\n\n\n\n    r = IGraphBuilder_QueryInterface(graph, &IID_IMediaEvent, (void **) &media_event);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media event.\\n\");\n\n        goto error;\n\n    }\n\n    ctx->media_event = media_event;\n\n\n\n    r = IMediaEvent_GetEventHandle(media_event, (void *) &media_event_handle);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media event handle.\\n\");\n\n        goto error;\n\n    }\n\n    proc = GetCurrentProcess();\n\n    r = DuplicateHandle(proc, media_event_handle, proc, &ctx->event[0],\n\n                        0, 0, DUPLICATE_SAME_ACCESS);\n\n    if (!r) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not duplicate media event handle.\\n\");\n\n        goto error;\n\n    }\n\n\n\n    r = IMediaControl_Run(control);\n\n    if (r == S_FALSE) {\n\n        OAFilterState pfs;\n\n        r = IMediaControl_GetState(control, 0, &pfs);\n\n    }\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not run filter\\n\");\n\n        goto error;\n\n    }\n\n\n\n    ret = 0;\n\n\n\nerror:\n\n\n\n    if (devenum)\n\n        ICreateDevEnum_Release(devenum);\n\n\n\n    if (ret < 0)\n\n        dshow_read_close(avctx);\n\n\n\n    return ret;\n\n}\n", "idx": 13429, "substitutes": {"avctx": ["afdj", "avesettings", " avcmp", "awcontext", "abcontext", "navwcs", "avtx", "avecfg", "ajpkg", "aircpu", "avcfg", "ovcfg", "avcpu", " avcontext", "avsetup", "avecb", "avwcs", "afcb", "awctx", " avcb", " avtmp", "ovtmp", "avtmp", "awjp", " avcv", "avewcs", "ajctx", "avepkg", "ajdj", "afcontext", "ovctx", " avcpu", "avpkg", "navctx", "aftx", "ajfx", "evcontext", "ovcontext", "avectx", "avjp", "afctx", "avefx", "aircontext", "abconn", " avsetup", " avpkg", "avdj", " avconn", " avsettings", "abtx", "airjp", "airctx", "svcv", "svtmp", "avcontext", "avesetup", "avecontext", "abctx", "avecv", "afsettings", "avedj", "affx", "svcmp", "svtx", "avfx", "avcmp", "evtx", " avjp", "evctx", "navsetup", "evcmp", "awcpu", " avcfg", "afpkg", "avetx", " avtx", "svctx", "avsettings", "ovtx", "avcv", "avconn", "aveconn", "svcfg", "ovdj", "afcfg", " avwcs", "svcontext", "svdj", "avcb", "navcontext"], "ctx": ["pkg", "tk", "cmp", "px", "cm", "np", "addr", "cp", "cb", "this", "check", "kl", "cv", "vals", "acl", "ca", "td", "context", "that", "kw", "tmp", "ck", "txt", "ctrl", "Context", "cu", "jac", "cfg", "timeout", "tc", "gc", "cf", "kt", "conn", "tm", "cmd", "doc", "abc", "kind", "ind", "prefix", "req", "parent", "unc", "etc", "buf", "c", "comm", "loc", "ppo", "nt", "cc", "note", "index", "ka", "ct", "handler", "work", "wcs", "xp", "tx", "lc", "ctl", "local", "setup", "xc", "hw", "conf", "yes", "p", "desc", "module", "act", "crit", "fc", "config", "wx", "scope", "obj", "qt"], "graph": ["gd", "context", "shape", "cache", "adj", "container", "map", "png", "stack", "memory", "history", "json", "go", "node", "Graph", "draw", "raph", "buf", "reg", "connection", "via", "background", "browser", "document", "media", "pen", "tree", "connect", "ograph", "org", "host", "growth", "dr", "storage", "name", "window", "pg", "domain", "network", "gen", "gc", "path", "subject", "g", "igraph", "layout", "data", "conn", "msg", "driver", "order", "widget", "gr", "config", "man", "doc", "hold", "stream", "profile"], "devenum": ["Devenumb", "devenumb", "deiennum", " devenumb", "deennum", "devinenum", "deenumb", " deiennum", " devenumer", " deienumb", "deienumb", "deienumer", "devinom", "deienum", "Deenumb", "devenom", "devinum", "Deenom", "Devenenum", " deienum", "Deenum", " devennum", "devinumb", "devenenum", "deenom", "deenenum", "Devenum", "devennum", "deenum", " deienumer", "deenumer", "Deenenum", "Devenom", "devenumer"], "control": ["Control", "management", "success", "content", "history", "format", "ctrl", "ctl", "error", "information", "media", "connect", "change", "support", "controller", "cont", "script", "record", "contact", "controlled", "driver", "rol", "crit", "config", "command", "form", "hold", "edit"], "media_event": ["media___event", "media_Event", "media_command", " media_error", " media_command", " media_Event", "media___Event", "media___command", "media___error", "media_error"], "media_event_handle": ["media_event_handler", "media_error_object", "media_error_Handle", "media_event_object", "media_error_handler", "media_event_Handle", "media_error_handle"], "proc": ["cache", "reader", "pc", "tmp", "progress", "alloc", "serial", "cur", "cmp", "pid", "processor", "exec", "p", "sys", "ptr", "ser", "console", "pointer", "gc", "loop", " PROC", "func", "camera", " Proc", "debug", "program", "obj", "process"], "r": ["h", "i", "usr", "rate", "d", "l", "rs", "rel", "n", "rin", "status", "z", "br", "rb", "error", "re", "run", "result", "ar", "c", "q", "er", "p", "arr", "err", "m", "ran", "R", "dr", "rd", "entry", "e", "rc", "rr", "nr", "ret", "rect", "g", "res", "j", "rg", "rn", "record", "rad", "rar", "row", "fr", "rm", "sr", "mr", "t", "attr", "pr", "resp", "rt", "ral", "cr", "v", "f", "kr", "lr", "or", "w"]}}
{"project": "qemu", "commit_id": "274250c30158f60aefb46088a7bb0d711061226c", "target": 1, "func": "static inline void s390_machine_initfn(Object *obj)\n\n{\n\n    object_property_add_bool(obj, \"aes-key-wrap\",\n\n                             machine_get_aes_key_wrap,\n\n                             machine_set_aes_key_wrap, NULL);\n\n    object_property_set_description(obj, \"aes-key-wrap\",\n\n            \"enable/disable AES key wrapping using the CPACF wrapping key\",\n\n\n    object_property_set_bool(obj, true, \"aes-key-wrap\", NULL);\n\n\n\n    object_property_add_bool(obj, \"dea-key-wrap\",\n\n                             machine_get_dea_key_wrap,\n\n                             machine_set_dea_key_wrap, NULL);\n\n    object_property_set_description(obj, \"dea-key-wrap\",\n\n            \"enable/disable DEA key wrapping using the CPACF wrapping key\",\n\n\n    object_property_set_bool(obj, true, \"dea-key-wrap\", NULL);\n\n    object_property_add_str(obj, \"loadparm\",\n\n            machine_get_loadparm, machine_set_loadparm, NULL);\n\n    object_property_set_description(obj, \"loadparm\",\n\n            \"Up to 8 chars in set of [A-Za-z0-9. ] (lower case chars converted\"\n\n            \" to upper case) to pass to machine loader, boot manager,\"\n\n            \" and guest kernel\",\n\n\n\n\n\n\n\n\n\n}", "idx": 13437, "substitutes": {"obj": ["pkg", "dl", "ind", "req", "kw", "n", "elt", "tmp", "nw", "ck", "txt", "x", "bj", "tk", "compl", "cmp", "addr", "src", "np", "bh", "comm", "hw", "cb", "ext", "eps", "def", "sys", "org", "m", "ht", "xs", "mk", "bo", "att", "nt", "js", "ot", "xy", "ctx", "gc", "object", "cont", "it", "kt", "j", "act", "obo", "fr", "det", "inst", "gt", "try", "t", "typ", "phys", "attr", "opp", "net", "gr", "pt", "resp", "o", "cmd", "ob", "unk", "inv", "stick", "rt", "mg", "obs", "Obj", "co"]}}
{"project": "FFmpeg", "commit_id": "d86d7b2486cd5c31db8e820d8a89554abf19567e", "target": 0, "func": "static int ljpeg_decode_rgb_scan(MJpegDecodeContext *s, int nb_components, int predictor, int point_transform)\n\n{\n\n    int i, mb_x, mb_y;\n\n    uint16_t (*buffer)[4];\n\n    int left[4], top[4], topleft[4];\n\n    const int linesize = s->linesize[0];\n\n    const int mask     = ((1 << s->bits) - 1) << point_transform;\n\n    int resync_mb_y = 0;\n\n    int resync_mb_x = 0;\n\n\n\n    if (s->nb_components != 3 && s->nb_components != 4)\n\n        return AVERROR_INVALIDDATA;\n\n    if (s->v_max != 1 || s->h_max != 1 || !s->lossless)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n\n    s->restart_count = s->restart_interval;\n\n\n\n    av_fast_malloc(&s->ljpeg_buffer, &s->ljpeg_buffer_size,\n\n                   (unsigned)s->mb_width * 4 * sizeof(s->ljpeg_buffer[0][0]));\n\n    buffer = s->ljpeg_buffer;\n\n\n\n    for (i = 0; i < 4; i++)\n\n        buffer[0][i] = 1 << (s->bits - 1);\n\n\n\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n\n        uint8_t *ptr = s->picture_ptr->data[0] + (linesize * mb_y);\n\n\n\n        if (s->interlaced && s->bottom_field)\n\n            ptr += linesize >> 1;\n\n\n\n        for (i = 0; i < 4; i++)\n\n            top[i] = left[i] = topleft[i] = buffer[0][i];\n\n\n\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n            int modified_predictor = predictor;\n\n\n\n            if (s->restart_interval && !s->restart_count){\n\n                s->restart_count = s->restart_interval;\n\n                resync_mb_x = mb_x;\n\n                resync_mb_y = mb_y;\n\n                for(i=0; i<4; i++)\n\n                    top[i] = left[i]= topleft[i]= 1 << (s->bits - 1);\n\n            }\n\n            if (mb_y == resync_mb_y || mb_y == resync_mb_y+1 && mb_x < resync_mb_x || !mb_x)\n\n                modified_predictor = 1;\n\n\n\n            for (i=0;i<nb_components;i++) {\n\n                int pred, dc;\n\n\n\n                topleft[i] = top[i];\n\n                top[i]     = buffer[mb_x][i];\n\n\n\n                PREDICT(pred, topleft[i], top[i], left[i], modified_predictor);\n\n\n\n                dc = mjpeg_decode_dc(s, s->dc_index[i]);\n\n                if(dc == 0xFFFFF)\n\n                    return -1;\n\n\n\n                left[i] = buffer[mb_x][i] =\n\n                    mask & (pred + (dc << point_transform));\n\n            }\n\n\n\n            if (s->restart_interval && !--s->restart_count) {\n\n                align_get_bits(&s->gb);\n\n                skip_bits(&s->gb, 16); /* skip RSTn */\n\n            }\n\n        }\n\n        if (s->rct && s->nb_components == 4) {\n\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[4*mb_x + 2] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2] - 0x200) >> 2);\n\n                ptr[4*mb_x + 1] = buffer[mb_x][1] + ptr[4*mb_x + 2];\n\n                ptr[4*mb_x + 3] = buffer[mb_x][2] + ptr[4*mb_x + 2];\n\n                ptr[4*mb_x + 0] = buffer[mb_x][3];\n\n            }\n\n        } else if (s->nb_components == 4) {\n\n            for(i=0; i<nb_components; i++) {\n\n                int c= s->comp_index[i];\n\n                if (s->bits <= 8) {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ptr[4*mb_x+3-c] = buffer[mb_x][i];\n\n                    }\n\n                } else if(s->bits == 9) {\n\n                    return AVERROR_PATCHWELCOME;\n\n                } else {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ((uint16_t*)ptr)[4*mb_x+c] = buffer[mb_x][i];\n\n                    }\n\n                }\n\n            }\n\n        } else if (s->rct) {\n\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[3*mb_x + 1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2] - 0x200) >> 2);\n\n                ptr[3*mb_x + 0] = buffer[mb_x][1] + ptr[3*mb_x + 1];\n\n                ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1];\n\n            }\n\n        } else if (s->pegasus_rct) {\n\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[3*mb_x + 1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2]) >> 2);\n\n                ptr[3*mb_x + 0] = buffer[mb_x][1] + ptr[3*mb_x + 1];\n\n                ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1];\n\n            }\n\n        } else {\n\n            for(i=0; i<nb_components; i++) {\n\n                int c= s->comp_index[i];\n\n                if (s->bits <= 8) {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ptr[3*mb_x+2-c] = buffer[mb_x][i];\n\n                    }\n\n                } else if(s->bits == 9) {\n\n                    return AVERROR_PATCHWELCOME;\n\n                } else {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ((uint16_t*)ptr)[3*mb_x+2-c] = buffer[mb_x][i];\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 13442, "substitutes": {"s": ["bs", "fs", "ears", "ps", "args", "ms", "ports", "js", "g", "services", "sw", "ex", "se", "sc", "tests", "y", "ins", "details", "h", "d", "changes", "sb", "series", "ops", "results", "os", "als", "sv", "has", "set", "m", "sports", "events", "as", "w", "j", "t", "states", "is", "parts", "ns", "l", "rs", "S", "c", "comm", "eps", "sys", "ls", "vs", "hs", "ats", "its", "ims", "sq", "sets", "ts", "ows", "a", "bits", "qs", "ss", "sts", "aunts", "n", "ants", "settings", "ses", "bes", "ar", "conf", "p", "es", "aws", "rates", "gs", "b", "e", "spec", "bis", "less", "ds", "cs", "comments", "v", "stats", "obj", "scl"], "nb_components": ["nb_comands", "nb_compances", "nb_colients", "nb_compodes", "nb_Compands", "nb_compands", "nb_commances", "nb_comients", "nb_compients", "nb_Components", "nb_exponents", "nb_commands", "nb_Compensions", "nb_expands", "nb_distensions", "nb_commensions", "nb_Compients", "nb_comodes", "nb_colodes", "nb_Compances", "nb_expodes", "nb_distonents", "nb_colands", "nb_distances", "nb_comonents", "nb_Compodes", "nb_colonents", "nb_expensions", "nb_commodes", "nb_commonents", "nb_compensions", "nb_distodes"], "predictor": ["predictive", "predictutor", "pictive", "predictcor", "predictcer", "fredictator", "friptoration", "priptcor", "fredictoration", "pictutor", "pcorrectcer", "priptcer", "friptcer", "priptator", "pictcer", "pveyoration", "predictoration", "pictor", "priptor", "pveyor", "pcorrector", "friptutor", "fredictutor", "predictator", "friptive", "pveyator", "fredictcer", "pcorrectutor", "friptcor", "pcorrectcor", "pictoration", "fredictive", "priptive", "pictator", "friptator", "pveyive", "priptutor", "priptoration", "pictcor", "fredictor", "fredictcor", "friptor"], "point_transform": ["point_draw", "point2mask", "mask_draw", "point_sign", "pointer_sign", "point_scale", "point2draw", "point2scale", "pointer_scale", "point2transform", "pointer_transform", "pointer_mask", "mask_scale", "mask_transform", "point_mask", "mask_mask"], "i": ["status", "cli", "oi", "mac", " ii", "it", "g", "ci", "ie", "ki", "zi", "mi", "y", "uri", "info", "ii", "ji", "ij", "init", "hi", "m", "ri", "name", "ia", "multi", "ni", "j", "iii", "xi", "try", "ik", "t", "ix", "is", "ui", "ini", "qi", "ind", "ai", "di", "x", "c", "q", "ti", "li", "\u0438", "I", "si", "batch", "im", "in", "II", "ims", "fi", "index", "ity", "ico", "phi", "pi", "bi", "io", "iq", "gi", "sim", "ip", "ei", "p", "us", "b", "e", "chain", "ami", "remote", "iu", "id", "me", "ic", "MI", "v", "PI"], "mb_x": ["mbjxi", "mb_l", "kbJy", "lb_ix", "kbJix", "mm_y", "kb_x", "mbJy", "mm_xy", "mb__y", "mbJix", "mbjx", "lb_xml", "kbJl", "mb_ux", "mb_xml", "mbjux", "sb_x", "mbaxyxi", "lb_xs", "kb_y", "mb_inx", "mbJl", "mbJx", "mbaxyinx", "sb_inx", "mb_xs", "mb__ix", "sb_xi", "lb_x", "mb__wx", "mbjinx", "mbaxyx", "kb_ix", "mb__xy", "kb_w", "mb_xi", "kbJx", "mb_w", "mbaxyux", "mb__l", "mb_xy", "mb_wx", "mm_wx", "kb_l", "mb__w", "sb_ux", "mb_ix", "mm_x", "mb__x"], "mb_y": ["mb_i", "mbYi", "mb_hot", "mb_ya", "mb_my", "bb_y", "mbaxyy", "mb_ey", "bound_w", "MB_my", "mbaxymy", "brain_ya", "mbaxyye", "mb_gy", "mb_yo", "bound_ey", "brain_y", "cb_yl", "mb_yl", "mb_yer", "bound_y", "cb_x", "mbYey", "bb_ey", "cb_yo", "brain_gy", "bb_hot", "mbaxyx", "MB_ye", "MB_y", "brain_yer", "MB_x", "mb_w", "bound_i", "mbYy", "mbYw", "mb_ye", "mb_ies", "bb_ies", "cb_y"], "buffer": ["shape", "device", "queue", "view", "cache", "flash", "map", "image", "page", "stack", "memory", "header", "sequence", "byte", "buf", "frame", "result", "screen", "document", "bridge", "message", "filter", "position", "batch", "database", "cell", "buff", "port", "mem", "window", "array", "count", "iter", "block", "size", "Buffer", "line", "data", "row", "stream", "scroll", "binary", "pixel", "library", "v", "table", "base", "command", "length", "output", "texture", "button"], "top": ["lower", "l", "parent", "level", "stack", "lat", "above", "below", "hop", "hot", "center", "root", "st", "tips", "list", "tools", "upper", "cover", "min", "trace", "TOP", "Top", "pointer", "there", "path", "to", "at", "limit", "offset", "scroll", "bottom", "control", "bot", "front", "master", "tops", "table", "first", "up", "tail"], "topleft": ["totheft", "tolect", "Topleft", "tothelf", "Tplevel", "popleaft", "tolex", "popleft", "Tplex", "tochect", "todoreaft", "tolevel", "takenlf", "topleaft", "toplelf", "poplelf", "tocheft", "podoreft", "toleft", "podoreaft", "tplect", "todorefts", "Tpleft", "Toplex", "todorelf", "toplevel", "Tplect", "takenft", "tochevel", "tochex", "toplex", "takenaft", "podorelf", "tpleft", "toplefts", "tothefts", "totheaft", "tplex", "podorefts", "todoreft", "tplevel", "takenfts", "Toplect", "toplect", "Toplevel", "poplefts"], "ptr": ["ind", "ref", "rep", "req", "address", "map", "tmp", "alloc", "br", "temp", "buf", "inters", "depth", "addr", "dest", "prime", "loc", "arr", "zero", "err", "tr", "dr", "push", "pos", "mem", "pointer", "index", "sp", "each", "pointers", "dep", "offset", "grow", "coord", "ctr", "pad", "head", "Ptr", "pend", "obj"], "restart_count": ["restart_max", "restart_last", "restard_max", "restarttenancecode", "restart_set", "restART_cond", "restart__count", "restART_set", "restart_cond", "restarttenancecond", "restartlyCount", "restart_table", "restart__list", "restART__set", "restART_list", "restART__list", "restarttenanceCount", "restartlycount", "restartcountset", "restard_Count", "restart__last", "restartcountlist", "restART__last", "restart__set", "restART_count", "restART_code", "restartlytable", "restard_table", "restART_last", "restarttenancecount", "restart_list", "restart_code", "restART__count", "restartcountcount", "restart_Count", "restard_count", "restartlymax", "restartcountlast", "restART_Count"]}}
{"project": "qemu", "commit_id": "b5e751b51f14cffada6be647aa576b79f1755d7e", "target": 1, "func": "static void qemu_spice_display_init_one(QemuConsole *con)\n\n{\n\n    SimpleSpiceDisplay *ssd = g_new0(SimpleSpiceDisplay, 1);\n\n\n\n    qemu_spice_display_init_common(ssd);\n\n\n\n    ssd->qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_display_interface(&ssd->qxl, con);\n\n    assert(ssd->worker);\n\n\n\n    qemu_spice_create_host_memslot(ssd);\n\n\n\n    ssd->dcl.ops = &display_listener_ops;\n\n    ssd->dcl.con = con;\n\n    register_displaychangelistener(&ssd->dcl);\n\n}\n", "idx": 13448, "substitutes": {"con": ["un", "bind", "cal", "ch", "CON", "pc", "bc", "win", "fac", "conv", "go", "connection", "cur", "c", "cons", "cn", "connect", "pen", "comm", "conf", "an", "ran", "mon", "ln", "in", "ain", "cc", "com", "fn", "dial", "coll", "Con", "conn", "bin", "gate", "en", "enc", "cl", "ex", "ec", "nc", "fc", "ca", "Conn", "ac", "ins", "obj", "can", "co"], "ssd": ["csssd", "rssl", "cssud", "hessdm", "essud", "messd", "cssld", "ssbd", "rssd", "issd", "cssdh", "ssfd", "ssdo", "essd", "SSd", "ssdh", "rssld", "sdd", "esssd", "issdh", "essdd", "ssdm", "hessds", "ssdd", "ssl", "cssdd", "cssmd", "essl", "cssdo", "cssd", " ssdm", "essds", "rssfd", "ysds", "rssmd", " ssmd", "ssld", "mesds", "issfd", " ssbd", "sdsd", "rsssd", "ssmd", "issds", "cssbd", "cssds", "rssbd", "ysdm", "rssdh", "sdds", " ssfd", "ssds", "essdo", "cssl", "sddo", "SSds", "essbd", "ysd", " ssds", "sssd", " sssd", "ysbd", "issld", "ssud", "SSud", "SSsd", "mesdd", "isssd", "hessbd", "hessd", "mesd", "rssds"]}}
{"project": "FFmpeg", "commit_id": "fe7547d69e6721d064c8604d0a6375a2d24b35ca", "target": 0, "func": "int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,\n\n                              int64_t wanted_timestamp, int flags)\n\n{\n\n    int a, b, m;\n\n    int64_t timestamp;\n\n\n\n    a = -1;\n\n    b = nb_entries;\n\n\n\n    // Optimize appending index entries at the end.\n\n    if (b && entries[b - 1].timestamp < wanted_timestamp)\n\n        a = b - 1;\n\n\n\n    while (b - a > 1) {\n\n        m         = (a + b) >> 1;\n\n\n\n        // Search for the next non-discarded packet.\n\n        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {\n\n            m++;\n\n            if (m == b && entries[m].timestamp >= wanted_timestamp) {\n\n                m = b - 1;\n\n                break;\n\n            }\n\n        }\n\n\n\n        timestamp = entries[m].timestamp;\n\n        if (timestamp >= wanted_timestamp)\n\n            b = m;\n\n        if (timestamp <= wanted_timestamp)\n\n            a = m;\n\n    }\n\n    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;\n\n\n\n    if (!(flags & AVSEEK_FLAG_ANY))\n\n        while (m >= 0 && m < nb_entries &&\n\n               !(entries[m].flags & AVINDEX_KEYFRAME))\n\n            m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;\n\n\n\n    if (m == nb_entries)\n\n        return -1;\n\n    return m;\n\n}\n", "idx": 13462, "substitutes": {"entries": ["entsues", "entensions", "Enties", "entities", "ENTires", "Entrs", "ENTensions", "identries", "pentires", "Entries", "entsials", "entityials", "ntries", "ntities", "entityries", "Entents", "identities", "entrys", "ENTies", "entlements", "Entlements", "entsried", "entsries", "entsities", "ENTities", "entityrys", "istlements", "ntrys", "entsrys", "entials", "entried", "Entities", "pentries", "entires", "pentensions", "enties", "Entords", "entrs", "Entensions", "entsires", "istities", "ENTries", "pentues", "istents", "ENTords", "istries", "ENTues", "entslements", "Entrys", "entsies", "entsensions", "ENTrys", "Entials", "entityensions", "entents", "entords", "identrs", "entsrs", "entues", "entsents", "identried", "ntords", "Entried"], "nb_entries": ["nb_contries", "nb_entsits", "nb_ntrows", "nb_ENTlements", "nb_Entrys", "nb_entits", "nb_countresses", "nb_entrows", "nb_pentities", "nb_entsies", "nb_Entresses", "nb_entsities", "nb_entues", "nb_entrys", "nb_ENTits", "nb_ntities", "nb_sequresses", "nb_ntlements", "nb_ntries", "nb_entlements", "nb_entsrows", "nb2enties", "nb_pentries", "nb_entslements", "nb_countries", "nb2ntits", "nb_penties", "nb_countrys", "nb_entities", "nb2ntries", "nb2entities", "nb_contues", "nb_pentits", "nb2ntities", "nb_ntits", "nb_sequrys", "nb_contities", "nb_ENTrows", "nb_ntues", "nb_entresses", "nb_enties", "nb_entsries", "nb_nties", "nb2entits", "nb2nties", "nb_conties", "nb2entries", "nb_sequries", "nb_ENTries", "nb_Entries"], "wanted_timestamp": ["wanted_Timstone", "wanted_tmest", "wanted_timeence", "wanted_timeest", "wanted_tmestamp", "wanted_mintestamp", "wanted_mintstone", "wanted_temestamp", "wanted_waitence", "wanted_Timence", "wanted_timstone", "wanted_timeetime", "wanted_timeestamp", "wanted_mintetime", "wanted_tmence", "wanted_Timtime", "wanted_mintest", "wanted_temence", "wanted_Timetime", "wanted_timtime", "wanted_Timest", "wanted_Timeline", "wanted_timest", "wanted_Timestamp", "wanted_temeline", "wanted_waitestamp", "wanted_waitest", "wanted_timetime", "wanted_tmetime", "wanted_temetime", "wanted_timestone", "wanted_timence", "wanted_temest", "wanted_timeline", "wanted_tmtime", "wanted_timeeline"], "flags": ["fps", "details", "lines", "fs", "doms", "limits", "ants", "fts", "settings", "status", "ments", "terms", "reports", "levels", "FLAG", "planes", "heads", " Flags", "words", "fields", "rights", "weights", "atts", "args", "bugs", "options", "ums", "rates", "flag", "features", "faces", "Flags", "ports", "locks", "ags", "tags", "fd", "missions", "finals", "pins", "frames", "marks", "magic", "properties", "states", "acts", "ts", "comments", "cond", "bits", "wcs", "types", "products", "stats", "lag", "parts", "mask", "packages", "posts"], "a": ["i", "o", "h", "d", " A", "l", "area", "ai", "n", "am", "aj", "app", "A", "la", "x", "pa", "ga", "ar", "c", "aa", "ap", "p", "s", "an", "r", " sa", "ma", "ach", "bo", "oa", "ia", "e", "as", "sa", "al", "na", "w", "aaa", "to", "g", "va", "at", "j", "access", " at", "t", "apa", "ca", "ea", "au", "ba", "ace", "ae", "ac", "be", " i", " ca", "ab", "eas", "f", "da", "alpha", "ta"], "b": ["bs", "i", "o", "blue", "d", "l", "bar", "sb", "n", "bl", "bt", "bc", "z", "bm", "bf", "BA", "rb", "br", "c", "u", "cb", "aa", "f", "p", "s", "ib", "r", "batch", "bound", "pb", "mb", "bo", "fb", "e", "eb", "db", "bb", "w", "bis", "bas", "g", "it", "j", "back", "B", "nb", "t", "bp", "beta", "body", "ba", "ob", "be", "base", "bi", "ab", "wb", "by", "y", "bg", "length", "v", "gb"], "m": ["dn", "esm", "managed", "cm", "u", "r", "ym", "arm", "mo", "ms", "dim", "mem", "mac", "g", "mm", "mi", "sm", "y", "vm", "mu", "rem", "h", "mun", "d", "am", "mc", "mb", "multi", "j", "msg", "mod", "t", "em", "tm", "perm", "f", "mat", "bm", "l", "om", "fm", "asm", "gm", "value", "c", "mut", "ma", "wm", "im", "mp", "month", "mx", "rm", "mt", "mr", "km", "mail", "o", "mean", "mis", "i", "dm", "n", "met", "M", "p", "s", "nm", "md", "id", "um", "module", "me", "lem", "span", "hm", "v", "pm"], "timestamp": ["capemark", "timpoint", "portesta", "portporal", "latistic", "capage", "latatile", "stimporal", "timest", "timension", "Timeness", "estampestamp", "theeline", "timeeness", "timage", "latporal", "laturation", "theporal", "suspetime", "estampage", "timerence", "timeestamp", "stimestamp", "streamest", "streamestamp", "Timestamp", "timemark", "laterence", "streamporal", "temestamp", "matchestamp", "timeporal", "temerence", "matchemark", "timeetime", "tempoint", "payeness", "Timetime", "portestamp", "temesta", "tempestamp", "timistic", "thepoint", "latestamp", "capestamp", "porterence", "timeension", "stimesta", "payetime", "timetime", "stimemark", "temporal", "timporal", "latesta", "timepoint", "estampemark", "latemark", "suspestamp", "tempemark", "suspatile", "timeatile", "temeline", "theestamp", "timeness", "timeeline", "matchage", "stimest", "timeline", "stimuration", "latetime", "stimension", "timeest", "tempuration", "streamension", "tempesta", "suspistic", "timeistic", "timatile", "timuration", "timesta", "payestamp"]}}
{"project": "FFmpeg", "commit_id": "668494acd8b20f974c7722895d4a6a14c1005f1e", "target": 1, "func": "static int codec_get_buffer(AVCodecContext *s, AVFrame *frame)\n{\n    InputStream *ist = s->opaque;\n    FrameBuffer *buf;\n    int ret, i;\n    if (!ist->buffer_pool && (ret = alloc_buffer(s, ist, &ist->buffer_pool)) < 0)\n        return ret;\n    buf              = ist->buffer_pool;\n    ist->buffer_pool = buf->next;\n    buf->next        = NULL;\n    if (buf->w != s->width || buf->h != s->height || buf->pix_fmt != s->pix_fmt) {\n        av_freep(&buf->base[0]);\n        av_free(buf);\n        ist->dr1 = 0;\n        if ((ret = alloc_buffer(s, ist, &buf)) < 0)\n            return ret;\n    }\n    buf->refcount++;\n    frame->opaque        = buf;\n    frame->type          = FF_BUFFER_TYPE_USER;\n    frame->extended_data = frame->data;\n    frame->pkt_pts       = s->pkt ? s->pkt->pts : AV_NOPTS_VALUE;\n    for (i = 0; i < FF_ARRAY_ELEMS(buf->data); i++) {\n        frame->base[i]     = buf->base[i];  // XXX h264.c uses base though it shouldn't\n        frame->data[i]     = buf->data[i];\n        frame->linesize[i] = buf->linesize[i];\n    }\n    return 0;\n}", "idx": 13468, "substitutes": {"s": ["bs", "h", "fs", "rs", "n", "sb", "serv", "app", "z", "ses", "conv", "os", "S", "space", "session", "ast", "http", "c", "sv", "ps", "comm", "er", "st", "p", "sys", "es", "set", "m", "sam", "ls", "same", "hs", "ms", "gs", "ats", "its", "js", "as", "ctx", "sts", "w", "spec", "ims", "g", "sq", "sw", "less", "sf", "cl", "t", "ares", "ds", "self", "cs", "ts", "sc", "is", "a", "source", "stat", "v", "f", "ins", "qs", "ns", "ss"], "frame": ["event", "framework", "context", "queue", "render", "version", "req", "comp", "send", "package", "image", "component", "page", "term", "point", "header", "Frame", "x", "sequence", "next", "draw", "face", "state", "error", "video", "c", "force", "picture", "message", "cast", "update", "dr", "rame", "close", "flag", "scene", "fb", "trace", "window", "profile", "response", "reason", "buffer", "remote", "e", "request", "object", "fe", "der", "ce", "cf", "feat", "line", "fr", "frames", "data", "fram", "iframe", "zone", "we", "fw", "feature", "part", "cmd", "plot", "base", "f", "command", "process", "w", "call", "one"], "ist": ["pect", "art", "wp", "et", "nil", "tip", "elist", "iss", "exist", "it", "IST", "expr", "pt", "ins", "ht", "dit", "osi", "ij", "ast", "pas", "xt", "artist", "istant", "ia", "erd", "eh", "imm", "ict", "ik", "ix", "is", "stat", "ui", "irst", "ind", "rs", "wi", "st", "isting", "loc", "ust", "ess", "ois", "ilst", "ir", "ive", "ims", "isd", "iste", "alist", "il", "est", "dist", "iq", "xp", "fp", "ip", "ost", "p", "list", "dr", "ism", "port", "ert", "iter", "ctx", "iz", "act", "ic", "inst", "assert", "ac", "ista", "ists", "hist", "obj", "iat"], "buf": ["bs", "pkg", "norm", "xff", "bl", "bc", "conv", "cp", "cb", "bh", "bd", "ptr", "pb", "mem", "fb", "pg", "cv", "Buffer", "pt", "ob", "que", "uf", "cache", "prop", "bar", "keep", "tmp", "alloc", "br", "txt", "next", "Buff", "def", "vec", "img", "vp", "good", "buffer", "env", "bb", "cap", "msg", "fr", "nb", "bp", "phy", "cmd", "burst", "ab", "doc", "bu", "req", "bytes", "bt", "fg", "fac", "bf", "rb", "rib", "tab", "foo", "arr", "err", "uv", "batch", "cam", "cast", "block", "fi", "data", "seq", "BU", "proc", "bed", "fw", "var", "queue", "ff", "ref", "fp", "new", "nm", "desc", "bo", "buff", "b", "window", "box", "db", "font", "ctx", "fun", "feat", "og", "lim", "grab", "bin", "func", "kat", "wb", "obj"], "ret": ["rel", "ref", "RET", "elt", "pret", "success", "status", "txt", "ber", "out", "re", "reg", "cat", "Ret", "result", "pas", "ext", "def", "not", "r", "err", "tr", "desc", "valid", "ry", "Return", "alt", "repl", "att", "nt", "rev", "len", "cont", "it", "res", "rm", "mt", "det", "gt", "try", "fail", "t", "ll", "ter", "net", "rets", "nat", " Ret", "resp", "rt", "deg", "val", "print", "v", "virtual", "reset", "rem"], "i": ["qi", "ind", "ai", "ii", "ji", "gi", "k", "status", "di", "x", "sim", "cli", "ij", "ip", "init", "u", "ti", "li", "hi", "\u0438", "I", "p", "ei", "si", "m", "ri", "ir", "b", "im", "multi", "chain", "ami", "remote", "ims", "index", "iu", "id", "g", "it", "j", "me", "ci", "xi", "ic", "ki", "phi", "em", "zi", "span", "ix", "mi", "is", "pi", "v", "y", "f", "ini", "bi", "ui", "uri", "io", "mu"], "refcount": ["RefCount", "refcycle", "Refcounter", "refCount", "referenceCount", "reqcounter", "reqcycle", "reqcount", "reqCount", "referencecounter", "referencecount", "refcounter", "Refcount", "referencecycle", "Refcycle"]}}
{"project": "FFmpeg", "commit_id": "b8edf91657ad9fa2f0c5175c9ca8fbe3c8b0c624", "target": 0, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *inpic)\n\n{\n\n    AVFilterContext   *ctx     = inlink->dst;\n\n    HisteqContext     *histeq  = ctx->priv;\n\n    AVFilterLink      *outlink = ctx->outputs[0];\n\n    int strength  = histeq->strength  * 1000;\n\n    int intensity = histeq->intensity * 1000;\n\n    int x, y, i, luthi, lutlo, lut, luma, oluma, m;\n\n    AVFrame *outpic;\n\n    unsigned int r, g, b, jran;\n\n    uint8_t *src, *dst;\n\n\n\n    outpic = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n\n    if (!outpic) {\n\n        av_frame_free(&inpic);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    av_frame_copy_props(outpic, inpic);\n\n\n\n    /* Seed random generator for antibanding. */\n\n    jran = LCG_SEED;\n\n\n\n    /* Calculate and store the luminance and calculate the global histogram\n\n       based on the luminance. */\n\n    memset(histeq->in_histogram, 0, sizeof(histeq->in_histogram));\n\n    src = inpic->data[0];\n\n    dst = outpic->data[0];\n\n    for (y = 0; y < inlink->h; y++) {\n\n        for (x = 0; x < inlink->w * histeq->bpp; x += histeq->bpp) {\n\n            GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);\n\n            luma = (55 * r + 182 * g + 19 * b) >> 8;\n\n            dst[x + histeq->rgba_map[A]] = luma;\n\n            histeq->in_histogram[luma]++;\n\n        }\n\n        src += inpic->linesize[0];\n\n        dst += outpic->linesize[0];\n\n    }\n\n\n\n#ifdef DEBUG\n\n    for (x = 0; x < 256; x++)\n\n        av_dlog(ctx, \"in[%d]: %u\\n\", x, histeq->in_histogram[x]);\n\n#endif\n\n\n\n    /* Calculate the lookup table. */\n\n    histeq->LUT[0] = histeq->in_histogram[0];\n\n    /* Accumulate */\n\n    for (x = 1; x < 256; x++)\n\n        histeq->LUT[x] = histeq->LUT[x-1] + histeq->in_histogram[x];\n\n\n\n    /* Normalize */\n\n    for (x = 0; x < 256; x++)\n\n        histeq->LUT[x] = (histeq->LUT[x] * intensity) / (inlink->h * inlink->w);\n\n\n\n    /* Adjust the LUT based on the selected strength. This is an alpha\n\n       mix of the calculated LUT and a linear LUT with gain 1. */\n\n    for (x = 0; x < 256; x++)\n\n        histeq->LUT[x] = (strength * histeq->LUT[x]) / 255 +\n\n                         ((255 - strength) * x)      / 255;\n\n\n\n    /* Output the equalized frame. */\n\n    memset(histeq->out_histogram, 0, sizeof(histeq->out_histogram));\n\n\n\n    src = inpic->data[0];\n\n    dst = outpic->data[0];\n\n    for (y = 0; y < inlink->h; y++) {\n\n        for (x = 0; x < inlink->w * histeq->bpp; x += histeq->bpp) {\n\n            luma = dst[x + histeq->rgba_map[A]];\n\n            if (luma == 0) {\n\n                for (i = 0; i < histeq->bpp; ++i)\n\n                    dst[x + i] = 0;\n\n                histeq->out_histogram[0]++;\n\n            } else {\n\n                lut = histeq->LUT[luma];\n\n                if (histeq->antibanding != HISTEQ_ANTIBANDING_NONE) {\n\n                    if (luma > 0) {\n\n                        lutlo = histeq->antibanding == HISTEQ_ANTIBANDING_WEAK ?\n\n                                (histeq->LUT[luma] + histeq->LUT[luma - 1]) / 2 :\n\n                                 histeq->LUT[luma - 1];\n\n                    } else\n\n                        lutlo = lut;\n\n\n\n                    if (luma < 255) {\n\n                        luthi = (histeq->antibanding == HISTEQ_ANTIBANDING_WEAK) ?\n\n                            (histeq->LUT[luma] + histeq->LUT[luma + 1]) / 2 :\n\n                             histeq->LUT[luma + 1];\n\n                    } else\n\n                        luthi = lut;\n\n\n\n                    if (lutlo != luthi) {\n\n                        jran = LCG(jran);\n\n                        lut = lutlo + ((luthi - lutlo + 1) * jran) / LCG_M;\n\n                    }\n\n                }\n\n\n\n                GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);\n\n                if (((m = FFMAX3(r, g, b)) * lut) / luma > 255) {\n\n                    r = (r * 255) / m;\n\n                    g = (g * 255) / m;\n\n                    b = (b * 255) / m;\n\n                } else {\n\n                    r = (r * lut) / luma;\n\n                    g = (g * lut) / luma;\n\n                    b = (b * lut) / luma;\n\n                }\n\n                dst[x + histeq->rgba_map[R]] = r;\n\n                dst[x + histeq->rgba_map[G]] = g;\n\n                dst[x + histeq->rgba_map[B]] = b;\n\n                oluma = (55 * r + 182 * g + 19 * b) >> 8;\n\n                histeq->out_histogram[oluma]++;\n\n            }\n\n        }\n\n        src += inpic->linesize[0];\n\n        dst += outpic->linesize[0];\n\n    }\n\n#ifdef DEBUG\n\n    for (x = 0; x < 256; x++)\n\n        av_dlog(ctx, \"out[%d]: %u\\n\", x, histeq->out_histogram[x]);\n\n#endif\n\n\n\n    av_frame_free(&inpic);\n\n    return ff_filter_frame(outlink, outpic);\n\n}\n", "idx": 13488, "substitutes": {"inlink": ["cinLink", "inconnection", " outstream", "INlinked", "airLink", "outLink", "cinlinked", "cinblock", " inLink", "cinloop", "inconn", "InLink", "airlink", "innthread", "inloop", "instream", "Inlink", "inthread", "INlink", "INblock", " inconn", " outconnection", "inblock", "onconnection", "onlock", " inconnection", " outlock", "innlink", "inLink", "Inthread", " instream", " inlock", "onstream", "airlinked", "cinlink", "INLink", "onlink", "innloop", "inlock", "cinconn", "innconn", "airblock", " inloop", "inlinked", "outthread", "innLink"], "inpic": ["ainnic", " insp", "inpicture", "Inpicture", "Injp", "outscript", " innic", " inpc", "dinpicture", " inpy", "innpic", "inpin", "Inpin", " inpicture", "cinpic", " inpipe", "oldpicture", "oldpic", "dinpict", "dinpic", "isinpict", "innpipe", "Inpic", "insp", " injp", "injp", " inscript", "isinpic", "inpy", "oldsp", "cinpc", "Insp", "inpipe", "isinpicture", "isinpy", "cinnic", "interpicture", " inpict", "ainpic", "oldpin", " inpin", "outpipe", "innscript", "ainpc", "inpict", "inscript", "interjp", "interpic", "inpc", "dinpy", "interpin", "innic"], "ctx": ["pkg", "context", "jp", "kw", "fp", "tmp", "ck", "txt", "tx", "conv", "lc", "ctl", "ctrl", "history", "setup", "cmp", "cm", "np", "xc", "cp", "cb", "conf", "hw", "cu", "loc", "mc", "sys", "jac", "cfg", "timeout", "tz", "tc", "cc", "gc", "cv", "cf", "act", "kt", "mom", "conn", "ct", "ic", "fw", "ca", "nc", "sc", "config", "cmd", "kb", "obj", "iat", "co"], "histeq": [" historyfy", "distq", "historyeer", "highe", "historyec", "plotequ", " histeps", "recentrt", "historyq", "phyreq", "histrox", "hashqt", " histime", "hashequality", "historyequality", "humeq", "statearch", "restreq", "higheer", " histqt", "humqt", "alertq", "phyeer", "histqq", " histequ", "hasheq", " histe", "restq", "restequ", "recenteq", "alertearch", "plotqt", " historyeq", "histreq", "highequ", "historyeq", "humeer", "hashqq", "histequality", "Histue", "recentequ", "hessequality", " histreq", "Histeq", "Histq", "hashq", "humreq", "histe", " historyec", "historyreq", "alerteq", "Histequ", "plotqq", "hessq", "distreq", " histearch", "highreq", "disteq", "alertreq", "histq", "histue", "statequ", " histue", "histearch", " histqq", "histime", "hashequ", "Histequal", "historyequal", "statime", "althec", "monitoreq", "hesseq", "monitorequal", "histequal", "histqt", " historyeps", "Histe", "histrt", "stateps", "horox", "historyearch", "phyrox", "statreq", "hoeer", "statqq", "resteq", "phyequ", "monitorrox", "ploteq", " histq", "distequ", "historyfy", "phyequal", "historyrt", "hoeq", "histec", "historye", "Histreq", "althfy", "hashreq", "hume", "humearch", "historyequ", "histeer", "stateq", "highequal", "altheps", "monitoreer", "higheq", "phyeq", "state", "hessreq", "statqt", "hoequal", "altheq", "recenteps", "statrt", "distearch", "histfy", "historyeps", "historyue", "historyqq", "histequ", "statq", "humequ", "historyime", "histeps", " histrt", "phyq"], "outlink": [" outink", "odisk", "itlink", "itdisk", "onink", "olock", "outlock", "itlock", "atlock", "atparent", "outputLink", "Outport", "outnode", "outink", "itparent", "connode", "outport", "Outink", "oLink", "outparent", " outLink", " outport", "connlink", "conink", "outputlink", "atlink", " outnode", "oli", "outputdisk", "OutLink", "Outlink", "atdisk", "connnode", "outdisk", " outdisk", "onLink", "olink", "outputli", "conLink", "outli", "onport", "connLink", "conlink", "oparent", "onlink", "connink", " outli", "outLink"], "x": ["ey", "k", "xe", "px", "check", "add", "xd", "ex", "X", "xx", "h", "ax", "full", "xt", "any", "upload", "at", "j", "xi", "t", "ix", " xx", "f", "yx", "wy", "fx", "l", "xxxx", "c", "ext", "xf", "batch", "key", "xes", "index", "inx", "xxx", "mx", "max", "step", "ct", "lex", "axis", "o", "a", "xp", "n", "dx", "time", "z", "tx", "xc", "p", "ux", "xa", "rx", "xs", "dr", "e", "xy", "act", "el", "ox", "wx", "v", "w", "on"], "y": ["wy", "h", "ey", "ch", "py", "l", "n", "ady", "vy", "ty", "z", "kit", "ies", "iy", "cy", "dy", "c", "p", "sy", "ry", "e", "xy", "my", "ay", "j", "at", "yt", "ya", "gy", "axy", "t", "yy", "yr", "o", "Y", "sky", "v", "by", "w", "ny"], "i": ["l", "ai", "ii", "ij", "iy", "c", "u", "li", "I", "p", "si", "in", "iu", "it", "j", "ci", "xi", "ic", "phi", "ix", "mi", "pi", "v", "f"], "luthi": ["lushia", "lutia", "lutl", "luthia", "lohy", " lushy", " luti", "lushl", " lushi", " lutl", "luty", "luthl", "lushy", "lohia", "luthy", " luty", "lohi", "luti", "lohl", "lushi", " lutia", " lushia", " lushl"], "lutlo": ["lustla", "lustlo", "Lutla", "Lutli", "lUThi", "lUTli", "LUTlo", "LUThi", "lUTla", "ludhi", "Lutlo", "lutli", "ludlo", "Luthi", "LUTla", "LUTli", "lutla", "lusthi", "ludla", "lustli", "lUTlo", "ludli"], "lut": [" luta", "flut", "sluta", "lUT", "sluti", "luti", " luti", "fluta", "slUT", "luta", "flUT", "slut", "fluti", " lUT"], "luma": ["Luna", "olpha", "ylama", "Lama", "eluna", "slama", " lum", "tluna", "Lamia", "eluma", "lora", "llpha", "yluma", "luna", "eluda", "lama", "liuna", "yluna", " lama", "lamia", " luna", "lpha", "Lua", "oluna", "sluna", "sluma", " lpha", "lluma", "liuma", "lluna", "tlua", "ylua", " luda", "tlama", "elama", "Luma", "tluma", "llora", "lium", "luda", "lua", "sluda", "olora", "lum", " lora", " lamia", "Lum", "liamia"], "oluma": ["lumin", "llumin", "lluna", "flumin", "lum", "olumin", "oluna", "fluma", "fluna", "flum", "llum", "olum", "lluma", "luna"], "m": ["mean", "h", "d", "l", "dm", "n", "gm", "cm", "M", "c", "p", "wm", "dim", "mem", "mx", "rm", "mm", "t", "tm", "mi", "o", "sm", "v", "f", "perm", "w", "bm", "mu"], "outpic": ["devpic", "inpicture", "outscript", " outjp", "outpin", "OUTlink", "outpicture", "outerpict", "inp", " outPic", "outsp", "OUTnic", "Outsp", "outerpic", "outp", " outsp", "otsp", "rawnic", "devpc", "devscript", "outerscript", "outjp", "rawsp", "orpic", "OUTpic", "OUTpin", "orlink", "ornic", "ojp", "outnic", " outpc", "insp", "injp", "inPic", "OutPic", "OUTscript", "syspin", " outpict", "op", "itpic", " outpicture", "otpic", "Outnic", "rawPic", "Outpic", "outerpc", "orscript", "otnic", "devpict", "opicture", "opic", "itpin", " outp", " outnic", "rawpic", "otPic", "sysnic", "itnic", "itscript", "syspic", "outpc", "outpict", "innic", "outPic", "sysscript", " outscript"], "r": ["h", "usr", "d", "l", "rin", "k", "rb", "re", "ar", "c", "u", "q", "er", "p", "ri", "rx", "dr", "R", "rd", "e", "rc", "rr", "rh", "ro", "rg", "red", "j", "sr", "mr", "t", "vr", "rt", "a", "cr", "v", "f", "lr", "w"], "g": ["gd", "h", "l", "n", "gi", "k", "fg", "gm", "gn", "gg", "gu", "c", "q", "u", "p", "gp", "gam", "e", "G", "gc", "w", "rg", "j", "gy", " G", "ig", "gr", "f", "v", "bg", "mg", "gb", "ga"], "b": ["bs", "h", "d", "ch", "l", "n", "sb", "bc", "z", "bf", "rb", "c", "u", "p", "ib", "fb", "e", "db", "eb", "bb", "bis", "B", "t", "beta", "o", "a", "v", "bi", "f", "bg", "be", "w", "ba"], "jran": [" jroman", "ngran", "jsan", "vran", "jgran", "Jran", "djsan", "djroman", "Jbin", " jbin", "Jgran", "djgran", " jlan", "Jlan", "djran", "jbin", "nsan", "nroman", " jsan", "vgran", "vbin", " jgran", "jroman", "jlan", "vlan", "nran"], "src": ["bs", "rel", "usr", "fp", "sn", "rs", "sb", "tmp", "sl", "ur", "txt", "rb", "addr", "np", "dest", "cb", "st", "ss", "scale", "sub", "loc", "s", "sys", "img", "ptr", "ug", "origin", "ser", "syn", "rx", "rc", "hl", "fn", "gin", "url", "str", "rl", "sq", "load", "iv", "bin", "sr", "inst", "copy", "sc", "source", "rt", "lit", "ins", "lr", "rob"], "dst": ["ncr", "nbr", " dST", "mdst", "dsts", "dnt", "adst", "lest", "sdest", "lst", "ldest", "jst", "mddest", "Dest", "dput", "dsbr", "dsp", " dsrc", "dest", "lsts", "Dbr", "Dsp", "dssp", " dest", "mdest", " dput", "Dst", " ddest", "dST", "ddest", "dscr", "Ddest", "mdST", "sddest", "adest", "Dsrc", "dsrc", "sdsts", "Dsts", "adput", "dsst", "Dput", "dbr", "jnt", "Dnt", "DST", "nsp", "dcr", " dnt", "jsrc", "sdst", "jest", "nst", "addest", "Dcr"], "in_histogram": ["in_historyology", "in_topometry", "in_chronory", "in_chronhist", "in_topome", "in_memoryory", "in_chronology", "in_memoryograms", "in_hashob", "in_memometry", "in_memhist", "in_historyicle", "in_topograms", "in_memograms", "in_historyory", "in_histhistory", "in_historyograms", "in_histology", "in_memology", "in_histicle", "in_topory", "in_histob", "in_histhist", "in_historyob", "in_memicle", "in_histograms", "in_hashogram", "in_logograms", "in_History", "in_logory", "in_topogram", "in_Histome", "in_hashum", "in_histomial", "in_history", "in_historyome", "in_chronogram", "in_hashory", "in_memoryogram", "in_topicle", "in_memoryomial", "in_topob", "in_statogram", "in_logogram", "in_memhistory", "in_statory", "in_statum", "in_historyhistory", "in_memory", "in_histum", "in_histome", "in_histometry", "in_Histhistory", "in_historyometry", "in_logomial", "in_historyomial", "in_historyhist", "in_statob", "in_Histogram", "in_memome", "in_historyum", "in_memob", "in_memogram", "in_historyogram"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_int32(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_S32);\n\n}\n", "idx": 13494, "substitutes": {"data": ["context", "device", "d", "reader", "image", "map", "bytes", "Data", "json", "DATA", "error", "next", "session", "state", "input", "ata", "bus", "store", "list", "batch", "da", "valid", "read", "mem", "window", "array", "initial", "buffer", "iter", "done", "size", "ad", "values", "bin", "text", "table", "dat", "mu", "accept"], "unused": ["unuse", "ungused", "ungsupported", "unsupported", "sunusable", "uncuse", "nus", "unus", "unguse", " unuse", "sunuse", "nuse", "sunchecked", " unus", " unsupported", "uncchecked", "ungus", "unchecked", "unusable", "sunused", "nused", " unchecked", "uncused", " unusable", "nsupported", "uncusable"]}}
{"project": "qemu", "commit_id": "353ab969730742b7392414d62f4ba9632e8cf22c", "target": 0, "func": "static void nbd_trip(void *opaque)\n\n{\n\n    NBDClient *client = opaque;\n\n    NBDExport *exp = client->exp;\n\n    NBDRequest *req;\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n    uint32_t command;\n\n\n\n    TRACE(\"Reading request.\");\n\n    if (client->closing) {\n\n        return;\n\n    }\n\n\n\n    req = nbd_request_get(client);\n\n    ret = nbd_co_receive_request(req, &request);\n\n    if (ret == -EAGAIN) {\n\n        goto done;\n\n    }\n\n    if (ret == -EIO) {\n\n        goto out;\n\n    }\n\n\n\n    reply.handle = request.handle;\n\n    reply.error = 0;\n\n\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n        goto error_reply;\n\n    }\n\n    command = request.type & NBD_CMD_MASK_COMMAND;\n\n    if (command != NBD_CMD_DISC && (request.from + request.len) > exp->size) {\n\n            LOG(\"From: %\" PRIu64 \", Len: %u, Size: %\" PRIu64\n\n            \", Offset: %\" PRIu64 \"\\n\",\n\n                    request.from, request.len,\n\n                    (uint64_t)exp->size, (uint64_t)exp->dev_offset);\n\n        LOG(\"requested operation past EOF--bad client?\");\n\n        goto invalid_request;\n\n    }\n\n\n\n    if (client->closing) {\n\n        /*\n\n         * The client may be closed when we are blocked in\n\n         * nbd_co_receive_request()\n\n         */\n\n        goto done;\n\n    }\n\n\n\n    switch (command) {\n\n    case NBD_CMD_READ:\n\n        TRACE(\"Request type is READ\");\n\n\n\n        if (request.type & NBD_CMD_FLAG_FUA) {\n\n            ret = blk_co_flush(exp->blk);\n\n            if (ret < 0) {\n\n                LOG(\"flush failed\");\n\n                reply.error = -ret;\n\n                goto error_reply;\n\n            }\n\n        }\n\n\n\n        ret = blk_pread(exp->blk, request.from + exp->dev_offset,\n\n                        req->data, request.len);\n\n        if (ret < 0) {\n\n            LOG(\"reading from file failed\");\n\n            reply.error = -ret;\n\n            goto error_reply;\n\n        }\n\n\n\n        TRACE(\"Read %u byte(s)\", request.len);\n\n        if (nbd_co_send_reply(req, &reply, request.len) < 0)\n\n            goto out;\n\n        break;\n\n    case NBD_CMD_WRITE:\n\n        TRACE(\"Request type is WRITE\");\n\n\n\n        if (exp->nbdflags & NBD_FLAG_READ_ONLY) {\n\n            TRACE(\"Server is read-only, return error\");\n\n            reply.error = EROFS;\n\n            goto error_reply;\n\n        }\n\n\n\n        TRACE(\"Writing to device\");\n\n\n\n        ret = blk_pwrite(exp->blk, request.from + exp->dev_offset,\n\n                         req->data, request.len, 0);\n\n        if (ret < 0) {\n\n            LOG(\"writing to file failed\");\n\n            reply.error = -ret;\n\n            goto error_reply;\n\n        }\n\n\n\n        if (request.type & NBD_CMD_FLAG_FUA) {\n\n            ret = blk_co_flush(exp->blk);\n\n            if (ret < 0) {\n\n                LOG(\"flush failed\");\n\n                reply.error = -ret;\n\n                goto error_reply;\n\n            }\n\n        }\n\n\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    case NBD_CMD_DISC:\n\n        TRACE(\"Request type is DISCONNECT\");\n\n        errno = 0;\n\n        goto out;\n\n    case NBD_CMD_FLUSH:\n\n        TRACE(\"Request type is FLUSH\");\n\n\n\n        ret = blk_co_flush(exp->blk);\n\n        if (ret < 0) {\n\n            LOG(\"flush failed\");\n\n            reply.error = -ret;\n\n        }\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    case NBD_CMD_TRIM:\n\n        TRACE(\"Request type is TRIM\");\n\n        ret = blk_co_discard(exp->blk, (request.from + exp->dev_offset)\n\n                                       / BDRV_SECTOR_SIZE,\n\n                             request.len / BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            LOG(\"discard failed\");\n\n            reply.error = -ret;\n\n        }\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    default:\n\n        LOG(\"invalid request type (%u) received\", request.type);\n\n    invalid_request:\n\n        reply.error = EINVAL;\n\n    error_reply:\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    }\n\n\n\n    TRACE(\"Request/Reply complete\");\n\n\n\ndone:\n\n    nbd_request_put(req);\n\n    return;\n\n\n\nout:\n\n    nbd_request_put(req);\n\n    client_close(client);\n\n}\n", "idx": 13504, "substitutes": {"opaque": ["boaque", "ipaque", "operaques", "obacity", "opsaque", "obaque", "ipatile", "xener", "opoch", "xaque", "ipener", "oboch", "obque", "operatile", "xaques", "boque", "operaque", "boacity", "opsque", "opsoch", "opque", "opacity", "xatile", "opatile", "opsacity", "opaques", "opener", "booch", "operener", "ipaques"], "client": ["event", "context", "cache", "channel", "con", "prefix", "hunt", "parent", "app", "null", "server", "x", "cli", "connection", "local", "util", "ip", "peer", "cur", "pool", "http", "out", "c", "connect", "this", "p", "store", "cell", "close", "application", "window", "bolt", "buffer", "remote", "ctx", "to", "manager", "google", "contact", "module", "Client", "conn", "cl", "handler", "self", "net", "wrapper", "api", "config", "resp", "cmd", "obj", "query", "current", "owner", "co"], "req": ["pkg", "requ", "ind", "jp", "ck", "txt", "tx", "rb", "need", "cur", "Requ", "q", "comm", " requ", "Request", "def", "err", "r", "ire", "urg", "rx", "desc", "pro", "qq", "mem", "nt", "rr", "ctx", "form", "job", "res", "sq", "require", "fr", "msg", "grab", "dq", "proc", "attr", "quest", "expr", "crit", "resp", "rw", "cmd", "inv", "needed", "rec", "var", "aux", "qt", "query", "reset"], "request": ["requ", "select", "art", "transfer", "error", "frame", "http", "resource", "create", "xml", "message", "push", "initial", "instance", "record", "forward", "param", "report", "quest", "accept", "pair", "event", "worker", "package", "hello", "subject", "complete", "word", "connection", "next", "Request", "position", " event", "upload", "buffer", "each", "vector", "order", "resp", "cmd", " requested", "first", "query", "type", "usage", "claim", "begin", "q", "change", " query", "update", "seek", "response", "reference", "decl", "range", "item", "work", " argument", "process", "call", "est", "phrase", "address", "point", "task", "result", "have", "input", "new", "document", "p", "match", "attribute", "import", "QUEST", "load", "transform", "self", "test", "config", "post", "reset", "shift"], "reply": ["details", "ror", "info", "role", "related", "prefix", " Reply", "route", "replace", "answer", "translation", "transfer", "next", "out", "error", "connection", "sequence", "result", "frame", "force", "respons", "message", "sys", "r", "bill", "repl", "entry", "match", "trace", "response", "rr", "reason", "remote", "shell", "respond", "ply", "output", "sett", "echo", "module", "back", "fr", "Response", "try", "comment", "Reply", "report", "proxy", "write", "resp", "part", "link", "print", "policy", "relation", "fire", "notice", "query", "onse"], "ret": ["status", "success", "re", "prot", "cat", "Ret", "tif", "ptr", "ry", "mem", "att", "vet", "sec", "sat", "done", "inter", "ter", "rets", "pt", "rem", "usr", "dt", "git", " RET", "def", "tr", "eth", "at", "res", "kt", "after", "sr", "try", "pat", "t", "net", "get", "resp", "cmd", "print", "mat", "tail", "jp", "RT", "RET", "pret", "format", "compl", "ext", "sys", "arr", "alt", "nt", "cert", "mt", "det", "gt", "arg", "ts", "rt", "deg", "val", "let", "ft", "ref", "elt", "lt", "progress", "out", "result", "tech", "desc", "dr", "match", "rev", "ert", "len", "iter", "fun", "cont", "rier", "str", "back", "ll", "tt", " Ret", "reset"], "command": ["event", "kind", "rank", "category", "type", "version", "power", "three", "directory", "direction", "dom", "style", "content", "sequence", "error", "connection", "password", "frame", "confirmed", "value", "service", "priority", "document", "argument", "message", "language", "position", "Command", "height", "action", "key", "flag", "md", "code", "mac", "response", "rule", "pattern", "domain", "attribute", "method", "mode", "operation", "module", "description", "communication", "magic", "comment", "class", "handler", "cmd", "function", "policy", "length", "relation", "execute", "button"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_register_reset(QEMUResetHandler *func, void *opaque)\n\n{\n\n    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));\n\n\n\n    re->func = func;\n\n    re->opaque = opaque;\n\n    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);\n\n}\n", "idx": 13513, "substitutes": {"func": ["pkg", "kw", "con", "comp", "package", "fac", "conv", "unc", "go", "alloc", "util", "buf", "closure", "addr", "cb", "sys", "impl", "callback", "lambda", "b", "cc", "apply", "sec", "none", "fn", "ctx", "fun", "cf", "res", "bin", "conn", "proc", "handler", "attr", "PF", "wrapper", "fc", "nc", "ac", "function", "f", "obj", "aux"], "opaque": ["operent", "bitque", "operacity", "ipaque", "obacity", "bitaque", "ipent", "obaque", "ipatile", "pity", "operque", "patile", "pent", "obque", "pacity", "Opatile", "pque", "operaque", "opity", "opent", " opity", "opque", "Opent", "bitacity", "paque", "opacity", "opatile", " opacity", " opque", "bitent", "ipacity", "Opque", "ipque", "obity", "Opaque"], "re": ["rel", "rate", "RE", "rep", "rs", "ge", "ref", "con", "reat", "spe", "reg", "ar", "pas", "pre", "sys", "ru", "r", "p", "ire", "m", "ne", "ent", "ry", "ren", "e", "parse", "real", "he", "ret", "are", "request", "op", "ro", "it", "res", "red", "fr", "cre", "bre", "rer", "we", "ary", "se", "au", "resp", "ue", "le", "rest", "rec", "ere", "Re", "gre", "reset", "co", "rem"]}}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "void stl_phys_notdirty(hwaddr addr, uint32_t val)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!memory_region_is_ram(section->mr) || section->readonly) {\n\n        addr = memory_region_section_addr(section, addr);\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n        io_mem_write(section->mr, addr, val, 4);\n\n    } else {\n\n        unsigned long addr1 = (memory_region_get_ram_addr(section->mr)\n\n                               & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, addr);\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        stl_p(ptr, val);\n\n\n\n        if (unlikely(in_migration)) {\n\n            if (!cpu_physical_memory_is_dirty(addr1)) {\n\n                /* invalidate code */\n\n                tb_invalidate_phys_page_range(addr1, addr1 + 4, 0);\n\n                /* set dirty bit */\n\n                cpu_physical_memory_set_dirty_flags(\n\n                    addr1, (0xff & ~CODE_DIRTY_FLAG));\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 13517, "substitutes": {"addr": ["i", "rel", "ind", "ord", "ref", "l", "rs", "address", "ash", "adj", "asm", "map", "Address", "alloc", "tx", "x", "off", "hash", "ress", "ip", "gz", "hop", "src", "sha", "np", "hw", "dh", "adr", "ap", "loc", "p", "arr", "r", "err", "add", "tr", "dr", "handle", "pos", "mem", "eth", "index", "id", "url", "rn", "at", "ad", "offset", "inter", " address", "mt", "nl", "attr", "work", "align", "ix", "rt", "pad", "ace", "ac", "a", "arp", "lr", "obj"], "val": [" value", "cal", "Val", "ref", "eval", "sol", "pol", "tx", "x", "als", "value", "buf", "slot", "px", "sel", "p", "VAL", "ival", " eval", "vec", "key", "valid", "Value", " update", " valid", "mem", "xy", "al", " v", "vt", " arg", "ret", "index", "it", "vals", "res", "data", "test", "vol", "fee", " data", "pr", "resp", "pt", "lit", "v", "stat"], "ptr": ["ind", "ref", "fp", "address", "pc", "alloc", "point", "ip", "buf", "inters", "np", "dh", "adr", "ps", "loc", "p", "arr", "r", "add", "tr", "dr", "handle", "pos", "seek", "tp", "buffer", "ctx", "pointer", "index", "eth", "sp", "pointers", "fd", "offset", "inter", "attr", "grad", "pr", "pt", "pad", "Ptr", "td", "pair"], "section": ["second", "ment", "status", "header", "resource", "year", "journal", "element", "sec", "region", "record", "description", "param", "se", "feature", "man", "function", "option", "portion", "pair", "context", "sections", "side", "division", "group", "connection", "slot", "set", "tag", "position", "Section", "name", "flag", "member", "size", "line", "j", "comment", "mod", "part", "link", "library", "command", "definition", "channel", "prefix", "version", "parent", "page", "format", "tab", "session", "usage", "service", "key", "cell", "block", "index", "mode", "job", "variable", "access", "item", "step", "character", "master", "area", "address", "reader", "sect", "local", "state", "result", "setting", "action", "port", "entry", "network", "row", "test", "table", "sector"]}}
{"project": "FFmpeg", "commit_id": "6f1ec38ce2193d3d4cacd87edb452c6d7ba751ec", "target": 0, "func": "static void compute_antialias_float(MPADecodeContext *s,\n\n                              GranuleDef *g)\n\n{\n\n    float *ptr;\n\n    int n, i;\n\n\n\n    /* we antialias only \"long\" bands */\n\n    if (g->block_type == 2) {\n\n        if (!g->switch_point)\n\n            return;\n\n        /* XXX: check this for 8000Hz case */\n\n        n = 1;\n\n    } else {\n\n        n = SBLIMIT - 1;\n\n    }\n\n\n\n    ptr = g->sb_hybrid + 18;\n\n    for(i = n;i > 0;i--) {\n\n        float tmp0, tmp1;\n\n        float *csa = &csa_table_float[0][0];\n\n#define FLOAT_AA(j)\\\n\n        tmp0= ptr[-1-j];\\\n\n        tmp1= ptr[   j];\\\n\n        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\\\n\n        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];\n\n\n\n        FLOAT_AA(0)\n\n        FLOAT_AA(1)\n\n        FLOAT_AA(2)\n\n        FLOAT_AA(3)\n\n        FLOAT_AA(4)\n\n        FLOAT_AA(5)\n\n        FLOAT_AA(6)\n\n        FLOAT_AA(7)\n\n\n\n        ptr += 18;\n\n    }\n\n}\n", "idx": 13524, "substitutes": {"s": ["h", "d", "rs", "sg", "x", "S", "c", "sv", "p", "es", "si", "m", "ms", "gs", "ats", "e", "js", "w", "sq", "t", "ds", "cs", "a", "ns", "ss"], "g": ["gd", "d", "l", "ge", "sg", "gi", "fg", "gm", "z", "go", "group", "gn", "gu", "c", "q", "p", "r", "tg", "m", "gp", "cfg", "gs", "b", "greg", "pg", "gen", "G", "gc", "eg", "j", "og", "msg", "gt", "game", "t", "v", "f", "bg", "mg"], "ptr": ["h", "ind", "fp", "ref", "jp", "address", "pc", "br", "ij", "inters", "depth", "addr", "src", "np", "c", "ps", "adr", "prime", "p", "arr", "r", "m", "nm", "tr", "dr", "push", "pos", "tp", "iter", "buffer", "len", "pointer", "index", "sp", "pointers", "rect", "rn", "offset", "grow", "fr", "iv", "row", "ctr", "t", "pr", "pt", "ts", "pad", "pi", "v", "Ptr", "obj", "length", "lr", "shift"], "n": ["un", "d", "sn", "l", " ni", "nw", "x", "nan", "nu", "np", "number", "c", "nv", "cn", "p", "m", "nm", "mn", "ne", "N", "Ni", "ln", "nt", "len", "no", "nr", "na", "index", "ni", "it", "size", "j", "nn", "num", "en", "nl", "nb", "t", "nc", "pi", "v", "ns"], "i": ["qi", "ind", "l", "ai", "ii", "gi", "k", "di", "x", "sim", "ij", "ip", "c", "ti", "li", "\u0438", "I", "p", "si", "m", "im", "multi", "iter", "index", "iu", "id", "ni", "it", "at", "j", "ci", "ic", "phi", "zi", "ix", "mi", "pi", "v", "y", "bi", "ui"], "tmp0": ["tmp00", "tmpZero", "txt0", " tmpZero", "img0", "img00", "pkgZero", "imgEl", "tempzero", "imgzero", "cache1", "txtEl", "cache0", "txt00", "temp0", "cmpZero", "braceZero", "pkg1", " tmp00", "txtzero", "cmp1", "cmp0", "cacheZero", "tmpzero", "cmp00", "tempEl", "pkg0", "tmpEl", "pkg00", "temp00", "brace0", "brace1"], "tmp1": ["cmpOne", "buff01", "tmp01", "temp2", "tmp001", "emp001", "attrone", "temp01", "cmp2", "attr01", "tmpOne", "emp1", "buff001", "tempOne", "temp1", "cmpone", "buff1", "attr1", "tmpone", " tmp01", " tmpOne", "tempone", "cmp1", "attrOne", "tmp2", "temp001", " tmp2", "cmp01", " tmpone", "emp01", "buffone", "empone"], "csa": ["csp", "csas", "cieso", "lsa", "cso", " cso", "ciesas", "lso", "ciesp", " csas", "ciesa", "lsp", " csp", "lsas"]}}
{"project": "qemu", "commit_id": "97679527bf2f002225d08cfb93f840cef449ac0e", "target": 1, "func": "PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size)\n\n{\n\n    DeviceState *dev;\n\n    PCIBus *b;\n\n    PCIDevice *d;\n\n    I440FXState *s;\n\n    PIIX3State *piix3;\n\n\n\n    dev = qdev_create(NULL, \"i440FX-pcihost\");\n\n    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));\n\n    b = pci_bus_new(&s->busdev.qdev, NULL, 0);\n\n    s->bus = b;\n\n    qdev_init_nofail(dev);\n\n\n\n    d = pci_create_simple(b, 0, \"i440FX\");\n\n    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);\n\n\n\n    piix3 = DO_UPCAST(PIIX3State, dev,\n\n                                 pci_create_simple(b, -1, \"PIIX3\"));\n\n    piix3->pic = pic;\n\n    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);\n\n    (*pi440fx_state)->piix3 = piix3;\n\n\n\n    *piix3_devfn = piix3->dev.devfn;\n\n\n\n    ram_size = ram_size / 8 / 1024 / 1024;\n\n    if (ram_size > 255)\n\n        ram_size = 255;\n\n    (*pi440fx_state)->dev.config[0x57]=ram_size;\n\n\n\n    return b;\n\n}\n", "idx": 13548, "substitutes": {"pi440fx_state": ["pi440fx___states", "pi440fx___state", "pi440fx_init", "pi440fx2state", "pi440fx2start", "pi440fx_State", "pi440fx_trans", "pi440fx_start", "pi440FX_trans", "pi440FX_state", "pi440fx___stat", "pi440ty_state", "pi440fx___init", "pi440FX_init", "pi440fx_states", "pi440fx2stat", "pi440FX_start", "pi440fx_info", "pi440fx___State", "pi440ty_stat", "pi440fx___trans", "pi440fx2states", "pi440fx___info", "pi440fx_stat", "pi440fx___start", "pi440FX_states", "pi440ty_State", "pi440FX_State", "pi440FX_info", "pi440fx2State"], "piix3_devfn": ["piix3_Devfn", "piix3__devpath", "piix3_defpath", "piix3_evfc", "piix3__evnm", "piix3_devfc", "piix3_deffun", "piix3__evpath", "piix3__evfn", "piix3__devfn", "piix3_devln", "piix3__devnm", "piix3_Devnm", "piix3_evpath", "piix3_Devpath", "piix3_devnm", "piix3__evfun", "piix3_evnm", "piix3_devicefn", "piix3__devfun", "piix3_verfc", "piix3_evfun", "piix3_defnm", "piix3_devicefc", "piix3_deviceln", "piix3_devfun", "piix3_deffn", "piix3_evfn", "piix3_verln", "piix3_evln", "piix3_devpath", "piix3_Devfun", "piix3_verfn"], "pic": ["i", "jp", "iac", "pc", "png", "pol", "txt", "pa", "ps", "pen", "picture", "p", "mc", "pict", "pin", "cam", "Pic", "pb", "eric", "sci", "icon", "sac", "tc", "fi", "sp", "gc", "phot", "nic", "pins", "cap", "bin", "pres", "magic", "ic", "phys", "pit", "ig", "fc", "lib", "sc", "ics", "pi", "bi", "ping", "icc", "script"], "ram_size": ["ram2size", "ram_loss", "ram_SIZE", "ram_scale", "cam_size", " ram_code", "crypt_div", "ram_length", "ram2Size", "scale_shape", "RAM_size", "bufferplsize", "ram_default", "scale_Size", "rampldefault", "ramxshape", "crypt_length", "cam_scale", "cam_name", "buffer_default", "bufferpldefault", "cam_info", "ramxdiv", "RAM_Size", "ram_Size", "ram2len", "bufferplloss", "ramptSize", "ram_code", "ram_info", "ramptSIZE", "ram00size", "ramptsize", "crypt_size", "ram2SIZE", " ram_SIZE", "buffer_loss", "ramxsize", "ram00default", "ram_shape", "crypt_shape", "RAM_SIZE", "ramplsize", "ramplloss", "ramxlength", "ram_div", "ram00loss", "scale_len", "ram_name", "scale_size", "ramptlen", "ram_len", " ram_scale", "RAM_len", "buffer_size"], "dev": ["device", "ch", "av", "gu", "develop", "mem", "js", "des", "g", "sd", "sw", "debug", "se", "adv", "vo", "h", "prop", "serv", "os", "util", "def", "bus", "tr", "pro", "res", "iv", "dj", "conn", "enc", "t", "cmd", "vision", "ve", "ow", "serial", "buf", "sys", "cam", "de", "ev", "ad", "data", "normal", "a", "val", "pub", "dem", "n", "DEV", "priv", "go", "out", "local", "new", "hw", "ver", "p", "desc", "raw", "e", "db", "Dev", "dd", "cho", "dis", "driver", "test", "pad", "v", "w", "build"], "b": ["bs", "bu", "i", "h", "l", "or", "sb", "n", "bl", "bt", "bc", "br", "x", "rb", "out", "usb", "c", "u", "bh", "cb", "p", "bus", "ib", "r", "pb", "bo", "fb", "db", "e", "bb", "w", "g", "j", "bank", "B", "bin", "nb", "t", "o", "ba", "a", "v", "wb", "be", "bi", "f", "y", "bg"], "d": ["gd", "i", "h", "l", "dm", "dict", "n", "dx", "dt", "z", "di", "dc", "c", "bd", "p", "r", "dr", "dim", "e", "db", "dd", "der", "D", "g", "j", "ad", "sd", "dj", "driver", "t", "ds", "du", "a", "v", "f", "w", "da"], "s": ["bs", "sing", "i", "fs", "rs", "sb", "n", "serv", "sl", "z", "S", "os", "sv", "c", "ps", "p", "sys", "m", "gs", "js", "sa", "sp", "w", "g", "sh", "j", "sd", "sq", "t", "ds", "se", "cs", "ts", "sc", "a", "v", "y", "ns", "ss"], "piix3": ["apiix1", "piIX3", "piixels03", "apiax1", "apiixels3", " piuxthree", "piact2", "apiiox03", "piix1", "apiixthree", "apifx03", "piox3", "piixels7", "piixels3", "piinx1", "piix4", "piIX4", "piax1", "piiox4", "piux2", "apiix4", " piux2", "pix3", "pixThree", "piiox3", " piox1", " piox2", "apiax7", " piix1", "piinx03", "piixels1", "piax7", "apifx3", "pirixthree", "piux03", "pifx3", "apiiox4", "piixelsthree", "apiax3", "parixthree", "piIX03", " piixthree", "piox7", "piiox03", "piaxthree", " piux3", "piix7", "piox2", "piuxthird", "paixthree", "pix1", "piox1", "pioxthird", "pioxthree", "paix3", "parix03", " piox3", " piixthird", "piix03", "apiaxthree", "apiix7", "piinx3", "pirix03", "piixthird", "piinx2", "piinxThree", "piixthree", "pioxThree", "piax3", "piix2", " piix2", "piux43", "piux3", "apiixelsthree", "pix2", "piactthird", "apiixels03", "piactthree", "apiix43", "apiix03", "piox43", "pifx03", "piixt4", "apiiox3", "piox03", "paix43", "piixt03", "paix03", "piix43", "pifx43", "piuxthree", "pifxthree", "piact3", " piuxthird", "parix3", "piixThree", "apifx43", " pioxThree", "piinx43", "pirix3", "parix43", "apiix3", "piixt3", "pix03", " piixThree", "pixthree", "piinxthree", "pirix43"]}}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)\n\n{\n\n    return inline_cvttq(env, a, float_round_to_zero, 0);\n\n}\n", "idx": 13554, "substitutes": {"env": ["context", "info", "end", "map", "En", "gn", "buf", "nv", "np", "conf", "environment", " environment", "ptr", "bench", "vp", "te", "viron", "mem", "code", "e", "window", "dev", "ah", "hl", "estate", "ctx", "cv", "ev", "en", "conn", "ov", "anc", "open", "ec", "ef", "esc", "nc", "Environment", "config", "v", "gov"], "a": ["eta", "am", "fa", "A", "ta", "ar", "ata", "c", "aa", "ap", "an", "ma", "ia", "b", "as", "sa", "na", "aaa", "wa", "access", "ao", "ya", "data", "sta", "t", "eas", "apa", "ca", "ea", "o", "ba", "ac", "ae", "y", "area", "da", "alpha", "ga"]}}
{"project": "FFmpeg", "commit_id": "73789b85a759f3874112618120194e1712d7adcd", "target": 0, "func": "int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)\n\n{\n\n    int ret;\n\n\n\n    s->ext_audio_mask = 0;\n\n    s->xch_pos = s->xxch_pos = s->x96_pos = 0;\n\n\n\n    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)\n\n        return ret;\n\n    s->gb_in = s->gb;\n\n\n\n    if ((ret = parse_frame_header(s)) < 0)\n\n        return ret;\n\n    if ((ret = alloc_sample_buffer(s)) < 0)\n\n        return ret;\n\n    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)\n\n        return ret;\n\n    if ((ret = parse_optional_info(s)) < 0)\n\n        return ret;\n\n\n\n    // Workaround for DTS in WAV\n\n    if (s->frame_size > size && s->frame_size < size + 4)\n\n        s->frame_size = size;\n\n\n\n    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Read past end of core frame\\n\");\n\n        if (s->avctx->err_recognition & AV_EF_EXPLODE)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13555, "substitutes": {"s": ["bs", "fs", "ids", "ps", "r", "outs", "ms", "js", "sa", "services", "g", "sw", "gets", "se", "y", "ins", "details", "h", "changes", "sb", "serv", "ops", "results", "als", "os", "sv", "has", "er", "set", "m", "ers", "ags", "is", "ains", "parts", "ns", "l", "rs", "save", "ads", "ies", "S", "q", "eps", "comm", "st", "sys", "ls", "vs", "reads", "hs", "ats", "its", "ims", "sq", "sets", "ts", "ows", "qs", "ss", "sts", "n", "z", "ses", "ar", "ver", "p", "es", "sam", "us", "aws", "gs", "bis", "eds", "less", "ds", "cs", "stats", "obj", "w"], "data": ["d", "cache", " DATA", "bytes", "image", "Data", "DATA", "out", "value", "buf", "ata", "new", "p", "r", "m", "empty", "raw", "name", "in", "b", "window", "buffer", "len", "done", "to", "str", "bin", "t", "o", "a", "bits", "text", "f", "length", "w", "dat"], "size": ["shape", "equal", "ize", "IZE", "sum", "type", "send", "n", "SIZE", "style", "padding", "format", "small", "number", "scale", "message", "set", "capacity", "zero", "general", "empty", "name", "now", "window", "count", "none", "len", "no", "total", "to", "id", "g", "use", "offset", "num", "grow", "en", "normal", "max", "zone", "fee", "ose", "body", "v", "Size", "length", "area", "shift"], "ret": ["status", "re", "cat", "Ret", "r", "pass", "et", "nil", "ry", "mem", "att", "it", "url", "report", "ter", "expr", "rets", "fit", "rem", "usr", "prop", " alt", "pas", "del", "def", "tr", "good", "flag", "res", "j", "try", "net", "resp", "print", "jp", "RET", "pret", "ber", "value", "not", "sys", "alt", "nt", "cert", "red", "rm", "mt", "det", "gt", "arg", "rt", "deg", "val", "let", "ft", "ref", "elt", "out", "reg", "result", "rev", "iter", "fun", "cont", "rier", "back", "ll", " Ret", "lit", "v", "reset"]}}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv sr_cy = tcg_temp_new();\n\n\n\n    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);\n\n    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);\n\n\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);\n\n\n\n    gen_ove_cy(dc, sr_cy);\n\n    tcg_temp_free(sr_cy);\n\n}\n", "idx": 13556, "substitutes": {"dc": ["oc", "vc", "d", "kw", "dm", "dt", "pc", "bc", "dp", "DC", "lc", "di", "cm", "c", "cp", "mc", "disc", "desc", "dr", "tc", "cc", "rc", "db", "ctx", "arc", "ic", "ec", "ds", "nc", "fc", "ca", "sc", "ac", "cr", "cd", "doc", "da"], "dest": ["dist", "usr", "d", "orig", "route", "trans", "nw", "win", "cas", "Dest", "way", "cat", "result", "src", "st", "del", "loc", "disc", "tr", "desc", "origin", "us", "port", "target", "dev", "home", "iter", "path", "decl", "spec", "de", "comb", "trip", "source", "master", "v", "wb", "rest", "est"], "srca": ["srA", " srcA", "srao", " srcarea", "sourceao", "sourcea", "rcA", "rcaa", "srcA", "srcarea", " srcao", "srarea", "targeta", "rca", "srcao", "targetA", " srcaa", "targetaa", "sra", "sourceA", "sourcearea", "srcaa"], "srcb": ["srcr", "srcbb", "destbb", "src2", " srcbb", "dest2", "rcdb", "srcdb", " srcB", "sourcebb", "source2", "rcb", "rca", " srcdb", "srcB", " srcr", "destb", "sourceB", "rcr", "surr", "surdb", "sura", " src2", "destB", "sourceb", "surb"]}}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static int decode_init_mp3on4(AVCodecContext * avctx)\n\n{\n\n    MP3On4DecodeContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    if ((avctx->extradata_size < 2) || (avctx->extradata == NULL)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Codec extradata missing or too short.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    s->chan_cfg = (((unsigned char *)avctx->extradata)[1] >> 3) & 0x0f;\n\n    s->frames = mp3Frames[s->chan_cfg];\n\n    if(!s->frames) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid channel config number.\\n\");\n\n        return -1;\n\n    }\n\n    avctx->channels = mp3Channels[s->chan_cfg];\n\n\n\n    /* Init the first mp3 decoder in standard way, so that all tables get builded\n\n     * We replace avctx->priv_data with the context of the first decoder so that\n\n     * decode_init() does not have to be changed.\n\n     * Other decoders will be inited here copying data from the first context\n\n     */\n\n    // Allocate zeroed memory for the first decoder context\n\n    s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext));\n\n    // Put decoder context in place to make init_decode() happy\n\n    avctx->priv_data = s->mp3decctx[0];\n\n    decode_init(avctx);\n\n    // Restore mp3on4 context pointer\n\n    avctx->priv_data = s;\n\n    s->mp3decctx[0]->adu_mode = 1; // Set adu mode\n\n\n\n    /* Create a separate codec/context for each frame (first is already ok).\n\n     * Each frame is 1 or 2 channels - up to 5 frames allowed\n\n     */\n\n    for (i = 1; i < s->frames; i++) {\n\n        s->mp3decctx[i] = av_mallocz(sizeof(MPADecodeContext));\n\n        s->mp3decctx[i]->compute_antialias = s->mp3decctx[0]->compute_antialias;\n\n        s->mp3decctx[i]->adu_mode = 1;\n\n        s->mp3decctx[i]->avctx = avctx;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13571, "substitutes": {"avctx": [" avjac", "avercontext", " avcmp", "vrconn", "awcontext", "awtx", "wavcontext", "avtx", "avecfg", "ajconn", " avreq", "avetimeout", "aftimeout", "vrcontext", "avcfg", "ovcfg", "averpool", " avcontext", "avecb", "avcf", "avertimeout", "awctx", " avcb", " avtmp", "ajctl", "ajtx", "ovcb", "avtc", " avcf", "avereq", "avmc", "avtmp", "awjac", "ajctx", "ajjp", "avepkg", "vertx", "avertmp", "afcontext", "avermc", "ovctx", "averkl", "avcmd", "avtimeout", "averctl", "afctl", "avpkg", "navctx", "averctx", "vrtx", "aftxt", "navjac", "avejac", "vrcmp", "avectx", "avjp", "afctx", "avekl", " avmc", "aftmp", "avsys", " avpkg", "navsys", "avjac", "avesys", "navtc", "verctx", "avepool", "avcontext", "avercmd", "avpool", "vrjac", "avecontext", "ajcv", "wavpkg", "ajcmp", "avertc", " avtxt", "ajmc", "averreq", " avkl", "averpkg", "ajcontext", "avcmp", "averjac", " avcmd", "averjp", " avjp", "vrctx", "avtxt", "avercmp", "wavcf", " avcfg", "avetxt", "avetc", "afpkg", "avkl", "afjac", "afcmp", "avetx", " avctl", "avctl", " avtx", "wavctx", "avercv", "avecmd", "vrctl", "avectl", "avertx", "vercv", "avecmp", "avcv", "ovtx", "avconn", "aveconn", " avpool", "aversys", "avecf", "avcb", "avreq"], "s": ["bs", "fs", "ids", "status", "pers", "ps", "strings", "args", "ms", "ports", "js", "iss", "sa", "g", "services", "sw", "gets", "ares", "se", "tests", "y", "ins", "details", "h", "changes", "sb", "series", "als", "os", "sv", "m", "sports", "ags", "tags", "j", "t", "states", "is", "ains", "parts", "ns", "mods", "l", "rs", "sl", "S", "c", "comm", "sys", "ess", "ls", "vs", "hs", "ats", "its", "ims", "sq", "https", "acs", "ts", "ows", "qs", "ss", "sts", "ses", "p", "es", "aws", "gs", "spec", "bis", "less", "ds", "cs", "v", "stats", "obj", "scl"], "i": [" ki", "cli", "gu", "u", " m", " ii", "it", "g", "ci", "ki", "zi", " mi", " iter", "mi", "y", " multi", "mu", " li", "h", " n", "ii", " si", " di", "ij", " pi", "m", "ri", "multi", "j", "xi", " x", "ix", "is", "ui", "ini", "qi", "ind", "l", "ai", "di", "x", "c", "q", " bi", "ti", "li", "\u0438", "I", "si", "batch", "im", "in", " v", "ims", "index", "fi", "a", " vi", "pi", "bi", " pos", "n", "gi", " ni", "z", "point", "sim", "ip", " p", "p", " j", " I", "ami", "remote", " index", "iu", "id", "me", " count", "span", " c", "v", " ti"]}}
{"project": "qemu", "commit_id": "1acae9f22380a03b468a29a3cc035b280610b5e4", "target": 0, "func": "_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,\n\n          const struct timespec *,tsp,int,flags)\n\n#endif\n\n#endif /* CONFIG_UTIMENSAT  */\n\n\n\n#ifdef CONFIG_INOTIFY\n\n#include <sys/inotify.h>\n\n\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\nstatic int sys_inotify_init(void)\n\n{\n\n  return (inotify_init());\n\n}\n", "idx": 13589, "substitutes": {}}
{"project": "qemu", "commit_id": "8dc7a7725bd6db2aa7e3c09b49bc21a1a25f40cb", "target": 1, "func": "static void curl_readv_bh_cb(void *p)\n\n{\n\n    CURLState *state;\n\n    int running;\n\n\n\n    CURLAIOCB *acb = p;\n\n    BDRVCURLState *s = acb->common.bs->opaque;\n\n\n\n    qemu_bh_delete(acb->bh);\n\n    acb->bh = NULL;\n\n\n\n    size_t start = acb->sector_num * SECTOR_SIZE;\n\n    size_t end;\n\n\n\n    // In case we have the requested data already (e.g. read-ahead),\n\n    // we can just call the callback and be done.\n\n    switch (curl_find_buf(s, start, acb->nb_sectors * SECTOR_SIZE, acb)) {\n\n        case FIND_RET_OK:\n\n            qemu_aio_release(acb);\n\n            // fall through\n\n        case FIND_RET_WAIT:\n\n            return;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    // No cache found, so let's start a new request\n\n    state = curl_init_state(s);\n\n    if (!state) {\n\n        acb->common.cb(acb->common.opaque, -EIO);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->start = 0;\n\n    acb->end = (acb->nb_sectors * SECTOR_SIZE);\n\n\n\n    state->buf_off = 0;\n\n    g_free(state->orig_buf);\n\n    state->buf_start = start;\n\n    state->buf_len = acb->end + s->readahead_size;\n\n    end = MIN(start + state->buf_len, s->len) - 1;\n\n    state->orig_buf = g_malloc(state->buf_len);\n\n    state->acb[0] = acb;\n\n\n\n    snprintf(state->range, 127, \"%zd-%zd\", start, end);\n\n    DPRINTF(\"CURL (AIO): Reading %d at %zd (%s)\\n\",\n\n            (acb->nb_sectors * SECTOR_SIZE), start, state->range);\n\n    curl_easy_setopt(state->curl, CURLOPT_RANGE, state->range);\n\n\n\n    curl_multi_add_handle(s->multi, state->curl);\n\n\n\n    /* Tell curl it needs to kick things off */\n\n    curl_multi_socket_action(s->multi, CURL_SOCKET_TIMEOUT, 0, &running);\n\n}\n", "idx": 13604, "substitutes": {"p": ["pkg", "i", "h", "fp", "jp", "n", "pc", "pa", "np", "c", "cp", "q", "ps", "ap", "wp", "r", "m", "pb", "vp", "b", "ctx", "sp", "op", "P", "g", "j", "t", "bp", "a", "pp", "pi", "v", "ping"], "state": ["view", "status", "success", "trust", "error", "sequence", "space", "run", "resource", "check", "r", "private", "valid", "close", "rule", "instance", "stable", "se", "ace", "base", "powered", "current", "event", "h", "info", "power", "ate", "component", "style", "started", "temp", "draw", "init", "root", "set", "tag", "store", "start", "operator", "m", "name", "commit", "active", "loop", "the", "zone", "comment", "t", "State", "states", "is", "stat", "print", "f", "policy", "command", "registered", "finished", "type", "version", "value", "c", "st", "change", "update", "STATE", "trace", "count", "no", "al", "index", "job", "range", "control", "process", "call", "un", "runner", "n", "time", "progress", "monitor", "out", "local", "result", "list", "port", "none", "estate", "spec", "see", "we", "test", "config", "scope", "user", "post"], "running": ["version", " started", "starting", "hidden", "status", "NING", "padding", "started", " starting", "cur", "run", "working", "enabled", "available", "setting", "ready", "bound", "binding", " remaining", "valid", "name", "using", "no", "active", "loop", "existing", "total", "done", "stable", "ending", "loading", " Running", "blocking", "live", "current", "checked", "visible", "Running", "initialized"], "acb": ["acersb", " acbc", "accu", "accb", "acona", "pacv", "accbb", "abb", "aclj", "acerr", "acrb", "sacl", "acba", "acr", "accbe", "acbuf", "acnb", "pacbd", "actb", "ancbe", "acsb", "acbr", " acsb", "accg", "acong", "iacsb", "sacB", " acr", " cacbb", "ACp", "actrb", "icanb", "sacv", "acl", "accr", "acab", "acca", "pacbc", "iacbb", "acp", " acbb", "ancbb", "ocbe", "aclb", "accB", "accbd", "racbe", " acbe", "acd", "ocb", " cacr", "actl", "ACB", "aconb", "ecob", "iacp", "accj", "acbc", "accob", " acby", "absbb", " acd", "pacl", "pacsb", "aclba", "agb", " acu", "accsb", " cacsb", "aca", "accbc", "pacg", "sacbd", "abr", "ancv", "ancb", "iacb", "agwb", "pacp", "absb", "racwb", "accby", "abnb", "sacsb", " cacba", "accbuf", "aconbb", "iacba", "sacb", "acg", "pacb", "ancsb", " cacob", "racb", "achbr", "acby", "ancrb", "aconbuf", "aclnb", "aconr", "ACbuf", " acrb", " acba", "ancbd", "acwb", "acv", "racsb", "accwb", "actB", "macp", "aconrb", "iacd", "ecba", " acj", "abba", "aclsb", "acob", "aconp", "icanbe", "aconB", "acu", " cacby", "ecb", "pacbe", "absba", "macb", "accl", "accd", "acerbc", "achwb", "ancr", "aconbe", "acbd", " acp", "achb", " aca", "accba", "acerb", "agab", "acj", "actbb", "aconbd", "agbr", "icanbc", "acB", "ocbb", "ecbb", "actp", "icanl", "accbr", "macrb", "acbb", "ACb", "actsb", " cacb", "achab", "aconu", "accnb", "acbe", "aclr", "ocrb", "accab", "accp", "macbb", "pacwb"], "s": ["bs", "h", "fs", "rs", "changes", "sb", "n", "sl", "settings", "status", "ses", "S", "os", "session", "space", "service", "sv", "q", "c", "ps", "comm", "sys", "r", "socket", "set", "m", "args", "ls", "ssl", "gs", "b", "ats", "its", "js", "ports", "as", "sa", "sp", "sk", "w", "sts", "spec", "bis", "g", "services", "sq", "https", "t", "self", "ds", "se", "ts", "is", "a", "south", "bits", "v", "stats", "ins", "qs", "scope", "parts", "ns", "params", "ss"], "end": ["event", "ff", "send", "stop", "ax", "n", "last", "nd", "eff", "z", "off", "out", "next", "until", "begin", "dest", "st", "eng", "set", "start", "add", "rend", "port", "ent", "close", "pos", "e", " End", "len", "gen", "env", "final", "index", "hend", "id", "size", "it", "limit", "range", "offset", "ending", "ended", "en", "max", "den", "open", "enc", "END", "fin", "ender", "End", "head", "pad", "rest", "be", "length", "pend", "est"]}}
{"project": "FFmpeg", "commit_id": "3a83b2461e4ce9d48ad6ab037eb14569d0e53506", "target": 1, "func": "static int dnxhd_encode_rdo(AVCodecContext *avctx, DNXHDEncContext *ctx)\n\n{\n\n    int lambda, up_step, down_step;\n\n    int last_lower = INT_MAX, last_higher = 0;\n\n    int x, y, q;\n\n\n\n    for (q = 1; q < avctx->qmax; q++) {\n\n        ctx->qscale = q;\n\n        avctx->execute2(avctx, dnxhd_calc_bits_thread, NULL, NULL, ctx->m.mb_height);\n\n    }\n\n    up_step = down_step = 2<<LAMBDA_FRAC_BITS;\n\n    lambda = ctx->lambda;\n\n\n\n    for (;;) {\n\n        int bits = 0;\n\n        int end = 0;\n\n        if (lambda == last_higher) {\n\n            lambda++;\n\n            end = 1; // need to set final qscales/bits\n\n        }\n\n        for (y = 0; y < ctx->m.mb_height; y++) {\n\n            for (x = 0; x < ctx->m.mb_width; x++) {\n\n                unsigned min = UINT_MAX;\n\n                int qscale = 1;\n\n                int mb = y*ctx->m.mb_width+x;\n\n                for (q = 1; q < avctx->qmax; q++) {\n\n                    unsigned score = ctx->mb_rc[q][mb].bits*lambda+(ctx->mb_rc[q][mb].ssd<<LAMBDA_FRAC_BITS);\n\n                    if (score < min) {\n\n                        min = score;\n\n                        qscale = q;\n\n                    }\n\n                }\n\n                bits += ctx->mb_rc[qscale][mb].bits;\n\n                ctx->mb_qscale[mb] = qscale;\n\n                ctx->mb_bits[mb] = ctx->mb_rc[qscale][mb].bits;\n\n            }\n\n            bits = (bits+31)&~31; // padding\n\n            if (bits > ctx->frame_bits)\n\n                break;\n\n        }\n\n        //av_dlog(ctx->m.avctx, \"lambda %d, up %u, down %u, bits %d, frame %d\\n\",\n\n        //        lambda, last_higher, last_lower, bits, ctx->frame_bits);\n\n        if (end) {\n\n            if (bits > ctx->frame_bits)\n\n                return -1;\n\n            break;\n\n        }\n\n        if (bits < ctx->frame_bits) {\n\n            last_lower = FFMIN(lambda, last_lower);\n\n            if (last_higher != 0)\n\n                lambda = (lambda+last_higher)>>1;\n\n            else\n\n                lambda -= down_step;\n\n            down_step *= 5; // XXX tune ?\n\n            up_step = 1<<LAMBDA_FRAC_BITS;\n\n            lambda = FFMAX(1, lambda);\n\n            if (lambda == last_lower)\n\n                break;\n\n        } else {\n\n            last_higher = FFMAX(lambda, last_higher);\n\n            if (last_lower != INT_MAX)\n\n                lambda = (lambda+last_lower)>>1;\n\n            else if ((int64_t)lambda + up_step > INT_MAX)\n\n                return -1;\n\n            else\n\n                lambda += up_step;\n\n            up_step = FFMIN((int64_t)up_step*5, INT_MAX);\n\n            down_step = 1<<LAMBDA_FRAC_BITS;\n\n        }\n\n    }\n\n    //av_dlog(ctx->m.avctx, \"out lambda %d\\n\", lambda);\n\n    ctx->lambda = lambda;\n\n    return 0;\n\n}\n", "idx": 13635, "substitutes": {"avctx": [" avjac", "averjac", "avercontext", "savjp", " avcc", "abcc", "absetup", "averjp", "cvcontext", " avjp", " avcmp", "abcontext", "afcontext", "aversetup", "avtx", "vctx", "avcontext", "averctl", "afcm", "savctl", " avcontext", "avsetup", "vtx", "averctx", "cvctx", "avetx", "aftx", "avcmp", "avctl", " avctl", " avtx", "savctx", "svctx", "vcontext", "abcm", "avectx", "abctx", "avecontext", "avertx", "afctx", "avjp", "savjac", " avsetup", "cvcc", "cvtx", "avecm", "avcc", "svcmp", "svcontext", "vcmp", "abtx", "avjac", "svtx", "avcm"], "ctx": ["pkg", "voc", "history", "tk", "conv", "cmp", "cm", "np", "addr", "cp", "city", "check", "kl", "pg", "fn", "cv", "acl", "utils", "expr", "ca", "context", "that", "info", "kw", "std", "tmp", "ck", "ctrl", "Context", "cu", "mc", "jac", "cfg", "timeout", "ia", "tc", "gc", "cf", "kt", "conn", "resp", "cmd", "command", "abc", "jp", "req", "prefix", "pc", "unc", "via", "etc", "c", "exec", "loc", "sys", "ppo", "console", "cc", "index", "ct", "kj", "proc", " cx", "work", "fw", "rt", "wcs", "co", "xp", "tx", "lc", "ctl", "setup", "xc", "hw", "jj", "desc", "handle", "act", "mom", "ctr", "func", "crit", "nc", "fc", "config", "wx", "aka", "obj", "iat"], "lambda": ["lower", "eta", "priority", "cb", "this", "bd", "kl", "prime", "qa", "frequency", "colm", "dim", "lam", "offset", "acl", "expr", "function", "mu", "ta", "kw", "sb", "fa", "tmp", "partial", "two", "hello", "la", "half", "hi", "dra", "zero", "m", "mb", "factor", "Alpha", "ja", "aaa", "size", "cf", "igma", "broad", "t", "fee", "perm", "f", "length", "delay", "alpha", "l", "bf", "xb", "usage", "balance", "hz", "xf", "foo", "ma", "lo", "fred", "nom", "wa", "mas", "mega", "amb", "lu", "phi", "shr", "aw", "una", "deg", "a", "bits", "pi", "da", "i", "progress", "json", "lc", "scale", "capacity", "weights", "sam", "xa", "window", "xy", "pointer", "amd", "fun", "lim", "func", "beta", "appa", "lr", "qt", "shift"], "up_step": ["down_steps", "down_walk", "upTimetick", "up_walk", "up_STEP", "up___steps", "down_STEP", "up___step", "up_skip", "upTimestep", "up___sum", "upTimesteps", " up_loop", "up_steps", "down_sum", "upTimewalk", "up_loop", "up_sum", " up_steps", "up_tick", "up___STEP", "down_tick", " up_skip"], "down_step": ["down_steps", "down_scale", "up_STEP", "up_Step", "up_stage", "down_STEP", "down2STEP", "down2step", "down_drop", "down2start", "downptstep", "down_start", " down_steps", "up_steps", "downptdrop", "downptstage", " down_scale", "downptsteps", "up_loop", "up_drop", "down_loop", "down_Step", "down2steps", " down_STEP", "up_start", "down_stage"], "x": ["fx", "i", "h", "xp", "l", "ax", "n", "dx", "time", "k", "z", "tx", "lat", "px", "xc", "xml", "xf", "p", "xt", "r", "m", "ux", "key", "rx", "xa", "xs", "ry", "in", "att", "xy", "index", "path", "inx", "at", "j", "xxx", "ice", "mx", "xi", "ex", "el", "ox", "t", "X", "ix", "o", "wx", "v", "ph", "f", "yx", "w", "xx", "on"], "y": ["wy", "i", "ey", "ch", "py", "ye", "yi", "vy", "ty", "z", "kit", "ies", "sim", "iy", "cy", "col", "dy", "yo", "hot", "asy", "sys", "very", "sy", "from", "m", "ym", "height", "ry", "b", "yer", "ot", "xy", "my", "lon", "ay", "g", "j", "yt", "ya", "row", "ys", "axy", "gy", "try", "oy", "yy", "yr", "Y", "sky", "v", "by", "ny"], "q": ["pkg", "requ", "ch", "k", "u", "cp", "qa", "ry", "eq", "pg", "quit", "cv", "g", "quant", "quest", "pt", "qu", "que", "bg", "h", "ck", "Q", "aq", "ib", "m", "mb", "j", "ix", "f", "query", "qi", "l", "req", "quote", "ve", "pe", "ql", "gm", "qt", "c", "ask", "key", "qual", "min", "mp", "index", "bit", "sq", "lock", "dq", "pp", "mask", "iq", "i", "queue", "quality", "z", "go", "ip", "kg", "col", "p", "qq", "b", "id", "qv", "ke", "ox", "quick", "question", "wx", "ue", "v", "w"]}}
{"project": "FFmpeg", "commit_id": "5a2645cafeca1c2207ac55cc831c3349572a82ed", "target": 1, "func": "static int find_and_decode_index(NUTContext *nut)\n\n{\n\n    AVFormatContext *s = nut->avf;\n\n    AVIOContext *bc    = s->pb;\n\n    uint64_t tmp, end;\n\n    int i, j, syncpoint_count;\n\n    int64_t filesize = avio_size(bc);\n\n    int64_t *syncpoints;\n\n    int8_t *has_keyframe;\n\n    int ret = AVERROR_INVALIDDATA;\n\n\n\n    avio_seek(bc, filesize - 12, SEEK_SET);\n\n    avio_seek(bc, filesize - avio_rb64(bc), SEEK_SET);\n\n    if (avio_rb64(bc) != INDEX_STARTCODE) {\n\n        av_log(s, AV_LOG_ERROR, \"no index at the end\\n\");\n\n        return ret;\n\n    }\n\n\n\n    end  = get_packetheader(nut, bc, 1, INDEX_STARTCODE);\n\n    end += avio_tell(bc);\n\n\n\n    ffio_read_varlen(bc); // max_pts\n\n    GET_V(syncpoint_count, tmp < INT_MAX / 8 && tmp > 0);\n\n    syncpoints   = av_malloc(sizeof(int64_t) *  syncpoint_count);\n\n    has_keyframe = av_malloc(sizeof(int8_t)  * (syncpoint_count + 1));\n\n    if (!syncpoints || !has_keyframe)\n\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < syncpoint_count; i++) {\n\n        syncpoints[i] = ffio_read_varlen(bc);\n\n        if (syncpoints[i] <= 0)\n\n            goto fail;\n\n        if (i)\n\n            syncpoints[i] += syncpoints[i - 1];\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        int64_t last_pts = -1;\n\n        for (j = 0; j < syncpoint_count;) {\n\n            uint64_t x = ffio_read_varlen(bc);\n\n            int type   = x & 1;\n\n            int n      = j;\n\n            x >>= 1;\n\n            if (type) {\n\n                int flag = x & 1;\n\n                x >>= 1;\n\n                if (n + x >= syncpoint_count + 1) {\n\n                    av_log(s, AV_LOG_ERROR, \"index overflow A\\n\");\n\n                    goto fail;\n\n                }\n\n                while (x--)\n\n                    has_keyframe[n++] = flag;\n\n                has_keyframe[n++] = !flag;\n\n            } else {\n\n                while (x != 1) {\n\n                    if (n >= syncpoint_count + 1) {\n\n                        av_log(s, AV_LOG_ERROR, \"index overflow B\\n\");\n\n                        goto fail;\n\n                    }\n\n                    has_keyframe[n++] = x & 1;\n\n                    x >>= 1;\n\n                }\n\n            }\n\n            if (has_keyframe[0]) {\n\n                av_log(s, AV_LOG_ERROR, \"keyframe before first syncpoint in index\\n\");\n\n                goto fail;\n\n            }\n\n            assert(n <= syncpoint_count + 1);\n\n            for (; j < n && j < syncpoint_count; j++) {\n\n                if (has_keyframe[j]) {\n\n                    uint64_t B, A = ffio_read_varlen(bc);\n\n                    if (!A) {\n\n                        A = ffio_read_varlen(bc);\n\n                        B = ffio_read_varlen(bc);\n\n                        // eor_pts[j][i] = last_pts + A + B\n\n                    } else\n\n                        B = 0;\n\n                    av_add_index_entry(s->streams[i], 16 * syncpoints[j - 1],\n\n                                       last_pts + A, 0, 0, AVINDEX_KEYFRAME);\n\n                    last_pts += A + B;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n\n        av_log(s, AV_LOG_ERROR, \"index checksum mismatch\\n\");\n\n        goto fail;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    av_free(syncpoints);\n\n    av_free(has_keyframe);\n\n    return ret;\n\n}\n", "idx": 13636, "substitutes": {"nut": ["six", "stab", "nuts", "n", "critical", "tn", "nih", "nw", "bj", "cot", "nv", "np", "ours", "cn", "nm", "Nut", "nas", "orn", "san", "hawk", "nt", "sat", "ng", "uts", "fn", "nr", "ctx", "four", "rn", "nova", "sq", "hog", "nor", "rot", "nir", "cro", "piece", "ox", "mson", "gob", "nc", "snap", "torn", "ore", "nex", "hn", "anova", "ns", "sequ"], "s": ["bs", "h", "fs", "sn", "rs", "n", "sb", "sl", "ses", "conv", "S", "os", "c", "sv", "ps", "conf", "p", "sys", "es", "r", "set", "an", "hs", "aws", "gs", "sac", "ats", "b", "js", "sat", "sa", "sts", "w", "csv", "sq", "t", "ds", "cs", "ts", "sc", "is", "a", "v", "f", "stats", "sis", "ns", "ss"], "bc": ["bs", "oc", "vc", "con", "sb", "pc", "bt", "ck", "bec", "lc", "unc", "bf", "gro", "dc", "rb", "conv", "cm", "c", "xc", "cb", "comm", "cn", "bitcoin", "mc", "bd", "ib", "jac", "pb", "console", "bo", "arb", "tc", "b", "chron", "cc", "rc", "sec", "db", "ctx", "gc", "bb", "conn", "cl", "soc", "ic", "ec", "BC", "bp", "nc", "fc", "cs", "sc", "uc", "jc", "ob", "bi", "bg", "co"], "tmp": ["ind", "cache", "stop", "bytes", "nd", "temp", "out", "etc", "buf", "cmp", "assets", " old", "np", "important", "cb", "root", "p", "uv", "err", "m", "ptr", "img", "T", "mb", "mk", "timeout", "buff", "qq", "tc", "nt", "mp", "tp", "xy", "ctx", "sp", "size", "offset", "max", "nb", "t", "test", "tt", "tm", "snap", "resp", "rt", " np", "cmd", "perm", "td", "obj", "params"], "end": ["ff", "send", "stop", "nd", "off", "buf", "np", "begin", "st", "append", "set", "p", "start", "add", "ent", "alt", "mem", "e", "len", "final", "buffer", "ret", "id", "size", "ad", "offset", "ending", "ended", "max", "conn", "ep", "END", "t", "fin", "End", "head", "ue", "td", "pend", "obj", "post", "length", "reset"], "i": ["k", "status", "cli", " ii", "it", "g", "ci", "ie", "ki", "zi", "mi", "y", "h", "info", "ii", "ji", "ij", "init", "hi", "er", "m", "ri", "name", "ia", "multi", "iii", "xi", "try", "ix", "is", "f", "ui", "ini", "qi", "ind", "l", "ai", "di", "c", "ti", "li", "\u0438", "I", "si", "batch", "im", "in", "ims", "index", "phi", "o", "pi", "bi", "io", "iq", "n", "gi", "sim", "ip", "ei", "p", "jj", "list", "dr", "e", "chain", "ami", "iu", "id", "me", "ic", "v"], "j": ["h", "ind", "jp", "l", "ii", "ji", "n", "aj", "k", "z", "json", "br", "bj", "sim", "ij", "c", "q", "p", "jj", "jump", "m", "jac", "oj", "nm", "pos", "b", "ja", "js", "xy", "ni", "g", "it", "uj", "fr", "dj", "kj", "try", "J", "jc", "ix", "o", "y", "v", "bi", "obj", "jl"], "syncpoint_count": ["syncpoint8Count", "syncpoint8time", "synctype_number", "syncpoint_counter", "syncpointer_length", "syncpoint1count", "syncpointlyCount", "syncpoint_code", "syncpointer_count", "syncpoint1num", "syncpoint2Count", "syncpointer_time", "syncpoint_time", "syncpoint_length", "syncpoint2count", "syncpointlycount", "synctype_found", "syncpoint8count", "syncpoint_size", "syncpointer_code", "synctype_count", "syncpoint_num", "syncpoint8code", "syncpoint_number", "syncblock_Count", "syncblock_code", "syncpoint2length", "syncpoint1Count", "syncblock_num", "syncblock_count", "syncpointlynumber", "syncpointlyfound", "syncpoint1code", "syncpoint2code", "syncpointer_Count", "syncpoint_found", "synctype_Count", "syncpoint_Count"], "syncpoints": ["synPoints", "yncobjects", "flushPoints", "writeobjects", "syncbits", "flushparts", "yncbits", "yncpointers", "scrollobjects", " syncparts", "synbits", "synpointers", " syncdates", "writepoints", "syncparts", " syncbits", "writepointers", "scalepoints", "scaledates", " syncpos", "yncparts", "synparts", "flushpointers", "flushpoints", " syncPoints", " synctypes", "syncPoints", "synobjects", "synjobs", "syncjobs", "yncpoints", "synpoints", "syncdates", "synctypes", " syncjobs", "synclines", "synpos", "yncjobs", "syntypes", "syncobjects", "scrollpoints", "flushdates", "ynctypes", "ynclines", "synlines", "scalepointers", "scalePoints", " syncobjects", "yncPoints", "yncdates", "syndates", "syncpos", "yncpos", "syncpointers", "writelines", "scrolldates"], "has_keyframe": ["has_kframe", "has_linkframes", "has_keyFrame", "has_Keycode", "has_Keyframe", "has_Keyfram", "has_linkFrame", "has_powerfram", "has_powerframes", "has_keyframes", "has_KEYframes", "has_boxframe", "has_KEYFrame", "has_kframes", "has_powerframe", "has_KEYword", "has_keycode", "has_keyword", "has_Keyword", "has_boxframes", "has_linkfram", "has_linkword", "has_keyfram", "has_kcode", "has_linkframe", "has_Keyframes", "has_boxcode", "has_KeyFrame", "has_KEYframe"], "x": ["fx", "xp", "type", "dx", "n", "z", "tx", "xxxx", "xe", "px", "xc", "c", "xf", "p", "xt", "ux", "xa", "rx", "xs", "xes", "e", "xy", "xd", "inx", "bit", "xxx", "mx", "xi", "ex", "ox", "t", "X", " xx", "ix", "wx", "y", "v", "f", "w", "xx"]}}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "func": "static inline void menelaus_rtc_stop(struct menelaus_s *s)\n\n{\n\n    qemu_del_timer(s->rtc.hz);\n\n    s->rtc.next =- qemu_get_clock(rt_clock);\n\n    if (s->rtc.next < 1)\n\n        s->rtc.next = 1;\n\n}\n", "idx": 13667, "substitutes": {"s": ["bs", "h", "fs", "rs", "changes", "sb", "ties", "sl", "ops", "ses", "ies", "S", "os", "tes", "so", "service", "sv", "c", "ps", "ss", "st", "comm", "sys", "r", "set", "es", "m", "ls", "hs", "aws", "ms", "gs", "ats", "js", "sa", "sp", "spec", "services", "g", "sq", "less", "sr", "t", "ares", "ds", "se", "states", "cs", "ts", "is", "stats", "sync", "qs", "su", "ns", "params", "sts"]}}
{"project": "qemu", "commit_id": "8cf07dcbe7691dbe4f47563058659dba6ef66b05", "target": 1, "func": "int drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return -2;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[drives_table_idx].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    case IF_COUNT:\n\n        abort();\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n", "idx": 13672, "substitutes": {"arg": ["event", "ark", "ref", "mer", "ax", "ag", "reg", "ar", "argument", "alias", "admin", "loc", "tag", "ma", "args", "mem", "md", "ang", "pg", "cand", "parse", "agg", "ack", "op", "ay", "g", "job", "og", "ad", "Arg", "param", "ig", "config", "mark", "cmd", "ac", "arp", "doc", "call"], "snapshot": ["apshots", "Snapvol", "apshot", "Snapshots", "Snapshot", "rootshots", "apimage", "snapvol", "Snapimage", "snapimage", "rootvol", "snapshots", "rootimage", "rootshot", "apvol"], "opaque": ["iopoid", "iopacity", "openaque", "openoid", "oppoid", "OPaque", "oppaque", "iopatile", "oppacity", "Opatile", "Opacity", "opoid", "iopaque", "OPatile", "opacity", "opatile", "OPacity", "openacity", "Opaque"], "buf": ["pkg", "map", "orig", "bc", "history", "conv", "pool", "cp", "cb", "r", "args", "read", "pos", "cv", "Buffer", "param", "filename", "base", "ba", "uf", "tmp", "txt", "br", "Buff", "def", "vec", "bus", "img", "tr", "cfg", "code", "rc", "buffer", "env", "cap", "msg", "rw", "cmd", "doc", "folder", "opt", "bytes", "bf", "rb", "src", "arr", "err", "array", "block", "data", "board", "seq", "proc", "var", "queue", "ref", "cur", "desc", "buff", "b", "rev", "box", "db", "iter", "window", "ctx", "row", "bin", "ctr", "attr", "config", "pad", "wb", "obj"], "file": ["device", "queue", "channel", "ile", "page", "files", "connection", "number", "loc", "bus", "list", "family", "File", "storage", "name", "port", "chain", "db", "buffer", "block", "path", "unit", "dir", "line", "limit", "disk", "board", "filename", "vol", "body", "link", "stat", "base", "table", "f", "le", "fat", "user", "command", "area", "io", "folder"], "devname": ["evstring", "devicenames", "devsize", "dirname", "disksize", "diskname", "volname", "volnames", "devicename", "devName", "padnet", "dirpath", "devpath", "dirName", "volsource", "busname", "padname", "devdir", "diskdir", "diskstring", "evnames", "busName", "bussource", "volName", "divstring", "divdir", "divname", "busline", "Devnames", "padName", "devicesize", "devstring", "devnames", "volline", "evsource", " devnames", "evnet", " devName", "dirsize", "devsource", "DevName", "Devname", "evdir", "divName", "volnet", "devicepath", "deviceName", "devnet", "devline", "evname", "diskName", "diskpath", "padnames", "evName", "evline"], "serial": ["device", "version", "phone", "trans", "ion", "util", "number", "usb", "loc", "bus", "speed", "pro", "ser", "binding", "port", "security", "mode", "res", "description", "num", "unknown", "driver", "proc", "comment", "Serial", "label", "sector"], "mediastr": ["mediustart", "mediustrl", "medirastart", "medustr", "medastart", "mediestart", "medastr", "medustart", "mediustar", "medirastar", "medirastrl", "mediastrl", "mediestr", "medastar", "mediastart", "mediestrl", "medastrl", "mediestar", "mediustr", "medustar", "medustrl", "mediastar", "medirastr"], "type": ["kind", "role", "info", "view", "category", " TYPE", "parent", "pe", "ty", "time", "status", "style", "format", "title", "state", "top", "ver", "interface", "Type", "position", "family", "list", "change", "language", " family", "where", "rule", "instance", "ype", "id", "op", "like", "copy", "class", "t", "typ", "test", "types", "by", "option", "command", "policy", "all", "ping", "relation", "TYPE"], "media": ["device", "category", "reader", "Media", "image", "style", "memory", "history", "slave", "util", "video", "browser", "bridge", "picture", "message", "interface", "language", "position", "gallery", "storage", "movie", "multi", "material", "basic", "volume", "mode", "medium", "medi", "module", "description", "communication", "magic", "meta", "camera", "metadata", "pi", "library", "policy", "command", "option", "area"], "bus_id": ["bus_name", "bridge_ids", "bus2ids", " bus_name", " bus_Id", "bus_ids", "unit_mid", "unit_ident", "bus_ident", "bus_index", "busxident", "busxpid", "bus8id", "busxmid", "bridge_Id", "bus2Id", " bus_link", " bus_pid", "bus_pid", "bus8sid", "bus_sid", "bus_Id", "bus_link", " bus_sid", "bus_mid", "unit_name", "busxname", "bus2id", "bus8link", "busxId", "bus2index", " bus_ident", "bus8name", "busxid", "bridge_id", "bridge_index"], "unit_id": [" unit_index", "system_uid", "unit_ident", " unit_type", "system_id", " unit_name", "unit_uid", "unit_ref", " unit_ref", "unit_name", "system_ident", "unit_ids", "unit_type", "unit_index", " unit_ids"], "cyls": ["cillers", " cyl", "tyols", " cygs", "sygs", "syls", "ciols", "iel", "iels", "tyllers", "cyles", "cyols", "syl", "cysels", "tyles", " cyllers", "iegs", " cysels", "cygs", "ciles", " cyles", "iesels", "tyls", "cyl", "cyllers", "sysels", "cils", " cyols"], "heads": ["aunts", "hours", "limits", "HEAD", "sticks", "ads", "mins", "views", "aches", "helps", "links", "relations", "outs", "uploads", "reads", "guards", "blocks", "locks", "offs", "uns", "owners", "tails", "rows", "hops", "sets", "roots", "cks", "olds", "headed", "loads", " Heads", "masters", "head", "tops", "docs", "bots", "headers"], "secs": ["secS", "connectS", "secss", " secls", " secss", "sectls", " secS", "seqls", "connectss", "connectls", "secls", " sects", "connects", "seqts", "sectts", "seqs", "seqss", "sectS", "seqS", "sects"], "translation": ["lations", "version", "direction", "trans", "padding", "history", "conv", "versions", "transfer", "ion", "util", "usage", "lation", "alias", "language", "message", "family", "tr", "binding", "selection", "generation", "Translation", "rating", "formation", "transform", "description", "communication", "rot", "normal", "comment", "utils", "late", "creation", "heading", "lang", "relation", "location", "operation"], "bdrv": ["bldm", "bderf", "bderv", "bdrvs", "bdrm", "bsrv", "blocksrf", "blockdrvs", "bsrm", "bderm", "bdrf", "blockdrf", "blocksrm", "bldv", "blocksrv", "blocksrvs", "bsrf", "bdervs", "bldf", "bsrvs", "bldvs", "blockdrm", "blockdrv"], "drv": ["frv", " drm", "frm", " drvs", "drvs", "frvs", "drp", "frp", "srvs", "srm", "drm", " drp", "srv", "srp"], "machine": ["device", "parent", "image", "memory", "connection", "state", "achine", "mc", "m", "host", "storage", "target", "chain", "domain", "network", "instance", "mob", "volume", "mobile", "mode", " machines", "manager", "mobi", "module", "engine", "disk", "model", "magic", "meta", "handler", "template", "proxy", "vol", "link", "metadata", "master", "command", "Machine", "vm", "owner"], "max_devs": ["max_devts", "max_devicets", "max_devjs", "max_evjs", "max_evS", "max_Devts", "max2evices", "max_navS", "max_evids", "max_Devs", "max_deves", "max_veS", "max_eves", "max_ves", "max2devices", "max_navices", "max_deviceids", "max_devices", "max2devs", "max_devids", "max_DevS", "max_vees", "max_navs", "max_vejs", "max_evices", "max2devS", "max2evs", "max2evS", "max_evs", "max_Devices", "max_evts", "max_devS", "max_Devids"], "index": ["context", "i", "ind", "info", "version", "address", "page", "status", "x", "connection", "error", "number", "connect", "alias", "loc", "interface", "position", "speed", "Index", "key", "action", "pos", "code", "count", "instance", "id", "size", "engine", "access", "offset", "num", "lock", "max", "comment", "order", "axis", "link"], "cache": ["sum", "version", "status", "hash", "aches", "c", "cu", "force", "conf", "check", "capacity", "scan", "ach", "dirty", "timeout", "cover", "code", "seek", "cc", "ache", "count", "rc", "buffer", "volume", "gc", "limit", "offset", "lock", "max", "Cache", "comment", "debug", "acc", "comments", "config", "ac", "option", "table", "sync", "cycle", "co"], "bdrv_flags": ["bdrf__status", "bdrv_status", "bdrf__flags", "bdrv_flag", "bdrv__flags", "bdrv__status", "bdrv__fields", "bdrf_status", "bdrf_fields", "bdrf_flags", "bdrf_flag", "bdrvgfields", "bdrv_fields", "bdrvgflag", "bdrvgstatus", "bdrvgflags", "bdrf__flag", "bdrv__flag", "bdrf__fields"], "onerror": ["errored", "onerrr", "errr", "asterrr", "rerrored", "onerrored", "onerlock", "rerlock", "asterlock", "rerrr", "asterror", "error", "asterrored", "erlock", "rerror"], "drives_table_idx": ["drives_table_midindex", "drives_table_idindex", "drives_table_idz", "drives_table_midxs", "drives_table_indz", "drives_table_idxs", "drives_table_Idindex", "drives_table_Idz", "drives_table_Idxs", "drives_table_indxs", "drives_table_midz", "drives_table_Idx", "drives_table_indindex", "drives_table_midx", "drives_table_indx"], "str": ["nick", "rs", "comp", "opt", "priv", "orig", "status", "bc", "txt", "br", "conv", "out", "cmp", "STR", "cur", "ar", "exec", "ps", "st", "comm", "p", "s", "arr", "err", "r", "list", "def", "ptr", "tr", "dr", "desc", "raw", "cfg", "Str", "name", "wr", "chain", "buffer", "sp", "spec", "ok", "cont", "res", "msg", "fr", "data", "bool", "proc", "enc", "inst", "ctr", "attr", "expr", "vol", "cmd", "text", "v", "var", "obj", "doc"], "params": ["changes", "bars", "tmp", "settings", "ops", "keys", "json", "flags", "versions", "conv", "files", "units", "cmp", "cp", "conf", "ams", "ps", "args", "vs", "options", "name", "blocks", "pos", "names", "ctx", "spec", "vals", "caps", "values", "pins", "cap", "data", "proc", "param", "attr", "actions", "AMS", "config", "types", "par", "v", "headers", "lines"]}}
{"project": "qemu", "commit_id": "217bfb445b54db618a30f3a39170bebd9fd9dbf2", "target": 1, "func": "static void gic_complete_irq(gic_state * s, int cpu, int irq)\n\n{\n\n    int update = 0;\n\n    int cm = 1 << cpu;\n\n    DPRINTF(\"EOI %d\\n\", irq);\n\n    if (s->running_irq[cpu] == 1023)\n\n        return; /* No active IRQ.  */\n\n    if (irq != 1023) {\n\n        /* Mark level triggered interrupts as pending if they are still\n\n           raised.  */\n\n        if (!GIC_TEST_TRIGGER(irq) && GIC_TEST_ENABLED(irq, cm)\n\n                && GIC_TEST_LEVEL(irq, cm) && (GIC_TARGET(irq) & cm) != 0) {\n\n            DPRINTF(\"Set %d pending mask %x\\n\", irq, cm);\n\n            GIC_SET_PENDING(irq, cm);\n\n            update = 1;\n\n        }\n\n    }\n\n    if (irq != s->running_irq[cpu]) {\n\n        /* Complete an IRQ that is not currently running.  */\n\n        int tmp = s->running_irq[cpu];\n\n        while (s->last_active[tmp][cpu] != 1023) {\n\n            if (s->last_active[tmp][cpu] == irq) {\n\n                s->last_active[tmp][cpu] = s->last_active[irq][cpu];\n\n                break;\n\n            }\n\n            tmp = s->last_active[tmp][cpu];\n\n        }\n\n        if (update) {\n\n            gic_update(s);\n\n        }\n\n    } else {\n\n        /* Complete the current running IRQ.  */\n\n        gic_set_running_irq(s, cpu, s->last_active[s->running_irq[cpu]][cpu]);\n\n    }\n\n}\n", "idx": 13706, "substitutes": {"s": ["bs", "details", "h", "fs", "l", "rs", "changes", "n", "sb", "serv", "series", "sl", "ids", "ses", "S", "os", "als", "state", "http", "service", "sv", "ps", "comm", "conf", "eps", "p", "sys", "r", "es", "store", "ssl", "set", "ls", "vs", "hs", "ms", "aws", "gs", "events", "its", "js", "ims", "sts", "spec", "bis", "services", "g", "sq", "sw", "less", "t", "ds", "self", "se", "states", "cs", "ts", "comments", "tests", "is", "stats", "qs", "parts", "ns", "ss"], "cpu": ["device", "computer", "gpu", "server", "cli", "pool", "cat", "cm", "np", "cp", "u", "core", "nice", "mem", "mac", "tp", "CPU", "base", "sync", "chrom", "uu", "vm", "mu", "current", "context", "clock", "cache", "component", "ck", "boot", "pid", "processor", "cu", "cn", "client", "socket", "uid", "ilo", "pai", "buffer", "gc", "line", "nic", "num", "css", "phys", "net", "pc", "page", "thread", "cum", "node", "ruby", "hz", "c", "uci", "currency", "cam", "batch", "linux", "count", "mx", "proc", " CPU", "prof", "pixel", "process", "chip", "pu", "us", "port", "remote", "ctx", "module", "nc", "cycle"], "irq": ["rirq", "irqq", "irquery", "irtql", "virql", " irQ", "hrqq", "nirqq", "iraquest", "rerq", "irtv", "irequest", "fireq", "nirqi", "virq", "virch", "ipq", "iraquery", "ferq", "iorQ", " irqu", "pirq", "warq", "ipqi", "iroch", "iriq", "fireqt", "iraqq", "iriquire", "irce", "irv", "warqq", "virqt", "arQ", "pirlock", "irque", "hrqi", "irve", "ircharge", "ironqt", "iriqi", "irove", "virce", "virquire", "pirqueue", "iroquery", "iriqu", "hrqu", "vircharge", "fireqi", "ireQ", "mirq", "irave", "ironqi", "iorqq", "irtcharge", "pirqi", "virve", "pirv", "irique", "ferqi", "pirque", "ipqu", "ipqq", "ironreq", "irqueue", "iraqu", "irece", "iriqueue", "irch", "irqu", "iraqi", " irquest", "irreq", "ferquire", "irtq", "warqu", "irlock", "virv", "irace", "iorqu", "warv", "iraque", "pirce", "rirce", "irqt", "pirch", "nirq", "arqq", "mirQ", "ireq", "virqueue", "rerce", "arq", "irqi", "virquery", "pirquest", "irql", "mirce", "pirqu", "arqu", "iorq", " irqq", "irilock", "irtqq", "virqi", "nirce", "iraq", " irce", "irtqu", "rerqq", "firereq", "ironq", " irch", "rircharge", "hrq", "irtce", "pirqq", "iriv", "irav", "irach", "irireq", "virreq", "mirquest", "irquire", "virlock", "rirql", "iroq", "rerqi", "irquest", "irQ", "ferreq"]}}
{"project": "FFmpeg", "commit_id": "ca32f7f2083f9ededd1d9964ed065e0ad07a01e0", "target": 0, "func": "static void init_dequant8_coeff_table(H264Context *h){\n\n    int i,q,x;\n\n    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly\n\n    h->dequant8_coeff[0] = h->dequant8_buffer[0];\n\n    h->dequant8_coeff[1] = h->dequant8_buffer[1];\n\n\n\n    for(i=0; i<2; i++ ){\n\n        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){\n\n            h->dequant8_coeff[1] = h->dequant8_buffer[0];\n\n            break;\n\n        }\n\n\n\n        for(q=0; q<52; q++){\n\n            int shift = div6[q];\n\n            int idx = rem6[q];\n\n            for(x=0; x<64; x++)\n\n                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =\n\n                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *\n\n                    h->pps.scaling_matrix8[i][x]) << shift;\n\n        }\n\n    }\n\n}\n", "idx": 13712, "substitutes": {"h": ["ch", "cache", "info", "l", "hd", "th", "memory", "history", "here", "ha", "hash", "http", "c", "hw", "bh", "dh", "comm", "H", "p", "hi", "m", "host", "hr", "dr", "handle", "hs", "kh", "b", "ah", "ho", "dev", "hz", "hl", "he", "eh", "w", "env", "ih", "rh", "g", "sh", "hp", "help", "php", "sw", "el", "t", "tm", "oh", "HH", "qu", "hm", "v", "f", "ph", "rec", "hh", "ht"], "i": ["qi", "o", "ind", "info", "l", "ai", "ii", "gi", "k", "z", "di", "sim", "out", "ij", "ip", "init", "c", "u", "ti", "li", "hi", "I", "p", "this", "ei", "ib", "si", "m", "ri", "asi", "ia", "im", "multi", "in", "b", "ami", "index", "iu", "id", "it", "at", "j", "ci", "xi", "ic", "ki", "phi", "zi", "ix", "mi", "is", "a", "pi", "y", "v", "bi", "ini", "ui", "f", "iat", "io"], "q": ["qi", "pkg", "iq", "queue", "ch", "requ", "charge", "req", "k", "ck", "ql", "Q", "out", "ip", "aq", "c", "u", "cu", "p", "m", "qa", "qual", "qq", "eq", "kh", "e", "quit", "id", "g", "it", "um", "at", "j", "sq", "quant", "qv", "dq", "el", "quick", "quest", "ix", "gr", "pt", "question", "qu", "ue", "wx", "pp", "v", "le", "f", "qs", "que", "y", "qt", "query"], "x": ["fx", "ey", "ch", "xp", "ax", "dx", "nz", "k", "z", "tx", "xxxxxxxx", "lat", "xe", "xxxx", "px", "c", "xc", "u", "ext", "xf", "pl", "xt", "p", "change", "check", "xml", "ux", "xa", "rx", "dr", "any", "key", "bo", "xs", "xes", "e", "xy", "ctx", "xd", "g", "at", "j", "xxx", "php", "mx", "xi", "ex", "el", "ox", "step", "t", "lex", "X", "ix", " xx", "pt", "wx", "ick", "qu", "y", "v", "yx", "w", "xx", "zx", "on"]}}
{"project": "qemu", "commit_id": "9e0ff75e5158c7dbb65ee447382bbdf4cafbef8b", "target": 1, "func": "char *vnc_display_local_addr(const char *id)\n\n{\n\n    VncDisplay *vs = vnc_display_find(id);\n\n\n\n\n    return vnc_socket_local_addr(\"%s:%s\", vs->lsock);\n\n}", "idx": 13726, "substitutes": {"id": ["i", "h", "d", "info", "ref", "type", "end", "n", "ids", "k", "ident", "init", "pid", "addr", "c", "ID", "s", "tag", "oid", "def", "uid", "vid", "name", "aid", "iden", "b", "db", "no", "mid", "url", "ad", "wid", "rid", "Id", "kid", "link", "f"], "vs": ["bs", "fs", "ks", "ves", "px", "sv", "ps", "ours", " VS", "vl", "ls", "fits", "hs", "ms", "gs", "lights", "VS", "vt", "ims", "sts", "Vs", "vals", "vis", "values", "uds", "ils", "ts", "cs", "vers", "plays", "ins", "qs", "vd", "vm", "obs", "ns", "lists", "ss"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(set_T0)\n\n{\n\n    T0 = PARAM(1);\n\n    RETURN();\n\n}\n", "idx": 13728, "substitutes": {}}
{"project": "qemu", "commit_id": "68ab47e4b4ecc1c4649362b8cc1e49794d1a6537", "target": 1, "func": "static void test_validate_fail_struct_nested(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', 'dict1': { 'string1': 'string1', 'dict2': { 'userdef1': { 'integer': 42, 'string': 'string', 'extra': [42, 23, {'foo':'bar'}] }, 'string2': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefTwo(udp);\n\n}\n", "idx": 13734, "substitutes": {"data": ["context", "device", "rel", "d", "info", "reader", "map", "join", "Data", "ops", "json", "DATA", "format", "error", "input", "result", "ata", "rew", "mu", "def", "bus", "zero", "batch", "empty", "raw", "mem", "in", "window", "initial", "block", "spec", "missing", "step", "t", "text", "table", "base", "form", "dat", "da", "accept"], "unused": [" unchecked", "unuse", "unavailable", " unuse", "untuse", "UNchecked", "UNavailable", " unavailable", "untavailable", "untchecked", "UNuse", "unchecked", "UNused", "untused"], "udp": ["ubper", "udpi", "vdper", "vdp", "rodp", "ugp", "svcp", "uidpp", "udpa", "ugper", "dlp", "udpp", "tdp", "dlcp", "tdpa", "ugps", "vdP", "ugP", "uidps", "sdps", "ubP", "rodpp", "svp", "ubp", "sdpa", "tdpi", "dlpa", "sdpp", "udps", "svpa", "rodpa", "svpi", "udper", "rodps", "ubps", "uidpa", "uidp", "dlpi", "tdcp", "vdps", "udcp", "udP", "sdp"], "err": ["norm", "req", "Error", "sol", "elt", "priv", "die", "txt", "error", "ulp", "er", "sys", "arr", "r", "urg", "mem", "e", "rr", "iter", "aaa", "der", "exc", "ev", "res", "str", "msg", "fr", "mr", "proc", "coord", "ec", "order", "attr", "fee", "spr", "gr", " terr", "pr", "resp", "inv", "kr", "cr", "errors", "lr", "obj", "eas", "Er", "eor"], "v": ["i", "h", "vc", "l", "ve", "av", "n", "V", "nv", "c", "u", "sv", "q", "ver", "p", "uv", "r", "m", "vs", "vp", "b", "e", "vt", "vi", "cv", "g", "it", "ev", "j", "vis", "iv", "ov", "t", "vv", "vr", "pr", "f", "y", "w", "vm"]}}
{"project": "qemu", "commit_id": "595ab64169be9063d64c3b1aa1c249fbe2662221", "target": 1, "func": "static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    ssize_t len;\n\n\n\n    do {\n\n        len = qemu_recv(s->fd, buf, size, 0);\n\n    } while (len == -1 && socket_error() == EINTR);\n\n\n\n    if (len == -1)\n\n        len = -socket_error();\n\n\n\n    return len;\n\n}\n", "idx": 13736, "substitutes": {"opaque": ["iopoid", "ploid", "ioposer", " Optain", " opaco", "opsaque", "OPaque", "ploser", " opoid", "optain", "oposer", " Opaque", "OPlay", "opstain", "placo", "opslay", "opsque", "opoid", "iopaco", "opque", "OPtain", " Opque", " oposer", "iopaque", "plaque", "opaco", "OPque", "oplay", " Oplay"], "buf": ["uf", "bs", "queue", "bar", "bytes", "bl", "bc", "bf", "br", "rb", "q", "cb", "p", "vec", "batch", "img", "pb", " buffer", "raw", "buff", "mem", "fb", "b", "iter", "buffer", "block", "bb", "cv", "Buffer", "cap", "msg", "data", "seq", "enc", "bp", "pad", "cmd", "ob", "v", "wb", "que", "doc"], "pos": ["type", " position", " def", "off", "os", " old", "position", " os", "start", " clen", "et", " start", "no", " index", " doc", "Pos", "offset", " limit", " count", " ref", " offset", " num", " end", "o", " loc"], "size": ["ize", "sum", "type", "end", "n", "SIZE", "style", "z", "os", "space", "scale", "message", "loc", "set", "si", "start", "name", " length", "count", "no", "iz", "sp", "unit", "spec", "to", "g", "Pos", "offset", "cap", "en", " offset", "t", " sizes", "fee", "since", "Size", "length"], "s": ["bs", "i", "h", "fs", "l", "rs", "n", "S", "sv", "c", "ps", " ss", " ts", "p", "sys", "socket", "ssl", "sam", "ls", "hs", "gs", "b", "js", "sa", "sp", "sts", "j", "sq", "less", "t", "ds", "cs", "ts", "sm", "v", "ns", "ss"], "len": ["ptr", " length", "mem", "hl", "ret", "ann", "offset", "L", "all", "Len", "gl", "del", "vec", " le", "ln", "lon", "limit", "en", " _", "nl", "t", "lib", "resp", "ld", "length", "dl", "ind", "l", "ell", "bytes", "sl", "off", "compl", "li", "pl", "err", "ls", "nt", "count", "gen", "al", "total", " el", "lic", "lf", "seq", "fl", "il", "val", "lan", "lp", "n", "elt", "lt", "z", " l", "p", "list", " bl", "fun", "ler", "el", "ll", "fin", "lit", "v", "le"]}}
{"project": "qemu", "commit_id": "b71706d122838d9656e1a6dae80e22401babdf37", "target": 1, "func": "static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,\n\n                                  size_t *count)\n\n{\n\n    GIOStatus status;\n\n    OVERLAPPED ov = {0};\n\n    BOOL ret;\n\n    DWORD written;\n\n\n\n    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n    ret = WriteFile(c->handle, buf, size, &written, &ov);\n\n    if (!ret) {\n\n        if (GetLastError() == ERROR_IO_PENDING) {\n\n            /* write is pending */\n\n            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);\n\n            if (!ret) {\n\n                if (!GetLastError()) {\n\n                    status = G_IO_STATUS_AGAIN;\n\n                } else {\n\n                    status = G_IO_STATUS_ERROR;\n\n\n            } else {\n\n                /* write is complete */\n\n                status = G_IO_STATUS_NORMAL;\n\n                *count = written;\n\n\n        } else {\n\n            status = G_IO_STATUS_ERROR;\n\n\n    } else {\n\n        /* write returned immediately */\n\n        status = G_IO_STATUS_NORMAL;\n\n        *count = written;\n\n\n\n\n\n\n\n\n    return status;\n", "idx": 13739, "substitutes": {"c": ["h", "vc", "ch", "l", "channel", "con", "n", "k", "bc", "lc", "dc", "etc", "cur", "cm", "cp", "cb", "comm", "conf", "cu", "p", "mc", "r", "cam", "C", "b", "e", "cc", "rc", "com", "ctx", "ce", "g", "cont", "cod", "cf", "ci", "cl", "enc", "ec", "t", "ca", "cs", "fc", "o", "a", "ac", "v", "f", "cd", "w", "can"], "buf": ["uf", "bs", "queue", "ref", "bytes", "tmp", "bc", "txt", "br", "rb", "Buff", "cb", "p", "vec", "batch", "img", "pb", "raw", "buff", "read", "mem", "b", "window", "buffer", "block", "cv", "Buffer", "cap", "msg", "data", "seq", "doc", "cmd", "v", "wb", "text", "w"], "size": ["shape", "ize", "sum", "type", "send", "SIZE", "time", "out", "scale", "set", "empty", "any", "sent", "name", "now", "read", "code", "seek", "len", "ctx", "g", "offset", "cap", "data", "en", " Size", "used", "body", "v", "Size", "needed", "length", "area"], "count": ["event", "ize", "sum", "cache", "ount", "created", "n", "time", "Count", "counter", "state", "ed", "check", "list", "start", "batch", "cast", "now", "read", "flag", "code", "nt", "cc", "buffer", "index", "offset", "num", "amount", "max", "ct", "comment", "found", "t", "order", "write", "config", "cond", "current", "checked", "all", "length", "cycle", "call"], "status": ["success", "atus", "cli", "error", "re", "sequence", "activation", "cat", "enabled", "xml", "message", "check", "r", "read", "close", "g", "use", "description", "report", "expr", "sync", "wait", "details", "sol", "serv", "style", "score", "complete", "group", "title", "set", "tag", "ssl", "name", "flag", "code", "active", "gc", "Status", "res", "msg", "resp", "source", "stat", "ping", "version", "prefix", "condition", "summary", "format", "service", "st", "console", "response", "access", "stay", "uses", "progress", "out", "state", "result", "new", "scale", "s", "list", "STAT", "match", "reason", "spec", "id", "str", "see", "used", "comments", "sort", "v", "stats", "output"], "ret": ["ref", "jp", "RT", "std", "RET", "elt", "success", "null", "pret", "txt", "re", "reg", "Ret", "result", "addr", "enabled", " RET", "def", "true", "arr", "err", "r", " continued", "tr", "valid", "ne", " returned", "flag", "alt", " ov", "entry", "nt", "rev", "vet", "sat", "vt", "plain", "gc", "cont", "url", "res", "j", "back", " captured", "bool", "mt", "try", "gt", "t", "fin", "net", "rets", "get", " Ret", "verified", "resp", "rt", "stat", "print", "v", "virtual", "gov", "stay", " retained", "lit", "got", "reset", "backed"], "written": ["printed", "finished", "writing", "rote", "created", "wrote", " Written", " consumed", "bytes", "n", "called", "added", "out", "successful", "connected", " flushed", "ed", " done", "won", "weight", "wat", " created", "led", "reported", "played", "writ", "seen", "sent", " saved", "read", "generated", "writer", "ritten", "held", " updated", "len", "issued", "done", " copied", "changed", " wrote", "built", "data", "used", "recorded", "write", "itted", "drawn", " writer", "writers", "checked", "Written", "needed", "encrypted", "w", "failed"]}}
{"project": "FFmpeg", "commit_id": "8d0a2180582005e91d9f14ae3dd219a882277c23", "target": 1, "func": "int ff_jni_exception_get_summary(JNIEnv *env, jthrowable exception, char **error, void *log_ctx)\n\n{\n\n    int ret = 0;\n\n\n\n    AVBPrint bp;\n\n\n\n    char *name = NULL;\n\n    char *message = NULL;\n\n\n\n    jclass class_class = NULL;\n\n    jmethodID get_name_id = NULL;\n\n\n\n    jclass exception_class = NULL;\n\n    jmethodID get_message_id = NULL;\n\n\n\n    jstring string;\n\n\n\n    av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC);\n\n\n\n    exception_class = (*env)->GetObjectClass(env, exception);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find Throwable class\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    class_class = (*env)->GetObjectClass(env, exception_class);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find Throwable class's class\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    get_name_id = (*env)->GetMethodID(env, class_class, \"getName\", \"()Ljava/lang/String;\");\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find method Class.getName()\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    string = (*env)->CallObjectMethod(env, exception_class, get_name_id);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Class.getName() threw an exception\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    if (string) {\n\n        name = ff_jni_jstring_to_utf_chars(env, string, log_ctx);\n\n        (*env)->DeleteLocalRef(env, string);\n\n        string = NULL;\n\n    }\n\n\n\n    get_message_id = (*env)->GetMethodID(env, exception_class, \"getMessage\", \"()Ljava/lang/String;\");\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find method java/lang/Throwable.getMessage()\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    string = (*env)->CallObjectMethod(env, exception, get_message_id);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Throwable.getMessage() threw an exception\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    if (string) {\n\n        message = ff_jni_jstring_to_utf_chars(env, string, log_ctx);\n\n        (*env)->DeleteLocalRef(env, string);\n\n        string = NULL;\n\n    }\n\n\n\n    if (name && message) {\n\n        av_bprintf(&bp, \"%s: %s\", name, message);\n\n    } else if (name && !message) {\n\n        av_bprintf(&bp, \"%s occurred\", name);\n\n    } else if (!name && message) {\n\n        av_bprintf(&bp, \"Exception: %s\", message);\n\n    } else {\n\n        av_log(log_ctx, AV_LOG_WARNING, \"Could not retreive exception name and message\\n\");\n\n        av_bprintf(&bp, \"Exception occurred\");\n\n    }\n\n\n\n    ret = av_bprint_finalize(&bp, error);\n\ndone:\n\n\n\n    av_free(name);\n\n    av_free(message);\n\n\n\n    if (class_class) {\n\n        (*env)->DeleteLocalRef(env, class_class);\n\n    }\n\n\n\n    if (exception_class) {\n\n        (*env)->DeleteLocalRef(env, exception_class);\n\n    }\n\n\n\n    if (string) {\n\n        (*env)->DeleteLocalRef(env, string);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 13740, "substitutes": {"env": ["pkg", "timer", "esm", "outer", "export", "server", "loader", "nv", "addr", "cb", "eng", "org", "et", "iev", "hl", "cv", "wt", "sw", "den", "ef", "esc", "expr", "vert", "inv", "vm", "event", "context", "worker", "usr", "kw", "end", "serv", "dt", "esp", "here", "draw", "er", "enter", "forge", "def", "vp", "cfg", "erd", "eh", "era", "ten", "cap", "en", "conn", "net", "cmd", "doc", "req", "ve", "app", "nw", "qt", "exec", "walker", "uv", "vs", "viron", "ent", "eg", "ev", "ew", "stage", "ec", "var", "wd", "ework", "priv", "cur", "hw", "environment", "impl", "desc", "e", "dev", "window", "db", "iter", "box", "ctx", "exc", "manager", "erb", "nav", "act", "ov", "ect", "gear", "inst", "ped", "assert", "attr", "vv", "self", "config", "v", "gov", "obj", "ener"], "exception": ["interception", "sexception", "expection", "sexceptions", "exppection", "exceptceptions", "exceptception", "exceptions", "excceptions", "failpection", "sexpection", "exException", "exceptor", "expaction", "exaction", "sexException", "excception", "failaction", "failception", "interaction", "interceptor", "excException", "expception", "failceptor", "excpection", "expceptor", "exceptpection", "interpection", "exceptException"], "error": ["event", "warning", "ror", "channel", "type", "Error", "address", "success", "value", "result", "resource", "change", "err", "action", "e", "ception", "reason", "instance", "attribute", "comment", "order", "ERROR", "errors", "command"], "log_ctx": ["log_tz", "log_cmp", "read_pkg", "web_context", "logmycas", "readgerdesc", "log_conn", "read_desc", "loggercontext", "loglogctx", "logmmctx", "log2context", "log_kt", "log_tx", " log2context", "webablectx", "logmyctx", "read_ctx", "read_cmp", "base_cp", "cat_ctx", "webablepop", "cat_hw", "logptctx", "log_cas", "readgerpkg", "baseptcp", "catmmkt", "cat_pkg", "logablepop", "logmmhw", " log_kt", "logptcp", "log_pop", "web_ctx", "loggerconn", "log_desc", "log2kt", "loggerdesc", "log_cp", "baseptctx", "loglogcontext", " log_context", "log_pkg", "log_lvl", "readgerctx", "log_hw", "logptcas", "logablectx", "readgercmp", "webableconn", "log2ctx", "loglogkt", "logmycp", "logablecontext", "loggerpkg", "catmmctx", "web_conn", "logableconn", "base_tz", "cat_kt", " log2tx", "log_context", "loggerctx", "logloglvl", "base_cas", "web_pop", "catmmhw", "logmytz", "loggercmp", "logmmkt", "loggerpop", "log2tx", "logmmpkg", " log_lvl", "loglogtx", " log2kt", " log2ctx", "logpttz", "catmmpkg", "basepttz", "baseptcas", "base_ctx", " log_tx", "webablecontext"], "bp": ["bs", " eb", "fp", "jp", "lp", " BP", "sb", "pc", "bt", "bf", "bj", "rb", "pa", " esp", "BP", "np", "bh", "bn", "cb", "p", "wp", "pb", "gp", " ap", "vp", "b", "wr", "tp", " lb", "bb", "sp", "PB", " hp", "bps", " outp", "bsp", "bg", " gp", "ba"], "name": ["prefix", "version", "type", "n", "Name", "format", "title", "local", "NAME", "alias", "key", "action", "code", "names", "len", "path", "object", "id", "str", "description", "data", "comment", "String", "class", "filename", "file", "part", "ame", "text", "base", "var"], "message": ["context", "version", "summary", "memory", "content", "value", "sequence", "essage", "Message", "console", "trace", "reason", "reference", "member", "object", "module", "description", "msg", "comment", "class", "filename", "file", "body", "text", "command"]}}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void vscsi_command_complete(SCSIBus *bus, int reason, uint32_t tag,\n\n                                   uint32_t arg)\n\n{\n\n    VSCSIState *s = DO_UPCAST(VSCSIState, vdev.qdev, bus->qbus.parent);\n\n    vscsi_req *req = vscsi_find_req(s, tag);\n\n    SCSIDevice *sdev;\n\n    uint8_t *buf;\n\n    int32_t res_in = 0, res_out = 0;\n\n    int len, rc = 0;\n\n\n\n    dprintf(\"VSCSI: SCSI cmd complete, r=0x%x tag=0x%x arg=0x%x, req=%p\\n\",\n\n            reason, tag, arg, req);\n\n    if (req == NULL) {\n\n        fprintf(stderr, \"VSCSI: Can't find request for tag 0x%x\\n\", tag);\n\n        return;\n\n    }\n\n    sdev = req->sdev;\n\n\n\n    if (req->sensing) {\n\n        if (reason == SCSI_REASON_DONE) {\n\n            dprintf(\"VSCSI: Sense done !\\n\");\n\n            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n            vscsi_put_req(s, req);\n\n        } else {\n\n            uint8_t *buf = sdev->info->get_buf(sdev, tag);\n\n\n\n            len = MIN(arg, SCSI_SENSE_BUF_SIZE);\n\n            dprintf(\"VSCSI: Sense data, %d bytes:\\n\", len);\n\n            dprintf(\"       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\\n\",\n\n                    buf[0], buf[1], buf[2], buf[3],\n\n                    buf[4], buf[5], buf[6], buf[7]);\n\n            dprintf(\"       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\\n\",\n\n                    buf[8], buf[9], buf[10], buf[11],\n\n                    buf[12], buf[13], buf[14], buf[15]);\n\n            memcpy(req->sense, buf, len);\n\n            req->senselen = len;\n\n            sdev->info->read_data(sdev, req->qtag);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (reason == SCSI_REASON_DONE) {\n\n        dprintf(\"VSCSI: Command complete err=%d\\n\", arg);\n\n        if (arg == 0) {\n\n            /* We handle overflows, not underflows for normal commands,\n\n             * but hopefully nobody cares\n\n             */\n\n            if (req->writing) {\n\n                res_out = req->data_len;\n\n            } else {\n\n                res_in = req->data_len;\n\n            }\n\n            vscsi_send_rsp(s, req, 0, res_in, res_out);\n\n        } else if (arg == CHECK_CONDITION) {\n\n            dprintf(\"VSCSI: Got CHECK_CONDITION, requesting sense...\\n\");\n\n            vscsi_send_request_sense(s, req);\n\n            return;\n\n        } else {\n\n            vscsi_send_rsp(s, req, arg, 0, 0);\n\n        }\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    }\n\n\n\n    /* \"arg\" is how much we have read for reads and how much we want\n\n     * to write for writes (ie, how much is to be DMA'd)\n\n     */\n\n    if (arg) {\n\n        buf = sdev->info->get_buf(sdev, tag);\n\n        rc = vscsi_srp_transfer_data(s, req, req->writing, buf, arg);\n\n    }\n\n    if (rc < 0) {\n\n        fprintf(stderr, \"VSCSI: RDMA error rc=%d!\\n\", rc);\n\n        sdev->info->cancel_io(sdev, req->qtag);\n\n        vscsi_makeup_sense(s, req, HARDWARE_ERROR, 0, 0);\n\n        vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    }\n\n\n\n    /* Start next chunk */\n\n    req->data_len -= rc;\n\n    if (req->writing) {\n\n        sdev->info->write_data(sdev, req->qtag);\n\n    } else {\n\n        sdev->info->read_data(sdev, req->qtag);\n\n    }\n\n}\n", "idx": 13748, "substitutes": {"bus": ["bs", "bur", "serv", "bc", "ck", "out", "os", "state", "boot", "usb", "http", "c", "sys", "socket", "ux", "host", "us", "bo", "b", " BUS", "chain", "box", "dev", "block", "sp", "cus", "back", "ud", "board", "conn", "soc", " Bus", "BS", "phys", "US", "Bus", " buses", "mount", "BUS", "is", "ass"], "reason": ["cause", "context", "kind", "type", "render", "comp", "condition", "status", "summary", "when", "unc", "group", "re", "title", "draw", "state", "frame", "reg", "result", "ASON", "argument", "message", "zero", "ason", "because", "name", "flag", "code", "method", "rev", "none", "no", "note", "request", "ok", "why", "see", "description", "strong", "msg", "comment", "param", "non", "report", "issue", "date", "crit", "mark", "cmd", "asons", "command", "Reason", "term", "doc", "call"], "tag": ["kind", "ref", "type", "prefix", "ag", "task", "word", "error", "TAG", "reg", "cat", "addr", "Tag", "loc", "oid", "message", "tg", "key", "name", "flag", "target", "tick", "ang", "code", "md", "match", "field", "pg", "agg", "agn", "tags", "tar", "id", "op", "unit", "module", "feat", "str", "num", "msg", "conn", "gate", "token", "mt", "comment", "param", "attr", "bug", "test", "debug", "date", "cmd", "stat", "var", "command", "lag", "doc", "label"], "arg": ["event", "nick", "oc", "ref", "end", "comp", "ax", "inc", "ag", "slot", "sec", "reg", "ar", "argument", "ext", "loc", "org", "arr", "err", "args", "add", "urg", "target", "flag", "mem", "ang", "in", "field", "arge", "pg", "count", "ret", "ack", "rc", "op", " larg", "res", "og", "str", "amp", "msg", "num", "Arg", "max", "enc", "proc", "rap", "gt", "param", "pack", "attr", " targ", "vol", "ig", "resp", "cmd", "val", "par", "arp", "lag", "or", "doc", "call"], "s": ["bs", "h", "fs", "d", "l", "rs", "sb", "n", "sl", "z", "os", "S", "session", "state", "space", "sv", "q", "c", "ps", "st", "p", "sys", "es", "socket", "r", "m", "ls", "gs", "b", "js", "as", "sp", "sts", "spec", "g", "j", "sq", "sw", "less", "ex", "t", "self", "ds", "cs", "ts", "sc", "is", "v", "stats", "sync", "su", "ns", "ss"], "req": ["pkg", "requ", "need", "cmp", "ps", "r", "urg", "qa", "mem", "eq", "parse", "rr", "dep", "require", "ie", "quest", "expr", "needed", "rem", "txt", "def", "tek", "good", "rc", "rss", "request", "res", "j", "msg", "coord", "resp", "cmd", "query", "ind", "jp", "prefix", "rb", "q", "exec", "comm", "ext", "err", "rez", "decl", "eg", "sq", "range", "supp", "seq", "rig", "dq", "proc", "required", "rec", "var", "aux", "iq", "dist", "ref", "comp", "tx", "task", "reg", "rpm", "conf", "p", "desc", "buff", "qq", "md", "dev", "rev", "ctx", "spec", "grab", "attr", "test", "quick", "crit", "gr", "wx", "obj", "qt"], "sdev": ["sdiv", "nsserv", "sdef", "sgu", "ssdev", "asserv", "rsdev", "wsdiv", "rsserv", "isdev", " sinfo", "sconn", "stsdev", " sgu", "isserv", "nsdef", "asconn", "svdevice", "rspay", "wsinfo", "sserv", "nsdev", "asdev", " sDEV", "stsDEV", "vdev", "tsDev", "vDev", "SDev", "svdev", "aspay", "ssdevice", "sDev", " sserv", "Sserv", " sDev", "spay", "ispay", "tsdev", "ssdef", "tsdef", "vdef", "rsconn", "sdevice", "vdevice", "Sdev", "ssgu", "sinfo", "tsdevice", " sdevice", "isconn", "ssDEV", "wsdev", "sDEV", " sdiv", "Sdef", "wsdevice", " sdef", "nsDev", "svgu", "stsdiv"], "buf": ["bs", "pkg", "map", "bl", "bc", "conv", "pool", "np", "cb", "mem", "fb", "cv", "Buffer", "pack", "grad", "emb", "que", "bg", " vec", "uf", "prop", "tmp", "txt", "br", "Buff", "def", "vec", "zero", "img", "mb", "good", "buffer", "cap", "msg", "cmd", "burst", "doc", "fam", "bytes", "fac", "rb", "off", "begin", "ext", "loc", "foo", "arr", "err", "cam", "batch", "gen", "block", "agg", "data", "seq", "ec", "bed", "deg", "val", "var", "aux", "queue", "ff", "ref", "cur", "nm", "raw", "buff", "b", "box", "iter", "ctx", "fun", "str", "act", "lim", "bin", "func", "pad", "v", "obj", "w"], "len": ["un", "l", "ref", "lp", "n", "elt", "bytes", "la", "lc", "gz", "cmp", " l", " mem", "loc", "vec", "err", " clen", "ls", " le", " bl", " length", "pos", "ln", "mem", "nt", "lon", "fn", "sp", " el", "ret", "fun", "size", "str", "lf", " Len", "coll", "L", "num", "lim", "en", "seq", "el", "fl", "nl", "ll", "fin", "lib", "resp", "ld", "val", "lit", "Len", "length", "lan"]}}
{"project": "qemu", "commit_id": "7d6250e3d1a145e5427f21f5664995e0056b34a6", "target": 0, "func": "void helper_store_sdr1(CPUPPCState *env, target_ulong val)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n\n\n    if (!env->external_htab) {\n\n        if (env->spr[SPR_SDR1] != val) {\n\n            ppc_store_sdr1(env, val);\n\n            tlb_flush(CPU(cpu));\n\n        }\n\n    }\n\n}\n", "idx": 13754, "substitutes": {"env": ["event", "context", "worker", "end", "ve", "serv", "esp", "server", "here", "qt", "node", "txt", "buf", "init", "cur", "nv", "hw", "eng", "conf", "er", "ext", "environment", "enter", "cb", "store", "vs", "et", "desc", "te", "viron", "ah", "e", "dev", "window", "db", "entry", "vt", "ctx", "sp", "cv", "eg", "erd", "ev", "ew", "engine", "sw", "en", "conn", "gear", "enc", "proc", "ec", "doc", "chart", "esc", "el", "vv", "nc", "sc", "cmd", "v", "gov", "emb", "obj", "w", "query"], "val": [" value", " Val", "Val", "ref", "prop", "eval", " VAL", "sol", "pri", "elt", "serv", "V", "status", "pol", "tx", "local", "value", "slot", "buf", "state", "util", "px", "sel", "VAL", " eval", "err", "empty", "key", "valid", "qual", "Value", " vel", "AL", "dev", "xy", "vt", " v", "ctx", " arg", "index", "unit", " aval", "it", "vals", "VALUE", "pal", "num", "hal", "data", "bool", "el", "fail", "test", "vol", "lib", "pt", "resp", "v"], "cpu": ["cal", "clock", "pc", "gpu", "ck", "alloc", "cum", "pool", "px", "pu", "nu", " cp", "processor", "cp", "hw", "cu", "core", "cn", "nice", "pid", "hz", "cam", "bench", "ork", "mem", "tp", "ctx", "gc", " proc", "nic", "CU", "ka", "proc", "CPU", "phys", "prof", "process", "uu", "mu"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size, bool is_write)\n\n{\n\n    return (size == 1) || (is_write && size == 2);\n\n}\n", "idx": 13768, "substitutes": {"opaque": ["oclay", "oph", "och", "openaque", "openc", " oplay", "openh", "occ", "ocaque", "opc", "oplay", "openlay", " oph", " opc"], "addr": ["info", "ref", "address", "alloc", "br", "hash", "src", "dh", "loc", "start", "add", "ptr", "key", "dr", "handle", "name", "ctx", "eth", "index", "kt", "ad", "cap", "coord", "attr", "ld", "var", "obj"], "size": ["shape", "equal", "ize", "sum", "cache", "type", "address", "n", "bytes", "SIZE", "settings", "style", "padding", "slot", "space", "small", "number", "sha", "scale", "weight", "message", "position", "capacity", "zero", "height", "empty", "too", "storage", "name", "dim", "mem", "news", "e", "count", "len", "buffer", "sh", "offset", "num", "grow", "fee", "align", "body", "sized", "Size", "scope", "length", "area"], "is_write": ["is_close", "is_only", " is_read", "is_writer", "is_lock", "is_read", " is_lock", " is_only", " is_writer", " is_close"]}}
{"project": "qemu", "commit_id": "6a81dd172cd5d03fce593741629cb4c78fff10cb", "target": 0, "func": "sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn,\n\n                                   uint64_t bus_offset,\n\n                                   uint32_t page_shift,\n\n                                   uint32_t nb_table,\n\n                                   bool vfio_accel)\n\n{\n\n    sPAPRTCETable *tcet;\n\n    char tmp[64];\n\n\n\n    if (spapr_tce_find_by_liobn(liobn)) {\n\n        fprintf(stderr, \"Attempted to create TCE table with duplicate\"\n\n                \" LIOBN 0x%x\\n\", liobn);\n\n        return NULL;\n\n    }\n\n\n\n    if (!nb_table) {\n\n        return NULL;\n\n    }\n\n\n\n    tcet = SPAPR_TCE_TABLE(object_new(TYPE_SPAPR_TCE_TABLE));\n\n    tcet->liobn = liobn;\n\n    tcet->bus_offset = bus_offset;\n\n    tcet->page_shift = page_shift;\n\n    tcet->nb_table = nb_table;\n\n    tcet->vfio_accel = vfio_accel;\n\n\n\n    snprintf(tmp, sizeof(tmp), \"tce-table-%x\", liobn);\n\n    object_property_add_child(OBJECT(owner), tmp, OBJECT(tcet), NULL);\n\n\n\n    object_property_set_bool(OBJECT(tcet), true, \"realized\", NULL);\n\n\n\n    return tcet;\n\n}\n", "idx": 13772, "substitutes": {"owner": ["own", " ownership", "parent", "component", " owns", "server", "slave", "shared", "peer", "group", "owned", "share", "hw", "root", "er", "org", "uid", "independent", "window", "cc", "holder", "member", "instance", "inner", "size", "lease", "owners", " Owner", "driver", "office", "handler", "username", "older", "link", "Owner", "user", "OWN", "pty"], "liobn": ["liobern", "flubowne", "liombcn", " liorgen", "liobarn", "liobaren", "lioberna", "flubowr", "libowN", "fluobn", "ilirobn", "lirobN", "liorgen", "libowne", "blobyner", "libcn", "liobnt", "liOBon", "lioberrn", "libsn", "liobne", "liobbnt", " liorggn", "liobarcn", "ilirobN", "blobn", "liobyner", "flubown", "bloben", "liobner", "iliobsn", "iliobnum", "liobsne", "libown", "liobernt", "liombsn", "liobbrn", "liobyrn", "lirobon", "blobner", " liobdn", "liobycn", "liobgn", "liobsr", "liobsn", "iliombcn", "iliobdn", "liorgn", "liobsN", "lioyn", "iliobon", "lioben", "fluobN", "lirobn", "liobrn", "luobbnt", " liobgn", "liobcn", "lioconN", "liobercn", "liobbN", "liobben", "liocken", "luobn", "libowr", "iliombsn", "luobnt", "iliobn", "lioberner", "lioconn", "liobr", "luobbna", "lioydn", "liOBnum", "liobbne", "liobyen", "liorgdn", "liockgn", "liobon", "ilirobon", "liobynt", "blobyn", "lioconon", "liobyn", "flubowN", "liobnum", "ilirobnum", "lioycn", "liockn", "luobbn", "liombn", "blobcn", "fluobr", "lioysn", "liOBn", "liobN", "luobbrn", "liobbn", "liobbgn", " liorgn", "iliobN", "luobna", "liobdn", "iliombn", "blobycn", "liobbdn", "liobna", "iliombdn", " liorgdn", "liobarner", "liobyna", "fluobne", "liOBN", "libdn", "libn", "blobyen", "iliobcn", "liombdn", "luobrn", "liobbr", "liorggn", " lioben", "lirobnum", "lioberen", "liockdn", "liobbna", "lioconnum"], "bus_offset": ["boot_prefix", "busipslot", "aseipslot", "bus2shift", "bus2offset", "busityowner", "bus_open", "busllshift", "busityshift", "socket_connection", "bus_connection", "ase_shift", "ase_slot", "busipshift", "boot_offset", "aseipoffset", "busipoffset", "buslloffset", "bus_position", "busityprefix", "ase_offset", "bus_owner", "boot_owner", "socket_open", "bus_slot", "bus___offset", "busllprefix", "ase_off", "bus___connection", "bus___open", "busityoffset", "bus_off", "bus2off", "bus_prefix", "aseipshift", "bus_shift", "boot_shift", "socket_offset", "bus2slot", "bus___position", "socket_position", "busllowner", "aseipoff", "busipoff"], "page_shift": ["page_slice", "pageingshift", "menu_slice", "page_command", "pagelyoffset", "pageswshift", "menu_shift", "page_default", "age_offset", "age_default", "page_size", "pageingsize", "bus_command", "menuinghead", "pageedhead", "pageinghead", "bus_size", "age_dist", "menu_size", "busswcount", "pageedshift", "pageswsize", "pagelydefault", "pageedsize", "page_dist", "pageedslice", "busswsize", "pageswcommand", "menuingshift", "age_shift", "pageingslice", "page_count", "page_head", "pageedcount", "bus_shift", "menuingsize", "page_offset", "pagelydist", "busswcommand", "menuingslice", "busswshift", "pagelyshift", "menu_head", "pageswcount", "bus_count", "pageedcommand"], "nb_table": ["nbableindex", "nb2TABLE", "nbabletable", "nv_required", "np_binary", "nbpttable", "inv___stable", "nt_scope", "nbptpage", "nb___scope", "nb___container", "nb_stable", "nvmyrequired", "nb_binary", "nb2tab", "nv_table", "nv_index", "nb_container", "nbmytable", "nv_page", "nt_table", "inv___total", "nt_server", "nt___table", "nbPserver", "nbablepage", "nb___tab", "nt___server", "nbmyrequired", "inv_table", "nb___stable", "nb_scope", "nbjserver", "nt_container", "nb_tab", "nb___total", "nb_server", "nb_total", "nb2table", "nb_required", "np_tab", "nvmypage", "np_table", "inv_tab", "nbablerequired", "nb2binary", "nvmyindex", "nt___scope", "nbptrequired", "np_TABLE", "inv_stable", "nt___container", "inv___tab", "nbjtable", "nvmytable", "nbmypage", "nb___server", "inv___table", "nb_index", "nbptindex", "nbjcontainer", "nbmyindex", "nb___table", "nbPcontainer", "nbjscope", "nb_TABLE", "inv_total", "nb_page", "nbPscope", "nbPtable"], "vfio_accel": ["vfio_ccel", "vfio_acccel", "vfio_acl", "vfio_cl", "vfio_macceler", "vfio_acsel", "vfio_maccel", "vfio_acccl", "vfio_accceler", "vfio_acel", "vfio_acceler", "vfio_cel", "vfio_cceler", "vfio_accompl", "vfio_acscel", "vfio_facce", "vfio_macce", "vfio_acccompl", "vfio_faccel", "vfio_acsl", "vfio_acscl", "vfio_ccl", "vfio_faccompl", "vfio_acce", "vfio_accce", "vfio_accl", "vfio_acsceler", "vfio_facceler", "vfio_maccompl"], "tcet": ["timemet", "tcets", " tcET", "tocett", "tkate", "TCel", "ecett", "cuee", "mcpet", "cuetter", "cacheee", "ascet", "tcot", "racemet", " tcect", "TChet", " tcel", "ecet", "ascreset", " tcetter", "tcset", "tocreset", " tcett", "ascound", "TCets", "uscbet", "timET", "TCiet", " tcee", "cuet", "currencyett", "mcET", "racreset", "TCdat", "tciet", "uscpet", "tkect", " tcate", "racET", "mcet", "ticdat", "rcet", "cciemet", "tcemet", "tcbet", "TCett", "lcet", "cacheetter", "cacheet", "ascET", "TCound", "tcpet", "ecect", "cacheset", "ascett", "uscel", "tchet", "uscet", "ticett", "TCpet", "tcET", "cciET", "tcel", "lcET", "TCET", "lchet", "mciet", "racet", "TCet", "cciett", "rcET", "timet", "tcound", "tcect", " tcpet", "ticot", " tcset", "tcett", "tket", "currencyound", "timett", "racdat", "TCbet", " tcot", "tkett", "lcets", "tcdat", "tocemet", "tcate", "racett", "TCot", "ascemet", "tcetter", "ecate", "TCemet", "cuset", "cciet", "tcee", " tcbet", " tciet", "rcets", "currencyet", "ticET", "tocet", "ticet", "currencyET", "tcreset", "rchet"], "tmp": ["cache", "ptr", "extra", "bt", "txt", "temp", "rb", "out", "etc", "tab", "buf", "cmp", "space", "np", "src", "local", "new", "cb", "cp", "MP", "zip", "uv", "err", "m", "img", "pb", "sam", "xs", "mb", "empty", "tf", "buff", "vp", "mk", "qq", "nt", "mp", "tp", "buffer", "ctx", "sp", "cv", "aaa", "csv", "html", "cont", "msg", "data", "nb", "t", "attr", "test", "tt", "tm", "snap", "rw", "pad", "resp", "cmd", "v", "perm", "td", "obj", "sample", "params"]}}
{"project": "qemu", "commit_id": "192cf55cc02dc0838bbfa5ac17feb7f6c1651441", "target": 1, "func": "static void debug_print_fis(uint8_t *fis, int cmd_len)\n\n{\n\n#ifdef DEBUG_AHCI\n\n    int i;\n\n\n\n    fprintf(stderr, \"fis:\");\n\n    for (i = 0; i < cmd_len; i++) {\n\n        if ((i & 0xf) == 0) {\n\n            fprintf(stderr, \"\\n%02x:\",i);\n\n        }\n\n        fprintf(stderr, \"%02x \",fis[i]);\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n#endif\n\n}\n", "idx": 13784, "substitutes": {"fis": ["xfIS", "vois", "vIS", " fois", "dfis", "sfIS", "sfIs", "xfis", "fIS", "fIs", "fois", "xfois", "dfisi", "sfis", "xfisi", "vis", "fisi", "vIs", "sfois", "dfIS", "dfIs", " fisi", " fIS", "dfois"], "cmd_len": ["cmd2del", " cmd_den", "cmd_del", " cmd_Len", " cmd_del", " cmd_length", "cmd2len", "cmd_Len", "cmd_den", "cmd_length", "cmd2length"], "i": ["qi", "iq", "ind", "ai", "ii", "ji", "n", "gi", " di", "status", "di", "x", "sim", "cli", "ij", "ip", "init", "number", " bi", "ti", "li", "hi", "\u0438", "I", "ei", " j", "p", "client", "si", "batch", "m", "oi", "ri", "us", "im", "multi", "in", "ami", "ims", "vi", "index", "iu", "to", "id", " ii", "Ti", "it", "j", "g", "num", "ci", "xi", "ic", "ki", "t", " x", "phi", "ogi", "zi", "ix", "mi", "is", "o", "pi", "y", "bi", "ini", "ui", "uri", " ti"]}}
{"project": "FFmpeg", "commit_id": "be00ec832c519427cd92218abac77dafdc1d5487", "target": 0, "func": "static av_cold int svc_encode_init(AVCodecContext *avctx)\n\n{\n\n    SVCContext *s = avctx->priv_data;\n\n    SEncParamExt param = { 0 };\n\n    int err = AVERROR_UNKNOWN;\n\n    int log_level;\n\n    WelsTraceCallback callback_function;\n\n    AVCPBProperties *props;\n\n\n\n    // Mingw GCC < 4.7 on x86_32 uses an incorrect/buggy ABI for the WelsGetCodecVersion\n\n    // function (for functions returning larger structs), thus skip the check in those\n\n    // configurations.\n\n#if !defined(_WIN32) || !defined(__GNUC__) || !ARCH_X86_32 || AV_GCC_VERSION_AT_LEAST(4, 7)\n\n    OpenH264Version libver = WelsGetCodecVersion();\n\n    if (memcmp(&libver, &g_stCodecVersion, sizeof(libver))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Incorrect library version loaded\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n#endif\n\n\n\n    if (WelsCreateSVCEncoder(&s->encoder)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to create encoder\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    // Pass all libopenh264 messages to our callback, to allow ourselves to filter them.\n\n    log_level = WELS_LOG_DETAIL;\n\n    (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_LEVEL, &log_level);\n\n\n\n    // Set the logging callback function to one that uses av_log() (see implementation above).\n\n    callback_function = (WelsTraceCallback) libopenh264_trace_callback;\n\n    (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_CALLBACK, (void *)&callback_function);\n\n\n\n    // Set the AVCodecContext as the libopenh264 callback context so that it can be passed to av_log().\n\n    (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_CALLBACK_CONTEXT, (void *)&avctx);\n\n\n\n    (*s->encoder)->GetDefaultParams(s->encoder, &param);\n\n\n\n    param.fMaxFrameRate              = avctx->time_base.den / avctx->time_base.num;\n\n    param.iPicWidth                  = avctx->width;\n\n    param.iPicHeight                 = avctx->height;\n\n    param.iTargetBitrate             = avctx->bit_rate;\n\n    param.iMaxBitrate                = FFMAX(avctx->rc_max_rate, avctx->bit_rate);\n\n    param.iRCMode                    = RC_QUALITY_MODE;\n\n    param.iTemporalLayerNum          = 1;\n\n    param.iSpatialLayerNum           = 1;\n\n    param.bEnableDenoise             = 0;\n\n    param.bEnableBackgroundDetection = 1;\n\n    param.bEnableAdaptiveQuant       = 1;\n\n    param.bEnableFrameSkip           = s->skip_frames;\n\n    param.bEnableLongTermReference   = 0;\n\n    param.iLtrMarkPeriod             = 30;\n\n    param.uiIntraPeriod              = avctx->gop_size;\n\n#if OPENH264_VER_AT_LEAST(1, 4)\n\n    param.eSpsPpsIdStrategy          = CONSTANT_ID;\n\n#else\n\n    param.bEnableSpsPpsIdAddition    = 0;\n\n#endif\n\n    param.bPrefixNalAddingCtrl       = 0;\n\n    param.iLoopFilterDisableIdc      = !s->loopfilter;\n\n    param.iEntropyCodingModeFlag     = 0;\n\n    param.iMultipleThreadIdc         = avctx->thread_count;\n\n    if (s->profile && !strcmp(s->profile, \"main\"))\n\n        param.iEntropyCodingModeFlag = 1;\n\n    else if (!s->profile && avctx->coder_type == FF_CODER_TYPE_AC)\n\n        param.iEntropyCodingModeFlag = 1;\n\n\n\n    param.sSpatialLayers[0].iVideoWidth         = param.iPicWidth;\n\n    param.sSpatialLayers[0].iVideoHeight        = param.iPicHeight;\n\n    param.sSpatialLayers[0].fFrameRate          = param.fMaxFrameRate;\n\n    param.sSpatialLayers[0].iSpatialBitrate     = param.iTargetBitrate;\n\n    param.sSpatialLayers[0].iMaxSpatialBitrate  = param.iMaxBitrate;\n\n\n\n    if ((avctx->slices > 1) && (s->max_nal_size)){\n\n        av_log(avctx,AV_LOG_ERROR,\"Invalid combination -slices %d and -max_nal_size %d.\\n\",avctx->slices,s->max_nal_size);\n\n        goto fail;\n\n    }\n\n\n\n    if (avctx->slices > 1)\n\n        s->slice_mode = SM_FIXEDSLCNUM_SLICE;\n\n\n\n    if (s->max_nal_size)\n\n        s->slice_mode = SM_DYN_SLICE;\n\n\n\n    param.sSpatialLayers[0].sSliceCfg.uiSliceMode               = s->slice_mode;\n\n    param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceNum = avctx->slices;\n\n\n\n    if (s->slice_mode == SM_DYN_SLICE) {\n\n        if (s->max_nal_size){\n\n            param.uiMaxNalSize = s->max_nal_size;\n\n            param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = s->max_nal_size;\n\n        } else {\n\n            if (avctx->rtp_payload_size) {\n\n                av_log(avctx,AV_LOG_DEBUG,\"Using RTP Payload size for uiMaxNalSize\");\n\n                param.uiMaxNalSize = avctx->rtp_payload_size;\n\n                param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = avctx->rtp_payload_size;\n\n            } else {\n\n                av_log(avctx,AV_LOG_ERROR,\"Invalid -max_nal_size, specify a valid max_nal_size to use -slice_mode dyn\\n\");\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((*s->encoder)->InitializeExt(s->encoder, &param) != cmResultSuccess) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Initialize failed\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {\n\n        SFrameBSInfo fbi = { 0 };\n\n        int i, size = 0;\n\n        (*s->encoder)->EncodeParameterSets(s->encoder, &fbi);\n\n        for (i = 0; i < fbi.sLayerInfo[0].iNalCount; i++)\n\n            size += fbi.sLayerInfo[0].pNalLengthInByte[i];\n\n        avctx->extradata = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!avctx->extradata) {\n\n            err = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        avctx->extradata_size = size;\n\n        memcpy(avctx->extradata, fbi.sLayerInfo[0].pBsBuf, size);\n\n    }\n\n\n\n    props = ff_add_cpb_side_data(avctx);\n\n    if (!props) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    props->max_bitrate = param.iMaxBitrate;\n\n    props->avg_bitrate = param.iTargetBitrate;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    svc_encode_close(avctx);\n\n    return err;\n\n}\n", "idx": 13809, "substitutes": {"avctx": [" avjac", "avercontext", "ajcu", "AVobj", "avercp", "averpy", " avcmp", "abcontext", "averconn", "avercpu", "avtx", "ajconn", "navcp", "avdt", "avcpu", " avcontext", "avecp", "navkl", "auctx", " avtmp", "varsys", "averkb", "avtc", "avtmp", "ajctx", "avertmp", "abconf", "invcu", "avecu", "averkl", "avermsg", "avcmd", "avernp", "ajdt", "averctl", "abobj", " avmsg", " avtc", "averctx", "navctx", "avejac", "avectx", " avkb", "avekl", "varcpu", "varnp", "avsys", "aveconf", "avjac", "navcmd", "ajobj", "avobj", "avesys", "avcu", "varcu", "avercu", "AVcontext", "auctl", "ajtc", "AVctx", "avenp", "avcontext", "avercmd", "avmsg", "avecontext", "abctx", " avpy", "invjac", "aveobj", "varreq", "avedt", "avkb", "averreq", "varobj", "avnp", "ajcontext", "avcmp", "averjac", "avpy", "avcp", "averobj", "ajcpu", "avercmp", "AVpy", "avetc", "avkl", "svkb", "ajmsg", "invcontext", " avcu", "averdt", "aujac", "avctl", " avtx", "svctx", "avertx", "avectl", "avecmd", "avconf", "invctx", "ajreq", "avconn", "ajtmp", "aveconn", "svcontext", "aversys", "ajsys", " avsys", "AVconf", "aucu", "varctx", "svtx", "avreq", "AVcmp"], "s": ["bs", "h", "fs", "l", "rs", "sb", "n", "ses", "ies", "S", "os", "als", "ar", "c", "sv", "pers", "ps", "comm", "p", "sys", "set", "es", "m", "sam", "ls", "sports", "vs", "hs", "aws", "ms", "gs", "b", "ats", "its", "js", "as", "ctx", "sts", "w", "spec", "g", "sq", "sw", "less", "t", "ds", "self", "cs", "ts", "sc", "is", "a", "v", "y", "f", "qs", "ns", "ss"], "log_level": ["log___mode", "log_mode", "loginglevel", "tool_message", " log_function", "tool_function", "log_local", "LOG_local", "loginglocal", "LOG_operator", "log___level", "LOG_vel", "logingoperator", " log_mode", "log_message", "log_function", "logingvel", "log___type", "logLoperator", "log_vel", "log_operator", "log_type", "logLvel", "tool_level", "logLlevel", "tool_vel", " log_type", "log___function", "LOG_level", "logLlocal"], "callback_function": ["filter_address", "callback_address", "back_closure", "callbacklyfactor", "callback_func", "filter_func", "callback_column", "callbackzfunction", "callbacklyfunc", "callbackzfunc", "callbacklyfunction", "back_function", "callbacklycolumn", "callbackzcolumn", "callback_Function", "callbacklyaddress", "filter_functional", "callback_functional", "back_Function", " callback_func", " callback_factor", "callback_factor", " callback_column", "callbackzfactor", "callbacklyfunctional", "callback_closure", "filter_function"], "props": ["Properties", "procs", "prgs", "parcs", "properties", "parperties", "Props", "prperties", "Procs", "parps", "progs", "Progs", "prcs", "prps", "pargs"]}}
{"project": "qemu", "commit_id": "6a2a5aae02b9a0b53807b9ad91f15cd4988781f9", "target": 0, "func": "static void sm501_disp_ctrl_write(void *opaque, hwaddr addr,\n\n                                  uint64_t value, unsigned size)\n\n{\n\n    SM501State *s = (SM501State *)opaque;\n\n    SM501_DPRINTF(\"sm501 disp ctrl regs : write addr=%x, val=%x\\n\",\n\n                  (unsigned)addr, (unsigned)value);\n\n\n\n    switch (addr) {\n\n    case SM501_DC_PANEL_CONTROL:\n\n        s->dc_panel_control = value & 0x0FFF73FF;\n\n        break;\n\n    case SM501_DC_PANEL_PANNING_CONTROL:\n\n        s->dc_panel_panning_control = value & 0xFF3FFF3F;\n\n        break;\n\n    case SM501_DC_PANEL_FB_ADDR:\n\n        s->dc_panel_fb_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_PANEL_FB_OFFSET:\n\n        s->dc_panel_fb_offset = value & 0x3FF03FF0;\n\n        break;\n\n    case SM501_DC_PANEL_FB_WIDTH:\n\n        s->dc_panel_fb_width = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_FB_HEIGHT:\n\n        s->dc_panel_fb_height = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_TL_LOC:\n\n        s->dc_panel_tl_location = value & 0x07FF07FF;\n\n        break;\n\n    case SM501_DC_PANEL_BR_LOC:\n\n        s->dc_panel_br_location = value & 0x07FF07FF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_H_TOT:\n\n        s->dc_panel_h_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_H_SYNC:\n\n        s->dc_panel_h_sync = value & 0x00FF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_V_TOT:\n\n        s->dc_panel_v_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_V_SYNC:\n\n        s->dc_panel_v_sync = value & 0x003F0FFF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_HWC_ADDR:\n\n        s->dc_panel_hwc_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_LOC:\n\n        s->dc_panel_hwc_location = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_COLOR_1_2:\n\n        s->dc_panel_hwc_color_1_2 = value;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_COLOR_3:\n\n        s->dc_panel_hwc_color_3 = value & 0x0000FFFF;\n\n        break;\n\n\n\n    case SM501_DC_CRT_CONTROL:\n\n        s->dc_crt_control = value & 0x0003FFFF;\n\n        break;\n\n    case SM501_DC_CRT_FB_ADDR:\n\n        s->dc_crt_fb_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_CRT_FB_OFFSET:\n\n        s->dc_crt_fb_offset = value & 0x3FF03FF0;\n\n        break;\n\n    case SM501_DC_CRT_H_TOT:\n\n        s->dc_crt_h_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_H_SYNC:\n\n        s->dc_crt_h_sync = value & 0x00FF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_V_TOT:\n\n        s->dc_crt_v_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_V_SYNC:\n\n        s->dc_crt_v_sync = value & 0x003F0FFF;\n\n        break;\n\n\n\n    case SM501_DC_CRT_HWC_ADDR:\n\n        s->dc_crt_hwc_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_CRT_HWC_LOC:\n\n        s->dc_crt_hwc_location = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_HWC_COLOR_1_2:\n\n        s->dc_crt_hwc_color_1_2 = value;\n\n        break;\n\n    case SM501_DC_CRT_HWC_COLOR_3:\n\n        s->dc_crt_hwc_color_3 = value & 0x0000FFFF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_PALETTE ... SM501_DC_PANEL_PALETTE + 0x400 * 3 - 4:\n\n        sm501_palette_write(opaque, addr - SM501_DC_PANEL_PALETTE, value);\n\n        break;\n\n\n\n    default:\n\n        printf(\"sm501 disp ctrl : not implemented register write.\"\n\n               \" addr=%x, val=%x\\n\", (int)addr, (unsigned)value);\n\n        abort();\n\n    }\n\n}\n", "idx": 13829, "substitutes": {"opaque": ["operacity", "operaques", "opsaque", "opsonymous", "operonymous", "opsaques", " opaques", "ioposit", "iopque", "iopient", "Opient", "operaque", "opque", "oponymous", "iopaque", " opient", "opacity", "opsacity", " opacity", " opque", "opaques", " oposit", " oponymous", "Opque", "Oposit", "opient", "Opaque", "oposit"], "addr": ["bind", "info", "ref", "rs", "prefix", "address", "asm", "Address", "ident", "alloc", "hash", "ip", "init", "cmp", "hop", "src", "hw", "adr", "alias", "r", "err", "host", "ptr", "add", "handle", "name", "pos", "mem", "mac", "att", "dev", "seek", "field", "rc", "ctx", "eth", "ack", "index", "id", "url", "act", "ad", "offset", " address", "coord", "attr", "work", "align", "ix", "link", "pad", "inv", "cmd", "var", "obj"], "value": ["select", "image", "status", "content", "padding", "memory", "server", "sequence", "weight", "create", "message", "Value", "element", "unit", "done", "description", "feature", "function", "all", "option", "example", "current", " Value", "info", "package", "hello", "word", "number", "set", "operator", "vp", "name", "code", "expression", "buffer", "vector", "comment", "fee", "get", "length", "type", "format", "byte", "key", "trace", "field", "reference", "block", "total", "index", "values", "VALUE", "variable", "range", "data", "val", "python", "address", "json", "go", "state", "input", "new", "property", "list", "raw", "now", "attribute", "see", "test", "widget", "ue", "v", "label"], "size": ["ize", "sum", " len", "type", "address", " si", "SIZE", "password", "state", "weight", "set", "action", "name", "mem", "code", "field", "count", "len", "cap", "data", " count", "fee", "Size", " sock", "length"], "s": ["bs", "details", "fs", "rs", "sn", "changes", "sol", "sb", "n", "sl", "status", "ses", "ies", "S", "os", "ips", "service", "sv", "pers", "ps", "comm", "p", "sys", "es", "set", "ssl", "m", "ls", "vs", "sports", "hs", "aws", "ms", "gs", "ats", "ports", "js", "ims", "sp", "sts", "spec", "bis", "services", "j", "sq", "t", "ds", "properties", "states", "cs", "ts", "is", "sm", "y", "stats", "ins", "sis", "qs", "obj", "ns", "ss"]}}
{"project": "FFmpeg", "commit_id": "9b2c28e6edbb43e00e0b2d99b95567189cd46e91", "target": 0, "func": "void rgb15to16(const uint8_t *src,uint8_t *dst,uint32_t src_size)\n\n{\n\n#ifdef HAVE_MMX\n\n  register const char* s=src+src_size;\n\n  register char* d=dst+src_size;\n\n  register int offs=-src_size;\n\n  __asm __volatile(PREFETCH\"\t%0\"::\"m\"(*(s+offs)):\"memory\");\n\n  __asm __volatile(\n\n\t\"movq\t%0, %%mm4\\n\\t\"\n\n\t\"movq\t%1, %%mm5\"\n\n\t::\"m\"(mask15b), \"m\"(mask15rg):\"memory\");\n\n  while(offs<0)\n\n  {\n\n\t__asm __volatile(\n\n\t\tPREFETCH\"\t32%1\\n\\t\"\n\n\t\t\"movq\t%1, %%mm0\\n\\t\"\n\n\t\t\"movq\t8%1, %%mm2\\n\\t\"\n\n\t\t\"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t\t\"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t\t\"pand\t%%mm4, %%mm0\\n\\t\"\n\n\t\t\"pand\t%%mm5, %%mm1\\n\\t\"\n\n\t\t\"pand\t%%mm4, %%mm2\\n\\t\"\n\n\t\t\"pand\t%%mm5, %%mm3\\n\\t\"\n\n\t\t\"psllq\t$1, %%mm1\\n\\t\"\n\n\t\t\"psllq\t$1, %%mm3\\n\\t\"\n\n\t\t\"por\t%%mm1, %%mm0\\n\\t\"\n\n\t\t\"por\t%%mm3, %%mm2\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 8%0\"\n\n\t\t:\"=m\"(*(d+offs))\n\n\t\t:\"m\"(*(s+offs))\n\n\t\t:\"memory\");\n\n\toffs+=16;\n\n  }\n\n  __asm __volatile(SFENCE:::\"memory\");\n\n  __asm __volatile(EMMS:::\"memory\");\n\n#else\n\n   const uint16_t *s1=( uint16_t * )src;\n\n   uint16_t *d1=( uint16_t * )dst;\n\n   uint16_t *e=((uint8_t *)s1)+src_size;\n\n   while( s1<e ){\n\n     register int x=*( s1++ );\n\n     /* rrrrrggggggbbbbb\n\n        0rrrrrgggggbbbbb\n\n        0111 1111 1110 0000=0x7FE0\n\n        00000000000001 1111=0x001F */\n\n     *( d1++ )=( x&0x001F )|( ( x&0x7FE0 )<<1 );\n\n   }\n\n#endif\n\n}\n", "idx": 13855, "substitutes": {"src": ["bs", "usr", "rs", "sn", "std", "sb", "ur", "txt", "rb", "input", "dest", "st", "sel", "sub", "loc", "sys", "r", "scan", "img", "ptr", "ls", "syn", "ser", "gs", "usc", "b", "rob", "sur", "rc", "hl", "rl", "iv", "bin", "sr", "inst", "sc", "config", "source", "ins", "ipl", "sts"], "dst": ["edend", "ssts", "Dend", " dnd", "adtd", "dsts", " dtd", "adst", "sdest", "lest", "lst", "ldest", "ednd", "Dest", "lsts", "dest", "snd", "adnd", "edst", "sst", "Dst", " ddest", "ltd", "ddest", " dsts", "lnd", "lend", "Dnd", "edest", "dend", "dnd", "addest", "dtd"], "src_size": ["src_Size", "src_num", "srcptSize", "rc_SIZE", "srcptsize", "source_time", "rc_size", " src_len", " src_SIZE", "source_Size", "src_mode", "src_time", "source_SIZE", "src_SIZE", "srcptSIZE", "source_num", "src_len", "source_name", "rc_mode", "source_size", "src_name", "rc_Size", "srcptmode"], "s": ["bs", "i", "rs", "sb", "n", "sl", "S", "os", "sv", "c", "st", "ps", "p", "es", "si", "r", "ls", "gs", "b", "js", "sp", "sts", "g", "sh", "j", "sq", "sw", "sr", "t", "ds", "cs", "ts", "sc", "sm", "f", "ins", "su", "ss"], "d": ["dn", "h", "l", "dm", "n", "dt", "z", "di", "dc", "out", "c", "q", "st", "dra", "bd", "p", "r", "dr", "b", "db", "des", "dd", "fd", "de", "g", "D", "id", "j", "ad", "data", "dq", "t", "ds", "o", "v", "f", "w", "da"], "m": ["h", "i", "l", "dm", "n", "asm", "gm", "value", "cm", "M", "c", "p", "mc", "r", "mem", "b", "field", "g", "module", "mt", "mm", "t", "tm", "mi", "o", "a", "sm", "v", "f", "y", "perm", "length", "w", "vm", "mask"], "memory": ["context", "clock", "phrase", "cache", "ref", "type", "address", "image", "time", "history", "sequence", "value", "session", "cm", "number", "resource", "information", "media", "maximum", "integer", "message", "zero", "height", "storage", "statement", "frequency", "mem", "window", "field", "reference", "buffer", "attribute", "pointer", "gc", "medium", "size", "module", "me", "variable", "record", "description", "data", "mx", "model", "template", "Memory", "metadata", "library", "length", "sample"], "s1": ["d01", "sOnce", "js91", "sone", "S0", "s81", " s01", "cs1", "x01", "dsOnce", "js1", "ds1", "Sone", "cs0", "sv1", "s2", "s0", "jsOnce", "ds01", "sv0", "ss0", " s0", "ss1", "rs0", " s81", "ss81", "svone", "js01", "ds91", " s4", "cs81", " s2", "ss4", "S2", "s01", "rs1", "d0", "rs2", "s4", "rs01", "s91", "xOnce", " sone", "d2", "cs4", "S1", "x1", "sv2", "x91"], "d1": ["DOne", "D001", " dOne", "sOne", "D1", "dOne", "ds1", "dt001", "ds001", "s0", " d0", "D0", "dt3", "D3", "ds3", "ds0", "dt1", "d0", "d3", "d001", "dt0"], "e": ["eu", "h", "i", "E", "l", "ge", "end", "n", "elt", "pe", "x", "oe", "c", "ed", "er", "p", "r", "es", "et", "te", "ne", "ent", "b", "eb", "ele", "eeee", "eg", "g", "ev", "en", "el", "ec", "t", "ep", "se", "o", "ue", "ae", "east", "f", "ee"]}}
{"project": "FFmpeg", "commit_id": "4749e074987d45cb98935a683a7ee8e1ee376d86", "target": 1, "func": "static int rle_unpack(const unsigned char *src, unsigned char *dest,\n\n    int src_len, int dest_len)\n\n{\n\n    const unsigned char *ps;\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n\n\n    ps = src;\n\n    pd = dest;\n\n    if (src_len & 1)\n\n        *pd++ = *ps++;\n\n\n\n    src_len >>= 1;\n\n    i = 0;\n\n    do {\n\n        l = *ps++;\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (pd + l > dest_end)\n\n                return ps - src;\n\n            memcpy(pd, ps, l);\n\n            ps += l;\n\n            pd += l;\n\n        } else {\n\n            if (pd + i > dest_end)\n\n                return ps - src;\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = ps[0];\n\n                *pd++ = ps[1];\n\n            }\n\n            ps += 2;\n\n        }\n\n        i += l;\n\n    } while (i < src_len);\n\n\n\n    return ps - src;\n\n}\n", "idx": 13859, "substitutes": {"src": ["bs", "sing", "rel", "dist", "usr", "ind", "rs", "sn", "comp", "std", "sb", "tmp", "trans", "null", "ur", "txt", "rb", "out", "gz", "init", "cur", "buf", "addr", "st", "loc", "sub", "sys", "s", "this", "start", "img", "ptr", "syn", "origin", "ser", "ssl", "in", "rob", "sur", "rc", "gin", "sh", "str", "rl", "supp", "msg", "sr", "proc", "inst", "copy", "ctr", "pack", "attr", "sc", "source", "rt", "ins", "sync", "stream", "sts"], "dest": ["dist", "usr", "prop", "end", "priv", "orig", "trans", "tmp", "temp", "out", "Dest", "np", "addr", "cp", "st", "del", "loc", "ptr", "desc", "origin", "port", "target", "pos", "dev", "home", "gen", "decl", "to", "id", "max", "gate", "proc", "coord", "phi", "test", "pt", "source", "master", "lit", "rest", "v", "pi", "est"], "src_len": ["src_length", "src_ld", "src6li", "src_end", "source_li", "source_limit", " src_length", " src_li", "src_gen", " src_size", "srcptli", "source_len", "source_gen", "src__len", " src_ln", "src__length", "src_li", "srcableld", "src_ln", "src__li", "srcptlen", "source_length", "srcablelen", "src6len", "src6ln", "srcptlength", "srcablelength", " src_end", "srcptlimit", "src__limit", "srcablegen", "src_size", "source_ld", "src_limit", "src6end"], "dest_len": ["source_length", "dest_length", "dest___lan", "dest2lan", " Dest___len", " Dest___size", "dest_lan", "dest_size", "dest2len", " Dest_size", "dest2size", " Dest_line", " Dest_lan", "dest2line", "source_end", "source_l", "dest___len", "dest___line", " Dest_len", " Dest___lan", "source_len", "dest___size", " Dest___line", "dest_l", "dest_line"], "ps": ["bs", "fs", "amps", "px", "pers", "cp", "ptr", "ms", "pos", "ports", "pps", "js", "vals", "pt", "pr", "plays", "ins", "posts", "points", "ops", "checks", "als", "ands", "pas", "ones", "sp", "res", "pins", "ems", "pres", "css", "po", "pes", "times", "ping", "parts", "ns", "fps", "jp", "rs", "pe", "pa", "eps", "pl", "pose", "vs", "ls", "ples", "ats", "its", "mp", "ims", "proc", "pse", "ts", "pp", "pi", "ph", "PS", "params", "sts", "lp", "ips", "p", "s", "Ps", "gs", "eds", "aps", "ds", "cs", "stats"], "pd": ["pkg", "dl", "ppa", "d", "py", "hd", "lp", "dt", "pe", "pc", "dp", "ctl", "px", "pu", "pid", "np", "cp", "eps", "pl", "p", "PD", "bd", "ping", "pb", "ls", "pn", "ln", "md", "pard", "tp", "pps", "lv", "pdf", "xd", "dd", "fd", "sd", "php", "pod", "ud", "pak", "pat", "pipe", "phi", "ds", "po", "ped", "pt", "pr", "ld", "pp", "pi", "ph", "td", "cd", "vd", "posts", "pm"], "i": ["qi", "h", "d", "ind", "ai", "ii", "ji", "n", "gi", "k", "di", "x", "cli", "ij", "ip", "c", "u", "ti", "li", "hi", "\u0438", "I", "p", "ei", "si", "m", "oi", "im", "e", "b", "multi", "in", "iter", "fi", "index", "iu", " ii", "it", "j", "me", "ci", "ie", "xi", "ic", "ki", "t", "phi", "zi", "ix", "mi", "is", "o", "a", "pi", "y", "v", "ui", "ini", "bi", "print", "io"], "l": ["lis", "dl", "h", "d", "lp", "ly", "tl", "n", "lt", "sl", "lc", "la", "local", "isl", "lb", "c", "u", "ul", "li", "pl", "p", "loc", "kl", "list", "s", "m", "ls", "lo", "ln", "b", "len", "al", "lv", "hl", "g", "it", "j", "lf", "line", "L", "ml", "cl", "el", "lu", "nl", "ol", "t", "ll", "il", "ld", "lit", "le", "v", "f", "length", "jl", "lr"], "dest_end": ["rest_open", "dest___end", "dest___termin", "destvalend", "src_end", "desc_end", "dest_start", "src_ends", "rest_termin", "desc_ends", "dest_hend", "destvalbegin", "rest_begin", "dest_ends", "dest_begin", "destvalopen", "dest_termin", "dest___open", "destvaltermin", "dest___begin", "dest_open", "rest_end", "src_hend", "desc_start"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,\n\n                                           src - (stride * 2) +\n\n                                           sizeof(uint8_t), stride,\n\n                                           dst, stride);\n\n}\n", "idx": 13867, "substitutes": {"dst": ["tdest", "dests", "dsts", "desrc", "dmit", "Dest", " dsrc", "dest", "tmit", "mmit", "mdest", " dest", "Dst", " ddest", "ddest", " dmit", "Dsrc", "dsrc", " dsts", "Dsts", "tst", "mst", "deest", "test", "mest"], "src": ["dist", "ind", "rs", "sn", "req", "comp", "sb", "ur", "txt", "cur", "cmp", "input", "dest", "st", "loc", "sub", "s", "sys", "r", "scan", "img", "ptr", "imp", "urg", "ser", "desc", "syn", "usc", "b", "in", "sur", "rc", "cc", "hl", "inner", "cont", "str", "rl", "supp", "sr", "dq", "inst", "ctr", "sc", "source", "rt", "uint", "ins", "RC"], "stride": ["suspided", "strance", "strided", " strride", "stripe", " stripe", "ctrider", "strope", "stide", "sprride", "spripe", "strride", "suspride", "STRope", "stided", "drice", "dides", "drend", "stipe", "STRance", "stringides", "volride", " strope", "volide", "suspope", "dide", "dope", "STRride", " strice", "suspide", "ctrend", "stringide", "ctride", "spride", "drider", "sprided", "strider", "strice", "STRided", "STRide", "volance", "strides", "dride", "volider", " strides", " strided", "strend", "stringope", " strend", "ctrice", " strider", "STRider", " strance", "stringride"]}}
{"project": "FFmpeg", "commit_id": "374c907fb35f8236547b24d792fbb9bed201e321", "target": 1, "func": "static int vorbis_parse(AVCodecParserContext *s1, AVCodecContext *avctx,\n\n                        const uint8_t **poutbuf, int *poutbuf_size,\n\n                        const uint8_t *buf, int buf_size)\n\n{\n\n    VorbisParseContext *s = s1->priv_data;\n\n    int duration;\n\n\n\n    if (!s->vp && avctx->extradata && avctx->extradata_size) {\n\n        s->vp = av_vorbis_parse_init(avctx->extradata, avctx->extradata_size);\n\n        if (!s->vp)\n\n            goto end;\n\n    }\n\n\n\n    if ((duration = av_vorbis_parse_frame(s->vp, buf, buf_size)) >= 0)\n\n        s1->duration = duration;\n\n\n\nend:\n\n    /* always return the full packet. this parser isn't doing any splitting or\n\n       combining, only packet analysis */\n\n    *poutbuf      = buf;\n\n    *poutbuf_size = buf_size;\n\n    return buf_size;\n\n}\n", "idx": 13888, "substitutes": {"s1": ["S0", " s01", "cs1", "ts0", "sOne", "ts1", "s2", "s0", "SOne", "cs2", "cs01", "ss01", "ss2", "ss1", " s0", " s2", "S2", "s01", "csOne", "S01", "ssOne", "S1", " sOne", "ts2"], "avctx": ["avercontext", "averconfig", " avconfig", "avepkg", "AVcontext", "varpkg", "avermc", "avtx", "ravca", "avcli", "averkl", "vctx", "AVctx", "avcontext", "aveca", "avkl", "varcli", "varconfig", "avpkg", " avcontext", "averctx", "vtx", "averca", "ravmc", "AVconfig", "varcontext", " avtx", "avercli", "vcontext", "avectx", "avecontext", "AVtx", "vconfig", "ravcontext", " avmc", "avconfig", " avca", "varsys", "avsys", " avpkg", " avcli", "aversys", " avkl", "averpkg", "varctx", " avsys", "avmc", "varkl", "ravctx", "avca"], "poutbuf": ["portbuf", "poutqueue", "pinbuffer", " pOutbuffer", " pOutdb", "Poutbuf", "Poutqueue", "portbuffer", "pOutbuf", "pinqueue", "punebuf", "Pinbuf", " poutqueue", "portdb", "pOutbuffer", "pindb", "Poutpipe", "pOutqueue", "portqueue", "Pinpipe", "pinbuf", "punepipe", " poutdb", "pinpipe", "poutpipe", " pOutqueue", "Pinbuffer", "pOutdb", " poutbuffer", " pOutbuf", "poutbuffer", "pOutpipe", "punequeue", "punebuffer", "poutdb", "Pinqueue", "Poutbuffer"], "poutbuf_size": ["poutbuffer_size", "poutbuffer_len", "poutbuf_max", "poutbuffer_SIZE", "poutbuf_len", "poutbuffer_count", "poutbuf_count", "poutbuffer_max", "poutbuf_SIZE"], "buf": ["uf", "pkg", "queue", "ff", "cache", "tmp", "bc", "txt", "bf", "br", "rb", "out", "Buff", "cur", "result", "np", "cb", "vec", "uv", "err", "batch", "img", "pb", "raw", "buff", "bag", "mem", "b", "window", "db", "box", "buffer", "block", "ctx", "cv", "Buffer", "cap", "msg", "data", "seq", "proc", "func", "pad", "cmd", "wb", "doc"], "buf_size": ["uf_size", "uf_start", "buffer_mode", "buf_Size", "buf64len", "buf64size", "cap_len", "buf64code", "buf67index", " buf_len", "buf_mode", "buf_len", "uf_code", "buf2len", " buf2set", "buffer_Size", "cap2len", "cap2error", " buf2len", "buf_error", "cap_size", "buf_set", "buf2size", "buf64start", "buf64mode", "buf67start", " buf2size", "buf67code", "buf2mode", "buf64index", "buf2error", "buf_code", "cap2mode", "buf64error", "buf_index", "cap_mode", "cap2size", " buf_set", "buf67size", "buf2set", "buf_start", "uf_index", "buffer_size", "cap_error", "buffer_len"], "s": ["bs", "i", "h", "rs", "sg", "sol", "n", "sb", "sl", "ses", "S", "os", "sv", "c", "comm", "ps", "p", "sys", "ess", "sam", "ls", "sports", "hs", "aws", "gs", "ats", "b", "ports", "js", "ims", "sts", "sp", "spec", "services", "j", "sq", "sw", "less", "ds", "se", "cs", "ts", "is", "sm", "v", "y", "stats", "qs", "sync", "simple", "scl", "ns", "ss"], "duration": ["event", "d", "resolution", "timer", "version", "time", "component", "progress", "padding", "memory", "complete", "format", "sequence", "run", "depth", "result", "video", "number", "document", "message", "position", "Duration", "uv", "whatever", "relation", "vp", "timeout", "valid", "port", "frequency", "seconds", "dim", "trace", "window", "len", "verb", "distance", "volume", "runtime", "fd", "size", "description", "latest", "uration", "relative", "recorded", "period", "span", "date", "vr", "during", "later", "future", "v", "portion", "performance", "policy", "length", "doc", "delay", "wait"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void xen_ram_init(PCMachineState *pcms,\n\n                         ram_addr_t ram_size, MemoryRegion **ram_memory_p)\n\n{\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    ram_addr_t block_len;\n\n    uint64_t user_lowmem = object_property_get_int(qdev_get_machine(),\n\n                                                   PC_MACHINE_MAX_RAM_BELOW_4G,\n\n                                                   &error_abort);\n\n\n\n    /* Handle the machine opt max-ram-below-4g.  It is basically doing\n\n     * min(xen limit, user limit).\n\n     */\n\n    if (HVM_BELOW_4G_RAM_END <= user_lowmem) {\n\n        user_lowmem = HVM_BELOW_4G_RAM_END;\n\n    }\n\n\n\n    if (ram_size >= user_lowmem) {\n\n        pcms->above_4g_mem_size = ram_size - user_lowmem;\n\n        pcms->below_4g_mem_size = user_lowmem;\n\n    } else {\n\n        pcms->above_4g_mem_size = 0;\n\n        pcms->below_4g_mem_size = ram_size;\n\n    }\n\n    if (!pcms->above_4g_mem_size) {\n\n        block_len = ram_size;\n\n    } else {\n\n        /*\n\n         * Xen does not allocate the memory continuously, it keeps a\n\n         * hole of the size computed above or passed in.\n\n         */\n\n        block_len = (1ULL << 32) + pcms->above_4g_mem_size;\n\n    }\n\n    memory_region_init_ram(&ram_memory, NULL, \"xen.ram\", block_len,\n\n                           &error_abort);\n\n    *ram_memory_p = &ram_memory;\n\n    vmstate_register_ram_global(&ram_memory);\n\n\n\n    memory_region_init_alias(&ram_640k, NULL, \"xen.ram.640k\",\n\n                             &ram_memory, 0, 0xa0000);\n\n    memory_region_add_subregion(sysmem, 0, &ram_640k);\n\n    /* Skip of the VGA IO memory space, it will be registered later by the VGA\n\n     * emulated device.\n\n     *\n\n     * The area between 0xc0000 and 0x100000 will be used by SeaBIOS to load\n\n     * the Options ROM, so it is registered here as RAM.\n\n     */\n\n    memory_region_init_alias(&ram_lo, NULL, \"xen.ram.lo\",\n\n                             &ram_memory, 0xc0000,\n\n                             pcms->below_4g_mem_size - 0xc0000);\n\n    memory_region_add_subregion(sysmem, 0xc0000, &ram_lo);\n\n    if (pcms->above_4g_mem_size > 0) {\n\n        memory_region_init_alias(&ram_hi, NULL, \"xen.ram.hi\",\n\n                                 &ram_memory, 0x100000000ULL,\n\n                                 pcms->above_4g_mem_size);\n\n        memory_region_add_subregion(sysmem, 0x100000000ULL, &ram_hi);\n\n    }\n\n}\n", "idx": 13890, "substitutes": {"pcms": ["pconds", "cms", "socms", "crs", "pcensions", "nicks", "pbces", "picents", " pcps", "cpfs", "pcems", "pcm", "pcams", "mcfs", "panents", "procterms", "picfs", "procmic", "pxmes", "pbms", "pcws", "pbns", "picns", "bcns", "pcfs", "bcms", "socws", "picms", "mcps", "socents", "cpts", "arcss", "pxonds", "pnds", "vcts", " pcrs", "cps", "mcms", "procmis", "cpams", "procm", "procmes", "picds", "pnents", "pcmes", "procms", "nicms", "picmes", "procjs", "nicams", "picces", "cpss", " pcfs", "pcmos", "panems", "arcts", "pcns", "pxcs", "vcss", "pnmis", " pcmic", "dcms", "arcmos", "bcds", "pccs", "picensions", "cpmes", "cpms", "panms", "bcensions", "pcjs", "cpks", "picm", "pcents", "pnterms", "pcces", "vcmos", "pcks", "picems", "pnws", "mcrs", "cfs", "pxterms", "proconds", "pbjs", "procns", "picjs", "pnmes", "pnms", "arcms", "pxks", "pnonds", "pcmic", "piccs", "pcterms", "dcems", "pnensions", "procws", "pcts", "cpmos", "pxams", "vcms", "procfs", "pcps", "nicterms", "pances", " pcm", "pcss", "socmis", "pnns", "cpcs", "pxfs", "dcents", "pcrs", "cpterms", "procces", "pcds", "picmic", "dcces", "pxms", "pcmis", "procents"], "ram_size": ["ramzpos", "ram2size", "ram_loss", "rum_size", "cam_size", "gram_length", " ram2file", "ram_length", "cam_number", "ramzsize", "block_size", "ram_type", " ram_type", " ram2size", "ram_file", "rum_ize", " ram_length", "ramztype", "ram_Size", "gram_type", "ram2pos", "ramtsize", "ram_group", "ramtpos", "rum_Size", "ramzlength", "ramtlength", "block_length", "gram2size", "ram_number", "gram2length", "cam_group", "rum_loss", " ram2type", "ram2file", "ramttype", "gram2type", "ram2type", "gram_size", "ram_pos", "ram2length", "ram_name", "cam_len", " ram2length", "block_name", "ram_len", "gram2pos", "gram_pos", "ram_ize", " ram_file"], "ram_memory_p": ["ram_mem_p", "ram_memory__p", "ram_memory__pb", "ram_memory2p", "ram_storage_t", "ram_storage_pc", "ram_storage_p", "ram_memory_pb", "ram_storage_P", "ram_memory__P", "ram_mem_pb", "ram_mem_P", "ram_memory__pre", "ram_memory_t", "ram_memory_P", "ram_mem_pre", "ram_memory_pc", "ram_memory2pc", "ram_memory2t", "ram_memory2P", "ram_memory_pre"], "sysmem": [" sysmb", "symem", "sysmm", "systemmemory", "sysgo", "procdoc", " syscore", "Sysmb", "ysmem", "sysdoc", "procmm", "privmem", "systemmsg", "systemmem", "sysmb", "symemory", "privmm", "symsg", "systemcore", "syscore", "procgo", "ysmb", "privdoc", " sysmemory", "procmem", "SysMem", "ysMem", "symm", "privgo", "Sysmem", "sysmsg", " sysmsg", "sygo", "sydoc", "ysmemory", "Sysmemory", "sysmemory", " sysMem", "sycore", "sysMem"], "block_len": ["lock_len", "buffer_l", "buffer_mem", "lock_Len", "block_mem", "Block_lim", "block_loc", "block_size", "block_l", "buffer__size", "Block_len", " block_Len", "buffer__l", " block_coll", "block__l", "Block_Len", "block_Len", "block__size", "buffer__mem", "block_coll", " block_length", "block_length", "Block_lon", "lock_pos", "lock_loc", "block_lim", "block__mem", "block_pos", "block__len", "buffer__len", "block_lon", "buffer_size", "buffer_len"]}}
{"project": "qemu", "commit_id": "caae58cba07efec5f0616f568531c9dfaf1e9179", "target": 1, "func": "static void pci_spapr_set_irq(void *opaque, int irq_num, int level)\n\n{\n\n    /*\n\n     * Here we use the number returned by pci_spapr_map_irq to find a\n\n     * corresponding qemu_irq.\n\n     */\n\n    sPAPRPHBState *phb = opaque;\n\n\n\n    trace_spapr_pci_lsi_set(phb->busname, irq_num, phb->lsi_table[irq_num].irq);\n\n    qemu_set_irq(spapr_phb_lsi_qirq(phb, irq_num), level);\n\n}\n", "idx": 13897, "substitutes": {"opaque": ["oplaque", "OPaques", "pane", "OPaque", "Opane", " oplay", " opaques", "opane", "OPlay", "Opaques", "oplaques", "opque", "paque", " opque", "opaques", "oplque", "OPque", " opane", "paques", "oplay", "Opaque", "opllay"], "irq_num": ["irq_den", "irq_nm", "irquest_con", "irqi_mon", "irqxmon", "irq_mon", "irch_um", "irqi_num", "irv_Num", "irch_num", "irqxnum", "irq_number", "irq_Num", "irq_n", "irch_sum", "irq_um", "irqxNum", "irq_sum", "irqi_number", "irquest_nm", "irv_index", "irq_con", "irquest_mon", "irch_den", "irqi_n", "irv_num", "irv_mon", "irquest_num", "irqxindex", "irq_index"], "level": ["low", "equal", "prop", "type", "quality", "status", "style", "impact", "what", "group", "local", "priority", "levels", "depth", "scale", "message", "vl", "family", " Level", "where", "vel", "qual", "lev", "lvl", "index", "mode", "LE", "Level", "limit", "show", "cost", "fail", "VEL", "debug", "print", "le", "scope", "command", "length"], "phb": [" phbb", "Phbb", "Phb", " pbb", "phbp", "phc", " pa", "Phbar", "iphc", "khwb", " phB", "ophcb", "ophb", "aphba", " pha", "phyba", "phba", "iphb", "phyB", "iphbp", "aphc", "phyc", "phB", "phyb", "aphB", " phbar", " pb", "khb", " phbp", "iphB", "aphwb", "phycb", "phbar", "Pha", " phwb", "phybp", "khB", "khc", "phcb", " phc", "pha", "phbb", " pbar", "ophba", "aphcb", "aphb", "ophB", "phwb"]}}
{"project": "FFmpeg", "commit_id": "2f6ec9fdd7808c8ed045ae0ca4134ab21fb785e6", "target": 1, "func": "static int alloc_sequence_buffers(DiracContext *s)\n\n{\n\n    int sbwidth  = DIVRNDUP(s->source.width,  4);\n\n    int sbheight = DIVRNDUP(s->source.height, 4);\n\n    int i, w, h, top_padding;\n\n\n\n    /* todo: think more about this / use or set Plane here */\n\n    for (i = 0; i < 3; i++) {\n\n        int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0);\n\n        int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0);\n\n        w = s->source.width  >> (i ? s->chroma_x_shift : 0);\n\n        h = s->source.height >> (i ? s->chroma_y_shift : 0);\n\n\n\n        /* we allocate the max we support here since num decompositions can\n\n         * change from frame to frame. Stride is aligned to 16 for SIMD, and\n\n         * 1<<MAX_DWT_LEVELS top padding to avoid if(y>0) in arith decoding\n\n         * MAX_BLOCKSIZE padding for MC: blocks can spill up to half of that\n\n         * on each side */\n\n        top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2);\n\n        w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); /* FIXME: Should this be 16 for SSE??? */\n\n        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;\n\n\n\n        s->plane[i].idwt_buf_base = av_mallocz((w+max_xblen)*h * sizeof(IDWTELEM));\n\n        s->plane[i].idwt_tmp      = av_malloc((w+16) * sizeof(IDWTELEM));\n\n        s->plane[i].idwt_buf      = s->plane[i].idwt_buf_base + top_padding*w;\n\n        if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    w = s->source.width;\n\n    h = s->source.height;\n\n\n\n    /* fixme: allocate using real stride here */\n\n    s->sbsplit  = av_malloc(sbwidth * sbheight);\n\n    s->blmotion = av_malloc(sbwidth * sbheight * 16 * sizeof(*s->blmotion));\n\n    s->edge_emu_buffer_base = av_malloc((w+64)*MAX_BLOCKSIZE);\n\n\n\n    s->mctmp     = av_malloc((w+64+MAX_BLOCKSIZE) * (h*MAX_BLOCKSIZE) * sizeof(*s->mctmp));\n\n    s->mcscratch = av_malloc((w+64)*MAX_BLOCKSIZE);\n\n\n\n    if (!s->sbsplit || !s->blmotion)\n\n        return AVERROR(ENOMEM);\n\n    return 0;\n\n}\n", "idx": 13899, "substitutes": {"s": ["bs", "fs", "re", "pers", "ps", "ms", "ports", "js", "g", "ex", "ares", "y", "ins", "details", "changes", "sb", "series", "ops", "results", "os", "als", "has", "sv", "erences", "as", "t", "times", "states", "is", "f", "south", "parts", "ns", "rs", "ies", "S", "c", "comm", "eps", "sys", "ls", "vs", "hs", "ats", "its", "ims", "sq", "sets", "acs", "ts", "a", "bits", "qs", "sts", "ss", "n", "ants", "ses", "ar", "conf", "p", "es", "sam", "us", "aws", "rates", "gs", "b", "bis", "eds", "less", "ds", "self", "cs", "comments", "stats", "obj"], "i": ["status", "cli", "gu", "u", "oi", "ish", "dim", "vi", "ret", " ii", "it", "g", "ci", "ex", "zi", "mi", "y", "uri", "info", "ii", "ji", "ij", "init", "m", "ri", "any", "name", "ia", "multi", "j", "xi", "try", "ix", "is", "print", "f", "ui", "ini", "qi", "ind", "l", "ai", "di", "x", "c", "q", "ti", "li", "\u0438", "I", "err", "si", "batch", "im", "in", "fi", "index", "phi", "il", "o", "iri", "pi", "bi", "io", "n", "gi", "yi", "go", "sim", "ip", "ei", "p", "list", "us", "dr", "chain", "iu", "id", "me", "ic", "mount", "v"], "w": ["wind", "wl", "d", "l", "kw", "n", "ow", "nw", "win", "wal", "z", "x", "wi", "u", "hw", "rew", "weight", "q", "p", "wp", "r", "height", "ww", "tw", "wr", "b", "window", "W", "wa", "g", "html", "wt", "ew", "sw", "wid", "wn", "max", "iw", "t", "we", "widget", "fw", "ll", "aw", "rw", "wx", "v", "wh", "wb", "wd", "f", "y", "ht"], "h": ["ch", "l", "hd", "th", "k", "z", "ha", "history", "hash", "hz", "q", "bh", "dh", "hw", "hi", "c", "H", "gh", "p", "height", "m", "hr", "host", "zh", "hang", "ish", "hs", "kh", "b", "ah", "ho", "he", "ih", "hl", "rh", "g", "sh", "hal", "uh", "t", "phi", "oh", "o", "hm", "y", "high", "wh", "ph", "f", "v", "hh", "ht"], "top_padding": ["top_pointer", "bottom_height", "bottom_adding", "top_prefix", "top67pressure", "top_space", "top_height", "top_pressure", "top67margin", "topPpadding", "topPadding", "bottom_border", "top_adding", "top_margin", "bottom_pointer", "top_border", "bottom_space", "bottom_margin", "bottom_pressure", "top67padding", "bottom_offset", "bottom_padding", "topPpointer", "top_offset", "bottom_prefix", "top67space", "topPmargin"]}}
{"project": "FFmpeg", "commit_id": "bfeb83a8b7d3fcf09a54d8dbc9c521e10bb17530", "target": 1, "func": "static int hevc_handle_packet(AVFormatContext *ctx, PayloadContext *rtp_hevc_ctx,\n\n                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n\n                              const uint8_t *buf, int len, uint16_t seq,\n\n                              int flags)\n\n{\n\n    const uint8_t *rtp_pl = buf;\n\n    int tid, lid, nal_type;\n\n    int first_fragment, last_fragment, fu_type;\n\n    uint8_t new_nal_header[2];\n\n    int res = 0;\n\n\n\n    /* sanity check for size of input packet: 1 byte payload at least */\n\n    if (len < RTP_HEVC_PAYLOAD_HEADER_SIZE + 1) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Too short RTP/HEVC packet, got %d bytes\\n\", len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /*\n\n     * decode the HEVC payload header according to section 4 of draft version 6:\n\n     *\n\n     *    0                   1\n\n     *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n\n     *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n     *   |F|   Type    |  LayerId  | TID |\n\n     *   +-------------+-----------------+\n\n     *\n\n     *      Forbidden zero (F): 1 bit\n\n     *      NAL unit type (Type): 6 bits\n\n     *      NUH layer ID (LayerId): 6 bits\n\n     *      NUH temporal ID plus 1 (TID): 3 bits\n\n     */\n\n    nal_type =  (buf[0] >> 1) & 0x3f;\n\n    lid  = ((buf[0] << 5) & 0x20) | ((buf[1] >> 3) & 0x1f);\n\n    tid  =   buf[1] & 0x07;\n\n\n\n    /* sanity check for correct layer ID */\n\n    if (lid) {\n\n        /* future scalable or 3D video coding extensions */\n\n        avpriv_report_missing_feature(ctx, \"Multi-layer HEVC coding\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    /* sanity check for correct temporal ID */\n\n    if (!tid) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Illegal temporal ID in RTP/HEVC packet\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* sanity check for correct NAL unit type */\n\n    if (nal_type > 50) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported (HEVC) NAL type (%d)\\n\", nal_type);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch (nal_type) {\n\n    /* video parameter set (VPS) */\n\n    case 32:\n\n    /* sequence parameter set (SPS) */\n\n    case 33:\n\n    /* picture parameter set (PPS) */\n\n    case 34:\n\n    /*  supplemental enhancement information (SEI) */\n\n    case 39:\n\n    /* single NAL unit packet */\n\n    default:\n\n        /* sanity check for size of input packet: 1 byte payload at least */\n\n        if (len < 1) {\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\\n\",\n\n                   len, nal_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        /* create A/V packet */\n\n        if ((res = av_new_packet(pkt, sizeof(start_sequence) + len)) < 0)\n\n            return res;\n\n        /* A/V packet: copy start sequence */\n\n        memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n        /* A/V packet: copy NAL unit data */\n\n        memcpy(pkt->data + sizeof(start_sequence), buf, len);\n\n\n\n        break;\n\n    /* aggregated packet (AP) - with two or more NAL units */\n\n    case 48:\n\n        /* pass the HEVC payload header */\n\n        buf += RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n        len -= RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n\n\n        /* pass the HEVC DONL field */\n\n        if (rtp_hevc_ctx->using_donl_field) {\n\n            buf += RTP_HEVC_DONL_FIELD_SIZE;\n\n            len -= RTP_HEVC_DONL_FIELD_SIZE;\n\n        }\n\n\n\n        res = ff_h264_handle_aggregated_packet(ctx, pkt, buf, len,\n\n                                               rtp_hevc_ctx->using_donl_field ?\n\n                                               RTP_HEVC_DOND_FIELD_SIZE : 0,\n\n                                               NULL, 0);\n\n        if (res < 0)\n\n            return res;\n\n        break;\n\n    /* fragmentation unit (FU) */\n\n    case 49:\n\n        /* pass the HEVC payload header */\n\n        buf += RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n        len -= RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n\n\n        /*\n\n         *    decode the FU header\n\n         *\n\n         *     0 1 2 3 4 5 6 7\n\n         *    +-+-+-+-+-+-+-+-+\n\n         *    |S|E|  FuType   |\n\n         *    +---------------+\n\n         *\n\n         *       Start fragment (S): 1 bit\n\n         *       End fragment (E): 1 bit\n\n         *       FuType: 6 bits\n\n         */\n\n        first_fragment = buf[0] & 0x80;\n\n        last_fragment  = buf[0] & 0x40;\n\n        fu_type        = buf[0] & 0x3f;\n\n\n\n        /* pass the HEVC FU header */\n\n        buf += RTP_HEVC_FU_HEADER_SIZE;\n\n        len -= RTP_HEVC_FU_HEADER_SIZE;\n\n\n\n        /* pass the HEVC DONL field */\n\n        if (rtp_hevc_ctx->using_donl_field) {\n\n            buf += RTP_HEVC_DONL_FIELD_SIZE;\n\n            len -= RTP_HEVC_DONL_FIELD_SIZE;\n\n        }\n\n\n\n        av_dlog(ctx, \" FU type %d with %d bytes\\n\", fu_type, len);\n\n\n\n        if (len <= 0) {\n\n            /* sanity check for size of input packet: 1 byte payload at least */\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\\n\",\n\n                   len, nal_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (first_fragment && last_fragment) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Illegal combination of S and E bit in RTP/HEVC packet\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        new_nal_header[0] = (rtp_pl[0] & 0x81) | (fu_type << 1);\n\n        new_nal_header[1] = rtp_pl[1];\n\n\n\n        res = ff_h264_handle_frag_packet(pkt, buf, len, first_fragment,\n\n                                         new_nal_header, sizeof(new_nal_header));\n\n\n\n        break;\n\n    /* PACI packet */\n\n    case 50:\n\n        /* Temporal scalability control information (TSCI) */\n\n        avpriv_report_missing_feature(ctx, \"PACI packets for RTP/HEVC\\n\");\n\n        res = AVERROR_PATCHWELCOME;\n\n        break;\n\n    }\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n    return res;\n\n}\n", "idx": 13905, "substitutes": {"ctx": ["pkg", "context", "xp", "jp", "kw", "prefix", "ck", "tx", "conv", "cas", "ctl", "dc", "gz", "setup", "cmp", "unc", "cm", "addr", "xc", "cp", "cb", "conf", "cn", "cu", "hw", "sys", "jac", "kk", "cfg", "desc", "tz", "tc", "nt", "cc", "fn", "gc", "cv", "kt", "act", "cf", "ci", "conn", "cl", "ct", "func", " cx", "ca", "nc", "sc", "config", "wx", "cmd", "wcs", "wd", "obj", "iat", "co"], "rtp_hevc_ctx": ["rtp_heVC_cv", "rtp_hevc_context", "rtp_heVC_ctx", "rtp_heVC_context", "rtp_hevc_ct", "rtp_heVC_ct", "rtp_hevc_cv"], "st": ["ST", "ut", "std", "utt", "St", "ast", "ist", "ste", "xt", "sam", "et", "nt", "sp", "str", "act", "sw", "fr", "est", "stage", "ct", "mt", "inst", "sta", "sth", "tt", "rt", "rest", "sts"], "pkt": ["pkg", "packacket", "cpet", "Pett", "cpct", "tkt", "pett", "cacket", "packkt", " pnt", "tct", " pck", " pet", "ppnt", "apkg", " pkg", "cnt", " packet", "Packet", "npkt", "tck", "npnt", "pet", "ppkt", "pck", "cet", "cpkt", "cpacket", "npkg", "Pet", " pct", "packett", "Pkt", "apnt", "pnt", "apacket", "ckt", "packet", "ppacket", "tacket", "pct", "ppet", "cpett", "cpck", "apkt", "npacket"], "timestamp": ["timtime", "Timstart", "simestamp", "timest", "Timtime", "temstart", "simest", "temestamp", "Timest", "temtime", "temest", "timstart", "simstart", "simtime", "Timestamp"], "buf": ["pkg", "bs", "xff", "bl", "bc", "header", "conv", "ait", "pool", "cmp", "np", "addr", "cp", "cb", "ptr", "pb", "pos", "mem", "pg", "cv", "Buffer", "pack", "late", "ob", "Len", "emb", "uf", "packed", "h", "cache", "prop", "tmp", "txt", "br", "next", "Buff", "bn", "vec", "img", "vp", "buffer", "res", "cap", "msg", "bp", "rw", "cmd", "length", "bytes", "rb", "loc", "arr", "err", "cam", "data", "proc", "queue", "ff", "ref", "elt", "cur", "p", "nm", "desc", "raw", "buff", "b", "db", "box", "iter", "str", "bin", "ctr", "pad", "aka"], "len": ["uf", "lis", "dl", "l", "lp", "n", "bytes", "elt", "z", "lc", "conv", "full", "gz", "loc", "kl", "vec", "err", "ls", "syn", "pos", "mem", "ln", "nt", "iter", "lon", "fn", "ret", "lic", "size", "res", "lf", "line", "coll", "L", "cap", "lim", "en", "msg", "num", "el", "fl", "enc", "nl", "late", "ll", "fin", "resp", "lang", "val", "all", "Len", "length", "lan"], "seq": ["ref", "req", "nos", "serv", "cas", "sequence", "next", "frame", "q", "cb", "ver", "vec", "ess", "flow", "pos", "alt", "code", "sec", "iter", "count", "gen", "loop", "vals", "msg", "ctr", "body", "val"], "flags": ["details", "ff", "fs", "status", "files", "ps", "weight", "fields", "links", "args", "options", "ms", "flag", "faces", "Flags", "ags", "tags", "vals", "cf", "ents", "fl", "ds", "cs", "ts", "bits", "types", "mask", "ns"], "rtp_pl": ["rtv__pl", "rtv__pp", "rtp__pl", "rtv__cl", "rtp__cl", "rtv_cl", "rtp__pp", "rtv_pp", "rtp_pp", "rtp_cl", "rtv__pb", "rtp__pb", "rtp_pb", "rtv_pl", "rtv_pb"], "tid": [" tids", "tgid", "tmid", "gId", "tgoid", "gmid", "toid", "goid", " toid", "lmid", "tip", "ntype", "ltype", "nId", "loid", "lId", "lids", "ttype", "tgId", "tgip", "gid", " tmid", "nids", " ttype", "nid", "tId", "lip", " tip", "tids", " tId"], "lid": ["tmid", "tiden", "lno", "mlid", "lsmid", "naid", " laid", "cmid", "liden", "laid", "lpid", "flaid", "noid", "lmid", "mliden", " ltype", " lpid", "cid", "tno", "ntype", "ltype", "lsiden", "mlids", "loid", " lids", "lids", " loid", "lsno", "lsid", "nid", " liden", "floid", "cno", "ilpid", "ciden", "ilids", "fltype", "ilid", "mlpid", "iliden", "flid"], "nal_type": ["nAL_name", "naling_Type", "nal_status", "neal_types", "naletyType", "nals_Type", "naling_type", "nal_types", "nall_Type", "nal_style", "nal2type", "nal__pe", "nall_type", "nal_tag", "neal_type", "nals_type", "nAL_style", "naletyype", "nal__type", "nal_name", "nall_tag", "neal_status", "nal_TYPE", "nal__Type", "nAL_type", "nal__TYPE", "naletytype", "nal_Type", "nal_ype", "neal_Type", "nAL_Type", "nal_length", "nal_pe", "nal2status", "nal2types", "nAL_pe", "naling_block", "nal2Type", "naling_length", "nAL_TYPE", "nals_ype", "nal_block"], "first_fragment": ["first_pragments", "first_fragramement", "first_frgement", "first_fragmentation", "first_fragement", "first_frigment", "first_fragramment", "first_fragrammentation", "first_frgmentation", "first_pragement", "first_frigement", "first_prigement", "first_fragments", "first_pragmentation", "first_frgment", "first_fragramments", "first_frgments", "first_prigments", "first_frigmentation", "first_frigments", "first_prigment", "first_prigmentation", "first_pragment"], "last_fragment": ["last_frongments", "last_frigement", "last_frigment", "last_frongmentation", "last_frongment", "last_frangments", "last_fagmentation", "last_figmentation", "last_frangmentation", "last_fagments", "last_frangment", "last_fagment", "last_fragments", "last_frangement", "last_fagement", "last_frigments", "last_figments", "last_fragmentation", "last_figment", "last_frigmentation", "last_fragement", "last_figement", "last_frongement"], "fu_type": ["du_types", "fu_types", "du_name", "du_pe", "fu_name", "du_type", "fu_pe"], "new_nal_header": ["new_nal__header", "new_nals_size", "new_nals_info", "new_nal__head", "new_nal__info", "new_nals_head", "new_nal__size", "new_nal_head", "new_nals_header", "new_nal_info", "new_nal_size"]}}
{"project": "FFmpeg", "commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "target": 1, "func": "int avpriv_lock_avformat(void)\n\n{\n\n    if (lockmgr_cb) {\n\n        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))\n\n            return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 13906, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static int libschroedinger_encode_close(AVCodecContext *avctx)\n\n{\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n\n\n    /* Close the encoder. */\n\n    schro_encoder_free(p_schro_params->encoder);\n\n\n\n    /* Free data in the output frame queue. */\n\n    ff_schro_queue_free(&p_schro_params->enc_frame_queue,\n\n                        libschroedinger_free_frame);\n\n\n\n\n\n    /* Free the encoder buffer. */\n\n    if (p_schro_params->enc_buf_size)\n\n        av_freep(&p_schro_params->enc_buf);\n\n\n\n    /* Free the video format structure. */\n\n    av_freep(&p_schro_params->format);\n\n\n\n    return 0;\n\n}\n", "idx": 13915, "substitutes": {"avctx": ["AVcontext", "avtx", "avparams", "ovctx", "AVctx", "avcontext", " avcontext", "AVconn", "avetx", "ovparams", " avtx", "ovcontext", "avectx", "avecontext", "AVtx", "ovtx", "AVparams", "avconn", " avparams", "aveconn", " avconn"], "p_schro_params": ["p_schro__names", "p_schro2names", "p_schrob_pins", "p_schrob_stats", "p_schro_pins", "p_schro_names", "p_schrob_names", "p_schro_files", "p_schro_data", "p_schro2params", "p_schro___ams", "p_schro_ams", "p_schrotparams", "p_schrob_info", "p_schro_param", "p_schro__pins", "p_schrob_param", "p_schro2param", "p_schrob_data", "p_schro_stats", "p_schro___data", "p_schro__ams", "p_schrob_ams", "p_schrotstats", "p_schro___params", "p_schrotpins", "p_schro__data", "p_schrob_files", "p_schro__params", "p_schrob_params", "p_schrotams", "p_schro___files", "p_schro__info", "p_schro2ams", "p_schro_info"]}}
{"project": "FFmpeg", "commit_id": "121be310607879841d19a34d9f16d4fe9ba7f18c", "target": 0, "func": "static int cinepak_decode_frame(AVCodecContext *avctx,\n\n                                void *data, int *got_frame,\n\n                                AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int ret = 0, buf_size = avpkt->size;\n\n    CinepakContext *s = avctx->priv_data;\n\n\n\n    s->data = buf;\n\n    s->size = buf_size;\n\n\n\n    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)\n\n        return ret;\n\n\n\n    if (s->palette_video) {\n\n        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n\n        if (pal) {\n\n            s->frame->palette_has_changed = 1;\n\n            memcpy(s->pal, pal, AVPALETTE_SIZE);\n\n        }\n\n    }\n\n\n\n    if ((ret = cinepak_decode(s)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"cinepak_decode failed\\n\");\n\n    }\n\n\n\n    if (s->palette_video)\n\n        memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE);\n\n\n\n    if ((ret = av_frame_ref(data, s->frame)) < 0)\n\n        return ret;\n\n\n\n    *got_frame = 1;\n\n\n\n    /* report that the buffer was completely consumed */\n\n    return buf_size;\n\n}\n", "idx": 13943, "substitutes": {"avctx": [" avjac", "avercontext", "cvcpp", "afconn", "vrctx", "cvcontext", "AVpkg", "AVcontext", "avertmp", "afcontext", "avtx", "AVctx", "avcontext", "vrcontext", "afpkg", "afjac", "avpkg", " avcontext", "averctx", "cvctx", "vrtx", "avetx", "avcpp", "aftx", " avtx", "avejac", "apcontext", "avectx", "avecontext", "avertx", "afctx", "AVtx", "vrcpp", "apctx", " avtmp", "avconn", "aveconn", "cvtx", "aptx", " avpkg", " avconn", "avjac", "avtmp", "avecpp", "aptmp"], "data": ["d", "cache", "ref", "end", "package", " DATA", "image", "bytes", "map", "n", "Data", "extra", "padding", "DATA", "content", "flags", "out", "value", "next", "feed", "frame", "input", "video", "ata", "rew", "message", "p", "batch", "m", "empty", "options", "raw", "name", "read", "pos", "mem", "window", "chain", "buffer", "len", "al", "done", "id", "to", "size", "str", "ad", "values", "res", "fr", "bin", "t", "pipe", "apps", "actions", "body", "pad", "a", "bits", "text", "f", "v", "length", "w", "area", "dat", "mu"], "got_frame": ["got_count", "sent_frame", "got_frames", "got_process", "sent_int", "got_offset", "sent_offset", "got_int", " got_frames", " got_count", " got_process", "sent_frames"], "avpkt": ["avpkw", "avetpkt", "avcmsg", "avepmsg", "avpgt", "avcpkt", "wavwpkt", "aveppj", "aveppt", "avparkt", "avpargt", "avspct", "avppt", "wavwpkw", "wavwpnt", "avppgt", "avcpkw", "avvpnt", "avtpkg", "avepkg", "avespct", "avppkt", "avvpacket", "aveppkt", "avepdt", "avwpacket", "avpkg", "avparkg", "avwpkw", "avppmsg", "avPacket", "avcpnt", "wavpkw", "avwpnt", "wavpacket", "aveppacket", "avepacket", "avvpkt", "avcpt", "avpaj", "avpdt", "aveppmsg", "avppkg", "avcacket", "avpct", "avetpgt", "avckt", "avspkt", "avsppt", "avespkt", "avppj", "avcj", "avetpkg", "avppdt", "avesppt", "avPkt", "wavpnt", "avPct", "avcct", "wavwpacket", "avpakt", "avtpdt", "avetpdt", "avepgt", "avPpt", "avpamsg", "avpj", "avespacket", "avpnt", "avepj", "avepct", "avtpgt", "avwpkt", "avpardt", "avppacket", "avpmsg", "avcpacket", "avepkt", "avspacket", "wavpkt", "avpacket", "avtpkt", "avvpkw", "avpaacket"], "buf": ["uf", "pkg", "queue", "ref", "bytes", "bl", "tmp", "bc", "alloc", "br", "rb", "np", "cb", "p", "arr", "vec", "batch", "pb", "tr", "raw", "buff", "mem", "b", "box", "db", "iter", "buffer", "block", "cv", "cap", "msg", "lim", "seq", "proc", "capt", "cmd", "wb", "dat"], "s": ["bs", "details", "i", "h", "fs", "ans", "rs", "changes", "n", "sb", "serv", "ants", "ses", "ies", "S", "os", "als", "so", "c", "sv", "has", "ps", "comm", "conf", "p", "sys", "ess", "r", "es", "ls", "sports", "vs", "us", "hs", "ms", "gs", "b", "ats", "its", "js", "as", "ims", "sts", "spec", "bis", "g", "j", "sq", "sw", "less", "ds", "span", "se", "cs", "ts", "is", "bits", "v", "stats", "ins", "qs", "y", "parts", "ns", "ss"], "pal": ["pkg", "label", "cal", "rel", "theme", "cel", "pol", "app", "wal", "ali", "fac", "what", "local", "phal", "pillar", "ill", "Pal", "col", "pu", "pid", "pen", " Pal", "pl", "p", "ap", "arr", "isal", "pill", "sam", "uid", "pro", "cell", "mon", "buff", "mem", "pard", "sal", "al", "font", "hal", "skin", "bin", "el", "pat", "nl", "apple", "tile", "phil", "pixel", "bat", "mel", "val", "pp", "le", "ph", "mat", "v", "ass", "cil", "qt", "dat", "pac"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void taihu_405ep_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    char *filename;\n\n    qemu_irq *pic;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *bios;\n\n    MemoryRegion *ram_memories = g_malloc(2 * sizeof(*ram_memories));\n\n    MemoryRegion *ram = g_malloc0(sizeof(*ram));\n\n    hwaddr ram_bases[2], ram_sizes[2];\n\n    long bios_size;\n\n    target_ulong kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    int linux_boot;\n\n    int fl_idx, fl_sectors;\n\n    DriveInfo *dinfo;\n\n\n\n    /* RAM is soldered to the board so the size cannot be changed */\n\n    ram_size = 0x08000000;\n\n    memory_region_allocate_system_memory(ram, NULL, \"taihu_405ep.ram\",\n\n                                         ram_size);\n\n\n\n    ram_bases[0] = 0;\n\n    ram_sizes[0] = 0x04000000;\n\n    memory_region_init_alias(&ram_memories[0], NULL,\n\n                             \"taihu_405ep.ram-0\", ram, ram_bases[0],\n\n                             ram_sizes[0]);\n\n    ram_bases[1] = 0x04000000;\n\n    ram_sizes[1] = 0x04000000;\n\n    memory_region_init_alias(&ram_memories[1], NULL,\n\n                             \"taihu_405ep.ram-1\", ram, ram_bases[1],\n\n                             ram_sizes[1]);\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register cpu\\n\", __func__);\n\n#endif\n\n    ppc405ep_init(sysmem, ram_memories, ram_bases, ram_sizes,\n\n                  33333333, &pic, kernel_filename == NULL ? 0 : 1);\n\n    /* allocate and load BIOS */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register BIOS\\n\", __func__);\n\n#endif\n\n    fl_idx = 0;\n\n#if defined(USE_FLASH_BIOS)\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n    if (dinfo) {\n\n        BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo));\n\n\n\n        bios_size = bdrv_getlength(bs);\n\n        /* XXX: should check that size is 2MB */\n\n        //        bios_size = 2 * 1024 * 1024;\n\n        fl_sectors = (bios_size + 65535) >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Register parallel flash %d size %lx\"\n\n               \" at addr %lx '%s' %d\\n\",\n\n               fl_idx, bios_size, -bios_size,\n\n               bdrv_get_device_name(bs), fl_sectors);\n\n#endif\n\n        pflash_cfi02_register((uint32_t)(-bios_size),\n\n                              NULL, \"taihu_405ep.bios\", bios_size,\n\n                              bs, 65536, fl_sectors, 1,\n\n                              4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    } else\n\n#endif\n\n    {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Load BIOS from file\\n\");\n\n#endif\n\n        if (bios_name == NULL)\n\n            bios_name = BIOS_FILENAME;\n\n        bios = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram(bios, NULL, \"taihu_405ep.bios\", BIOS_SIZE,\n\n                               &error_abort);\n\n        vmstate_register_ram_global(bios);\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (filename) {\n\n            bios_size = load_image(filename, memory_region_get_ram_ptr(bios));\n\n            g_free(filename);\n\n            if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n                error_report(\"Could not load PowerPC BIOS '%s'\", bios_name);\n\n                exit(1);\n\n            }\n\n            bios_size = (bios_size + 0xfff) & ~0xfff;\n\n            memory_region_add_subregion(sysmem, (uint32_t)(-bios_size), bios);\n\n        } else if (!qtest_enabled()) {\n\n            error_report(\"Could not load PowerPC BIOS '%s'\", bios_name);\n\n            exit(1);\n\n        }\n\n        memory_region_set_readonly(bios, true);\n\n    }\n\n    /* Register Linux flash */\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n    if (dinfo) {\n\n        BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo));\n\n\n\n        bios_size = bdrv_getlength(bs);\n\n        /* XXX: should check that size is 32MB */\n\n        bios_size = 32 * 1024 * 1024;\n\n        fl_sectors = (bios_size + 65535) >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Register parallel flash %d size %lx\"\n\n               \" at addr \" TARGET_FMT_lx \" '%s'\\n\",\n\n               fl_idx, bios_size, (target_ulong)0xfc000000,\n\n               bdrv_get_device_name(bs));\n\n#endif\n\n        pflash_cfi02_register(0xfc000000, NULL, \"taihu_405ep.flash\", bios_size,\n\n                              bs, 65536, fl_sectors, 1,\n\n                              4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    }\n\n    /* Register CLPD & LCD display */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register CPLD\\n\", __func__);\n\n#endif\n\n    taihu_cpld_init(sysmem, 0x50100000);\n\n    /* Load kernel */\n\n    linux_boot = (kernel_filename != NULL);\n\n    if (linux_boot) {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"%s: load kernel\\n\", __func__);\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr,\n\n                        \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n    }\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: Done\\n\", __func__);\n\n#endif\n\n}\n", "idx": 13951, "substitutes": {"machine": ["computer", "menu", "series", "image", "monitor", "server", "memory", "sim", "node", "connection", "history", "state", "managed", "password", "physical", "achine", "message", "mc", "check", "m", "host", "smart", "cell", "controller", "mac", "shell", "instance", "mode", "manager", "module", "me", "engine", "model", "anim", "money", "magic", "zone", "hard", "iso", "template", "handler", "keeper", "link", "command", "Machine", "process", "vm"], "kernel_filename": ["kernelityfilename", "kernel5source", " kernel_username", "kernelityfile", "ernel_file", "kernelphpfile", "kernel_username", "kernel_file", "kernelingfile", "kernel5file", "kernelphpbase", "kernel__username", "kernelphpdatabase", "kernelphpfilename", "kernel_txt", " kernel_file", " kernel_txt", "kernel_database", "ernel_master", "kernel__filename", "kernel5filename", "kernel5master", "kernel__txt", "kernelitybase", "kernel_source", "kernel__file", "ernel_source", "ernel_database", "kernelingmaster", "ernel_filename", "kernelingfilename", "kernel_master", "ernel_base", "kernelitydatabase", "kernelingsource"], "initrd_filename": ["initrs_filename", "initrdmlfilename", "initrd___filename", "initrdmldetails", "initrs_file", "initrd_files", "initrs_processor", "initrd_Filename", "initrs_details", "initrdmlFilename", "initrd__file", "initrd__filename", "initrd__processor", "initrd_file", "initrdmlfile", "initrd_processor", "initrd___processor", "initrd_details", "initrd__files", "initrd___files", "initrd___file", "initrs_Filename", "initrs_files"], "filename": ["Filename", "fp", "sn", "sharp", "png", "txt", "til", "picture", "tif", "kl", "pict", "Pic", "sic", "tty", "bite", "fn", "fi", "path", "csv", "kj", "file", "fc", "kan", "icc", "script", "pac"], "pic": ["panic", "iac", "pc", "pol", "png", "txt", "pa", "media", "picture", "p", "mc", "pict", "cam", "Pic", "img", "eric", "icon", "sac", "Picture", "fi", "sp", "fn", "phot", "shot", "nic", "wic", "ic", "pipe", "typ", "spr", "fc", "lib", "pan", "ics", "pi", "script", "pac"], "sysmem": [" sysmb", "systemmemory", "systemMem", " sysman", "ysmem", "sysm", "ysm", "systemmem", "sysmb", "systemmb", "sysman", "ysman", "ysmb", "systemman", " sysmemory", "ysMem", "systemm", " sysm", "ysmemory", "sysmemory", " sysMem", "sysMem"], "bios": ["gbricks", " bases", "Bricks", "bio", "Bio", "bricks", "gbases", "bases", "Bios", "gbio", " bricks", " bio", "gbios", "Bases"], "ram_memories": ["ram_cryptory", "ram_sumories", "ram_hististries", "ram_memos", "ram_temories", "ram_histograms", "ram_temos", "ram_messory", "ram_matograms", "ram_sumory", "ram_memometers", "ram_histographies", "ram_mators", "ram_messories", "ram_temives", "ram_histors", "ram_manories", "ram_messometers", "ram_manaries", "ram_metographies", "ram_temograms", "ram_memory", "ram_memaries", "ram_temors", "ram_cryptaries", "ram_matos", "ram_metaries", "ram_messos", "ram_sumaries", "ram_histaries", "ram_memistries", "ram_memors", "ram_histives", "ram_sumistries", "ram_manory", "ram_matory", "ram_cryptors", "ram_matometers", "ram_cryptives", "ram_temory", "ram_memives", "ram_histories", "ram_metory", "ram_metories", "ram_cryptistries", "ram_history", "ram_manographies", "ram_memographies", "ram_memograms", "ram_cryptories", "ram_temometers", "ram_matories"], "ram": ["gem", "sum", "iam", "menu", "ra", "am", "cms", "mic", "memory", "win", "rb", "ruby", "Ram", "reg", "cpu", "hw", "rain", "root", "sys", "mc", "scan", "cam", "ma", "sam", "imus", "m", "mb", "storage", "raw", "dim", "mem", "mac", "lam", "md", "RAM", "amd", "rum", "path", "gc", "ro", "mode", "sd", "gold", "rad", "disk", "row", "bin", "mm", "rom", "lib", "rw", "ru", "sky", "base", "vm", "gram", "fat", "ras", "gb", "gra"], "ram_bases": ["ram_abias", "ram___iboots", "ram_laches", "ram_lbias", "ram_vas", "ram___boots", "ram_nbas", "ram_vasing", "ram_biase", "ram_abases", "ram_ibaches", "ram_gales", "ram___baches", "ram_lasts", "ram_gores", "ram_bias", "ram_bats", "ram_bades", "ram_lase", "ram_bounds", "ram_lores", "ram_gboes", "ram_boes", "ram_beales", "ram_gbases", "ram_nbasing", "ram_lases", "ram_lbaches", "ram___ibias", "ram_baches", "ram_abaches", "ram_basing", "ram_iboots", "ram_beores", "ram_nbases", "ram_lbases", "ram___ibases", "ram_basts", "ram_gbones", "ram___ibaches", "ram_bolases", "ram_lats", "ram_lales", "ram_vades", "ram_boots", "ram_biats", "ram_beones", "ram_basias", "ram_basaches", "ram_bones", "ram___bases", "ram_gase", "ram_ibases", "ram_beases", "ram_basases", "ram_ibias", "ram_aboots", "ram_bas", "ram_gases", "ram_bolats", "ram_biounds", "ram_bease", "ram_bolounds", "ram_basasts", "ram_bores", "ram_biases", "ram_base", "ram_beoes", "ram_bolase", "ram_nbias", "ram_vones", "ram_ibasts", "ram_vases", "ram_lias", "ram___bias", "ram_biasing", "ram_gbades", "ram_voes", "ram_lboots", "ram_bales", "ram_beades", "ram_vias", "ram_lounds", "ram_biias"], "ram_sizes": ["ram_sapes", "ram__msapes", "ram_mices", "ram2sizes", "ram_Senses", "ram_scizing", "ram_mites", "ram_msites", "ram_isices", "ram_cizes", "ram_seists", "ram_Sizes", "ram_stizes", "ram_mizes", "ram2siz", "ram2seiz", "ram_sides", "ram_usizes", "ram2sists", "ram_lumbers", "ram_Sides", "ram_sumbers", "ram2mices", "ram__sapes", "ram_isikes", "ram_eizes", "ram2sses", "ram_damples", "ram2sices", "ram_sists", "ram_seumbers", "ram_seides", "ram_isizes", "ram_sites", "ram_seiz", "ram_stists", "ram_scizes", "ram_setsices", "ram_usales", "ram_ssizes", "ram_sses", "ram_lists", "ram_stizers", "ram2mikes", "ram_usamples", "ram_dizes", "ram_scumbers", "ram_setsikes", "ram2ses", "ram_stes", "ram_sizing", "ram2ssizes", "ram_Sizers", "ram_ses", "ram__msites", "ram_cites", "ram_mists", "ram_Sales", "ram_siz", "ram_lides", "ram_seizing", "ram__sists", "ram_isizers", "ram_usenses", "ram_senses", "ram2sides", "ram_capes", "ram_mikes", "ram_mizers", "ram2mizers", "ram_ssizers", "ram_cists", "ram_ssists", "ram__sizes", "ram_Siz", "ram2sizers", "ram_eizers", "ram2seides", "ram_mapes", "ram_lizers", "ram_Samples", "ram__msists", "ram_msapes", "ram_scists", "ram_seizers", "ram_seizes", "ram_sizers", "ram_sales", "ram_eists", "ram2seizes", "ram2mizes", "ram_msists", "ram_liz", "ram_sikes", "ram2sikes", "ram2seizers", "ram2ssizers", "ram_msizes", "ram__sites", "ram__msizes", "ram_lizing", "ram_setsizes", "ram_sices", "ram_denses", "ram_setsizers", "ram2ssists", "ram_ees", "ram_dales", "ram_lizes", "ram_samples"], "bios_size": ["bio_SIZE", "bios_SIZE", "bio_size", "bio_count", "bios_count", "bio_Size", "bios_Size"], "kernel_base": [" kernel_scale", "kernel___base", "kernel___prefix", "kernel_scale", "kernel___size", "kernel___scale", "kernel_prefix", " kernel_prefix"], "initrd_base": ["initrd_prefix", "initrd_origin", "initrs_buffer", "initrd_buffer", "initrs_prefix", "initrs_origin", "initrs_base"], "kernel_size": ["kernel_resolution", "binary_resolution", "binary_name", "kernel_speed", "kernel_name", "binary_size", "binary_speed"], "initrd_size": ["initrd_SIZE", "initrd_name", "initrs_SIZE", "initrs_Size", "initrd_Size", "initrs_name", "initrs_size"], "linux_boot": ["linux5bus", "linux_base", "linux_Boot", "linuxMembase", " linux_bus", "linuxMembus", "linuxMemBoot", "linux5boot", "linux_bus", " linux_Boot", "linux5Boot", "linux5base", " linux_base", "linuxMemboot"], "fl_idx": ["fl_idsx", "fl_Idy", "fl_indv", "fl_Idxs", "fl_idsxs", "fl_idxf", "fl_indxc", "fl_Idx", "fl_idsy", "fl_indx", "fl_idv", "fl_idxc", "fl_indxs", "fl_Idxf", "fl_idy", "fl_idxs", "fl_indz", "fl_indxf", "fl_Idv", "fl_idz", "fl_Idxc", "fl_Idz", "fl_idsxc"], "fl_sectors": ["fl_psevers", "fl_spex", "fl_scs", "fl_specs", "fl_spectors", "fl_severs", "fl_secs", "fl_sctors", "fl_psecs", "fl_psex", "fl_sex", "fl_psectors", "fl_sx", "fl_svers", "fl_spevers"], "dinfo": [" dInfo", "dno", " dfo", "Dno", "dfo", "rInfo", "DINFO", "DInfo", "rinf", "rfo", " dinf", "ddinfo", "ddInfo", " dno", "rinfo", "ddINFO", "ddinf", "rno", "dInfo", "dinf", "Dinf", "Dinfo", " dINFO", "dINFO", "Dfo"], "bs": ["bos", "fs", "bid", "bl", "bc", "bf", "br", "bh", "bd", "ls", "gs", "js", "lbs", "bles", "bb", "bis", "bas", "bps", "bed", "BS", "ds", "ubs", "bp", "cs", "bi", "bm", "ns", "ba"]}}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static void *ff_avio_child_next(void *obj, void *prev)\n\n{\n\n    AVIOContext *s = obj;\n\n    AVIOInternal *internal = s->opaque;\n\n    return prev ? NULL : internal->h;\n\n}\n", "idx": 13969, "substitutes": {"obj": ["info", "ref", "tmp", "txt", "tx", "bj", "node", "out", "os", "init", "src", "oid", "oj", "impl", "vp", "bo", "nt", "js", "ot", "ctx", "fn", "object", "id", "op", "res", "act", "j", "data", "attr", "pr", "resp", "o", "cmd", "ob", "onet", "ns", "Obj"], "prev": ["before", "rel", " Prev", "pri", "parent", "orig", "tmp", "last", "history", "next", "buf", "cmp", "new", "pred", "reverse", "this", "pre", "Previous", "jump", "p", "wp", "skip", "vp", "nil", "rev", "mp", "buffer", "sp", "nav", "j", "iv", "pres", "Prev", "vious", " previous", "vr", "inv", "v", "rec", "first", "current"], "s": ["i", "h", "rs", "sn", "n", "sb", "sl", "shared", "S", "c", "sv", "p", "sys", "r", "m", "ssl", "ls", "gs", "b", "as", "sp", "sts", "j", "sq", "sd", "less", "t", "ds", "ts", "o", "a", "sm", "v", "ins", "sis", "ass", "ns", "ss"]}}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "static void pm_ioport_read(IORange *ioport, uint64_t addr, unsigned width,\n\n                            uint64_t *data)\n\n{\n\n    PIIX4PMState *s = container_of(ioport, PIIX4PMState, ioport);\n\n    uint32_t val;\n\n\n\n    switch(addr) {\n\n    case 0x00:\n\n        val = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n        break;\n\n    case 0x02:\n\n        val = s->ar.pm1.evt.en;\n\n        break;\n\n    case 0x04:\n\n        val = s->ar.pm1.cnt.cnt;\n\n        break;\n\n    case 0x08:\n\n        val = acpi_pm_tmr_get(&s->ar);\n\n        break;\n\n    default:\n\n        val = 0;\n\n        break;\n\n    }\n\n    PIIX4_DPRINTF(\"PM readw port=0x%04x val=0x%04x\\n\", (unsigned int)addr, val);\n\n    *data = val;\n\n}\n", "idx": 13988, "substitutes": {"ioport": ["ospost", "iopORT", "ospart", "opart", "opORT", "ioparent", "osporter", "lipost", "ioported", "riport", "ospport", "opost", "ioporter", "liported", "iport", "liporter", "ypost", "ypport", "liport", "osport", "yport", "riporter", "iopost", "lipORT", "ipost", "osported", "lipport", "osparent", "oparent", "ypORT", "iparent", "iopport", "riported", "ipart", "ripport", "iopart", "oport", "opport"], "addr": ["ord", "ref", "type", "rs", "address", "tx", "hash", "ip", "cmp", "src", "hw", "adr", "tag", "err", "r", "start", "ptr", "tr", "dr", "name", "pos", "alt", "db", "rc", "len", "ctx", "eth", "ack", "index", "id", "url", "str", "act", "ad", "at", "res", "offset", "msg", " address", "mt", "coord", "nl", "order", "attr", "net", "align", "ix", "rt", "cmd", "inv", "a", "var", "obj"], "data": ["d", "cache", " DATA", "map", "bytes", "image", "n", "Data", "DATA", "flags", "out", "value", " Data", "buf", "ata", "c", "p", "def", "bus", "batch", "m", "pos", "window", "dev", "buffer", "ret", "done", "size", "str", "bin", "step", "t", " dat", "pad", "text", "table", "length", "w", "dat", "mu"], "s": ["bs", "h", "fs", "rs", "sol", "sb", "serv", "sl", "ses", "ies", "S", "os", "als", "ar", "sv", "has", "comm", "ps", "sys", "es", "sam", "ls", "syn", "vs", "xs", "hs", "aws", "ms", "gs", "ats", "b", "its", "iss", "js", "ports", "sa", "sts", "spec", "services", "sh", "sq", "sw", "ares", "self", "ds", "actions", "states", "cs", "ts", "is", "a", "sm", "south", "v", "ins", "stats", "sis", "qs", "parts", "ns", "params", "ss"], "val": [" value", "eval", "bl", "valid", "Value", "pos", "mem", "ret", "ann", "it", "vals", "pr", "pt", "all", "prop", "als", "util", "def", "vt", "aval", "num", "msg", "broad", "fail", "fee", "resp", "stat", "rel", " Val", "pol", "x", "value", "buf", "pl", "loc", "arr", "err", "update", "alt", "al", " v", "index", "cal", "Val", "ref", "elt", "tx", "local", "bil", "sel", "p", "VAL", " eval", "ival", "dev", "xy", "len", "ctx", "str", "cho", "pal", "el", "rol", "test", "vol", "crit", "v", "label"]}}
{"project": "FFmpeg", "commit_id": "4d87001096ff1d4e3ee6f88f8caddbd8ccb2c816", "target": 1, "func": "static int update_dimensions(VP8Context *s, int width, int height)\n\n{\n\n    if (width  != s->avctx->width ||\n\n        height != s->avctx->height) {\n\n        if (av_image_check_size(width, height, 0, s->avctx))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        vp8_decode_flush_impl(s->avctx, 1, 0, 1);\n\n\n\n        avcodec_set_dimensions(s->avctx, width, height);\n\n    }\n\n\n\n    s->mb_width  = (s->avctx->coded_width +15) / 16;\n\n    s->mb_height = (s->avctx->coded_height+15) / 16;\n\n\n\n    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));\n\n    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));\n\n    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);\n\n    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));\n\n    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));\n\n\n\n    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||\n\n        !s->top_nnz || !s->top_border)\n\n        return AVERROR(ENOMEM);\n\n\n\n    s->macroblocks        = s->macroblocks_base + 1;\n\n\n\n    return 0;\n\n}\n", "idx": 14014, "substitutes": {"s": ["bs", "fs", "ids", "styles", "views", "pers", "ps", "storage", "ms", "ports", "js", "des", "services", "g", "sd", "sw", "gets", "tests", "y", "ins", "details", "h", "changes", "sb", "ops", "results", "os", "als", "sv", "er", "sports", "erences", "ers", "as", "ags", "t", "states", "is", "ains", "parts", "ns", "mods", "rs", "sl", "ies", "S", "c", "comm", "eps", "ls", "vs", "hs", "ats", "its", "scripts", "ims", "sq", "ts", "bits", "qs", "ss", "sts", "n", "ants", "ses", "conf", "es", "xs", "aws", "gs", "e", "spec", "bis", "less", "ys", "ds", "cs", "comments", "v", "stats"], "height": ["shape", "h", "rank", "ch", "resolution", "angle", "image", "th", "ty", "holes", "padding", "history", "above", "hash", "depth", "density", "dimension", "capacity", "Height", "hang", "dim", "window", "gravity", "len", "total", "volume", "xy", "size", "crop", "html", "it", "rows", "range", " heights", "grow", "row", "max", "inches", "gy", "axy", "t", "stroke", "bottom", "hei", "chip", "ows", "sky", "y", "high", "length", "ht", "alpha"]}}
{"project": "qemu", "commit_id": "01b05c66a3616d5a4adc39fc90962e9efaf791d1", "target": 1, "func": "int nbd_receive_reply(QIOChannel *ioc, NBDReply *reply, Error **errp)\n\n{\n\n    int ret;\n\n    const char *type;\n\n\n\n    ret = nbd_read_eof(ioc, &reply->magic, sizeof(reply->magic), errp);\n\n    if (ret <= 0) {\n\n        return ret;\n\n    }\n\n\n\n    be32_to_cpus(&reply->magic);\n\n\n\n    switch (reply->magic) {\n\n    case NBD_SIMPLE_REPLY_MAGIC:\n\n        ret = nbd_receive_simple_reply(ioc, &reply->simple, errp);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n\n\n        trace_nbd_receive_simple_reply(reply->simple.error,\n\n                                       nbd_err_lookup(reply->simple.error),\n\n                                       reply->handle);\n\n        if (reply->simple.error == NBD_ESHUTDOWN) {\n\n            /* This works even on mingw which lacks a native ESHUTDOWN */\n\n            error_setg(errp, \"server shutting down\");\n\n            return -EINVAL;\n\n        }\n\n        break;\n\n    case NBD_STRUCTURED_REPLY_MAGIC:\n\n        ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n        type = nbd_reply_type_lookup(reply->structured.type);\n\n        trace_nbd_receive_structured_reply_chunk(reply->structured.flags,\n\n                                                 reply->structured.type, type,\n\n                                                 reply->structured.handle,\n\n                                                 reply->structured.length);\n\n        break;\n\n    default:\n\n        error_setg(errp, \"invalid magic (got 0x%\" PRIx32 \")\", reply->magic);\n\n        return -EINVAL;\n\n    }\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 14022, "substitutes": {"ioc": ["iot", "bioc", "uoc", "iocl", "uec", "iOC", " iocal", "uot", " iosc", " iot", "inosc", "oog", " iocl", "oocal", " ioint", "iosc", "bioci", "biOC", "oot", " iog", "iec", "oocl", "biog", "ioint", "pioc", "piocl", "piOC", "pioint", "biec", "iog", "oec", "biot", "oOC", "ioci", "ooint", "iocal", " ioci", "ooc", " iOC", "oosc", "inec", "inoc", "inocal", " iec", "uoci"], "reply": ["repair", "send", "route", "status", "transfer", "frame", "patch", "message", "article", "parse", "apply", "rr", "rule", "review", "display", "record", "Reply", "report", "proxy", "se", "mi", "sync", "details", "detail", "info", "py", "join", "next", "support", "repl", "request", "line", "play", "try", "comment", "link", "resp", "cmd", "part", "print", "policy", "command", "ping", "notice", "query", "onse", "role", "ror", "prefix", "quote", "ve", "req", "pop", "answer", "replace", "vote", "service", "response", "shell", "note", "job", "pipe", "plugin", "pty", "call", "related", "address", "invoke", "bro", "embed", "match", "reason", "remote", "attribute", "ply", "module", "see", "write", "post", "reset"], "errp": ["errpp", " errpp", "ererp", "aerps", "ferpkg", "aerp", " errP", " errps", " errpkg", "aerpa", " errper", "serpa", " errpa", "rrpkg", "rerm", "aerper", "aerpp", " errpb", "errm", " errpc", "errps", "aerpb", "rrP", "derp", "rerpa", "errpb", "rrpp", "errP", "ererpb", "errpc", "aerP", "derpa", "rrp", "derm", "ererpc", "ferP", "errping", "rrpb", " errping", "ferpc", "rerp", "serP", "ererP", "rerpt", " errm", "serp", "ererpkg", "errpa", "rrping", "rrper", "errpt", " errpt", "derpt", "errper", "rrps", "aerping", "ferp", "errpkg", "serpb"], "ret": ["status", "re", "prot", "cat", "Ret", "ptr", "ry", "mem", "att", "vet", "rect", "it", "rot", "inter", "ter", "expr", "rets", "quad", "rem", "usr", " alt", "end", "dt", "last", "txt", " RET", "def", "xt", "tr", "code", "final", "res", "try", "t", "net", "cmd", "print", "RET", "pret", "ber", "x", "format", "old", "ext", "arr", "round", "Return", "alt", "nt", "cert", "rm", "mt", "det", "gt", "nat", "rt", "deg", "val", "ft", "ref", "elt", "lt", "out", "reg", "col", "result", "desc", "port", "rev", "iter", "len", "fun", "cont", "rier", "str", "back", " Ret", "rest", "reset"], "type": ["rel", "kind", "ror", "info", "role", "version", "area", " TYPE", "pe", "ty", "time", "level", "style", "format", "error", "what", "value", "sequence", "group", " typ", " name", "number", "q", " t", "interface", "Type", "p", "tag", "r", "message", "check", "cast", "action", "handle", "name", "port", "target", " Type", "code", "trace", "tp", "field", "buffer", "sp", "unit", "ype", "index", "id", "module", "offset", " kind", "class", "t", "handler", "typ", "test", "file", "sort", "rt", "link", "types", " error", " other", "length", "ping", "relation", "TYPE", " ty"]}}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static void ne2000_receive(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    NE2000State *s = opaque;\n\n    uint8_t *p;\n\n    int total_len, next, avail, len, index, mcast_idx;\n\n    uint8_t buf1[60];\n\n    static const uint8_t broadcast_macaddr[6] = \n\n        { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n    \n\n#if defined(DEBUG_NE2000)\n\n    printf(\"NE2000: received len=%d\\n\", size);\n\n#endif\n\n\n\n    if (!ne2000_can_receive(s))\n\n        return;\n\n    \n\n    /* XXX: check this */\n\n    if (s->rxcr & 0x10) {\n\n        /* promiscuous: receive all */\n\n    } else {\n\n        if (!memcmp(buf,  broadcast_macaddr, 6)) {\n\n            /* broadcast address */\n\n            if (!(s->rxcr & 0x04))\n\n                return;\n\n        } else if (buf[0] & 0x01) {\n\n            /* multicast */\n\n            if (!(s->rxcr & 0x08))\n\n                return;\n\n            mcast_idx = compute_mcast_idx(buf);\n\n            if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))))\n\n                return;\n\n        } else if (s->mem[0] == buf[0] &&\n\n                   s->mem[2] == buf[1] &&                   \n\n                   s->mem[4] == buf[2] &&            \n\n                   s->mem[6] == buf[3] &&            \n\n                   s->mem[8] == buf[4] &&            \n\n                   s->mem[10] == buf[5]) {\n\n            /* match */\n\n        } else {\n\n            return;\n\n        }\n\n    }\n\n\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    index = s->curpag << 8;\n\n    /* 4 bytes for header */\n\n    total_len = size + 4;\n\n    /* address for next packet (4 bytes for CRC) */\n\n    next = index + ((total_len + 4 + 255) & ~0xff);\n\n    if (next >= s->stop)\n\n        next -= (s->stop - s->start);\n\n    /* prepare packet header */\n\n    p = s->mem + index;\n\n    s->rsr = ENRSR_RXOK; /* receive status */\n\n    /* XXX: check this */\n\n    if (buf[0] & 0x01)\n\n        s->rsr |= ENRSR_PHY;\n\n    p[0] = s->rsr;\n\n    p[1] = next >> 8;\n\n    p[2] = total_len;\n\n    p[3] = total_len >> 8;\n\n    index += 4;\n\n\n\n    /* write packet data */\n\n    while (size > 0) {\n\n        avail = s->stop - index;\n\n        len = size;\n\n        if (len > avail)\n\n            len = avail;\n\n        memcpy(s->mem + index, buf, len);\n\n        buf += len;\n\n        index += len;\n\n        if (index == s->stop)\n\n            index = s->start;\n\n        size -= len;\n\n    }\n\n    s->curpag = next >> 8;\n\n\n\n    /* now we can signal we have receive something */\n\n    s->isr |= ENISR_RX;\n\n    ne2000_update_irq(s);\n\n}\n", "idx": 14023, "substitutes": {"opaque": ["ipaque", "ipas", "OPaque", "oaque", "Opity", "Opane", "spane", " oplay", "spity", "opane", "OPlay", "Opacity", "spaque", "opity", "oane", "opque", "opacity", "iplay", "oacity", "OPas", " opque", "oity", "OPque", "opas", "ipque", "oplay", " opas", "Opaque", "spacity"], "buf": ["pkg", "map", "xff", "orig", "bl", "bc", "conv", "ait", "pool", "cp", "cb", "ptr", "pb", "mem", "fb", "cv", "Buffer", "pack", "emb", "que", "uf", "cache", "prop", "bar", "tmp", "txt", "br", "Buff", "vec", "img", "good", "buffer", "cap", "msg", "cmd", "doc", "bu", "bytes", "bf", "rb", "ext", "foo", "arr", "batch", "cam", "cast", "bag", "block", "data", "seq", "proc", "deg", "queue", "ff", "tx", "cur", "nm", "desc", "raw", "buff", "b", "window", "box", "db", "iter", "ctx", "str", "lim", "bin", "func", "aka", "v", "wb", "obj"], "size": ["sn", "send", "padding", "space", "password", "message", "storage", "news", "mem", "pos", "g", "offset", "scroll", "Size", "ize", "cache", "number", "set", "height", "sent", "timeout", "name", "code", "buffer", "sp", "limit", "num", " sizes", "fee", "length", "notice", "shape", "sum", "type", "bytes", "small", "c", "empty", "min", "count", "no", "total", "data", "max", "address", "n", "SIZE", "z", "new", "scale", "now", " Size", "body", "shift"], "s": ["bs", "fs", "sn", "server", "ears", "space", "http", "ps", "ms", "js", "g", "sw", "gets", "se", "sm", "y", "sis", "h", "d", "changes", "sb", "serv", "os", "als", "sv", "set", "store", "ssl", "m", "events", "ers", "as", "sp", "t", "is", "ains", "ns", "mods", "rs", "sl", "S", "so", "service", "c", "comm", "sys", "ls", "vs", "hs", "ats", "its", "scripts", "ims", "sq", "sets", "ts", "o", "qs", "sts", "ss", "i", "n", "z", "ses", "state", "conf", "es", "sam", "aws", "gs", "b", "e", "spec", "bis", "less", "ds", "self", "cs", "stats"], "p": ["pkg", "h", "i", "jp", "fp", "rep", "lp", "n", "pc", "x", "pa", "ip", "np", "c", "cp", "ps", "ap", "wp", "pre", "r", "m", "ptr", "pb", "vp", "pos", "b", "tp", "sp", "pointer", "op", "P", "g", "j", "t", "po", "pt", "o", "pp", "v", "f"], "total_len": ["full_Len", "public_Len", "equal_Len", "totalaxyLen", "public_len", "total_lif", "equalaxylen", "equalaxyLen", "public67len", "total_Len", "totalaxylength", "total_lang", "total_ll", "equal_len", "totalaxyden", "public67lif", "total67Len", "total_mem", "full_mem", "total_length", "full_len", "public67Len", "totalaxylen", "total_den", "public_lif", "public67lang", "total67lang", "total67len", "full_ll", "equalaxyden", "equalaxylength", "public_lang", "equal_den", "total67mem", "total67lif", "total67ll", "equal_length"], "next": ["i", "ind", "jp", "end", "n", "route", "page", "last", "success", "z", "sequence", "new", "li", "Next", "loc", "jump", "position", "start", "skip", "ptr", "timeout", "ne", "min", "pos", "big", "dev", "sec", "iter", "gen", "ng", "pointer", "path", "j", "limit", "after", "offset", "max", "forward", "seq", "prev", "net", "front", "link", "head", "future", "first", "length", "current", "shift"], "avail": ["capend", "apail", "vile", "avend", "avile", "apay", "apile", "vay", "apend", "capile", "capay", "vail", "vend", "avay", "capail"], "len": ["l", "lp", "n", "elt", "loc", "vec", "ls", "min", "pos", "mem", "fun", "line", "limit", "offset", "cap", "lim", "en", "el", "late", "ll", "fin", "il", "lib", "Len", "length", "lan", "label"], "index": ["i", "ind", "info", "end", "address", "stop", "n", "page", "route", "point", "x", "error", "ip", "init", "addr", "new", "find", "loc", "position", "set", "start", "Index", "si", "add", "key", "pos", "seek", "iter", "initial", "block", "slice", "buffer", "id", "path", "line", "j", "offset", "num", "lock", "row", "max", "open", "axis", "ix", "link", "head", "val", "length", "cycle"], "mcast_idx": ["mcast_midxc", "mcast_modxc", "mcast_idg", "mcast_midxf", "mcast_txx", "mcast_Idg", "mcast_indx", "mcast_indg", "mcast_ridxs", "mcast_Idx", "mcast2idx", "mcast_txct", "mcast_ridix", "mcast_txz", "mcast_modx", "mcast2Idz", "mcast_idz", "mcast_indc", "mcast_modxf", "mcast_ridxf", "mcast_idxf", "mcast_ridz", "mcast_Idxs", "mcast_midz", "mcast2idxs", "mcast2Idxs", "mcast_midct", "mcast_ridx", "mcast_idsx", "mcast_indz", "mcast_idsz", "mcast_idix", "mcast_idxc", "mcast_idsct", "mcast_midc", "mcast_inc", "mcast2idz", "mcast_Idz", "mcast_ridxc", "mcast_txc", "mcast_idct", "mcast_Idc", "mcast_inz", "mcast_midx", "mcast_inx", "mcast2Idx", "mcast_ing", "mcast_modix", "mcast_idc", "mcast_midix", "mcast_idsc", "mcast_idxs"], "buf1": ["vec1", " buffer0", "buf2", "uf2", "buffer2", " buffer3", "buffer0", "vec0", "vec4", "buff3", "uf4", "buffer1", " buf0", " buffer1", " buffer2", "buff4", "uf0", "buff2", "buff1", "uf1", "buf4", " buf4", "buf0", "buf3", "vec3", "uf3", "buff0", " buf2", " buf3"], "broadcast_macaddr": ["broadcast_macorder", "broadcast_micaddr", "broadcast_microorder", "broadcast_MACaddress", "broadcast_MACaddr", "broadcast_macref", "broadcast_ipref", "broadcast_micaddress", "broadcast_micorder", "broadcast_ipaddress", "broadcast_micref", "broadcast_microaddr", "broadcast_microaddress", "broadcast_macaddress", "broadcast_MACref", "broadcast_ipaddr"]}}
{"project": "FFmpeg", "commit_id": "f264d336fe61c12ce9607c3060aa5d3dca947c61", "target": 1, "func": "static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)\n\n{\n\n    int16_t tmp[146 + 60], *ptr0, *ptr1;\n\n    const int16_t *filter;\n\n    int i, t, off;\n\n\n\n    t = dec->offset2[quart];\n\n    if(t == 127){\n\n        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));\n\n        return;\n\n    }\n\n    for(i = 0; i < 146; i++)\n\n        tmp[i] = dec->filtbuf[i];\n\n    off = (t / 25) + dec->offset1[quart >> 1] + 18;\n\n\n    ptr0 = tmp + 145 - off;\n\n    ptr1 = tmp + 146;\n\n    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;\n\n    for(i = 0; i < 60; i++){\n\n        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;\n\n        ptr0++;\n\n        dec->newvec[i] = t;\n\n        ptr1[i] = t;\n\n    }\n\n}", "idx": 14024, "substitutes": {"quart": ["quarter", "qua", " Quart", "clock", "butt", " quot", "opt", "art", "percent", "ilt", "point", "hart", "aq", "q", "ext", "integer", " quarter", "foo", "qa", "cart", "qq", "nut", "pound", "mint", "crop", " quant", "quet", "ant", "amp", "rot", "quant", "minute", "minus", "ct", " quint", "ox", "aqu", "ART", "frac", "quick", "crit", "pocket", "qu", "rt", "quad", "qt", "pie"], "tmp": ["uf", "pkg", "cache", "jp", "prefix", "emp", "map", "txt", "temp", "out", "etc", "buf", "cmp", "util", "np", "new", "utm", "cp", "ap", "p", "wp", "uv", "zero", "adjusted", "tf", "ptr", "empty", "img", "mb", "mk", "buff", "qq", "mp", "array", "db", "buffer", "offs", "ctx", "sp", "mint", "ot", "total", "op", "sq", "data", "rot", "test", "tt", "snap", " np", " tcp", "ob", "v", "table", "td", "obj", "aux", "up", "gb", " mp"], "ptr0": ["ptrZero", "Ptr00", "attr047", "prime1", "pt8", "Ptr6", "Ptr8", "ptr00", "ptr047", "pert0", "pt2", "pr256", "pert1", "ptr10", "ptr2", " ptrZero", "pr1", "attr0", "pr10", "Ptr1", "PtrZero", "ptrNR", "prime6", " ptr00", "pt1", "pertNR", " ptr8", " ptr2", "attr1", "pt10", "loc00", "locZero", "pr6", "loc1", " ptr10", "Ptr047", "Ptr0", "pr0", "ptr6", "pt0", "ptr256", "Ptr2", "pt256", "ptr8", " ptr256", "attrNR", "PtrNR", "prime0", "pert047", "loc0"], "ptr1": ["Ptr100", "prime2", "ptrone", "pt4", "prime1", "ptrb", "expr100", "pointer4", "pointer0", "Ptr6", "expr2", "pert0", "primeone", "pert1", "ptr2", "exprone", "pointer3", "Ptr1", "Ptr4", "pertb", "pt1", "pointers0", "expr1", "pointersb", "ptr6", "prime100", "Ptrone", "Ptr2", "Ptr0", "Ptrb", "pt0", "pt3", "ptr3", "pointer1", "pert6", "pointers1", "pointers6", "ptr100", "ptr4", "Ptr3"], "filter": ["ff", "search", "ft", "ch", "type", "channel", "select", "condition", "cut", "map", "burn", "ilt", "bt", "style", "join", "fac", "format", "only", "hash", "q", "p", "tag", "list", "skip", "batch", "tf", "check", "aff", "tr", "flag", "match", "Filter", "block", "buffer", "attribute", "transform", "limit", "offset", "fil", "ct", "fl", "pack", "pipe", "test", "control", "sort", "cond", "config", "v", "table", "f", "user", "term", "mask", "profile", "alpha", "tail"], "i": ["status", "ski", "cli", "u", "this", "oi", "asi", " ii", "it", "g", "ci", "ie", "ki", "zi", "mi", "y", "uri", "ii", "ji", "ij", "init", "hi", "client", "m", "multi", "ni", "j", "xi", "ix", "is", "print", "ui", "ini", "qi", "ind", "l", "ai", "di", "x", "q", " bi", "ti", "li", "you", "\u0438", "I", "si", "key", "im", "in", "itime", "index", "phi", "o", "pi", "bi", "iq", "n", "gi", "sim", "ip", "ei", "p", " j", " I", "s", "us", "chain", "iter", "iu", "id", "me", "ic", "span", "v", "iat"], "t": ["h", "d", "l", "type", "n", "opt", "dt", "ty", "tu", "fort", "txt", "x", "temp", "title", "c", "q", "ti", "tif", "tree", "p", "s", "tg", "tf", "T", "m", "tr", "te", "tip", "tz", "tw", "tc", "trace", "tp", "tap", "ot", "vt", "total", "mint", "tar", "to", "g", "it", "at", "wt", "offset", "typ", "test", "tt", "tm", " T", "ts", "pt", "o", "rt", "a", "v", "f", "term", "qt", "iat", "got", "ta"], "off": ["ff", "ut", "end", "aft", "n", "art", "Offset", "out", "ta", "ext", "ap", "p", "start", "from", "m", "et", "aff", "origin", "bo", "now", "oa", "pos", "nt", "ot", "len", "offs", "Off", "it", "j", "after", "offset", "pres", "open", "det", "ox", "opp", "OFF", "pt", "o", "a", "onet", "pad", "v", "f", "length", "on", "shift"]}}
{"project": "qemu", "commit_id": "ad2d30f79d3b0812f02c741be2189796b788d6d7", "target": 1, "func": "static void scsi_disk_purge_requests(SCSIDiskState *s)\n\n{\n\n    SCSIDiskReq *r;\n\n\n\n    while (!QTAILQ_EMPTY(&s->qdev.requests)) {\n\n        r = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests));\n\n        if (r->req.aiocb) {\n\n            bdrv_aio_cancel(r->req.aiocb);\n\n        }\n\n        scsi_remove_request(r);\n\n    }\n\n}\n", "idx": 14025, "substitutes": {"s": ["h", "d", "fs", "rs", "n", "sb", "serv", "ops", "ses", "os", "S", "als", "space", "c", "comm", "conf", "ps", "p", "sys", "ess", "es", "ls", "hs", "aws", "gs", "js", "sts", "spec", "sp", "less", "ds", "self", "ts", "is", "y", "v", "stats", "south", "ns", "ss"], "r": ["h", "usr", "d", "rs", "req", "end", "reb", "br", "rb", "re", "run", "result", "ar", "c", "q", "u", "rf", "er", "p", "err", "hr", "R", "dr", "rx", "ry", "rd", "repl", "b", "rc", "rr", "response", "rh", "request", "ro", "rg", "res", "rn", "j", "item", "rar", "fr", "rm", "sr", "mr", "t", "attr", "vr", "pr", "rw", "rt", "inv", "cr", "all", "rec", "obj", "or", "rem"]}}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static int net_slirp_init(VLANState *vlan)\n\n{\n\n    if (!slirp_inited) {\n\n        slirp_inited = 1;\n\n        slirp_init();\n\n    }\n\n    slirp_vc = qemu_new_vlan_client(vlan, \n\n                                    slirp_receive, NULL);\n\n    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), \"user redirector\");\n\n    return 0;\n\n}\n", "idx": 14031, "substitutes": {"vlan": ["vehLAN", "Vlu", "VLAN", "vlu", " vLAN", "vlif", "vlay", "svlu", "vul", " vlay", " vul", "svlay", "svul", "vane", " vlu", "vehane", "Vul", "vLAN", "Vlay", " vane", "vehlif", "svlan", " vlif", "vehlan", "Vane", "Vlan", "Vlif"]}}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int pnm_decode_header(AVCodecContext *avctx, PNMContext * const s){\n\n    char buf1[32], tuple_type[32];\n\n    int h, w, depth, maxval;;\n\n\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    if (!strcmp(buf1, \"P4\")) {\n\n        avctx->pix_fmt = PIX_FMT_MONOWHITE;\n\n    } else if (!strcmp(buf1, \"P5\")) {\n\n        if (avctx->codec_id == CODEC_ID_PGMYUV) \n\n            avctx->pix_fmt = PIX_FMT_YUV420P;\n\n        else\n\n            avctx->pix_fmt = PIX_FMT_GRAY8;\n\n    } else if (!strcmp(buf1, \"P6\")) {\n\n        avctx->pix_fmt = PIX_FMT_RGB24;\n\n    } else if (!strcmp(buf1, \"P7\")) {\n\n        w = -1;\n\n        h = -1;\n\n        maxval = -1;\n\n        depth = -1;\n\n        tuple_type[0] = '\\0';\n\n        for(;;) {\n\n            pnm_get(s, buf1, sizeof(buf1));\n\n            if (!strcmp(buf1, \"WIDTH\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                w = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"HEIGHT\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                h = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"DEPTH\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                depth = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"MAXVAL\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                maxval = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"TUPLETYPE\")) {\n\n                pnm_get(s, tuple_type, sizeof(tuple_type));\n\n            } else if (!strcmp(buf1, \"ENDHDR\")) {\n\n                break;\n\n            } else {\n\n                return -1;\n\n            }\n\n        }\n\n        /* check that all tags are present */\n\n        if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type[0] == '\\0')\n\n            return -1;\n\n        avctx->width = w;\n\n        avctx->height = h;\n\n        if (depth == 1) {\n\n            if (maxval == 1)\n\n                avctx->pix_fmt = PIX_FMT_MONOWHITE;\n\n            else \n\n                avctx->pix_fmt = PIX_FMT_GRAY8;\n\n        } else if (depth == 3) {\n\n            avctx->pix_fmt = PIX_FMT_RGB24;\n\n        } else if (depth == 4) {\n\n            avctx->pix_fmt = PIX_FMT_RGBA32;\n\n        } else {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    } else {\n\n        return -1;\n\n    }\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    avctx->width = atoi(buf1);\n\n    if (avctx->width <= 0)\n\n        return -1;\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    avctx->height = atoi(buf1);\n\n    if (avctx->height <= 0)\n\n        return -1;\n\n    if (avctx->pix_fmt != PIX_FMT_MONOWHITE) {\n\n        pnm_get(s, buf1, sizeof(buf1));\n\n    }\n\n\n\n    /* more check if YUV420 */\n\n    if (avctx->pix_fmt == PIX_FMT_YUV420P) {\n\n        if ((avctx->width & 1) != 0)\n\n            return -1;\n\n        h = (avctx->height * 2);\n\n        if ((h % 3) != 0)\n\n            return -1;\n\n        h /= 3;\n\n        avctx->height = h;\n\n    }\n\n    return 0;\n\n}\n", "idx": 14056, "substitutes": {"avctx": [" avcmd", "airjac", "avreq", "abcmp", "afreq", "avcp", "airctx", "vrctx", "verctx", "avcu", "vercp", "Avconn", "vertx", " avcmp", "abcontext", "vercontext", "avcontent", "avtx", "ahconn", "abcmd", "navtx", "vrcpu", " avreq", "Avctx", "avcontext", "avcmd", "ivercpu", "navcmp", "aircpu", "verconn", "obcomm", "Avcp", " avcu", "avcpu", " avcontext", "iverjac", "navctx", "afcmp", "avetx", "aftx", " avtx", "ahctx", " avcomm", "vrjac", "avectx", "abctx", " avcp", "avecontext", "ivercontent", "afctx", "Avcontext", "avcomm", "abconn", "avconn", "vrcontent", "obconn", "aveconn", "iverctx", "obcu", "vercmd", "vercmp", " avconn", "ahcu", "aircontent", "navreq", "abtx", "avjac", "ahcomm", "avcmp", "obctx"], "s": ["fs", "rs", "sb", "ants", "n", "settings", "ations", "ses", "conv", "x", "sql", "S", "os", "space", "c", "q", "ps", "conf", "er", "sys", "es", "an", "socket", "ssl", "us", "hs", "gs", "b", "ats", "its", "js", "as", "ctx", "sts", "ims", "csv", "bis", "sq", "sw", "css", "self", "ds", "cs", "ts", "sc", "is", "south", "ins", "stats", "qs", "obj", "ains", "scl", "ns", "ss"], "buf1": ["aka01", "aka3", "bu100", "buache", "buffer0", "cam1", "vec11", "cb1", "cache1", "bufable", "buf001", "cmd0", "bu15", "bu0", "ufed", "cache0", "buable", "bu2", " buffer2", "tmp1", "uf01", "cam0", "uf1", "braceache", "uf21", "Buff1", "vecOne", "iteratorache", "ufaj", "uf3", "akaable", " buf2", "uf512", "iterator1", "vec2", "bag3", "buone", " buf7", "brace1", "que15", "buf8", " buffer8", "cbOne", "buff21", "cmd1", "bag0", " buffer3", "buffn", " bufn", "buff15", "buffer1", "buf100", "buf01", "bufed", "buf21", "batchone", " buffer1", "buff7", "buff001", "img1", "camOne", "buff1", "bu21", "pkg1", "pool11", "uf7", "buf512", "buOne", "buff0", "bufone", "tmp3", "ufone", "iteratored", "buf11", "batch1", "poolone", "uf11", "img3", "vec1", "cam2", "buff100", "buffern", "buf2", "buffaj", "cb100", " buf8", "cache3", "buffer2", "braceed", "buff3", "bufOne", "bu3", "batch3", "tmpOne", "Buff3", "buffOne", "uf001", "bufache", "pkgOne", "imgOne", "buffer3", " bufOne", "pool1", "buf0", "que01", "vecone", "uf8", "tmp2", "buf3", "vec3", "buf7", "Buff2", "buffone", "aka1", "uf15", "bufn", "pkgone", "bagaj", "Buffaj", "cmd2", "que1", "bufaj", "bu1", "uf2", "batchache", "cmdone", "bag1", "bu512", " buf0", "ufache", "ufable", "pkg2", "uf0", "buff2", "cache001", "Buff001", "img15", "pool3", "ufn", "buff512", "buffache", "ufOne", "aka15", "cb3", "buf15", " buf3"], "tuple_type": ["tour2types", "conv", "tuple2name", "tour2type", "_", "tour2Type", "tuple2types", "def", "tuple_val", "tour_val", "tuple__val", "tour_type", "tuple__type", "tuple2val", "tuple__types", "tour2val", "tuple2Type", "tuple2type", "tour_types", "tour_Type", "cont", "tuple_types", "func", "tuple_name", "tuple__Type", "tuple_Type"], "h": ["i", "ch", "d", "l", "n", "k", "z", "x", "c", "q", "bh", "hw", "hi", "hz", "H", "p", "r", "height", "m", "hr", "dr", "hs", "b", "len", "hl", "ih", "he", "id", "g", "html", "sh", "j", "hp", "hal", "t", "oh", "hm", "v", "y", "ph", "wh", "high", "ht"], "w": ["wl", "d", "l", "kw", "n", "nw", "wal", "z", "x", "wi", "q", "hw", "wat", "words", "p", "wp", "r", "m", "height", "ww", "wr", "window", "W", "wa", "g", "wt", "sw", "wid", "iw", "we", "work", "fw", "aw", "rw", "wx", "v", "wh", "wb", "wd"], "depth": ["pkg", "context", "d", "type", "th", "time", "level", "stack", "padding", "history", "hash", "q", "Depth", "weight", "scale", "hi", "root", "ps", "p", "tree", "r", "height", "ptr", "hr", "m", "dr", "where", "dim", "trace", "window", "dev", "deep", "volume", "path", "dir", "max", "dq", "t", "debug", "metadata", "wcs", "v", "length", "ths", "reverse"], "maxval": ["MAXvals", "Maxval", "MAXval", " maxVAL", "lastvalue", "maxVAL", " maxVal", "maxvals", "MaxVAL", "maxvalue", "MAXVAL", " maxvalue", "lastval", "maxVal", "MAXVal", "MAXvalue", " maxvals", "Maxvalue", "Maxvals", "lastVal", "lastVAL"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,\n\n                            int len, int is_write)\n\n{\n\n    return address_space_rw(&address_space_memory, addr, buf, len, is_write);\n\n}\n", "idx": 14076, "substitutes": {"addr": ["pkg", "ind", "ref", "address", "ag", "Address", "alloc", "tx", "off", "src", "hw", "dh", "adr", "loc", "r", "err", "store", "add", "ptr", " plat", "et", "urg", "handle", "mk", "target", "pos", "ctx", "eth", "ack", "index", "to", "at", "act", "ad", "offset", "inter", " address", "coord", "attr", "ix", "align", "pad", "cmd", "rt", "on"], "buf": ["uf", "queue", "ref", "bar", "map", "bytes", "bc", " buffers", "alloc", "bf", " buff", "Buff", "cb", "arr", "vec", "batch", "img", "ptr", "cast", " buffer", "buff", "mem", "b", "window", "buffer", "block", "cv", "Buffer", "msg", "data", "seq", "pad", "cmd", "aka", " vec"], "len": ["un", "h", "rel", "lis", "l", "lp", "n", "elt", "bytes", "sl", "kl", " clen", " length", "pos", "mem", "ln", "nt", "hl", "fun", "size", "lf", "coll", "lim", "en", "seq", "fil", "el", "fl", "nl", "fin", "lib", "ld", "le", "Len", "length", "lan"], "is_write": ["is_w", "is_only", " is_read", " is_Write", "is_set", " is_set", "is_read", "is__set", "is__write", "is__Write", " is_only", " is_w", "is__only", "is_Write"]}}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_link(void *opaque)\n\n{\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n    int32_t dfid, oldfid;\n\n    V9fsFidState *dfidp, *oldfidp;\n\n    V9fsString name;\n\n    size_t offset = 7;\n\n    int err = 0;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n\n\n    dfidp = get_fid(pdu, dfid);\n\n    if (dfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    oldfidp = get_fid(pdu, oldfid);\n\n    if (oldfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out;\n\n    }\n\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n\n    if (!err) {\n\n        err = offset;\n\n    }\n\nout:\n\n    put_fid(pdu, dfidp);\n\nout_nofid:\n\n    v9fs_string_free(&name);\n\n    complete_pdu(s, pdu, err);\n\n}\n", "idx": 14090, "substitutes": {"opaque": ["popacity", "ocatile", "posit", "roposit", "pvious", "oppaque", "oppatile", "opvious", "ropaque", "ioposit", "iopvious", "iopque", "oppacity", "popque", "pque", "popatile", "ropvious", "ocacity", "opque", "oppque", "popaque", "iopaque", "paque", "opacity", "opatile", "ocque", "ropque", "ocaque", "oposit"], "pdu": ["prci", "psue", "pertu", "ipu", " Pju", "qtu", " pdem", "mud", "produ", "psci", "prdu", "cpdef", "proud", "ppdi", "pci", "psow", "mdu", "psder", " pue", " pdi", "pda", "Psu", " Psu", "mtu", "pso", "mda", "apdem", "qso", "apso", "prud", "prosu", "ptu", "cpud", "cpue", " pui", "Ptu", "ppder", "psu", "cpdu", "persu", "pder", "pptu", "proju", " Pdu", "apdu", "perdu", " pso", " Pud", "opdu", "iptu", "puu", "pingud", "ipcu", "pdem", "psdi", "pstu", "pdef", "quu", " pud", "pingdu", "ipud", "pcu", "ipdu", "opu", "prow", "Pue", "psdu", "ppui", " pju", "pdi", " pdef", "pju", "aptu", "cso", "Pui", "opcu", "prtu", "Pso", "optu", " psu", "perud", "cdu", " ptu", "ctu", "apud", "pu", "qdu", "pingsu", "cuu", "Pdem", " pder", "ppdu", "perdef", "pue", "prda", "ipda", "perue", "apsu", " puu", "pingtu", "pscu", " pci", "Pdu", "pui", "ppue", "pud"], "s": ["bs", "h", "i", "fs", "d", "rs", "sg", "n", "sb", "z", "ies", "S", "os", "session", "state", "c", "sv", "ps", "p", "sys", "r", "es", "set", "m", "gs", "b", "e", "js", "as", "sp", "g", "sq", "less", "t", "ds", "cs", "ts", "is", "o", "a", "sm", "v", "y", "f", "ins", "stats", "ns", "ss"], "dfid": ["ufident", "diskand", "pdfhide", "lfID", "dxid", "dfand", "fdh", "dfoid", " defip", "dfpid", "dxID", "diskid", "lfident", "DFID", "diskoid", "dfhide", "pdfand", "fdident", "dfID", "ufid", "dfh", " defID", " dfident", "pdfoid", " dfh", "fpoid", "dfident", "fdid", "dfip", "DFid", "lfh", "lfid", "DFident", "diskhide", "fpand", "dxip", "dxpid", " defpid", "fpid", "pdfid", " dfpid", "fphide", "ufID", "fdID", " defid", " dfID", " dfip"], "oldfid": ["oldifid", "oldvid", " oldvid", "oldferide", "oldfdbid", "oldFid", "oldFids", " oldFids", "olderFid", "oldfID", "olderFids", "olderfid", "oldfdids", "oldfsids", "oldFide", " oldvId", "oldfids", "olderfId", "oldvide", "oldfsId", " oldfbid", "oldfsID", "oldFbid", "oldfsid", "oldfdId", "olderFID", "oldvids", "oldferId", " oldFId", "oldfbid", " oldfId", "oldferid", "oldvId", " oldfids", "oldfId", "oldvID", "oldifID", "oldifId", "olderfids", "olderfID", "olderFId", " oldfide", "oldFId", "oldfide", " oldFid", "oldvbid", " oldvide", "oldFID", "oldfdid", " oldFbid"], "dfidp": ["dfhidep", "dfidwp", "dfkidpp", "dfidm", "dfidephp", "cfidentps", "dfhidephp", "tfidentm", "tfidentp", "definedmidp", "dfoidj", "dfkidps", "dfcharpp", "dfmidj", "dfidentlp", "dfinitwp", "dfkidwp", "dfsidpid", "cfidwp", "dfkidp", " dfkidj", "dfidpid", "dfidentpa", " dfkidp", "dfkidh", "dfidentps", "dfidentpid", " dfidlike", "dfkidj", "dfkidpc", "dfoidp", " dfoidpa", "dfidepa", "cfidps", "dfidj", "dfidentp", "dfidenth", " dfkidh", "dfmidpy", "definedidpa", "cfidentwp", "cfidp", "dfidentj", "dfcharj", "tfidp", "tfidentlp", "tfidpid", "dfidentpp", "dfnamepid", "dfcharp", "dfidlp", "dfidentpc", " dfidj", "definedidpy", "dfhidepa", "dfnamem", "dfidentm", "dfinitpc", "dfoidlike", "dfmidp", "dfinitp", "dfidpa", "dfidlike", "tfidentpid", " dfoidp", "dfidepy", "cfidentp", "definedmidphp", " dfoidlike", "cfidentpc", "dfidentlike", "dfnamelp", "dfcharh", "dfsidm", "dfidpc", "dfsidlp", "dfinitps", "dfidep", "dfoidpa", " dfidpp", "dfmidphp", "dfidh", " dfoidj", "dfsidp", "cfidpc", "dfidpy", "dfmidlike", "dfidpp", " dfkidpp", " dfidh", "tfidlp", " dfidpa", "dfmidpa", "definedidphp", "dfidps", "definedidp", "dfidphp", "dfhidepy", "tfidm", "dfidentwp", "definedmidpa", "definedmidpy", "dfnamep"], "oldfidp": ["oldfoidP", "oldfoidpolicy", "oldfaidP", "oldfidpoint", "oldfmidpoint", "oldvidm", "oldhidp", "oldfdidp", "oldfdidpb", "oldfidpb", "oldvIdm", "oldfmemp", "oldvpidpoint", "oldfoidp", "oldvidpoint", "oldfitP", "oldfdidpoint", "oldhoidp", "oldfIdP", "oldfidP", "oldhidP", "oldhidps", "oldvIdP", "oldfIdps", "oldfmidp", "oldfitp", "oldfmemm", "oldvIdp", "oldfitpa", "oldhoidP", "oldfidpa", "oldhoidps", "oldfIdpolicy", "oldfidpolicy", "oldhoidpolicy", "oldvidp", "oldfoidps", "oldvpidpb", "oldfitm", "oldvidps", "oldvpidp", "oldvIdps", "oldfmidpb", "oldfIdm", "oldfpidpb", "oldfIdpa", "oldvidpb", "oldfaidps", "oldvidpa", "oldvIdpa", "oldfIdp", "oldvidP", "oldfidps", "oldhidpolicy", "oldfpidp", "oldfaidp", "oldfpidpoint", "oldfmempa", "oldfaidpolicy", "oldfmemP", "oldfidm"], "name": ["info", "ref", "type", "version", "prefix", "package", "n", "Name", "nam", "null", "word", "error", "out", "title", "local", "NAME", "c", "new", "cn", "alias", "message", "named", "r", "err", "nm", "key", "qual", "mem", "san", "e", "chain", "names", "reason", "no", "path", "na", "id", "size", "str", "cap", "msg", "data", " Name", "comment", "filename", "attr", "self", "part", "ame", "text", "base", "var", "v", "user", "f", "w", "scope", "ns"]}}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "int dxva2_init(AVCodecContext *s)\n\n{\n\n    InputStream *ist = s->opaque;\n\n    int loglevel = (ist->hwaccel_id == HWACCEL_AUTO) ? AV_LOG_VERBOSE : AV_LOG_ERROR;\n\n    DXVA2Context *ctx;\n\n    int ret;\n\n\n\n    if (!ist->hwaccel_ctx) {\n\n        ret = dxva2_alloc(s);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n    ctx = ist->hwaccel_ctx;\n\n\n\n    if (s->codec_id == AV_CODEC_ID_H264 &&\n\n        (s->profile & ~FF_PROFILE_H264_CONSTRAINED) > FF_PROFILE_H264_HIGH) {\n\n        av_log(NULL, loglevel, \"Unsupported H.264 profile for DXVA2 HWAccel: %d\\n\", s->profile);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (s->codec_id == AV_CODEC_ID_HEVC &&\n\n        s->profile != FF_PROFILE_HEVC_MAIN && s->profile != FF_PROFILE_HEVC_MAIN_10) {\n\n        av_log(NULL, loglevel, \"Unsupported HEVC profile for DXVA2 HWAccel: %d\\n\", s->profile);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    av_buffer_unref(&ctx->hw_frames_ctx);\n\n\n\n    ret = dxva2_create_decoder(s);\n\n    if (ret < 0) {\n\n        av_log(NULL, loglevel, \"Error creating the DXVA2 decoder\\n\");\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14108, "substitutes": {"s": ["bs", "fs", "ps", "args", "irs", "ms", "ports", "js", "g", "sw", "sc", "ins", "details", "h", "changes", "sb", "results", "os", "als", "sv", "set", "m", "sports", "ags", "t", "times", "is", "stat", "parts", "ns", "mods", "l", "rs", "ies", "S", "c", "comm", "eps", "st", "sys", "ls", "vs", "hs", "ats", "its", "ims", "sq", "sets", "ts", "o", "a", "qs", "params", "ss", "sts", "i", "aunts", "n", "settings", "ses", "p", "es", "xs", "aws", "gs", "b", "spec", "less", "ds", "cs", "v", "stats", "scl"], "ist": ["dist", "ind", "xp", "ith", "pect", "art", "esp", "dit", "ast", "st", "pas", "isting", "ost", "xt", "tif", "ust", "ess", "wp", "istant", "nil", "ism", "ish", "ilst", "iss", "ive", "ert", "IS", "erd", "ih", "sts", "exist", "imm", "ict", "iste", "inst", "IST", "alist", "assert", "typ", "pt", "is", "isi", "oci", "ists", "ush", "ista", "hist", "ht", "htt", "irst", "est"], "ctx": ["pkg", "context", "jp", "voc", "kw", "tmp", "bc", "ck", "txt", "tx", "conv", "ctl", "cmp", "cm", "np", "c", "cp", "hw", "cb", "Context", "loc", "p", "mc", "cam", "jac", "cfg", "mem", "tc", "nt", "cc", "window", "sp", "gc", "cv", "kt", "cf", "act", "conn", "ct", "ctr", "ca", "nc", "sc", "cmd", "ac", "kb", "obj", "co"], "ret": ["usr", "ft", "jp", " alt", "RT", "RET", "elt", "lt", "dt", "nz", "status", "txt", "ber", "out", "re", "value", "hash", "reg", "reflect", "Ret", "result", "ort", "ext", " RET", "pas", "def", "arr", "r", "err", "tr", "ry", "flag", "alt", "att", "nt", "cert", "rev", "ert", "iter", "len", "gc", "fun", "cont", "res", "str", "back", "after", "rm", "mt", "det", "gt", "try", "utils", "t", "ll", "ter", "net", "rets", " Ret", "resp", "rt", "deg", "val", "print", "cmd", "reset", "rem"]}}
{"project": "qemu", "commit_id": "d4cd45028898a37afb45fb449954115b4960d4e9", "target": 0, "func": "static XenPTBarFlag xen_pt_bar_reg_parse(XenPCIPassthroughState *s,\n\n                                         XenPTRegInfo *reg)\n\n{\n\n    PCIDevice *d = &s->dev;\n\n    XenPTRegion *region = NULL;\n\n    PCIIORegion *r;\n\n    int index = 0;\n\n\n\n    /* check 64bit BAR */\n\n    index = xen_pt_bar_offset_to_index(reg->offset);\n\n    if ((0 < index) && (index < PCI_ROM_SLOT)) {\n\n        int type = s->real_device.io_regions[index - 1].type;\n\n\n\n        if ((type & XEN_HOST_PCI_REGION_TYPE_MEM)\n\n            && (type & XEN_HOST_PCI_REGION_TYPE_MEM_64)) {\n\n            region = &s->bases[index - 1];\n\n            if (region->bar_flag != XEN_PT_BAR_FLAG_UPPER) {\n\n                return XEN_PT_BAR_FLAG_UPPER;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* check unused BAR */\n\n    r = &d->io_regions[index];\n\n    if (!xen_pt_get_bar_size(r)) {\n\n        return XEN_PT_BAR_FLAG_UNUSED;\n\n    }\n\n\n\n    /* for ExpROM BAR */\n\n    if (index == PCI_ROM_SLOT) {\n\n        return XEN_PT_BAR_FLAG_MEM;\n\n    }\n\n\n\n    /* check BAR I/O indicator */\n\n    if (s->real_device.io_regions[index].type & XEN_HOST_PCI_REGION_TYPE_IO) {\n\n        return XEN_PT_BAR_FLAG_IO;\n\n    } else {\n\n        return XEN_PT_BAR_FLAG_MEM;\n\n    }\n\n}\n", "idx": 14126, "substitutes": {"s": ["details", "h", "i", "fs", "l", "rs", "n", "sb", "settings", "status", "ses", "S", "os", "session", "state", "http", "service", "sv", "c", "ps", "ss", "comm", "st", "p", "sys", "es", "ssl", "m", "ls", "sports", "hs", "aws", "gs", "b", "js", "sp", "spec", "services", "sd", "sq", "sw", "less", "t", "ds", "self", "se", "states", "ts", "is", "a", "south", "v", "stats", "ins", "sis", "qs", "ns", "sts"], "reg": ["ref", "sg", "asm", "memory", "br", "Reg", "gro", "re", "eng", "tag", "scan", "REG", "disc", "err", "raw", "mem", "greg", "rr", "gc", "eg", "ro", "g", "rg", "res", "decl", "range", "rar", "row", "conn", "debug", "snap", "resp", "rest", "rec", "grid", "gra", "rem"], "d": ["dn", "device", "dl", "h", "ind", "l", "dm", "n", "dx", "dt", "dom", "di", "dc", "session", "c", "dh", "p", "m", "dr", "b", "pd", "dev", "db", "dd", "D", "g", "j", "ad", "sd", "driver", "t", "ds", "v", "w"], "region": ["ge", "address", "component", "memory", "division", "summary", "local", "ion", "slot", "pool", "state", "usage", "dimension", "resource", "global", "argument", "root", "p", "country", "REG", "Region", "port", "b", "chain", "domain", "network", "reference", "buffer", "remote", "member", "gc", "g", "rg", "record", "module", "variable", "description", "rar", "zone", "character", "t", "config", "section", "table", "scope", "command", "option", "relation", "location"], "r": ["h", "i", "l", "rs", "br", "rb", "re", "ar", "c", "u", "p", "m", "R", "dr", "rd", "b", "e", "rc", "rr", "ro", "rg", "g", "rn", "res", "j", "rar", "rm", "sr", "mr", "t", "rt", "cr", "v", "f", "w"]}}
{"project": "FFmpeg", "commit_id": "50c466d609ec60a324a7a776dfdb57c8d38faa11", "target": 1, "func": "static av_cold int g726_encode_init(AVCodecContext *avctx)\n\n{\n\n    G726Context* c = avctx->priv_data;\n\n\n\n    if (avctx->strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL &&\n\n        avctx->sample_rate != 8000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Sample rates other than 8kHz are not \"\n\n               \"allowed when the compliance level is higher than unofficial. \"\n\n               \"Resample or reduce the compliance level.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if (avctx->sample_rate <= 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Samplerate is invalid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels != 1){\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono is supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (avctx->bit_rate % avctx->sample_rate) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitrate - Samplerate combination is invalid\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    c->code_size = (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate;\n\n    if (c->code_size < 2 || c->code_size > 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid number of bits %d\\n\", c->code_size);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    avctx->bits_per_coded_sample = c->code_size;\n\n\n\n    g726_reset(c, c->code_size - 2);\n\n\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n    avctx->coded_frame->key_frame = 1;\n\n\n\n    /* select a frame size that will end on a byte boundary and have a size of\n\n       approximately 1024 bytes */\n\n    avctx->frame_size = ((int[]){ 4096, 2736, 2048, 1640 })[c->code_size - 2];\n\n\n\n    return 0;\n\n}\n", "idx": 14141, "substitutes": {"avctx": [" avjac", "avercontext", "ajcu", "avercp", "averpy", " avcmp", "averconn", "avtx", "avecfg", "ajconn", " avreq", "ajpkg", "avcfg", "wavcp", " avcontext", "afnp", "ravpkg", "avecp", "ajctl", " avca", "avconfig", "avepy", "avct", "ajtx", "avereq", "avtmp", "avca", "ajctx", "avkw", " savcp", "avepkg", "abpkg", "ivercrit", "afcontext", " savcontext", "avertmp", "navdl", "avecu", "avermsg", "avcmd", "avernp", "iverconn", "abcrit", "averctl", "avpkg", "navctx", "averctx", "aveaddr", "navpkg", "averct", "avloc", "aftxt", "avhistory", "avejac", "averkt", "avectx", "navnp", " avcp", "avjp", "afctx", "iverpkg", "avekl", "averaddr", "abconn", " avpkg", "navcfg", "avemsg", "ajjac", " avconn", "ajpy", "ravjp", "avjac", "averdl", "afcp", "ravctx", "aveconfig", "ajkl", "avcu", "avkt", "avehistory", "avergc", "ravgc", "ajca", "avcontext", "avercmd", "avmsg", "avercfg", "ajkt", "avecontext", "abctx", " avkw", " avaddr", "wavpkg", "afcmd", "ravcu", "ajhistory", "iverctx", " avdl", " savcmp", "averkw", "ajcfg", "ajaddr", "ajcmd", " avkl", "averreq", "navreq", "averpkg", "avnp", "ajcontext", " savctx", "avcmp", "wavtx", "avgc", "averjac", "avpy", " avcmd", "avetmp", "ajtxt", "afreq", "avcp", "avekt", "avdl", "averjp", "averloc", "avcrit", "avtxt", " avloc", "avercmp", "avertxt", "avercrit", " avcfg", "avetxt", "ajkw", "aveca", "avkl", "afpkg", "ajconfig", "ajmsg", "ravconfig", "afcmp", "ajcp", "avetx", "averca", "wavcfg", "ravjac", "aveloc", "avctl", " avtx", " avctl", "wavctx", "wavgc", "ajct", "avertx", "avecmd", "wavtmp", "avecmp", "avconn", "aveconn", "averhistory", "avaddr", "avect", "wavjp", "avreq", "navcontext"], "c": ["abc", "context", "vc", "ch", "d", "l", "con", "cache", "n", "pc", "bc", "lc", "unc", "dc", "etc", "cur", "cmp", "cm", "cp", "xc", "cu", "conf", "cb", "p", "mc", "cam", "m", "C", "b", "tc", "chain", "cc", "rc", "com", "e", "ctx", "gc", "cv", "spec", "csv", "ce", "g", "cont", "cf", "ci", "cl", "ct", "enc", "ic", "anc", "ec", "t", "ca", "cs", "fc", "comments", "config", "a", "ac", "cr", "v", "f", "w", "call", "co"]}}
{"project": "FFmpeg", "commit_id": "8332321c5737cf24ebad504bf10a03818424718d", "target": 1, "func": "static int dv_read_seek(AVFormatContext *s, int stream_index,\n\n                       int64_t timestamp, int flags)\n\n{\n\n    RawDVContext *r   = s->priv_data;\n\n    DVDemuxContext *c = r->dv_demux;\n\n    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);\n\n\n\n    dv_offset_reset(c, offset / c->sys->frame_size);\n\n\n\n    offset = avio_seek(s->pb, offset, SEEK_SET);\n\n    return (offset < 0) ? offset : 0;\n\n}\n", "idx": 14144, "substitutes": {"s": ["bs", "h", "d", "fs", "rs", "sn", "n", "sb", "ses", "os", "als", "S", "q", "comm", "ss", "ps", "er", "p", "sys", "es", "ls", "hs", "aws", "ms", "gs", "b", "ats", "its", "js", "as", "spec", "g", "sq", "sr", "ds", "self", "cs", "ts", "sc", "is", "a", "v", "stats", "y", "qs", "w", "ns", "sts"], "stream_index": ["ream_column", "streamidcolumn", "streamidnum", "reamidcolumn", "streamidindex", "streamidind", "reamidnum", "reamidind", "ream_num", "ream_index", "stream_num", "ream_ind", "reamidindex", "stream_ind", "stream_column"], "timestamp": ["Timest", "image", "datest", "imest", "imeness", "Timestamp", "timetime", "Timeness", "timest", "temestamp", "datage", "timage", "imestamp", "dateness", "datestamp", " timace", "Timage", " timetime", "temace", "Timetime", "temetime", "temest", " timest", "Timace", "timace", "timeness"], "flags": ["doms", "ants", "months", "ensions", "reports", "amps", "styles", "dds", "FLAG", "fields", "links", "weights", "atts", "args", "options", "uploads", "faces", "features", "flag", "Flags", "ats", "ports", "events", "members", "locks", "tags", "ags", "properties", "acts", "comments", "bits", "types", "errors", "stats", "grades", "lag", "mask", "posts"], "r": ["i", "h", "d", "rs", "ra", "br", "rb", "re", "ar", "q", "er", "p", "m", "R", "rd", "ir", "rc", "rh", "nr", "rect", "ro", "rg", "res", "g", "rl", "rar", "sr", "mr", "rw", "rt", "kr", "cr", "v", "or", "w"], "c": ["vc", "d", "ch", "l", "con", "cache", "pc", "bc", "lc", "unc", "dc", "cm", "cp", "xc", "cu", "cb", "p", "mc", "m", "C", "b", "e", "tc", "cc", "rc", "ctx", "gc", "cv", "ce", "cf", "ct", "enc", "ic", "ec", "t", "ca", "cs", "fc", "sc", "ac", "v", "f", "co"]}}
{"project": "qemu", "commit_id": "788d2599def0e26d92802593b07ec76e8701ccce", "target": 1, "func": "static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler,\n\n                                     DeviceState *plugged_dev, Error **errp)\n\n{\n\n    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));\n\n    PCIDevice *pdev = PCI_DEVICE(plugged_dev);\n\n    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);\n\n    Error *local_err = NULL;\n\n\n\n    /* if DR is disabled we don't need to do anything in the case of\n\n     * hotplug or coldplug callbacks\n\n     */\n\n    if (!phb->dr_enabled) {\n\n        /* if this is a hotplug operation initiated by the user\n\n         * we need to let them know it's not enabled\n\n         */\n\n        if (plugged_dev->hotplugged) {\n\n            error_setg(errp, QERR_BUS_NO_HOTPLUG,\n\n                       object_get_typename(OBJECT(phb)));\n\n        }\n\n        return;\n\n    }\n\n\n\n    g_assert(drc);\n\n\n\n    spapr_phb_add_pci_device(drc, phb, pdev, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (plugged_dev->hotplugged) {\n\n        spapr_hotplug_req_add_by_index(drc);\n\n    }\n\n}\n", "idx": 14162, "substitutes": {"plug_handler": ["pluginghand", "plug_hand", "plug_device", "plug_handle", "plugitydevice", "plugityhand", " plug_job", " plug_handle", "pluggehandler", "pluglydevice", " plug_device", "plugingdevice", "plug_job", "pluggehandle", "pluglyhandle", "plugityhandler", "plug_reader", "plugityreader", "switch_hand", "switchinghand", "switchinghandler", "pluginghandler", "switchingreader", "pluglyjob", "pluggejob", "pluglyhandler", "switch_device", "switchingdevice", "pluggedevice", "switch_reader", "plugingreader", "switch_handler"], "plugged_dev": ["plugged_conf", "pluggedingve", "plugge_DEV", "plugged_serial", "pluglockedptDEV", "pluglocked_dev", "plugged_Dev", "plugge_device", "plugge_dev", "pluglockedptconf", "plugging_device", "pluggedptDEV", "pluggedingpub", "plugging_pub", "pluglockedptdev", "plugged_DEV", "plugged_pub", "plugging_Dev", "plugged_device", "plugged2device", "plugging_ve", "pluggedptdev", "pluggedingdevice", "plugging_dev", "pluglocked_serial", "plugged_ve", "pluggedptserial", "plugged2dev", "plugge_ev", "plugged2ev", "plugged_ev", "pluggedingdev", "pluglocked_DEV", "plugging_ev", "plugged2Dev", "pluglockedptserial", "pluglocked_conf", "pluggedptconf"], "errp": ["ererp", "aerp", " errP", "arrpb", " errpy", "arrp", "ererpat", " errpb", "aerpat", "errpad", "aerpb", "rrpy", "errpb", "errP", "ererpb", "eorp", "aerP", "rrp", "diepad", "rrpb", " errpat", "ererP", "arrpad", "errpat", "eorpy", "diep", "eorpb", "diepb", "dieP", "arrP", "errpy", " errpad"], "phb": [" phbb", "pheB", "ppb", "mphb", "phc", "holbe", "pherb", "holwb", "palbb", "ppj", "hpb", "phwb", "cmdb", " phB", "pherB", "PHB", "iphb", "PHb", "mphB", "palb", "cmdbb", "phB", "palr", "phbt", "hpbt", "ppB", "cmdr", "khb", "hpwb", " phnb", "khr", "iphwb", "holb", "phr", "mphj", "iphbe", "iphbt", "mphc", "phj", "phnb", "PHc", "mphr", "mphbb", "phenb", "khB", "phbe", "phebb", "phbb", "pherbb", "hpbe", "ppc", "holbt", "phernb", "khbb", "palB", " phr", "PHj", "pheb"], "pdev": [" pdevices", " pdevice", " praw", "pdef", "apgu", "pcdev", "pcgu", "pcmem", "pcraw", "graw", "praw", "Pdevice", "pDev", " pgu", "pgu", "Pdev", "pdevice", "pcDev", "apdev", "gev", "Pdef", " pDev", "pcdevice", " pdef", "pcdevices", "Pdevices", "gdev", "pdevices", " pev", "apmem", "pcev", " pmem", "pcdef", "pev", "apDev", "pmem", "gdevice"], "drc": ["gric", "didiq", "dric", "pric", "zoc", "drs", "grc", "drent", "zRC", "isdfc", " dric", " drs", "grs", "Drent", "didric", "gRC", "DRC", "Doc", "Dric", " darc", "Dfc", "isdrc", "darc", " doc", "Diq", "dRC", "prc", "zarc", " drent", "Drc", " dfc", "isdRC", "Drs", " dRC", "piq", "dfc", "Darc", "isdrent", "didrc", "zrc", "doc", "diq", "didRC", "pRC"], "local_err": ["local__e", "localitydata", "loc_rr", " local_conn", "localityerr", "local__er", "local_plain", "local__error", "localityrr", " local_e", "local__ev", "local__err", "local__conn", "local___conn", "loc_usr", "local___err", " local_ev", "localmyer", "localmyplain", "local_error", "local_ev", "loc_data", "local_rr", "loc_err", "local_e", "localmyfr", "local_data", "local___er", " local_error", "local___e", " local_fr", "local_fr", "localmyerr", "local_er", "local_usr", " local_plain", " local_er", "localityusr", "local_conn"]}}
{"project": "FFmpeg", "commit_id": "70d54392f5015b9c6594fcae558f59f952501e3b", "target": 0, "func": "av_cold int ff_dvvideo_init(AVCodecContext *avctx)\n\n{\n\n    DVVideoContext *s = avctx->priv_data;\n\n    DSPContext dsp;\n\n    static int done = 0;\n\n    int i, j;\n\n\n\n    if (!done) {\n\n        VLC dv_vlc;\n\n        uint16_t new_dv_vlc_bits[NB_DV_VLC*2];\n\n        uint8_t  new_dv_vlc_len[NB_DV_VLC*2];\n\n        uint8_t  new_dv_vlc_run[NB_DV_VLC*2];\n\n        int16_t  new_dv_vlc_level[NB_DV_VLC*2];\n\n\n\n        done = 1;\n\n\n\n        /* it's faster to include sign bit in a generic VLC parsing scheme */\n\n        for (i = 0, j = 0; i < NB_DV_VLC; i++, j++) {\n\n            new_dv_vlc_bits[j]  = dv_vlc_bits[i];\n\n            new_dv_vlc_len[j]   = dv_vlc_len[i];\n\n            new_dv_vlc_run[j]   = dv_vlc_run[i];\n\n            new_dv_vlc_level[j] = dv_vlc_level[i];\n\n\n\n            if (dv_vlc_level[i]) {\n\n                new_dv_vlc_bits[j] <<= 1;\n\n                new_dv_vlc_len[j]++;\n\n\n\n                j++;\n\n                new_dv_vlc_bits[j]  = (dv_vlc_bits[i] << 1) | 1;\n\n                new_dv_vlc_len[j]   =  dv_vlc_len[i] + 1;\n\n                new_dv_vlc_run[j]   =  dv_vlc_run[i];\n\n                new_dv_vlc_level[j] = -dv_vlc_level[i];\n\n            }\n\n        }\n\n\n\n        /* NOTE: as a trick, we use the fact the no codes are unused\n\n           to accelerate the parsing of partial codes */\n\n        init_vlc(&dv_vlc, TEX_VLC_BITS, j,\n\n                 new_dv_vlc_len, 1, 1, new_dv_vlc_bits, 2, 2, 0);\n\n        assert(dv_vlc.table_size == 1184);\n\n\n\n        for (i = 0; i < dv_vlc.table_size; i++){\n\n            int code = dv_vlc.table[i][0];\n\n            int len  = dv_vlc.table[i][1];\n\n            int level, run;\n\n\n\n            if (len < 0){ //more bits needed\n\n                run   = 0;\n\n                level = code;\n\n            } else {\n\n                run   = new_dv_vlc_run  [code] + 1;\n\n                level = new_dv_vlc_level[code];\n\n            }\n\n            ff_dv_rl_vlc[i].len   = len;\n\n            ff_dv_rl_vlc[i].level = level;\n\n            ff_dv_rl_vlc[i].run   = run;\n\n        }\n\n        ff_free_vlc(&dv_vlc);\n\n    }\n\n\n\n    /* Generic DSP setup */\n\n    ff_dsputil_init(&dsp, avctx);\n\n    ff_set_cmp(&dsp, dsp.ildct_cmp, avctx->ildct_cmp);\n\n    s->get_pixels = dsp.get_pixels;\n\n    s->ildct_cmp = dsp.ildct_cmp[5];\n\n\n\n    /* 88DCT setup */\n\n    s->fdct[0]     = dsp.fdct;\n\n    s->idct_put[0] = dsp.idct_put;\n\n    for (i = 0; i < 64; i++)\n\n       s->dv_zigzag[0][i] = dsp.idct_permutation[ff_zigzag_direct[i]];\n\n\n\n    /* 248DCT setup */\n\n    s->fdct[1]     = dsp.fdct248;\n\n    s->idct_put[1] = ff_simple_idct248_put;  // FIXME: need to add it to DSP\n\n    memcpy(s->dv_zigzag[1], ff_zigzag248_direct, 64);\n\n\n\n    avctx->coded_frame = &s->picture;\n\n    s->avctx = avctx;\n\n    avctx->chroma_sample_location = AVCHROMA_LOC_TOPLEFT;\n\n\n\n    return 0;\n\n}\n", "idx": 14168, "substitutes": {"avctx": [" avjac", "ivctx", "cvcontext", " avcmp", "ivcontext", "AVcontext", "AVctx", "avcontext", " avcontext", "cvctx", "avectx", "avecontext", " avconf", "avecmp", "avconf", "cvcmp", "ivcmp", "cvjac", "aveconf", "AVconf", "avjac", "avcmp", "ivjac", "AVcmp"], "s": ["h", "d", "fs", "n", "sb", "x", "S", "c", "sv", "ps", "p", "sys", "m", "b", "js", "w", "spec", "g", "sq", "t", "ds", "cs", "sc", "v", "ns", "ss"], "dsp": ["dlp", "Dp", " dSP", " dlp", "Dsp", "dnlp", "DSP", "dnsp", "dSP", " dp", "dp", "dnp", "dnSP", "Dlp"], "i": ["h", "ind", "info", "ai", "ii", "ji", "n", "gi", "series", "status", "di", "json", "x", "ij", "ip", "ti", "li", "hi", "\u0438", "I", "p", "ei", "list", "si", "m", "ri", "key", "name", "im", "e", "multi", "in", "ims", "index", "iu", "id", " ii", "at", "it", "me", "uri", "ci", "ie", "xi", "ic", "ki", "ik", "phi", "zi", "ix", "mi", "is", "o", "pi", "v", "by", "bi", "ini", "ui", "y", "iri", "io", "f"], "j": ["bs", "k", "server", "bj", "r", "from", "js", "g", "it", "jc", "pr", "pt", "all", "y", "jit", "h", "d", "and", "ji", "aj", "br", "ij", "ion", "next", "er", "jump", "m", "oj", "jac", "tr", "ja", "at", "res", "uj", "fr", "dj", "other", "t", "ix", "kid", "f", "rel", "ind", "jp", "l", "adj", "off", "q", "err", "si", "key", "im", "note", "index", "job", "kj", "J", "jl", "io", "n", "z", "json", "out", "ip", "p", "jj", "b", "id", "el", "v", "obj"], "dv_vlc": ["dv_plac", "dv_tlt", "dv_wlt", "dv_kltc", "dv_vlpc", "dv_dlc", "dv_wlac", "dv_vlg", "dv__vlcs", "dv_ladc", "dv_tlc", "dv_flc", "dv__flt", "dv__flc", "dv_lvltc", "dv_ladg", "dv_klpc", "dv_klc", "dv_lvlfc", "dv_dlg", "dv_dltc", "dv_ladtc", "dv_flt", "dv_flfc", "dv__vlt", "dv_tltc", "dv__vlc", "dv_tlfc", "dv_ladpc", "dv_wlc", "dv_vltc", "dv_vlfc", "dv_dlpc", "dv_wlcs", "dv_flcs", "dv_plc", "dv_vlcs", "dv__vlac", "dv_fltc", "dv_plt", "dv_flac", "dv_vlt", "dv__flac", "dv_vlac", "dv_lvlc", "dv__flcs", "dv_klg", "dv_plcs", "dv_lvlt"], "new_dv_vlc_bits": ["new_dv_vlp_pieces", "new_dv_vlc__bits", "new_dv_vlb__pieces", "new_dv_vlc__pins", "new_dv_vlc_bit", "new_dv_vlc_bugs", "new_dv_vlp_bytes", "new_dv_vlb_bits", "new_dv_vlcs_bytes", "new_dv_vlcs_flags", "new_dv_vlc_bytes", "new_dv_vlb__bit", "new_dv_vlp_bugs", "new_dv_vlc__bs", "new_dv_vlp_bits", "new_dv_vlp_pins", "new_dv_vlc__pieces", "new_dv_vlb_bs", "new_dv_vlb__bs", "new_dv_vlb_bit", "new_dv_vlc_bs", "new_dv_vlb_pieces", "new_dv_vlcs_bits", "new_dv_vlcs_tops", "new_dv_vlc__bit", "new_dv_vlp_bit", "new_dv_vlc__bugs", "new_dv_vlc_flags", "new_dv_vlb__bits", "new_dv_vlcs_bit", "new_dv_vlc_tops", "new_dv_vlc_pins", "new_dv_vlc_pieces", "new_dv_vlc__bytes", "new_dv_vlcs_len"], "new_dv_vlc_len": ["new_dv_vlc_en", "new_dv_vlcs_l", "new_dv_vlc__l", "new_dv_vlcs_level", "new_dv_vlc_l", "new_dv_vlc__lim", "new_dv_vluc_Len", "new_dv_vlc_lim", "new_dv_vlcs_del", "new_dv_vlcs_lim", "new_dv_vlc__ln", "new_dv_vlc__Len", "new_dv_vlc_gen", "new_dv_vlc_seq", "new_dv_vlcs_len", "new_dv_vluc_en", "new_dv_vlc_ls", "new_dv_vlc_Len", "new_dv_vlcs_lib", "new_dv_vlc__len", "new_dv_vlcs_ln", "new_dv_vlcs_ls", "new_dv_vlc__lib", "new_dv_vlc__ls", "new_dv_vlc_lib", "new_dv_vlc__level", "new_dv_vluc_len", "new_dv_vlc_length", "new_dv_vlcs_Len", "new_dv_vlcs_length", "new_dv_vlc_del", "new_dv_vlcs_gen", "new_dv_vlc_ln", "new_dv_vlc__gen", "new_dv_vluc_seq"], "new_dv_vlc_run": ["new_dv_vlac_roll", "new_dv_vlci_run", "new_dv_vlp_coll", "new_dv_vlac_runs", "new_dv_vlp_run", "new_dv_vlc_path", "new_dv_vlci_runs", "new_dv_vlp_runs", "new_dv_vlcPpath", "new_dv_vlac_run", "new_dv_vlac_path", "new_dv_vlci_roll", "new_dv_vlci_len", "new_dv_vlp_len", "new_dv_vlcProll", "new_dv_vlc_coll", "new_dv_vlcPrun", "new_dv_vlc_runs", "new_dv_vlcPruns", "new_dv_vlc_roll"], "new_dv_vlc_level": ["new_dv_vlcs_levels", "new_dv_vlc__coll", "new_dv_vlc_lvl", "new_dv_vlc_vel", "new_dv_vlc_log", "new_dv_vlc_levels", "new_dv_vlcs_log", "new_dv_vlcs_vel", "new_dv_vlc__len", "new_dv_vlcs_lvl", "new_dv_vlcs_coll", "new_dv_vlcs_level", "new_dv_vlc_coll", "new_dv_vlc__log", "new_dv_vlcs_len", "new_dv_vlc__level"]}}
{"project": "FFmpeg", "commit_id": "4641ae352ec587355764ffd5c43dd0d0ebd47654", "target": 1, "func": "static int libquvi_read_header(AVFormatContext *s)\n\n{\n\n    int i, ret;\n\n    quvi_t q;\n\n    quvi_media_t m;\n\n    QUVIcode rc;\n\n    LibQuviContext *qc = s->priv_data;\n\n    char *media_url, *pagetitle;\n\n\n\n    rc = quvi_init(&q);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    quvi_setopt(q, QUVIOPT_FORMAT, qc->format);\n\n\n\n    rc = quvi_parse(q, s->filename, &m);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    rc = quvi_getprop(m, QUVIPROP_MEDIAURL, &media_url);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    av_assert0(!qc->fmtctx->codec_whitelist && !qc->fmtctx->format_whitelist);\n\n    qc->fmtctx-> codec_whitelist = av_strdup(s->codec_whitelist);\n\n    qc->fmtctx->format_whitelist = av_strdup(s->format_whitelist);\n\n\n\n    ret = avformat_open_input(&qc->fmtctx, media_url, NULL, NULL);\n\n    if (ret < 0)\n\n        goto end;\n\n\n\n    rc = quvi_getprop(m, QUVIPROP_PAGETITLE, &pagetitle);\n\n    if (rc == QUVI_OK)\n\n        av_dict_set(&s->metadata, \"title\", pagetitle, 0);\n\n\n\n    for (i = 0; i < qc->fmtctx->nb_streams; i++) {\n\n        AVStream *st = avformat_new_stream(s, NULL);\n\n        AVStream *ist = qc->fmtctx->streams[i];\n\n        if (!st) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto end;\n\n        }\n\n        avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den);\n\n        avcodec_copy_context(st->codec, qc->fmtctx->streams[i]->codec);\n\n    }\n\n\n\n    return 0;\n\n\n\nquvi_fail:\n\n    av_log(s, AV_LOG_ERROR, \"%s\\n\", quvi_strerror(q, rc));\n\n    ret = AVERROR_EXTERNAL;\n\n\n\nend:\n\n    quvi_parse_close(&m);\n\n    quvi_close(&q);\n\n    return ret;\n\n}\n", "idx": 14199, "substitutes": {"s": ["h", "fs", "d", "mods", "rs", "sg", "changes", "n", "sb", "ses", "S", "os", "c", "sv", "ps", "conf", "comm", "p", "set", "sys", "an", "es", "args", "ls", "sam", "erences", "r", "hs", "aws", "ms", "gs", "ats", "e", "b", "js", "its", "as", "ims", "sts", "spec", "w", "csv", "sq", "sw", "ex", "t", "ds", "times", "cs", "ts", "sc", "source", "a", "south", "is", "v", "ins", "qs", "parts", "scl", "ns", "params", "ss"], "i": [" li", "info", "ai", "ii", "ji", " si", "hi", "gi", " ni", "di", "x", "sim", "cli", "ij", "ip", "c", "u", "ti", " bi", "li", " t", "\u0438", "I", "p", " j", " I", "mc", "si", "batch", " pi", "oi", "ri", "im", "multi", "chain", "ami", " index", "ims", "index", "iu", "fi", "id", " ii", "it", "j", "ci", "xi", "ic", "ki", "t", "phi", "zi", " mi", "ix", " iter", "mi", "pi", "y", "bi", "ini", "ui", " ti"], "ret": ["uf", "usr", "ft", "ref", "RT", "RET", "elt", "tn", "nz", "status", "txt", "re", "reply", "cat", "Ret", "result", "addr", "pas", " RET", "def", "arr", "r", "tr", "ry", "flag", "alt", "nt", "rr", "len", "fi", "gc", "cont", "at", "res", "red", "back", "j", "rm", "mt", "gt", "ll", "fin", "rets", " Ret", "resp", "rt", "val", "print", "reset", "rem"], "q": ["qi", "iq", "h", "ch", "l", "k", "ql", "z", "ur", "Q", "aq", "c", "u", "p", "r", "qa", "et", "qq", "b", "w", "cv", "quit", "g", "at", "j", "sq", " sq", "dq", "ox", "t", "qu", "ue", "o", "v", "f", "qs", "qt", "query"], "m": [" mm", " mc", "d", "l", "dm", "fm", "n", "am", "gm", " im", "bm", "managed", "cm", " rm", "c", "M", "p", "mc", "r", "ma", "nm", "mo", "ms", "mem", "b", "e", "md", "mp", "g", "module", "j", "msg", " M", " cm", "mt", "mm", "mr", "t", "em", "tm", " mt", "mi", "o", "sm", "v", "f", "mat", "vm", "mu"], "rc": ["cor", " cr", "success", "cmp", "cb", "r", "scan", "star", "ry", "rd", "rr", "cv", "rect", "arc", "sc", " res", "roc", "cr", "sync", "rob", "usr", "con", "ck", "irc", "gc", "ack", "ro", "resp", "RC", "ror", "rs", "req", "pc", "dc", "src", "c", "sys", "err", "imp", " cc", "cc", "rn", "red", "rm", "dq", "ec", "rom", "rys", "rt", "rec", "co", "comp", "rin", "nz", "lc", "cur", "rx", " r", " ro", "auc", "ok", "cont", "rl", "row", "ctr", "nc", "crit", "fc", "cs", "uc", " err", "cd"], "qc": ["sqp", "qca", "sqcs", "eqcu", "qcache", "ekc", "aqt", "ekcs", "qqcs", "sqc", "aqca", "eqcon", "questcoll", "flowcoll", "sqt", "iqp", "qmc", "sqmc", " qcs", " qci", "sqci", " qca", "questn", "qulc", "sqca", "aqdc", "flowc", " qdc", " qlc", "qdc", "qlc", "qn", "eqdc", "quca", "quc", "qcon", "qcs", "qqlc", "qqcache", "eqc", "iqci", "qqc", "qcu", "iqca", "questc", "qucs", "ql", "qci", "qqcu", "flowdc", "qqci", "iqcs", "sqlc", " qcu", "qqp", "qcoll", "questdc", " qn", "iqt", "eql", "ekci", "iqcon", "sqdc", "eqcs", "eqlc", "iqdc", "qudc", "aqlc", "iql", " qp", "sqcon", "aqmc", " ql", " qcoll", " qcache", "eklc", "qup", "iqc", "flown", "eqp", "aqc", "qp", "qumc", "iqlc", "qt", "eqcache"], "media_url": [" media_string", "media___l", "media_string", "base_url", "media___field", " media_field", "media_field", "media_uri", " media_ref", "media_l", "base_Url", "media_Url", " media_l", "media_ref", "base_key", "media___url", " media_id", "media_key", "media___string", "media_id", "base_uri"], "pagetitle": ["pagertitle", "pagedetitled", "pagedettitle", "pagedetitle", "pagedesttitle", "paginettitle", "pagetarget", "pagettoken", "pagenoken", "pagestarget", "paginetttitle", "pagenarget", "pagetitled", "paginetoken", "pagesttitle", "pagetopic", "paginettoken", "pagisttitle", "pagetoken", "pagedetarget", "pagedestitled", "pagertoken", "pagistoken", "pagestitle", "pagertopic", "pagetttitle", "pagettitle", "paginettarget", "pagedestitle", "pagenitle", "pagertarget", "pagestoken", "paginetopic", "paginetitle", "pagettarget", "paginettopic", "pagettopic", "pagistarget", "pagettitled", "pagestitled", "paginetarget", "pagistitle", "pagenopic", "pagedestarget", "pagistitled"], "st": ["ST", "usr", "ft", "ut", "sn", "std", "sb", "St", "art", "sl", "nd", "bt", "th", "ast", "sv", "src", "ste", "ost", "xt", "sys", "ust", "store", "sty", "start", "ctx", "sp", " est", "stable", "sts", "it", "sh", "str", "sw", "est", "mt", "inst", "sta", "t", "sth", "se", "sc", "rt", "sm", "stat", "rest", "obj", "stream", "irst", "ss"], "ist": ["dist", "ind", "std", "ith", "pect", "art", "dit", "osi", "ast", "pas", "isting", "ost", "xt", "wp", "ust", "istor", "sty", "et", "ird", "istant", "ism", "ilst", "exist", "elist", "ert", "iz", "ict", "it", "mot", "isd", "wid", "iste", "ic", "inst", "IST", "alist", "is", "ld", "isi", "ista", "ists", "rest", "spect", "hist", "ht", "htt", "irst", "est"]}}
{"project": "qemu", "commit_id": "6750e795b167e3defab36502e61b8c57ede119eb", "target": 0, "func": "static int add_old_style_options(const char *fmt, QemuOpts *opts,\n\n                                 const char *base_filename,\n\n                                 const char *base_fmt)\n\n{\n\n    if (base_filename) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {\n\n            error_report(\"Backing file not supported for file format '%s'\",\n\n                         fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    if (base_fmt) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {\n\n            error_report(\"Backing file format not supported for file \"\n\n                         \"format '%s'\", fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 14220, "substitutes": {"fmt": ["vtm", "qmr", "cmt", " flt", "cformat", "ctm", "Fmr", "fformat", "fmr", "Fprintf", "qmt", " flamm", "Fmt", "vlamm", "ftm", "qprintf", "flamm", " Fmt", " Flamm", " Fformat", " ftm", "vmt", "clt", "vformat", "Fformat", "qformat", " Fprintf", "flt", "vlt", " fformat", " fmr"], "opts": ["OPs", "opcs", "atttions", "iopts", "atttx", "OPts", "ops", "opTS", "OPTS", "opgs", " opcs", "opertx", "OPgs", "options", "optcs", "opttions", " opgs", "attts", "optts", "iopgs", " options", " oprs", "OPrs", "iops", "oprs", "optx", "optTS", "opttx", "opers", "OPtx", "operts", "attcs", "operTS", "ioprs", " optx", " ops"], "base_filename": ["base_Filename", "base64file", " base_font", " base_src", "Base_filename", " base_file", "base_src", "Base_file", "base64dir", "base_file", "base_dir", "base_username", "base_folder", "base_family", "Base_username", "base_font", "base64family", " base_family", " base_dir", "base64filename", " base_Filename", "Base_folder"], "base_fmt": ["base_Fpl", "base_mmt", "base_ftx", "base_Fformat", "base_mtype", "base_wmat", "base_wformat", "base_fMT", "base_vtype", "base_frpl", "base_fpl", "base_vmat", "base_vmt", "base_vformat", "base_ftype", "base_frformat", "base_vMT", "base_FMT", "base_fformat", "base_confmt", "base_confmat", "base_conftx", "base_frMT", "base_mformat", "base_Fmt", "base_wmt", "base_wtx", "base_frmt", "base_fmat", "base_confformat", "base_vpl", "base_mMT", "base_vtx"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_flush_queued_packets(VLANClientState *vc)\n\n{\n\n    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {\n\n        VLANPacket *packet;\n\n        int ret;\n\n\n\n        packet = TAILQ_FIRST(&vc->vlan->send_queue);\n\n        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);\n\n\n\n        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);\n\n        if (ret == 0 && packet->sent_cb != NULL) {\n\n            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);\n\n            break;\n\n        }\n\n\n\n        if (packet->sent_cb)\n\n            packet->sent_cb(packet->sender, ret);\n\n\n\n        qemu_free(packet);\n\n    }\n\n}\n", "idx": 14228, "substitutes": {"vc": ["oc", "voc", "pc", "serv", "bc", "lc", "ctrl", "dc", "ctl", "etc", "xc", "vin", "c", "cu", "hw", "sv", "comm", "cb", "vd", "vs", "vp", "irm", "tc", "att", "nt", "cc", "vet", "WC", "vt", "lv", "gc", "cv", "ce", "cf", "ev", "ci", "ic", "nec", "fw", "vr", "cs", "fc", "nc", "fax", "wx", "inv", "wcs", "cmd", "v", "vm", "VC", "ht"], "packet": ["asset", "parseacket", "payeter", "checkpet", "buckacket", "packinet", "packalty", "claimpet", "pacew", "Packant", "packpet", "formett", "ppET", "packata", "assacket", "pickant", "processett", "presacket", "formeting", "preset", " packade", "pakacket", " packpet", "sticket", "packageetter", "packageew", " packant", "packetter", "parseett", "packant", "pairalty", "buckET", "checkacket", " packew", "stickacket", "pakew", "pairet", "parseette", "formeter", "Packet", "bucket", "packET", "paketting", "formetting", "packageet", "pacacket", "buckel", "packageeter", "packageET", "ppel", "pakand", "processacket", "pickacket", "packeter", "parseet", " packacket", "formet", "paket", "formette", "formalty", "pacet", "payacket", "picket", "mixpet", "pacata", "checkette", "pakinet", "mixet", "pacette", "parsepet", "presade", "mixacket", " packata", "pairacket", "asseting", "claimacket", "claimet", "packett", "assalty", "ppacket", "ppet", "pickand", "packageacket", "processet", "packacket", "stickpet", "packeting", "paketer", "paceter", "pacpet", "pakpet", "prespet", "Packand", "claiminet", "packageant", "picketer", "processette", "mixata", "payetting", "stickade", "checket", "packel", "packetting", "paireting", "parseant", "formacket", "parseew", "Packacket", "picketter", "packette", "Packeter", "packade", "packand", "packageel", "Packetter", "packew", "payet", " packinet"], "ret": ["ft", "ref", "jp", "RET", "elt", "tn", "status", "success", "out", "re", "reply", "cat", "Ret", "result", "addr", "cb", "ext", "def", "arr", "tr", "desc", "mb", "ent", "ry", "pet", "flag", "alt", "entry", "att", "nt", "mem", "match", "vet", "len", "db", "fun", "cont", "res", "j", "back", "num", "rm", "inter", "mt", "det", "gt", "ctr", "try", "t", "ter", "rets", "pt", " Ret", "resp", "rt", "deg", "val", "print", "cmd", "reset"]}}
{"project": "FFmpeg", "commit_id": "c0bc8b9afb7e4f39d84080870b9feedcd23ab5c9", "target": 1, "func": "LF_FUNC (h,  luma,         sse2)\n\nLF_IFUNC(h,  luma_intra,   sse2)\n\nLF_FUNC (v,  luma,         sse2)\n\nLF_IFUNC(v,  luma_intra,   sse2)\n\n\n\n/***********************************/\n\n/* weighted prediction */\n\n\n\n#define H264_WEIGHT(W, H, OPT) \\\n\nvoid ff_h264_weight_ ## W ## x ## H ## _ ## OPT(uint8_t *dst, \\\n\n    int stride, int log2_denom, int weight, int offset);\n\n\n\n#define H264_BIWEIGHT(W, H, OPT) \\\n\nvoid ff_h264_biweight_ ## W ## x ## H ## _ ## OPT(uint8_t *dst, \\\n\n    uint8_t *src, int stride, int log2_denom, int weightd, \\\n\n    int weights, int offset);\n\n\n\n#define H264_BIWEIGHT_MMX(W,H) \\\n\nH264_WEIGHT  (W, H, mmx2) \\\n\nH264_BIWEIGHT(W, H, mmx2)\n\n\n\n#define H264_BIWEIGHT_MMX_SSE(W,H) \\\n\nH264_BIWEIGHT_MMX(W, H) \\\n\nH264_WEIGHT      (W, H, sse2) \\\n\nH264_BIWEIGHT    (W, H, sse2) \\\n\nH264_BIWEIGHT    (W, H, ssse3)\n\n\n\nH264_BIWEIGHT_MMX_SSE(16, 16)\n\nH264_BIWEIGHT_MMX_SSE(16,  8)\n\nH264_BIWEIGHT_MMX_SSE( 8, 16)\n\nH264_BIWEIGHT_MMX_SSE( 8,  8)\n\nH264_BIWEIGHT_MMX_SSE( 8,  4)\n\nH264_BIWEIGHT_MMX    ( 4,  8)\n\nH264_BIWEIGHT_MMX    ( 4,  4)\n\nH264_BIWEIGHT_MMX    ( 4,  2)\n\n\n\nvoid ff_h264dsp_init_x86(H264DSPContext *c)\n\n{\n\n    int mm_flags = av_get_cpu_flags();\n\n\n\n    if (mm_flags & AV_CPU_FLAG_MMX2) {\n\n        c->h264_loop_filter_strength= h264_loop_filter_strength_mmx2;\n\n    }\n\n#if HAVE_YASM\n\n    if (mm_flags & AV_CPU_FLAG_MMX) {\n\n        c->h264_idct_dc_add=\n\n        c->h264_idct_add= ff_h264_idct_add_mmx;\n\n        c->h264_idct8_dc_add=\n\n        c->h264_idct8_add= ff_h264_idct8_add_mmx;\n\n\n\n        c->h264_idct_add16     = ff_h264_idct_add16_mmx;\n\n        c->h264_idct8_add4     = ff_h264_idct8_add4_mmx;\n\n        c->h264_idct_add8      = ff_h264_idct_add8_mmx;\n\n        c->h264_idct_add16intra= ff_h264_idct_add16intra_mmx;\n\n\n\n        if (mm_flags & AV_CPU_FLAG_MMX2) {\n\n            c->h264_idct_dc_add= ff_h264_idct_dc_add_mmx2;\n\n            c->h264_idct8_dc_add= ff_h264_idct8_dc_add_mmx2;\n\n            c->h264_idct_add16     = ff_h264_idct_add16_mmx2;\n\n            c->h264_idct8_add4     = ff_h264_idct8_add4_mmx2;\n\n            c->h264_idct_add8      = ff_h264_idct_add8_mmx2;\n\n            c->h264_idct_add16intra= ff_h264_idct_add16intra_mmx2;\n\n\n\n            c->h264_v_loop_filter_chroma= ff_x264_deblock_v_chroma_mmxext;\n\n            c->h264_h_loop_filter_chroma= ff_x264_deblock_h_chroma_mmxext;\n\n            c->h264_v_loop_filter_chroma_intra= ff_x264_deblock_v_chroma_intra_mmxext;\n\n            c->h264_h_loop_filter_chroma_intra= ff_x264_deblock_h_chroma_intra_mmxext;\n\n#if ARCH_X86_32\n\n            c->h264_v_loop_filter_luma= ff_x264_deblock_v_luma_mmxext;\n\n            c->h264_h_loop_filter_luma= ff_x264_deblock_h_luma_mmxext;\n\n            c->h264_v_loop_filter_luma_intra = ff_x264_deblock_v_luma_intra_mmxext;\n\n            c->h264_h_loop_filter_luma_intra = ff_x264_deblock_h_luma_intra_mmxext;\n\n\n            c->weight_h264_pixels_tab[0]= ff_h264_weight_16x16_mmx2;\n\n            c->weight_h264_pixels_tab[1]= ff_h264_weight_16x8_mmx2;\n\n            c->weight_h264_pixels_tab[2]= ff_h264_weight_8x16_mmx2;\n\n            c->weight_h264_pixels_tab[3]= ff_h264_weight_8x8_mmx2;\n\n            c->weight_h264_pixels_tab[4]= ff_h264_weight_8x4_mmx2;\n\n            c->weight_h264_pixels_tab[5]= ff_h264_weight_4x8_mmx2;\n\n            c->weight_h264_pixels_tab[6]= ff_h264_weight_4x4_mmx2;\n\n            c->weight_h264_pixels_tab[7]= ff_h264_weight_4x2_mmx2;\n\n\n\n            c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_mmx2;\n\n            c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_mmx2;\n\n            c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_mmx2;\n\n            c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_mmx2;\n\n            c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_mmx2;\n\n            c->biweight_h264_pixels_tab[5]= ff_h264_biweight_4x8_mmx2;\n\n            c->biweight_h264_pixels_tab[6]= ff_h264_biweight_4x4_mmx2;\n\n            c->biweight_h264_pixels_tab[7]= ff_h264_biweight_4x2_mmx2;\n\n\n\n            if (mm_flags&AV_CPU_FLAG_SSE2) {\n\n                c->h264_idct8_add = ff_h264_idct8_add_sse2;\n\n                c->h264_idct8_add4= ff_h264_idct8_add4_sse2;\n\n\n\n                c->weight_h264_pixels_tab[0]= ff_h264_weight_16x16_sse2;\n\n                c->weight_h264_pixels_tab[1]= ff_h264_weight_16x8_sse2;\n\n                c->weight_h264_pixels_tab[2]= ff_h264_weight_8x16_sse2;\n\n                c->weight_h264_pixels_tab[3]= ff_h264_weight_8x8_sse2;\n\n                c->weight_h264_pixels_tab[4]= ff_h264_weight_8x4_sse2;\n\n\n\n                c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_sse2;\n\n                c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_sse2;\n\n                c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_sse2;\n\n                c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_sse2;\n\n                c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_sse2;\n\n\n\n\n                c->h264_v_loop_filter_luma = ff_x264_deblock_v_luma_sse2;\n\n                c->h264_h_loop_filter_luma = ff_x264_deblock_h_luma_sse2;\n\n                c->h264_v_loop_filter_luma_intra = ff_x264_deblock_v_luma_intra_sse2;\n\n                c->h264_h_loop_filter_luma_intra = ff_x264_deblock_h_luma_intra_sse2;\n\n\n\n\n                c->h264_idct_add16 = ff_h264_idct_add16_sse2;\n\n                c->h264_idct_add8  = ff_h264_idct_add8_sse2;\n\n                c->h264_idct_add16intra = ff_h264_idct_add16intra_sse2;\n\n            }\n\n            if (mm_flags&AV_CPU_FLAG_SSSE3) {\n\n                c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_ssse3;\n\n                c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_ssse3;\n\n                c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_ssse3;\n\n                c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_ssse3;\n\n                c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_ssse3;\n\n            }\n\n        }\n\n    }\n\n\n}", "idx": 14248, "substitutes": {"c": ["h", "d", "cache", "dc", "cp", "cu", "p", "mc", "s", "m", "C", "b", "e", "tc", "cc", "ctx", "g", "cf", "ct", "t", "cs", "fc", "o", "a", "ac", "v", "f", "w"]}}
{"project": "FFmpeg", "commit_id": "6202e2fede75df92cbc374a3f7d6893d0c5ac721", "target": 0, "func": "static int decode_band_hdr(IVI45DecContext *ctx, IVIBandDesc *band,\n\n                           AVCodecContext *avctx)\n\n{\n\n    int plane, band_num, indx, transform_id, scan_indx;\n\n    int i;\n\n\n\n    plane    = get_bits(&ctx->gb, 2);\n\n    band_num = get_bits(&ctx->gb, 4);\n\n    if (band->plane != plane || band->band_num != band_num) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid band header sequence!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    band->is_empty = get_bits1(&ctx->gb);\n\n    if (!band->is_empty) {\n\n        int old_blk_size = band->blk_size;\n\n        /* skip header size\n\n         * If header size is not given, header size is 4 bytes. */\n\n        if (get_bits1(&ctx->gb))\n\n            skip_bits(&ctx->gb, 16);\n\n\n\n        band->is_halfpel = get_bits(&ctx->gb, 2);\n\n        if (band->is_halfpel >= 2) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid/unsupported mv resolution: %d!\\n\",\n\n                   band->is_halfpel);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n#if IVI4_STREAM_ANALYSER\n\n        if (!band->is_halfpel)\n\n            ctx->uses_fullpel = 1;\n\n#endif\n\n\n\n        band->checksum_present = get_bits1(&ctx->gb);\n\n        if (band->checksum_present)\n\n            band->checksum = get_bits(&ctx->gb, 16);\n\n\n\n        indx = get_bits(&ctx->gb, 2);\n\n        if (indx == 3) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid block size!\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        band->mb_size  = 16 >> indx;\n\n        band->blk_size = 8 >> (indx >> 1);\n\n\n\n        band->inherit_mv     = get_bits1(&ctx->gb);\n\n        band->inherit_qdelta = get_bits1(&ctx->gb);\n\n\n\n        band->glob_quant = get_bits(&ctx->gb, 5);\n\n\n\n        if (!get_bits1(&ctx->gb) || ctx->frame_type == IVI4_FRAMETYPE_INTRA) {\n\n            transform_id = get_bits(&ctx->gb, 5);\n\n            if (transform_id >= FF_ARRAY_ELEMS(transforms) ||\n\n                !transforms[transform_id].inv_trans) {\n\n                avpriv_request_sample(avctx, \"Transform %d\", transform_id);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            if ((transform_id >= 7 && transform_id <= 9) ||\n\n                 transform_id == 17) {\n\n                avpriv_request_sample(avctx, \"DCT transform\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n#if IVI4_STREAM_ANALYSER\n\n            if ((transform_id >= 0 && transform_id <= 2) || transform_id == 10)\n\n                ctx->uses_haar = 1;\n\n#endif\n\n\n\n            band->inv_transform = transforms[transform_id].inv_trans;\n\n            band->dc_transform  = transforms[transform_id].dc_trans;\n\n            band->is_2d_trans   = transforms[transform_id].is_2d_trans;\n\n            if (transform_id < 10)\n\n                band->transform_size = 8;\n\n            else\n\n                band->transform_size = 4;\n\n\n\n            if (band->blk_size != band->transform_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            scan_indx = get_bits(&ctx->gb, 4);\n\n            if (scan_indx == 15) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Custom scan pattern encountered!\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (scan_indx > 4 && scan_indx < 10) {\n\n                if (band->blk_size != 4)\n\n                    return AVERROR_INVALIDDATA;\n\n            } else if (band->blk_size != 8)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            band->scan = scan_index_to_tab[scan_indx];\n\n\n\n            band->quant_mat = get_bits(&ctx->gb, 5);\n\n            if (band->quant_mat >= FF_ARRAY_ELEMS(quant_index_to_tab)) {\n\n\n\n                if (band->quant_mat == 31)\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"Custom quant matrix encountered!\\n\");\n\n                else\n\n                    avpriv_request_sample(avctx, \"Quantization matrix %d\",\n\n                                          band->quant_mat);\n\n                band->quant_mat = -1;\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        } else {\n\n            if (old_blk_size != band->blk_size) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"The band block size does not match the configuration \"\n\n                       \"inherited\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (band->quant_mat < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Invalid quant_mat inherited\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n\n\n        /* decode block huffman codebook */\n\n        if (!get_bits1(&ctx->gb))\n\n            band->blk_vlc.tab = ctx->blk_vlc.tab;\n\n        else\n\n            if (ff_ivi_dec_huff_desc(&ctx->gb, 1, IVI_BLK_HUFF,\n\n                                     &band->blk_vlc, avctx))\n\n                return AVERROR_INVALIDDATA;\n\n\n\n        /* select appropriate rvmap table for this band */\n\n        band->rvmap_sel = get_bits1(&ctx->gb) ? get_bits(&ctx->gb, 3) : 8;\n\n\n\n        /* decode rvmap probability corrections if any */\n\n        band->num_corr = 0; /* there is no corrections */\n\n        if (get_bits1(&ctx->gb)) {\n\n            band->num_corr = get_bits(&ctx->gb, 8); /* get number of correction pairs */\n\n            if (band->num_corr > 61) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Too many corrections: %d\\n\",\n\n                       band->num_corr);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            /* read correction pairs */\n\n            for (i = 0; i < band->num_corr * 2; i++)\n\n                band->corr[i] = get_bits(&ctx->gb, 8);\n\n        }\n\n    }\n\n\n\n    if (band->blk_size == 8) {\n\n        band->intra_base = &ivi4_quant_8x8_intra[quant_index_to_tab[band->quant_mat]][0];\n\n        band->inter_base = &ivi4_quant_8x8_inter[quant_index_to_tab[band->quant_mat]][0];\n\n    } else {\n\n        band->intra_base = &ivi4_quant_4x4_intra[quant_index_to_tab[band->quant_mat]][0];\n\n        band->inter_base = &ivi4_quant_4x4_inter[quant_index_to_tab[band->quant_mat]][0];\n\n    }\n\n\n\n    /* Indeo 4 doesn't use scale tables */\n\n    band->intra_scale = NULL;\n\n    band->inter_scale = NULL;\n\n\n\n    align_get_bits(&ctx->gb);\n\n\n\n    return 0;\n\n}\n", "idx": 14263, "substitutes": {"ctx": ["pkg", "bc", "history", "conv", "cmp", "px", "cm", "addr", "np", "cp", "cb", "check", "warn", "args", "mem", "cv", "vals", "ca", "unk", "context", "kw", "prop", "std", "serv", "ck", "stack", "txt", "Context", "def", "mc", "height", "jac", "cfg", "tc", "ack", "kt", "cf", "msg", "disk", "conn", "lib", "resp", "cmd", "req", "prefix", "dc", "buf", "comm", "loc", "sys", "batch", "cam", "cc", "bit", "ct", "proc", " cx", "handler", "work", "wcs", "params", "comp", "tx", "ctl", "xc", "hw", "conf", "bo", "window", "box", "act", "inst", "func", "self", "nc", "crit", "fc", "config", "wx", "obj", "iat"], "band": ["bind", "art", "need", "patch", "weight", "bd", "display", "prep", "report", "unk", "bor", "chrom", "stream", "pair", "and", "power", "bar", "dom", "br", "word", "group", "bridge", "def", "filter", "tag", "bright", "beam", "flag", "bb", "bands", "ack", "disk", "ud", "broad", "lib", "link", "library", "burst", "command", "lag", "form", "channel", "format", "service", "Band", "border", "batch", "disc", "cast", "bag", "cand", "light", "block", "road", "job", "bit", "range", "supp", "amp", "data", "binary", "layer", "bed", "handler", "work", "plugin", "pp", "flash", "product", "way", "find", "raid", "list", "b", "chain", "db", "box", "dd", "back", "load", "bank", "rad", "bin", "grab", "bart", "bug", "plot", "rest", "brand"], "avctx": [" avcc", "jamcmd", "aveconfig", "jamctx", "verctx", " avconfig", "avercpp", "avcb", "AVcontext", "afcpp", "aversetup", "jamcb", "avtx", "AVcc", "AVctx", "afsetup", "avcontext", "avcmd", "jamcas", "avcfg", "vercfg", "avercfg", " avcontext", "avsetup", "versetup", "averctx", "avetx", "avecc", "aftx", "avcpp", "AVconfig", "vercpp", "avecb", "avecas", "svctx", "avectx", "avecontext", "afcb", "avecmd", "afctx", "afcas", "afcmd", "avegc", "avconfig", "afcfg", "avcas", "avcc", "svcmd", "svgc", "afgc", "svtx", "avgc"], "plane": ["zo", "ve", "lane", "angle", "direction", "pe", "zon", "panel", "translation", "pa", "way", "place", "half", "clip", "balance", "planes", "face", "orient", "cone", "bridge", "pen", "pose", "plan", "beam", "flow", "port", "flag", "mate", "slice", "poses", "mode", "car", "cube", "mission", "rot", "board", "gate", "zone", "ane", "fl", "atten", "flat", "pipe", "phi", "axis", "late", "plate", "phy", "pan", "heading", "plot", "phase", "onet", "sea", "mask", "profile", "shift"], "band_num": [" band_n", "band_no", "bit_nom", "band_dev", "band_dim", "band2n", " band_len", "band_number", "band_nb", "bandjnb", "frame_nb", "bit_num", "frame_num", "band_len", "bandjn", "bit_number", " band_dim", "band_nom", "band_max", "bandjnum", " band_number", "band2dim", "bit_no", "band2num", "bandjdev", " band_max", "frame_n", "band_n", "band2number", "frame_dev"], "indx": [" indxc", "indX", "codX", " indX", "idy", "Indy", "ndex", "INDy", "Indxc", "INDx", "idon", "ndy", "IndX", "codix", " indix", "indy", "Index", "ndx", "Indix", " index", "index", " indon", "INDxc", "codx", "INDex", "Indx", "INDix", "ndix", "idx", "indxc", " indy", "cody", "Indon", "idex", "idix", "indon", "indix"], "transform_id": ["transformregid", "trans_type", "transform_pid", "trans_id", "transform_type", "transformregpid", "trans_pid", "transform_ids", "transformregtype", "transformregids", "trans_ids"], "scan_indx": ["scan_idx", "scan_ndx", "scan_ndix", "scan_indn", "scan_ndn", "scan_ridx", "scan_index", "scan_idn", "scan_indix", "scan_idix", "scan_ndex", "scan_ridex", "scan_ridn", "scan_ridix", "scan_idex"], "i": ["l", "ai", "ii", "gi", "di", "ij", "ip", "c", " bi", "ti", "li", "I", "p", "si", "m", "b", "fi", "it", "j", "ci", "xi", "t", "phi", "mi", "pi", "v", "bi", "io"]}}
{"project": "qemu", "commit_id": "1a9353d258aba69afd8a389bf5fb705caab12ce0", "target": 0, "func": "long do_syscall(void *cpu_env, int num, long arg1, long arg2, long arg3, \n\n                long arg4, long arg5, long arg6)\n\n{\n\n    long ret;\n\n    struct stat st;\n\n    struct kernel_statfs *stfs;\n\n    \n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\\n\", num);\n\n#endif\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n#ifdef HAVE_GPROF\n\n        _mcleanup();\n\n#endif\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        ret = get_errno(read(arg1, (void *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_write:\n\n        ret = get_errno(write(arg1, (void *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_open:\n\n        ret = get_errno(open((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk((char *)arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(fork());\n\n        break;\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int *status = (int *)arg2;\n\n            ret = get_errno(waitpid(arg1, status, arg3));\n\n            if (!is_error(ret) && status)\n\n                tswapls((long *)&status);\n\n        }\n\n        break;\n\n    case TARGET_NR_creat:\n\n        ret = get_errno(creat((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_link:\n\n        ret = get_errno(link((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_unlink:\n\n        ret = get_errno(unlink((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_execve:\n\n        ret = get_errno(execve((const char *)arg1, (void *)arg2, (void *)arg3));\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        ret = get_errno(chdir((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_time:\n\n        {\n\n            int *time_ptr = (int *)arg1;\n\n            ret = get_errno(time((time_t *)time_ptr));\n\n            if (!is_error(ret) && time_ptr)\n\n                tswap32s(time_ptr);\n\n        }\n\n        break;\n\n    case TARGET_NR_mknod:\n\n        ret = get_errno(mknod((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_chmod:\n\n        ret = get_errno(chmod((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_lchown:\n\n        ret = get_errno(chown((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getpid:\n\n        ret = get_errno(getpid());\n\n        break;\n\n    case TARGET_NR_mount:\n\n        /* need to look at the data field */\n\n        goto unimplemented;\n\n    case TARGET_NR_umount:\n\n        ret = get_errno(umount((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(getuid());\n\n        break;\n\n    case TARGET_NR_stime:\n\n        {\n\n            int *time_ptr = (int *)arg1;\n\n            if (time_ptr)\n\n                tswap32s(time_ptr);\n\n            ret = get_errno(stime((time_t *)time_ptr));\n\n        }\n\n        break;\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n    case TARGET_NR_utime:\n\n        goto unimplemented;\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n    case TARGET_NR_access:\n\n        ret = get_errno(access((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n    case TARGET_NR_sync:\n\n        ret = get_errno(sync());\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        ret = get_errno(rename((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_mkdir:\n\n        ret = get_errno(mkdir((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_rmdir:\n\n        ret = get_errno(rmdir((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        {\n\n            int *pipe_ptr = (int *)arg1;\n\n            ret = get_errno(pipe(pipe_ptr));\n\n            if (!is_error(ret)) {\n\n                tswap32s(&pipe_ptr[0]);\n\n                tswap32s(&pipe_ptr[1]);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_times:\n\n        goto unimplemented;\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(getgid());\n\n        break;\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(getegid());\n\n        break;\n\n    case TARGET_NR_acct:\n\n        goto unimplemented;\n\n    case TARGET_NR_umount2:\n\n        ret = get_errno(umount2((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        switch(arg2) {\n\n        case F_GETLK:\n\n        case F_SETLK:\n\n        case F_SETLKW:\n\n            goto unimplemented;\n\n        default:\n\n            ret = get_errno(fcntl(arg1, arg2, arg3));\n\n            break;\n\n        }\n\n        break;\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        ret = get_errno(chroot((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n    case TARGET_NR_sigaction:\n\n#if 0\n\n        {\n\n            int signum = arg1;\n\n            struct target_old_sigaction *tact = arg2, *toldact = arg3;\n\n            ret = get_errno(setsid());\n\n            \n\n\n\n        }\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sgetmask:\n\n        goto unimplemented;\n\n    case TARGET_NR_ssetmask:\n\n        goto unimplemented;\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_sigsuspend:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigpending:\n\n        goto unimplemented;\n\n    case TARGET_NR_sethostname:\n\n        ret = get_errno(sethostname((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_getrlimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_getrusage:\n\n        goto unimplemented;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct target_timeval *target_tv = (void *)arg1;\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                target_tv->tv_sec = tswapl(tv.tv_sec);\n\n                target_tv->tv_usec = tswapl(tv.tv_usec);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct target_timeval *target_tv = (void *)arg1;\n\n            struct timeval tv;\n\n            tv.tv_sec = tswapl(target_tv->tv_sec);\n\n            tv.tv_usec = tswapl(target_tv->tv_usec);\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        goto unimplemented;\n\n    case TARGET_NR_setgroups:\n\n        goto unimplemented;\n\n    case TARGET_NR_select:\n\n        goto unimplemented;\n\n    case TARGET_NR_symlink:\n\n        ret = get_errno(symlink((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_readlink:\n\n        ret = get_errno(readlink((const char *)arg1, (char *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n    case TARGET_NR_swapon:\n\n        ret = get_errno(swapon((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_reboot:\n\n        goto unimplemented;\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_mmap:\n\n        {\n\n            uint32_t v1, v2, v3, v4, v5, v6, *vptr;\n\n            vptr = (uint32_t *)arg1;\n\n            v1 = tswap32(vptr[0]);\n\n            v2 = tswap32(vptr[1]);\n\n            v3 = tswap32(vptr[2]);\n\n            v4 = tswap32(vptr[3]);\n\n            v5 = tswap32(vptr[4]);\n\n            v6 = tswap32(vptr[5]);\n\n            ret = get_errno((long)mmap((void *)v1, v2, v3, v4, v5, v6));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_mmap2:\n\n#else\n\n    case TARGET_NR_mmap:\n\n#endif\n\n        ret = get_errno((long)mmap((void *)arg1, arg2, arg3, arg4, arg5, arg6));\n\n        break;\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(munmap((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_truncate:\n\n        ret = get_errno(truncate((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getpriority:\n\n        ret = get_errno(getpriority(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n    case TARGET_NR_statfs:\n\n        stfs = (void *)arg2;\n\n        ret = get_errno(sys_statfs((const char *)arg1, stfs));\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            tswap32s(&stfs->f_type);\n\n            tswap32s(&stfs->f_bsize);\n\n            tswap32s(&stfs->f_blocks);\n\n            tswap32s(&stfs->f_bfree);\n\n            tswap32s(&stfs->f_bavail);\n\n            tswap32s(&stfs->f_files);\n\n            tswap32s(&stfs->f_ffree);\n\n            tswap32s(&stfs->f_fsid.val[0]);\n\n            tswap32s(&stfs->f_fsid.val[1]);\n\n            tswap32s(&stfs->f_namelen);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        stfs = (void *)arg2;\n\n        ret = get_errno(sys_fstatfs(arg1, stfs));\n\n        goto convert_statfs;\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, (long *)arg2);\n\n        break;\n\n    case TARGET_NR_syslog:\n\n        goto unimplemented;\n\n    case TARGET_NR_setitimer:\n\n        goto unimplemented;\n\n    case TARGET_NR_getitimer:\n\n        goto unimplemented;\n\n    case TARGET_NR_stat:\n\n        ret = get_errno(stat((const char *)arg1, &st));\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        ret = get_errno(lstat((const char *)arg1, &st));\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st = (void *)arg2;\n\n                target_st->st_dev = tswap16(st.st_dev);\n\n                target_st->st_ino = tswapl(st.st_ino);\n\n                target_st->st_mode = tswap16(st.st_mode);\n\n                target_st->st_nlink = tswap16(st.st_nlink);\n\n                target_st->st_uid = tswap16(st.st_uid);\n\n                target_st->st_gid = tswap16(st.st_gid);\n\n                target_st->st_rdev = tswap16(st.st_rdev);\n\n                target_st->st_size = tswapl(st.st_size);\n\n                target_st->st_blksize = tswapl(st.st_blksize);\n\n                target_st->st_blocks = tswapl(st.st_blocks);\n\n                target_st->st_atime = tswapl(st.st_atime);\n\n                target_st->st_mtime = tswapl(st.st_mtime);\n\n                target_st->st_ctime = tswapl(st.st_ctime);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            target_long *status_ptr = (void *)arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            struct target_rusage *target_rusage = (void *)arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr)\n\n                    *status_ptr = tswap32(status);\n\n                if (target_rusage) {\n\n                    target_rusage->ru_utime.tv_sec = tswapl(rusage.ru_utime.tv_sec);\n\n                    target_rusage->ru_utime.tv_usec = tswapl(rusage.ru_utime.tv_usec);\n\n                    target_rusage->ru_stime.tv_sec = tswapl(rusage.ru_stime.tv_sec);\n\n                    target_rusage->ru_stime.tv_usec = tswapl(rusage.ru_stime.tv_usec);\n\n                    target_rusage->ru_maxrss = tswapl(rusage.ru_maxrss);\n\n                    target_rusage->ru_ixrss = tswapl(rusage.ru_ixrss);\n\n                    target_rusage->ru_idrss = tswapl(rusage.ru_idrss);\n\n                    target_rusage->ru_isrss = tswapl(rusage.ru_isrss);\n\n                    target_rusage->ru_minflt = tswapl(rusage.ru_minflt);\n\n                    target_rusage->ru_majflt = tswapl(rusage.ru_majflt);\n\n                    target_rusage->ru_nswap = tswapl(rusage.ru_nswap);\n\n                    target_rusage->ru_inblock = tswapl(rusage.ru_inblock);\n\n                    target_rusage->ru_oublock = tswapl(rusage.ru_oublock);\n\n                    target_rusage->ru_msgsnd = tswapl(rusage.ru_msgsnd);\n\n                    target_rusage->ru_msgrcv = tswapl(rusage.ru_msgrcv);\n\n                    target_rusage->ru_nsignals = tswapl(rusage.ru_nsignals);\n\n                    target_rusage->ru_nvcsw = tswapl(rusage.ru_nvcsw);\n\n                    target_rusage->ru_nivcsw = tswapl(rusage.ru_nivcsw);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_swapoff:\n\n        ret = get_errno(swapoff((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_sysinfo:\n\n        goto unimplemented;\n\n    case TARGET_NR_ipc:\n\n        goto unimplemented;\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_sigreturn:\n\n        goto unimplemented;\n\n    case TARGET_NR_clone:\n\n        goto unimplemented;\n\n    case TARGET_NR_setdomainname:\n\n        ret = get_errno(setdomainname((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        ret = get_errno(sys_uname((struct new_utsname *)arg1));\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = get_errno(gemu_modify_ldt(cpu_env, arg1, (void *)arg2, arg3));\n\n        break;\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n    case TARGET_NR_mprotect:\n\n        ret = get_errno(mprotect((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n            target_ulong *pset = (void *)arg2, *poldset = (void *)arg3;\n\n            \n\n            switch(how) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -EINVAL;\n\n                goto fail;\n\n            }\n\n            \n\n            if (pset) {\n\n                target_to_host_old_sigset(&set, pset);\n\n                set_ptr = &set;\n\n            } else {\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(arg1, set_ptr, &oldset));\n\n            if (!is_error(ret) && poldset) {\n\n                host_to_target_old_sigset(poldset, &oldset);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_create_module:\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n    case TARGET_NR_get_kernel_syms:\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(mprotect((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n    case TARGET_NR_setfsuid:\n\n        goto unimplemented;\n\n    case TARGET_NR_setfsgid:\n\n        goto unimplemented;\n\n    case TARGET_NR__llseek:\n\n        {\n\n            int64_t res;\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n            *(int64_t *)arg4 = tswap64(res);\n\n        }\n\n        break;\n\n    case TARGET_NR_getdents:\n\n#if TARGET_LONG_SIZE != 4\n\n#error not supported\n\n#endif\n\n        {\n\n            struct dirent *dirp = (void *)arg2;\n\n            long count = arg3;\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = tswap16(de->d_reclen);\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = reclen;\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR__newselect:\n\n        ret = do_select(arg1, (void *)arg2, (void *)arg3, (void *)arg4, \n\n                        (void *)arg5);\n\n        break;\n\n    case TARGET_NR_flock:\n\n        goto unimplemented;\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            int count = arg3;\n\n            int i;\n\n            struct iovec *vec;\n\n            struct target_iovec *target_vec = (void *)arg2;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            for(i = 0;i < count; i++) {\n\n                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);\n\n                vec[i].iov_len = tswapl(target_vec[i].iov_len);\n\n            }\n\n            ret = get_errno(readv(arg1, vec, count));\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            int count = arg3;\n\n            int i;\n\n            struct iovec *vec;\n\n            struct target_iovec *target_vec = (void *)arg2;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            for(i = 0;i < count; i++) {\n\n                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);\n\n                vec[i].iov_len = tswapl(target_vec[i].iov_len);\n\n            }\n\n            ret = get_errno(writev(arg1, vec, count));\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n    case TARGET_NR_fdatasync:\n\n        goto unimplemented;\n\n    case TARGET_NR__sysctl:\n\n        goto unimplemented;\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n    case TARGET_NR_sched_setparam:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_getparam:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_setscheduler:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_getscheduler:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n    case TARGET_NR_sched_get_priority_min:\n\n    case TARGET_NR_sched_rr_get_interval:\n\n    case TARGET_NR_nanosleep:\n\n    case TARGET_NR_mremap:\n\n    case TARGET_NR_setresuid:\n\n    case TARGET_NR_getresuid:\n\n    case TARGET_NR_vm86:\n\n    case TARGET_NR_query_module:\n\n    case TARGET_NR_poll:\n\n    case TARGET_NR_nfsservctl:\n\n    case TARGET_NR_setresgid:\n\n    case TARGET_NR_getresgid:\n\n    case TARGET_NR_prctl:\n\n    case TARGET_NR_rt_sigreturn:\n\n    case TARGET_NR_rt_sigaction:\n\n    case TARGET_NR_rt_sigprocmask:\n\n    case TARGET_NR_rt_sigpending:\n\n    case TARGET_NR_rt_sigtimedwait:\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n    case TARGET_NR_rt_sigsuspend:\n\n    case TARGET_NR_pread:\n\n    case TARGET_NR_pwrite:\n\n        goto unimplemented;\n\n    case TARGET_NR_chown:\n\n        ret = get_errno(chown((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getcwd:\n\n        ret = get_errno(sys_getcwd1((char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_capget:\n\n    case TARGET_NR_capset:\n\n    case TARGET_NR_sigaltstack:\n\n    case TARGET_NR_sendfile:\n\n    case TARGET_NR_getpmsg:\n\n    case TARGET_NR_putpmsg:\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(vfork());\n\n        break;\n\n    case TARGET_NR_ugetrlimit:\n\n    case TARGET_NR_truncate64:\n\n    case TARGET_NR_ftruncate64:\n\n    case TARGET_NR_stat64:\n\n    case TARGET_NR_lstat64:\n\n    case TARGET_NR_fstat64:\n\n    case TARGET_NR_lchown32:\n\n    case TARGET_NR_getuid32:\n\n    case TARGET_NR_getgid32:\n\n    case TARGET_NR_geteuid32:\n\n    case TARGET_NR_getegid32:\n\n    case TARGET_NR_setreuid32:\n\n    case TARGET_NR_setregid32:\n\n    case TARGET_NR_getgroups32:\n\n    case TARGET_NR_setgroups32:\n\n    case TARGET_NR_fchown32:\n\n    case TARGET_NR_setresuid32:\n\n    case TARGET_NR_getresuid32:\n\n    case TARGET_NR_setresgid32:\n\n    case TARGET_NR_getresgid32:\n\n    case TARGET_NR_chown32:\n\n    case TARGET_NR_setuid32:\n\n    case TARGET_NR_setgid32:\n\n    case TARGET_NR_setfsuid32:\n\n    case TARGET_NR_setfsgid32:\n\n    case TARGET_NR_pivot_root:\n\n    case TARGET_NR_mincore:\n\n    case TARGET_NR_madvise:\n\n    case TARGET_NR_getdents64:\n\n    case TARGET_NR_fcntl64:\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n    case TARGET_NR_readahead:\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n    case TARGET_NR_fsetxattr:\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n    case TARGET_NR_fgetxattr:\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    case TARGET_NR_flistxattr:\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n    case TARGET_NR_fremovexattr:\n\n        goto unimplemented;\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"Unsupported syscall: %d\\n\", num);\n\n        ret = -ENOSYS;\n\n        break;\n\n    }\n\n fail:\n\n    return ret;\n\n}\n", "idx": 14289, "substitutes": {"cpu_env": ["cpu_info", "cpu_v", "cpu_dir", "gpu_dir", "gpu_v", "gpu_env", "gpu_info"], "num": ["un", "con", "n", "th", "x", "temp", "out", "off", "run", "number", "nu", "np", "tim", "new", "result", "conf", "ver", "zero", "nm", "m", "mon", "valid", "Num", "dim", "code", "multi", "final", "no", "nom", "index", "na", "ctx", "id", "um", "gnu", "msg", "en", "NUM", "coord", "nb", "t", "val", "current"], "arg1": ["argA", "dev5", "alg2", "args5", "argument2", " arg21", "args0", "argument3", "val1", "dev2", "par21", "doc1", "doc0", " arg0", "args3", "pg0", "pg3", "arg0", "alg5", "doc01", "pg1", "arg21", "prop2", "ag2", "argument1", " argOne", "val2", "valOne", " arg01", "alg1", "par1", "argument0", "par5", "val5", "val3", "ag3", "argOne", "prop3", "argument5", "dev3", "argsA", "ag5", "group3", "prop1", " argA", "argsOne", "group1", "args1", "group0", "ag1", "group2", "argument4", "ag4", "doc5", "arg01", "par2", "alg21", "agA", "dev1", "val0", "pg2", "prop5", "args2", "args01"], "arg2": ["args5", "target2", "args0", "argsSecond", "val1", "argTwo", "doc1", "argsTwo", " arg0", "args3", "tagTwo", "args02", "arg0", "tag02", "target5", "dateTwo", "target3", " arg02", "prop2", "Arg3", "ag2", "val2", "Arg0", " argSecond", "tag2", "Arg02", "val5", "val3", "ag3", "argSecond", "doc2", "prop3", "prop6", "date1", "doc3", "date02", "args1", "ag1", "Arg1", "tag1", "tag5", "arg02", "Arg2", "doc5", "target6", "tag3", "prop5", "args2", "Arg5", "agSecond", "date2"], "arg3": ["group03", "docUE", "param1", "argument03", " arg03", "Arg43", "argument3", "ar003", " arg103", " arg003", "ass3", " argUE", "argUE", "param03", "arg43", "agUE", "args3", " arg53", "arg003", "date3", "Arg3", "ag2", "param3", "tag03", "ar3", "Arg103", "tag2", "arg53", "Arg03", "ass1", "tag4", "ag3", "ag6", "doc2", "param2", "ar53", " arg43", "date1", "date53", "doc3", "group3", "assUE", "argument43", "args1", "arg103", "date003", "Arg1", "ass2", "ArgUE", "doc6", "group2", "ar1", "Arg2", "tag3", "argument103", "args03", "args2", "group4", "arg03"], "arg4": ["val40", "int413", " arg43", "int43", "int40", "val413", "arg40", " arg40", "val43", "arg43", " arg413", "val4", "int4", "arg413"], "arg5": ["arg25", "dim25", "var45", "dim45", "dim5", "dim75", "var5", "arg45", "var75", " arg75", "var25", "arg75", " arg25", " arg45"], "arg6": ["Arg4", "dim6", "args4", "Arg7", "arg7", "args6", "Arg6", "args9", "dim4", "dim7", "args7", "Arg9", "arg9", "dim9"], "ret": ["success", "ben", "re", "cat", "Ret", "r", "mem", "att", "vet", "des", "expr", "rets", "rem", "details", "usr", "dt", "full", "pas", " RET", "def", "tr", "mb", "flag", "eth", "gc", "j", "try", "nl", "t", "net", "get", "resp", "cmd", "stat", "jp", "RET", "pret", "summary", "format", "compl", "ext", "arr", "err", "leg", "Return", "alt", "nt", "count", "red", "rm", "mt", "det", "gt", "arg", "rt", "val", "ft", "ref", "n", "elt", "out", "reg", "result", "desc", "len", "fun", "back", "ll", " fut", " Ret", "lit", "reset"], "st": ["ST", "usr", "d", "ut", "std", "St", "x", "ste", "ost", "nt", "sp", "sts", "str", "sw", "ct", "mt", "nl", "sth", " ST", "net", "se", "ts", "sc", "ld", "sm", "rest", "est"], "stfs": ["STms", "stf", "Stf", "Stps", "STf", "STfs", "stms", " stps", "STps", " stms", "Stms", "Stfs", " stf", "stps"], "status": ["usr", "info", "version", "type", "n", "uses", "atus", "success", "progress", "null", "x", "error", "only", "compl", "state", "pid", "result", "p", "s", "err", "si", "ssl", "STAT", "handle", "valid", "name", "flag", "code", "count", "active", "sp", "index", "currently", "wa", "id", "Status", "gc", "str", "sw", "susp", "msg", "ex", "login", "sex", "resp", "negative", "stat", "f", "sync", "lag", "ping", "current", "wait"]}}
{"project": "qemu", "commit_id": "f80ac75d0e6e6e7481d61cdb86e5a741a442f100", "target": 1, "func": "static int rebuild_refcount_structure(BlockDriverState *bs,\n\n                                      BdrvCheckResult *res,\n\n                                      void **refcount_table,\n\n                                      int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t first_free_cluster = 0, reftable_offset = -1, cluster = 0;\n\n    int64_t refblock_offset, refblock_start, refblock_index;\n\n    uint32_t reftable_size = 0;\n\n    uint64_t *on_disk_reftable = NULL;\n\n    void *on_disk_refblock;\n\n    int ret = 0;\n\n    struct {\n\n        uint64_t reftable_offset;\n\n        uint32_t reftable_clusters;\n\n    } QEMU_PACKED reftable_offset_and_clusters;\n\n\n\n    qcow2_cache_empty(bs, s->refcount_block_cache);\n\n\n\nwrite_refblocks:\n\n    for (; cluster < *nb_clusters; cluster++) {\n\n        if (!s->get_refcount(*refcount_table, cluster)) {\n\n            continue;\n\n        }\n\n\n\n        refblock_index = cluster >> s->refcount_block_bits;\n\n        refblock_start = refblock_index << s->refcount_block_bits;\n\n\n\n        /* Don't allocate a cluster in a refblock already written to disk */\n\n        if (first_free_cluster < refblock_start) {\n\n            first_free_cluster = refblock_start;\n\n        }\n\n        refblock_offset = alloc_clusters_imrt(bs, 1, refcount_table,\n\n                                              nb_clusters, &first_free_cluster);\n\n        if (refblock_offset < 0) {\n\n            fprintf(stderr, \"ERROR allocating refblock: %s\\n\",\n\n                    strerror(-refblock_offset));\n\n            res->check_errors++;\n\n            ret = refblock_offset;\n\n            goto fail;\n\n        }\n\n\n\n        if (reftable_size <= refblock_index) {\n\n            uint32_t old_reftable_size = reftable_size;\n\n            uint64_t *new_on_disk_reftable;\n\n\n\n            reftable_size = ROUND_UP((refblock_index + 1) * sizeof(uint64_t),\n\n                                     s->cluster_size) / sizeof(uint64_t);\n\n            new_on_disk_reftable = g_try_realloc(on_disk_reftable,\n\n                                                 reftable_size *\n\n                                                 sizeof(uint64_t));\n\n            if (!new_on_disk_reftable) {\n\n                res->check_errors++;\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n            on_disk_reftable = new_on_disk_reftable;\n\n\n\n            memset(on_disk_reftable + old_reftable_size, 0,\n\n                   (reftable_size - old_reftable_size) * sizeof(uint64_t));\n\n\n\n            /* The offset we have for the reftable is now no longer valid;\n\n             * this will leak that range, but we can easily fix that by running\n\n             * a leak-fixing check after this rebuild operation */\n\n            reftable_offset = -1;\n\n        }\n\n        on_disk_reftable[refblock_index] = refblock_offset;\n\n\n\n        /* If this is apparently the last refblock (for now), try to squeeze the\n\n         * reftable in */\n\n        if (refblock_index == (*nb_clusters - 1) >> s->refcount_block_bits &&\n\n            reftable_offset < 0)\n\n        {\n\n            uint64_t reftable_clusters = size_to_clusters(s, reftable_size *\n\n                                                          sizeof(uint64_t));\n\n            reftable_offset = alloc_clusters_imrt(bs, reftable_clusters,\n\n                                                  refcount_table, nb_clusters,\n\n                                                  &first_free_cluster);\n\n            if (reftable_offset < 0) {\n\n                fprintf(stderr, \"ERROR allocating reftable: %s\\n\",\n\n                        strerror(-reftable_offset));\n\n                res->check_errors++;\n\n                ret = reftable_offset;\n\n                goto fail;\n\n            }\n\n        }\n\n\n\n        ret = qcow2_pre_write_overlap_check(bs, 0, refblock_offset,\n\n                                            s->cluster_size);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret));\n\n            goto fail;\n\n        }\n\n\n\n        /* The size of *refcount_table is always cluster-aligned, therefore the\n\n         * write operation will not overflow */\n\n        on_disk_refblock = (void *)((char *) *refcount_table +\n\n                                    refblock_index * s->cluster_size);\n\n\n\n        ret = bdrv_write(bs->file, refblock_offset / BDRV_SECTOR_SIZE,\n\n                         on_disk_refblock, s->cluster_sectors);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret));\n\n            goto fail;\n\n        }\n\n\n\n        /* Go to the end of this refblock */\n\n        cluster = refblock_start + s->refcount_block_size - 1;\n\n    }\n\n\n\n    if (reftable_offset < 0) {\n\n        uint64_t post_refblock_start, reftable_clusters;\n\n\n\n        post_refblock_start = ROUND_UP(*nb_clusters, s->refcount_block_size);\n\n        reftable_clusters = size_to_clusters(s,\n\n                                             reftable_size * sizeof(uint64_t));\n\n        /* Not pretty but simple */\n\n        if (first_free_cluster < post_refblock_start) {\n\n            first_free_cluster = post_refblock_start;\n\n        }\n\n        reftable_offset = alloc_clusters_imrt(bs, reftable_clusters,\n\n                                              refcount_table, nb_clusters,\n\n                                              &first_free_cluster);\n\n        if (reftable_offset < 0) {\n\n            fprintf(stderr, \"ERROR allocating reftable: %s\\n\",\n\n                    strerror(-reftable_offset));\n\n            res->check_errors++;\n\n            ret = reftable_offset;\n\n            goto fail;\n\n        }\n\n\n\n        goto write_refblocks;\n\n    }\n\n\n\n    assert(on_disk_reftable);\n\n\n\n    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {\n\n        cpu_to_be64s(&on_disk_reftable[refblock_index]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, reftable_offset,\n\n                                        reftable_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    assert(reftable_size < INT_MAX / sizeof(uint64_t));\n\n    ret = bdrv_pwrite(bs->file, reftable_offset, on_disk_reftable,\n\n                      reftable_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    /* Enter new reftable into the image header */\n\n    reftable_offset_and_clusters.reftable_offset = cpu_to_be64(reftable_offset);\n\n    reftable_offset_and_clusters.reftable_clusters =\n\n        cpu_to_be32(size_to_clusters(s, reftable_size * sizeof(uint64_t)));\n\n    ret = bdrv_pwrite_sync(bs->file,\n\n                           offsetof(QCowHeader, refcount_table_offset),\n\n                           &reftable_offset_and_clusters,\n\n                           sizeof(reftable_offset_and_clusters));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR setting reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {\n\n        be64_to_cpus(&on_disk_reftable[refblock_index]);\n\n    }\n\n    s->refcount_table = on_disk_reftable;\n\n    s->refcount_table_offset = reftable_offset;\n\n    s->refcount_table_size = reftable_size;\n\n    update_max_refcount_table_index(s);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    g_free(on_disk_reftable);\n\n    return ret;\n\n}\n", "idx": 14300, "substitutes": {"bs": ["bos", "fs", "rs", "ashes", "sb", "bytes", "aos", "bl", "ks", "bc", "os", "bes", "ubis", "bh", "ps", "sys", "outs", "vs", "ls", "pb", "hs", "ms", "gs", "b", "its", "js", "lbs", "sts", "bles", "bis", "cks", "bps", "BS", "ds", "ubs", "cs", "ts", "bits", "bm", "obs", "ns", "ss"], "res": ["rel", "rs", "req", "results", "re", "ress", "reg", "result", "q", "ps", "cons", "pas", "def", " Res", "err", "r", "us", "rev", "rc", "rez", "des", "ret", "ack", "der", "RES", "ro", "red", "resh", "conn", "pres", "mr", "rek", "expr", "crit", "cs", "gr", "resp", "inv", "Res", "cr", "rest", "reset", "rem"], "refcount_table": ["refcount2data", "refount_map", "refount_TABLE", "refcount_map", "refcount2table", "refcount_tr", "refCount_map", "refCount_Table", "refcount_data", "refcount_point", "refcount__map", "refcount__table", "refcountMTABLE", "refCount_data", "refcountMtr", "refount_data", "refcount2Table", "refcount2TABLE", "refCount_point", "refount_table", "refcount_TABLE", "refcountMtable", "refCount_tr", "refcountMpoint", "refCount_TABLE", "refcount_Table", "refcount__Table", "refcount__data", "refcount2map", "refCount_table"], "nb_clusters": ["nb_Cluster", "nb_scluster", "nb_plusters", "nb_Clodes", "nb_clocations", "nb_pluster", "nb_shusters", "nb_clanks", "nb_clblocks", "nb_sclocations", "nb_shblocks", "nb_combodes", "nb_planks", "nb_custers", "nb_custer", "nb_ciders", "nb_colusters", "nb_colblocks", "nb_clanches", "nb_cliders", "nb_plblocks", "nb_plocations", "nb_shanches", "nb_clodes", "nb_Clusters", "nb_shuster", "nb_splanks", "nb_colanches", "nb_combiders", "nb_spluster", "nb_splusters", "nb_splocations", "nb_codes", "nb_coluster", "nb_planches", "nb_combusters", "nb_sclanks", "nb_combuster", "nb_Cliders", "nb_sclusters", "nb_cluster"], "s": ["h", "fs", "rs", "sb", "ants", "settings", "ops", "ses", "S", "os", "als", "sv", "c", "ps", "ss", "comm", "conf", "p", "sys", "es", "r", "vs", "ls", "hs", "ms", "aws", "gs", "b", "ats", "its", "js", "sa", "ims", "sp", "spec", "ags", "sq", "sw", "less", "t", "ds", "cs", "ts", "is", "bits", "stats", "ins", "qs", "parts", "ns", "sts"], "refblock_offset": ["refblockxstart", "refBlock_error", "reflock_location", "refblock_point", "refblock__offset", "refblockxoffset", "reflink_off", "refblock_addr", "refblock_length", "reflock_addr", "refBlock_offset", "refblock__position", "refblock_location", "refbl_point", "refbl_off", "reflock_offset", "refblock_slot", "refblock_address", "refblockxaddr", "reflink_error", "refblockxerror", "reflink_offset", "refblockxlocation", "refblockxaddress", "refblock__error", "refBlock_slot", "refblock_error", "refblock_off", "refbl_offset", "refblock_position", "refblockxoff", "reflink_start", "refblock__length", "refBlock_index", "refbl_error", "reflock_address"], "refblock_start": ["refblockxstart", "refblock_point", "refblockxoffset", "refrow_start", "refrecord_start", "refblock_last", "refblockzindex", "refblock_key", "refblockxkey", "refrecordxoffset", "refrow_shift", "refrecordxkey", "refblock0stop", "refrecordxstart", "refblockzlast", "refblock_end", "refrecord_index", "refblockzpoint", "refblock_stop", "refrow_end", "refblock0offset", "refblockxindex", "refrecord_offset", "refrecord_key", "refrecordxindex", "refrow_index", "refblock0shift", "refblock_shift", "refblock0start", "refblockzstart"], "refblock_index": ["refbox_index", "refblock2ind", "refboxipinter", "refBlock_ind", "refblockipstart", "refblock_length", "refBlock_offset", "refblockipinfo", "refblock_num", "refboxipinfo", "refblock_info", "refblockTheindex", "refboxipstart", "refbox_info", "refblockipinter", "refblock_no", "refbox_inter", "refBlock_length", "refblockTheno", "refblock1offset", "refblock1index", "refcase_ind", "refblock1ind", "refblock2index", "refcase_index", "refblock_inter", "refblock2num", "refcase_no", "refcase_position", "refblockTheind", "refblock_position", "refblock1length", "refboxipindex", "refblock2offset", "refblock_ind", "refbox_start", "refBlock_index", "refblockipindex", "refblockTheposition"], "on_disk_reftable": ["on_disk_reaftabe", "on_disk_reaftorable", "on_disk_preftables", "on_disk_reffabe", "on_disk_preaftables", "on_disk_reftorable", "on_disk_preaftabe", "on_disk_reptorable", "on_disk_reffable", "on_disk_preftorable", "on_disk_reffables", "on_disk_preftable", "on_disk_reaftables", "on_disk_reptabe", "on_disk_preaftorable", "on_disk_reptables", "on_disk_refforable", "on_disk_reaftable", "on_disk_reftabe", "on_disk_preftabe", "on_disk_reptable", "on_disk_reftables", "on_disk_preaftable"], "on_disk_refblock": ["on_disk_referenceBlock", "on_disk_referencebl", "on_disk_nextbl", "on_disk_nextBlock", "on_disk_referenceblock", "on_disk_lastBlock", "on_disk_lastbl", "on_disk_refbl", "on_disk_nextblock", "on_disk_refBlock", "on_disk_lastblock"], "QEMU_PACKED": ["QEMU_PACER", "QEMU_MIXED", "QEMU_PACKed", "QEMU_PIXED", "QEMU_MACKER", "QEMU_MACKed", "QEMU_PAC2", "QEMU_PADD2", "QEMU_PADDED", "QEMU_MACKED", "QEMU_MIX2", "QEMU_PIXER", "QEMU_PIXed", "QEMU_MIXER", "QEMU_MIXed", "QEMU_PIX2", "QEMU_PACK2", "QEMU_PACED", "QEMU_PADDed", "QEMU_PACed", "QEMU_PADDER", "QEMU_PACKER", "QEMU_MACK2"], "cluster": ["plorum", "scorum", "scoci", " clocation", "collique", "plluster", "oclorum", "oclust", " cloci", "chust", "cloci", "chuster", "ploser", "chumn", "scusters", "gloser", "clorum", "plancer", "chocation", "chique", "bloci", "chluster", "clocation", "plust", "bluster", "ocluster", "closer", "collancer", "clancer", "colloser", "oclluster", " clluster", "glancer", "glust", " clusters", "colluster", "collocation", "collust", "scluster", "clique", "clluster", "blusters", "pluster", "CLuster", "blocation", "gluster", "CLust", "plumn", "scocation", "scust", "scuster", " clumn", "clust", " clust", "clumn", "CLique", "CLocation", "clusters"], "check_errors": ["check_rors", "checkitydetails", "checkityresults", "check_results", "max_rors", "check_details", "checkityerrors", "checkityrors", "max_errors", "max_details", "max_results"], "new_on_disk_reftable": ["new_on_disk_reffab", "new_on_disk_reaftables", "new_on_disk_revtables", "new_on_disk_preftables", "new_on_disk_prectable", "new_on_disk_rectab", "new_on_disk_reftab", "new_on_disk_reaftable", "new_on_disk_preptable", "new_on_disk_reffables", "new_on_disk_reptabe", "new_on_disk_reptable", "new_on_disk_preftable", "new_on_disk_preftive", "new_on_disk_reafttable", "new_on_disk_precttable", "new_on_disk_reftabe", "new_on_disk_rectables", "new_on_disk_revtable", "new_on_disk_rectabe", "new_on_disk_preftabe", "new_on_disk_reffable", "new_on_disk_prectables", "new_on_disk_prectab", "new_on_disk_preptables", "new_on_disk_prefttable", "new_on_disk_preptive", "new_on_disk_rective", "new_on_disk_rectable", "new_on_disk_reptables", "new_on_disk_preftab", "new_on_disk_recttable", "new_on_disk_reftables", "new_on_disk_revtabe", "new_on_disk_reptive", "new_on_disk_preptabe", "new_on_disk_reftive", "new_on_disk_refftable", "new_on_disk_reaftab", "new_on_disk_refttable", "new_on_disk_revtive"], "reftable_clusters": ["reftable_glusters", "reftable_clroups", "reftable_custers", "reftable_glroups", "reftable_colusters", "reftable_colroups", "reftable_cocations", "reftable_clocations", "reftable_colocations", "reftable_glocations", "reftable_croups"]}}
{"project": "FFmpeg", "commit_id": "f1ffb01ee9fd3a15c395c3cf6ff362ac5cd668d0", "target": 0, "func": "static int synchronize_audio(VideoState *is, short *samples,\n\n                             int samples_size1, double pts)\n\n{\n\n    int n, samples_size;\n\n    double ref_clock;\n\n\n\n    n = 2 * is->audio_st->codec->channels;\n\n    samples_size = samples_size1;\n\n\n\n    /* if not master, then we try to remove or add samples to correct the clock */\n\n    if (((is->av_sync_type == AV_SYNC_VIDEO_MASTER && is->video_st) ||\n\n         is->av_sync_type == AV_SYNC_EXTERNAL_CLOCK)) {\n\n        double diff, avg_diff;\n\n        int wanted_size, min_size, max_size, nb_samples;\n\n\n\n        ref_clock = get_master_clock(is);\n\n        diff = get_audio_clock(is) - ref_clock;\n\n\n\n        if (diff < AV_NOSYNC_THRESHOLD) {\n\n            is->audio_diff_cum = diff + is->audio_diff_avg_coef * is->audio_diff_cum;\n\n            if (is->audio_diff_avg_count < AUDIO_DIFF_AVG_NB) {\n\n                /* not enough measures to have a correct estimate */\n\n                is->audio_diff_avg_count++;\n\n            } else {\n\n                /* estimate the A-V difference */\n\n                avg_diff = is->audio_diff_cum * (1.0 - is->audio_diff_avg_coef);\n\n\n\n                if (fabs(avg_diff) >= is->audio_diff_threshold) {\n\n                    wanted_size = samples_size + ((int)(diff * is->audio_st->codec->sample_rate) * n);\n\n                    nb_samples = samples_size / n;\n\n\n\n                    min_size = ((nb_samples * (100 - SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;\n\n                    max_size = ((nb_samples * (100 + SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;\n\n                    if (wanted_size < min_size)\n\n                        wanted_size = min_size;\n\n                    else if (wanted_size > max_size)\n\n                        wanted_size = max_size;\n\n\n\n                    /* add or remove samples to correction the synchro */\n\n                    if (wanted_size < samples_size) {\n\n                        /* remove samples */\n\n                        samples_size = wanted_size;\n\n                    } else if (wanted_size > samples_size) {\n\n                        uint8_t *samples_end, *q;\n\n                        int nb;\n\n\n\n                        /* add samples */\n\n                        nb = (samples_size - wanted_size);\n\n                        samples_end = (uint8_t *)samples + samples_size - n;\n\n                        q = samples_end + n;\n\n                        while (nb > 0) {\n\n                            memcpy(q, samples_end, n);\n\n                            q += n;\n\n                            nb -= n;\n\n                        }\n\n                        samples_size = wanted_size;\n\n                    }\n\n                }\n\n                av_dlog(NULL, \"diff=%f adiff=%f sample_diff=%d apts=%0.3f vpts=%0.3f %f\\n\",\n\n                        diff, avg_diff, samples_size - samples_size1,\n\n                        is->audio_clock, is->video_clock, is->audio_diff_threshold);\n\n            }\n\n        } else {\n\n            /* too big difference : may be initial PTS errors, so\n\n               reset A-V filter */\n\n            is->audio_diff_avg_count = 0;\n\n            is->audio_diff_cum       = 0;\n\n        }\n\n    }\n\n\n\n    return samples_size;\n\n}\n", "idx": 14306, "substitutes": {"is": ["bs", "fs", "needs", "orts", "isal", "ish", "ms", "news", "iss", "js", "it", "iris", "icks", "isf", "plays", "ins", "sis", "details", "info", "ii", "serv", "os", "init", "has", "ires", "tis", "isc", "as", "ik", "ics", "isi", "parts", "ns", "isl", "ist", "eps", "ois", "ls", "ir", "in", "im", "its", "trace", "isa", "ims", "are", "Is", "was", "il", "ows", "bits", "oss", "isin", "lis", "i", "sim", "ip", "p", "s", "es", "us", "ism", "does", "IS", "bis", "act", "ic", "iso", "ais", "rest", "ists", "ris", "obs"], "samples": ["tents", "Sents", "sents", "tamples", "Samples", "samps", " samps", "tamps", " sents", "Samps"], "samples_size1": ["samples_length2", "samples_size3", "samples_length1", "samples_type0", "samples_size2", "samples_type3", "samples_size0", "samples_length3", "samples_type2", "samples_type1", "samples_length0"], "pts": ["ctls", "streamsd", "rounds", "ptS", "roundsd", "streamls", "ctS", "ctsd", "streamS", "roundS", "roundls", "ptsd", "streams", "ptls", "cts"], "n": ["dn", "un", "i", "h", "d", "sn", "l", " N", "k", "nw", "z", "x", "gn", "nan", "nu", "np", "nv", "c", "number", "cn", "p", "s", "an", "m", "nm", "ne", "N", "name", "min", "ln", "nt", "count", "network", "len", "fn", "na", "ni", "size", "g", "j", "nn", "num", "en", "t", "net", "nc", "o", "v", "w", "ns", " ns"], "samples_size": ["samples32total", "samples27start", "samps_ize", "samples27sample", "samples____total", "samples_Size", "samples_style", "samplesPmember", "srooms_style", "samps_type", "samples_offset", "samples____size", "samples_type", "spaces_only", "samplesPsize", "spled_sample", "sples_size", "spaces_member", "samps_style", "samples_scale", "sples_since", "samps_done", "spled_start", "samples_done", "srooms_ize", "samples_ize", "samples32done", "samples32ize", "samples_energy", "samples_only", "samples_since", "samples____ize", "spled_score", "samps_size", "samplesPenergy", "samps_Size", "samples_score", "samples_total", "srooms_offset", "samplesPonly", "samps_scale", "spaces_energy", "spled_size", "samples32size", "samps_total", "spaces_size", "samples_start", "samples____done", "sples_style", "samples27score", "samples_member", "samples_sample", "samples27size", "srooms_size"], "ref_clock": ["refencycle", "refrescycle", "refjtime", "relative_size", " ref_time", " ref2time", "relative_cycle", "refacclock", "refacsize", "ref_switch", "refenclock", "ref_frequency", "refacshock", "relativeencycle", "refresclock", "ref2time", "ref_time", " ref_ck", "ref_ck", "relativeenclock", "refenshock", "relativeenshock", "refressize", "ref2frequency", " ref_frequency", "relative_shock", "refjck", "refensize", "relativeensize", " ref2clock", "ref_size", "refresshock", "refjclock", "refaccycle", " ref_switch", " ref2frequency", "ref_cycle", "refjswitch", "ref2clock", "relative_clock", "ref_shock"], "diff": [" difference", "dist", "dl", "d", "inf", "sum", "ref", "different", "comp", "deb", "extra", "iff", "eff", "dp", "transfer", "draw", "value", "dc", "cmp", "dy", "result", "np", "scale", "conf", "def", "erence", "change", "Diff", "df", "p", "tf", "add", "update", "desc", "alpha", "now", "dev", "none", "distance", "total", "dd", "fd", "to", "changed", "size", "range", "dust", "missing", "gap", " Diff", "step", "flo", "relative", "test", " delta", "mix", "iffs", "deg", "v", "f", "length", "delay", " differences", "shift"], "avg_diff": ["avg_mix", "avge_cmp", "avG_dist", "avg_dust", "avG_err", "avge_diff", "avge_mix", "avg_change", "avig_diff", "avig_mix", "avg_err", "avg_dist", "avig_dust", "avg_cmp", "avig_change", "avg_grad", "avG_grad", "avge_dist", "avG_diff"], "wanted_size": ["wantedingmessage", "wantedlyshape", "wanted0owner", "wantedlymember", "wanted7size", "wiedTimesize", "wneededlshape", "wanted_len", "waredTsize", "wantedlowner", "wared_speed", "want_size", "wanted0size", "wanted_owner", "wANT_stream", "wanted7status", "wiedTimelocation", "wantededscope", "want_len", "wantedlsize", "wantedlysource", "wanting_source", "wanting_size", "wanted_status", "wanted_ize", "wowed_ize", "wish_member", "wowed_message", "wanted_speed", "wanted_scale", "wanted_format", "wneeded_owner", "wanted_global", "wantedTimemin", "wanted_sized", "wanted_stream", "wanted_source", "wantedtmessage", "wanting_scale", "wiedTimemin", "wantedTsize", "wantedTimesize", "wanted\u05bcenergy", "wanted\u05bcscale", "wared_storage", "wantedTimelocation", "wantededsize", "wneeded_energy", "wishlysize", "wowedtscope", "wish_shape", "wishlymember", "wantedingscope", "wneeded_shape", "wared_size", "wanted_shape", "wanted7energy", "wanted7stream", "wanted\u05bcsize", "wowed_status", "wowed_global", "wowed_scope", "wowedtmessage", "wantedingsize", "wantedlysize", "wanted_storage", "wowed_max", "wared_format", "wantedlshape", "wneededlowner", "wantedTspeed", "wneededlsize", "wanted_member", "wied_size", "wantedlyenergy", "waredTstorage", "wanted\u05bcsource", "wantedtsize", "wantedlyscale", "wantededlen", "wowedtsize", "waredTformat", "wneededlenergy", "wishlyshape", "wanted0energy", "wanted_max", "wANT_size", "wantedTstorage", "wowedtglobal", "wanted7max", "wish_size", "wanted_location", "wanted_scope", "waredTspeed", "wanted_min", "wanting_energy", "wANT_energy", "wantedingglobal", "wanted_energy", "wied_min", "wantedtglobal", "wanted_message", "wanted0shape", "wantedlenergy", "wantedTformat", "wneeded_size", "wANT_sized", "wowed_size", "wanted7sized", "wied_location", "wanted7ize", "want_scope", "wantedtscope"], "min_size": ["admin_size", "min_small", "minsetsize", "main_location", "minlystyle", "min_term", "min_style", "min00style", "min_SIZE", "min_score", "minTstyle", " min_score", "minsetsmall", "minlymessage", "minsetlocation", "adminlysize", "minTcode", "minsetterm", "min00code", "min_location", "min_code", " min_space", "min_speed", " min_speed", "adminlymessage", "min_message", "minTsize", "min_space", "main_small", "admin_code", "adminlystyle", "admin_style", "main_term", "min00message", "min00size", "minlyscore", "adminlycode", "minlycode", " min_SIZE", "minTmessage", "admin_message", "main_size", "minlySIZE", "minlysize"], "max_size": ["maxnetsize", "max_Size", "max_scale", "max_large", "maxvalsize", "maxensize", "maxenlarge", "root_scale", "maxencity", "maxvalglobal", " max_empty", "rootlexscale", "rootlexsize", " max_SIZE", "max_city", "root_size", "maxlexsize", "maxlexnotice", "rootlexnotice", "max_notice", "maxvalempty", "maxnetcity", "maxlexscale", "primeensize", "primeencity", "maxnetlarge", "prime_global", "maxlexSize", "maxvalheight", "max__Size", "root_notice", "maxvalcity", "rootlexSize", "prime_large", "maxvallarge", "prime_city", "root_Size", "max__SIZE", "maxvalSize", "max_global", " max_height", " max_length", "primeenlarge", "primeenglobal", "maxenglobal", "max_height", "max__length", "max_length", "max__size", "max_SIZE", "max_empty", " max_Size", "maxnetglobal", "prime_size"], "nb_samples": ["nb_nsamples", "nb_subtracks", "nb42sreads", "nb_servamples", "nb_namps", "nb_namples", "nb42sanguages", "nb42nsreads", "nb_ttracks", "nb_nsreads", "nb_tacks", "nb42nsigs", "nb___sinks", "nb_sacks", "nb_tinks", "nb_svamples", "nb42sigs", "nb_sanguages", "nb42nsanguages", "nb_subamps", "nb_nsanguages", "nb_samps", "nb42samples", "nb_subamples", "nb_Samples", "nb_subents", "nb_nsigs", "nb_stracks", "nb_Sents", "nb_svanguages", "nb_ninks", "nb___samps", "nb_idsreads", "nb_idsanguages", "nb_svigs", "nb_stacks", "nb___namps", "nb_sigs", "nb_sreads", "nb_tizes", "nb_servinks", "nb_tamps", "nb_servizes", "nb_Samps", "nb_stents", "nb___namples", "nb___samples", "nb_sinks", "nb___sizes", "nb_servamps", "nb_Sacks", "nb_tents", "nb_sizes", "nb42nsamples", "nb_idsigs", "nb_seents", "nb_seamps", "nb_seamples", "nb_setracks", "nb_stamples", "nb_idsamples", "nb___ninks", "nb_svreads", "nb_tamples", "nb_stamps", "nb___nizes", "nb_nizes", "nb_sents"], "audio_diff_avg_count": ["audio_diff_avg_nr", "audio_diff_avg____count", "audio_diff_avG_Count", "audio_diff_avg__nr", "audio_diff_avg_c", "audio_diff_avg____c", "audio_diff_avg____Count", "audio_diff_avg__count", "audio_diff_avg__Count", "audio_diff_avG_count", "audio_diff_avG_nr", "audio_diff_avg__c", "audio_diff_avg_Count", "audio_diff_avg____nr", "audio_diff_avG_c", "audio_diff_avg_nb", "audio_diff_avG_nb"]}}
{"project": "FFmpeg", "commit_id": "a82468514048fb87d9bf38689866bc3b9aaccd02", "target": 1, "func": "av_cold int ff_ivi_init_planes(IVIPlaneDesc *planes, const IVIPicConfig *cfg,\n\n                               int is_indeo4)\n\n{\n\n    int p, b;\n\n    uint32_t b_width, b_height, align_fac, width_aligned,\n\n             height_aligned, buf_size;\n\n    IVIBandDesc *band;\n\n\n\n    ivi_free_buffers(planes);\n\n\n\n    if (av_image_check_size(cfg->pic_width, cfg->pic_height, 0, NULL) < 0 ||\n\n        cfg->luma_bands < 1 || cfg->chroma_bands < 1)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    /* fill in the descriptor of the luminance plane */\n\n    planes[0].width     = cfg->pic_width;\n\n    planes[0].height    = cfg->pic_height;\n\n    planes[0].num_bands = cfg->luma_bands;\n\n\n\n    /* fill in the descriptors of the chrominance planes */\n\n    planes[1].width     = planes[2].width     = (cfg->pic_width  + 3) >> 2;\n\n    planes[1].height    = planes[2].height    = (cfg->pic_height + 3) >> 2;\n\n    planes[1].num_bands = planes[2].num_bands = cfg->chroma_bands;\n\n\n\n    for (p = 0; p < 3; p++) {\n\n        planes[p].bands = av_mallocz_array(planes[p].num_bands, sizeof(IVIBandDesc));\n\n        if (!planes[p].bands)\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* select band dimensions: if there is only one band then it\n\n         *  has the full size, if there are several bands each of them\n\n         *  has only half size */\n\n        b_width  = planes[p].num_bands == 1 ? planes[p].width\n\n                                            : (planes[p].width  + 1) >> 1;\n\n        b_height = planes[p].num_bands == 1 ? planes[p].height\n\n                                            : (planes[p].height + 1) >> 1;\n\n\n\n        /* luma   band buffers will be aligned on 16x16 (max macroblock size) */\n\n        /* chroma band buffers will be aligned on   8x8 (max macroblock size) */\n\n        align_fac       = p ? 8 : 16;\n\n        width_aligned   = FFALIGN(b_width , align_fac);\n\n        height_aligned  = FFALIGN(b_height, align_fac);\n\n        buf_size        = width_aligned * height_aligned * sizeof(int16_t);\n\n\n\n        for (b = 0; b < planes[p].num_bands; b++) {\n\n            band = &planes[p].bands[b]; /* select appropriate plane/band */\n\n            band->plane    = p;\n\n            band->band_num = b;\n\n            band->width    = b_width;\n\n            band->height   = b_height;\n\n            band->pitch    = width_aligned;\n\n            band->aheight  = height_aligned;\n\n            band->bufs[0]  = av_mallocz(buf_size);\n\n            band->bufs[1]  = av_mallocz(buf_size);\n\n            band->bufsize  = buf_size/2;\n\n            if (!band->bufs[0] || !band->bufs[1])\n\n                return AVERROR(ENOMEM);\n\n\n\n            /* allocate the 3rd band buffer for scalability mode */\n\n            if (cfg->luma_bands > 1) {\n\n                band->bufs[2] = av_mallocz(buf_size);\n\n                if (!band->bufs[2])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n            if (is_indeo4) {\n\n                band->bufs[3]  = av_mallocz(buf_size);\n\n                if (!band->bufs[3])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n            /* reset custom vlc */\n\n            planes[p].bands[0].blk_vlc.cust_desc.num_rows = 0;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14308, "substitutes": {"planes": ["devices", "ubes", "views", "boards", "packs", "ques", "blocks", "pd", "ports", "services", "vals", "photos", "rows", "cats", "players", "grades", "packages", "lists", "banks", "changes", "limits", "points", "objects", "keys", "levels", "pieces", "rots", "bands", "tags", "pins", "hops", "pak", "apps", "rices", "pes", "states", "parts", "headers", "lines", "jobs", "versions", "cuts", "words", "models", "plugins", "drivers", "faces", "projects", "modules", "lights", "poses", "groups", "boxes", "sets", "frames", "anes", "ippers", "rooms", "bits", "writers", "types", "plane", "params", "codes", "bees", "sites", "settings", "pages", "files", "plates", "videos", "weights", "users", "cards", "rates", "workers", "flows", "nets", "flat", "maps", "dates", "images", "products", "classes", "works"], "cfg": ["pkg", "gas", "req", "adj", "fig", "iana", "settings", "fg", "bc", "virt", "alg", "ctl", "dc", "gz", "gg", "oga", "gn", "addr", "c", "exec", "cb", "conf", "comm", "eng", "forge", "def", "mc", "org", "err", "cgi", "args", "jac", "gp", "known", "gs", "cand", "ng", "ctx", "note", "gc", "eg", "g", "gom", "cf", "google", "og", "fine", "fle", "msg", "cap", "conn", "gate", "ctr", "fee", "config", "deg", "cmd", "gov", "ini", "bg", "Conf", "mg", "eas", "gb"], "is_indeo4": ["is_indeco4", "is_indee8", "is_indeo3", "is_indeco1", "is_indee1", "is_inde_4", "is_inde_1", "is_indeco8", "is_indeo8", "is_indee4", "is_indee3", "is_inde_8", "is_indeo1", "is_inde_3", "is_indeco3"], "p": ["pkg", "k", "padding", "np", "pers", "cp", "u", "ps", "patch", "ap", "wp", "r", "pb", "pos", "tp", "pg", "g", "it", "pod", "pt", "pr", "y", "h", "d", "rep", "power", "dp", "br", "pid", "er", "m", "pro", "vp", "sp", "at", "j", "pat", "t", "bp", "part", "perm", "f", "ping", "jp", "l", "pc", "pe", "app", "x", "pa", "c", "q", "pl", "pre", "pin", "op", "o", "a", "pp", "pi", " P", "i", "fp", "lp", "n", "progress", "point", "out", "local", "ip", "port", "ctx", "per", "P", "php", "self", "pad", "v", "w", "post", "up"], "b": ["bs", "bu", "i", "h", "l", "bar", "or", "sb", "bl", "bt", "bc", "br", "bf", "rb", "lb", "c", "bh", "cb", "bd", "ib", "r", "batch", "m", "bound", "mb", "bo", "fb", "db", "eb", "bb", "j", "back", "B", "bin", "binary", "nb", "t", "bp", "ub", "bot", "ba", "a", "ob", "v", "f", "bi", "be", "bg", "wb", "by", "base", "ab", "gb"], "b_width": ["b_port", "boxwidth", "boxduration", "a_width", "b_conn", "bibradius", "bibwidth", "blogmemory", "buf_radius", "a_conn", "a_port", "bufibduration", "boxmemory", "bufibwidth", "boxconn", "bufibmemory", "bufibradius", "b2len", "blogwidth", "b_memory", "buf_memory", "b_len", "blogradius", " b_len", "a_height", "b_duration", "bibduration", "buf_width", "b_radius", "boxheight", "boxradius", "bibmemory", "boxport", "blogduration", "b2height", "b2width", "buf_duration"], "b_height": ["bJhang", "b_history", "bb_hang", "b_data", "B_length", "bJhistory", "B_data", "b_ty", "b_gravity", " b_ty", "bJstyle", "B_resolution", "b_resolution", "bb_history", "b_hang", "b_style", " b_strength", "bb_height", "bjlength", " b_gravity", "bjheight", "bJheight", "bjresolution", "bb_style", "bjdata", "b_length", "B_height", "b_strength"], "align_fac": ["aff_acc", "alignityacc", " align_frac", "align2fac", " align_rat", "align_rat", "coord_Fac", "align_acc", " align_bu", "alignmmfac", "align_conv", "alignmmfc", "coord_fc", " align_Fac", "align2rat", "align_Fac", "coord_conv", "alignablefc", "coordmmfc", "alignmmconv", " align2rat", "align2factor", "align_fc", "align_factor", " align2factor", "alignableconv", "coordmmfac", "coordmmconv", "alignablefac", "alignityfac", "alignableFac", "alignityfactor", "aff_cand", "align_bu", "align_cand", "alignitycand", " align_factor", "aff_factor", " align2fac", "coord_fac", "alignmmFac", "align2frac", "align_frac", " align2frac", "coordmmFac", "aff_fac"], "width_aligned": [" width_shaped", "w_adjusted", "width64align", "w_initialized", "width_align", "width64angled", " width_align", "width64shaped", "width_shaped", "width_angled", "w_aligned", " width_angled", " width_covered", " width_igned", "width_adjusted", "width_igned", "width_initialized", "width64aligned", "width_covered"], "height_aligned": ["height2signed", "height2aligned", "height67aligned", "length_adj", "heightenadj", " height_signed", " height_centered", "ack67aligned", "ack_enabled", "height_agged", "height_signed", "height_centered", "ack_agged", "ack_ordered", "length_aligned", "height67enabled", "height_adj", "ack67ordered", "heightenordered", "ack67agged", "heightenalign", "height67agged", "heightenaligned", "height_ordered", "height2align", "length_rot", "height2centered", " height2signed", "height_enabled", "height67ordered", "heightenagged", "height_rot", " height2aligned", " height_align", " height2centered", "heightenenabled", "ack67enabled", "ack_aligned", "height_align", "length_align", "heightenrot", " height2align"], "buf_size": ["buf64range", "buf64SIZE", " bufxsize", "buf64speed", "bufxdim", " bufxspace", "bufxsize", "buf_range", "buf0size", " bufxcount", "bufxspace", "buf64size", "buf0speed", " bufxdim", " buf_count", "buf_SIZE", "buffer_range", "buf_speed", "buf_count", " buf_space", "buf_dim", "buffer_SIZE", " buf_dim", "buffer_speed", "bufxcount", "buf0SIZE", "buf0range", "buffer_size", "buf_space"], "band": ["channel", "power", "image", "art", "plane", "nd", "word", "node", "group", "tab", "bridge", "Band", "bd", "filter", "tag", "batch", "frequency", "flag", "field", "block", "job", "bit", "line", "back", "bank", "bin", "board", "step", " bands", "piece", "binary", "ground", "zone", "pipe", "bed", "handler", "plugin", "plug", "pixel", " Band", "part", "link", "plot", "bor", "command", "brand", "io", "pair"]}}
{"project": "FFmpeg", "commit_id": "ce551a3925a1cf9c7824e26a246b99b6773bda4b", "target": 1, "func": "static av_cold int seqvideo_decode_init(AVCodecContext *avctx)\n{\n    SeqVideoContext *seq = avctx->priv_data;\n    seq->avctx = avctx;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    seq->frame = av_frame_alloc();\n    if (!seq->frame)\n        return AVERROR(ENOMEM);\n    return 0;\n}", "idx": 14309, "substitutes": {"avctx": ["avercontext", "versys", "AVsys", "aveconfig", "avobj", "verkt", " avjp", "cvcontext", "vanctx", "verctx", " avcmp", "vertx", " avconfig", "AVcontext", "vercontext", "afcontext", "avkt", "avtx", "afobj", "afconfig", "cvctl", "AVctx", "avcontext", "afctl", "avpkg", "cvctx", " avcontext", "vancontext", "averctx", " avctl", "avctl", "aftx", " avtx", "averkt", "verpkg", "avectx", "avecontext", "avjp", "afctx", "AVtx", "AVjp", "avconfig", "aveobj", "cvtx", "avsys", " avobj", " avpkg", "vancmp", "averpkg", " avsys", "avcmp", " avkt", "AVcmp", "vanjp"], "seq": ["pkg", "iq", "queue", "req", "comp", "sim", "sequence", "ctrl", "next", "buf", "cmp", "q", "sel", "ext", "sub", "zip", "vec", "ess", "batch", "qa", "syn", "desc", "flow", "eq", "mp", "sec", "iter", "gen", "len", "spec", "job", "j", "feat", "sq", "msg", " sequence", "cl", "mod", "ec", "capt", "Sequ", "test", "pse", "sc", "sup", "obs", "sequ"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static BlockAIOCB *bdrv_co_aio_rw_vector(BdrvChild *child,\n\n                                         int64_t sector_num,\n\n                                         QEMUIOVector *qiov,\n\n                                         int nb_sectors,\n\n                                         BdrvRequestFlags flags,\n\n                                         BlockCompletionFunc *cb,\n\n                                         void *opaque,\n\n                                         bool is_write)\n\n{\n\n    Coroutine *co;\n\n    BlockAIOCBCoroutine *acb;\n\n\n\n    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);\n\n    acb->child = child;\n\n    acb->need_bh = true;\n\n    acb->req.error = -EINPROGRESS;\n\n    acb->req.sector = sector_num;\n\n    acb->req.nb_sectors = nb_sectors;\n\n    acb->req.qiov = qiov;\n\n    acb->req.flags = flags;\n\n    acb->is_write = is_write;\n\n\n\n    co = qemu_coroutine_create(bdrv_co_do_rw);\n\n    qemu_coroutine_enter(co, acb);\n\n\n\n    bdrv_co_maybe_schedule_bh(acb);\n\n    return &acb->common;\n\n}\n", "idx": 14324, "substitutes": {"child": ["h", "brother", "i", "ch", "rel", "ind", "poll", "parent", "cel", "pc", "bl", "th", "x", "node", "col", "c", "q", "background", "force", "root", "sub", "client", "batch", "add", "ach", "pb", "cell", "key", "handle", "desc", "raw", "close", "Child", "entry", "b", "dev", "nt", "count", "shell", "block", "oll", "ctx", "children", "ay", "job", "ew", "row", "other", "cl", "seq", "self", "unk", "v", "base", "w"], "sector_num": ["sectoritynom", " sector_Num", "sector_orig", "serveritynam", "server_nom", "server_nam", "sector_Num", "sector_nam", " sector_mon", "serveritynom", "sectoritynumber", "sectoritynam", "sector_number", "sectoritynum", "serveritynumber", "server_num", " sector_orig", "sector_mon", "server_number", "serveritynum", "sector_nom"], "qiov": [" qiour", " qovi", "eqdyl", " qisco", "eqiour", "quiov", "Qdyl", "chiov", "Qiv", "Qovi", " qiop", " qiv", "quiv", "Qiov", " qiev", "qvr", "chiev", "quisco", "qdyl", "Qiop", "qiop", "Qiour", "qovi", "qiour", "qiv", "eqiov", "qiev", "quvr", "chisco", "chvr", "eqovi", "quiour", "quiop", "quiev", " qdyl", " qvr", "qisco"], "nb_sectors": ["nb_suers", "nb_suivers", "nb_veivers", "nb_veors", "nb_belements", "nb_vectors", "nb_spevers", "nb_pevers", "nb_veers", "nb_seers", "nb_peors", "nb_specs", "nb_suors", "nb_peivers", "nb_pecs", "nb_seivers", "nb_becs", "nb_pelements", "nb_secs", "nb_spectors", "nb_vecs", "nb_speors", "nb_velements", "nb_spelements", "nb_pectors", "nb_suctors", "nb_selements", "nb_severs", "nb_peers", "nb_bevers", "nb_seors", "nb_bectors"], "flags": ["details", "fps", "mods", "abilities", "limits", "phones", "fts", "settings", "ads", "alf", "reports", "amps", "levels", "styles", "FLAG", "heads", "ps", " offsets", "xf", "s", "weights", "atts", "args", "posts", "fits", "bugs", "options", "ms", "flag", "faces", "Flags", "locks", "offs", "tags", "ags", "groups", "vals", "pins", " futures", "cats", "utils", "bps", " quirks", " styles", "properties", "acts", "comments", "iffs", "items", "bits", "cmd", "types", "wcs", "stats", "forces", "grades", "mask", " mods", " interests"], "cb": ["bs", "fp", "sb", "abb", "bt", "bc", "ck", "bf", "xb", "rb", "ctrl", "cli", "lb", "c", "cp", "cgi", "pb", "callback", "fb", "obb", "db", "cc", "eb", "ctx", "cv", "cf", "erb", "func", "nb", "fw", "bp", "nc", "fc", "cmd", "kb", "ob", "wb", "CB", "cd", "gb", "ub"], "opaque": ["Opulent", "operacity", "psole", "operque", "ropsole", "ropaque", " opaques", "pacity", "opsole", "Opacity", "pque", "operaque", "Opaques", "opque", " opulent", "paque", "opacity", "opulent", "pulent", " opacity", "opaques", "ropque", "paques", "Opaque", "opersole", "ropacity"], "is_write": ["has_writ", "is__exit", " is_exit", "Is_fine", "Is_write", "is__read", "is_writ", "has_writer", "Is_writ", " is_read", "has_wait", "is_writer", "is_wait", "is_read", " is_writ", "has_write", "Is_Write", "is__writ", "is__write", "is_Write", "is_fine", "is_exit"], "co": ["ror", "cor", "con", "ano", " Co", "pc", "ko", "go", "oe", "local", "col", "so", "c", "cu", "cons", "loc", "oo", "fo", "mo", "cover", "bo", "lo", "ho", "oll", "cc", "com", "ctx", "ro", "coll", "cho", "soc", "cro", "ico", "aco", "coord", "coe", "po", "CO", "fc", "o", "ob", "Co", "PO", "flo", "io"], "acb": ["accb", "pacbr", "achmb", "abb", "sacrb", "acrb", "facp", "sacl", "acba", "accbe", "ach", "acnb", "actb", "acsb", "acbr", " acsb", "ica", "saca", "acl", "facl", "acca", "acp", " acbb", "ainba", "icbb", "accbd", "icba", " acbe", " acbs", "abh", "pacnb", "aconb", "acbc", "jacsb", "pacl", "jacbe", "pacsb", "accsb", " cacsb", "aca", "accbc", " acn", "sacbd", "accbs", "accn", "absb", "abnb", "accrb", " cacbs", " cacp", "pach", "sacb", "pacb", "icb", "ac2", "acbs", " acnb", "facn", " acrb", " acba", "icn", "micbe", "ainn", "micbc", "facbe", "actmb", "sacn", "icbd", "ainb", "facmb", "aconn", "acc", "micsb", "acn", "accl", "micb", " acmb", "sacc", "aconbe", "acbd", " acp", "Acb", "achbe", "achb", "Acba", "accba", "acmb", "Acbb", "jacb", "actbe", " ac2", "facb", "acon2", "accc", " acbr", "acch", "actp", "accbr", " cacb", "jacbc", "acbe", "accnb", "achn", "ainnb", "icl", "accp", " acbd", "fac2", "acbb", "icc", " acl"]}}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int standard_decode_picture_secondary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status = 0, index;\n\n\n\n    switch (v->s.pict_type)\n\n    {\n\n    case P_TYPE: status = decode_p_picture_secondary_header(v); break;\n\n    case B_TYPE: status = decode_b_picture_secondary_header(v); break;\n\n    case BI_TYPE:\n\n    case I_TYPE: break; //Nothing needed as it's done in the epilog\n\n    }\n\n    if (status < 0) return FRAME_SKIPED;\n\n\n\n    /* AC Syntax */\n\n    v->ac_table_level = decode012(gb);\n\n    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)\n\n    {\n\n        v->ac2_table_level = decode012(gb);\n\n    }\n\n    /* DC Syntax */\n\n    index = decode012(gb);\n\n    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];\n\n    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];\n\n   \n\n    return 0;\n\n}\n", "idx": 14350, "substitutes": {"v": ["i", "wire", "vc", "view", "h", "l", "tv", "version", "ve", "av", "V", "conv", "x", "value", "nv", "video", "c", "sv", "q", "ver", "p", "s", "uv", "vim", "m", "vs", "vp", "b", "e", "vt", "vi", "lv", "cv", "form", "g", "it", "ev", "j", "iv", "qv", "ov", "vv", "vr", "qu", "inv", "o", "val", "f", "y", "vd", "w", "vm"], "gb": ["uf", "gd", "GB", "py", "sb", "pc", "fg", "bc", "gm", "hub", "bt", "bf", "rb", "gg", "gu", " GB", "hz", "cb", "bn", "bridge", "vg", "cgi", "gp", "cfg", "mb", "storage", "gs", "b", "fb", "db", "eb", "box", "xy", "ctx", "gc", "bb", "cv", "csv", "eg", "g", "rg", "rect", "hog", "gt", "nb", "fc", "gif", "kb", "wb", "gov", "bg", "bm", "Gb"], "index": ["context", "i", "device", "ind", "sum", "type", "n", "condition", "insert", "status", "level", "point", "server", "x", "error", "connection", "input", "c", "dimension", "find", "connect", "interface", "check", "position", "loc", "list", "set", "Index", "add", "store", "key", "scan", "si", "capacity", "zero", "empty", "pos", "code", "seek", "count", "member", "instance", "id", "size", "j", "offset", "num", "lock", "row", "ex", "order", "axis", "test", "ix", "val", "scope", "length", "example"]}}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n    NMIClass *nc = NMI_CLASS(oc);\n\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->ri_allowed = true;\n\n    s390mc->cpu_model_allowed = true;\n\n    s390mc->css_migration_enabled = true;\n\n    s390mc->gs_allowed = true;\n\n    mc->init = ccw_init;\n\n    mc->reset = s390_machine_reset;\n\n    mc->hot_add_cpu = s390_hot_add_cpu;\n\n    mc->block_default_type = IF_VIRTIO;\n\n    mc->no_cdrom = 1;\n\n    mc->no_floppy = 1;\n\n    mc->no_serial = 1;\n\n    mc->no_parallel = 1;\n\n    mc->no_sdcard = 1;\n\n    mc->use_sclp = 1;\n\n    mc->max_cpus = S390_MAX_CPUS;\n\n    mc->has_hotpluggable_cpus = true;\n\n    mc->get_hotplug_handler = s390_get_hotplug_handler;\n\n    mc->cpu_index_to_instance_props = s390_cpu_index_to_props;\n\n    mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;\n\n    /* it is overridden with 'host' cpu *in kvm_arch_init* */\n\n    mc->default_cpu_type = S390_CPU_TYPE_NAME(\"qemu\");\n\n    hc->plug = s390_machine_device_plug;\n\n    hc->unplug_request = s390_machine_device_unplug_request;\n\n    nc->nmi_monitor_handler = s390_nmi;\n\n}\n", "idx": 14356, "substitutes": {"oc": ["vc", "ocation", "voc", "pc", "cms", "bc", "alloc", "unc", "dc", "cot", "c", "loc", "oid", "mic", "oco", "mac", "ot", "cc", "rc", "toc", "ok", "OC", "ocr", "og", "nic", "arc", "soc", "aco", "ic", "ec", "osc", "uc", "roc", "o", "ob", "ac", "oci", "co"], "data": ["d", "info", " DATA", "Data", "di", "DATA", "json", "out", "init", "result", "ata", "new", "rew", "def", "bus", "raw", "name", "rc", "res", "bin", "config", "o", "rec", "obj", "dat", "mu"], "mc": ["abc", "vc", "cache", "pc", "cms", "bc", "di", "lc", "sim", "custom", "dc", "cmp", "cm", "c", "cp", "yes", "MC", "mic", "disc", "m", "sam", "Mc", "any", "cfg", "mn", "mk", "ms", "cci", "mem", "mac", "md", "tc", "mp", "cc", "multi", "mint", "gc", "spec", " MC", "OC", "tic", "module", "mot", "nic", "ml", "arc", "disk", "mx", "conn", "lim", "anc", "mr", "mt", "ic", "ec", "mm", "css", "meta", "mod", "tm", "mos", "fc", "cs", "mi", "uc", "ac", "doc", "bm", "can", "icc", "co"], "nc": ["psc", "n", "pc", "nz", "nih", "bc", "ck", "unc", "dc", "nv", "np", "xc", "hw", "cn", "nm", "mn", "tc", "nt", "cc", "isc", "rc", "ctx", "gc", "toc", "rn", "nic", "nn", "NC", "conn", "anc", "nec", "ic", "nl", "ec", "fc", "cs", "roc", "ns"], "hc": ["hashci", "phci", "thp", "phc", "phac", "hashac", "hac", "ohcu", "hcu", "thac", "hdc", "Hdc", "Hc", "Hpc", "ohpc", "ohp", " hpc", "ohac", " hdc", "ohc", "thc", "Hac", " hcu", "hp", "hpc", "hci", " hp", " hac", " hci", "thcu", "ohdc", "hashc", "phcu", "hashcu"], "s390mc": ["S40mc", "sletcolm", "siftcci", "s380mobile", "s399mic", " s390mn", " s30nic", "s30nic", "S390MC", " s90conn", "sletmc", " s90mic", " s30mc", "S390mc", "s390MC", " s30m", "s350conn", "s380mc", "S390colm", " s30anc", "s399cci", " s390m", "s390colm", "s350MC", "s30mn", "s350m", "s30m", "sigmamic", "s90conn", " s390mem", "s392anc", "sigmaconn", "s392mc", " s390anc", " s390nic", "s390m", " s30mobile", "s390anc", "s40mc", "s392mic", "s30mic", "s30mobile", "s392nic", "s399mn", "sigmamc", "s350mem", "s390mn", " s390mobile", "s90mc", "s390mic", " s30cci", " s30mic", "s40MC", "s399mc", " s390conn", "s40colm", "s390conn", "sletMC", "s350mobile", "sletmic", "s350mic", " s90mc", "siftmic", "siftmc", "S40MC", "s30cci", "s350colm", "s390nic", "s390mem", "s30anc", "s90mic", "s390mobile", "s399nic", "S390mic", "s90mem", "sigmamem", "s40mic", "s380mic", " s90mem", "s30mc", "S40mic", "siftmn", "s380m", " s390mic", "s350mc", "s399anc", " s30mn", "S40colm", " s390cci", "s390cci"]}}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)\n\n{\n\n    buf[0] = 0;\n\n    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);\n\n    AV_WB16(&buf[4], s->w);\n\n    AV_WB16(&buf[6], s->h);\n\n    AV_WB16(&buf[8], num_strips);\n\n\n\n    return CVID_HEADER_SIZE;\n\n}\n", "idx": 14359, "substitutes": {"s": ["h", "fs", "rs", "sg", "sb", "n", "serv", "ses", "S", "als", "c", "sv", "ps", "comm", "conf", "p", "r", "ess", "aws", "gs", "ats", "in", "b", "js", "as", "sts", "w", "spec", "sq", "ex", "ds", "self", "cs", "ts", "is", "a", "source", "ins", "qs", "ns", "ss"], "buf": ["uf", "pkg", "queue", "ff", "usr", "cache", "req", "fam", "bar", "bytes", "map", "tmp", "bc", "fac", "br", "rb", "off", "Buff", "tab", "cur", "pool", "cat", "cb", "bh", "loc", "vec", "err", "arr", "batch", "img", "ptr", "pb", "cast", "cam", "desc", "args", "buff", "bag", "port", "pos", "mem", "b", "window", "db", "box", "buffer", "font", "env", "cv", "paste", "Buffer", "cap", "seq", "proc", "func", "pack", "late", "bp", "aka", "cmd", "doc"], "num_strips": ["num_wraPS", "num_snips", "num_snPS", "num_striops", "num_snps", "num_stripped", "num_stripips", "num_snops", "num_stripps", "num_striips", "num_wrapped", "num_rips", "num_wraops", "num_stripPS", "num_wraps", "num_strippped", "num_ripped", "num_riops", "num_riips", "num_stripops", "num_wraips", "num_striPS"], "data_size": ["data2length", "DATA_Size", "data_SIZE", "DATA_size", "data_source", "DATA_SIZE", "data_length", "DATA_source", "data2size", "data_Size", "data2Size", "DATA_length", "data2SIZE"]}}
{"project": "FFmpeg", "commit_id": "f907615f0813e8499f06a7eebccf1c63fce87c8e", "target": 1, "func": "static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n\n\n    pc->enc = av_mallocz(sizeof(MpegEncContext));\n\n    if (!pc->enc)\n\n        return -1;\n\n    pc->first_picture = 1;\n\n\n    return 0;\n\n}", "idx": 14362, "substitutes": {"s": ["h", "i", "fs", "rs", "n", "sb", "ses", "S", "os", "c", "sv", "ps", "p", "sys", "r", "set", "aws", "ms", "sac", "gs", "ats", "js", "as", "sa", "sts", "sq", "less", "acs", "ds", "cs", "ts", "a", "ins", "qs", "ns", "ss"], "pc": ["pkg", "oc", "vc", "lp", "bc", "ck", "lc", "unc", "pa", "etc", "dc", "px", "c", "cp", "xc", "cu", "p", "mc", "wp", "pb", "pic", "pn", "tc", "pd", "cc", "tp", "rc", "ctx", "gc", "ack", "kt", "amp", "anc", "proc", "ic", "ct", "soc", "acs", "ec", " mp", "nc", "fc", "pr", "pt", "cs", "pan", "uc", "ac", "pi", "td", "icc", "PC", "pm", "co", "pac"]}}
{"project": "FFmpeg", "commit_id": "a6d6b8a20072a5919d38258dd48cc612e2372f81", "target": 1, "func": "const AVOption *av_opt_next(void *obj, const AVOption *last)\n\n{\n\n    AVClass *class = *(AVClass**)obj;\n\n    if (!last && class->option[0].name) return class->option;\n\n    if (last && last[1].name)           return ++last;\n\n    return NULL;\n\n}\n", "idx": 14366, "substitutes": {"obj": ["pkg", "elt", "opt", "tmp", "objects", "txt", "rb", "off", "next", "src", "oid", "org", "arr", "err", "lass", "oj", "owner", "impl", "ent", "att", "nt", "js", "ot", "instance", "ctx", "object", "rect", "str", "act", "og", "inst", "typ", "attr", "o", "rt", "ob", "onet", "Obj"], "last": ["kind", "cycle", "info", "cache", "end", "parent", "th", "nd", "style", "slave", "br", "only", "local", "next", "forced", "full", "ast", "state", "Last", "old", "las", "global", "st", "tag", "list", "empty", "any", "recent", "push", "ent", "good", "close", "native", "rev", "nt", "count", "tail", "final", "active", "total", "always", "str", "show", "latest", "node", "data", "max", "weak", "prev", "bottom", "leaf", "highest", "stat", "rest", "all", "first", "length", "needed", "never", "table", "command", "reverse", "est"], "class": ["con", "type", "parent", "package", " CLASS", "style", "node", "product", "util", "CLASS", "top", "c", "this", "lass", "interface", "tag", "from", "cast", "name", "common", "instance", "attribute", "classified", "object", "spec", "module", "use", "Class", "cl", "pack", "self", " Class", "file", "lib", "config", "ace", "section", "function", "base", "classes", "future", "first", "ass", "all", "co"]}}
{"project": "FFmpeg", "commit_id": "369cb092ecbbaff20bb0a2a1d60536c3bc04a8f0", "target": 1, "func": "static void do_audio_out(AVFormatContext *s, OutputStream *ost,\n\n                         InputStream *ist, AVFrame *decoded_frame)\n\n{\n\n    uint8_t *buftmp;\n\n\n\n    int size_out, frame_bytes, resample_changed, ret;\n\n    AVCodecContext *enc = ost->st->codec;\n\n    AVCodecContext *dec = ist->st->codec;\n\n    int osize = av_get_bytes_per_sample(enc->sample_fmt);\n\n    int isize = av_get_bytes_per_sample(dec->sample_fmt);\n\n    uint8_t *buf = decoded_frame->data[0];\n\n    int size     = decoded_frame->nb_samples * dec->channels * isize;\n\n    int out_linesize = 0;\n\n    int buf_linesize = decoded_frame->linesize[0];\n\n\n\n    get_default_channel_layouts(ost, ist);\n\n\n\n    if (alloc_audio_output_buf(dec, enc, decoded_frame->nb_samples, &out_linesize) < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Error allocating audio buffer\\n\");\n\n        exit_program(1);\n\n    }\n\n\n\n    if (audio_sync_method > 1                      ||\n\n        enc->channels       != dec->channels       ||\n\n        enc->channel_layout != dec->channel_layout ||\n\n        enc->sample_rate    != dec->sample_rate    ||\n\n        dec->sample_fmt     != enc->sample_fmt)\n\n        ost->audio_resample = 1;\n\n\n\n    resample_changed = ost->resample_sample_fmt  != dec->sample_fmt ||\n\n                       ost->resample_channels    != dec->channels   ||\n\n                       ost->resample_channel_layout != dec->channel_layout ||\n\n                       ost->resample_sample_rate != dec->sample_rate;\n\n\n\n    if ((ost->audio_resample && !ost->avr) || resample_changed) {\n\n        if (resample_changed) {\n\n            av_log(NULL, AV_LOG_INFO, \"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:0x%\"PRIx64\" to rate:%d fmt:%s ch:%d chl:0x%\"PRIx64\"\\n\",\n\n                   ist->file_index, ist->st->index,\n\n                   ost->resample_sample_rate, av_get_sample_fmt_name(ost->resample_sample_fmt),\n\n                   ost->resample_channels, ost->resample_channel_layout,\n\n                   dec->sample_rate, av_get_sample_fmt_name(dec->sample_fmt),\n\n                   dec->channels, dec->channel_layout);\n\n            ost->resample_sample_fmt  = dec->sample_fmt;\n\n            ost->resample_channels    = dec->channels;\n\n            ost->resample_channel_layout = dec->channel_layout;\n\n            ost->resample_sample_rate = dec->sample_rate;\n\n            if (ost->avr)\n\n                avresample_close(ost->avr);\n\n        }\n\n        /* if audio_sync_method is >1 the resampler is needed for audio drift compensation */\n\n        if (audio_sync_method <= 1 &&\n\n            ost->resample_sample_fmt  == enc->sample_fmt &&\n\n            ost->resample_channels    == enc->channels   &&\n\n            ost->resample_channel_layout == enc->channel_layout &&\n\n            ost->resample_sample_rate == enc->sample_rate) {\n\n            ost->audio_resample = 0;\n\n        } else if (ost->audio_resample) {\n\n            if (!ost->avr) {\n\n                ost->avr = avresample_alloc_context();\n\n                if (!ost->avr) {\n\n                    av_log(NULL, AV_LOG_FATAL, \"Error allocating context for libavresample\\n\");\n\n                    exit_program(1);\n\n                }\n\n            }\n\n\n\n            av_opt_set_int(ost->avr, \"in_channel_layout\",  dec->channel_layout, 0);\n\n            av_opt_set_int(ost->avr, \"in_sample_fmt\",      dec->sample_fmt,     0);\n\n            av_opt_set_int(ost->avr, \"in_sample_rate\",     dec->sample_rate,    0);\n\n            av_opt_set_int(ost->avr, \"out_channel_layout\", enc->channel_layout, 0);\n\n            av_opt_set_int(ost->avr, \"out_sample_fmt\",     enc->sample_fmt,     0);\n\n            av_opt_set_int(ost->avr, \"out_sample_rate\",    enc->sample_rate,    0);\n\n            if (audio_sync_method > 1)\n\n                av_opt_set_int(ost->avr, \"force_resampling\", 1, 0);\n\n\n\n            /* if both the input and output formats are s16 or u8, use s16 as\n\n               the internal sample format */\n\n            if (av_get_bytes_per_sample(dec->sample_fmt) <= 2 &&\n\n                av_get_bytes_per_sample(enc->sample_fmt) <= 2) {\n\n                av_opt_set_int(ost->avr, \"internal_sample_fmt\", AV_SAMPLE_FMT_S16P, 0);\n\n            }\n\n\n\n            ret = avresample_open(ost->avr);\n\n            if (ret < 0) {\n\n                av_log(NULL, AV_LOG_FATAL, \"Error opening libavresample\\n\");\n\n                exit_program(1);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (audio_sync_method > 0) {\n\n        double delta = get_sync_ipts(ost, ist->last_dts) * enc->sample_rate - ost->sync_opts -\n\n                       av_fifo_size(ost->fifo) / (enc->channels * osize);\n\n        int idelta = delta * dec->sample_rate / enc->sample_rate;\n\n        int byte_delta = idelta * isize * dec->channels;\n\n\n\n        // FIXME resample delay\n\n        if (fabs(delta) > 50) {\n\n            if (ist->is_start || fabs(delta) > audio_drift_threshold*enc->sample_rate) {\n\n                if (byte_delta < 0) {\n\n                    byte_delta = FFMAX(byte_delta, -size);\n\n                    size += byte_delta;\n\n                    buf  -= byte_delta;\n\n                    av_log(NULL, AV_LOG_VERBOSE, \"discarding %d audio samples\\n\",\n\n                           -byte_delta / (isize * dec->channels));\n\n                    if (!size)\n\n                        return;\n\n                    ist->is_start = 0;\n\n                } else {\n\n                    av_fast_malloc(&async_buf, &allocated_async_buf_size,\n\n                                   byte_delta + size);\n\n                    if (!async_buf) {\n\n                        av_log(NULL, AV_LOG_FATAL, \"Out of memory in do_audio_out\\n\");\n\n                        exit_program(1);\n\n                    }\n\n\n\n                    if (alloc_audio_output_buf(dec, enc, decoded_frame->nb_samples + idelta, &out_linesize) < 0) {\n\n                        av_log(NULL, AV_LOG_FATAL, \"Error allocating audio buffer\\n\");\n\n                        exit_program(1);\n\n                    }\n\n                    ist->is_start = 0;\n\n\n\n                    generate_silence(async_buf, dec->sample_fmt, byte_delta);\n\n                    memcpy(async_buf + byte_delta, buf, size);\n\n                    buf = async_buf;\n\n                    size += byte_delta;\n\n                    buf_linesize = allocated_async_buf_size;\n\n                    av_log(NULL, AV_LOG_VERBOSE, \"adding %d audio samples of silence\\n\", idelta);\n\n                }\n\n            } else if (audio_sync_method > 1) {\n\n                int comp = av_clip(delta, -audio_sync_method, audio_sync_method);\n\n                av_log(NULL, AV_LOG_VERBOSE, \"compensating audio timestamp drift:%f compensation:%d in:%d\\n\",\n\n                       delta, comp, enc->sample_rate);\n\n//                fprintf(stderr, \"drift:%f len:%d opts:%\"PRId64\" ipts:%\"PRId64\" fifo:%d\\n\", delta, -1, ost->sync_opts, (int64_t)(get_sync_ipts(ost) * enc->sample_rate), av_fifo_size(ost->fifo)/(ost->st->codec->channels * 2));\n\n                avresample_set_compensation(ost->avr, comp, enc->sample_rate);\n\n            }\n\n        }\n\n    } else if (audio_sync_method == 0)\n\n        ost->sync_opts = lrintf(get_sync_ipts(ost, ist->last_dts) * enc->sample_rate) -\n\n                                av_fifo_size(ost->fifo) / (enc->channels * osize); // FIXME wrong\n\n\n\n    if (ost->audio_resample) {\n\n        buftmp = audio_buf;\n\n        size_out = avresample_convert(ost->avr, (void **)&buftmp,\n\n                                      allocated_audio_buf_size, out_linesize,\n\n                                      (void **)&buf, buf_linesize,\n\n                                      size / (dec->channels * isize));\n\n        size_out = size_out * enc->channels * osize;\n\n    } else {\n\n        buftmp = buf;\n\n        size_out = size;\n\n    }\n\n\n\n    /* now encode as many frames as possible */\n\n    if (!(enc->codec->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE)) {\n\n        /* output resampled raw samples */\n\n        if (av_fifo_realloc2(ost->fifo, av_fifo_size(ost->fifo) + size_out) < 0) {\n\n            av_log(NULL, AV_LOG_FATAL, \"av_fifo_realloc2() failed\\n\");\n\n            exit_program(1);\n\n        }\n\n        av_fifo_generic_write(ost->fifo, buftmp, size_out, NULL);\n\n\n\n        frame_bytes = enc->frame_size * osize * enc->channels;\n\n\n\n        while (av_fifo_size(ost->fifo) >= frame_bytes) {\n\n            av_fifo_generic_read(ost->fifo, audio_buf, frame_bytes, NULL);\n\n            encode_audio_frame(s, ost, audio_buf, frame_bytes);\n\n        }\n\n    } else {\n\n        encode_audio_frame(s, ost, buftmp, size_out);\n\n    }\n\n}\n", "idx": 14372, "substitutes": {"s": ["i", "fs", "rs", "sb", "os", "src", "sv", "c", "ps", "es", "ls", "ats", "e", "as", "sa", "w", "g", "sq", "sw", "t", "ds", "is", "a", "o", "v", "ss"], "ost": ["ond", "oc", "ont", "ft", "ind", " nost", "ott", "om", "utt", "art", "hess", "ops", "ether", "orth", "oe", "os", "ast", "hop", "otype", "st", "ort", "tto", "oad", "ust", "oid", "ori", "host", "store", "et", "org", "boost", "vest", "mont", "irc", "OST", "hs", "rob", "nt", "ot", "oop", "ert", "od", "osta", "ocr", "op", "rost", "oster", "yt", "ys", "soc", "ox", "iop", "lost", "tt", "htt", "o", "oth", "rog", "onet", "rest", "ob", "oss", "lov", "or", "ore", "post", "obs", "istor", "irst", "est"], "ist": ["ft", "ith", "art", "txt", "dit", "osi", "ast", "src", "st", "ort", "isting", "istor", "wp", "ust", "icol", "et", "ird", "vp", "istant", "ism", "irc", "ilst", "its", "isc", "iss", "ert", "pir", "exist", "iz", "ih", "erd", "elist", "sts", "osit", "ict", "osp", "it", "isd", "iv", "iste", "rist", "iw", "ic", "inst", "ik", "iop", "IST", "alist", "il", "tt", "pt", "is", "oth", "isi", "ista", "ists", "ush", "rest", "hist", "ht", "htt", "irst", "est"], "decoded_frame": ["decodedptframe", "decated_frame", "decoded_sample", "decodedroyframe", "decached_component", "decachedptframe", "decode_base", "decode_frames", "decodedationcomponent", "decimated_feature", "decodededframes", "decodedptuser", "decoded___image", "decodedoyuser", "decoded_fram", "decimated_file", "decoded_file", "decodedoyframe", "decoded_profile", "decoded_feat", "decatedmysample", "decodedoycomponent", "decoded_sequence", "deccoded_sequence", "decodedoyprofile", "decodedingframe", "decodedroysequence", "decimated_fram", "decoded_base", "deccoded_frames", "decached_frame", "decode_feat", "decoded_frames", "decoded_image", "decated_sample", "decodedroyuser", "decoded_message", "decodedmyimage", "decached_profile", "decodedptcomponent", "decatedmyframe", "decodedingbase", "decimated_frame", "decodedationfile", "decodedationprofile", "decoded3feature", "decated_image", "decoded_user", "decodedationfram", "decodedationuser", "decoded3frame", "deccoded___sequence", "decoded___frames", "decoded3fram", "decoded_feature", "decodedptprofile", "deccoded_user", "decodedationfeature", "decatedmymessage", "decoded___frame", "decodedingframes", "decachedptcomponent", "deccoded___frame", "decatedmyimage", "decodededframe", "decoded___user", "deccoded___frames", "decoded___sample", "decodedmysample", "decode_frame", "decodedmymessage", "deccoded___user", "decated_message", "decachedptuser", "decoded___sequence", "decodedingfeat", "deccoded_frame", "decodededbase", "decoded3file", "decached_user", "decodededfeat", "decoded___message", "decachedptprofile", "decodedmyframe", "decodedationframe", "decoded_component", "decodedroyframes"], "buftmp": ["bufdMP", "buctup", "fufdup", "buptMP", "buctmp", "buftMP", "buptmp", "fuftMP", "fuftool", "fuftup", "buctool", "fufdmp", "buftool", "fufdool", "bufdool", "buctMP", "buftup", "fufdMP", "fuftmp", "bufdup", "buptool", "bufdmp", "buptup"], "size_out": ["size_Out", "ize_in", "size_in", "size_output", "ize_out", "size2Out", "size2output", "size2in", "ize_Out", "ize_output", "size2out"], "frame_bytes": [" frame_size", " frame_offset", "frame_offset", "frame_byte", "frame_size", " frame_byte"], "resample_changed": ["resample__change", "resample2change", "resample2Changed", "resample__created", "ressample_required", "resample2was", "ressample_forced", "resample_created", "resample___Changed", "resample__changed", "resamp_created", "resample___change", "resample2changed", "resample_Changed", "resample___was", "resamples_Changed", "ressample_changed", "resample_forced", "resample_rot", "resamples_changed", "resample___changed", "resample__rot", "resamp_change", "resample_was", "resamp_changed", "ressample_change", "resample_required", "resample_change", "resamp_rot", "resample_locked", "resamples_was", "ressample_locked", "resamples_change"], "ret": ["rel", "ref", "jp", "RET", "elt", "tmp", "status", "txt", "conv", "re", "Ret", "rew", "arr", "flag", "alt", "mem", "len", "fi", "gc", "res", "resp", "rt", "val", "aux", "reset"], "enc": ["eu", "oc", " Enc", "con", "kw", "iac", "inc", "oder", "asc", "En", "conv", "unc", "cmp", "ENC", "enth", "eng", "oen", "vec", "disc", "et", "desc", "ren", "ent", "ne", "ang", "code", "rc", "sec", "env", "ack", "ena", "eg", "exc", "Enc", "cod", "ev", "ew", "act", "acl", "iv", "conn", "en", "anc", "ox", "ec", "esc", "nc", "fc", "acc", "ens", "cmd", "ac", "lang", "rec", "emb", "encrypted", "obj"], "buf": ["uf", "queue", "map", "tmp", "bc", "txt", "br", "bf", "out", "cb", "vec", "arr", "err", "img", "pb", "raw", "buff", "mem", "b", "buffer", "cv", "msg", "data", "bin", "seq", "cmd", "doc", "output"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags)\n\n{\n\n    switch (shiftop) {\n\n    case 0: /* LSL */\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, 32 - shift);\n\n            tcg_gen_shli_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 1: /* LSR */\n\n        if (shift == 0) {\n\n            if (flags) {\n\n                tcg_gen_shri_i32(var, var, 31);\n\n                gen_set_CF(var);\n\n            }\n\n            tcg_gen_movi_i32(var, 0);\n\n        } else {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_shri_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 2: /* ASR */\n\n        if (shift == 0)\n\n            shift = 32;\n\n        if (flags)\n\n            shifter_out_im(var, shift - 1);\n\n        if (shift == 32)\n\n          shift = 31;\n\n        tcg_gen_sari_i32(var, var, shift);\n\n        break;\n\n    case 3: /* ROR/RRX */\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_rotri_i32(var, var, shift); break;\n\n        } else {\n\n            TCGv tmp = load_cpu_field(CF);\n\n            if (flags)\n\n                shifter_out_im(var, 0);\n\n            tcg_gen_shri_i32(var, var, 1);\n\n            tcg_gen_shli_i32(tmp, tmp, 31);\n\n            tcg_gen_or_i32(var, var, tmp);\n\n            dead_tmp(tmp);\n\n        }\n\n    }\n\n};\n", "idx": 14376, "substitutes": {"var": ["pkg", "rank", "view", "av", "map", "orig", "lat", "cat", "addr", "cp", "ptr", "star", "mem", "cv", "pack", "expr", "grad", "feature", "function", "vm", "vc", "usr", "kw", "bar", "tmp", "word", "temp", "ctrl", "tag", "name", "buffer", "as", "sp", "bb", "w", "cf", "iv", "msg", "mod", "coord", "vr", "cmd", "shape", "req", "type", "fac", "x", "ars", "via", "tab", "buf", "c", "sys", "err", "cast", "vs", "ser", "bag", "lv", "car", "op", "variable", "ct", "prev", "Var", "rt", "val", "wd", "let", "ref", "vari", "null", "go", "input", "ar", "ver", "p", "raw", "dev", "box", "iter", "ctx", "spec", "str", "act", "module", "row", "watch", "func", "attr", "self", "test", "v", "par", "obj", "lr"], "shiftop": ["shiftoper", "expops", "offsetcop", "shiftOP", "tipops", "hiftops", "hiftoper", "hiftop", " shiftOP", " shiftoper", "shiftcop", "tipop", "offsetOP", "shiftops", "hiftOP", "expop", "tipOP", "expoper", "offsetops", "expOP", "offsetop", " shiftcop", "tipcop", " shiftops"], "shift": ["send", "ign", "shake", "error", "need", " Shift", "dest", "eng", "weight", "add", "push", "star", "tip", "close", "ffff", "sh", "use", "help", "offset", "grow", "forward", "pack", "snap", "ssh", "sign", "power", "delete", "join", "ift", "stack", "effect", "hash", "half", "ul", "alias", "focus", "set", "start", "flag", "tick", "size", "hack", "vector", "align", "ix", "lag", "length", "delay", "drop", "sum", "jp", "pop", "save", "off", "value", "center", "loc", "skip", "batch", "hide", "alt", "hift", "field", "count", "seek", "index", "move", "just", "step", "dq", "shr", "aw", "mask", "reverse", "ff", "xp", "share", "scale", "handle", "now", "carry", "window", "slice", " shifted", "Shift", "transform", "sup", "sort", "pad", "diff", " shifts"], "flags": ["fps", "details", "laws", "lines", "fs", "goal", "limits", "ants", "ments", "points", "files", "lets", "amps", "reports", "levels", "styles", "planes", "heads", "words", " Flags", "weight", "cons", "fields", "helps", "weights", "atts", "args", "bugs", "options", "opens", "mates", "ms", "flag", "gs", "features", "Flags", "aws", "ports", "members", "locks", "af", "ags", "tags", "groups", "workers", "cf", "finals", "pins", "olds", "Flag", "properties", "cs", "ts", "comments", "cond", "bits", "stats", "grades", "lag", "products", "mask", "packages", "posts"]}}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_vlan_filters(VMXNET3State *s)\n\n{\n\n    int i;\n\n\n\n    /* Copy configuration from shared memory */\n\n    VMXNET3_READ_DRV_SHARED(s->drv_shmem,\n\n                            devRead.rxFilterConf.vfTable,\n\n                            s->vlan_table,\n\n                            sizeof(s->vlan_table));\n\n\n\n    /* Invert byte order when needed */\n\n    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {\n\n        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);\n\n    }\n\n\n\n    /* Dump configuration for debugging purposes */\n\n    VMW_CFPRN(\"Configured VLANs:\");\n\n    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {\n\n        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {\n\n            VMW_CFPRN(\"\\tVLAN %d is present\", i);\n\n        }\n\n    }\n\n}\n", "idx": 14379, "substitutes": {"s": ["details", "bs", "h", "d", "fs", "rs", "changes", "n", "sb", "sl", "ops", "ses", "ears", "sql", "S", "os", "so", "c", "sv", "st", "ss", "comm", "ps", "p", "sys", "r", "store", "es", "m", "ls", "vs", "where", "hs", "aws", "gs", "its", "js", "ports", "des", "spec", "g", "services", "eps", "sq", "sw", "less", "ex", "t", "ds", "states", "cs", "ts", "is", "o", "source", "v", "stats", "qs", "w", "parts", "ns", "params", "sts"], "i": [" ki", "ski", "cli", "gu", "u", "oi", " m", " ii", "it", "g", "ci", "ex", "ki", "zi", " mi", " iter", "mi", "y", " multi", "uri", " li", "ii", "ji", " si", "ij", "init", "hi", "client", "m", " pi", "ri", "cgi", "name", "multi", "to", "j", "xi", "t", "ix", "print", "ui", "ini", "qi", "ind", "l", "ai", "di", "x", "c", "q", " bi", "ti", "li", "\u0438", "I", "si", "ori", "batch", "key", "eric", "im", "in", "ims", "fi", "index", "phi", "o", "iri", "pi", "bi", "io", "iq", "yi", "gi", "z", "point", "json", "sim", "ip", "result", "ei", "p", " j", " I", "us", "e", "chain", "ami", "remote", "iu", "id", "me", "span", " ti"]}}
{"project": "qemu", "commit_id": "a9cf98d939c4f6539fad7e7d812ea16d96ba3dc9", "target": 0, "func": "static void arm_timer_recalibrate(arm_timer_state *s, int reload)\n\n{\n\n    uint32_t limit;\n\n\n\n    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {\n\n        /* Free running.  */\n\n        if (s->control & TIMER_CTRL_32BIT)\n\n            limit = 0xffffffff;\n\n        else\n\n            limit = 0xffff;\n\n    } else {\n\n          /* Periodic.  */\n\n          limit = s->limit;\n\n    }\n\n    ptimer_set_limit(s->timer, limit, reload);\n\n}\n", "idx": 14387, "substitutes": {"s": ["bs", "h", "fs", "rs", "sb", "sl", "ses", "S", "os", "http", "sv", "q", "comm", "ss", "ps", "p", "set", "r", "es", "store", "sys", "an", "ls", "sports", "hs", "aws", "gs", "b", "js", "sp", "spec", "j", "sq", "sw", "less", "t", "ds", "se", "ts", "is", "source", "south", "a", "y", "stats", "sis", "qs", "ns", "sts"], "reload": ["Reloaded", " Reload", " reloaded", " reLoad", "Rethink", "REload", " Reloads", " reloader", "ReLoad", " rethink", "rethink", "Reloads", "REloaded", "reloads", "REloader", "reloaded", "Reload", "REthink", " Rethink", " reloads", " ReLoad", "Reloader", "reloader", "reLoad"], "limit": ["queue", "view", "l", "Limit", "limits", "condition", "cut", "map", "join", "level", "status", "time", "only", "value", "priority", "pool", "local", "margin", "message", "filter", "position", "capacity", "p", "wait", "limited", "timeout", "port", "target", "alt", "match", "window", "iter", "block", "len", "total", "Lim", "buffer", "pointer", "minimum", "size", "it", "trigger", "line", "fine", "duration", "latest", "lock", "lim", "enable", "max", "offset", "required", "late", "control", "file", "source", "lit", "pi", "print", "policy", "base", "length", "lan", "delay", "tail"]}}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_down_char(void)\n\n{\n\n    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n\n\treturn;\n\n    if (term_history[++term_hist_entry] != NULL) {\n\n\tpstrcpy(term_cmd_buf, sizeof(term_cmd_buf),\n\n                term_history[term_hist_entry]);\n\n    } else {\n\n\tterm_hist_entry = -1;\n\n    }\n\n    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n}\n", "idx": 14388, "substitutes": {"term_hist_entry": ["term_history_row", "term_hist_desc", "term_history_offset", "term_history_char", "term_history_entity", "term_hist_entity", "term_history_desc", "term_histopentity", "term_histopentry", "term_hist_row", "term_history_entry", "term_hist_window", "term_hist___no", "term_histitykey", "term_histityentry", "term_hist_offset", "term_histitydesc", "term_hist___key", "term_hist___offset", "term_history_key", "term_hist_key", "term_histitychar", "term_hist_number", "term_hist_no", "term_history_no", "term_histoprow", "term_hist___entry", "term_hist_char", "term_history_window", "term_history_number"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_log_start(target_phys_addr_t phys_addr, ram_addr_t size)\n\n{\n\n        return kvm_dirty_pages_log_change(phys_addr, size,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES);\n\n}\n", "idx": 14393, "substitutes": {"phys_addr": ["mem_addr", "physipact", " phys_adr", "physipadr", "phys_map", " phys_act", "mem_address", "physipmap", "phys_address", "physqadr", "phys_act", "mem_adr", "physqmap", "phys_adr", "physqaddr", "physqact", "physipaddr", " phys_map"], "size": ["shape", "ize", "sum", "send", "bytes", "SIZE", "small", "state", "share", "password", "sha", "scale", "root", "set", "izes", "empty", "too", "storage", "name", "read", "dim", "news", "code", "count", "path", "sh", "use", "max", " Size", "used", " sizes", "fee", "body", "is", "since", "pi", "by", "Size", "fat", "length", "area", "owner", "params"]}}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_log(int argc, const char **argv)\n\n{\n\n    int mask;\n\n    \n\n    if (argc != 2)\n\n        goto help;\n\n    if (!strcmp(argv[1], \"none\")) {\n\n        mask = 0;\n\n    } else {\n\n        mask = cpu_str_to_log_mask(argv[1]);\n\n        if (!mask) {\n\n        help:\n\n            help_cmd(argv[0]);\n\n            return;\n\n        }\n\n    }\n\n    cpu_set_log(mask);\n\n}\n", "idx": 14413, "substitutes": {"argc": ["argpc", "Argv", " argce", "Argce", " argcs", "argce", " argct", "arkce", "agpc", "Argct", "Argcs", "argcs", "argnc", "arkc", "agct", "agcs", " argpc", "Argpc", "arkv", "Argc", "Argnc", "arknc", " argnc", "argct", "agc"], "argv": ["datec", "Argv", "argpi", "argsvs", "argumentp", " argvs", " argl", "argumentvs", "argsp", "argsk", "argp", " argk", "argsc", "argspi", " argp", "argumentv", "args", "regv", "argk", "argsv", "regvs", "argsl", "argl", "argumentc", "argvs", " argpi", "regp", "Argk", "Argc", "Argl", " args", "dates", "argss", "regc", "datev", "datepi"], "mask": ["sum", "sign", "map", "can", "clean", "miss", "clear", "hash", "share", "cm", "result", "cat", "ask", "scale", "weight", "patch", "lay", "allow", "mut", "set", "zero", "list", "batch", "ma", "m", "qa", "key", "cast", "hide", "mk", "mb", "ms", "flag", "window", "match", "count", "block", "Mask", "sk", "form", "gray", "bit", "transform", "black", "offset", "lock", "msg", "mx", "row", "gate", "bool", "broad", "mt", "mail", "pack", "bug", "mark", " masked", "master", "hold", "label", "shift"]}}
{"project": "FFmpeg", "commit_id": "1a3ed056c523b4670e192301be15dbc521ec8353", "target": 0, "func": "static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)\n\n{\n\n    HEVCContext *s  = avctxt->priv_data;\n\n    int ctb_size    = 1 << s->sps->log2_ctb_size;\n\n    int more_data   = 1;\n\n    int x_ctb       = 0;\n\n    int y_ctb       = 0;\n\n    int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];\n\n\n\n    if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Impossible initial tile.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->sh.dependent_slice_segment_flag) {\n\n        int prev_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts - 1];\n\n        if (s->tab_slice_address[prev_rs] == -1) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Previous slice segment missing\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    while (more_data && ctb_addr_ts < s->sps->ctb_size) {\n\n        int ctb_addr_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts];\n\n\n\n        x_ctb = (ctb_addr_rs % ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;\n\n        y_ctb = (ctb_addr_rs / ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;\n\n        hls_decode_neighbour(s, x_ctb, y_ctb, ctb_addr_ts);\n\n\n\n        ff_hevc_cabac_init(s, ctb_addr_ts);\n\n\n\n        hls_sao_param(s, x_ctb >> s->sps->log2_ctb_size, y_ctb >> s->sps->log2_ctb_size);\n\n\n\n        s->deblock[ctb_addr_rs].beta_offset = s->sh.beta_offset;\n\n        s->deblock[ctb_addr_rs].tc_offset   = s->sh.tc_offset;\n\n        s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;\n\n\n\n        more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);\n\n        if (more_data < 0) {\n\n            s->tab_slice_address[ctb_addr_rs] = -1;\n\n            return more_data;\n\n        }\n\n\n\n\n\n        ctb_addr_ts++;\n\n        ff_hevc_save_states(s, ctb_addr_ts);\n\n        ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);\n\n    }\n\n\n\n    if (x_ctb + ctb_size >= s->sps->width &&\n\n        y_ctb + ctb_size >= s->sps->height)\n\n        ff_hevc_hls_filter(s, x_ctb, y_ctb);\n\n\n\n    return ctb_addr_ts;\n\n}\n", "idx": 14442, "substitutes": {"avctxt": ["avcttx", "avcittxt", " avcttx", "avcitxt", " avcxt", "avptxt", "avctext", "AVcctxt", " avcttxt", "AVctxt", "avconttx", "avptext", "AVcctx", " avctx", "avcontext", "AVccxt", "avcckt", "avcttxt", "avctkt", " avctkt", "avccext", "avcctxt", "AVccext", "avpttxt", "avcxt", "avctx", "avcittx", "avconttxt", "avckt", " avckt", "avcctx", "AVctext", "AVcttx", "avpttx", "avccxt", "avcitkt", "AVcttxt", "avcontxt"], "isFilterThread": ["isfilterThread", "isWebEvent", "isfilterthread", "isBrowserEvent", " isfilterThread", "isfilterEvent", " isfilterthread", " isFilterEvent", " isFilterthread", "isFilterEvent", "isWebthread", "isFilterthread", "isBrowserThread", " isfilterEvent", "isBrowserthread", "isWebThread"], "s": ["bs", "fs", "ties", "ysis", "ps", "args", "ms", "ports", "js", "g", "sw", "gets", "ex", "ares", "sc", "ins", "details", "h", "changes", "sb", "als", "os", "sv", "has", "m", "sports", "events", "as", "ags", "j", "t", "is", "source", "ains", "parts", "ns", "mys", "rs", "sl", "ions", "ies", "x", "S", "service", "c", "comm", "ls", "vs", "hs", "ats", "its", "ims", "sq", "ts", "a", "ows", "qs", "ss", "sts", "aunts", "ants", "z", "ses", "bes", "conf", "p", "es", "us", "aws", "gs", "b", "ctx", "spec", "bis", "less", "ds", "actions", "cs", "comments", "v", "stats", "w", "scl"], "ctb_addr_ts": ["ctb_ref_cs", "ctb_ptr_ps", "ctb_addr_times", "ctb_addr_ls", "ctb_addr_ats", "ctb_ref_snap", "ctb_ptr_rs", "ctb_addr_abs", "ctb_ptr_times", "ctb_addr2rs", "ctb_address_ts", "ctb_addr_snap", "ctb_addr_cs", "ctb_ptr_ts", "ctb_addr_rs", "ctb_address_rs", "ctb_ptr_ls", "ctb_addr_ps", "ctb_addr2tes", "ctb_addr2ts", "ctb_ptr_ctr", "ctb_adr_times", "ctb_addr_t", "ctb_addr_ctr", "ctb_adr_cs", "ctb_adr_ps", "ctb_ref_ts", "ctb_addr2ms", "ctb_ptr_ms", "ctb_addr_tes", "ctb_address_ps", "ctb_address_abs", "ctb_ref_t", "ctb_adr_ts", "ctb_addr_ms"]}}
{"project": "FFmpeg", "commit_id": "8155233413540c63e53a620ff5734fb4b0635611", "target": 1, "func": "static int decode_header(MPADecodeContext *s, UINT32 header)\n\n{\n\n    int sample_rate, frame_size, mpeg25, padding;\n\n    int sample_rate_index, bitrate_index;\n\n    if (header & (1<<20)) {\n\n        s->lsf = (header & (1<<19)) ? 0 : 1;\n\n        mpeg25 = 0;\n\n    } else {\n\n        s->lsf = 1;\n\n        mpeg25 = 1;\n\n    }\n\n    \n\n    s->layer = 4 - ((header >> 17) & 3);\n\n    /* extract frequency */\n\n    sample_rate_index = (header >> 10) & 3;\n\n    sample_rate = mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25);\n\n    if (sample_rate == 0)\n\n        return 1;\n\n    sample_rate_index += 3 * (s->lsf + mpeg25);\n\n    s->sample_rate_index = sample_rate_index;\n\n    s->error_protection = ((header >> 16) & 1) ^ 1;\n\n\n\n    bitrate_index = (header >> 12) & 0xf;\n\n    padding = (header >> 9) & 1;\n\n    //extension = (header >> 8) & 1;\n\n    s->mode = (header >> 6) & 3;\n\n    s->mode_ext = (header >> 4) & 3;\n\n    //copyright = (header >> 3) & 1;\n\n    //original = (header >> 2) & 1;\n\n    //emphasis = header & 3;\n\n\n\n    if (s->mode == MPA_MONO)\n\n        s->nb_channels = 1;\n\n    else\n\n        s->nb_channels = 2;\n\n    \n\n    if (bitrate_index != 0) {\n\n        frame_size = mpa_bitrate_tab[s->lsf][s->layer - 1][bitrate_index];\n\n        s->bit_rate = frame_size * 1000;\n\n        switch(s->layer) {\n\n        case 1:\n\n            frame_size = (frame_size * 12000) / sample_rate;\n\n            frame_size = (frame_size + padding) * 4;\n\n            break;\n\n        case 2:\n\n            frame_size = (frame_size * 144000) / sample_rate;\n\n            frame_size += padding;\n\n            break;\n\n        default:\n\n        case 3:\n\n            frame_size = (frame_size * 144000) / (sample_rate << s->lsf);\n\n            frame_size += padding;\n\n            break;\n\n        }\n\n        s->frame_size = frame_size;\n\n    } else {\n\n        /* if no frame size computed, signal it */\n\n        if (!s->free_format_frame_size)\n\n            return 1;\n\n        /* free format: compute bitrate and real frame size from the\n\n           frame size we extracted by reading the bitstream */\n\n        s->frame_size = s->free_format_frame_size;\n\n        switch(s->layer) {\n\n        case 1:\n\n            s->frame_size += padding  * 4;\n\n            s->bit_rate = (s->frame_size * sample_rate) / 48000;\n\n            break;\n\n        case 2:\n\n            s->frame_size += padding;\n\n            s->bit_rate = (s->frame_size * sample_rate) / 144000;\n\n            break;\n\n        default:\n\n        case 3:\n\n            s->frame_size += padding;\n\n            s->bit_rate = (s->frame_size * (sample_rate << s->lsf)) / 144000;\n\n            break;\n\n        }\n\n    }\n\n    s->sample_rate = sample_rate;\n\n    \n\n#if defined(DEBUG)\n\n    printf(\"layer%d, %d Hz, %d kbits/s, \",\n\n           s->layer, s->sample_rate, s->bit_rate);\n\n    if (s->nb_channels == 2) {\n\n        if (s->layer == 3) {\n\n            if (s->mode_ext & MODE_EXT_MS_STEREO)\n\n                printf(\"ms-\");\n\n            if (s->mode_ext & MODE_EXT_I_STEREO)\n\n                printf(\"i-\");\n\n        }\n\n        printf(\"stereo\");\n\n    } else {\n\n        printf(\"mono\");\n\n    }\n\n    printf(\"\\n\");\n\n#endif\n\n    return 0;\n\n}\n", "idx": 14459, "substitutes": {"s": ["bs", "fs", "sg", "status", "pers", "ps", "r", "ms", "ports", "js", "g", "services", "sw", "utils", "sc", "tests", "y", "ins", "details", "h", "changes", "sb", "ops", "os", "als", "sv", "er", "set", "m", "sports", "ers", "as", "t", "is", "source", "ains", "parts", "ns", "tes", "l", "rs", "sl", "ies", "S", "c", "browser", "eps", "comm", "sys", "ls", "vs", "uploads", "hs", "ats", "its", "ims", "sets", "https", "orders", "ts", "a", "qs", "sts", "ss", "ants", "settings", "ses", "conf", "p", "es", "aws", "rates", "gs", "dev", "spec", "bis", "less", "ds", "cs", "comments", "stats", "obj", "w"], "header": ["event", "h", "info", "cache", "timer", "version", "hd", "lp", "outer", "HEAD", "player", "dt", "hidden", "former", "history", "x", "format", "peer", "hash", "title", "prot", "frame", "addr", "er", "message", "p", "filter", "server", "r", "list", "dr", "tr", "json", "name", "code", "hawk", "window", "Header", "response", "iter", "block", "buffer", "len", "attribute", "tar", "form", "size", "offset", "msg", "data", "magic", "token", "vector", "layer", "t", " HDR", "ter", "debug", "wrapper", "body", "part", "heading", "head", "function", "v", "table", "drm", "lr", "term", "hh", "headers", "shift"], "sample_rate": ["sample67rate", " sample_rates", "sample67rated", " sample_rated", "sample_size", "sample_area", "sample7state", "sample_zip", "sample_state", "sampleplsize", "sample7rates", "sample_count", "ample_count", "sample_score", "sampleplrate", "sample67score", "sampleacrate", "ample_score", "sample2size", "sample_system", "sample00area", "sample00rates", "sample_rated", "sample67count", "sampleacarea", "sampleplsystem", "sampleacrates", "sample_rating", "frame_state", " sample_score", " sample_size", "ample_rate", " sample_zip", " sample_rating", " sample_system", "sample00zip", "sample00rate", " sample_area", "frame_rate", "sample2rating", "sample7rate", "sample2rate", "sampleaczip", "sample_rates", "frame_rates"], "frame_size": [" frame_tree", "frame8capacity", "frameetname", "frame_message", "responselysystem", "profileetstore", "frame_strength", "frameetstrength", "profileetsize", "frameetvector", "frame_storage", " frame_count", "frame_count", "Frame_size", "framelexstore", "scenetloss", "framelexcapacity", "profile_store", "frameListstart", "frame_store", "sample_size", "scene_size", "frames_length", "line_size", "fieldetsize", "frame_member", "framelexsize", "line_vector", "frame67size", "framelexcount", "frametunit", "frame_length", "frame67scale", "draw8Size", "frame_system", "frame_weight", "frame_sum", "profile_strength", "field_size", "frameetsize", "response_size", "frames_offset", "frame9loss", "frame67style", "frame8size", "frametsize", "frame_loss", "response_name", "draw_Size", "profileetstyle", "fieldetstorage", "frametsum", "term_strength", "frameSetsize", "sample_start", "sample_scale", "fieldetoffset", "frameListname", " frame_description", "sample_weight", "responselystart", "framexspeed", "flow_message", "frame_start", "response_system", "framelexvector", " frame_storage", "field_name", "sample_store", "framelexstrength", "frame67message", "frame2scope", "frame8Size", "profile_style", "scene_loss", "term_size", "response_start", "framexstrength", "framexcapacity", "framelyname", "frames_address", "frame_tree", "flow_size", "frame_Size", "framettree", "frameetoffset", "frame_style", "frame67store", "draw8vector", "scene_sum", "frame2message", "frame2size", "frame_name", "frameSetoffset", "responselysize", " frame_speed", "framelexSize", "frametloss", "frame_vector", "draw8capacity", "responselyname", "scenetsize", "framelexweight", "frame_location", "frameSetlength", "frame8vector", "frametweight", "frame2scale", "framexsize", "line_offset", "scenetsum", "framelysize", "field_offset", "frame9weight", "draw8size", "frameetstore", "frame67strength", "frame_scope", "term_location", "frame_speed", "frame_capacity", "Frame_scale", "frameListsize", "frames_size", "frame_address", "framelexloss", "frame9size", "profileetstrength", "scene_weight", "term_capacity", "framelexstyle", "frame_offset", "sample_name", "flow_scale", "fieldetname", "flow_scope", "framexlocation", "profile_size", "framexstorage", "framelexsum", "line_style", "draw_capacity", "frame9sum", "frame67scope", "Frame_Size", " frame_member", "frame_unit", "framelexmember", "frame_description", " frame_scale", "framelystart", "draw_size", "frameetstyle", "field_storage", "scenetweight", "framelysystem", "frame_scale", " frame_length", "frameListscale", "draw_vector", "frameSetaddress", "frameetstorage", " frame_unit"], "mpeg25": ["cam5", "peg26", "cam75", "cow75", "mpeg20", "mpeg26", "cam24", "mobi20", "media25", "peg25", "ammy20", "peg5", " microphone75", "mpeg5", "cow25", "ammy75", "mpeg75", "mpeg125", " microphone25", " microphone625", " microphone125", "mobi15", "cam125", "media75", "ammy26", "mobi25", "mpeg15", "media5", "media26", "mpeg625", "mobi75", "mpeg24", "cow24", "peg625", "cam25", "cam625", "peg24", "peg20", "ammy25", "peg125", "cow5", "peg75", "peg15", "cam26", "ammy15", "mobi26"], "padding": ["packing", "shape", "context", "ppa", "resolution", "prefix", "version", "address", "type", "pc", "radius", "added", "translation", "above", "pa", "processing", "activation", "password", "protection", "depth", "margin", "scale", "border", "position", "p", "ping", "wp", "height", "empty", "timeout", "frequency", "adding", "trace", "buffer", "volume", "pointer", "unit", "size", "offset", "data", "magic", "zone", "pixel", "pad", "pi", "policy", "length", "pressure", "mask", "delay", "shift"], "sample_rate_index": ["sample_stream_position", "sample_rate__offset", "sample_time_strength", "sample_rate_Index", "sample_rate__id", "sample_rate_position", "sample_rate__index", "sample_rate_strength", "sample_rates_offset", "sample_stream_index", "sample_time_Index", "sample_rate_key", "sample_time_key", "sample_time_id", "sample_rates_Index", "sample_stream_Index", "sample_rates_id", "sample_rates_i", "sample_time_index", "sample_stream_offset", "sample_rates_index", "sample_rate_i", "sample_rate_offset", "sample_rate_id", "sample_rate__Index"], "bitrate_index": ["bitrate_pos", "bitrate_id", "bittime2offset", "bitrate___ind", "bittime_offset", "bitrace_ind", "bitRate_Index", "bitrate2index", "bitrate2offset", "bittime2ind", "bitrace_index", "bitRate_id", "bitrace_Index", "bitrate___index", "bitrate___pos", "bitrate2id", "bitrace_pos", "bittime_index", "bittime_id", "bitrate2ind", "bittime2index", "bittime_ind", "bittime2id", "bitRate_index", "bitrate_Index", "bitrate___Index", "bitrate_ind", "bitrate_offset"]}}
{"project": "FFmpeg", "commit_id": "2d66fc543b01995d6146fc132a778d3e722ca665", "target": 1, "func": "static av_cold int init(AVFilterContext *ctx, const char *args)\n\n{\n\n    GradFunContext *gf = ctx->priv;\n\n    float thresh = 1.2;\n\n    int radius = 16;\n\n\n\n    if (args)\n\n        sscanf(args, \"%f:%d\", &thresh, &radius);\n\n\n\n    thresh = av_clipf(thresh, 0.51, 255);\n\n    gf->thresh = (1 << 15) / thresh;\n\n    gf->radius = av_clip((radius + 1) & ~1, 4, 32);\n\n\n\n    gf->blur_line = ff_gradfun_blur_line_c;\n\n    gf->filter_line = ff_gradfun_filter_line_c;\n\n\n\n    if (ARCH_X86)\n\n        ff_gradfun_init_x86(gf);\n\n\n\n    av_log(ctx, AV_LOG_VERBOSE, \"threshold:%.2f radius:%d\\n\", thresh, gf->radius);\n\n\n\n    return 0;\n\n}\n", "idx": 14469, "substitutes": {"ctx": ["pkg", "context", "abc", "jp", "kw", "req", "bc", "ck", "txt", "tx", "conv", "cas", "ctl", "dc", "ij", "kg", "setup", "cmp", "cm", "np", "xc", "cp", "hw", "bh", "Context", "cu", "cb", "mc", "sys", "jac", "kk", "mk", "ia", "tc", "cc", "gc", "cv", "kt", "act", "cf", "conn", "ct", "anc", " cx", "nc", "ca", "fc", "sc", "resp", "wx", "cmd", "ac", "wcs", "obj"], "args": ["fs", "rs", "arms", "limits", "GS", "ids", "points", "objects", "terms", "keys", "flags", "checks", "files", "amps", "words", "fields", "friends", "s", "arr", "p", "weights", "atts", "posts", "vs", "any", "xs", "users", "aws", "gs", "ats", "names", "members", "ims", "ags", "facts", "caps", "rows", "values", "range", "orders", "arg", "properties", "actions", "cs", "ts", "cmd", "ins", "qs", "w", "parts", "Args", "ns", "params"], "gf": ["rgw", "gmf", " gfo", "grouply", "gcv", "gwt", "gpy", "ggfac", "ergf", " gfr", "gfr", "Gw", "gfac", "gfer", "gal", " gpy", "bgif", "gfm", "gfor", " gtf", "gainf", "gainfs", "ogfor", "gametf", "gufor", "ogif", "bgfor", "ggwt", "gpv", "ggly", "ergpy", " gif", "gmfac", "bgt", "ggf", "bgf", " gfer", "gfo", "gfs", " gt", "gpf", "gamepy", "gpfac", "gif", "gamefo", "ogf", "gly", "gainfm", "gainfr", "sgf", "gpwt", "guly", "gtf", "groupf", " gw", "rgfo", "rgfer", "gv", " gfor", "sgw", "gmwt", "ggfr", "gcw", "gcfm", "Gf", "groupal", "gt", "sgfo", " gfm", "ggv", "ogt", "groupfor", "Gfm", "rgf", "gcf", "gamef", "Gv", "gmv", "sgfer", "guf", "ggfs", "ergtf", "ggfor", "gw", "gual", "ergfo", " gfs", " gv", "ggal", "ggfm"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,\n\n\t\t\t\t    int enable)\n\n{\n\n\treturn kvm_set_migration_log(enable);\n\n}\n", "idx": 14476, "substitutes": {"client": ["cache", "channel", "type", "pc", "server", "node", "connection", "cli", "product", "service", "resource", "c", "core", "key", "cell", "name", "window", "project", "manager", "Client", "conn", "cl", "net", "file", "config", "master", "grid"], "enable": ["online", "end", "stop", "status", "disable", "complete", "replace", "activate", "Enable", "begin", "enabled", "sche", "force", "pen", "allow", "append", "english", "start", "update", "hide", "apply", "active", "incre", "show", "require", "en", "forward", "define", "open", " Enable", "debug", "write", "on", "animate", "execute"]}}
{"project": "FFmpeg", "commit_id": "fc8fa007fb6099643a1f742a162e5e5eda760fd6", "target": 0, "func": "static int64_t rtmp_read_seek(URLContext *s, int stream_index,\n\n                              int64_t timestamp, int flags)\n\n{\n\n    RTMP *r = s->priv_data;\n\n\n\n    if (flags & AVSEEK_FLAG_BYTE)\n\n        return AVERROR(ENOSYS);\n\n\n\n    /* seeks are in milliseconds */\n\n    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);\n\n    if (!RTMP_SendSeek(r, timestamp))\n\n        return -1;\n\n    return timestamp;\n\n}\n", "idx": 14499, "substitutes": {"s": ["i", "h", "fs", "rs", "sn", "n", "sb", "os", "S", "c", "sv", "comm", "ss", "p", "es", "m", "ssl", "ls", "aws", "ms", "gs", "b", "e", "js", "as", "sq", "https", "t", "ds", "cs", "ts", "sc", "is", "a", "v", "ns", "sts"], "stream_index": ["stream_Index", "stream_number", "streamidindex", "Stream_Index", "Streamidind", "Stream_ind", "streamidind", "Stream_number", "StreamidIndex", "streamidIndex", "streamidnumber", "Stream_index", "stream_ind", "Streamidnumber", "Streamidindex"], "timestamp": ["timtime", "timpoint", "timeless", "Timpoint", "mintetime", "Timest", "checkest", "timeline", "impoint", "imest", "timeday", "tememark", "Timestamp", "timemark", "temence", "mintestamp", "tmporal", "timetime", "stimporal", "cumestamp", "timest", "Timtime", "temestamp", "timeemark", "tmestamp", "timporal", "timeest", "cumporal", "minttime", "imestamp", "timence", "imetime", "Timemark", "tmeline", "checkestamp", "mintest", " timeday", " timtime", "timeence", "stimeline", "timeetime", "checketime", "checkpoint", "Timetime", "timeeday", "temest", "timeestamp", "stimestamp", "stimeless", "cumeless", "Timeday", " timest", "cumeline", "tmeless", "Timence"], "flags": ["details", "fps", "ants", "ids", "uses", "settings", "status", "terms", "pages", "reports", "FLAG", "heads", "words", " Flags", "fields", "links", "atts", "args", "options", "ms", "flag", "features", "Flags", "events", "locks", "ags", "tags", "values", "aps", "sets", "properties", "times", "states", "ts", "comments", "bits", "grades", "lag", "parts", "mask", "posts", "allows"], "r": ["h", "d", "l", "rs", "br", "rb", "re", "ar", "c", "q", "er", "p", "m", "hr", "R", "rx", "rd", "e", "rc", "rr", "rect", "ro", "g", "res", "rg", "rar", "sr", "mr", "t", "vr", "rw", "rt", "kr", "v", "or", "w"]}}
{"project": "FFmpeg", "commit_id": "6df1cfa7e4d488051d7b5033c0c69df970db9f82", "target": 0, "func": "static av_cold int mace_decode_init(AVCodecContext * avctx)\n\n{\n\n    MACEContext *ctx = avctx->priv_data;\n\n\n\n    if (avctx->channels > 2)\n\n        return -1;\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    avcodec_get_frame_defaults(&ctx->frame);\n\n    avctx->coded_frame = &ctx->frame;\n\n\n\n    return 0;\n\n}\n", "idx": 14508, "substitutes": {"avctx": ["avercontext", "ivercontext", "airtimeout", "airctx", "avcp", "avekt", "vrctx", "cvcontext", "afloc", "aircp", "avkt", " avcmp", "avepkg", "averloc", "averconf", "afcontext", "avtx", "afkt", "iverloc", "wavconf", "avetimeout", "avcontext", "vrcontext", "avtimeout", "averctl", "iverkt", "avpkg", " avtimeout", "cvctx", " avcontext", "vrtx", "averctx", "avloc", "avetx", "aftx", "avctl", "wavctl", " avtx", "vrcmp", "averkt", "wavctx", "avectx", " avcp", "avertx", "afctx", "avectl", "aircontext", "avconf", "cvcmp", "wavtx", "airpkg", "cvtx", "iverctx", " avpkg", "airkt", "airtx", "aveconf", "avcmp", "afcp", " avkt"], "ctx": ["pkg", "context", "xp", "jp", "kw", "ck", "txt", "tx", "tk", "ctrl", "ctl", "cmp", "px", "np", "xc", "cp", "cb", "hw", "loc", "jac", "cfg", "xs", "timeout", "desc", "tz", "tc", "nt", "cc", "gc", "cv", "kt", "cf", "act", "ct", "nc", "crit", "fc", "pt", "cmd", "wcs", "ac", "kb", "obj", "qt"]}}
{"project": "qemu", "commit_id": "1bf6beec8a012cae4bb6fbc89c465127e9650c92", "target": 1, "func": "float16 float32_to_float16(float32 a, flag ieee STATUS_PARAM)\n\n{\n\n    flag aSign;\n\n    int_fast16_t aExp;\n\n    uint32_t aSig;\n\n    uint32_t mask;\n\n    uint32_t increment;\n\n    int8 roundingMode;\n\n    a = float32_squash_input_denormal(a STATUS_VAR);\n\n\n\n    aSig = extractFloat32Frac( a );\n\n    aExp = extractFloat32Exp( a );\n\n    aSign = extractFloat32Sign( a );\n\n    if ( aExp == 0xFF ) {\n\n        if (aSig) {\n\n            /* Input is a NaN */\n\n            float16 r = commonNaNToFloat16( float32ToCommonNaN( a STATUS_VAR ) STATUS_VAR );\n\n            if (!ieee) {\n\n                return packFloat16(aSign, 0, 0);\n\n            }\n\n            return r;\n\n        }\n\n        /* Infinity */\n\n        if (!ieee) {\n\n            float_raise(float_flag_invalid STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0x3ff);\n\n        }\n\n        return packFloat16(aSign, 0x1f, 0);\n\n    }\n\n    if (aExp == 0 && aSig == 0) {\n\n        return packFloat16(aSign, 0, 0);\n\n    }\n\n    /* Decimal point between bits 22 and 23.  */\n\n    aSig |= 0x00800000;\n\n    aExp -= 0x7f;\n\n    if (aExp < -14) {\n\n        mask = 0x00ffffff;\n\n        if (aExp >= -24) {\n\n            mask >>= 25 + aExp;\n\n        }\n\n    } else {\n\n        mask = 0x00001fff;\n\n    }\n\n    if (aSig & mask) {\n\n        float_raise( float_flag_underflow STATUS_VAR );\n\n        roundingMode = STATUS(float_rounding_mode);\n\n        switch (roundingMode) {\n\n        case float_round_nearest_even:\n\n            increment = (mask + 1) >> 1;\n\n            if ((aSig & mask) == increment) {\n\n                increment = aSig & (increment << 1);\n\n            }\n\n            break;\n\n        case float_round_up:\n\n            increment = aSign ? 0 : mask;\n\n            break;\n\n        case float_round_down:\n\n            increment = aSign ? mask : 0;\n\n            break;\n\n        default: /* round_to_zero */\n\n            increment = 0;\n\n            break;\n\n        }\n\n        aSig += increment;\n\n        if (aSig >= 0x01000000) {\n\n            aSig >>= 1;\n\n            aExp++;\n\n        }\n\n    } else if (aExp < -14\n\n          && STATUS(float_detect_tininess) == float_tininess_before_rounding) {\n\n        float_raise( float_flag_underflow STATUS_VAR);\n\n    }\n\n\n\n    if (ieee) {\n\n        if (aExp > 15) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0);\n\n        }\n\n    } else {\n\n        if (aExp > 16) {\n\n            float_raise(float_flag_invalid | float_flag_inexact STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0x3ff);\n\n        }\n\n    }\n\n    if (aExp < -24) {\n\n        return packFloat16(aSign, 0, 0);\n\n    }\n\n    if (aExp < -14) {\n\n        aSig >>= -14 - aExp;\n\n        aExp = -14;\n\n    }\n\n    return packFloat16(aSign, aExp + 14, aSig >> 13);\n\n}\n", "idx": 14521, "substitutes": {"a": ["i", "h", "d", "am", "n", "app", "z", "A", "x", "go", "out", "ast", "ga", "ar", "c", "ata", "aa", "u", "ed", "ap", "p", "s", "an", "ma", "m", "oa", "ia", "b", "att", "e", "window", "as", "sa", "na", "aaa", "g", "at", "act", "angular", "era", "ao", "sta", "t", "eas", "aw", "ca", "ea", "au", "o", "ac", "all", "y", "ae", "f", "ab", "v", "w", "area", "da", "alpha", "ta"], "STATUS_PARAM": ["STATUS_PARAR", "STATUS_NAR", "STATUS_VUM", "STATUS_VAMS", "STATUS_PARAMS", "STATUS_NUM", "STATUS_NAM", "STATUS_VAM", "STATUS_PAMS", "STATUS_PAM", "STATUS_PARUM", "STATUS_VAR", "STATUS_NAMS", "STATUS_PUM", "STATUS_PAR"], "aSign": ["asShape", "isaSign", "anaSign", "anShape", "anReg", "assign", " aScale", "aaScale", " aPort", " aNeg", "aaReg", "ePos", "isaNeg", "asSign", "anaNeg", "aPort", "asPos", "eSign", "anaRand", " aRand", "iLog", "aaRand", "aeSign", " asign", "aeSIGN", "eScale", "aScale", "aePort", "aReg", "aLog", "asLog", "isaSIGN", "oSign", "aShape", "aeNeg", "anSign", "asReg", "uSeg", "uSign", "aaExp", "aaDig", " aSIGN", "aSIGN", "oReg", "aDig", "iSign", "anLog", "anaPos", "aasign", "aSeg", "iSIGN", "uSIGN", "anSIGN", "asSIGN", " aReg", "oDig", "asign", "aRand", "anSeg", " aPos", "aaSIGN", "uLog", "anDig", "oSIGN", "aNeg", "aaPos", "asSeg", "eExp", "asRand", "aaSign", "aPos", "iShape", "aaNeg", "isaPort"], "aExp": ["appExpress", "aEx", "saSp", " aEx", "aaExpress", " aEnc", "aExpress", "appComp", "anExp", "asGe", "saSign", "aExt", "appGe", "vaExec", " aExec", "vaExpress", "anEnc", "nameExpress", " aSp", "nameExp", "aSp", "oaEx", "dataRest", "vaExt", "aaEx", "nameEx", "asExec", "aGe", "alphaExpress", "aaSp", "aComp", "aaExt", "aaExec", "saExp", "aSec", " aSec", "aEnc", "oaRest", "oaEXP", "asEnc", "vaExp", "aaExp", " aEXP", " aExt", "alphaEx", "appExp", "asComp", "saComp", "alphaSec", "asExpress", "aaSec", "anComp", "asExp", "nameExt", "saExec", " aGe", "dataEXP", "dataEx", "saPos", " aPos", " aComp", "aRest", "aEXP", "aaPos", "aaComp", " aRest", "aaSign", "aExec", " aExpress", "dataExp", "aPos", "asExt", "alphaExp", "oaExp", "anExec"], "aSig": ["aSim", " aSignigh", "aSetigma", " aSignIG", "aRsite", "aIssign", "aTigh", "aAsim", "ASIG", "aIssIG", "aInsigs", "caAsign", "saRseg", "aVsign", " aSigh", "aSeigma", "AAsigma", "aSeature", "saRsite", "aIsigned", "aSigs", "amSiet", " aInsigs", "aSnig", "aSneg", "amSeg", "aSignig", "saIsigs", "aSigned", "aSeim", "aVseg", "saIsig", "aAsigh", "aDseg", "aIssature", "aSnigma", "saSigs", "amSig", "aSIG", "aSeigs", " aSignig", "aSetigh", "aInseg", "aVsig", "aAsig", "aIsigs", "aSeigh", "aPeg", " aInseg", "ASigh", "aDsigned", " aSeg", "aIsig", "saSeg", " aInsig", "aPosag", "aSignIG", "aAsign", "aRsig", "caSign", " aSIG", "aVsigma", "amVsig", "aAsigs", "saSigned", "aSeteg", " aSag", "saIsigned", "amVsigma", "aSeeg", "aaDim", "saRsigma", "AAsIG", "aDim", "aAsature", "aSite", "aSature", "aDigs", "aaSig", " aSigs", "ASigma", "aTig", "caSig", "saRsig", "aInsiet", "amVseg", "aaDig", "aDig", "aSignature", "aSnite", "aAsigma", "caSature", "aSiet", "AAsigh", "aSeIG", "AAsig", "aIssig", "aPosigs", "aSeg", "aInsig", "aInsigned", "caAsature", "aAsIG", "aSetig", "amSigma", "aTature", "ASig", "saSigma", "aVsiet", "caAsIG", "aSeig", "aDIG", "aaDigs", "aPIG", "aSetIG", "aPosig", "caSIG", "aSetiet", " aInsIG", "aSag", "amVsiet", "aaDIG", "aaSigs", "caAsig", "aSigh", " aSature", "saSite", "aDsigs", "saSig", "aaSIG", "aPigs", "aSignigh", "aPosIG", "aDsig", "aSignigma", "aTIG", "aSigma", "aIseg", "aVsature", "saIseg", "aInsigma", "aRsigma", " aSignature", "aPig", "aaSim", "aRseg", "aSeite", "aAsag", "aVsIG", "aInsIG"], "mask": ["shape", "sum", "sign", "cache", "map", "keep", "miss", "level", "flags", "clear", "error", "hash", "cm", "result", "margin", "ask", "scale", "weight", "hold", "allow", "filter", "mut", "tag", "scan", "skip", "ma", "m", "batch", "key", "zero", "set", "mb", "mk", "cover", "hide", "ms", "flag", "where", "known", "match", "window", "count", "box", "block", "empty", "Mask", "sk", "size", "fix", "bit", "use", "black", "limit", "offset", "lock", "mx", "gate", "magic", "bool", "comment", "MAS", "mod", "pack", "bug", "mark", "bits", "master", " masked", "perm", "shift"], "increment": ["Decrement", "enablementation", " decrecomment", "schemented", "increement", "adjustement", "schement", "Increment", "itermentation", " decreMENT", " decreement", "vancement", "Incremented", "rese", "reement", "gremented", "incremented", " incrementcomment", "Incrementation", "incmental", "Increma", "increence", "schementation", " incrementment", " decrement", "improvema", "greement", "vanceement", "enablemented", "improvement", " decremission", "enablement", "adjustmented", "grese", " incrementmented", " decreension", "improvemental", "improveement", "Decremented", "rementation", "increension", "adjustmentation", "remented", "vancese", "incmented", "schemental", "incment", "rement", "itermental", "improvemented", "incremission", "increcomment", " increition", "iterment", "adjustment", "Decremental", "vancemented", " incrementation", "adjustcomment", " incremented", "schemission", "incremental", "adjustmission", "improveence", "adjustition", "incrementation", "improvemission", "adjustMENT", "grement", "Incremental", "incma", "incement", "Decremission", "itermented", "increMENT", "improveMENT", " decremented", "improveition", "reence", "adjustension", "improveension", "enableence", "improvementation", "increition", " incrementmission", "increma", "increse"], "roundingMode": ["roundoundingMode", "turningStatus", "roundINGStatus", "rollingMode", "roundingStatus", "callingMode", "roundoundingStatus", "turnINGmode", "turningMode", "rolluningModule", "roundingmode", "rollingTheme", "roundingModule", "turningmode", "roundbingMode", "roundbingEngine", "rounduningTheme", "roundtingMethod", "rolluningMode", "roundbingModule", "roundoundingMethod", "roundINGMethod", "callningMode", "rounduningMode", "roundINGmode", "turnINGStatus", "rounduningMODE", "roundningMODE", "roundgingTheme", "roundifyingMODE", "roundbingMODE", "roundifyingMode", "rolluningTheme", "turnINGMethod", "roundningMode", "turnINGMode", "roundtingStatus", "rounduningModule", "roundningEngine", "callningMODE", "callingEngine", "callningEngine", "roundingTheme", "roundingMethod", "roundbingTheme", "roundINGMode", "roundgingModule", "roundtingMode", "roundgingMode", "rollingModule", "roundingMODE", "rolluningMODE", "rollingMODE", "callingMODE", "roundifyingEngine", "roundtingmode", "roundgingMODE", "turningMethod", "roundoundingmode", "roundingEngine"]}}
{"project": "qemu", "commit_id": "0d8d7690850eb0cf2b2b60933cf47669a6b6f18f", "target": 0, "func": "int virtqueue_avail_bytes(VirtQueue *vq, int in_bytes, int out_bytes)\n\n{\n\n    unsigned int idx;\n\n    unsigned int total_bufs, in_total, out_total;\n\n\n\n    idx = vq->last_avail_idx;\n\n\n\n    total_bufs = in_total = out_total = 0;\n\n    while (virtqueue_num_heads(vq, idx)) {\n\n        unsigned int max, num_bufs, indirect = 0;\n\n        target_phys_addr_t desc_pa;\n\n        int i;\n\n\n\n        max = vq->vring.num;\n\n        num_bufs = total_bufs;\n\n        i = virtqueue_get_head(vq, idx++);\n\n        desc_pa = vq->vring.desc;\n\n\n\n        if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_INDIRECT) {\n\n            if (vring_desc_len(desc_pa, i) % sizeof(VRingDesc)) {\n\n                error_report(\"Invalid size for indirect buffer table\");\n\n                exit(1);\n\n            }\n\n\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (num_bufs >= max) {\n\n                error_report(\"Looped descriptor\");\n\n                exit(1);\n\n            }\n\n\n\n            /* loop over the indirect descriptor table */\n\n            indirect = 1;\n\n            max = vring_desc_len(desc_pa, i) / sizeof(VRingDesc);\n\n            num_bufs = i = 0;\n\n            desc_pa = vring_desc_addr(desc_pa, i);\n\n        }\n\n\n\n        do {\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (++num_bufs > max) {\n\n                error_report(\"Looped descriptor\");\n\n                exit(1);\n\n            }\n\n\n\n            if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_WRITE) {\n\n                if (in_bytes > 0 &&\n\n                    (in_total += vring_desc_len(desc_pa, i)) >= in_bytes)\n\n                    return 1;\n\n            } else {\n\n                if (out_bytes > 0 &&\n\n                    (out_total += vring_desc_len(desc_pa, i)) >= out_bytes)\n\n                    return 1;\n\n            }\n\n        } while ((i = virtqueue_next_desc(desc_pa, i, max)) != max);\n\n\n\n        if (!indirect)\n\n            total_bufs = num_bufs;\n\n        else\n\n            total_bufs++;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14531, "substitutes": {"vq": ["Vqt", "fz", " vqu", "vdq", " vque", "tvdq", "volaq", "vQ", "vqs", "Vqueue", "verq", "svqt", "vz", " vdq", "vcque", "nque", "verz", "vqu", "Vq", "volqu", "tvqu", "verque", "volq", "tvque", "naq", "viq", " vQ", "vplay", " vqs", "verqq", " vqt", "svque", "vciq", "svQ", "uvq", "Vqs", "fq", " vz", " viq", "vqt", "evdq", "evqu", "nq", "volque", "evqueue", " vplay", "vque", "fque", "evque", "evq", "vcq", "vaq", "nqu", "vcplay", "Vque", "uvque", "uviq", "vqueue", "fqq", "VQ", "uvplay", "svq", "tvaq", "vqq", " vqq", "evqs", "tvq", " vqueue"], "in_bytes": ["rin_sets", "in68bytes", "in_sets", "cin67boxes", "rinftyfits", "in68boxes", "inftyallows", "inBsets", "inuffybytes", "inftysets", "in67parts", "in67total", "in68fits", "in68total", "cin67parts", "in_parts", "inmmuses", "ini67terms", "in68sets", "in_boxes", "cin_total", "in8bytes", "cin67bytes", "inBfits", "rin_allows", "inftyfits", "inuffyuses", "in_allows", "inBallows", "inmmbytes", "inuffyterms", "in67boxes", "in8parts", "ini_terms", "in8total", "cin_bytes", "ini67devices", "inftybytes", "in_devices", "in8boxes", "ini_bytes", "ini67uses", "in_uses", "cin_boxes", "in68allows", "ini_devices", "in67bytes", "in68parts", "rinftysets", "in67terms", "rinftybytes", "inmmdevices", "rinftyallows", "rin_bytes", "ini67bytes", "ini_uses", "inuffydevices", "rin_fits", "in67uses", "in67devices", "in_terms", "cin_parts", "in_fits", "inBbytes", "cin67total", "inmmterms"], "out_bytes": ["out0bytes", "out0total", "out_nets", "out67total", "total67total", "in_nets", "out67bytes", "in_names", "out_tes", "out67tes", "outmmnets", "total_maps", "total67tes", "total_total", "in_errors", "out2bytes", "out_names", "total67maps", "out2total", "in_seconds", "out0tes", "out_maps", "out0maps", "out2tes", "outmmbytes", "out67maps", "out_seconds", "out_pointers", "in_pointers", "total_bytes", "out_errors", "total_tes", "outmmnames", "out2maps", "total67bytes"], "idx": ["Idy", "idy", "IdX", "Idex", "indn", "midix", "Idx", " idxi", "mdxs", "Idix", "indy", " idy", "mdx", "pidxs", "pidex", " idz", " idex", "Idn", "mdxi", "midxs", " idix", "midxi", "idxs", "IDix", " idxs", "Idz", "pidx", "idn", "indx", "idz", " idn", "mdix", "IDx", "IDX", "idX", "pidz", "idxi", " idX", "Idxs", "midx", "idex", "idix", "indix"], "total_bufs": ["total_devd", "total_bufz", "total_devts", "total_ufcs", "total_ufjs", "total_ufts", "total_buffries", "total_brals", "total_bufals", "total_ufals", "total_dirts", "total_dirs", "total_buffergs", "total_ufers", "total_logts", "total_dirers", "total_cmds", "total_bufferes", "total_bufjs", "total_logz", "total_ufz", "total_cmdz", "total2bufts", "total_loggs", "total_bufries", "total2buffcs", "total2buffs", "total_bufd", "total2bufs", "total_ufes", "total_ufries", "total_bufcs", "total2buffts", "total_bufes", "total_devries", "total_ufgs", "total_brjs", "total_ufs", "total_bufgs", "total_bufts", "total_buffjs", "total_bufers", "total_devs", "total_buffs", "total_dircs", "total2bufcs", "total_brts", "total_cmdts", "total_buffts", "total_buffcs", "total_ufd", "total_buffals", "total_brs", "total2buffers", "total2bufers", "total_buffd", "total_loges", "total_buffers", "total_logs"], "in_total": ["in5local", "inJparent", "in5total", "init_total", "init_local", "inJsofar", "inJlocal", "in_parent", "init5parent", "init_parent", "in_sofar", "in5parent", "in_no", "internal_not", "in_pages", "init5sofar", "in_last", " in_info", "internal_last", "in_info", " in_pages", "in5sofar", "internal_stable", "in_stable", "init5total", "in_local", " in_no", "init_sofar", "internal_total", "inJtotal", "in_not", "init5local"], "out_total": ["out1reported", "out1total", "out_max", " out_available", "devjserver", "dev_server", "out1global", "ex_total", "devjdesc", "out_no", "out68global", "out_desc", "dev_total", "dev_desc", "out_reported", "out2no", "out68total", " out_max", "out2total", "outjdesc", "dev_required", "outjrequired", "out68reported", "outjserver", "devjrequired", " out_no", "out68bytes", "out2available", "ex_global", "devjtotal", "ex_bytes", "out_available", "ex_reported", "out1bytes", "out_server", "out_global", "out2max", "outjtotal", "out_required"], "max": [" Max", "orig", "k", "med", "maximum", "prime", "check", "r", "ms", "ex", "all", "base", "current", "h", "Max", "end", "ax", "last", "hash", "full", "init", "root", "set", "start", " MAX", "m", "height", "mb", "final", "to", "size", "res", "limit", "num", "mod", "t", "length", "parent", "x", "c", "q", "ma", "recent", "min", "count", "locked", "total", "index", "range", "lock", "mx", "head", "master", "high", "co", "n", "null", "tx", "global", "scale", "conf", "p", "MAX", "now", "window", "box", "id", "exclusive", "act", "mad", "ox", "self", "checked", "v", "w"], "num_bufs": ["num_cves", "num_buffers", "num_bufits", "num_cvs", "num_reqers", "num_cvries", "num_cmdries", "num_bufers", "num_bufes", "num_rbts", "num_cvn", "num_bufds", "num_bufts", "num_rbs", "num_reqc", "num_ufries", "num_buffits", "num_brc", "num_buffes", "num_tells", "num_tellits", "num_cmdgs", "num_reqs", "num_buffts", "num_rbers", "num_reqts", "num_cmds", "num_ufc", "num_refs", "num_bufries", "num_ufers", "num_ufs", "num_brries", "num_brn", "num_bufgs", "num_cmdts", "num_refries", "num_ufes", "num_buffgs", "num_cvS", "num_ufn", "num_ufits", "num_cmdds", "num_refds", "num_ufgs", "num_buffS", "num_bufc", "num_buffs", "num_tellers", "num_rbc", "num_brs", "num_tellts", "num_ufS", "num_bufn", "num_ufds", "num_refts", "num_ufts", "num_cmdS", "num_cvc", "num_bufS", "num_buffds"], "desc_pa": ["obj_la", "descMemsa", "descmmpa", "desc_pai", " desc_p", "desc_da", "descPp", "degmmapa", "desc_pe", "mem3apa", "desc5pa", " desc_da", "esc_ha", "desc_pn", "desc_pha", "desc_pan", "mem3ara", "prop_ja", "degmmpa", "descJpan", "desc3pai", "desc_pet", " desc_pn", "descMempn", "descmmapa", "desc0PA", "mem_ara", "desc5apa", "desc0pa", "desc_pac", "desc0ppa", " desc_ppa", "desc_cro", "deg_apa", "asc_pac", "desc_pas", "esc_cro", " desc_pan", "desc___da", "desc___p", "prop_par", "descMempa", "descPda", "obj_pa", "desc3apa", "desc5ppa", "esc_pa", "mem_apa", " desc_pai", "deg_pe", "desc3pa", "asc_apa", "desc_ppa", "mem3pha", "mem3pa", "desc_p", "descJpa", " desc_sa", "desc_ja", "degmmpan", " desc_PA", "desc2ppa", "desc_sa", " desc_pe", "desc2pa", "deg_pan", "asc_pa", "desc3ara", "descmmpe", "descmmpan", "descJapa", "descJpe", "desc_apa", "descPpa", "prop_pas", "desc_PA", "desc5pac", "desc2sa", "mem_pha", "desc___pa", "desc0pe", "prop_pa", "desc___ppa", "desc3pan", "deg_pa", "mem_pa", "obj_ara", "obj_pet", "descMemppa", "desc2pn", "desc3pha", "desc_ara", "asc_ppa", "descPppa", "desc3ppa", "degmmpe", "desc_la", "desc_ha", "esc_ppa", "desc_par"], "i": ["qi", "h", "ind", "info", "l", "ai", "ii", "n", "gi", "k", "status", "z", "di", "x", "go", "cli", "ij", "ip", "init", "c", "q", "ti", "u", "li", "hi", "I", "p", "ei", "s", "err", "si", "start", "m", "oi", "ia", "ir", "in", "im", "e", "b", "iter", "instance", "ims", "index", "iu", "id", "ni", "it", "j", "ci", "ie", "xi", "ic", "t", "phi", "zi", "ix", "mi", "is", "a", "pi", "v", "y", "bi", "ini", "ui", "f", "iat", "io"]}}
{"project": "qemu", "commit_id": "bd5c51ee6c4f1c79cae5ad2516d711a27b4ea8ec", "target": 0, "func": "static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)\n\n{\n\n    CharDriverState *chr;\n\n    FDCharDriver *s;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(FDCharDriver));\n\n    s->fd_in = io_channel_from_fd(fd_in);\n\n    s->fd_out = io_channel_from_fd(fd_out);\n\n    fcntl(fd_out, F_SETFL, O_NONBLOCK);\n\n    s->chr = chr;\n\n    chr->opaque = s;\n\n    chr->chr_add_watch = fd_chr_add_watch;\n\n    chr->chr_write = fd_chr_write;\n\n    chr->chr_update_read_handler = fd_chr_update_read_handler;\n\n    chr->chr_close = fd_chr_close;\n\n\n\n    qemu_chr_be_generic_open(chr);\n\n\n\n    return chr;\n\n}\n", "idx": 14557, "substitutes": {"fd_in": ["fd_din", "fd_en", "FD_en", "fdableinc", "FD_orig", "fd_orig", "fd_cin", "dir_din", "or_cin", "orableconn", "orablecin", "orablein", "fdablein", "fdableconn", "FD_in", "fd_conn", "orableinc", "dir_in", "or_inc", "fdablecin", "fd_inc", "dir_out", "FD_out", "fd_ins", "or_conn", "dir_ins", "or_in"], "fd_out": ["fi_OUT", "f0out", "fd0serv", "disk_write", "f0serv", "disk_ou", "fd0to", "f0to", "dir_in", "fd0inner", "fi_out", "dir_out", "dir_new", "fdocknew", "fd_write", "disk_o", "fd_OUT", "fd_serv", "fdockwrite", "fd_new", "fd0out", "fd_o", "fd_inner", "f0inner", "f_to", "fd_ou", "fd_to", "fd___out", "dir_write", "f_inner", "f_out", "fd___ou", "fd_gen", "fi_in", "f_serv", "fi_gen", "fd___o", "fdockin", "fdockout", "disk_out", "fd___write"], "chr": ["chnr", "chercr", "cherr", " chbr", "cherrb", " chR", "echro", "thrb", " chro", "chear", "cher", "achrb", "cherru", "cheR", "cherrator", "chcr", " chrator", "echar", "CHrb", "cheru", "cherar", "chro", "chdr", "chrin", "cherro", "ichrar", "cherb", "achR", "achcr", "chet", "Chorer", "ichr", "cherorer", "Chrb", "cherR", "charru", "ichro", "echrc", "acht", "chbr", "thr", "chru", " cht", "thrar", "charr", "achrr", "achr", "chrar", "CHr", "achrin", "cherrid", "achro", "ichrid", "achbr", "chedr", "Cher", "ichbr", "achorer", "echr", "chrator", "chebr", "cherrr", "chrid", "cherer", "checr", "chrb", "chero", "achar", "thbr", "chnrin", "ichrb", "cht", "Chr", "CHrar", "acher", "cherin", "chrc", "chnR", "CHbr", "chR", " chrb", "chrr", "achdr", "chardr", "achrid", "cherc", " chrc", "achru", "chorer", "cherator", "charro", "chnrb"], "s": ["bs", "h", "i", "fs", "rs", "sb", "n", "ops", "ses", "ies", "out", "S", "als", "os", "so", "sv", "c", "ps", "ss", "p", "sys", "r", "socket", "si", "ssl", "sam", "ls", "set", "vs", "es", "hs", "ms", "gs", "ats", "b", "its", "js", "ports", "in", "as", "bis", "g", "services", "sq", "https", "less", "gets", "acs", "ds", "self", "se", "cs", "ts", "is", "o", "a", "ins", "stats", "qs", "ns", "sts"]}}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                             const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    G722Context *c = avctx->priv_data;\n\n    const int16_t *samples = (const int16_t *)frame->data[0];\n\n    int nb_samples, out_size, ret;\n\n\n\n    out_size = (frame->nb_samples + 1) / 2;\n\n    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))\n\n        return ret;\n\n\n\n    nb_samples = frame->nb_samples - (frame->nb_samples & 1);\n\n\n\n    if (avctx->trellis)\n\n        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);\n\n    else\n\n        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);\n\n\n\n    /* handle last frame with odd frame_size */\n\n    if (nb_samples < frame->nb_samples) {\n\n        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };\n\n        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);\n\n    }\n\n\n\n    if (frame->pts != AV_NOPTS_VALUE)\n\n        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);\n\n    *got_packet_ptr = 1;\n\n    return 0;\n\n}\n", "idx": 14566, "substitutes": {"avctx": ["avercontext", "afconn", "ajctx", "ajjp", "ajcu", "avclient", "avesys", "averclient", "avercb", "afcu", "avcu", " avjp", "averjp", "afcontext", "apconn", "afsys", "avtx", "avecfg", " avclient", "afjp", "avcontext", "avcmd", "ajpkg", "avetc", "afpkg", "avcfg", "avpkg", " avcu", "avercfg", " avcontext", "averctx", "avecb", " avtc", "avetx", "apjp", "avejp", "apcmd", "aftx", "ajclient", " avtx", "apcontext", "avectx", "avecontext", "avjp", "avecmd", "afctx", " avcb", "apctx", "avconn", "afcmd", "aveconn", "afcfg", "avsys", "aptx", " avpkg", "avertc", "aversys", " avconn", "avtc", "ajcontext", "avcb"], "avpkt": ["wavppacket", "avpkw", "avopkg", "avPett", "avdett", "avwpst", "aucpacket", "avpatett", "avpkgett", "avcpkt", "avwpett", "avpkgacket", "avopnt", " avppt", "avvet", "avpatck", "avdkt", "avopet", "avppt", "avnpet", "avvkt", " avopwt", " avoppt", "aucpkt", "avepkw", "avewpck", "avewpkt", " avpwt", "comvkg", "avnpacket", "avcpet", "avpkgdat", " avpett", "avpkgpt", "avpkgnt", "avpatkt", "avppkt", "avopkw", "avwpacket", "avdkg", "avpkg", "comvet", "avwpkw", "avpst", "aupkt", "compet", "avPacket", "avopkt", "avppnt", "avopck", "wavppkt", "avwpck", "wavpacket", "avwpwt", "avpkgwt", " avopkt", "comvett", "avvett", "avppdat", "avcpett", "avpkgkt", "avpadkt", "aupck", "wavpett", "avewpkw", "avpwt", "avpck", "compkg", "wavcpett", "avcpck", "aupacket", "avPet", "avewpett", "avdet", "wavcpet", "avpadck", "avPkt", "avpet", "wavpnt", "avepck", "wavppnt", "wavpet", "avpadacket", "compett", "avnpett", "aucpst", "avpnt", "aucpck", "comvkt", "avopett", "avpett", "avoppt", "compkt", "avnpkt", "wavppdat", "avopdat", "avepett", " avopett", "aupst", "avopacket", "wavcpkt", "avwpkt", "avppacket", "avcpst", "avpadst", "avpatkw", "avcpacket", "avepkt", "wavcpacket", "avopwt", "wavpkt", "avpacket", "avpdat", "wavpdat", "avwppt", "avvkg"], "frame": ["framework", "event", "info", "fake", "channel", "version", "image", "component", "style", "point", "header", "Frame", "sequence", "error", "connection", "face", "state", "video", "force", "message", "list", "rame", "flow", "movie", "close", "scene", "code", "e", "window", "chain", "fb", "trace", "block", "response", "request", "note", "fe", "form", "module", "line", "load", "show", "feat", "me", "frames", "data", "row", "fram", "fr", "zone", "iframe", "t", "file", "feature", "function", "f", "command", "policy", "length", "process", "call", "profile", "one"], "got_packet_ptr": ["got_packacket2addr", "got_packet8addr", "got_packacket_ref", "got_packet2ref", "got_packet8ref", "got_packet8pointer", "got_packacket2pointer", "got_packacket_pos", "got_packacket2ref", "got_packacket_ptr", "got_packacket_pointer", "got_packet2ptr", "got_packet_pointer", "got_packet2addr", "got_packacket2ptr", "got_packet_ref", "got_packet2pointer", "got_packet8ptr", "got_packet_pos", "got_packet2pos", "got_packacket_addr", "got_packet_addr", "got_packacket2pos"], "c": ["context", "h", "cache", "l", "con", "pc", "bc", "lc", "unc", "dc", "cmp", "cm", "cp", "xc", "cu", "cb", "conf", "p", "mc", "r", "m", "C", "tc", "b", "chain", "cc", "rc", "com", "ctx", "gc", "cv", "g", "cont", "cf", "ct", "ec", "t", "ca", "cs", "fc", "nc", "ac", "v", "f", "co"], "samples": ["hamples", "servicesamps", "Samples", "passamps", "Sources", "stones", "pances", "tents", "Sents", "Sances", " samps", "Stones", " sources", "pents", "pamples", " stones", "passents", "hples", "Samps", "sources", " sples", "passples", "servicesamples", "sents", "alsamps", "alsamples", "passamples", "Sples", "hamps", "tamples", "tances", "servicesources", "sances", " sents", "tamps", "alsents", "samps", "sples", "pamps", "hents", "servicestones", "alsples"], "nb_samples": ["nb_snapaces", "nb_alamps", "nb_nources", "nb_says", "nb_gesamps", "nb_snapamps", "nb_sumps", "nb_gesples", "nb_sonents", "nb_snapamples", "nb_speeds", "nb_Sicks", "nb_seonents", "nb_namps", "nb_psamps", "nb_tsumbers", "nb_namples", "nb_sances", "nbLoggesamps", "nb_psamples", "nb_snapages", "nb_esonents", "nb64esaces", "nb64says", "nb_insources", "nb_Sples", "nb_alamples", "nbLoggesples", "nb_spamples", "nb_Susters", "nb_swales", "nb_sacks", "nb_commicks", "nb_ssples", "nb_Sessions", "nb_gesances", "nb_exumbers", "nb_sples", "nb64samples", "nbLogsples", "nb_swamps", "nbLogsamps", "nb_tsamps", "nb_saces", "nb_examps", "nb_samps", "nb_persays", "nb_husters", "nb_swaves", "nb64esamples", "nb_spamps", "nb_hamples", "nb64esays", "nb_esays", "nb_Samples", "nb_sumbers", "nb_exources", "nb_statances", "nb_mages", "nb_Sents", "nb_esamples", "nb_insamples", "nb_tsamples", "nb_statamples", "nb_Sumps", "nb64esonents", "nb_sources", "nb_nents", "nb_gesamples", "nb_ssumps", "nb_alples", "nb_seaces", "nb_ssamples", "nb_commamples", "nb_sales", "nb_persamples", "nb_Saves", "nb_xsappings", "nb_alessions", "nb_vizes", "nb_Samps", "nb_vamples", "nb_vappings", "nb_persaces", "nb_Sages", "nb_seeds", "nb_Seeds", "nb_Sales", "nb_swamples", "nb_commamps", "nb_mamps", "nb_statamps", "nb64sonents", "nbLoggesances", "nb_Saces", "nb_psusters", "nb_Sances", "nb_Sacks", "nb_mamples", "nb_ssessions", "nbLogsances", "nb_hamps", "nb_insicks", "nb_sizes", "nb_Sumbers", "nb_Sizes", "nb_nales", "nb_xsizes", "nb_statples", "nb_psacks", "nb_xsamples", "nb_susters", "nb_ssamps", "nb_vamps", "nb64saces", "nb_commales", "nb_esaces", "nb_Sappings", "nb_hacks", "nb_exents", "nb_examples", "nb_insales", "nbLogsamples", "nb_naves", "nb_seays", "nb_sages", "nb_seamples", "nbLoggesamples", "nb_sessions", "nb_tsents", "nb_saves", "nb_insaves", "nb_xsamps", "nb_Sources", "nb_maces", "nb_sseeds", "nb_insamps", "nb_sicks", "nb_personents", "nb_sappings", "nb_spumps", "nb_sents"], "out_size": ["out2size", "outlenlen", "out_score", " out_score", "out_len", "out2len", "outlenSIZE", "out2SIZE", " out_name", "out_name", " out_shift", "out_shift", " out_len", "outlenscore", "outlensize", "out_SIZE", " out_Size", " out_SIZE", "out2score", "out_Size"], "ret": ["rel", "ft", "cor", "ref", "jp", "RET", "elt", "tmp", "success", "out", "re", "value", "Ret", "result", "ext", "arr", "r", "alt", "mem", "nt", "cert", "len", "over", "gc", "fun", "cont", "it", "res", "back", "det", "mt", "gt", "try", "t", "ll", "ter", "rets", "nat", "resp", "rt", "val", "print", "aux", "reset", "rem"], "last_samples": ["last_damp", "last_sents", "last_psamples", "last_bents", "last_psiffs", "last_damples", "last_ssamps", "last_samps", "last_samp", "last_Sales", "last_psamps", "last_sales", "last_psamp", "last_ssents", "last_siffs", "last_Sents", "last_diffs", "last_bales", "last_Samps", "last_bamples", "last_ssales", "last_bamps", "last_damps", "last_Samples", "last_ssamples", "last_Samp", "last_Siffs"]}}
{"project": "FFmpeg", "commit_id": "03d83ba34b2070878909eae18dfac0f519503777", "target": 0, "func": "static int gif_image_write_image(AVCodecContext *avctx,\n\n                                 uint8_t **bytestream, uint8_t *end,\n\n                                 const uint32_t *palette,\n\n                                 const uint8_t *buf, const int linesize,\n\n                                 AVPacket *pkt)\n\n{\n\n    GIFContext *s = avctx->priv_data;\n\n    int len = 0, height = avctx->height, width = avctx->width, x, y;\n\n    int x_start = 0, y_start = 0, trans = s->transparent_index;\n\n    int honor_transparency = (s->flags & GF_TRANSDIFF) && s->last_frame;\n\n    const uint8_t *ptr;\n\n\n\n    /* Crop image */\n\n    if ((s->flags & GF_OFFSETTING) && s->last_frame && !palette) {\n\n        const uint8_t *ref = s->last_frame->data[0];\n\n        const int ref_linesize = s->last_frame->linesize[0];\n\n        int x_end = avctx->width  - 1,\n\n            y_end = avctx->height - 1;\n\n\n\n        /* skip common lines */\n\n        while (y_start < y_end) {\n\n            if (memcmp(ref + y_start*ref_linesize, buf + y_start*linesize, width))\n\n                break;\n\n            y_start++;\n\n        }\n\n        while (y_end > y_start) {\n\n            if (memcmp(ref + y_end*ref_linesize, buf + y_end*linesize, width))\n\n                break;\n\n            y_end--;\n\n        }\n\n        height = y_end + 1 - y_start;\n\n\n\n        /* skip common columns */\n\n        while (x_start < x_end) {\n\n            int same_column = 1;\n\n            for (y = y_start; y <= y_end; y++) {\n\n                if (ref[y*ref_linesize + x_start] != buf[y*linesize + x_start]) {\n\n                    same_column = 0;\n\n                    break;\n\n                }\n\n            }\n\n            if (!same_column)\n\n                break;\n\n            x_start++;\n\n        }\n\n        while (x_end > x_start) {\n\n            int same_column = 1;\n\n            for (y = y_start; y <= y_end; y++) {\n\n                if (ref[y*ref_linesize + x_end] != buf[y*linesize + x_end]) {\n\n                    same_column = 0;\n\n                    break;\n\n                }\n\n            }\n\n            if (!same_column)\n\n                break;\n\n            x_end--;\n\n        }\n\n        width = x_end + 1 - x_start;\n\n\n\n        av_log(avctx, AV_LOG_DEBUG,\"%dx%d image at pos (%d;%d) [area:%dx%d]\\n\",\n\n               width, height, x_start, y_start, avctx->width, avctx->height);\n\n    }\n\n\n\n    /* image block */\n\n    bytestream_put_byte(bytestream, GIF_IMAGE_SEPARATOR);\n\n    bytestream_put_le16(bytestream, x_start);\n\n    bytestream_put_le16(bytestream, y_start);\n\n    bytestream_put_le16(bytestream, width);\n\n    bytestream_put_le16(bytestream, height);\n\n\n\n    if (!palette) {\n\n        bytestream_put_byte(bytestream, 0x00); /* flags */\n\n    } else {\n\n        unsigned i;\n\n        bytestream_put_byte(bytestream, 1<<7 | 0x7); /* flags */\n\n        for (i = 0; i < AVPALETTE_COUNT; i++) {\n\n            const uint32_t v = palette[i];\n\n            bytestream_put_be24(bytestream, v);\n\n        }\n\n    }\n\n\n\n    if (honor_transparency && trans < 0) {\n\n        trans = pick_palette_entry(buf + y_start*linesize + x_start,\n\n                                   linesize, width, height);\n\n        if (trans < 0) { // TODO, patch welcome\n\n            av_log(avctx, AV_LOG_DEBUG, \"No available color, can not use transparency\\n\");\n\n        } else {\n\n            uint8_t *pal_exdata = s->pal_exdata;\n\n            if (!pal_exdata)\n\n                pal_exdata = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);\n\n            if (!pal_exdata)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(pal_exdata, s->palette, AVPALETTE_SIZE);\n\n            pal_exdata[trans*4 + 3*!HAVE_BIGENDIAN] = 0x00;\n\n        }\n\n    }\n\n    if (trans < 0)\n\n        honor_transparency = 0;\n\n\n\n    bytestream_put_byte(bytestream, 0x08);\n\n\n\n    ff_lzw_encode_init(s->lzw, s->buf, 2 * width * height,\n\n                       12, FF_LZW_GIF, put_bits);\n\n\n\n    ptr = buf + y_start*linesize + x_start;\n\n    if (honor_transparency) {\n\n        const int ref_linesize = s->last_frame->linesize[0];\n\n        const uint8_t *ref = s->last_frame->data[0] + y_start*ref_linesize + x_start;\n\n\n\n        for (y = 0; y < height; y++) {\n\n            memcpy(s->tmpl, ptr, width);\n\n            for (x = 0; x < width; x++)\n\n                if (ref[x] == ptr[x])\n\n                    s->tmpl[x] = trans;\n\n            len += ff_lzw_encode(s->lzw, s->tmpl, width);\n\n            ptr += linesize;\n\n            ref += ref_linesize;\n\n        }\n\n    } else {\n\n        for (y = 0; y < height; y++) {\n\n            len += ff_lzw_encode(s->lzw, ptr, width);\n\n            ptr += linesize;\n\n        }\n\n    }\n\n    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);\n\n\n\n    ptr = s->buf;\n\n    while (len > 0) {\n\n        int size = FFMIN(255, len);\n\n        bytestream_put_byte(bytestream, size);\n\n        if (end - *bytestream < size)\n\n            return -1;\n\n        bytestream_put_buffer(bytestream, ptr, size);\n\n        ptr += size;\n\n        len -= size;\n\n    }\n\n    bytestream_put_byte(bytestream, 0x00); /* end of image block */\n\n    return 0;\n\n}\n", "idx": 14588, "substitutes": {"avctx": ["avercontext", "avercp", " avcmp", "abcontext", "wavcontext", "avtx", "ovjac", "navcp", "Avctx", "avdad", " avcontext", "vtx", "vctl", "vcontext", "vacontext", "avecheck", "navconf", "svctl", "savpkg", "ajctx", "abpkg", "ovctx", "avcmd", "avpkg", "navctx", "averctx", "Avcu", "avcheck", "ovcontext", "vapool", "avectx", "savjac", "vacheck", "vactx", "avjac", "navcmd", "averconf", "avcu", "avercu", "avcci", "ovdad", "avepool", "wavpool", "avcontext", "avercmd", "ovpkg", "wavcheck", "avpool", "savctx", "abctx", "avecontext", "Avcontext", "wavpkg", "savcci", "ajcmd", "ovcci", "Avcmp", "ajconf", "avcmp", "avcp", "vctx", "avercmp", " avcu", "ajcp", " avctl", "avctl", " avtx", "wavdad", "svctx", "wavctx", "wavjac", "avconf", "wavcci", "svcontext", "abdad", "svtx"], "bytestream": ["Byteststream", "Bythream", "bythstream", "Bytestring", "bythamps", "byterream", "byptrring", "byptramps", "Bytestream", "byteststream", "byterstream", "bythring", "Bythstream", "Bythamps", "Bythring", "bythream", "byteramps", "byptrream", "byptrstream", "Bytestamps", "bytestamps", "bytestring", "byterring"], "end": ["ff", "send", "stop", "nd", "addr", "begin", "dest", "st", "eng", "set", "start", "add", "bound", "ent", "buff", "close", "e", "id", "offset", "ending", "en", "ended", "enc", "ender", "pad", "pend"], "palette": ["colorlete", "Palettes", "plette", "Pallete", "pacettes", "palipple", "Palcolor", "plcolor", "Palette", "Palaque", "Palipple", "pacette", "coloraque", "pacipple", "colorette", "palettes", "palaque", "pallete", "plaque", "paccolor", "plettes", "plipple", "palcolor", "colorettes", "pllete"], "buf": ["uf", "pkg", "queue", "ff", "cache", "prop", "fam", "bytes", "tmp", "txt", "bf", "br", "rb", "conv", "pool", "Buff", "cb", "conf", "p", "def", "vec", "err", "cam", "img", "desc", "mb", "raw", "buff", "mem", "b", "fb", "window", "db", "eb", "buffer", "ctx", "cv", "Buffer", "cap", "msg", "lim", "bin", "seq", "proc", "func", "late", "pad", "cmd", "deg", "wb", "emb", "bg", "doc"], "linesize": ["framesizer", "inesIZE", "elinesization", "linesIZE", "setsiz", "linesization", "framesize", "pagesization", "linesized", "stylesize", "namesizer", "vertssize", "vertsizer", "stylesIZE", "framesization", "inesiz", "setsization", "locksize", "locksizer", "nameszie", "valsization", "valsiz", "inesocate", "inesizer", "facesizer", "namespace", "boardsize", "linesizer", "boardsization", "elinesIZE", "pagesIZE", "elinesocate", "valsizer", "framespace", "namesization", "valsize", "inesized", "inespace", "pagesize", " linesization", "namesiz", "imagesization", "imagesizer", "lockssize", "facesization", "vertsize", "stylesization", " lineszie", "boardsIZE", "setsize", "inesization", "lineszie", "imagessize", "facesiz", "stylesized", "setszie", "pagesocate", " linesiz", "facesize", "linessize", "linesiz", "inesize", "imagesize", "locksization", "linesocate", "linespace", "namesize", "boardsized", "vertsization", "elinesize"], "pkt": ["pkg", "ppmsg", "cpkt", " pqt", "pmsg", " pkg", "ppqt", "cpmsg", " pmsg", "ppkg", "cpqt", "cpkg", "ppkt", "pqt"], "s": ["bs", "details", "h", "d", "fs", "aunts", "rs", "changes", "n", "sb", "ops", "z", "ses", "S", "os", "als", "styles", "c", "sv", "ps", "comm", "p", "sys", "r", "es", "set", "m", "ls", "sports", "vs", "hs", "aws", "gs", "ats", "ports", "js", "scripts", "ctx", "sts", "w", "ims", "spec", "ags", "g", "sq", "sw", "aps", "less", "ex", "t", "ds", "actions", "times", "states", "cs", "ts", "sc", "comments", "is", "v", "stats", "ins", "qs", "parts", "scl", "ns", "ss"], "x": ["xp", "l", "dx", "image", "z", "tx", "px", "xt", "p", "m", "rx", "e", "xy", "index", "path", "xi", "ex", "ox", "X", "ix", "o", "w", "xx"], "y": ["wy", "ey", "ch", "py", "ye", "l", "ly", "n", "ady", "yd", "ty", "vy", "aily", "yi", "z", "kit", "story", "ies", "lat", "acy", "iy", "cy", "yn", "yes", "p", "uy", "sy", "icy", "zy", "m", "ym", "key", "iley", "rey", "hey", "yz", "ry", "b", "e", "yer", "yout", "xy", "my", "index", "ay", "j", "xxx", "ny", "ya", "axy", "yl", "gy", "try", "ys", "oy", "t", "yy", "yr", "ery", "o", "Y", "tiny", "sky", "ley", "by", "idy", "io", "yt"], "ptr": ["rel", "ff", "ind", "req", "map", "alloc", "br", "cur", "addr", "src", "dest", "pen", "loc", "err", "tr", "dr", "buff", "pos", "seek", "ctx", "pointer", "id", "offset", "row", "inter", "pad", "pend"], "ref": ["uf", "pkg", "rel", "ff", "cal", "info", "rep", "prop", "req", "cache", "map", "orig", "br", "rb", "re", "tab", "reg", "addr", "cb", "REF", "conf", "def", "r", "err", "tr", "desc", "pro", "mb", "buff", "pos", "mem", "fb", "rev", "db", "rc", "Ref", "reference", "buffer", "iter", "ret", "note", "ro", "url", "red", "range", "row", "grab", "rot", "seq", "ef", "arg", "resp", "deg", "cmd", "val", "all", "f", "obj", "reset"], "y_start": ["ny_step", "y_part", "ny0store", "y7starting", "ny_end", "ny0entry", "y7set", "y___set", "y0set", "ry_start", " y_Start", "y0entry", "my_start", "y_begin", "y_list", "x_begin", "ry_store", "y0start", "ny0set", " y_entry", "y_entry", "y09start", "ny_store", "yGstart", " y_open", " y_since", "y_open", "y0store", "y___start", "yGopen", "x_offset", "y_offset", "ry_part", "y_shift", "y7start", "x_inter", "y09starting", "y_starter", "yGend", "ry_starting", "y09part", "y_set", "y_wind", "y_starting", "y_store", "ry_wind", "my_part", "ny_set", "y_since", "y09end", "ny0start", "y___store", "ny_entry", "y_step", "y_inter", "ny_starter", "y09inter", "y_Start", "yGentry", "ny_start", "y09set", "y___entry", "my_end", "y09list", "my_shift", "y7part", "ry_set", "x_list"], "y_end": ["yPback", "ya_east", "ya_start", "y67east", "y__enable", "yresstart", "y_stop", "yptmax", "yPend", " y_out", "x_east", "ey_term", "key_end", "y_out", "y__term", "my_en", "y2ended", "key_enable", "x_ended", "y67ended", "y_east", "ey_end", "my_start", "y67en", "key67end", "yptstart", "key67ended", "yjend", "x_term", "key67enable", "yPrest", "yJterm", "my_End", "y_rest", "key67start", "ya67en", "yptend", " y_max", "yPstart", "ya67east", "yPeast", "ey_only", "yjstart", "yjen", "ya67start", "y_alt", "yresEnd", "y67enable", "y_term", "yJonly", "y2enable", "y_edge", "y67start", "y_enable", "y__end", "y_only", "ya67end", "y_max", "y_en", "ya_end", "my_edge", "ey_enable", "yptout", "y2start", "yJenable", "y_back", "yPstop", "x_stop", "y__only", "yJend", "x_rest", "ya_en", "my_end", "x_back", "key_start", "yresedge", "my_alt", "y2end", "y_ended", "yjalt", "y_End", "y2term", "yresend", "key_ended", "y67end"], "x_start": ["x_first", "y_index", "x10try", "x8get", "lex03try", "lex03start", "ex_old", "x_get", "ex_start", "x03start", "x00old", "x_sample", "x8next", "lex_try", "x___start", "x2start", "mx_client", "x03next", "x00get", "ex_first", "x_old", "mx_start", "mx_get", "x_next", "ex_root", "x8client", "x_Start", "x10start", "x00Start", "x00train", "ex_Start", "x_client", "x03get", "x03sample", "mx8get", "x10sample", "ex_train", "mx8starter", "x8start", "x_index", "ex_end", "x2end", "mx8client", "lex_next", "x00client", "x00start", "x2index", "x03client", "x00root", "x___end", "x8try", "lex_sample", "x00starter", "x03starter", "x_try", "x03try", "mx8start", "x_starter", "mx_starter", "x___train", "x10next", "x8sample", "x_train", "x___old", "lex03sample", "lex_start", "lex03next", "x8starter", "x00end", "x_root"], "x_end": ["x_ending", "x_until", "x9start", "x_run", "ex_ord", "x__ad", "x__start", "ex_stop", "ex_start", "x9ord", "x__ending", "ex_load", "x9end", "ex_max", "ex_save", "x_max", "ex_run", "x_save", "ex_ending", "ex_ad", "x_load", "x_right", "ex_end", "x__end", "x9load", "x_ad", "ex_until", "ex_right", "x_stop", "x_ord"]}}
{"project": "qemu", "commit_id": "9c4bab2668e6b5a9b69f77e3533380b6fd79034e", "target": 0, "func": "static int openfile(char *name, int flags)\n\n{\n\n\tif (bs) {\n\n\t\tfprintf(stderr, \"file open already, try 'help close'\\n\");\n\n\t\treturn 1;\n\n\t}\n\n\n\n\tbs = bdrv_new(\"hda\");\n\n\tif (!bs)\n\n\t\treturn 1;\n\n\n\n\tif (bdrv_open(bs, name, flags) == -1) {\n\n\t\tfprintf(stderr, \"%s: can't open device %s\\n\", progname, name);\n\n\t\tbs = NULL;\n\n\t\treturn 1;\n\n\t}\n\n\n\n\treturn 0;\n\n}\n", "idx": 14589, "substitutes": {"name": ["ch", "l", "type", "prefix", "n", "Name", "nam", "nw", "format", "local", "title", "out", "NAME", "new", "p", "s", "ma", "nm", "m", "key", "mem", "b", "e", "names", "sp", "path", "id", "ni", "size", "str", "j", "me", "cap", " Name", "data", "mod", "filename", "file", "part", "ame", "a", "val", "v", "base", "w"], "flags": ["fps", "limits", "ants", "ids", "ensions", "styles", "FLAG", "heads", " Flags", "eps", "fields", "weights", "atts", "args", "posts", "options", "ms", "flag", "features", "faces", "Flags", "ats", "ports", "members", "locks", "ags", "tags", "aps", "ents", "properties", "times", "acts", "ts", "cs", "bits", "types", "grades", "lag", "parts", "lines"]}}
{"project": "qemu", "commit_id": "67113c03423a23e60915574275aed7d60e9f85e1", "target": 0, "func": "static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)\n\n{\n\n    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);\n\n    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),\n\n                                  \"/e500-ccsr\"));\n\n\n\n    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);\n\n    d->config[PCI_HEADER_TYPE] =\n\n        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n\n\n    memory_region_init_alias(&b->bar0, OBJECT(ccsr), \"e500-pci-bar0\", &ccsr->ccsr_space,\n\n                             0, int128_get64(ccsr->ccsr_space.size));\n\n    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);\n\n}\n", "idx": 14591, "substitutes": {"d": ["dn", "h", "dl", "i", "ind", "l", "dm", "send", "dx", "n", "dt", "di", "dp", "x", "dc", "draw", "c", "did", "q", "dh", "ed", "del", "p", "bd", "r", "m", "dr", "pd", "e", "db", "dev", "md", "dd", "de", "D", "g", "j", "ad", "sd", "data", "ct", "dq", "mod", "t", "ds", "dos", "du", "o", "ld", "v", "ded", "w", "dat", "da"], "errp": ["erp", "errpp", " errpp", "erps", "erpp", "iterP", " errP", "errps", "iterpp", " errps", "errP", "iterps", "erP", "iterp"], "b": ["bs", "blue", "l", "bar", "reb", "n", "sb", "bt", "bc", "rb", "c", "bh", "cb", "p", "bd", "r", "ib", "m", "pb", "mb", "e", "fb", "db", "eb", "bb", "w", "g", "job", "j", "erb", "B", "amb", "nb", "bp", "a", "ba", "v", "y", "wb", "emb", "bg", "ab", "be", "f", "gb"], "ccsr": ["acsr", "ckrx", "pcrf", "csrx", "ckri", "cksf", "crf", "ckcr", "csspr", "ccrf", "ccSR", "cfSR", "ccsf", "pcsf", "ccicr", "cfri", "pcr", "csr", "ccspr", "cfsr", "pcsr", "cssf", "ccar", "cser", "cssr", "cccr", "acSR", "ccisr", "pcser", "pccr", "ccri", "cksr", "accr", "ccarf", "cciSR", "acri", "ccasr", "ccrx", "ccr", "csSR", "ccaser", "pcrx", "cfcr", "cr", "cscr", "ccser", "acspr", "ckSR", "ccispr"]}}
{"project": "FFmpeg", "commit_id": "290e7eb77bee5a54182fb3d5fb122c1e117190da", "target": 1, "func": "void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)\n\n{\n\n    int i;\n\n\n\n    for (i=0; i < in->n; i++) {\n\n        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);\n\n\n\n\n        do {\n\n            out[x] = 0.0;\n\n            x += in->pitch_lag;\n\n        } while (x < size && repeats);\n\n    }\n\n}", "idx": 14599, "substitutes": {"out": ["soft", "sum", "ref", "con", "serv", "clean", "x", "off", "ou", "pool", "result", "c", "new", "OUT", "ul", "p", "set", "check", "list", "client", "pos", "b", "array", "ot", "Out", "ret", "at", "it", "res", "found", "t", "net", "hit", "o", "print", "v", "y", "all", "f", "obj", "w", "up", "output"], "in": ["inf", "ind", "info", "l", "con", "req", "sum", "version", "rin", "serv", "inc", "inn", "local", "re", "init", "input", "old", "vin", "new", "from", "add", "ma", "raw", " IN", "min", "din", "isin", "al", "gin", "inner", "In", "it", "at", "bit", "bin", "ex", "mm", "t", "file", "IN", "ac", "by", "ins", "base", "or", "doc", "up", "on"], "size": ["shape", "equal", "ize", "sum", "l", "sn", "send", "n", "SIZE", "z", "space", "small", "number", "scale", "set", "capacity", "start", "si", "m", "empty", "name", "e", "count", "len", "no", "index", "g", "see", "offset", "num", "max", "ze", "v", "Size", "scope", "length", "or", "w", "shift"], "i": ["ind", "info", "l", "d", "ai", "ii", "n", "gi", "io", "z", "di", "x", "sim", "ij", "ip", "init", "c", "u", "ti", "li", "hi", "I", "p", " I", "si", "m", "ri", "us", "multi", "e", "im", "chain", "b", "ims", "fi", "index", "iu", "id", " ii", "it", "j", "me", "uri", "ci", "xi", "ex", "inter", "ic", "ki", "t", "phi", "zi", "ix", "mi", "is", "o", "pi", "y", "by", "bi", "ini", "ui", "v", " multi", " ti", "f"]}}
{"project": "FFmpeg", "commit_id": "c58d45e00489e07fd4606b64ad4095660494185b", "target": 1, "func": "static int film_read_header(AVFormatContext *s,\n\n                            AVFormatParameters *ap)\n\n{\n\n    FilmDemuxContext *film = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    unsigned char scratch[256];\n\n    int i;\n\n    unsigned int data_offset;\n\n    unsigned int audio_frame_counter;\n\n\n\n    film->sample_table = NULL;\n\n    film->stereo_buffer = NULL;\n\n    film->stereo_buffer_size = 0;\n\n\n\n    /* load the main FILM header */\n\n    if (avio_read(pb, scratch, 16) != 16)\n\n        return AVERROR(EIO);\n\n    data_offset = AV_RB32(&scratch[4]);\n\n    film->version = AV_RB32(&scratch[8]);\n\n\n\n    /* load the FDSC chunk */\n\n    if (film->version == 0) {\n\n        /* special case for Lemmings .film files; 20-byte header */\n\n        if (avio_read(pb, scratch, 20) != 20)\n\n            return AVERROR(EIO);\n\n        /* make some assumptions about the audio parameters */\n\n        film->audio_type = CODEC_ID_PCM_S8;\n\n        film->audio_samplerate = 22050;\n\n        film->audio_channels = 1;\n\n        film->audio_bits = 8;\n\n    } else {\n\n        /* normal Saturn .cpk files; 32-byte header */\n\n        if (avio_read(pb, scratch, 32) != 32)\n\n            return AVERROR(EIO);\n\n        film->audio_samplerate = AV_RB16(&scratch[24]);\n\n        film->audio_channels = scratch[21];\n\n        film->audio_bits = scratch[22];\n\n        if (scratch[23] == 2)\n\n            film->audio_type = CODEC_ID_ADPCM_ADX;\n\n        else if (film->audio_bits == 8)\n\n            film->audio_type = CODEC_ID_PCM_S8;\n\n        else if (film->audio_bits == 16)\n\n            film->audio_type = CODEC_ID_PCM_S16BE;\n\n        else\n\n            film->audio_type = CODEC_ID_NONE;\n\n    }\n\n\n\n    if (AV_RB32(&scratch[0]) != FDSC_TAG)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (AV_RB32(&scratch[8]) == CVID_TAG) {\n\n        film->video_type = CODEC_ID_CINEPAK;\n\n    } else\n\n        film->video_type = CODEC_ID_NONE;\n\n\n\n    /* initialize the decoder streams */\n\n    if (film->video_type) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        film->video_stream_index = st->index;\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->codec->codec_id = film->video_type;\n\n        st->codec->codec_tag = 0;  /* no fourcc */\n\n        st->codec->width = AV_RB32(&scratch[16]);\n\n        st->codec->height = AV_RB32(&scratch[12]);\n\n    }\n\n\n\n    if (film->audio_type) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        film->audio_stream_index = st->index;\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_id = film->audio_type;\n\n        st->codec->codec_tag = 1;\n\n        st->codec->channels = film->audio_channels;\n\n        st->codec->sample_rate = film->audio_samplerate;\n\n\n\n        if (film->audio_type == CODEC_ID_ADPCM_ADX) {\n\n            st->codec->bits_per_coded_sample = 18 * 8 / 32;\n\n            st->codec->block_align = st->codec->channels * 18;\n\n        } else {\n\n            st->codec->bits_per_coded_sample = film->audio_bits;\n\n            st->codec->block_align = st->codec->channels *\n\n                st->codec->bits_per_coded_sample / 8;\n\n        }\n\n\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_coded_sample;\n\n    }\n\n\n\n    /* load the sample table */\n\n    if (avio_read(pb, scratch, 16) != 16)\n\n        return AVERROR(EIO);\n\n    if (AV_RB32(&scratch[0]) != STAB_TAG)\n\n        return AVERROR_INVALIDDATA;\n\n    film->base_clock = AV_RB32(&scratch[8]);\n\n    film->sample_count = AV_RB32(&scratch[12]);\n\n    if(film->sample_count >= UINT_MAX / sizeof(film_sample))\n\n        return -1;\n\n    film->sample_table = av_malloc(film->sample_count * sizeof(film_sample));\n\n    if (!film->sample_table)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for(i=0; i<s->nb_streams; i++)\n\n        av_set_pts_info(s->streams[i], 33, 1, film->base_clock);\n\n\n\n    audio_frame_counter = 0;\n\n    for (i = 0; i < film->sample_count; i++) {\n\n        /* load the next sample record and transfer it to an internal struct */\n\n        if (avio_read(pb, scratch, 16) != 16) {\n\n            av_free(film->sample_table);\n\n            return AVERROR(EIO);\n\n        }\n\n        film->sample_table[i].sample_offset =\n\n            data_offset + AV_RB32(&scratch[0]);\n\n        film->sample_table[i].sample_size = AV_RB32(&scratch[4]);\n\n        if (AV_RB32(&scratch[8]) == 0xFFFFFFFF) {\n\n            film->sample_table[i].stream = film->audio_stream_index;\n\n            film->sample_table[i].pts = audio_frame_counter;\n\n            film->sample_table[i].pts *= film->base_clock;\n\n            film->sample_table[i].pts /= film->audio_samplerate;\n\n\n\n            if (film->audio_type == CODEC_ID_ADPCM_ADX)\n\n                audio_frame_counter += (film->sample_table[i].sample_size * 32 /\n\n                    (18 * film->audio_channels));\n\n            else\n\n                audio_frame_counter += (film->sample_table[i].sample_size /\n\n                    (film->audio_channels * film->audio_bits / 8));\n\n        } else {\n\n            film->sample_table[i].stream = film->video_stream_index;\n\n            film->sample_table[i].pts = AV_RB32(&scratch[8]) & 0x7FFFFFFF;\n\n            film->sample_table[i].keyframe = (scratch[8] & 0x80) ? 0 : 1;\n\n        }\n\n    }\n\n\n\n    film->current_sample = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 14612, "substitutes": {"s": ["h", "fs", "d", "l", "rs", "n", "sb", "ses", "S", "c", "sv", "ps", "comm", "p", "r", "m", "ls", "gs", "b", "e", "ats", "js", "as", "spec", "g", "t", "ds", "cs", "sc", "is", "a", "v", "f", "stats", "sis", "ins", "ns", "skin", "ss"], "ap": ["apt", "map", "pa", "ip", " p", "ar", "ps", " sap", "pl", "ape", " par", "att", "mp", "tap", "tp", "al", "sp", "op", "aps", "cap", "amp", "ep", "pp", "ac", " af", " sp", "par", " mp"], "film": ["tv", "image", "history", " Film", "face", "frame", "information", "faith", "intelligence", "movie", "article", "fb", "material", "review", "talk", "evil", "redd", "debug", " filmmaking", "feature", "drm", "skin", "ani", "detail", "voice", "render", "lamm", "lead", "ovie", "video", "motion", "food", "filter", "tf", "vid", " films", "farm", "medium", "html", "ideo", "vati", "hid", "intel", "gif", "fiction", "performance", "print", "f", "hall", "web", "fm", "compliance", "wikipedia", "die", "internet", "football", "mmmm", "Film", "cam", "Director", "trak", "fi", "runtime", "fashion", "work", "pp", "research", "flash", "interstitial", "product", "het", "media", "find", "production", "stall", "contact", "feat", "gear", "actor", " movies", "fin", "arel", "race", "v", "DVD", "ammu"], "pb": ["pkg", "uf", "bs", "stab", "jp", "fp", "lp", "sb", "pc", "tmp", "dp", "conv", "tk", "rb", "ctl", "pa", "dc", "pool", "buf", "cmp", "bj", "np", "pid", "rpm", "cp", "cb", "pl", "p", "sys", "vp", "buff", "tc", "fb", "tp", "apy", "mp", "buffer", "pg", "ctx", "tap", "bb", "cv", "farm", "pel", "orp", "dial", "prep", "cpp", "PB", "proc", "bps", "typ", "apa", "bp", "snap", "pt", "pan", "pp", "prototype", "wb", "vm", "pm", "ub"], "st": ["ST", "tv", "std", "St", "sl", "spe", "isl", "ist", "sv", "src", "ste", "ss", "sam", "sp", "stable", "cont", "sh", "str", "sw", "est", "ct", "inst", "sta", "ped", "sc", "rest", "spect", "sts"], "scratch": ["swratch", "ancrub", " scatch", "scapy", "searchatch", "bcratch", "scarry", "Scratch", "nowrub", "nowrap", "searchrap", " scachable", "descreenshot", "escrawler", "escratch", " schematic", "Scachable", "escatter", "scrawler", "scashed", "Scattered", "bcarry", "bcattered", "nowratch", "scraped", "Scrub", "shatch", "shhematic", "escatch", "ascratch", "eschematic", "searchhematic", "descrub", " screenshot", "Scapy", " scrub", "scrub", "ancashed", "descarry", "ascapy", "ancrap", "escash", "descratch", "swrub", "escrap", "shapy", " scraped", "searchrawler", "escreenshot", "scash", " scattered", "ascatch", "ascatter", "escrub", " scapy", "escashed", "escarry", "shrap", "shattered", "scatter", "searchratch", "Scraped", "descash", "secratch", "screenshot", "shratch", "scatch", "schematic", "secrub", "Screenshot", "escachable", "escattered", "swreenshot", "swash", "descattered", " scatter", "swatch", "escapy", "bcachable", "ancratch", "swrawler", "scachable", "scrap", "nowashed", "bchematic", "scattered", "ascattered", "swattered", "secapy", "secraped", "ascrub"], "i": ["d", "l", "ai", "ii", "rin", "c", "ti", "li", "I", "p", "si", "m", "b", "ati", "fi", "iu", " ii", "it", "j", "ci", "xi", "mi", "o", "pi", "v", "bi", "iat", "io"], "data_offset": ["video_offset", "data00counter", " data_Offset", "data00pos", "data00offset", "video_count", " data_pointer", "data_count", "data_counter", "data_pos", "data___Offset", "video_counter", "data___address", "video_pos", " data_address", "data_pointer", "data___offset", "data_address", "data___pointer", "data00count", "data_Offset"], "audio_frame_counter": ["audio_frames_counter", "audio_frames_count", "audio_frame_count", "audio_frames_number", "audio_frames_sequence", "audio_frame_number", "audio_frame_sequence"]}}
{"project": "FFmpeg", "commit_id": "d9051f8f3e60768f68867c3e3116e980d855215a", "target": 1, "func": "static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)\n\n{\n\n    int16_t *block = ctx->dct_block;\n\n    unsigned int pos;\n\n\n\n    ctx->bdsp.clear_block(block);\n\n\n\n    block[0] = get_bits(&ctx->gb, 8) << 3;\n\n\n\n    for (pos = 1; pos < num_coeffs; pos++) {\n\n        uint32_t vlc, num_bits;\n\n        int value;\n\n        int coeff;\n\n\n\n        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);\n\n        if (!vlc) /* end-of-block code */\n\n            return 0;\n\n        if (vlc == -1)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        /* pos_add and num_bits are coded in the vlc code */\n\n        pos     += vlc & 15; // pos_add\n\n        num_bits = vlc >> 4; // num_bits\n\n\n\n        if (pos >= 64)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        value = get_bits(&ctx->gb, num_bits);\n\n\n\n        /* FFmpeg's IDCT behaves somewhat different from the original code, so\n\n         * a factor of 4 was added to the input */\n\n\n\n        coeff = vlcdec_lookup[num_bits][value];\n\n        if (pos < 3)\n\n            coeff *= 16;\n\n        else /* TODO Use >> 10 instead of / 1001 */\n\n            coeff = (coeff * qscale) / 1001;\n\n\n\n        block[ctx->scantable.permutated[pos]] = coeff;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14639, "substitutes": {"ctx": ["pkg", "bc", "history", "conv", "cmp", "px", "cm", "np", "cp", "cb", "HK", "check", "ork", "cv", "acl", "ca", "sc", "context", "that", "kw", "std", "tmp", "ck", "stack", "txt", "ctrl", "Context", "cu", "def", "jac", "height", "cfg", "mk", "course", "ia", "tc", "rc", "gc", "kt", "cf", "conn", "anc", "tm", "resp", "cmd", "abc", "fx", "jp", "prefix", "req", "pc", "cas", "dc", "etc", "exec", "loc", "sys", "nt", "cc", "ct", " cx", "lex", "work", "aux", "xp", "tx", "ctl", "setup", "xc", "hw", "conf", "desc", "xs", "window", "act", "ic", "crit", "nc", "config", "wx", "obj", "iat", "scl"], "num_coeffs": ["num_cofficers", "num_coeffes", "num_coefficientS", "num_cofficS", "num_coefes", "num_coeffers", "num_coefficientsS", "num_coeffS", "num_coefers", "num_coefS", "num_coffics", "num_coefficientss", "num_coefficientes", "num_coefficientses", "num_coffers", "num_coefs", "num_coffS", "num_coefficients", "num_coffs"], "qscale": ["Qscale", "Qdelay", " QScale", "qtransform", "qScale", "qqScale", "qvscale", " Qtransform", " sqtransform", "qqdelay", "qvdelay", " sqScale", "Qweight", "qvScale", "qdelay", "qvweight", " Qscale", "qweight", "qqweight", "qqscale", "Qtransform", "QScale", " sqscale"], "block": ["BL", "view", "cache", "ref", "map", "join", "bl", "bc", "ck", "save", "panel", "tx", "group", "hash", "ip", "session", "pool", "out", "local", "init", "q", "filter", "bus", "list", "zero", "batch", "blocks", "mem", "chain", "window", "box", "field", "buffer", "sp", "ack", "object", "loop", "record", "line", "load", "bit", "limit", "ml", "lock", "disk", "row", "board", "cl", "bin", "pack", "link", "inv", "Block", "library", "sync", "obj", "bm", "mask"], "pos": ["bs", " len", "Position", "padding", "px", "ps", "Pos", "offset", "rot", "POS", "snap", "pt", "pr", "prop", "os", "slot", "pid", "def", "position", "tag", "client", "start", "pro", "loop", "size", "at", "limit", "num", "pres", "pat", "po", "apo", "part", "length", "doc", "ind", "nos", "pc", "trans", "x", "off", "loc", "pl", "pose", "mut", "key", " POS", "count", "no", "index", "op", "proc", "axis", "cond", "o", "val", "pi", "oss", " position", "point", "go", "out", "conf", "p", "neg", "port", "slice", "len", "pointer", "spec", "P", "row", " Pos", "diff", "post", "up", "shift"], "vlc": ["vcc", "vlpc", "slcc", "vccu", "volcu", "lvcs", "lvpc", "wltc", "klce", "volcc", "wlcu", "palcc", "vlcc", "klc", "bilce", "volc", "wlci", "slc", "lvtc", "llci", "slci", "llvc", "llpc", "plci", "pelcc", "vlci", "plc", "lvvc", "bilci", " plc", "lvc", "llc", " plci", "pltc", "volpc", "wlpc", "lvcu", "volcat", "vlvc", "slcu", "vinci", "wlce", "vlcat", "bilcs", "vccat", "lvcat", "vincc", "vlcs", "vlcu", "wlcs", "klcs", "klci", "svcs", "vinc", "pelpc", "svc", "wlc", "svpc", "wlcc", "vctc", " plpc", "vinpc", "vccs", "slpc", "palpc", "palcu", "vcci", "voltc", "pelci", " plvc", "plcs", "lvci", "palc", "pelc", "vlce", "svcu", "vltc", "bilc"], "num_bits": [" num_its", "num_bytes", "num2bit", "num_nets", " num_vals", " num_nets", "Num_bits", "num_ints", "num_bit", "num23bits", "num_bis", "num_planes", "Num_bit", "num_its", " num_bytes", " num_planes", "num2ints", "num_pieces", "num2its", "total_pieces", "num23bytes", "num_vals", "total_bytes", "num23vals", "Num_its", "total_bis", "Num_ints", "total_bits", "num2planes", "num23nets", "num2bytes", "num2bits"], "value": ["context", "TV", "tv", "version", "type", "select", "address", "package", "color", "image", "style", "word", "serial", "number", "new", "scale", "property", "VAL", "tag", "true", "position", "key", "vp", "valid", "raw", "Value", "name", "code", "field", "total", "attribute", "unit", "index", "instance", "see", "values", "VALUE", "bit", "num", "data", "vector", "comment", "widget", "ue", "val", "function", "v", "text", "length", "current", "label"], "coeff": ["coffe", "Coefficient", "COeff", "Coef", "coefficient", "COef", "COffe", "Coeff", "corffe", "coreff", "COefficient", "corff", "coef", " Coff", " Coeff", " coffe", "COff", " coff", " coef", " Coef", " coefficient", " Coefficient", "coff", "Coff", "coref"]}}
{"project": "FFmpeg", "commit_id": "87e302bfd8ffbc6cdb20920029013956b10ace63", "target": 0, "func": "static int svq3_decode_frame(AVCodecContext *avctx,\n\n                             void *data, int *data_size,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MpegEncContext *const s = avctx->priv_data;\n\n    H264Context *const h = avctx->priv_data;\n\n    int m, mb_type;\n\n\n\n    /* special case for last picture */\n\n    if (buf_size == 0) {\n\n        if (s->next_picture_ptr && !s->low_delay) {\n\n            *(AVFrame *) data = *(AVFrame *) &s->next_picture;\n\n            s->next_picture_ptr = NULL;\n\n            *data_size = sizeof(AVFrame);\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    init_get_bits (&s->gb, buf, 8*buf_size);\n\n\n\n    s->mb_x = s->mb_y = h->mb_xy = 0;\n\n\n\n    if (svq3_decode_slice_header(h))\n\n        return -1;\n\n\n\n    s->pict_type = h->slice_type;\n\n    s->picture_number = h->slice_num;\n\n\n\n    if (avctx->debug&FF_DEBUG_PICT_INFO){\n\n        av_log(h->s.avctx, AV_LOG_DEBUG, \"%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\\n\",\n\n               av_get_pict_type_char(s->pict_type), h->halfpel_flag, h->thirdpel_flag,\n\n               s->adaptive_quant, s->qscale, h->slice_num);\n\n    }\n\n\n\n    /* for hurry_up == 5 */\n\n    s->current_picture.pict_type = s->pict_type;\n\n    s->current_picture.key_frame = (s->pict_type == FF_I_TYPE);\n\n\n\n    /* Skip B-frames if we do not have reference frames. */\n\n    if (s->last_picture_ptr == NULL && s->pict_type == FF_B_TYPE)\n\n        return 0;\n\n    /* Skip B-frames if we are in a hurry. */\n\n    if (avctx->hurry_up && s->pict_type == FF_B_TYPE)\n\n        return 0;\n\n    /* Skip everything if we are in a hurry >= 5. */\n\n    if (avctx->hurry_up >= 5)\n\n        return 0;\n\n    if (  (avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == FF_B_TYPE)\n\n        ||(avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != FF_I_TYPE)\n\n        || avctx->skip_frame >= AVDISCARD_ALL)\n\n        return 0;\n\n\n\n    if (s->next_p_frame_damaged) {\n\n        if (s->pict_type == FF_B_TYPE)\n\n            return 0;\n\n        else\n\n            s->next_p_frame_damaged = 0;\n\n    }\n\n\n\n    if (frame_start(h) < 0)\n\n        return -1;\n\n\n\n    if (s->pict_type == FF_B_TYPE) {\n\n        h->frame_num_offset = (h->slice_num - h->prev_frame_num);\n\n\n\n        if (h->frame_num_offset < 0) {\n\n            h->frame_num_offset += 256;\n\n        }\n\n        if (h->frame_num_offset == 0 || h->frame_num_offset >= h->prev_frame_num_offset) {\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"error in B-frame picture id\\n\");\n\n            return -1;\n\n        }\n\n    } else {\n\n        h->prev_frame_num = h->frame_num;\n\n        h->frame_num = h->slice_num;\n\n        h->prev_frame_num_offset = (h->frame_num - h->prev_frame_num);\n\n\n\n        if (h->prev_frame_num_offset < 0) {\n\n            h->prev_frame_num_offset += 256;\n\n        }\n\n    }\n\n\n\n    for (m = 0; m < 2; m++){\n\n        int i;\n\n        for (i = 0; i < 4; i++){\n\n            int j;\n\n            for (j = -1; j < 4; j++)\n\n                h->ref_cache[m][scan8[0] + 8*i + j]= 1;\n\n            if (i < 3)\n\n                h->ref_cache[m][scan8[0] + 8*i + j]= PART_NOT_AVAILABLE;\n\n        }\n\n    }\n\n\n\n    for (s->mb_y = 0; s->mb_y < s->mb_height; s->mb_y++) {\n\n        for (s->mb_x = 0; s->mb_x < s->mb_width; s->mb_x++) {\n\n            h->mb_xy = s->mb_x + s->mb_y*s->mb_stride;\n\n\n\n            if ( (get_bits_count(&s->gb) + 7) >= s->gb.size_in_bits &&\n\n                ((get_bits_count(&s->gb) & 7) == 0 || show_bits(&s->gb, (-get_bits_count(&s->gb) & 7)) == 0)) {\n\n\n\n                skip_bits(&s->gb, h->next_slice_index - get_bits_count(&s->gb));\n\n                s->gb.size_in_bits = 8*buf_size;\n\n\n\n                if (svq3_decode_slice_header(h))\n\n                    return -1;\n\n\n\n                /* TODO: support s->mb_skip_run */\n\n            }\n\n\n\n            mb_type = svq3_get_ue_golomb(&s->gb);\n\n\n\n            if (s->pict_type == FF_I_TYPE) {\n\n                mb_type += 8;\n\n            } else if (s->pict_type == FF_B_TYPE && mb_type >= 4) {\n\n                mb_type += 4;\n\n            }\n\n            if (mb_type > 33 || svq3_decode_mb(h, mb_type)) {\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"error while decoding MB %d %d\\n\", s->mb_x, s->mb_y);\n\n                return -1;\n\n            }\n\n\n\n            if (mb_type != 0) {\n\n                hl_decode_mb (h);\n\n            }\n\n\n\n            if (s->pict_type != FF_B_TYPE && !s->low_delay) {\n\n                s->current_picture.mb_type[s->mb_x + s->mb_y*s->mb_stride] =\n\n                    (s->pict_type == FF_P_TYPE && mb_type < 8) ? (mb_type - 1) : -1;\n\n            }\n\n        }\n\n\n\n        ff_draw_horiz_band(s, 16*s->mb_y, 16);\n\n    }\n\n\n\n    MPV_frame_end(s);\n\n\n\n    if (s->pict_type == FF_B_TYPE || s->low_delay) {\n\n        *(AVFrame *) data = *(AVFrame *) &s->current_picture;\n\n    } else {\n\n        *(AVFrame *) data = *(AVFrame *) &s->last_picture;\n\n    }\n\n\n\n    avctx->frame_number = s->picture_number - 1;\n\n\n\n    /* Do not output the last pic after seeking. */\n\n    if (s->last_picture_ptr || s->low_delay) {\n\n        *data_size = sizeof(AVFrame);\n\n    }\n\n\n\n    return buf_size;\n\n}\n", "idx": 14654, "substitutes": {"avctx": ["avercontext", "vrconn", "averconn", "wavcontext", "avtx", "Avctx", "averbc", "vrcontext", "avdt", "averce", "avcfg", "Avcfg", " avcontext", "wavctl", "wavconn", "avegc", "avconfig", "avcam", "avercam", "averconfig", "AVctl", "avepkg", "avbc", "avecu", "averctl", "avpkg", "vrtx", "averctx", "AVconn", "avejac", "Avbc", "avectx", "avercc", "vrcu", " avconn", "avjac", "avce", "svconn", "varctl", "aveconfig", "avcu", "avergc", "avercu", "camjac", "AVctx", "avcontext", "avercfg", " avbc", "avece", "avecam", "avecontext", "Avcontext", "vrce", "avedt", "avcc", "averpkg", "avcmp", "wavtx", "avgc", "averjac", "vrctx", "avercmp", " avcfg", "averdt", "camctx", "wavconfig", "avetx", "avecc", "avctl", " avtx", "svctx", "wavctx", "wavgc", "varcmp", "avertx", "avectl", "AVtx", "avecmp", "avconn", "aveconn", "vrcc", "svcontext", "campkg", "varctx", "vardt", "vrcam", "svtx", "camcc"], "data": ["d", "info", "cache", "bytes", "image", "Data", "content", "DATA", "next", "value", "feed", "frame", "input", "video", "ata", "c", "result", "picture", "message", "p", "r", "batch", "empty", "img", "raw", "name", "read", "mem", "window", "buffer", "block", "size", "str", "bin", "t", "file", "align", "pad", "a", "bits", "text", "f", "v", "length", "w", "area", "dat"], "data_size": ["data_body", " data_number", "data64size", "data64SIZE", "buf_Size", "buf_size", "data_number", "data_SIZE", "data64number", " data_SIZE", "data_Size", "buf_body"], "avpkt": ["afpacket", "avjpkt", "awpft", "avnpacket", "avcpct", "avpqt", "avcpft", "afcpkt", "awpct", "awpacket", "avpcmd", "avpconn", "avPqt", "avppft", " avPkt", "avnpkt", "awcpacket", "avcpcmd", "avdcmd", "avppkt", "avnpconn", "afcpcmd", "avjpacket", "afppt", "avdpt", "avcpkt", "afcppt", " avPacket", "avPft", "avpct", "awcpkt", "awpkt", "avppacket", "awcpft", "afpkt", "avPconn", " avPqt", "avdacket", "avdkt", "avpft", "avjpqt", "avPacket", "avcppt", "avppt", "avjpconn", "avcpacket", "afcpacket", " avpconn", " avpqt", "afpcmd", "avpacket", "avnpqt", "avjpcmd", "avPkt", "avppct", "avjppt", "avPct", " avPconn", "awcpct", " avpacket"], "buf": ["uf", "queue", "map", "bytes", "bl", "tmp", "bc", "txt", "br", "conv", "rb", "Buff", "np", "cb", "bh", "p", "vec", "r", "batch", "img", "raw", "buff", "read", "mem", "b", "fb", "window", "box", "rc", "buffer", "block", "cv", "Buffer", "msg", "cmd", "v", "doc"], "s": ["bs", "fs", "ears", "ps", "his", "args", "ms", "ports", "js", "sa", "g", "services", "sh", "sw", "gets", "se", "tests", "sm", "y", "ins", "details", "d", "changes", "sb", "results", "os", "als", "ands", "sv", "has", "set", "sports", "as", "sp", "t", "is", "parts", "ns", "sum", "l", "rs", "S", "so", "service", "c", "st", "sys", "ess", "ls", "vs", "hs", "ats", "its", "ims", "sq", "ts", "bits", "a", "qs", "sts", "ss", "n", "settings", "z", "ses", "state", "ar", "conf", "p", "es", "sam", "gs", "b", "spec", "less", "ds", "cs", "comments", "sort", "v", "stats"], "h": ["d", "ch", "l", "hh", "hd", "info", "th", "history", "header", "ha", "hash", "os", "http", "c", "q", "bh", "dh", "u", "hi", "hw", "H", "p", "gh", "r", "host", "zh", "handle", "hs", "ish", "kh", "b", "ah", "hz", "he", "hl", "eh", "rh", "ih", "html", "it", "sh", "g", "hp", "hal", "uh", "ec", "t", "oh", "o", "hm", "v", "ph", "f", "has", "w", "ht"], "m": ["d", "dm", "om", "n", "gm", " im", "cmp", " p", "M", "p", "nm", "img", "dim", "mem", "im", "b", " v", "imm", "um", " M", "t", "attr", " mt", "mi", "v", "perm", "mask"], "mb_type": ["img_type", "mb_ty", "img_time", "mb_num", "mb_time", "img_ty", "img_num"], "mb_y": ["mb__iy", "MB_iy", "mb_e", "mb__e", "mb__y", "MB_y", "MB_e", "mb_iy", "MB_x", "mb__x"], "mb_x": ["mb__ex", "emb_xy", "mb_xy", "emb_ex", "mb__y", "emb_y", "emb_x", "mb__xy", "mb_ex", "mb__x"]}}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static av_cold int rl2_decode_init(AVCodecContext *avctx)\n\n{\n\n    Rl2Context *s = avctx->priv_data;\n\n    int back_size;\n\n    int i;\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    avcodec_get_frame_defaults(&s->frame);\n\n\n\n    /** parse extra data */\n\n    if(!avctx->extradata || avctx->extradata_size < EXTRADATA1_SIZE){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid extradata size\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /** get frame_offset */\n\n    s->video_base = AV_RL16(&avctx->extradata[0]);\n\n    s->clr_count = AV_RL32(&avctx->extradata[2]);\n\n\n\n    if(s->video_base >= avctx->width * avctx->height){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid video_base\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /** initialize palette */\n\n    for(i=0;i<AVPALETTE_COUNT;i++)\n\n        s->palette[i] = 0xFF << 24 | AV_RB24(&avctx->extradata[6 + i * 3]);\n\n\n\n    /** decode background frame if present */\n\n    back_size = avctx->extradata_size - EXTRADATA1_SIZE;\n\n\n\n    if(back_size > 0){\n\n        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);\n\n        if(!back_frame)\n\n            return -1;\n\n        rl2_rle_decode(s,avctx->extradata + EXTRADATA1_SIZE,back_size,\n\n                           back_frame,avctx->width,0);\n\n        s->back_frame = back_frame;\n\n    }\n\n    return 0;\n\n}\n", "idx": 14658, "substitutes": {"avctx": ["avercontext", "ajcm", " avcc", "abcc", "ajcu", " avcmp", "abcontext", "avercpu", "wavcontext", "avtx", "avecfg", "ajconn", " avreq", "ajpkg", "avcfg", "avcpu", " avcontext", "cvctx", "avecp", "awctx", " avtmp", "savcontext", "avconfig", "awcmp", "ajtx", "avereq", "avtmp", "savcrit", "ajctx", "ajjp", "averconfig", "cvcontext", "avepkg", "vertx", "abpkg", "vercontext", "afcontext", "avertmp", "ovctx", "avecu", " avcpu", "avcmd", "avpkg", "navctx", "averctx", "aftx", "devtx", "avejac", "navtmp", "avectx", " avconf", "avjp", "afctx", "avercc", "aftmp", "awpkg", "avecm", " avpkg", "ajjac", " avconn", "abtx", "avjac", "wavreq", "avcm", "avercm", "iverjp", "cvcrit", " avcrit", "verctx", "avcu", "devcc", "avercu", "ovcpu", "afjp", "avcontext", "avercmd", "avejp", "navjp", "awcp", "savctx", "abctx", "avecontext", "awcfg", "devcontext", "ovcmd", "ajcmp", "iverctx", "avcc", "ajcfg", "ajcontext", "awconn", "ajconf", "avcmp", "wavtx", "averjac", " avcmd", "afconn", "avetmp", "abcmp", "avcp", "camcmp", "averjp", " avjp", " avconfig", "savcfg", "avcrit", "ajcpu", "wavconf", " avcfg", "ivercpu", "afpkg", "wavcu", "afjac", "devctx", "afcmp", "camctx", " avcu", "ajcp", "wavconfig", "avetx", "avecc", "wavcfg", " avtx", "wavctx", "ivercp", "avertx", "cvcfg", "verjac", "avecpu", "ovtx", "avconf", "avconn", "ajtmp", "afcfg", "camcp", "campkg", "navcu", "avreq"], "s": ["bs", "details", "h", "fs", "rs", "changes", "sb", "n", "sl", "settings", "ops", "ses", "conv", "x", "ies", "S", "os", "als", "views", "c", "sv", "ps", "p", "set", "ess", "r", "es", "ls", "vs", "hs", "ms", "aws", "gs", "rates", "ats", "b", "its", "js", "ports", "ims", "sts", "spec", "w", "g", "services", "j", "sq", "sw", "less", "gets", "t", "self", "ds", "se", "cs", "ts", "sc", "is", "ows", "v", "stats", "ins", "qs", "sync", "scl", "ns", "ss"], "back_size": ["backnesssmall", "backed_mode", "back_length", "backed_small", "back_small", "back64length", "backed_scale", "back_scale", " back_count", " back_space", "back_max", " back_max", "backed_size", "back64size", "backnessscale", "back_Size", "back64Size", "back_time", "back64time", "back_mode", "backnesssize", "backnessmode", " back_length", "back_count", " back_time", "back_space", " back_mode", " back_Size"], "i": ["qi", "h", "ind", "ai", "ii", "ji", "n", "gi", " di", "k", "status", "di", "x", "cli", "sim", "ij", "ip", "c", "u", " bi", "ti", "li", "hi", "q", "I", "ei", " j", " I", "si", "m", "ri", "key", "asi", "b", "multi", "in", "iu", "id", "ni", " ii", "it", "g", "j", "me", "ci", "xi", "ico", "ic", "ki", "t", "phi", "zi", "ix", "mi", "o", "pi", "v", "y", "bi", "ini", "ui", "uri", " ti"], "back_frame": ["front_channel", "back_zone", "backmynext", "backmywindow", "back_image", "backuffyzone", "backuffyframe", "back2window", " back_window", "back____frame", "back____window", "back2zone", "backpyimage", "backableerror", "back____char", "back_word", "back_shot", "back_sample", "back2part", "back____shot", "front_sample", " back_error", "back_channel", "backpyframe", "backablenext", "BACK_frame", "backablewindow", "backableframe", "back_part", " back_shot", "back_error", "backuffyrow", " back_word", "backuffyword", "BACK_part", "backuffywindow", "back____row", "back_row", " back_char", "back____word", "back2frame", "front_image", "BACK_zone", " back_next", "front_frame", "back_window", "backpychannel", "backmyframe", " back_row", "backuffypart", "backmyerror", "backpysample", "BACK_window", "back_next", "back_char"]}}
{"project": "FFmpeg", "commit_id": "01a33b835f7a9e135eb8c7b7dd98c8b89f15dea1", "target": 1, "func": "static void picmemset(PicContext *s, AVFrame *frame, int value, int run,\n\n                      int *x, int *y, int *plane, int bits_per_plane)\n\n{\n\n    uint8_t *d;\n\n    int shift = *plane * bits_per_plane;\n\n    int mask  = ((1 << bits_per_plane) - 1) << shift;\n\n    value   <<= shift;\n\n\n\n    while (run > 0) {\n\n        int j;\n\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n\n            d = frame->data[0] + *y * frame->linesize[0];\n\n            d[*x] |= (value >> j) & mask;\n\n            *x += 1;\n\n            if (*x == s->width) {\n\n                *y -= 1;\n\n                *x = 0;\n\n                if (*y < 0) {\n\n                   *y = s->height - 1;\n\n                   *plane += 1;\n\n                   if (*plane >= s->nb_planes)\n\n                       return;\n\n                   value <<= bits_per_plane;\n\n                   mask  <<= bits_per_plane;\n\n                }\n\n            }\n\n        }\n\n        run--;\n\n    }\n\n}\n", "idx": 14665, "substitutes": {"s": ["fps", "i", "h", "fs", "rs", "n", "sb", "ops", "ses", "sim", "S", "os", "session", "space", "service", "c", "sv", "ps", "conf", "comm", "p", "sys", "r", "es", "m", "ls", "hs", "ms", "gs", "b", "e", "js", "ctx", "sts", "spec", "ims", "sq", "sf", "less", "t", "ds", "span", "se", "cs", "ts", "sc", "is", "v", "f", "ins", "qs", "scope", "ns", "ss"], "frame": ["framework", "context", "view", "render", "type", "image", "point", "Frame", "word", "sequence", "face", "state", "screen", "video", "c", "picture", "set", "ence", "movie", "rame", "scene", "window", "slice", "object", "form", "ce", "cf", "line", "load", "show", "fr", "frames", "iframe", "zone", "t", "stroke", "file", "feature", "ace", "source", "f", "process", "sample", "profile", "one", "ze"], "value": ["view", "version", "image", "time", "map", "memory", "state", "number", "depth", "scale", "weight", "message", "p", "position", "set", "r", "m", "action", "key", "vp", "Value", "name", "expression", "array", "buffer", "distance", "total", "index", "size", "line", "values", "VALUE", "variable", "data", "vector", "ue", "val", "function", "v", "command", "length", "sample", "current", "shift"], "run": ["un", "con", "n", "image", "process", "ride", "ur", "z", "runs", "task", "thread", "error", "draw", "q", "set", "r", "skip", "batch", "pass", "ran", "flow", "name", "Run", "une", "count", "len", "loop", "index", "fun", "job", "record", "line", "range", "load", "num", "lock", "row", "step", "seq", "try", "order", "work", "running", "cmd", "plot", "length", "cycle", "call", "pair"], "x": ["i", "l", "color", "ax", "dx", "n", "image", "z", "point", "tx", "lat", "px", "depth", "q", "p", "position", "client", "m", "height", "xs", "pos", "dim", "xy", "al", "index", "path", "id", "size", "line", "offset", "row", "data", "xi", "ex", "step", "ox", "t", "axis", "X", "ix", "pan", "wx", "v", "yx", "length", "w", "xx", "mask"], "y": ["i", "h", "ey", "ch", "py", "ye", "type", "angle", "entity", "n", "image", "vy", "page", "ty", "z", "ies", "lat", "cy", "iy", "c", "hot", "p", "sys", "sy", "start", "m", "height", "key", "yz", "b", "xy", "my", "size", "ay", "yt", "ya", "row", "rot", "ys", "axy", "gy", "try", "t", "axis", "yy", "o", "Y", "a", "sky", "v", "table", "base", "ny", "iny"], "plane": ["goal", "type", "angle", "lane", "cut", "pe", "side", "panel", "score", "half", "depth", "planes", "cone", "scale", "pen", "p", "pose", "pin", "spin", "plan", "key", "flow", "port", "dim", "mate", "slice", "mode", "id", "cube", "line", "limit", "layout", "offset", "board", "gate", "ane", "zone", "piece", "flat", "stroke", "late", "axis", "se", "plot", "scope", "mask", "profile", "shift"], "bits_per_plane": ["bits_per_depth", "bits_PER_plan", "bits_PER_lane", "bits_per___plan", "bits_per67sequence", "bits_PER_panel", "bits_PER_factor", "bits_PER_plate", "bits_per67planes", "bits_PER_depth", "bits_per_plate", "bits_per_plan", "bits_per_panel", "bits_per67plate", "bits_per_lane", "bits_per_planes", "bits_per___planes", "bits_per_sequence", "bits_PER_planes", "bits_PER_plane", "bits_per___depth", "bits_per67plane", "bits_PER_sequence", "bits_PER_frame", "bits_per_factor", "bits_per_frame", "bits_per___plane"], "d": ["i", "h", "l", "dm", "dict", "n", "dt", "z", "di", "dc", "c", "q", "u", "dh", "p", "bd", "r", "m", "dr", "dim", "b", "db", "dd", "fd", "D", "g", "ad", "data", "t", "ds", "o", "v", "f", "w", "dat", "da"], "j": ["i", "ind", "jp", "l", "ch", "ji", "aj", "n", "k", "z", "json", "bj", "out", "ij", "jo", "q", "p", "jj", "jump", "r", "m", "oj", "b", "ja", "js", "g", "job", "it", "at", "uj", "fr", "dj", "ju", "kj", "el", "other", "J", "t", " jump", "jc", "o", "v", "_", "obj", "jl", "jit", "shift"]}}
{"project": "FFmpeg", "commit_id": "f61d44b74aaae1d306d8a0d38b7b3d4292c89ced", "target": 0, "func": "static inline void silk_stabilize_lsf(int16_t nlsf[16], int order, const uint16_t min_delta[17])\n\n{\n\n    int pass, i;\n\n    for (pass = 0; pass < 20; pass++) {\n\n        int k, min_diff = 0;\n\n        for (i = 0; i < order+1; i++) {\n\n            int low  = i != 0     ? nlsf[i-1] : 0;\n\n            int high = i != order ? nlsf[i]   : 32768;\n\n            int diff = (high - low) - (min_delta[i]);\n\n\n\n            if (diff < min_diff) {\n\n                min_diff = diff;\n\n                k = i;\n\n\n\n                if (pass == 20)\n\n                    break;\n\n            }\n\n        }\n\n        if (min_diff == 0) /* no issues; stabilized */\n\n            return;\n\n\n\n        /* wiggle one or two LSFs */\n\n        if (k == 0) {\n\n            /* repel away from lower bound */\n\n            nlsf[0] = min_delta[0];\n\n        } else if (k == order) {\n\n            /* repel away from higher bound */\n\n            nlsf[order-1] = 32768 - min_delta[order];\n\n        } else {\n\n            /* repel away from current position */\n\n            int min_center = 0, max_center = 32768, center_val;\n\n\n\n            /* lower extent */\n\n            for (i = 0; i < k; i++)\n\n                min_center += min_delta[i];\n\n            min_center += min_delta[k] >> 1;\n\n\n\n            /* upper extent */\n\n            for (i = order; i > k; i--)\n\n                max_center -= min_delta[k];\n\n            max_center -= min_delta[k] >> 1;\n\n\n\n            /* move apart */\n\n            center_val = nlsf[k - 1] + nlsf[k];\n\n            center_val = (center_val >> 1) + (center_val & 1); // rounded divide by 2\n\n            center_val = FFMIN(max_center, FFMAX(min_center, center_val));\n\n\n\n            nlsf[k - 1] = center_val - (min_delta[k] >> 1);\n\n            nlsf[k]     = nlsf[k - 1] + min_delta[k];\n\n        }\n\n    }\n\n\n\n    /* resort to the fall-back method, the standard method for LSF stabilization */\n\n\n\n    /* sort; as the LSFs should be nearly sorted, use insertion sort */\n\n    for (i = 1; i < order; i++) {\n\n        int j, value = nlsf[i];\n\n        for (j = i - 1; j >= 0 && nlsf[j] > value; j--)\n\n            nlsf[j + 1] = nlsf[j];\n\n        nlsf[j + 1] = value;\n\n    }\n\n\n\n    /* push forwards to increase distance */\n\n    if (nlsf[0] < min_delta[0])\n\n        nlsf[0] = min_delta[0];\n\n    for (i = 1; i < order; i++)\n\n        if (nlsf[i] < nlsf[i - 1] + min_delta[i])\n\n            nlsf[i] = nlsf[i - 1] + min_delta[i];\n\n\n\n    /* push backwards to increase distance */\n\n    if (nlsf[order-1] > 32768 - min_delta[order])\n\n        nlsf[order-1] = 32768 - min_delta[order];\n\n    for (i = order-2; i >= 0; i--)\n\n        if (nlsf[i] > nlsf[i + 1] - min_delta[i+1])\n\n            nlsf[i] = nlsf[i + 1] - min_delta[i+1];\n\n\n\n    return;\n\n}\n", "idx": 14673, "substitutes": {"nlsf": ["nailsfac", "ncsf", "nslsf", "ncsfe", "nliscf", "npilssf", "nilssf", "norlsfd", "currentlesfi", " ncsfe", "nnsf", "nLSfl", " nlsfe", "nLSv", "nlesfi", "nelsb", "ynlasv", "dnlsf", " nLSfo", "nolsf", "nlsfc", "nlasd", "nlasif", "nameslsfr", "nselsv", "nelsf", "nlinesfo", "anlsf", "nlsfm", "nlisf", "nLSif", "dnlsfo", "namesstssf", "nlesif", "nLSfi", "currentlsfi", "nipssf", "nqsfo", "nlinesfe", "nlasfi", "dnslfo", "nlasf", "nipsf", "anlcb", "norlesfd", "ncsfo", "nLSfd", "nailsfo", "nailsfe", "nlsfac", "nolscf", "nlsb", "ynlsf", "nlesfac", "nLSsf", "nailsv", "nLSfc", "nlsif", "nplsf", " nLSsf", "ncsv", "nlasfr", "nameslsf", "nailsf", " nlsfac", "nLSfo", "nselsfc", "nameslssf", "nlasfs", "nelsfm", " nlssf", "nqsv", " ncsf", "nselsb", "nameslsd", " nlsfl", "nilsv", "nelsfs", "onlsfo", "ynlsfi", "ncssf", "currentlesfd", "nilsf", "anlcfm", "nolsfo", "ncscf", "nstsfr", "namesstsd", "anlcfs", " ncscf", "nlsd", "nlisfo", "ncsfi", "nstssf", "nlisfac", " nLSb", "norlsf", "onlisf", "currentlsfo", "llselsfc", "nilsfe", "nnsb", "nlsfr", "norlesf", "llselsb", "ncsfm", "ncssfe", "ncssfo", "nlesf", "nipsfr", "ynlsfs", "nlsfl", "nplsfe", "ynlasf", "dnlssf", "nselsfo", "nLSfac", "currentlesfo", " ncsfo", "norlsif", "nnssf", "currentlsfd", "lllsb", "nldfac", "onlsfac", " nLSfd", "dnslb", "nlesv", "ynlasfi", "llselsv", "lllsfc", " nLSv", "nldfo", "nolsfac", "dnlsb", "nselsfi", "nlsfs", "nqsfl", "nolsv", "nnsfo", "nlsfi", "nistsfi", "nLSfs", "nlasv", " nLSf", "dnslsf", "anlsfm", "ynlasfs", "nplssf", "nlesfo", " nlsb", "currentlsf", "nlasfd", "namesstsfr", "ncsfl", " nlsfo", "nlcb", "nlsfe", "nlssf", "nqsf", " nLSfe", "onlisfo", "nlesfd", "lllsf", "nslf", "nailsfd", "ngsf", "nslfo", "nldcf", "npilsf", "ngsfo", "nselsf", "ncsfs", "nwsv", "nistsfs", "anlcf", "llselsf", "nlsfo", "lllsv", "nwsf", "namesstsf", "ncsfd", "nolsfd", "nailssf", "nwsfd", "nlsfd", "nstsd", "nistsv", "nselsfd", " nlsv", "nwsfe", "onliscf", "nlinesf", "norlesif", "anlsfs", "nlscf", "npilsfe", "ncsfc", "nLSf", "npilsv", "nLSb", "nldf", "nplsv", "norlsv", "ynlsv", " nlsfd", "nolsfe", "nLSfe", "nlcf", "nlsv", "nistsf", " ncsv", " nlscf", "onlisfac", "nlcfm", "nipsd", "onlscf", "onlsf", "ngsb", " ncsfl", "nlassf", "ngssf", "nlinescf", "ncsb", "currentlesf", "nslb", " nLSfac", "norlesv", "anlsb", "dnslf", "nstsf", "ncsscf", "nlcfs"], "order": ["before", "rank", "ord", "type", "end", "address", "n", "Order", "page", "level", "radius", "score", "here", "off", "error", "sequence", "random", "ator", "depth", "number", "ORD", "q", "scale", "er", "grade", "p", "position", "r", "err", "zero", "empty", "key", "m", "ser", "ordered", "code", "e", "chain", "count", "iter", "block", "over", "sk", "index", "mode", "der", "dir", "size", "seed", "record", "id", "after", "offset", "num", "row", "orders", "ice", "max", "ordering", "ter", "sort", "o", "master", "v", "length", "cycle", "edge"], "min_delta": ["min_dtelta", "min2dency", "min_lition", "min_tota", "min2dition", "min_DDelta", "min_cdelt", "min_drection", "min_dtency", "min__delta", "min_idota", "minolydelta", "min_mandition", "min_lency", "min_telta", "min_dDelta", "min_dchange", "min_mval", "min_dictency", "min64dictelta", "min_dota", "min_miff", "min_pelta", "min_idelta", "min_siff", "min64dictota", "min_mta", "min_cant", "min_dynamic", "min_Delta", "min2dota", "min__dota", "min_dimency", "min_felt", "min_idant", "min64dictler", "min2lition", "min_dval", "min_dtota", "min_mota", "minolydimency", "min_develta", "min_ddrection", "min_cdency", "min_sdelta", "min_cition", "min_miffs", "min64dictivot", "min_mandota", "min_cdelta", "minolydants", "min_datata", "min_dimelta", "min_mandency", "min_Dota", "min_fels", "min_cota", "minolydimants", "min_dimchange", "min_dler", "min_dictants", "min_Dler", "min64delta", "min_delt", "min_lta", "min_telt", "min_cdval", "min_devivot", "minolydchange", "min_pelt", "min__rition", "min_diff", "min_tynamic", "min_sdency", "min_mandelta", "min__rota", "min2lency", "min_lota", "min2delta", "minolydimelta", "min_tDelta", "min_lelta", "min_melt", "min_tler", "min_rant", "min_dition", "min_felta", "min_dta", "min__dant", "min_sdchange", "min64divot", "min_dataota", "min_melta", "min_dency", "minolydency", "min_selta", "min_diffs", "min_dictota", "min_Delt", "min_selt", "min_Diff", "min_dictivot", "min__dition", "min__relta", "min2lelta", "min_mency", "min_rition", "min_dictler", "min_dtition", "min64dler", "min_dants", "min_divot", "min_ddynamic", "min_dataelta", "min_dtval", "min_sdants", "minolydimchange", "min_dictchange", "min_dtelt", "min_tivot", "min_dictDelta", "min_devler", "min_siffs", "min64dota", "min_dels", "min_trection", "min__rant", "min_ddelt", "min_rota", "min_Diffs", "min_dimants", "min_dant", "min2lota", "min_dictelta", "min_lelt", "min_dataelt", "min_celta", "min_relta", "min_idition", "min_devota", "min_ddelta", "min_pels"], "pass": ["fast", "jp", "prop", "stop", "level", "miss", "status", "task", "feed", "run", "hop", "col", "PASS", "ask", "pas", "p", "check", "def", "skip", "scan", "r", "through", "key", "batch", "add", "push", "port", "read", "strip", "chain", "pg", "window", "Pass", "commit", "gain", "loop", "loss", "ack", "mode", "id", "op", "g", "sw", "lock", "row", "stage", "step", "try", "fail", "test", "acc", "mix", "sc", "by", "ass", "process", "w", "post", "ride"], "i": ["status", "cli", "this", "oi", "g", "it", "ci", "ie", "ki", "zi", "mi", "y", "info", "ii", "ji", "ij", "init", "iy", "hi", "m", "ri", "name", "ia", "multi", "to", "iii", "xi", "try", "ik", "t", "ix", "is", "print", "by", "f", "ui", "ini", "qi", "ind", "l", "ai", "di", "x", "value", "ti", "li", "\u0438", "I", "si", "batch", "ori", "im", "in", "ims", "index", "item", "phi", "o", "iri", "pi", "bi", "io", "gi", "progress", "kit", "point", "sim", "go", "ip", "ei", "p", "s", " I", "list", "port", "e", "chain", "ami", "iter", "slice", "iu", "id", "me", "ic", "v", "PI"], "k": ["kind", "rank", "level", "kw", "type", "n", "kn", "ku", "ko", "ks", "ck", "isk", "radius", "kit", "tk", "go", "x", "wk", "kg", "ikk", "c", "q", "ask", "er", "p", "s", "r", "dk", "m", "key", "kk", "mk", "kar", "kh", "chain", "kick", "block", "sk", "ack", "ijk", "ok", "spec", "g", "it", "uk", "row", "max", "ka", "kj", " K", "ke", "km", "ik", "ak", "ek", "ki", "work", "kid", "o", "K", "kr", "f", "v", "kan", "length", "y"], "center_val": ["center7col", "center___pl", "pixel_val", "max_val", "pixel_bal", " center_lev", "area_el", "center_bal", "center_sel", "max_VAL", "escape_val", "center_valid", "center_value", "area_info", " center_value", " center_vals", "escape_doc", "center_doc", "center_el", "centerfulval", "center2val", "enter_val", "center_err", "centerableval", "centerfulinfo", "areafulpl", "max_value", "escape_sel", "center_vec", "area_val", "centerabledoc", "center7val", "areafulval", "area_pl", " center_obj", "enter_value", "areafulinfo", "center7VAL", "center_pl", "centerablemod", "centerfulel", "escape_mod", " center_valid", "pixel_err", "center_info", "center_obj", "center___el", "center___val", "center7value", " center_vec", "center_lev", "center2vals", "areafulel", "center_mod", "enter_col", "center_col", "enter_VAL", "center_VAL", "center___info", "centerablesel", "centerfulpl", "center_vals", "center2lev"], "j": ["bs", "ind", "jp", "l", "ji", "aj", "n", "z", "json", "br", "bj", "x", "ij", "value", "jo", "q", "jj", "jump", "jac", "oj", "key", " J", "bo", "b", "ja", "js", "job", "g", "it", "uj", "item", "fr", "dj", "max", "jas", "kj", "try", "J", "jc", "pr", "y", "v", "bi", "obj", "jl", "jit"]}}
{"project": "qemu", "commit_id": "2e29bd04786003561303dcad940b38afe790fb9b", "target": 1, "func": "static void pci_unin_main_config_writel (void *opaque, target_phys_addr_t addr,\n\n                                         uint32_t val)\n\n{\n\n    UNINState *s = opaque;\n\n\n\n    UNIN_DPRINTF(\"config_writel addr \" TARGET_FMT_plx \" val %x\\n\", addr, val);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n\n\n    s->config_reg = val;\n\n}\n", "idx": 14679, "substitutes": {"opaque": [" opaco", " opatile", "opsaque", "obaque", " opace", "obatile", " Opca", "opace", "opsatile", "opca", "obque", " Opaque", "opsace", "iopient", " Opient", " opca", "opsque", "iopaco", "opque", "iopaque", " opient", "iopca", "opatile", " Opaco", " opque", "opaco", "opient", "obace"], "addr": ["ord", "rs", "address", "ag", "Address", "alloc", "tx", "x", "src", "hw", "adr", "loc", "err", "add", "ptr", "tr", "dr", "now", "pos", "mem", "alt", "ctx", "eth", "index", "id", "at", "ad", "offset", " address", "coord", "attr", "rol", "work", "align", "pad", "cmd", "ace", "ac", "var", "obj"], "val": [" value", "cal", " Val", "Val", "ref", "eval", "sol", "serv", "pol", "sl", "bl", "z", "txt", "tx", "x", "out", "value", "slot", "buf", "reg", "sv", "sel", "p", "VAL", " eval", "ival", "valid", "Value", "AL", "pos", "alt", "b", "mem", "len", "al", " v", "vt", " arg", "ctx", "ret", "index", "bal", "it", "vals", "res", "bit", "num", "data", "bool", "seq", "arg", "rol", "test", "il", "vol", "oval", "pt", "pr", "resp", "all", "v", "stat", "var"], "s": ["bs", "i", "h", "fs", "rs", "n", "sb", "settings", "ops", "ses", "flags", "checks", "S", "os", "state", "c", "sv", "ps", "p", "r", "m", "hs", "gs", "b", "e", "sts", "w", "j", "sq", "sets", "t", "ds", "ts", "o", "a", "v", "stats", "qs", "ns", "ss"]}}
{"project": "qemu", "commit_id": "523b018dde3b7650fe5401d0499b30cf2f117515", "target": 1, "func": "vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *vmsg)\n{\n    struct vhost_vring_addr *vra = &vmsg->payload.addr;\n    unsigned int index = vra->index;\n    VubrVirtq *vq = &dev->vq[index];\n    DPRINT(\"vhost_vring_addr:\\n\");\n    DPRINT(\"    index:  %d\\n\", vra->index);\n    DPRINT(\"    flags:  %d\\n\", vra->flags);\n    DPRINT(\"    desc_user_addr:   0x%016llx\\n\", vra->desc_user_addr);\n    DPRINT(\"    used_user_addr:   0x%016llx\\n\", vra->used_user_addr);\n    DPRINT(\"    avail_user_addr:  0x%016llx\\n\", vra->avail_user_addr);\n    DPRINT(\"    log_guest_addr:   0x%016llx\\n\", vra->log_guest_addr);\n    vq->desc = (struct vring_desc *)(uintptr_t)qva_to_va(dev, vra->desc_user_addr);\n    vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr);\n    vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr);\n    vq->log_guest_addr = vra->log_guest_addr;\n    DPRINT(\"Setting virtq addresses:\\n\");\n    DPRINT(\"    vring_desc  at %p\\n\", vq->desc);\n    DPRINT(\"    vring_used  at %p\\n\", vq->used);\n    DPRINT(\"    vring_avail at %p\\n\", vq->avail);\n    vq->last_used_index = vq->used->idx;\n    return 0;", "idx": 14680, "substitutes": {"vra": ["vras", "vararma", "vara", "varrum", "vrou", "nvrum", "vtra", "verum", "vicra", " vrap", "evrum", "ivrum", "servraf", "varrap", "jraf", "veara", "vera", "evras", "krum", "fro", "vrum", "formtra", "formara", "varrar", "verri", " vrum", "evra", "invrum", "formrum", "graf", "viara", "gra", "servara", "vrar", "yara", "vrera", "ivra", "yero", "grar", "nvra", "vro", "virum", "invra", "ivrera", "varrou", " vtra", "verrum", "krar", "varara", "evraf", " vraf", "jran", " varma", "vicRA", "nvrar", " vran", "ftra", "varra", "vrap", "varran", "frou", "fra", "vri", "vira", "gero", "formra", "valara", "varma", "jra", "verara", "invara", "invras", "valro", "valtra", "vraf", "gras", "gara", "nvara", "verrar", "fraf", "frum", "servra", "verraf", "ivRA", "vertra", " vRA", "vicrera", "yrar", "kara", "evara", "invran", "gri", "fran", "servri", "invraf", "viraf", "vran", "yra", "valra", "vRA", " vro", " vara", "varero", "vicrum", " vrera", "verou", "verap", "verra", "fara", "vero", "kra", "farma", "jrum"], "vq": ["vqa", " vp", "convkg", "vqs", "Vqq", "vcf", "veq", "convqa", "vvcf", "volq", "viq", "liq", "convp", "varque", "varqi", "versionqu", " vkg", "lqa", "tvqa", "vocf", "varqq", "voiz", "vqueue", "requql", "vue", "invqueue", "uvqi", "vodq", "veqi", "voq", "versionquant", "vviz", " vqa", " vqu", "conviq", "vquery", "convqq", "Vq", "varqu", "tvp", " vql", "vp", "vequ", "Vqs", "varqueue", "viewqq", "invqq", "volog", "volqi", "lqq", "varql", "viewq", "vquant", "vvdq", "versioniq", "invq", "vf", "wq", "vqq", " vqq", "wqu", "tvq", "varqs", " vquant", "reququ", "vdq", "versionq", "varog", "svqu", "svqa", "convq", "vmq", "voque", "invquery", "vqi", "variz", "vog", "vecf", "invql", "viz", "svque", "svqs", "uvog", "vvq", "veque", "tvkg", "vql", "vque", "vvqi", "vmiq", "voqi", "vmqu", "svq", " viq", " vqueue", "vmquant", "uvf", "vkg", "varq", "varue", "Vqueue", "inviz", "vqu", " vue", "wque", "requue", "requq", "viewqueue", "viewql", "varquery", "veqa", "uvq", " viz", "vedq", "svqq", "vvque", "volf", "varf", "lq", "svqueue", " vquery", "wqa"]}}
{"project": "FFmpeg", "commit_id": "e7843db3df0224cafcc1af9da103a3a7286ae2ba", "target": 1, "func": "void ff_get_unscaled_swscale(SwsContext *c)\n\n{\n\n    const enum PixelFormat srcFormat = c->srcFormat;\n\n    const enum PixelFormat dstFormat = c->dstFormat;\n\n    const int flags = c->flags;\n\n    const int dstH = c->dstH;\n\n    int needsDither;\n\n\n\n    needsDither = isAnyRGB(dstFormat) &&\n\n            c->dstFormatBpp < 24 &&\n\n           (c->dstFormatBpp < c->srcFormatBpp || (!isAnyRGB(srcFormat)));\n\n\n\n    /* yv12_to_nv12 */\n\n    if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) &&\n\n        (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21)) {\n\n        c->swScale = planarToNv12Wrapper;\n\n    }\n\n    /* yuv2bgr */\n\n    if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUV422P ||\n\n         srcFormat == PIX_FMT_YUVA420P) && isAnyRGB(dstFormat) &&\n\n        !(flags & SWS_ACCURATE_RND) && !(dstH & 1)) {\n\n        c->swScale = ff_yuv2rgb_get_func_ptr(c);\n\n    }\n\n\n\n    if (srcFormat == PIX_FMT_YUV410P &&\n\n        (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P) &&\n\n        !(flags & SWS_BITEXACT)) {\n\n        c->swScale = yvu9ToYv12Wrapper;\n\n    }\n\n\n\n    /* bgr24toYV12 */\n\n    if (srcFormat == PIX_FMT_BGR24 &&\n\n        (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P) &&\n\n        !(flags & SWS_ACCURATE_RND))\n\n        c->swScale = bgr24ToYv12Wrapper;\n\n\n\n    /* RGB/BGR -> RGB/BGR (no dither needed forms) */\n\n    if (   isAnyRGB(srcFormat)\n\n        && isAnyRGB(dstFormat)\n\n        && srcFormat != PIX_FMT_BGR8      && dstFormat != PIX_FMT_BGR8\n\n        && srcFormat != PIX_FMT_RGB8      && dstFormat != PIX_FMT_RGB8\n\n        && srcFormat != PIX_FMT_BGR4      && dstFormat != PIX_FMT_BGR4\n\n        && srcFormat != PIX_FMT_RGB4      && dstFormat != PIX_FMT_RGB4\n\n        && srcFormat != PIX_FMT_BGR4_BYTE && dstFormat != PIX_FMT_BGR4_BYTE\n\n        && srcFormat != PIX_FMT_RGB4_BYTE && dstFormat != PIX_FMT_RGB4_BYTE\n\n        && srcFormat != PIX_FMT_MONOBLACK && dstFormat != PIX_FMT_MONOBLACK\n\n        && srcFormat != PIX_FMT_MONOWHITE && dstFormat != PIX_FMT_MONOWHITE\n\n        && srcFormat != PIX_FMT_RGB48LE   && dstFormat != PIX_FMT_RGB48LE\n\n        && srcFormat != PIX_FMT_RGB48BE   && dstFormat != PIX_FMT_RGB48BE\n\n        && srcFormat != PIX_FMT_BGR48LE   && dstFormat != PIX_FMT_BGR48LE\n\n        && srcFormat != PIX_FMT_BGR48BE   && dstFormat != PIX_FMT_BGR48BE\n\n        && (!needsDither || (c->flags&(SWS_FAST_BILINEAR|SWS_POINT))))\n\n        c->swScale= rgbToRgbWrapper;\n\n\n\n    /* bswap 16 bits per pixel/component packed formats */\n\n    if (IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR444) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR48)  ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR555) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR565) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_GRAY16) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB444) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB48)  ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB555) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB565))\n\n        c->swScale = packed_16bpc_bswap;\n\n\n\n    if ((usePal(srcFormat) && (\n\n        dstFormat == PIX_FMT_RGB32   ||\n\n        dstFormat == PIX_FMT_RGB32_1 ||\n\n        dstFormat == PIX_FMT_RGB24   ||\n\n        dstFormat == PIX_FMT_BGR32   ||\n\n        dstFormat == PIX_FMT_BGR32_1 ||\n\n        dstFormat == PIX_FMT_BGR24)))\n\n        c->swScale = palToRgbWrapper;\n\n\n\n    if (srcFormat == PIX_FMT_YUV422P) {\n\n        if (dstFormat == PIX_FMT_YUYV422)\n\n            c->swScale = yuv422pToYuy2Wrapper;\n\n        else if (dstFormat == PIX_FMT_UYVY422)\n\n            c->swScale = yuv422pToUyvyWrapper;\n\n    }\n\n\n\n    /* LQ converters if -sws 0 or -sws 4*/\n\n    if (c->flags&(SWS_FAST_BILINEAR|SWS_POINT)) {\n\n        /* yv12_to_yuy2 */\n\n        if (srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) {\n\n            if (dstFormat == PIX_FMT_YUYV422)\n\n                c->swScale = planarToYuy2Wrapper;\n\n            else if (dstFormat == PIX_FMT_UYVY422)\n\n                c->swScale = planarToUyvyWrapper;\n\n        }\n\n    }\n\n    if (srcFormat == PIX_FMT_YUYV422 &&\n\n       (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P))\n\n        c->swScale = yuyvToYuv420Wrapper;\n\n    if (srcFormat == PIX_FMT_UYVY422 &&\n\n       (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P))\n\n        c->swScale = uyvyToYuv420Wrapper;\n\n    if (srcFormat == PIX_FMT_YUYV422 && dstFormat == PIX_FMT_YUV422P)\n\n        c->swScale = yuyvToYuv422Wrapper;\n\n    if (srcFormat == PIX_FMT_UYVY422 && dstFormat == PIX_FMT_YUV422P)\n\n        c->swScale = uyvyToYuv422Wrapper;\n\n\n\n    /* simple copy */\n\n    if ( srcFormat == dstFormat ||\n\n        (srcFormat == PIX_FMT_YUVA420P && dstFormat == PIX_FMT_YUV420P) ||\n\n        (srcFormat == PIX_FMT_YUV420P && dstFormat == PIX_FMT_YUVA420P) ||\n\n        (isPlanarYUV(srcFormat) && isGray(dstFormat)) ||\n\n        (isPlanarYUV(dstFormat) && isGray(srcFormat)) ||\n\n        (isGray(dstFormat) && isGray(srcFormat)) ||\n\n        (isPlanarYUV(srcFormat) && isPlanarYUV(dstFormat) &&\n\n         c->chrDstHSubSample == c->chrSrcHSubSample &&\n\n         c->chrDstVSubSample == c->chrSrcVSubSample &&\n\n         dstFormat != PIX_FMT_NV12 && dstFormat != PIX_FMT_NV21 &&\n\n         srcFormat != PIX_FMT_NV12 && srcFormat != PIX_FMT_NV21))\n\n    {\n\n        if (isPacked(c->srcFormat))\n\n            c->swScale = packedCopyWrapper;\n\n        else /* Planar YUV or gray */\n\n            c->swScale = planarCopyWrapper;\n\n    }\n\n\n\n    if (ARCH_BFIN)\n\n        ff_bfin_get_unscaled_swscale(c);\n\n    if (HAVE_ALTIVEC)\n\n        ff_swscale_get_unscaled_altivec(c);\n\n}\n", "idx": 14694, "substitutes": {"c": ["abc", "vc", "cache", "l", "con", "n", "pc", "bc", "z", "lc", "conv", "dc", "etc", "cmp", "cm", "xc", "cp", "cu", "conf", "cn", "this", "p", "mc", "set", "err", "s", "cam", "C", "b", "tc", "e", "cc", "rc", "com", "ctx", "gc", "cv", "ce", "cont", "g", "cf", "coll", "ci", "cl", "ct", "anc", "enc", "ic", "ec", "t", "self", "ca", "cs", "fc", "sc", "config", "nc", "ac", "cr", "v", "f", "w", "can", "call", "co"], "needsDither": ["needsDsurry", "needsDsot", "needsDoot", "needsDoithering", "needsDsithering", "needsDithering", " needsDoithering", "needsduth", "needsdith", " needsDoither", "needsDsither", "needsDoith", "needsDecither", "requiresDoither", "needsdot", "needsDith", " needsDurry", " needsDourry", "needsDourry", "needsdither", "needsDurry", "needsDecuth", "needsDot", "needsDecot", "needsdurry", "needsDecith", " needsDoot", "requiresDoith", "requiresDith", "needsdithering", "requiresDouth", "requiresDot", "needsDouth", "requiresDither", " needsDot", "requiresDuth", "needsDoither", " needsDithering", "requiresDoot", "needsDuth"]}}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br)\n\n{\n\n    PCIDevice *pd = PCI_DEVICE(br);\n\n    PCIBus *parent = pd->bus;\n\n    PCIBridgeWindows *w = g_new(PCIBridgeWindows, 1);\n\n    uint16_t cmd = pci_get_word(pd->config + PCI_COMMAND);\n\n\n\n    pci_bridge_init_alias(br, &w->alias_pref_mem,\n\n                          PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                          \"pci_bridge_pref_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &w->alias_mem,\n\n                          PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                          \"pci_bridge_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &w->alias_io,\n\n                          PCI_BASE_ADDRESS_SPACE_IO,\n\n                          \"pci_bridge_io\",\n\n                          &br->address_space_io,\n\n                          parent->address_space_io,\n\n                          cmd & PCI_COMMAND_IO);\n\n\n\n    pci_bridge_init_vga_aliases(br, parent, w->alias_vga);\n\n\n\n    return w;\n\n}\n", "idx": 14716, "substitutes": {"br": ["bs", "rel", "jp", "bl", "art", "bt", "bc", "ck", "dp", "ber", "rb", "ij", "nah", "prot", "reg", "buf", "bro", "browser", "bh", "bridge", "bn", "pas", "pl", "p", "bd", "tree", "r", "arr", "adr", "batch", "hr", "gp", "dr", "tr", "band", "bo", "ren", "tw", "b", "rem", "wr", "db", "bolt", "block", "ctx", "BR", "sp", "bal", "it", "sw", "Br", "fr", "bart", "mr", "ctr", "bp", "vr", "gr", "pr", "pt", "spr", "ba", "kr", "bor", "cr", "bg", "lr", "bm", "pm", "bre"], "pd": ["dn", "dl", "d", "hd", "lp", "dt", "pc", "dp", "np", "pid", "cp", "ps", "dh", "PD", "bd", "p", "wp", "pb", "dr", "md", "tp", "xd", "dd", "sd", "ud", "dq", "pat", "ped", "po", "ds", "bp", "pt", "pr", "phy", "cmd", "pp", "pi", "wd", "cd", "vd", "td", "pm"], "parent": ["event", "shape", "h", "ch", "l", "child", "n", "k", "mother", "peer", "local", "pa", "pool", "out", "pid", "global", "ps", "root", "tree", "p", "def", "r", "parents", "ma", "m", "client", "pro", "origin", "associated", "port", "Parent", "writer", "holder", "rule", "remote", "sp", "unit", "spec", "per", "g", "manager", "public", "mt", "t", "test", "file", "snap", "pt", "pr", "part", "gr", "master", "man", "foreign", "by", "fat", "form", "owner", "params"], "w": ["h", "wl", "i", "d", "kw", "n", "ow", "nw", "win", "wal", "word", "x", "wi", "wk", "hw", "wat", "p", "wp", "r", "wm", "ww", "tw", "writer", "b", "wr", "window", "W", "rh", "wa", "g", "wt", "ew", "sw", "wine", "wo", "wn", "iw", "we", "fw", "aw", "rw", "wx", "a", "man", "wcs", "v", "y", "wh", "wb", "wd"]}}
{"project": "FFmpeg", "commit_id": "e22ebd04bcab7f86548794556c28ecca46d9c2ac", "target": 0, "func": "static void hls_transform_tree(HEVCContext *s, int x0, int y0,\n\n                               int xBase, int yBase, int cb_xBase, int cb_yBase,\n\n                               int log2_cb_size, int log2_trafo_size,\n\n                               int trafo_depth, int blk_idx)\n\n{\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n    uint8_t split_transform_flag;\n\n\n\n    if (trafo_depth > 0 && log2_trafo_size == 2) {\n\n        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase);\n\n        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase);\n\n    } else {\n\n        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) = 0;\n\n    }\n\n\n\n    if (lc->cu.intra_split_flag) {\n\n        if (trafo_depth == 1)\n\n            lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[blk_idx];\n\n    } else {\n\n        lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[0];\n\n    }\n\n\n\n    lc->tt.cbf_luma = 1;\n\n\n\n    lc->tt.inter_split_flag = s->sps->max_transform_hierarchy_depth_inter == 0 &&\n\n                              lc->cu.pred_mode == MODE_INTER &&\n\n                              lc->cu.part_mode != PART_2Nx2N &&\n\n                              trafo_depth == 0;\n\n\n\n    if (log2_trafo_size <= s->sps->log2_max_trafo_size &&\n\n        log2_trafo_size >  s->sps->log2_min_tb_size    &&\n\n        trafo_depth     < lc->cu.max_trafo_depth       &&\n\n        !(lc->cu.intra_split_flag && trafo_depth == 0)) {\n\n        split_transform_flag = ff_hevc_split_transform_flag_decode(s, log2_trafo_size);\n\n    } else {\n\n        split_transform_flag = log2_trafo_size > s->sps->log2_max_trafo_size ||\n\n                               (lc->cu.intra_split_flag && trafo_depth == 0) ||\n\n                               lc->tt.inter_split_flag;\n\n    }\n\n\n\n    if (log2_trafo_size > 2) {\n\n        if (trafo_depth == 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase)) {\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n                ff_hevc_cbf_cb_cr_decode(s, trafo_depth);\n\n        }\n\n\n\n        if (trafo_depth == 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase)) {\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =\n\n                ff_hevc_cbf_cb_cr_decode(s, trafo_depth);\n\n        }\n\n    }\n\n\n\n    if (split_transform_flag) {\n\n        int x1 = x0 + ((1 << log2_trafo_size) >> 1);\n\n        int y1 = y0 + ((1 << log2_trafo_size) >> 1);\n\n\n\n        hls_transform_tree(s, x0, y0, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 0);\n\n        hls_transform_tree(s, x1, y0, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 1);\n\n        hls_transform_tree(s, x0, y1, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 2);\n\n        hls_transform_tree(s, x1, y1, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 3);\n\n    } else {\n\n        int min_tu_size      = 1 << s->sps->log2_min_tb_size;\n\n        int log2_min_tu_size = s->sps->log2_min_tb_size;\n\n        int min_tu_width     = s->sps->min_tb_width;\n\n\n\n        if (lc->cu.pred_mode == MODE_INTRA || trafo_depth != 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) ||\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0)) {\n\n            lc->tt.cbf_luma = ff_hevc_cbf_luma_decode(s, trafo_depth);\n\n        }\n\n\n\n        hls_transform_unit(s, x0, y0, xBase, yBase, cb_xBase, cb_yBase,\n\n                           log2_cb_size, log2_trafo_size, trafo_depth, blk_idx);\n\n\n\n        // TODO: store cbf_luma somewhere else\n\n        if (lc->tt.cbf_luma) {\n\n            int i, j;\n\n            for (i = 0; i < (1 << log2_trafo_size); i += min_tu_size)\n\n                for (j = 0; j < (1 << log2_trafo_size); j += min_tu_size) {\n\n                    int x_tu = (x0 + j) >> log2_min_tu_size;\n\n                    int y_tu = (y0 + i) >> log2_min_tu_size;\n\n                    s->cbf_luma[y_tu * min_tu_width + x_tu] = 1;\n\n                }\n\n        }\n\n        if (!s->sh.disable_deblocking_filter_flag) {\n\n            ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_trafo_size,\n\n                                                  lc->slice_or_tiles_up_boundary,\n\n                                                  lc->slice_or_tiles_left_boundary);\n\n            if (s->pps->transquant_bypass_enable_flag &&\n\n                lc->cu.cu_transquant_bypass_flag)\n\n                set_deblocking_bypass(s, x0, y0, log2_trafo_size);\n\n        }\n\n    }\n\n}\n", "idx": 14723, "substitutes": {"s": ["bs", "h", "fs", "l", "rs", "sg", "sb", "n", "ops", "S", "os", "als", "c", "sv", "ps", "comm", "p", "sys", "m", "ls", "hs", "aws", "gs", "ats", "its", "js", "sa", "ims", "sts", "spec", "g", "sq", "sw", "less", "acs", "t", "ds", "cs", "ts", "o", "a", "south", "v", "qs", "scl", "ns", "ss"], "x0": ["ixma", "exBase", "yZero", "ox1", "x10", " xma", "ex0", "xz", "oxZero", "y1", "ox30", "oxE", "rx0", "rxZero", "time0", "ixE", "xi10", "rxBase", "xZero", "ix0", " xRaw", "xi0", "timeZero", "ox10", "timema", "xiz", "exZero", "x30", " xZero", "xi30", "ix30", "ixZero", "xiRaw", " xRes", "xRaw", "xma", "xiE", "ex1", "rx1", "ox0", " x1", "xE", "oxz", " x10", "xiZero", "xRes", "yRes", "oxRes", "x1", "oxRaw", "ixz"], "y0": ["yy1", "yZero", "skyZero", " y1", "gyChan", "ySource", "axyNo", "yiMac", "skyStr", "y1", "yChan", "ymInfo", "YZero", "nyNo", "yNo", "yRaw", "yy0", "uyChan", "xZero", " yZero", "axy0", "yKey", "eryElement", "yElement", "ryInfo", "xChan", "gy0", "yStr", "axySource", "nyRaw", "nyElement", "ery0", "eryZero", "yInfo", "Y0", "yiKey", "yyBase", "ryMac", "ry0", "ny0", "gyZero", "ymKey", "nySource", "ym0", "ryKey", "axyRaw", "sky0", "yMac", "uy0", "uyStr", "uyRaw", "gyElement", "yi0", "yyZero", "xStr", "Y1", "yiInfo", "uySource", "uyZero", "nyChan", "ymMac", "YBase", "skyChan", "eryChan", "uyNo", "nyZero"], "xBase": ["xFrame", "exBase", "ox1", "oxFrame", "yBottom", "xBas", "y1", "oxBase", "ix0", "xyCheck", " xBas", "exCheck", " xCheck", " xFrame", "oxCheck", " xBottom", "exFrame", " xbase", "ixbase", "xyBas", "xyBase", "ex1", "ix1", "xBottom", "ixCheck", "xCheck", "ixBas", " x1", "ixBase", "x1", "xybase", "ixBottom", "xbase"], "yBase": ["eryChain", " yBound", "cyBest", "iyBound", " yBas", "nyBase", "eyChain", "iyBase", " yRaw", "eyBase", "yRaw", "yy0", "yBound", "yBas", "nyRaw", "eyBest", "yyBas", "cyChain", "iyBas", "iybase", "yBest", "yyBase", "nybase", "cyBasic", "ny0", "cyBase", "nyBas", "yBasic", "yyRaw", "ybase", "eryBasic", " ybase", "eryBase", "eyBasic", "nyBound", "eryBest", "yChain"], "cb_xBase": ["cb_rxbase", "cb_rxFrame", "cb_x0", "cb_ybase", "cb_xbase", "cb_y0", "cb_rxBase", "cb_yFrame", "cb_rx0", "cb_xFrame"], "cb_yBase": ["cb__yBas", "cb_yBas", "cb__YBase", "cb__ybase", "cb_Ybase", "cb__yBase", "cb_rybase", "cb__YFace", "cb_xBas", "cb_ybase", "cb_xbase", "cb_xFace", "cb_yFace", "cb_ryBase", "cb__yFace", "cb_ryFace", "cb_YFace", "cb__YBas", "cb_YBase", "cb_YBas", "cb__Ybase", "cb_ryBas"], "log2_cb_size": ["log2_cb_len", "log2_tc_length", "log2_cb_SIZE", "log2_cb__size", "log2_tc_size", "log2_cb__SIZE", "log2_tc_SIZE", "log2_cb2length", "log2_cb2len", "log2_cb__len", "log2_tc_len", "log2_cb2size", "log2_cb2SIZE", "log2_cb_length", "log2_cb__length"], "log2_trafo_size": ["log2_traphy_depth", "log2_trafo2size", "log2_trafo_Size", "log2_trainfo_size", "log2_traphy_size", "log2_trafo_SIZE", "log2_trainfo_length", "log2_trainfo_Size", "log2_trafo_length", "log2_traphy_Size", "log2_trainfo2Size", "log2_trafo2Size", "log2_trafo_depth", "log2_traphy_mode", "log2_trainfo2size", "log2_trafo2length", "log2_trafo_mode", "log2_trainfo_SIZE", "log2_trainfo2length", "log2_trainfo_name", "log2_trafo_name", "log2_traphy_SIZE"], "trafo_depth": ["trafo_count", "trainfo_rank", "tragoo_total", "tragoo_path", "trafo_level", "trafo2counter", "trafo_result", "trainfo_scale", "tr_", "trainfo_status", "trafo8distance", "trafo0depth", "trafo_status", "trafo8total", "traifest_priority", "trafo_scale", "trafo_dim", "trainfo_pillar", "traphy_path", "traph_deep", "trafo0priority", "trafo_mode", "traph_dim", "trainfo_total", "trainfo_level", "trainfo_depth", "trainfo_deep", "trafo2depth", "trainfo_result", "trafo_path", "trafo_distance", "trafo8deep", "trafo0mode", "tragoo_deep", "traphy_rank", "trainfo_height", "trafo_rank", "traphy_depth", "traph_depth", "trafo2rank", " tra_", "trafo_total", "traphy_count", "trafo0deep", "tri_", "tra_", "trafo_priority", "tragoo_depth", "traifest_deep", "trafo_deep", "traifest_depth", "trafo2deep", "traifest_mode", "trafo2dim", "traphy_deep", "trafo8depth", "trainfo_distance", "trainfo_counter", "traphy_dim", "trafo_pillar", "trafo_counter", "trafo2count", "traph_rank", "trafo_height"], "blk_idx": ["blk_Idy", "blk_idxc", "blk_ridy", "blk2Idb", "blk2Idy", "blk_Idxc", "blk_Idz", "blk_inv", "blk_idy", "blk_ridxc", "blk2Idx", "blk2idx", "blk_ridv", "blk_inx", "blk_Idv", "blk2Idxc", "blk_Idx", "blk_idz", "blk_ridz", "blk2idy", "blk2idxc", "blk_idv", "blk_ridb", "blk_idb", "blk_Idb", "blk_inz", "blk_iny", "blk2idb", "blk_ridx"], "lc": ["LC", "wl", "dl", "vc", "lis", "l", "ell", "lp", "tl", "sol", "pc", "sl", "bc", "unc", "cli", "ctl", "dc", "etc", "ctrl", "cm", "las", "gl", "c", "cp", "cu", "uci", "comm", "lay", "court", "mc", "kl", "disc", "ls", "cell", "cci", "ln", "tc", "lam", "cc", "rc", "WC", "lv", "ctx", "gc", "gru", "lic", "cus", "cf", "lf", "rl", "coll", "acl", "ml", "ci", "cl", "mm", "lu", "func", "layer", "lua", "ll", "scl", "fc", "lib", "cs", "icc"], "split_transform_flag": ["split_transform_status", "split_scale_lock", "split_transform2flag", "split_scale_status", "split_scale_flag", "split_transform2flags", "split_transform2lock", "split_transform_flags", "split_transform2status", "split_scale_flags", "split_transform_lock"]}}
{"project": "FFmpeg", "commit_id": "ba3f07d0611d9a6c10eaa90b3c058ecdffe76676", "target": 1, "func": "static void aw_pulse_set2(WMAVoiceContext *s, GetBitContext *gb,\n\n                          int block_idx, AMRFixed *fcb)\n\n{\n\n    uint16_t use_mask_mem[9]; // only 5 are used, rest is padding\n\n    uint16_t *use_mask = use_mask_mem + 2;\n\n    /* in this function, idx is the index in the 80-bit (+ padding) use_mask\n\n     * bit-array. Since use_mask consists of 16-bit values, the lower 4 bits\n\n     * of idx are the position of the bit within a particular item in the\n\n     * array (0 being the most significant bit, and 15 being the least\n\n     * significant bit), and the remainder (>> 4) is the index in the\n\n     * use_mask[]-array. This is faster and uses less memory than using a\n\n     * 80-byte/80-int array. */\n\n    int pulse_off = s->aw_first_pulse_off[block_idx],\n\n        pulse_start, n, idx, range, aidx, start_off = 0;\n\n\n\n    /* set offset of first pulse to within this block */\n\n    if (s->aw_n_pulses[block_idx] > 0)\n\n        while (pulse_off + s->aw_pulse_range < 1)\n\n            pulse_off += fcb->pitch_lag;\n\n\n\n    /* find range per pulse */\n\n    if (s->aw_n_pulses[0] > 0) {\n\n        if (block_idx == 0) {\n\n            range = 32;\n\n        } else /* block_idx = 1 */ {\n\n            range = 8;\n\n            if (s->aw_n_pulses[block_idx] > 0)\n\n                pulse_off = s->aw_next_pulse_off_cache;\n\n        }\n\n    } else\n\n        range = 16;\n\n    pulse_start = s->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0;\n\n\n\n    /* aw_pulse_set1() already applies pulses around pulse_off (to be exactly,\n\n     * in the range of [pulse_off, pulse_off + s->aw_pulse_range], and thus\n\n     * we exclude that range from being pulsed again in this function. */\n\n    memset(&use_mask[-2], 0, 2 * sizeof(use_mask[0]));\n\n    memset( use_mask,   -1, 5 * sizeof(use_mask[0]));\n\n    memset(&use_mask[5], 0, 2 * sizeof(use_mask[0]));\n\n    if (s->aw_n_pulses[block_idx] > 0)\n\n        for (idx = pulse_off; idx < MAX_FRAMESIZE / 2; idx += fcb->pitch_lag) {\n\n            int excl_range         = s->aw_pulse_range; // always 16 or 24\n\n            uint16_t *use_mask_ptr = &use_mask[idx >> 4];\n\n            int first_sh           = 16 - (idx & 15);\n\n            *use_mask_ptr++       &= 0xFFFF << first_sh;\n\n            excl_range            -= first_sh;\n\n            if (excl_range >= 16) {\n\n                *use_mask_ptr++    = 0;\n\n                *use_mask_ptr     &= 0xFFFF >> (excl_range - 16);\n\n            } else\n\n                *use_mask_ptr     &= 0xFFFF >> excl_range;\n\n        }\n\n\n\n    /* find the 'aidx'th offset that is not excluded */\n\n    aidx = get_bits(gb, s->aw_n_pulses[0] > 0 ? 5 - 2 * block_idx : 4);\n\n    for (n = 0; n <= aidx; pulse_start++) {\n\n        for (idx = pulse_start; idx < 0; idx += fcb->pitch_lag) ;\n\n        if (idx >= MAX_FRAMESIZE / 2) { // find from zero\n\n            if (use_mask[0])      idx = 0x0F;\n\n            else if (use_mask[1]) idx = 0x1F;\n\n            else if (use_mask[2]) idx = 0x2F;\n\n            else if (use_mask[3]) idx = 0x3F;\n\n            else if (use_mask[4]) idx = 0x4F;\n\n            else                  return;\n\n            idx -= av_log2_16bit(use_mask[idx >> 4]);\n\n        }\n\n        if (use_mask[idx >> 4] & (0x8000 >> (idx & 15))) {\n\n            use_mask[idx >> 4] &= ~(0x8000 >> (idx & 15));\n\n            n++;\n\n            start_off = idx;\n\n        }\n\n    }\n\n\n\n    fcb->x[fcb->n] = start_off;\n\n    fcb->y[fcb->n] = get_bits1(gb) ? -1.0 : 1.0;\n\n    fcb->n++;\n\n\n\n    /* set offset for next block, relative to start of that block */\n\n    n = (MAX_FRAMESIZE / 2 - start_off) % fcb->pitch_lag;\n\n    s->aw_next_pulse_off_cache = n ? fcb->pitch_lag - n : 0;\n\n}\n", "idx": 14741, "substitutes": {"s": ["bs", "sg", "history", "shared", "resource", "ps", "args", "ms", "js", "sa", "locks", "sw", "se", "sm", "plays", "sis", "sync", "details", "h", "changes", "sb", "series", "ops", "os", "sv", "set", "store", "ssl", "m", "sports", "as", "sf", "is", "south", "parts", "ns", "rs", "sl", "x", "S", "so", "c", "comm", "sys", "ls", "hs", "its", "ims", "sq", "ts", "a", "qs", "sts", "ss", "aunts", "settings", "ses", "local", "conf", "p", "es", "sam", "aws", "gs", "b", "e", "spec", "less", "ds", "cs", "v", "stats", "w", "scl"], "gb": ["gd", "uf", "sg", "image", "gm", "RGB", "bf", "rb", "cb", "hw", "bridge", "bd", "ram", "mb", "buff", "gs", "db", "buffer", "gc", "bb", "eg", "rg", "g", "uk", "nb", " rgb", "kb", "bg", "bm"], "block_idx": ["blockOixc", "block_idexs", "blockingidxes", "block_idxa", "block_idz", "block2indx", "block_dixa", "block_idxes", "block_itxc", "block_locxf", "block_dixc", "block2indxs", "block_indx", "blockingdixc", "block_idexf", "block_identxf", "block_nameth", "block0identxf", "blockingidxf", "block_itxf", "block_indl", "blockOidxes", "block2indxf", "block_idez", "block2indy", "block0idth", "block_locxes", "block2idx", "block_Idxes", "blockingdixes", "block_indexno", "block_ix", "block_idv", "block_namex", "blockOidy", "block_indv", "block_idxf", "block_ixc", "block_dixf", "block0identct", "block_Idno", "block_idex", "block_indexv", "block_itx", "block_itxa", "block_dix", "block_idxs", "block_locxa", "block_indxf", "block_idy", "block_identx", "blockingdixf", "block0identx", "block_idct", "blockingdix", "block_idl", "block_idno", "block_idsx", "blockOidxc", "block_indexy", "block_indz", "block2idy", "block_itxes", "block_idxc", "block_Idxc", "block_idsxes", "block_identct", "block_idsxf", "block_namect", "block0idx", "blockingidxc", "blockOix", "block_idel", "block_iy", "block_indy", "block2idxs", "block_identth", "block_Idxs", "block_Idxf", "blockOixes", "block_Idy", "block0idct", "blockOiy", "block_indxs", "block_idth", "block_namexf", "block_idey", "block_ity", "blockOidx", "block_dixes", "block_Idl", "block0identth", "block_ixes", "block_Idv", "block2idxf", "block_Idx", "block_indexx", "block_idsxc", "block_Idz", "block_idev", "block0idxf", "block_locx", "blockingidx"], "fcb": ["eca", "acbd", "acb", "cfd", "ricd", "cfa", "racsb", "pcnb", "rica", "pca", "ricbd", "racbf", "acbf", "ecnb", "cfb", "aca", "FCa", "acnb", "acsb", "fcbd", "pcpb", "FCb", "fcsb", "pcb", "fcbf", "fcpb", "ricb", "ecb", "raca", "FCbf", "fca", "fcnb", "acpb", "acd", "racb", "FCsb", "ecpb", "fcd", "cfbd"], "use_mask_mem": ["use_mask2ptr", "use_mask_max", "use_mask2max", "use_flag_mem", "use_map_ptr", "use_mask2cap", "use_mask_map", "use_map2max", "use_mask_memory", "use_map_mem", "use_map2mem", "use_flag_memory", "use_map_cap", "use_map2ptr", "use_map2cap", "use_mask2mem", "use_flag_map", "use_map_max", "use_mask_cap"], "use_mask": ["use2weight", "used_mask", "use64mark", "usellweight", "use_weight", "user_shadow", "use_scale", "use_code", "uselymark", "usellhash", "used2weight", "uselypack", "use_match", "user_mask", " use_block", "used2hash", "uselymask", "user_map", "use64scale", "use_mark", "usexcode", "use_tag", "use_box", "use_flag", "uselymap", "uselyweight", "used2map", "used_map", "share_mask", " use_tag", " use_mark", "uselyquery", "share_flags", "use2hash", "share_map", "usexmap", "usexmask", "usellmap", " use_map", "use64shadow", " use_match", "share_comment", "use_comment", "use_map", "use_flags", "user_scale", "use_block", "use64map", "use2mask", " use_code", "use_query", " use_pack", "usextag", "use_pack", "use2map", "use_shadow", "use_hash", "usellmask", "use64query", " use_box", " use_flag", "used2mask", " use_weight", " use_query", "used_hash", "used_weight", "use64mask"], "pulse_start": ["puls_end", "pue_off", "pulse_down", "pulse_step", "pue_int", "puls_step", "pulse_off", "pue_start", "puls_down", "puls_start", "pulse_end", "pulse_int", "pue_end"], "n": ["i", "l", "k", "z", "nu", "np", "c", "q", "p", "r", "m", "nm", "ne", "N", "nt", "len", "nr", "na", "ni", "g", "j", "nn", "num", "nb", "o", "v", "w", "ns"], "idx": ["kidxc", "Idy", " idxc", "indi", "idy", "piddx", "IDxi", "midix", "Idx", "Idix", "idi", " idxi", "indy", "indz", "midxes", " idy", "midex", " idz", " idex", "pidxf", " idi", "kidxf", "bidx", "pidix", "bidex", "kidy", " idix", "indxes", "midxi", "kidxes", "index", "IDix", "bidi", "kiddx", "IDn", "idn", "indx", "bidix", "pidx", "pidxc", "midn", "idz", " idn", "IDx", "pidy", "idxf", "iddx", "idxes", "kidx", "idxi", "pidz", " idxf", "kidex", " iddx", "kidix", "idxc", "midx", "idex", "idix", "indix"], "range": ["view", "resolution", "sum", "ref", "type", "prefix", "angle", "ge", "area", "route", "radius", "ANGE", "history", "error", "sequence", "value", "share", "result", "resource", "scale", "conf", "interface", "set", "change", "family", "r", "from", "bound", "timeout", "handle", "flow", "ne", "rang", "trace", "chain", "window", "count", "slice", "domain", "network", "distance", "array", "index", "remote", "size", "limit", "offset", "spread", "num", "row", "max", "zone", "binary", "span", "align", "ange", "base", "rest", "scope", "Range", "length", "form", "diff", "lag", "call", "edge"], "aidx": ["indi", "edex", "index", "aidi", "idex", "edx", "aidex", "edy", "indx", "idy", "edi", "idi", "indy", "aidy"], "use_mask_ptr": ["use_mask__Ptr", "use_mask_addr", "use_map__ptr", "use_map_pointer", "use_mask_Ptr", "use_map_ptr", "use_map__pointer", "use_map__Ptr", "use_mask__ptr", "use_map_addr", "use_map_rel", "use_mask__rel", "use_map_Ptr", "use_map_pointers", "use_map__addr", "use_mask__pointer", "use_mask_rel", "use_mask_pointer", "use_mask__addr", "use_mask_pointers"]}}
{"project": "FFmpeg", "commit_id": "0ebb523f072322972ea446616676fff32e9603c6", "target": 1, "func": "static void asf_build_simple_index(AVFormatContext *s, int stream_index)\n\n{\n\n    ff_asf_guid g;\n\n    ASFContext *asf     = s->priv_data;\n\n    int64_t current_pos = avio_tell(s->pb);\n\n    int i;\n\n\n\n    avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET);\n\n    ff_get_guid(s->pb, &g);\n\n\n\n    /* the data object can be followed by other top-level objects,\n\n     * skip them until the simple index object is reached */\n\n    while (ff_guidcmp(&g, &index_guid)) {\n\n        int64_t gsize = avio_rl64(s->pb);\n\n        if (gsize < 24 || s->pb->eof_reached) {\n\n            avio_seek(s->pb, current_pos, SEEK_SET);\n\n            return;\n\n        }\n\n        avio_skip(s->pb, gsize - 24);\n\n        ff_get_guid(s->pb, &g);\n\n    }\n\n\n\n    {\n\n        int64_t itime, last_pos = -1;\n\n        int pct, ict;\n\n        int64_t av_unused gsize = avio_rl64(s->pb);\n\n        ff_get_guid(s->pb, &g);\n\n        itime = avio_rl64(s->pb);\n\n        pct   = avio_rl32(s->pb);\n\n        ict   = avio_rl32(s->pb);\n\n        av_log(s, AV_LOG_DEBUG,\n\n               \"itime:0x%\"PRIx64\", pct:%d, ict:%d\\n\", itime, pct, ict);\n\n\n\n        for (i = 0; i < ict; i++) {\n\n            int pktnum        = avio_rl32(s->pb);\n\n            int pktct         = avio_rl16(s->pb);\n\n            int64_t pos       = s->data_offset + s->packet_size * (int64_t)pktnum;\n\n            int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0);\n\n\n\n            if (pos != last_pos) {\n\n                av_log(s, AV_LOG_DEBUG, \"pktnum:%d, pktct:%d  pts: %\"PRId64\"\\n\",\n\n                       pktnum, pktct, index_pts);\n\n                av_add_index_entry(s->streams[stream_index], pos, index_pts,\n\n                                   s->packet_size, 0, AVINDEX_KEYFRAME);\n\n                last_pos = pos;\n\n            }\n\n        }\n\n        asf->index_read = ict > 0;\n\n    }\n\n    avio_seek(s->pb, current_pos, SEEK_SET);\n\n}\n", "idx": 14745, "substitutes": {"s": ["bs", "fs", "ties", "http", "ps", "ms", "ports", "js", "sw", "ex", "ares", "se", "ins", "details", "h", "changes", "sb", "serv", "sql", "os", "als", "sv", "ches", "set", "an", "m", "sports", "erences", "events", "ers", "as", "j", "t", "is", "f", "south", "ns", "rs", "x", "ies", "S", "c", "comm", "sys", "ls", "vs", "hs", "ats", "its", "ims", "sq", "https", "ts", "a", "qs", "params", "ss", "sts", "n", "z", "ses", "conf", "p", "es", "sam", "us", "aws", "gs", "b", "e", "spec", "bis", "less", "ds", "cs", "v", "stats", "scl"], "stream_index": ["stream_id", " stream_seek", " stream_id", "stream_pos", "stream_seek", " stream_pos"], "g": ["gd", "h", "ge", "sg", "gi", "ag", "fg", "gm", "go", "gn", "group", "gg", "reg", "gu", "guard", "c", "global", " eg", "tg", "m", "gp", "cfg", "gs", "b", "pg", " gp", "gen", "G", "gain", "gc", "eg", "rg", "j", "msg", "gate", "gt", " msg", "t", "ig", "gr", "erg", "v", "f", "bg", " mg", "gent", "gb", "ga"], "asf": ["rasv", "asv", "msf", "asc", "rasc", "Asfe", "rasfo", "asfo", "Asc", "msp", "Asp", "asfe", " asfe", "aresfo", "Asfo", "asp", "Asv", " asp", "aresc", " asc", " asv", "rasf", "msfo", "aresf", "aresfe", "msc", "Asf", " asfo", "msv"], "i": [" e", "cli", "u", "oi", "asi", "pos", " out", " m", " ii", "it", "ci", "ki", "zi", "mi", "y", " k", " it", "ii", "ij", "hi", " pi", "m", "multi", "j", "iii", "xi", "t", " x", "ix", "is", "f", "ui", "ini", "qi", "ind", "l", "ai", "di", "x", "c", " bi", "ti", "li", "\u0438", "I", "si", "im", "in", " start", " v", "index", "phi", "pi", " pos", "iq", "n", "gi", "sim", "ip", " l", " p", "ei", "p", " j", " I", "ami", " index", "iu", "id", "ic", "v", " err", " ti"], "itime": ["mph", "info", "iam", "udi", "hip", "ila", "time", "met", "iti", "mie", "wi", "ip", "idi", "ime", "him", "imet", "ist", "tim", "ti", "his", "hi", "iman", "loc", "position", "ici", "imp", "timeout", "port", "ms", "ia", "im", "tp", "iter", "pir", "consider", "ih", "mint", "mid", "import", "rice", "size", "meet", "it", "fine", "isd", "communication", "mine", "minute", "mt", "phis", "oni", "uti", "phi", "mit", "\u00ee", "irin", "mi", "is", "income", "pi", "length", "iat", "delay"], "pct": ["pact", "PCT", " pact", "pCT", "phpCT", "phpact", "phpct", "opCT", "prct", "Pact", "Pct", " pkl", "pkt", " pCT", "Pkl", "Pkt", " pw", "prw", "prCT", "pkl", "Pw", "opkt", "pw", "opact", " pkt", "opct", "phpkl"], "ict": ["iq", "ont", "icit", "oc", "voc", "dict", "elt", "dt", "anta", "virt", "di", "ich", "icts", "iat", "cot", "dc", "dds", "ist", "tif", "iction", "ICT", "tower", "qa", "et", "ota", "rict", "vid", "ent", "tz", "tc", "pd", "adic", "ot", "nt", "ffff", "mint", "dd", "it", "act", "nic", "chest", "uct", "wine", "tier", "ct", "ient", "ic", "iet", "ec", "ds", "tt", "pt", "adi", "assad", "qt", "ht"]}}
{"project": "qemu", "commit_id": "1f3ddfcb258e6e0562467a9644daad3f28597da8", "target": 1, "func": "static void bdrv_qed_drain(BlockDriverState *bs)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n\n\n    /* Cancel timer and start doing I/O that were meant to happen as if it\n\n     * fired, that way we get bdrv_drain() taking care of the ongoing requests\n\n     * correctly. */\n\n    qed_cancel_need_check_timer(s);\n\n    qed_plug_allocating_write_reqs(s);\n\n    bdrv_aio_flush(s->bs, qed_clear_need_check, s);\n\n}\n", "idx": 14750, "substitutes": {"bs": ["bos", "fs", "sb", "aos", "ks", "bc", "als", "bes", "aus", "bh", "ps", "es", "ls", "vs", "hs", "gs", "b", "ats", "its", "js", "iss", "lbs", "asis", "bb", "bis", "bas", "aps", "cks", "acs", "BS", "ds", "ubs", "bp", "cs", "ts", "is", "bits", "qs", "bm", "obs", "bing", "ns", "ss"], "s": ["h", "i", "rs", "n", "sl", "z", "ses", "S", "ar", "sv", "c", "q", "ps", "ss", "comm", " ss", "p", "sys", "ess", "es", "an", "m", "r", "ls", "us", "hs", "gs", "ats", "b", "its", "js", "iss", "as", "sa", "ims", "w", "g", "j", "sq", "less", "t", "ds", "cs", "ts", "is", "a", "y", "v", "ins", "qs", "ns", "sts"]}}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtol(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 14774, "substitutes": {"str": ["i", "stri", "end", "txt", "br", "out", "STR", "buf", "cur", "input", "st", "pre", "s", "arr", "r", "list", "ptr", "tr", "Str", "pos", "b", "chain", "buffer", "len", "sp", "spec", "ocr", "g", "res", "fr", "msg", "data", "seq", "ctr", "t", "vol", "gr", "cs", "source", "text", "f", "length", "doc"], "endptr": ["endpad", "endreq", "endedjp", "enderpoint", " endpad", "enderPtr", "endpoint", " endjp", "endedPtr", "enderjp", "enderpad", "enderpos", " endreq", "endedaddr", "endedpad", "ENDptr", "endedreq", "enderaddr", "enderptr", " endpos", "ENDaddr", "ENDpoint", "endPtr", "endedptr", "ENDPtr", "enderreq", "endedpoint", " endPtr", "endpos", "endedpos", "endjp", "endaddr"], "err": ["erer", "i", "ch", " cr", " len", "rs", "ind", "Error", "n", " ni", " ptr", "br", "error", "out", "cmp", " typ", " dist", "result", " result", " er", "er", "arr", "r", " gr", "urg", "ptr", "tr", "dr", " r", " fr", "rc", "rr", " resp", "iter", "nr", "ret", "der", "exc", "erm", "id", "res", "it", "fr", "resh", "msg", "ctr", "order", "attr", "fee", "gr", " Err", " terr", "pr", "resp", " res", " error", "cr", "errors", "Er", "viol", " dr"]}}
{"project": "qemu", "commit_id": "340849a9ff2a246bbc9a2da3f079c9fdbd2d5852", "target": 1, "func": "static int check_bind(const char *hostname, bool *has_proto)\n\n{\n\n    int fd = -1;\n\n    struct addrinfo ai, *res = NULL;\n\n    int rc;\n\n    int ret = -1;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = AF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(hostname, NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        if (rc == EAI_ADDRFAMILY ||\n\n            rc == EAI_FAMILY) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    fd = qemu_socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n    if (fd < 0) {\n\n        goto cleanup;\n\n    }\n\n\n\n    if (bind(fd, res->ai_addr, res->ai_addrlen) < 0) {\n\n        if (errno == EADDRNOTAVAIL) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    *has_proto = true;\n\n done:\n\n    ret = 0;\n\n\n\n cleanup:\n\n    if (fd != -1) {\n\n        close(fd);\n\n    }\n\n    if (res) {\n\n        freeaddrinfo(res);\n\n    }\n\n    return ret;\n\n}\n", "idx": 14775, "substitutes": {"hostname": [" hostName", "hostnames", "hoststring", "handName", "bindname", "domainname", "hostName", "hostame", "Hostame", "HostNAME", "hostNAME", "domainame", "bindName", "domainstring", "handnames", "bindstring", "Hostname", "Hoststring", "handname", "handNAME", " hostnames", "Hostnames", "HostName", " hostNAME", "domainName", "bindame"], "has_proto": ["has_colTo", "has_proocol", "has_pbocol", "has_Probo", "has_colto", "has_phybo", "has_pbto", "has_phyocol", "has_protserver", "has_PROto", "has_proserver", "has_ProTo", "has_colocol", "has_phypo", "has_protto", "has_Propo", "has_probo", "has_Proocol", "has_PROocol", "has_PRObo", "has_pbserver", "has_protocol", "has_PROpo", "has_phyto", "has_profo", "has_propserver", "has_protTo", "has_Proto", "has_propo", "has_Profo", "has_proTo", "has_propTo", "has_colfo", "has_protfo", "has_propocol", "has_propto"], "ai": ["aki", "iam", "ali", " wa", "ait", "ap", "ape", "arm", "asi", " au", "sa", "ay", " an", "ci", "ki", " mi", "mi", " ma", " ca", "rob", " aux", "ii", "aj", "am", " di", "aq", "cu", "hi", "an", "hai", "pai", "ia", "aaa", "aut", " da", " pri", "au", " af", "ae", "ui", " sa", " pa", " ha", "pa", " na", " ali", " bi", "aa", "AI", "ti", " ay", "ati", " av", "air", "auth", "aci", "ka", "acs", "a", "bi", "io", "i", "aus", "aim", "ar", "ei", "oa", "ami", " ah", "ao", " acc", "ais", "api", "aka", " a", "ass", "iat", " ac"], "res": ["bs", "re", "addr", "resource", "ps", "r", "nil", "ms", "mem", "js", "des", "ret", "der", "vals", "ex", "expr", "inv", "vers", "ins", "rem", "details", "usr", "sol", "serv", "complete", "results", "os", "full", "init", "has", "pas", "ires", "ri", "rss", "conn", "pres", "resp", "rs", "req", "ber", "ress", "sys", "err", "ser", "response", "rez", "rm", "mr", "resources", "rt", "Res", "rec", "aux", "ras", "i", "progress", "json", "out", "reg", "result", "cons", "rx", "desc", "raw", "rev", "remote", "ctx", "ok", "RES", "rek", "gr", "rest", "reset"], "rc": ["ror", "cor", "rs", "comp", "pc", "priv", "nz", "rev", "bc", "ck", "lc", "dc", "cur", "cmp", "addr", "src", "c", "cb", "loc", "err", "r", "rx", "desc", "round", "ry", "rd", "tc", "isc", "cc", "rr", "len", "sec", "rh", "ret", "gc", "nr", "rect", "ce", "cont", "ro", "rn", "coll", "arc", "row", "ctr", "ec", "nc", "cs", "fc", "sc", "rt", "roc", "cr", "rec", "cd", "RC", "co"]}}
{"project": "qemu", "commit_id": "684e508c23d28af8d6ed2c62738a0f60447c8274", "target": 1, "func": "static bool run_poll_handlers(AioContext *ctx, int64_t max_ns)\n\n{\n\n    bool progress = false;\n\n    int64_t end_time;\n\n\n\n    assert(ctx->notify_me);\n\n    assert(ctx->walking_handlers > 0);\n\n    assert(ctx->poll_disable_cnt == 0);\n\n\n\n    trace_run_poll_handlers_begin(ctx, max_ns);\n\n\n\n    end_time = qemu_clock_get_ns(QEMU_CLOCK_REALTIME) + max_ns;\n\n\n\n    do {\n\n        AioHandler *node;\n\n\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->io_poll &&\n\n                node->io_poll(node->opaque)) {\n\n                progress = true;\n\n            }\n\n\n\n            /* Caller handles freeing deleted nodes.  Don't do it here. */\n\n        }\n\n    } while (!progress && qemu_clock_get_ns(QEMU_CLOCK_REALTIME) < end_time);\n\n\n\n    trace_run_poll_handlers_end(ctx, progress);\n\n\n\n    return progress;\n\n}\n", "idx": 14777, "substitutes": {"ctx": ["pkg", "context", "jp", "kw", "req", "prefix", "tmp", "bc", "ck", "txt", "tx", "cas", "ctl", "etc", "setup", "cmp", "pool", "cm", "addr", "np", "c", "cp", "xc", "hw", "conf", "cb", "comm", "loc", "kl", "sys", "jac", "cfg", "xs", "mk", "timeout", "course", "tz", "tc", "cc", "xy", "gc", "cv", "kt", "cf", "act", "conn", "ct", "anc", "ctr", "work", "tm", "crit", "ca", "wx", "cmd", "wcs", "wd", "obj", "aux", "qt", "iat", "co"], "max_ns": ["max_ms", "max_mn", " max_ms", " max_xs", "max_nets", "max00ms", "max00xs", "maxsyseconds", "maxsybs", " max_seconds", " max_mn", " max_bs", "max00ns", "max67ns", "maxsyns", "max__nets", "max67mn", "max67ms", "max_bs", "max__ms", "maxsyms", "max67xs", "max_xs", "max__xs", "max__ns", "max_seconds", " max_nets", "max00nets"], "end_time": ["endlyime", "end_hour", "endlymin", " end_t", "endtimehour", "end__t", "endtimetime", "endmattime", "end__ime", "end__time", "end_t", " end_timer", "end_ime", "end__Time", "endmatime", " end_min", "endmatmin", "endtimetimer", "end_Time", " end_hour", " end_ime", "end_timer", "end_min", " end_Time", "endlytime"], "node": ["event", "pkg", "device", "worker", "cache", "child", "parent", "n", "page", "k", "tmp", "nw", "server", "slave", "content", "peer", "local", "hop", "np", "addr", "resource", "root", "tree", "list", "host", "m", "Node", "key", "ready", "callback", "name", "good", "entry", "e", "window", "nt", "holder", "field", "fn", "index", "path", "instance", "id", "note", "object", "station", "inner", "nn", "primary", "item", "msg", "row", "data", "normal", "token", "t", "handler", "ode", "self", "leaf", "wrapper", "link", "source", "master", "obj", "post"]}}
{"project": "FFmpeg", "commit_id": "3c5cf2a31b4b29a8e4282cbe6a3f0617c14698b8", "target": 0, "func": "static int screenpresso_decode_frame(AVCodecContext *avctx, void *data,\n\n                                     int *got_frame, AVPacket *avpkt)\n\n{\n\n    ScreenpressoContext *ctx = avctx->priv_data;\n\n    AVFrame *frame = data;\n\n    int keyframe;\n\n    int ret;\n\n\n\n    /* Size check */\n\n    if (avpkt->size < 3) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small (%d)\\n\", avpkt->size);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* Basic sanity check, but not really harmful */\n\n    if ((avpkt->data[0] != 0x73 && avpkt->data[0] != 0x72) ||\n\n        avpkt->data[1] != 8) { // bpp probably\n\n        av_log(avctx, AV_LOG_WARNING, \"Unknown header 0x%02X%02X\\n\",\n\n               avpkt->data[0], avpkt->data[1]);\n\n    }\n\n    keyframe = (avpkt->data[0] == 0x73);\n\n\n\n    /* Resize deflate buffer and frame on resolution change */\n\n    if (ctx->inflated_size != avctx->width * avctx->height * 3) {\n\n        av_frame_unref(ctx->current);\n\n        ret = ff_get_buffer(avctx, ctx->current, AV_GET_BUFFER_FLAG_REF);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        /* If malloc fails, reset len to avoid preserving an invalid value */\n\n        ctx->inflated_size = avctx->width * avctx->height * 3;\n\n        ret = av_reallocp(&ctx->inflated_buf, ctx->inflated_size);\n\n        if (ret < 0) {\n\n            ctx->inflated_size = 0;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* Inflate the frame after the 2 byte header */\n\n    ret = uncompress(ctx->inflated_buf, &ctx->inflated_size,\n\n                     avpkt->data + 2, avpkt->size - 2);\n\n    if (ret) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Deflate error %d.\\n\", ret);\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    /* When a keyframe is found, copy it (flipped) */\n\n    if (keyframe)\n\n        av_image_copy_plane(ctx->current->data[0] +\n\n                            ctx->current->linesize[0] * (avctx->height - 1),\n\n                            -1 * ctx->current->linesize[0],\n\n                            ctx->inflated_buf, avctx->width * 3,\n\n                            avctx->width * 3, avctx->height);\n\n    /* Otherwise sum the delta on top of the current frame */\n\n    else\n\n        sum_delta_flipped(ctx->current->data[0], ctx->current->linesize[0],\n\n                          ctx->inflated_buf, avctx->width * 3,\n\n                          avctx->width * 3, avctx->height);\n\n\n\n    /* Frame is ready to be output */\n\n    ret = av_frame_ref(frame, ctx->current);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Usual properties */\n\n    if (keyframe) {\n\n        frame->pict_type = AV_PICTURE_TYPE_I;\n\n        frame->key_frame = 1;\n\n    } else {\n\n        frame->pict_type = AV_PICTURE_TYPE_P;\n\n    }\n\n    *got_frame = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 14813, "substitutes": {"avctx": ["avercontext", "ajcu", "ajcoll", "avercb", "avercp", "wavcontext", "avtx", "avecfg", " avcoll", "avetimeout", "ajpkg", "avdt", "svcrit", "avdad", "avcfg", "ivertimeout", "wavcp", " avcontext", "wavctl", "avejs", "afkl", " avcb", "wavconn", "avegc", "savcontext", " avca", "avconfig", "navdt", "avca", "savcrit", "ajctx", "avjs", "averconfig", "wavcmd", "savtx", "avepkg", " avgc", "afcontext", "avecu", "avcmd", "ajdt", "avtimeout", "averctl", "avpkg", " avtimeout", "navctx", "averctx", "navpkg", "aftx", "avectx", " avcp", "afctx", "avekl", "avsys", "navcfg", "navconn", "navsys", "ajjs", " avconn", "afcp", "navca", "aveconfig", "ajkl", "avesys", " avcrit", "avcu", "svcp", "AVcontext", "avercu", "AVctx", "iverca", "avcontext", "avercmd", "AVcfg", "ajdad", "savctx", "afjs", "avecontext", "navcu", "wavpkg", "iverctx", "avedt", "svtx", "averpkg", "ajcontext", "avedad", "avcoll", "avgc", "wavtx", "afconn", "ivercontext", "savconn", "svpkg", "avcp", "avcrit", " avcfg", "aveca", "afpkg", "avkl", "wavcu", "wavconfig", "avetx", " avctl", "wavcfg", "avctl", " avtx", "svctx", "wavctx", "wavgc", "avertx", "AVtx", "avecmd", "avectl", "avconn", "aveconn", "navdad", "svcontext", "avercoll", "ajcb", " avsys", "avcb", "navcontext"], "data": ["device", "image", "map", "status", "content", "padding", "flags", "history", "what", "feed", "addr", "message", "r", "args", "valid", "read", "des", "done", "it", "use", "offset", "text", "mu", "d", "info", "cache", "br", "next", "hash", "video", "has", "def", "bus", "m", "height", "any", "timeout", "name", "good", "code", "buffer", "final", "to", "size", "res", "t", "f", "first", "form", "length", "relation", "query", "ns", "headers", "one", "delay", "rel", "channel", "version", "bytes", "byte", "buf", "empty", "options", "in", "response", "block", "no", "mode", "values", "bits", "a", "area", "da", "params", "ref", "time", "extra", "Data", "DATA", "out", "share", "depth", "input", "ata", "new", "rew", "fields", "p", "list", "action", "raw", "window", "xy", "len", "id", "str", "bin", "date", "table", "obj", "w", "dat"], "got_frame": ["gotewstate", "gotewwindow", "gotewheader", "gotewframe", "gotipstate", "received_header", "received_frame", "got_state", "received_window", "gotipframe", "gotipwindow", "received_state", "got_window", "got_header", "gotipheader"], "avpkt": ["avpodkat", "avpapt", "avpkw", "vanpkt", " avpnton", "avpakat", "avpaykt", "vrpkw", "dreamjpkt", "avpkgcht", "avpaykw", "avptt", "avpodgt", "iverpaywp", "avpodkw", "avpodkt", "avdett", "devpkt", "avpsgt", "avpkgoc", " avcpdat", "avtwt", "aftpadkg", "avpidvt", "avpgt", "aftpodgt", "iverpayacket", "avpodtt", "avpcdu", "aftpadkt", "avetett", "avcpkt", "avpkgacket", "avdwt", "vanppt", " avcpdt", " avcpkt", " avppt", "dreampkat", "avtpacket", "avpact", "avdkt", "avpayacket", "avppt", "avPoc", "aftpkg", "avpast", "avtkt", "devpct", "vanpapt", "avpadkg", "avpostacket", "avpkgkat", "dreamjpst", "avetacket", "avepwt", "avpadt", "afpacket", "avjpkat", "devpcht", "avcpct", "iverpacket", "aftpodkt", "avpkgpt", "avtacket", "vrpaydt", "avprekat", "avpadkat", "avpcpt", "avpkg", "devpacht", "aftpgt", "avpskat", "avwpdu", "avtpkw", "avpkgtt", "avpoddt", "dreamjpkat", "avpcht", "avpst", "aftpadcht", "avcpdat", "avpskt", "avcpkat", "aftpodkat", "avPacket", "avcpnt", "afcpacket", "avfacket", "avpadu", "iverpkt", "avpckt", "avpostwt", "avpkgkg", "avopkt", "vrpaykt", " avcpnton", "avprecht", "avfnt", "iverpayoc", "aftpkat", " avpacket", "aftpst", "avjpkt", "devpakt", "dreampkt", "avepacket", "avpdu", "avcpcht", "dreampst", "avpidkt", "iverpwp", "avpostkt", "vrptt", "avpnton", " avcppt", "avcpnton", "avpkgkt", "avpadkt", "avpakg", "afcpkat", "avpoc", "avpctt", "vanpdu", "vanptt", "avpidcht", "vrpaykw", "avpaytt", "avpadat", "avcpvt", "avpacht", "devpact", "avpdt", "avpkgnton", " avpdt", "avpwt", "avpostett", "avpct", "aftpadst", " avpdat", "afpkt", "avpvt", "avpidct", "avcpdt", "avopnton", "dreamjptt", "avpadnt", "avpatt", "avpaydt", "aftpkt", "avpkgwp", "vrpdt", "avPkt", "avetkt", "aftpcht", "avjpst", "avpakt", "avtptt", "avtpdt", "avpayoc", "iverpaykt", "avpadacket", "avjptt", " avcpacket", "avtpdat", "avfkat", "avpwp", "avpnt", "vanpadu", "afcpkt", "avPwp", "avpscht", "avwptt", "dreamptt", "avpaywp", "avetwt", "avpett", "avoppt", "vanpatt", "afpkat", "avpodcht", "devpvt", "vrpkt", "avepett", "avprekt", "afcpnt", "avfkt", "avpkgst", "avopacket", "avwpkt", "iverpoc", "afpnt", "avpadst", "avdacket", "avcppt", "avpregt", "avpkat", "avcpacket", "avepkt", "vanpakt", "avpavt", "vrpaytt", "avpacket", "avpdat", "avwppt", "avtpkt", "avtett", "avpadcht", "devpavt", "avpaacket", "aftpodcht"], "ctx": ["pkg", "tk", "pool", "cmp", "px", "cm", "addr", "np", "cp", "cb", "check", "kl", "wp", "mem", "fn", "cv", "expr", "ca", "context", "that", "kw", "tmp", "ck", "ctrl", "cu", "jac", "cfg", "timeout", "mk", "tz", "tc", "gc", "kt", "cf", "conn", "tm", "lib", "resp", "cmd", "doc", "ns", "abc", "fx", "dl", "jp", "req", "prefix", "parent", "pc", "unc", "dc", "etc", "loc", "sys", "nt", "cc", "ct", "proc", "mt", "aux", "co", "xp", "iac", "tx", "lc", "ctl", "xc", "hw", "conf", "desc", "act", "mom", "inst", "ctr", "func", "nc", "crit", "config", "wx", "scope", "obj", "wordpress", "qt", "iat"], "frame": ["ror", "info", "channel", "image", "component", "tx", "Frame", "draw", "state", "def", "name", "window", "block", "instance", "shot", "msg", "row", "fr", "frames", "piece", "mt", "feature", "part", "cmd", "base", "f"], "keyframe": ["eyFrame", "oleframe", "rootFrame", "Keyimage", "KEYframes", "oleFrame", "keyframes", "oleframes", " keypoint", "rootflag", "eyzone", "KEYframe", "Keyframes", "KEYpoint", "keyzone", "linkFrame", " keyframes", "Keyframe", "keyimage", "linkzone", "rootzone", "oleimage", "linkframe", "linkflag", " keyimage", "keyFrame", "eyflag", "keypoint", "rootframe", "KEYFrame", "keyflag", "KeyFrame", "Keypoint", "eyframe", " keyFrame"], "ret": ["status", "success", "re", "reply", "cat", "Ret", "et", "nil", "mem", "att", "vet", "plain", "url", "utils", "ter", "expr", "rets", "failed", "rem", "usr", "rep", "std", "tmp", "hash", " RET", "def", "tr", "cfg", "flag", "gc", "res", "j", "msg", "bool", "try", "t", "net", "resp", "cmd", "print", "jp", "RET", "pret", "summary", "value", "ext", "sys", "arr", "err", "imp", "leg", "alt", "nt", "locked", "rm", "mt", "det", "gt", "arg", "rt", "deg", "val", "aux", "ft", "ref", "elt", "nz", "out", "reg", "result", "dr", "rev", "ert", "len", "fun", "cont", "str", "back", "ll", "tt", " fut", " Ret", "mel", "lit", "reset", "backed"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline TCGv iwmmxt_load_creg(int reg)\n\n{\n\n    TCGv var = new_tmp();\n\n    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));\n\n    return var;\n\n}\n", "idx": 14814, "substitutes": {"reg": [" Reg", "ref", "req", "k", "br", "Reg", "re", "state", "addr", "loc", "tag", "REG", "key", "cell", "leg", "name", "port", "mem", "sec", "index", "eg", "region", "id", "g", "res", "str", "num", "mod", "typ", "attr", " REG", "lex", "lit", "rec", "grid", "rem"]}}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)\n\n{\n\n    const ARMCPRegInfo *ri = rip;\n\n\n\n    ri->writefn(env, ri, value);\n\n}\n", "idx": 14816, "substitutes": {"env": ["context", "esm", "ve", "pe", "En", "EN", "nv", "hw", "er", "environment", " ens", "et", "vs", "te", "viron", "mem", "ah", "e", "dev", "window", "shell", "vt", "estate", "eh", "ctx", "erd", "ev", "ew", "ten", "en", "conn", "ov", "ef", "ec", "esc", "nc", "Environment", "equ", "v", "ope", "obj"], "rip": ["sing", "ring", "udi", "jp", "rep", "hip", "river", "rin", " Rip", "rib", "ip", "rit", "rain", "pin", "tip", "gra", "strip", "RIP", "ipp", "ripp", "rh", "rim", "rus", "rup", "rive", "rou", "rig", "rap", "ric", "trip", "roy", "pr", "rub", "RI", "rike", "ping", "rack", "rob"], "value": ["type", "image", "word", "state", "reg", "result", "sv", "new", "property", "p", "VAL", "set", "key", "update", "vp", "Value", "name", "code", "rule", "unit", "index", "VI", "see", "values", "VALUE", "data", "bin", "release", "widget", "ue", "val", "function", "v", "wise", "process", "current"], "ri": ["ani", "i", "tri", "udi", "rs", "ra", "pri", "rin", "di", "rib", "ij", "ti", "ria", "hi", "ru", "r", "rx", "ry", "ir", "rd", "ro", "res", "rn", "rive", "rm", "xi", "rid", "sr", "ric", "ki", "rap", "uti", "rio", "pr", "mi", "rt", "rw", "iri", "pi", "rub", "RI", "ris", "ini", "uri", "io", "rob"]}}
{"project": "qemu", "commit_id": "0e22a2d18998fd183c8181663981eb681ca977e9", "target": 1, "func": "static void vhost_scsi_stop(VHostSCSI *s)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    int ret = 0;\n\n\n\n    if (!k->set_guest_notifiers) {\n\n        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);\n\n        if (ret < 0) {\n\n                error_report(\"vhost guest notifier cleanup failed: %d\\n\", ret);\n\n        }\n\n    }\n\n    assert(ret >= 0);\n\n\n\n    vhost_scsi_clear_endpoint(s);\n\n    vhost_dev_stop(&s->dev, vdev);\n\n    vhost_dev_disable_notifiers(&s->dev, vdev);\n\n}\n", "idx": 14822, "substitutes": {"s": ["bs", "i", "h", "fs", "d", "rs", "changes", "n", "sb", "serv", "ops", "ses", "os", "S", "als", "session", "service", "c", "sv", "ps", "ss", "comm", "p", "sys", "es", "r", "args", "sam", "ls", "vs", "hs", "aws", "ms", "gs", "ats", "b", "its", "js", "dev", "as", "services", "sq", "t", "ds", "self", "times", "cs", "ts", "sc", "is", "a", "y", "v", "sis", "ns", "sts"], "vdev": ["vDEV", "cvdev", "cvval", " vdevice", "vmstore", "vstore", "vtval", " vval", "tserv", "vmmd", "vend", "vhw", "vcdev", "vcmd", "vdes", "vcdes", "vmdev", "vval", "svdevice", " vstore", " vhw", "lvdev", "vdec", "vpad", "tDEV", "cvdec", " vmd", "vmend", "vchw", "lvdes", "svdev", "vtpad", " vend", "svDEV", "vdevice", " vDEV", "vcstore", "vserv", " vserv", "vcend", " vpad", "svserv", "vtdev", "cvpad", " vdec", "vmd", " vdes", "lvhw", "tdevice", "tdev", "vtdec", "lvend"], "qbus": [" qlock", "quboot", "qboot", " qBus", "QBUS", "Qboot", "dqBUS", "qBus", "QBus", "qubus", "qlock", " qBUS", "qqbus", "dqlock", "dqbus", "qqBus", "qqBUS", "Qbus", "qus", "dqBus", "qqlock", "qqbuf", "dqbuf", "qqboot", "qbuf", "Qbuf", " qboot", "dqboot", "quus", "Qus", "qBUS", " qus", "quBUS"], "k": ["kind", "UK", "kw", "kn", "ks", "ck", "kit", "z", "tk", "ker", "wk", "ikk", "q", "HK", "kl", "key", "kk", "mk", "KR", "kh", "b", "kick", "sk", "ijk", "ack", "VK", "uk", "kt", "j", "max", "ka", "kj", "ke", "km", "ki", "ik", "ek", "ak", "t", "get", "kat", "keeper", "aka", "K", "kr", "hm"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void start_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val &= ~TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n", "idx": 14823, "substitutes": {"d": ["gd", "dn", "dl", "ind", "info", "l", "ord", "dm", "dx", "dt", "di", "dp", "dc", "c", "q", "dh", "dra", "bd", "p", "df", "r", "m", "dr", "rd", "b", "pd", "dev", "db", "md", "dd", "fd", "de", "D", "it", "dump", "ad", "sd", "data", "dq", "t", "ds", "dos", "debug", "du", "ld", "dat", "da"], "val": [" value", "cal", "rel", "sil", "Val", "ref", "prop", "eval", " VAL", "elt", "serv", "pol", "V", "sl", "tx", "x", "value", "util", "ul", "pl", "p", "VAL", " eval", "ival", "vec", "key", "update", "valid", "b", "fb", " al", "xy", "al", " v", "ret", "bal", "g", "it", "vals", "res", "cho", "pal", "aval", "data", "bin", " _", "el", "t", "test", "vol", "crit", "pr", "pt", "cond", "all", "v", "iat"]}}
{"project": "qemu", "commit_id": "1931076077254a2886daa7c830c7838ebd1f81ef", "target": 0, "func": "void memory_global_dirty_log_stop(void)\n\n{\n\n    global_dirty_log = false;\n\n\n\n    /* Refresh DIRTY_LOG_MIGRATION bit.  */\n\n    memory_region_transaction_begin();\n\n    memory_region_update_pending = true;\n\n    memory_region_transaction_commit();\n\n\n\n    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);\n\n}\n", "idx": 14840, "substitutes": {}}
{"project": "qemu", "commit_id": "77eec1b3f1493ca4813eae2fbf8702d1ef58f147", "target": 0, "func": "static inline int open_by_handle(int mountfd, const char *fh, int flags)\n\n{\n\n    errno = ENOSYS;\n\n    return -1;\n\n}\n", "idx": 14842, "substitutes": {"mountfd": ["streamfd", "_fc", "streamFD", " procfd", "streamfc", "usrfc", "usrFD", " procfc", "usrform", " procFD", "usrfd", " procform", "streamform", "_FD", "_form", "_fd"], "fh": ["sfhandle", "fdhandle", " fch", "sfih", " fhandle", "fih", "fdih", " fih", "fdh", "sfch", "fdch", "fhandle", "sfh", "fch"], "flags": ["details", "kind", "fs", "rs", "settings", "status", "ensions", "fields", "args", "options", "flag", "features", "faces", "Flags", "names", "ags", "mode", "vals", "ents", "nl", "properties", "ds", "cs", "ts", "bits", "types", "mask", "ns"]}}
{"project": "qemu", "commit_id": "541dc0d47f10973c241e9955afc2aefc96adec51", "target": 0, "func": "static void cmd_get_event_status_notification(IDEState *s,\n\n                                              uint8_t *buf)\n\n{\n\n    const uint8_t *packet = buf;\n\n\n\n    struct {\n\n        uint8_t opcode;\n\n        uint8_t polled;        /* lsb bit is polled; others are reserved */\n\n        uint8_t reserved2[2];\n\n        uint8_t class;\n\n        uint8_t reserved3[2];\n\n        uint16_t len;\n\n        uint8_t control;\n\n    } __attribute__((packed)) *gesn_cdb;\n\n\n\n    struct {\n\n        uint16_t len;\n\n        uint8_t notification_class;\n\n        uint8_t supported_events;\n\n    } __attribute((packed)) *gesn_event_header;\n\n\n\n    enum notification_class_request_type {\n\n        NCR_RESERVED1 = 1 << 0,\n\n        NCR_OPERATIONAL_CHANGE = 1 << 1,\n\n        NCR_POWER_MANAGEMENT = 1 << 2,\n\n        NCR_EXTERNAL_REQUEST = 1 << 3,\n\n        NCR_MEDIA = 1 << 4,\n\n        NCR_MULTI_HOST = 1 << 5,\n\n        NCR_DEVICE_BUSY = 1 << 6,\n\n        NCR_RESERVED2 = 1 << 7,\n\n    };\n\n    enum event_notification_class_field {\n\n        ENC_NO_EVENTS = 0,\n\n        ENC_OPERATIONAL_CHANGE,\n\n        ENC_POWER_MANAGEMENT,\n\n        ENC_EXTERNAL_REQUEST,\n\n        ENC_MEDIA,\n\n        ENC_MULTIPLE_HOSTS,\n\n        ENC_DEVICE_BUSY,\n\n        ENC_RESERVED,\n\n    };\n\n    unsigned int max_len, used_len;\n\n\n\n    gesn_cdb = (void *)packet;\n\n    gesn_event_header = (void *)buf;\n\n\n\n    max_len = be16_to_cpu(gesn_cdb->len);\n\n\n\n    /* It is fine by the MMC spec to not support async mode operations */\n\n    if (!(gesn_cdb->polled & 0x01)) { /* asynchronous mode */\n\n        /* Only polling is supported, asynchronous mode is not. */\n\n        ide_atapi_cmd_error(s, SENSE_ILLEGAL_REQUEST,\n\n                            ASC_INV_FIELD_IN_CMD_PACKET);\n\n        return;\n\n    }\n\n\n\n    /* polling mode operation */\n\n\n\n    /*\n\n     * These are the supported events.\n\n     *\n\n     * We currently only support requests of the 'media' type.\n\n     */\n\n    gesn_event_header->supported_events = NCR_MEDIA;\n\n\n\n    /*\n\n     * We use |= below to set the class field; other bits in this byte\n\n     * are reserved now but this is useful to do if we have to use the\n\n     * reserved fields later.\n\n     */\n\n    gesn_event_header->notification_class = 0;\n\n\n\n    /*\n\n     * Responses to requests are to be based on request priority.  The\n\n     * notification_class_request_type enum above specifies the\n\n     * priority: upper elements are higher prio than lower ones.\n\n     */\n\n    if (gesn_cdb->class & NCR_MEDIA) {\n\n        gesn_event_header->notification_class |= ENC_MEDIA;\n\n        used_len = event_status_media(s, buf);\n\n    } else {\n\n        gesn_event_header->notification_class = 0x80; /* No event available */\n\n        used_len = sizeof(*gesn_event_header);\n\n    }\n\n    gesn_event_header->len = cpu_to_be16(used_len\n\n                                         - sizeof(*gesn_event_header));\n\n    ide_atapi_cmd_reply(s, used_len, max_len);\n\n}\n", "idx": 14846, "substitutes": {"s": ["h", "fs", "rs", "sg", "n", "sb", "serv", "ses", "os", "S", "session", "state", "c", "sv", "ps", "ss", "st", "p", "sys", "es", "r", "set", "m", "gs", "e", "sq", "t", "ds", "se", "cs", "ts", "sc", "is", "south", "stats", "ns", "sts"], "buf": ["uf", "pkg", "queue", "ref", "bar", "map", "bytes", "tmp", "bt", "alloc", "br", "txt", "rb", "out", "Buff", "cur", "result", "cb", "p", "vec", "err", "batch", "pb", "raw", "buff", "bag", "b", "buffer", "block", "ctx", "cv", "Buffer", "cap", "msg", "data", "bin", "seq", "pack", "rw", "resp", "cmd", "btn", "v", "wb", "obj"], "packet": ["packacket", "buckET", "octet", "peacket", "octent", "framat", "payant", "bucket", "packET", "packsET", "framette", "packsat", "buckette", "peant", "framET", "packsette", "octant", "peet", "packent", "packette", "packat", "buckat", "payent", "packset", "payet", "octacket", "framet", "payacket", "packant", "peent"], "reserved2": ["reserve3", "reserve2", "reserved02", "reserved12", "preserved2", "preserved02", "reserve12", "presumed02", "presumed12", "preserved12", "presumed2", "preserved3", "resumed3", "presumed3", "resolved2", "resumed2", "resolved12", "resumed12", "resolved02", "resolved3", "reserve02", "resumed02"], "reserved3": ["reserved23", "Reserved3", "Reset23", "reset3", "reserv5", "resolved23", "reset4", "Reserved23", "Reserved5", "reserv23", "resolved5", "reserv3", "reserved5", "reset5", "reserv4", "resolved4", "Reserved4", "Reset5", "Reset3", "Reset4", "resolved3", "reset23", "reserved4"], "gesn_cdb": ["gesn_cDb", "gesn___comDb", "gesn_cdo", "gesn_dcdeb", "gesn_lud", "gesn___cDB", "gesn_cdeb", "gesn_recvd", "gesn_csdb", "gesn_csd", "gesn_cud", "gesn_mock", "gesn_csDB", "gesn_ctDB", "gesn_comdb", "gesn___comDB", "gesn_pbl", "gesn_cbl", "gesn_comDB", "gesn_cvd", "gesn___comdb", "gesn_ctvd", "gesn_ctd", "gesn_mbl", "gesn_dcDB", "gesn_cdock", "gesn_dcobj", "gesn_csdo", "gesn_cobj", "gesn___cdeb", "gesn_rDB", "gesn_pgb", "gesn_ctdo", "gesn_rdo", "gesn_cgb", "gesn_acdb", "gesn_ldb", "gesn_cdgb", "gesn_recdb", "gesn_recud", "gesn_cd", "gesn_mgb", "gesn_pdb", "gesn_mdb", "gesn_ctud", "gesn_dcdb", "gesn_ecgb", "gesn_dcDb", "gesn_rdb", "gesn_cddb", "gesn_cock", "gesn_cDB", "gesn_lvd", "gesn_cdbl", "gesn_ecdb", "gesn_cdobj", "gesn___cDb", "gesn___comdeb", "gesn_rd", "gesn_comDb", "gesn_acDB", "gesn_comdeb", "gesn_acdeb", "gesn_acDb", "gesn_ecobj", "gesn_pock", "gesn_dcgb", "gesn___cdb", "gesn_ctdb"], "max_len": [" max_en", " max_length", "maxtmem", "max_mem", "min_length", "maxtlen", " max_mem", "maxten", "max_en", "max_length", "min_mem", "maxtlength", "min_len"], "used_len": ["created___loc", "created___pos", "created_len", "used_pos", "created___lim", "used___loc", "used___len", "created_lim", "created_loc", "used___lim", "used___pos", "created___len", "created_pos", "used_lim", "used_loc"]}}
{"project": "FFmpeg", "commit_id": "850c6db97d1f78e7607952ab8b854a93a185319e", "target": 0, "func": "static int decode_plane(UtvideoContext *c, int plane_no,\n\n                        uint8_t *dst, int step, ptrdiff_t stride,\n\n                        int width, int height,\n\n                        const uint8_t *src, int use_pred)\n\n{\n\n    int i, j, slice, pix;\n\n    int sstart, send;\n\n    VLC vlc;\n\n    GetBitContext gb;\n\n    int prev, fsym;\n\n    const int cmask = c->interlaced ? ~(1 + 2 * (!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P)) : ~(!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P);\n\n\n\n    if (build_huff(src, &vlc, &fsym)) {\n\n        av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (fsym >= 0) { // build_huff reported a symbol to fill slices with\n\n        send = 0;\n\n        for (slice = 0; slice < c->slices; slice++) {\n\n            uint8_t *dest;\n\n\n\n            sstart = send;\n\n            send   = (height * (slice + 1) / c->slices) & cmask;\n\n            dest   = dst + sstart * stride;\n\n\n\n            prev = 0x80;\n\n            for (j = sstart; j < send; j++) {\n\n                for (i = 0; i < width * step; i += step) {\n\n                    pix = fsym;\n\n                    if (use_pred) {\n\n                        prev += pix;\n\n                        pix   = prev;\n\n                    }\n\n                    dest[i] = pix;\n\n                }\n\n                dest += stride;\n\n            }\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    src      += 256;\n\n\n\n    send = 0;\n\n    for (slice = 0; slice < c->slices; slice++) {\n\n        uint8_t *dest;\n\n        int slice_data_start, slice_data_end, slice_size;\n\n\n\n        sstart = send;\n\n        send   = (height * (slice + 1) / c->slices) & cmask;\n\n        dest   = dst + sstart * stride;\n\n\n\n        // slice offset and size validation was done earlier\n\n        slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0;\n\n        slice_data_end   = AV_RL32(src + slice * 4);\n\n        slice_size       = slice_data_end - slice_data_start;\n\n\n\n        if (!slice_size) {\n\n            av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"\n\n                   \"yet a slice has a length of zero.\\n\");\n\n            goto fail;\n\n        }\n\n\n\n        memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        c->bdsp.bswap_buf((uint32_t *) c->slice_bits,\n\n                          (uint32_t *)(src + slice_data_start + c->slices * 4),\n\n                          (slice_data_end - slice_data_start + 3) >> 2);\n\n        init_get_bits(&gb, c->slice_bits, slice_size * 8);\n\n\n\n        prev = 0x80;\n\n        for (j = sstart; j < send; j++) {\n\n            for (i = 0; i < width * step; i += step) {\n\n                pix = get_vlc2(&gb, vlc.table, VLC_BITS, 3);\n\n                if (pix < 0) {\n\n                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");\n\n                    goto fail;\n\n                }\n\n                if (use_pred) {\n\n                    prev += pix;\n\n                    pix   = prev;\n\n                }\n\n                dest[i] = pix;\n\n            }\n\n            if (get_bits_left(&gb) < 0) {\n\n                av_log(c->avctx, AV_LOG_ERROR,\n\n                        \"Slice decoding ran out of bits\\n\");\n\n                goto fail;\n\n            }\n\n            dest += stride;\n\n        }\n\n        if (get_bits_left(&gb) > 32)\n\n            av_log(c->avctx, AV_LOG_WARNING,\n\n                   \"%d bits left after decoding slice\\n\", get_bits_left(&gb));\n\n    }\n\n\n\n    ff_free_vlc(&vlc);\n\n\n\n    return 0;\n\nfail:\n\n    ff_free_vlc(&vlc);\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 14848, "substitutes": {"c": ["abc", "h", "d", "cache", "ch", "con", "comp", "n", "bc", "lc", "conv", "dc", "etc", "cmp", "cm", "cp", "cb", "conf", "cu", "comm", "this", "p", "s", "mc", "cam", "m", "C", "b", "tc", "e", "cc", "rc", "com", "ctx", "gc", "cv", "ce", "g", "cont", "cf", "coll", "ci", "cl", "ct", "anc", "ic", "enc", "ec", "t", "self", "ca", "cs", "fc", "sc", "nc", "config", "a", "ac", "cr", "v", "f", "cd", "call", "co"], "plane_no": ["plane_nob", "plane_ne", " plane_nob", " plane_NO", "plane_No", " plane_nos", "plane_nos", " plane_No", "plane_NO", " plane_ne", "plane_n", " plane_n"], "dst": ["pst", "Dset", "Dend", "pest", " dnd", " dST", "mST", "sdest", "pdest", "sdset", "Dest", "pdST", "mnd", "sst", "Dst", "sest", "dset", "dST", "ddest", "sddest", "Ddest", "pdst", "mst", "pdnd", "sdst", "dend", "nset", "nest", "dnd", "pend", "nst", "ndest"], "step": ["shape", "resolution", "d", "version", "stop", "trans", "draw", "frame", "hop", "scale", "Step", "weight", "st", "jump", "speed", "skip", "batch", "wait", "start", "tower", "tr", "walk", "add", "dim", "window", "chain", "iter", "delay", "loop", "w", "pointer", "mode", "op", "seed", "crop", "transform", "range", "offset", "driver", "steps", "STEP", "stroke", "length", "diff", "ride", "shift"], "stride": ["strize", "stringider", "stice", "strine", "strade", "stide", "trides", "side", "strride", "trride", "strise", "slension", "sprine", "grider", "gride", "stize", "slage", "slize", "stringides", "strension", "sade", "slade", "strage", "STRise", "Strension", "STRride", "Strider", "sice", "tride", "size", "stringide", "Strice", "sline", "spride", "Strine", "grise", "strider", "strice", "trise", "Stride", "STRide", "Strides", "stade", "trider", "strides", "sprage", "stringice", "sprension", "trice", "grride", "slide", "STRider", "Strage"], "height": ["shape", "h", "rank", "resolution", "view", "kw", "angle", "th", "ty", "hub", "radius", "history", "above", "hash", "depth", "density", "capacity", "family", "Height", "zh", "hang", "flow", "read", "dim", "window", "gravity", "buffer", "volume", "size", "range", "grow", "row", "stroke", "bottom", "ows", "y", "length", "w", "ht", "shift"], "src": ["shape", "dist", "rs", "sn", "std", "comp", "sb", "image", "bytes", "tmp", "txt", "rb", "input", "addr", "ist", "st", "sel", "scale", "loc", "ost", "s", "sys", "r", "scan", "start", "img", "hr", "ptr", "origin", "ser", "desc", "in", "seek", "sur", "rc", "ctx", "seed", "inner", "crop", "str", "rl", "supp", "iv", "sr", "inst", "ctr", "filename", "fc", "sc", "source", "rt", "Source", "sort", "rest", "ins", "stream", "shift"], "use_pred": ["use_Pred", "use_repl", " use_prop", "useablerepl", " use_pre", "useablepred", "use_red", " use_repl", "useablered", "use_pre", "useablePred", " use_red", "use_prop", " use_Pred"], "i": ["qi", "ind", "l", "ai", "ii", "ji", "n", "gi", "z", "di", "x", "sim", "ij", "ip", "ti", "li", "\u0438", "I", "p", "s", "start", "si", "m", "ri", "ori", "asi", "in", "im", "e", "ami", "iter", "index", "iu", "it", "ci", "ice", "ie", "xi", "ki", "zi", "ix", "mi", "pi", "y", "v", "bi", "ini", "ui"], "j": ["ind", "jp", "l", "end", "ii", "ji", "ge", "n", "aj", "k", "z", "json", "br", "bj", "x", "sim", "ij", "jo", "q", "p", "jump", "jj", "s", "m", "b", "im", "ja", "js", "index", "job", "it", "g", "uj", "fr", "dj", "ie", "other", "kj", "J", "jc", "o", "v", "y", "f", "bi", "obj", "jl", "jit", "shift"], "slice": ["cut", "route", "sequence", "face", "frame", "cone", "prime", "parse", "choice", "region", "offset", "dose", "scroll", "late", "se", "series", "division", "slave", "slot", "zero", "sp", "loop", "limit", "try", "single", "copy", "mix", "source", "ini", "edge", "sing", "gem", "ind", "l", "ble", "ve", "pe", "sl", "node", "split", "ste", "li", "pose", "si", "batch", "cell", "ser", "sci", "block", "volume", "index", "seed", "lic", "range", "tie", "lock", "stage", "gate", "piece", "axis", "pixel", "reverse", "call", "plane", "angle", "scale", "sel", "square", "chain", "crop", "module", "ice", "tile", "span", "vol", "sort", "section", "plot", "scope", "sample", "label", "shift"], "pix": ["spIX", "paik", "cpfix", "pitch", "paIX", " pixels", " pIX", "Pitch", " pik", "mpich", "Px", " pich", "mpik", "px", "pich", "spix", "paich", "Pix", "PIX", "spixels", "pixels", " pitch", "cpIX", " pfix", " px", "spx", "pfix", "mpox", "paixels", " pox", "Pixels", "ppix", "pik", "ppx", "Pfix", "mpix", "pIX", "cpx", "paius", "ppixels", "ppitch", "cpixels", "paox", "cpix", "cpius", "ppIX", " pius", "pius", "paix", "pox"], "sstart": ["dsstop", " ssend", "sssend", "sopen", "dstart", "snext", "dsstart", "Sstart", "atsbegin", "ospart", "Send", "ssbegin", "dopen", " sbegin", "dbegin", "nsaddr", " spart", "sstop", "saddr", "prand", "ssstart", "nsstop", " sopen", "dsnext", "Sbegin", "psrand", "Snext", "dsend", "dsaddr", "spart", "atsopen", "pwind", "psstart", "atsstart", " saddr", "pstart", "nsend", "swind", "nsstart", "osstart", "osbegin", "sspart", " sstop", "dend", "ossend", "ssend", "atsend", "sbegin", " swind", "ssopen", "dsbegin", "pswind"], "send": ["bind", "sn", "export", "status", "transfer", "eng", "message", "check", "scan", "add", "push", "parse", "apply", "sd", "offset", "grow", "forward", "se", "sc", "wait", "end", "nd", "draw", "init", "sv", "force", "append", "set", "jump", "store", "start", "sent", "commit", "sp", "size", "msg", "END", "mit", "cmd", "ceive", "command", "sum", "miss", "save", "Send", "format", "st", "connect", "pose", "skip", " Send", "cast", "seek", "seed", "gate", "process", "ss", "scale", "find", "speed", "desc", "see", "load", "transform", "fin", "write", "sort", "pend", "shift"], "vlc": ["VLci", "vpci", "mlcs", "mlt", "vlct", "mll", "klt", "vpct", "wlc", "wlct", "VLc", "vpl", "wll", "vpc", "VLl", "klc", "wlci", "wlt", "kll", "mlc", "klcs", "vlci", "vlcs", "wlcs", "vlt", "VLct", "vll"], "gb": [" rg", " coord", " cz", " whence", " Dest", " des", " rend", " dist", " std", "uv", " disp", " dim", " rc", " dc", " cc", " cd", " td", " digest", " prog", " db", " count", " flag", " deg", " dat", " buf", " rgb", " status", " bus"], "prev": ["pkg", "before", "rel", "ref", "prefix", "adj", "prop", "jp", "VP", "orig", "tmp", "miss", "last", "save", "serv", "slave", "txt", "best", "conv", "next", "ip", "init", "cmp", "buf", "cp", "PRE", "pred", "pre", "jump", "vec", "skip", "ptr", "origin", "desc", "vp", "rev", "mp", "sp", "seed", "op", "iv", "msg", "pres", "Prev", "trip", "vious", "attr", "vv", "snap", "sup", "inv", "par", "perm", "var", "first", "rec"], "fsym": ["Fsyn", "ffsy", "Fsy", "lsym", "sfmbol", "fsyn", "FSym", "tfsym", "tfmy", "fcmbol", "rfsym", "tfsyn", "fcsy", "rfsy", "Fmy", "ftyp", "Fmbol", "zmbol", "zsy", " fsy", "fmy", "flmy", "rfmbol", "rftyp", "Fsym", "fsy", "fcsym", "lsy", "fmbol", "zcmp", "tfSym", "lmbol", "ffmbol", "flsym", "ffSym", " fcmp", "sfsym", "lSym", "ffsym", "fSym", "flsyn", "fcmp", "sftyp", "flSym", " fmbol", "lcmp", "fctyp", "sfsy", "zsym"], "dest": ["shape", "dist", "usr", "sum", "prop", "end", "opt", "orig", "tmp", "trans", "status", "temp", "out", "dc", "Dest", "cat", "result", "global", "new", "st", "pas", "loc", "this", "sys", "vec", "list", "jump", "img", "ptr", "cast", "tr", "desc", "origin", "port", "target", "dim", "mem", "alt", "chain", "iter", "sp", "decl", "cont", "it", "g", "transform", "msg", "est", "max", "comb", "copy", "coord", "test", "gest", "sup", "sort", "source", "config", "master", "lit", "v", "table", "rest", "output", "reverse", "shift"], "slice_data_start": ["slice_data__offset", "slice_image2id", "slice_data2end", "slice_data1start", "slice_data__end", "slice_data2id", "slice_data__first", "slice_data__start", "slice_data_first", "slice_data_id", "slice_data_offset", "slice_DATA_offset", "slice_DATA_start", "slice_image2start", "slice_data1end", "slice_data2start", "slice_image_start", "slice_data1first", "slice_image_end", "slice_DATA_first", "slice_image2end", "slice_image_id", "slice_DATA_end", "slice_data1offset"], "slice_data_end": ["slice_no_end", "slice_data____end", "jpg", "slice_no_head", "conv", "slice_data_index", "slice_no_index", "slice_data_e", "slice_data____index", "slice_data_head", "vec", "def", "img", "xy", "slice_data___end", "cont", "slice_data_max", "slice_data___index", "slice_data___head", "slice_data____head", "func", "slice_no_start", "slice_data___start", "_", "slice_data____start"], "slice_size": ["slice_offset", "slice_name", "slice_number", "tile_size", "slice_count", "tile_offset", "slice_shape", "tile_count", " slice_name", " slice_shape", "tile_number"]}}
{"project": "FFmpeg", "commit_id": "81a8701eb52d2b6469ae16ef442ce425388141b7", "target": 0, "func": "static int ogg_buffer_data(AVFormatContext *s, AVStream *st,\n\n                           uint8_t *data, unsigned size, int64_t granule,\n\n                           int header)\n\n{\n\n    OGGStreamContext *oggstream = st->priv_data;\n\n    OGGContext *ogg = s->priv_data;\n\n    int total_segments = size / 255 + 1;\n\n    uint8_t *p = data;\n\n    int i, segments, len, flush = 0;\n\n\n\n    // Handles VFR by flushing page because this frame needs to have a timestamp\n\n    // For theora, keyframes also need to have a timestamp to correctly mark\n\n    // them as such, otherwise seeking will not work correctly at the very\n\n    // least with old libogg versions.\n\n    // Do not try to flush header packets though, that will create broken files.\n\n    if (st->codec->codec_id == AV_CODEC_ID_THEORA && !header &&\n\n        (ogg_granule_to_timestamp(oggstream, granule) >\n\n         ogg_granule_to_timestamp(oggstream, oggstream->last_granule) + 1 ||\n\n         ogg_key_granule(oggstream, granule))) {\n\n        if (oggstream->page.granule != -1)\n\n            ogg_buffer_page(s, oggstream);\n\n        flush = 1;\n\n    }\n\n\n\n    // avoid a continued page\n\n    if (!header && oggstream->page.size > 0 &&\n\n        MAX_PAGE_SIZE - oggstream->page.size < size) {\n\n        ogg_buffer_page(s, oggstream);\n\n    }\n\n\n\n    for (i = 0; i < total_segments; ) {\n\n        OGGPage *page = &oggstream->page;\n\n\n\n        segments = FFMIN(total_segments - i, 255 - page->segments_count);\n\n\n\n        if (i && !page->segments_count)\n\n            page->flags |= 1; // continued packet\n\n\n\n        memset(page->segments+page->segments_count, 255, segments - 1);\n\n        page->segments_count += segments - 1;\n\n\n\n        len = FFMIN(size, segments*255);\n\n        page->segments[page->segments_count++] = len - (segments-1)*255;\n\n        memcpy(page->data+page->size, p, len);\n\n        p += len;\n\n        size -= len;\n\n        i += segments;\n\n        page->size += len;\n\n\n\n        if (i == total_segments)\n\n            page->granule = granule;\n\n\n\n        if (!header) {\n\n            AVStream *st = s->streams[page->stream_index];\n\n\n\n            int64_t start = av_rescale_q(page->start_granule, st->time_base,\n\n                                         AV_TIME_BASE_Q);\n\n            int64_t next  = av_rescale_q(page->granule, st->time_base,\n\n                                         AV_TIME_BASE_Q);\n\n\n\n            if (page->segments_count == 255 ||\n\n                (ogg->pref_size     > 0 && page->size   >= ogg->pref_size) ||\n\n                (ogg->pref_duration > 0 && next - start >= ogg->pref_duration)) {\n\n                ogg_buffer_page(s, oggstream);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (flush && oggstream->page.granule != -1)\n\n        ogg_buffer_page(s, oggstream);\n\n\n\n    return 0;\n\n}\n", "idx": 14865, "substitutes": {"s": ["bs", "h", "fs", "ans", "rs", "sn", "sb", "sl", "ops", "ses", "out", "S", "os", "so", "src", "c", "sv", "ps", "ss", "sys", "es", "ssl", "ls", "erences", "gs", "b", "ats", "its", "js", "sp", "g", "sw", "ys", "t", "ds", "self", "scl", "se", "ts", "sc", "a", "stat", "sm", "v", "stats", "stream", "ns", "sts"], "st": ["ST", "h", "d", "sn", "std", "stop", "sb", "th", "St", "art", "nd", "sl", "ast", "so", "src", "sv", "ist", "c", "ste", "ss", "ost", "ust", "set", "sty", "start", "sec", "sp", "stable", "str", "sh", "sw", "est", "stage", "ct", "mt", "sta", "inst", "t", "tt", "se", "ts", "sc", "rt", "sm", "stat", "rest", "spect", "stream", "irst", "sts"], "data": ["device", "d", "cache", "type", "image", "bytes", "map", "join", "Data", "content", "DATA", "padding", "memory", "format", "results", "value", "next", "feed", "buf", "init", "ata", "rew", "message", "start", "batch", "empty", "key", "raw", "name", "read", "pos", "window", "buffer", "block", "done", "to", "mode", "id", "offset", "bin", "t", "text", "base", "table", "first", "length", "dat", "delay"], "size": ["send", "status", "padding", "memory", "space", "message", "storage", "pos", "g", "use", "description", "offset", "scroll", "Size", "stream", "ize", "cache", "style", "score", "number", "position", "set", "zero", "start", "height", "timeout", "name", "member", "buffer", "sp", "to", "duration", "limit", "en", "fee", "length", "notice", "delay", "shape", "sum", "resolution", "l", "bytes", "summary", "small", "usage", "si", "empty", "count", "total", "index", "max", "pi", "area", "equal", "n", "SIZE", "time", "z", "scale", "capacity", "speed", "now", "e", "window", "spec", "id", "see", "body", "shift"], "granule": ["capsul", "granuler", "granle", "ranule", "capsuler", "vanule", "mnule", "severieval", "gnulo", "vanularity", "vanulo", "gunestyle", "ganularity", "ganuler", "gunle", "gunul", "ranular", "gunule", "circularity", "granestyle", "gunular", "granul", "ranul", "genle", "genul", "granulo", "circieval", "granular", "granularity", "ranestyle", "mnul", " granularity", "ranieval", "genularity", "ranularity", " granieval", "ganul", "circule", "gunulo", "gnule", "severulate", " granul", " granULE", "ganule", "ranulo", " granulate", "mnle", "gnular", "gnul", "capsularity", "gunieval", "gunularity", "genule", " granuler", "circULE", "granieval", "ranULE", "granulate", "severule", "capsule", "vanestyle", "mnularity", "granULE", "gunulate", "severularity"], "header": ["event", "h", "timer", "version", "player", "parent", "hidden", "padding", "server", "peer", "error", "hash", "priority", "title", "headers", "protection", "er", "filter", "border", "zero", "client", "empty", "dr", "flag", "writer", "window", "Header", "holder", "rule", "buffer", "block", "shift", "iler", "offset", "magic", "comment", "scroll", "vector", "layer", "order", "required", "handler", "ter", "debug", "body", "heading", "head", "table", "drm", "stream", "tail"], "oggstream": ["aggconsole", "aggserver", "oggdriver", "umbleStream", "ircstream", "obbpipe", "assembserver", "audstack", "awkstream", "ggconsole", "angstream", "ggstream", "obbsocket", "bbsocket", "oggsocket", "ogasync", "obbpoll", "obbline", "oggline", "oggstyle", "audserver", "ogStream", "obbstream", "obbsync", "ogstream", "ircpoll", "oggleconnection", "oggsync", "obbclean", "aggstyle", "ggStream", "oggStream", "bbthread", "ogglepoll", "readableconsole", "awkserver", "aggStream", "ggpoll", "oggclean", "ggcontext", "obbform", "readablethread", "oglStream", "assembclean", "oggleline", "bbcontext", "oggpoll", "oggform", "awkconsole", "oggedpipe", "angsync", "ogdriver", "ogpoll", "ggdriver", "oggconsole", "obbstyle", "ggsocket", "audconsole", "oggleStream", "ggconnection", "ircdriver", "ogconsole", "ircconsole", "readableStream", "ogglestream", "obbcontext", "umblestream", "oggconnection", "umbleconsole", "ogastream", "ogform", "oggedstream", "angStream", "ggform", "ggsync", "ggclean", "obbdriver", "angconnection", "oggleconsole", "ogthread", "oglproc", "ggserver", "aggstack", "oggpipe", "umblestyle", "readablestream", "oggledriver", "oggserver", "oglstream", "awkstack", "obbserver", "aggstream", "obbStream", "audstream", "oggedpoll", "oggstack", "ogastyle", "oggthread", "ggproc", "ogglestyle", "assembstream", "obbproc", "oglstyle", "ogglesync", "bbstream", "ggstyle", "oggcontext", "bbStream", "oggedStream", "assembStream", "ogaline", "bbconsole", "ggpipe", "oggproc"], "ogg": ["audio", "oc", "mpeg", "asc", "gg", "orm", "aud", "ost", "ink", "ib", "ssl", "ream", "buff", "gs", "pg", "pdf", "bb", "eg", "ocr", "og", "ik", "tt", "sc", "ob", "pp", "peg", "stat", "ht", "ga"], "p": ["h", "d", "fp", "jp", "l", "lp", "pc", "pe", "dp", "pa", "ip", "np", "c", "q", "cp", "ps", "u", "ap", "pl", "m", "ptr", "pb", "vp", "pos", "b", "tp", "buffer", "sp", "P", "g", "it", "j", "offset", "t", "pt", "pr", "o", "a", "pp", "pi", "v", "f"], "i": ["qi", "iq", "h", "ind", "l", "ai", "ii", "n", "gi", "di", "x", "sim", "go", "cli", "ip", "u", "ti", "li", "hi", "I", "ei", "si", "m", "im", "multi", "e", "b", "in", "iter", "index", "iu", "id", " ii", "it", "g", "j", "me", "ci", "xi", "ic", "t", "phi", "zi", "ix", "mi", "is", "pi", "y", "v", "bi", "ini", "ui"], "segments": ["seements", "pements", "psegments", "telements", "pegins", "begs", "eslements", "veges", "esgements", "beges", "tegments", "elegments", "nelements", "peges", "vegements", "egment", "tegements", "esgs", "bements", "seelements", "vements", "psements", "segements", "tements", "selements", " selements", "pegments", "pegements", "pseges", " segs", "tegs", " seges", "seeges", "esgments", "ements", "gegments", "negements", " segements", "vegment", "psegements", "tegment", "elegements", "esges", "begments", "sectors", "negments", "sements", "seegments", "geges", "gements", "segins", "pegment", "eleges", "nements", "vegins", "egments", "esctors", "segment", "vectors", "psegs", "velements", "elements", "pegs", "gegements", "vegments", "segs", " segment", " sements", "seges", "teges", "psegins", "psectors", "vegs"], "len": ["lis", "l", "lp", "n", "elt", "bytes", "bl", "sl", "lt", "full", "cmp", "lin", "loc", "kl", "vec", "ls", "pos", "mem", "ln", "lon", "sp", "str", "lf", "limit", "coll", "offset", "ml", "L", "lim", "en", "ler", "seq", "el", "fl", "nl", "t", "late", "ll", "il", "fin", "lang", "val", "lit", "le", "Len", "length", "lan", "label", "tail"], "page": ["view", "image", "map", "memory", "server", "peak", "error", "pool", "frame", "message", "this", "article", "pg", "rule", "instance", "record", "offset", "mark", "phase", "stream", "wait", "button", "event", "cache", "delete", "word", "group", "next", "draw", "number", "filter", "position", "start", "statement", "site", "code", "buffer", "request", "sp", "line", "limit", "comment", "order", "file", "link", "stat", "policy", "command", "form", "menu", "child", "web", "version", "parent", "pe", "node", "session", "tab", "vote", "average", "pl", "batch", "key", "count", "response", "block", "total", "index", "layout", "step", "office", "Page", "pixel", "pp", "pty", "queue", "phrase", "search", "address", "point", "go", "pages", "result", "new", "document", "age", "list", "port", "entry", "window", "pointer", "module", "see", "me", "row", "date", "section", "table", "pee", "cycle", "post", "pm"]}}
{"project": "FFmpeg", "commit_id": "38bb5a5434f913451aa512624a92b12b9925690f", "target": 0, "func": "void mpeg4_encode_picture_header(MpegEncContext * s, int picture_number)\n\n{\n\n    int time_incr;\n\n    int time_div, time_mod;\n\n\n\n    if(s->pict_type==AV_PICTURE_TYPE_I){\n\n        if(!(s->flags&CODEC_FLAG_GLOBAL_HEADER)){\n\n            if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT) //HACK, the reference sw is buggy\n\n                mpeg4_encode_visual_object_header(s);\n\n            if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT || picture_number==0) //HACK, the reference sw is buggy\n\n                mpeg4_encode_vol_header(s, 0, 0);\n\n        }\n\n        if(!(s->workaround_bugs & FF_BUG_MS))\n\n            mpeg4_encode_gop_header(s);\n\n    }\n\n\n\n    s->partitioned_frame= s->data_partitioning && s->pict_type!=AV_PICTURE_TYPE_B;\n\n\n\n    put_bits(&s->pb, 16, 0);                /* vop header */\n\n    put_bits(&s->pb, 16, VOP_STARTCODE);    /* vop header */\n\n    put_bits(&s->pb, 2, s->pict_type - 1);  /* pict type: I = 0 , P = 1 */\n\n\n\n    assert(s->time>=0);\n\n    time_div= s->time/s->avctx->time_base.den;\n\n    time_mod= s->time%s->avctx->time_base.den;\n\n    time_incr= time_div - s->last_time_base;\n\n    assert(time_incr >= 0);\n\n    while(time_incr--)\n\n        put_bits(&s->pb, 1, 1);\n\n\n\n    put_bits(&s->pb, 1, 0);\n\n\n\n    put_bits(&s->pb, 1, 1);                             /* marker */\n\n    put_bits(&s->pb, s->time_increment_bits, time_mod); /* time increment */\n\n    put_bits(&s->pb, 1, 1);                             /* marker */\n\n    put_bits(&s->pb, 1, 1);                             /* vop coded */\n\n    if (    s->pict_type == AV_PICTURE_TYPE_P\n\n        || (s->pict_type == AV_PICTURE_TYPE_S && s->vol_sprite_usage==GMC_SPRITE)) {\n\n        put_bits(&s->pb, 1, s->no_rounding);    /* rounding type */\n\n    }\n\n    put_bits(&s->pb, 3, 0);     /* intra dc VLC threshold */\n\n    if(!s->progressive_sequence){\n\n         put_bits(&s->pb, 1, s->current_picture_ptr->top_field_first);\n\n         put_bits(&s->pb, 1, s->alternate_scan);\n\n    }\n\n    //FIXME sprite stuff\n\n\n\n    put_bits(&s->pb, 5, s->qscale);\n\n\n\n    if (s->pict_type != AV_PICTURE_TYPE_I)\n\n        put_bits(&s->pb, 3, s->f_code); /* fcode_for */\n\n    if (s->pict_type == AV_PICTURE_TYPE_B)\n\n        put_bits(&s->pb, 3, s->b_code); /* fcode_back */\n\n}\n", "idx": 14872, "substitutes": {"s": ["bs", "webkit", "fs", "sg", "ties", "http", "ps", "args", "ms", "news", "ports", "js", "sw", "ex", "ares", "se", "tests", "y", "ins", "details", "h", "changes", "sb", "series", "ops", "results", "os", "als", "sv", "has", "er", "ches", "set", "m", "sports", "erences", "ges", "events", "as", "w", "ags", "states", "is", "source", "f", "ains", "parts", "ns", "tes", "mods", "l", "rs", "summary", "ions", "ies", "S", "c", "comm", "eps", "sys", "ls", "vs", "uploads", "hs", "ats", "its", "ims", "sq", "acs", "ts", "ows", "wcs", "bits", "qs", "oss", "ss", "sts", "aunts", "n", "ants", "z", "ses", "p", "es", "us", "aws", "gs", "b", "spec", "bis", "eds", "less", "cl", "ds", "cs", "comments", "v", "stats"], "picture_number": ["picture_column", "picture_num", "picture08column", "picture_type", "picture_nb", "picture___num", "picture___nb", "picture_volume", "picture08number", "picture___column", " picture_volume", " picture_num", "picture08num", " picture_type", " picture_column", "picture___number", "picture08nb", " picture_nb"], "time_incr": ["time_inccr", "time_incrc", "time_ignr", "time_ignre", "time_diffur", "time_inctr", "time_occrs", "time_ecrc", "time_incre", "time_occrc", "time_increrc", "time_INCcr", "time__incrs", "time_differ", "time_increr", "time_acccr", "time_supprs", "time_ignrd", "time_occcr", "time_accrd", "time_INCrd", "time_ecur", "time_incrs", "time_diffr", "time__acccr", "time_aggur", "time__incr", "time_suppr", "time_increcr", "time_incrd", "time_occur", "time_INCr", "time_increer", "time__inccr", "time_occr", "time__accrs", "time_supptr", "time_suppcr", "time__acctr", "time_igncr", "time_diffcr", "time_incur", "time__accr", "time_accre", "time_INCre", "time_agger", "time_occtr", "time_accr", "time__inctr", "time_aggr", "time_aggcr", "time_ecr", "time_ecer", "time_incer", "time_increur", "time_accrs", "time_acctr", "time_occer"], "time_div": [" time2con", "time2dev", "time12sub", "time_dec", "time62max", "time66dot", "time64dev", "ime_comm", " time_exp", "time_con", "time_dot", "time62div", " time_dec", " time_max", "time66div", " time2div", "time7div", "time_exp", "time66comm", "time62dec", " time_con", "time12dev", "ime_div", "time2sub", " time_dev", "time7dec", " time2dev", "time64sub", "time_max", "time2div", "time62exp", " time_sub", "time_comm", "time_sub", "time2con", "time7max", "time_dev", "time12con", "time12div", "ime_dot", "time64div", "time7exp", " time2sub", "time64con"], "time_mod": ["TIME_div", "time_dec", "time_orig", "time67max", "ime2step", "time2mod", "time2orig", "ime2orig", "time2dec", "ime_mod", "ime_orig", "time_req", "time67Mod", "time2step", "time5div", "time5mod", "ime2mod", "time2req", "ime_div", "time5step", "time67mod", "ime_max", "time_Mod", "time_max", "TIME_req", "time2div", "time67div", "time_step", "ime_step", "TIME_dec", "time5orig", "TIME_mod", "ime_Mod", "ime2div"]}}
{"project": "FFmpeg", "commit_id": "0273ceebbd01f9fd5238558e6151e0b9aa3305ab", "target": 0, "func": "static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, \n\n                      int nb_codes)\n\n{\n\n    uint8_t huff_size[256];\n\n    uint16_t huff_code[256];\n\n\n\n    memset(huff_size, 0, sizeof(huff_size));\n\n    build_huffman_codes(huff_size, huff_code, bits_table, val_table);\n\n    \n\n    init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2);\n\n}\n", "idx": 14884, "substitutes": {"vlc": ["lvc", "wlv", "flcs", "ell", "elcs", "flt", "vrc", "lvcs", "wlc", "elc", "vrt", "flv", "vlvc", "lvl", "wll", "vrv", "flc", "wlvc", "elvc", "wlt", "vrcs", "vlv", "vlcs", "lvvc", "wlcs", "vlt", "vll"], "bits_table": ["bitsingtable", "bits_code", "bitslytable", "bitsitycode", "bitsitylist", "bitslylist", "bitsingt", "bits_tmp", "bitsitytable", "bits_iterator", "bitslycode", " bits_t", "bitsingiterator", "bits_list", "bitsinglist", " bits_iterator", " bits_code", "bitsitytmp", " bits_tmp", " bits_list", "bits_t", "bitslytmp"], "val_table": ["valisttable", "valistpublic", "val_public", "vals_table", "valistlist", " val_tab", "vals_list", "vals_tab", " val_TABLE", "val_tab", " val_list", "vals_public", "valisttab", "val_TABLE", "val_list"], "nb_codes": ["nbphpcode", "nb_code", "nbphplevels", "num_code", " ng_codes", " ng_levels", "nb__code", " ngphpcodes", "num_codes", " ngphpcode", "nb_lines", " ng_code", "nb__lines", "nb__codes", " ng_terms", " ngphpterms", "nb_levels", "num_lines", "nb_terms", "nbphpcodes", " ngphplevels", "nbphpterms"], "huff_size": ["huffitysmall", "huff_global", "huf_size", "huff_name", "hood_small", "hooditysmall", "huff_info", "huffLSize", "huf_info", "hooditycode", "huf_window", "huffitycode", "hood_size", "huffLwindow", "huff_storage", "hooditystorage", "hood_storage", "huff_window", "huff_small", "huffLsize", "huf_name", "huf_city", "huff_Size", "huffitysize", "huf_Size", "huf_global", "huff_city", "huffitystorage", "huffLinfo", "hood_code", "huf_code", "huffLcode", "hooditysize"], "huff_code": ["huf_size", "huff__code", "huff_error", "huf_type", "huff_Code", "hufflnumber", "huff__error", "hufflsize", "huff__data", "hUFF_error", "huff_func", "huff_number", "hUFF_func", "huff8data", "huff_type", "hUFF__data", "huff8Code", "huff8error", "hUFF_code", "huf_code", "hUFF_Code", "hufflcode", "hUFF__Code", "hUFF__error", "hUFF_number", "huf_data", "hUFF_size", "hufflfunc", "huff__Code", "hUFF__code", "huff_data", "huff8code", "hUFF_data"]}}
{"project": "qemu", "commit_id": "4d68e86bb10159099da0798f74e7512955f15eec", "target": 0, "func": "void qemu_coroutine_adjust_pool_size(int n)\n\n{\n\n    qemu_mutex_lock(&pool_lock);\n\n\n\n    pool_max_size += n;\n\n\n\n    /* Callers should never take away more than they added */\n\n    assert(pool_max_size >= POOL_DEFAULT_SIZE);\n\n\n\n    /* Trim oversized pool down to new max */\n\n    while (pool_size > pool_max_size) {\n\n        Coroutine *co = QSLIST_FIRST(&pool);\n\n        QSLIST_REMOVE_HEAD(&pool, pool_next);\n\n        pool_size--;\n\n        qemu_coroutine_delete(co);\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool_lock);\n\n}\n", "idx": 14904, "substitutes": {"n": ["dn", "i", "d", "l", "sn", " N", "k", "z", "x", "nan", "number", "c", "u", "cn", "p", "s", "an", "m", "nm", "N", "ln", "b", "nt", "names", "count", "na", "w", "g", "j", "nn", "num", "en", "ity", "nl", "t", "nc", "o", "a", "y", "v", " fn", "ns"], "pool_size": ["memory_capacity", "policypromax", "policyprosize", "pool_capacity", "poolprosize", "poolablesize", "poolleSIZE", "memorylesize", "policyproSIZE", "policy_max", "poolableSIZE", "pool_storage", "memory_storage", "poolablecapacity", "poollestorage", "poolpromax", "poollesize", "policy_size", "policy_limit", "memory_SIZE", "poolprolimit", "pool_max", "poollecapacity", "pool_limit", "memoryleSIZE", "poolproSIZE", "memorylestorage", "poolablestorage", "memorylecapacity", "pool_SIZE", "policy_SIZE", "policyprolimit", "memory_size"], "co": ["oc", "con", "ano", " Co", "pc", "ko", "lc", "gro", "so", "xc", "roo", "cu", "cons", "pl", "oo", "fo", "mo", "cover", "bo", "lo", "cc", "ro", "occ", "coll", "cho", "wo", "ico", "aco", "coe", "cro", "coord", "po", "CO", "nc", "fc", "o", "Co", "flo", "vo"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void rndis_clear_responsequeue(USBNetState *s)\n\n{\n\n    struct rndis_response *r;\n\n\n\n    while ((r = s->rndis_resp.tqh_first)) {\n\n        TAILQ_REMOVE(&s->rndis_resp, r, entries);\n\n        qemu_free(r);\n\n    }\n\n}\n", "idx": 14911, "substitutes": {"s": ["bs", "h", "d", "fs", "rs", "n", "sb", "serv", "ops", "ses", "als", "os", "S", "sv", "ps", "ss", "comm", "p", "sys", "ls", "vs", "hs", "aws", "gs", "ats", "b", "its", "js", "as", "j", "sq", "less", "ares", "ds", "states", "ts", "is", "stats", "ns", "sts"], "r": ["h", "i", "d", "l", "rs", "br", "rb", "re", "run", "result", "ar", "rf", "q", "u", "c", "er", "p", "ru", "m", "R", "dr", "ren", "ry", "rd", "repl", "b", "e", "rc", "rr", "ro", "rg", "g", "res", "rn", "rl", "j", "fr", "rar", "rm", "sr", "mr", "t", "vr", "pr", "rw", "rt", "v", "rec", "lr", "rus", "rem"]}}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)\n\n{\n\n#if HAVE_YASM\n\n    int mm_flags = av_get_cpu_flags();\n\n\n\n    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {\n\n#if ARCH_X86_32\n\n        if (mm_flags & AV_CPU_FLAG_MMX) {\n\n            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;\n\n        }\n\n#endif\n\n\n\n        if (mm_flags & AV_CPU_FLAG_SSE2) {\n\n            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 14913, "substitutes": {"c": ["abc", "h", "d", "ch", "cache", "con", "container", "bc", "lc", "dc", "etc", "cm", "cp", "conf", "p", "cam", "m", "C", "b", "e", "tc", "cc", "rc", "com", "ctx", "gc", "cv", "ce", "cf", "coll", "ct", "anc", "enc", "ec", "t", "ca", "cs", "fc", "nc", "config", "o", "a", "ac", "cr", "v", "f", "co"], "codec": ["codocol", "Cododer", "Codocol", "choocol", "cpec", "cododer", "cpocol", "choEC", "codEC", "codeisc", "Codec", "CodEC", "chooder", "codeoc", "Codisc", "cpEC", "codisc", "codeEC", "cpoder", "codoc", "Codoc", " codEC", " codisc", " codoc", "choec", "codeec"]}}
{"project": "qemu", "commit_id": "b769d8fef6c06ddb39ef0337882a4f8872b9c2bc", "target": 0, "func": "int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int rw,\n\n                              int is_user, int is_softmmu)\n\n{\n\n    uint32_t physical;\n\n    int prot;\n\n    int exception = 0, error_code = 0;\n\n    int access_type;\n\n    int ret = 0;\n\n\n\n//    printf(\"%s 0\\n\", __func__);\n\n    access_type = env->access_type;\n\n    if (env->user_mode_only) {\n\n        /* user mode only emulation */\n\n        ret = -2;\n\n        goto do_fault;\n\n    }\n\n    /* NASTY BUG workaround */\n\n    if (access_type == ACCESS_CODE && rw) {\n\n\tprintf(\"%s: ERROR WRITE CODE ACCESS\\n\", __func__);\n\n\taccess_type = ACCESS_INT;\n\n    }\n\n    ret = get_physical_address(env, &physical, &prot,\n\n                               address, rw, access_type);\n\n    if (ret == 0) {\n\n\tret = tlb_set_page(env, address & ~0xFFF, physical, prot,\n\n\t\t\t   is_user, is_softmmu);\n\n    } else if (ret < 0) {\n\n    do_fault:\n\n#if defined (DEBUG_MMU)\n\n\tif (loglevel > 0)\n\n\t    cpu_ppc_dump_state(env, logfile, 0);\n\n#endif\n\n        if (access_type == ACCESS_CODE) {\n\n            exception = EXCP_ISI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables */\n\n                error_code = EXCP_ISI_TRANSLATE;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = EXCP_ISI_PROT;\n\n                break;\n\n            case -3:\n\n\t\t/* No execute protection violation */\n\n                error_code = EXCP_ISI_NOEXEC;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                /* No code fetch is allowed in direct-store areas */\n\n                error_code = EXCP_ISI_DIRECT;\n\n                break;\n\n            }\n\n        } else {\n\n            exception = EXCP_DSI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables */\n\n                error_code = EXCP_DSI_TRANSLATE;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = EXCP_DSI_PROT;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    /* Floating point load/store */\n\n                    exception = EXCP_ALIGN;\n\n                    error_code = EXCP_ALIGN_FP;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    /* lwarx, ldarx or srwcx. */\n\n                    exception = EXCP_DSI;\n\n                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT;\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    exception = EXCP_DSI;\n\n                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT |\n\n\t\t\tEXCP_DSI_ECXW;\n\n                    break;\n\n                default:\n\n\t\t    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    exception = EXCP_PROGRAM;\n\n                    error_code = EXCP_INVAL | EXCP_INVAL_INVAL;\n\n                    break;\n\n                }\n\n            }\n\n            if (rw)\n\n                error_code |= EXCP_DSI_STORE;\n\n\t    /* Store fault address */\n\n\t    env->spr[DAR] = address;\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\",\n\n               __func__, exception, error_code);\n\n#endif\n\n        env->exception_index = exception;\n\n        env->error_code = error_code;\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 14936, "substitutes": {"env": ["dn", "context", "esm", "end", "ve", "tmp", "server", "rb", "next", "setup", "cur", "nv", "addr", "cp", "hw", "conf", "eng", "er", "enter", "environment", "org", "store", "ptr", "vs", "et", "vp", "desc", "te", "viron", "ah", "e", "dev", "db", "window", "code", "vt", "ctx", "rc", "cv", "erd", "shell", "sp", "ev", "manager", "ew", "sw", "entry", "era", "en", "conn", "gate", "esc", "nc", "equ", "inv", "cmd", "v", "obj", "vm"], "address": ["context", "device", "page", "route", "Address", "memory", "ip", "password", "addr", "resource", "adr", "interface", "message", "position", "r", "host", "ptr", "add", "private", "handle", "port", "array", "network", "reference", "buffer", "attribute", "pointer", "index", "object", "path", "exclusive", "record", "uri", "range", "description", "offset", "relative", "order", "table", "command", "location"], "rw": ["wind", "rs", "req", "route", "nw", "rb", "addr", "rf", "hw", "rew", "rights", "wp", "ru", "r", "ptr", "raw", "rd", "wer", "wr", "mem", "window", "rh", "nr", "w", "wa", "ro", "ew", "range", "sw", "access", "row", "nb", "username", "RW", "work", "fw", "aw", "write", "rt", "wx", "wb", "wd", "aux"], "is_user": ["is_usr", "is_User", "is2usr", " is_usr", " is_or", " is_User", "is2User", "isdbUser", "is_or", "isdbusr", "is2user", "isdbuser"], "is_softmmu": ["is_southmmu", "is_softmmuit", "is_southmciu", "is_softMMu", "is_softmmus", "is_Softmmus", "is_softMMU", "is_SoftMMU", "is_SoftMMus", "is_southmcuit", "is_softmemU", "is_softtmu", "is_softtmuit", "is_Softmmu", "is_softmemus", "is_softmemo", "is_softmmo", "is_southmcu", "is_softtmiu", "is_southmmiu", "is_SoftMMo", "is_softmciu", "is_Softmmo", "is_southmmuit", "is_softMMus", "is_softmcu", "is_softmmU", "is_SoftMMu", "is_softmcuit", "is_softmmiu", "is_SoftmmU", "is_softMMo", "is_softmemu"], "physical": ["ref", "type", "prefix", "itary", "pc", "local", "serial", "restricted", "specific", "http", "resource", "np", "hw", "information", "p", "host", "ptr", "private", "pro", "raw", "wm", "port", "health", "target", "console", "tp", "ocol", "network", "real", "total", "pointer", "index", "path", "protected", "primary", "Physical", "public", "relative", "binary", "phys", "hid", "net", "pixel", "phy", "program", "config", "checked", "base", "virtual", "native"], "prot": ["iot", "type", "prop", "version", "inet", "afi", "format", "transfer", "ip", "col", "top", "supported", "np", "ort", "tif", "tf", "ptr", "tech", "pro", "port", "chron", "ports", "tp", " PROT", "ocol", "pattern", "eth", "mobile", "platform", "protected", "primary", "rot", "binary", "typ", "phys", "test", "net", "phy", "prototype", "virtual", "Prot", "io", "reset"], "access_type": ["access_color", " access_types", "access2Type", "accessingtype", "accessibleedcolor", "accessetytype", " access_length", "accesstypepost", "accessible_length", "accessetypost", "accessTypeoperator", "accessTypename", "accessibleedlength", "usageingpost", "accessetyTYPE", "access_types", "accesstypetyp", "accessetymode", "access___Type", "access___type", "accessible_TYPE", "access___types", "usageingmode", "accessingpost", "usage_typ", " access_field", "accessTypeType", "accesstypetype", "usage_mode", "access_Type", "accesstypemode", "access_method", " access_TYPE", "usage_post", "accessingTYPE", "accessibleedtype", "accessetyType", "access_name", "Access_name", "accessetylength", "accessingcolor", "usage_type", "accessetymethod", "access___rule", "accessingtyp", "accessTypetype", "accessedlength", "access2name", "accessible_color", "access_operator", "accessible_type", "accessinglength", "Access_Type", " access_rule", "access_post", "access2type", "accessetytyp", "accessibleedTYPE", "usageingtype", "access_TYPE", " access_status", "access_field", "accessedtype", "access_typ", "usageingtyp", "access_mode", "Access_operator", "access_status", "accessedcolor", "Access_type", " access_name", "accessingmode", "accessedTYPE", "access_length", " access_Type", " access_method", "access_rule", "accessetyfield"]}}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){\n\n    int y;\n\n    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;\n\n    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;\n\n\n\n    for(y=-2; y<height; y+=2){\n\n        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;\n\n        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;\n\n\n\n{START_TIMER\n\n        if(b1 <= b3)     horizontal_decompose53i(b2, width);\n\n        if(y+2 < height) horizontal_decompose53i(b3, width);\n\nSTOP_TIMER(\"horizontal_decompose53i\")}\n\n\n\n{START_TIMER\n\n        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);\n\n        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);\n\nSTOP_TIMER(\"vertical_decompose53i*\")}\n\n\n\n        b0=b2;\n\n        b1=b3;\n\n    }\n\n}\n", "idx": 14942, "substitutes": {"buffer": ["device", "queue", "view", "cache", "page", "memory", "history", "header", "byte", "buf", "pool", "face", "screen", "background", "document", "bridge", "available", "uffer", "message", "allow", "position", "batch", "database", "buff", "port", "b", "window", "seek", "match", "iter", "block", "reference", "surface", "Buffer", "data", "scroll", "pixel", "program", "v", "table", "length", "texture", "button"], "height": ["shape", "h", "rank", "resolution", "ch", "view", "kw", "power", "angle", "type", "SIZE", "ty", "th", "status", "style", "padding", "history", "above", "hash", "depth", "density", "important", " Height", "H", "capacity", "family", "Height", "through", "hang", "kh", "oom", "TH", "window", "count", "gravity", "volume", "id", "size", "html", "rows", " heights", "grow", "row", "inches", "t", "stroke", "bottom", "hei", "ows", "sky", "high", "scope", "wh", "length", "visible", "ht", "headers", "yt", "alpha"], "stride": ["STRade", "strpe", "Strend", "striide", " strride", "stripe", "Strify", "strine", "strade", "stide", "drride", "stringension", "stify", "strride", "Strpe", "struse", "STRge", " strine", "strge", "stpe", "drend", "strension", "strage", "Strension", "STRride", "druse", "strify", "Strade", "stend", "stringide", "stension", "Strine", "stage", "stringify", "stade", "Stride", "STRide", "striend", " strage", "stringride", "Struse", "stine", "dride", "Strride", "Strge", "strend", "stuse", "stge", "striuse", "Strage"], "y": ["ey", "ch", "vy", " ey", "lat", "dy", "uy", "icy", "ym", "ry", " ly", "sat", "my", "ay", " my", " dy", "ley", "h", " Y", "py", "ye", "ady", "iy", "yo", "sy", "m", "ot", "j", " ch", "try", "t", " x", "ery", "by", " i", "yt", "ny", " ty", "ind", "type", "ly", "ty", "x", "ies", "cy", " h", "asy", " py", "key", "yout", " v", "gy", "axy", "oy", "yr", "sky", "i", "yi", "aily", " cy", "z", "sim", "col", " j", " by", "hey", "now", " key", "yer", "xy", "ya", "row", "yl", "yy", " yo", "Y", "v", " err"], "b0": ["be3", "v3", "cb0", "v1", "bc1", "bc0", " b000", "h3", "cb00", "cb1", "bc2", "v0", "harg", "bb3", "B00", " barg", "bb000", "be1", "b000", "bb0", "h0", "bearg", "b00", "bb00", "bc000", "bb2", "p3", "p0", "barg", "B0", "p1", "B3", "h2", "v2", "cb3", "B1", "h1", "bb1", "be0", "p2"], "b1": ["e2", "b8", "bb9", "br7", " b4", "a1", "bb001", "back3", "B2", "bbone", " b001", "brone", "B8", " b7", "a0", "e9", "bb01", "bb8", "br01", "bb3", "back001", "br4", "b4", "p2", "back1", " b01", "b01", "bb2", "p3", " b9", "a2", "p0", "bone", "B0", "p1", "B3", "br2", "b9", "a3", " bone", " b8", "B1", "bb4", "b7", "bb1", "e1", "br1", "e01", "bb7", "b001"], "b2": ["v3", "eb2", "fb2", " b4", "l1", "back0", "back3", " b5", "v1", "l2", "fb1", "B2", "a1", "bb02", "ltwo", "a0", "v0", "sb2", "bb3", "bb5", "sb02", "back2", "gbtwo", "b4", "eb5", "ebTwo", "bb0", "bbtwo", "backtwo", "bb2", "p3", "a02", "btwo", "a2", "fbtwo", " bTwo", "p0", "l3", "sb0", "B0", "p1", "B3", "eb1", "bbTwo", "vtwo", "gb4", "v2", "gb2", "bTwo", "B1", "fb3", "gb1", "bb4", "bb1", "b5", "sb1", "p2", "b02", " btwo"], "b3": ["be3", "bo3", "be2", "bg2", "cb7", "bb23", "bb5", "b512", "p3", "bd7", "aThree", "wb3", "bThree", "wb63", "b7", "b5", "bthree", "ba512", "wbthree", "b23", "bo512", "rbthree", "be53", "b4", "sb03", "rb2", "bg4", "bb63", "bb03", "be4", "ba3", "b63", "rb03", "bbthree", " bthree", " b7", "rb3", "bg53", "sb2", "bg3", "bothree", "bb2", "bdthree", "b53", "b03", "ba2", "betaThree", "bdThree", "bathree", "p2", "beta5", "beta3", "bd3", "a1", "ba23", "wb23", "bb3", "cbthree", "sbthree", "sb3", "p4", "bbThree", "a5", "beta1", "p53", "cbThree", "a3", "bo2", "cb3", " bThree", "ba63", "bb1", " b512"]}}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    int ret, fd;\n\n    unsigned int datalen;\n\n\n\n    if (offset < s->inode.vdi_size) {\n\n        error_report(\"shrinking is not supported\");\n\n        return -EINVAL;\n\n    } else if (offset > SD_MAX_VDI_SIZE) {\n\n        error_report(\"too big image size\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n    s->inode.vdi_size = offset;\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    close(fd);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to update an inode.\");\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 14951, "substitutes": {"bs": ["bos", "fs", "rs", "sb", "aos", "bc", "bf", "os", "als", "bes", "aus", "bh", "vs", "ls", "hs", "gs", "b", "its", "js", "iss", "lbs", "bb", "bis", "bas", "cks", "BS", "ds", "ubs", "bp", "cs", "ts", "ils", "bits", "bi", "bm", "ns", "ss"], "offset": ["before", "ref", "expected", "end", "address", "prefix", "padding", "Offset", "point", "off", "error", "slot", "addr", "alias", "loc", "set", "position", "zero", "start", "from", "skip", "key", "origin", "timeout", "pos", "entry", "trace", "seek", "count", "block", "offs", "pointer", "index", "to", "size", "url", "range", "after", "num", "row", "fee", "o", "pad", "ace", "length", "location", "mask", "reset", "shift"], "s": ["ps", "ms", "js", "sa", "services", "g", "sd", "gets", "ares", "y", "ins", "plays", "sis", "details", "h", "changes", "sb", "ops", "als", "sv", "m", "sports", "as", "sp", "states", "is", "south", "parts", "ns", "l", "rs", "sl", "ies", "S", "so", "c", "comm", "st", " ss", "sys", "ess", "ls", "hs", "ats", "its", "ims", "sq", "https", "ts", "bits", "a", "qs", "sts", "ss", "settings", "ses", "state", "p", "es", "sam", "xs", "aws", "gs", "b", "spec", "bis", "ds", "cs", "v", "stats", "w"], "ret": ["usr", "ft", "RET", "elt", "lt", "tn", "status", "out", "re", "reply", "result", "Ret", "ext", "del", "def", "xt", "arr", "r", "ptr", "tr", "leg", "flag", "alt", "att", "nt", "cert", "ert", "len", "por", "fun", "cont", "it", "res", "at", "back", "rm", "inter", "mt", "det", "gt", "try", "arg", "fin", "il", "ter", "rets", "ll", " Ret", "resp", "rt", "deg", "val", "cmd", "print", "f", "reset", "rem"], "fd": ["gd", "uf", "dn", "ff", "dl", "fs", "d", "fp", "ft", "raf", "hd", "fm", "endif", "fa", "dt", "tmp", "bf", "FD", "result", "pid", "cb", "tif", "dra", "bd", "df", "err", "ptr", "nil", "handle", "port", "tty", "ln", "fb", "pd", "nt", "db", "por", "fi", "fn", "ctx", "dd", "dir", "fun", "fe", "cf", "lf", "red", "disk", "fr", "func", "fail", "handler", "ds", "fin", "fed", "file", "fc", "cond", "resp", "ld", "ind", "f", "td", "cd", "dat", "gb", "failed"], "datalen": [" datalun", "dallize", "Datlength", "datlength", "tatalen", " datalist", "Datlun", "damelize", "datalef", "dalize", "tatalon", "damelun", "damelef", "datenun", "Datlize", "datlen", "dialen", "datalun", "datalon", "damelength", " damelength", " damelist", "datlun", "datlize", " damelen", "dalon", "datenength", "tamelize", "Datalun", "tatalize", "Datlen", " damelun", "dalength", "dialef", "tamelef", "dallength", "damelen", "damelon", "tamelon", "dallist", "dialon", "damelist", "Datalength", "tamelen", "dalun", "Datalize", "Datalen", " datalength", "tatalef", "datenen", "dalen", "dalef", "datalength", "datalize", "dallun", "dialize", "datenist", "dallen", "datalist"]}}
{"project": "qemu", "commit_id": "190563f9a90c9df8ad32fc7f3e4b166deda949a6", "target": 0, "func": "static int rndis_parse(USBNetState *s, uint8_t *data, int length)\n\n{\n\n    uint32_t msg_type;\n\n    le32 *tmp = (le32 *) data;\n\n\n\n    msg_type = le32_to_cpup(tmp);\n\n\n\n    switch (msg_type) {\n\n    case RNDIS_INITIALIZE_MSG:\n\n        s->rndis_state = RNDIS_INITIALIZED;\n\n        return rndis_init_response(s, (rndis_init_msg_type *) data);\n\n\n\n    case RNDIS_HALT_MSG:\n\n        s->rndis_state = RNDIS_UNINITIALIZED;\n\n        return 0;\n\n\n\n    case RNDIS_QUERY_MSG:\n\n        return rndis_query_response(s, (rndis_query_msg_type *) data, length);\n\n\n\n    case RNDIS_SET_MSG:\n\n        return rndis_set_response(s, (rndis_set_msg_type *) data, length);\n\n\n\n    case RNDIS_RESET_MSG:\n\n        rndis_clear_responsequeue(s);\n\n        s->out_ptr = s->in_ptr = s->in_len = 0;\n\n        return rndis_reset_response(s, (rndis_reset_msg_type *) data);\n\n\n\n    case RNDIS_KEEPALIVE_MSG:\n\n        /* For USB: host does this every 5 seconds */\n\n        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);\n\n    }\n\n\n\n    return USB_RET_STALL;\n\n}\n", "idx": 14982, "substitutes": {"s": ["bs", "fs", "sn", "space", "http", "ps", "r", "ms", "js", "g", "services", "sw", "tests", "y", "ins", "sync", "details", "h", "d", "changes", "sb", "os", "als", "sv", "er", "ches", "set", "ssl", "sports", "as", "j", "t", "is", "stat", "south", "ns", "l", "rs", "ads", "ies", "S", "c", "comm", "sys", "ls", "vs", "hs", "ats", "its", "ims", "sq", "ts", "qs", "sts", "ss", "n", "ses", "conf", "p", "es", "sam", "xs", "aws", "gs", "b", "spec", "bis", "less", "ds", "cs", "v", "stats", "w"], "data": ["device", "d", "cache", "ord", "advert", " DATA", "bytes", "extra", "trans", "partial", "Data", "ops", "nd", "DATA", "what", "error", "value", "buf", "input", "addr", "ata", "new", "rew", "ext", "message", "p", "def", "batch", "args", "empty", "da", "any", "raw", "received", "name", "chain", "window", "nt", "dev", "block", "buffer", "as", "done", "to", "size", "dump", "bin", "t", "attr", "apps", "test", "ds", "aw", "pad", "bits", "items", "text", "table", "form", "obj", "dat", "mu", "ns", "params"], "length": ["shape", "h", " len", "l", "type", "end", "address", "n", "join", "time", "partial", "Length", "z", "padding", "full", " l", "number", "ength", "enth", "message", "family", "capacity", "position", " clen", "height", "ptr", "idth", "ish", "frequency", "ENGTH", "count", "len", "buffer", "total", "size", "duration", "load", "offset", "amount", " lengths", "pad"], "msg_type": ["msg_size", " msg_name", "msg_Type", "msgTypesize", "msg_id", " msg_size", "msgTypeType", " msg_id", "cmp_type", "msg_name", "cmp_typ", "cmp_Type", "msgTypetype", " msg_Type", "msgTypename", "msg_typ", " msg_t", "msg_t"], "tmp": ["tv", "emp", "bytes", "partial", "txt", "temp", "etc", "buf", "cmp", "np", "important", "cb", "img", "mb", "mk", "same", "buff", "nt", "mp", "xy", "ctx", "sp", "mint", "aaa", "msg", "proc", "mm", "t", "attr", "yy", "tm", "tt", "lib", "sup", "perm", "needed", "stuff", "obj"]}}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static int sap_write_header(AVFormatContext *s)\n\n{\n\n    struct SAPState *sap = s->priv_data;\n\n    char host[1024], path[1024], url[1024], announce_addr[50] = \"\";\n\n    char *option_list;\n\n    int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;\n\n    AVFormatContext **contexts = NULL;\n\n    int ret = 0;\n\n    struct sockaddr_storage localaddr;\n\n    socklen_t addrlen = sizeof(localaddr);\n\n    int udp_fd;\n\n    AVDictionaryEntry* title = av_dict_get(s->metadata, \"title\", NULL, 0);\n\n\n\n    if (!ff_network_init())\n\n        return AVERROR(EIO);\n\n\n\n    /* extract hostname and port */\n\n    av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port,\n\n                 path, sizeof(path), s->filename);\n\n    if (base_port < 0)\n\n        base_port = 5004;\n\n\n\n    /* search for options */\n\n    option_list = strrchr(path, '?');\n\n    if (option_list) {\n\n        char buf[50];\n\n        if (av_find_info_tag(buf, sizeof(buf), \"announce_port\", option_list)) {\n\n            port = strtol(buf, NULL, 10);\n\n        }\n\n        if (av_find_info_tag(buf, sizeof(buf), \"same_port\", option_list)) {\n\n            same_port = strtol(buf, NULL, 10);\n\n        }\n\n        if (av_find_info_tag(buf, sizeof(buf), \"ttl\", option_list)) {\n\n            ttl = strtol(buf, NULL, 10);\n\n        }\n\n        if (av_find_info_tag(buf, sizeof(buf), \"announce_addr\", option_list)) {\n\n            av_strlcpy(announce_addr, buf, sizeof(announce_addr));\n\n        }\n\n    }\n\n\n\n    if (!announce_addr[0]) {\n\n        struct addrinfo hints = { 0 }, *ai = NULL;\n\n        hints.ai_family = AF_UNSPEC;\n\n        if (getaddrinfo(host, NULL, &hints, &ai)) {\n\n            av_log(s, AV_LOG_ERROR, \"Unable to resolve %s\\n\", host);\n\n            ret = AVERROR(EIO);\n\n            goto fail;\n\n        }\n\n        if (ai->ai_family == AF_INET) {\n\n            /* Also known as sap.mcast.net */\n\n            av_strlcpy(announce_addr, \"224.2.127.254\", sizeof(announce_addr));\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n        } else if (ai->ai_family == AF_INET6) {\n\n            /* With IPv6, you can use the same destination in many different\n\n             * multicast subnets, to choose how far you want it routed.\n\n             * This one is intended to be routed globally. */\n\n            av_strlcpy(announce_addr, \"ff0e::2:7ffe\", sizeof(announce_addr));\n\n#endif\n\n        } else {\n\n            freeaddrinfo(ai);\n\n            av_log(s, AV_LOG_ERROR, \"Host %s resolved to unsupported \"\n\n                                    \"address family\\n\", host);\n\n            ret = AVERROR(EIO);\n\n            goto fail;\n\n        }\n\n        freeaddrinfo(ai);\n\n    }\n\n\n\n    sap->protocols = ffurl_get_protocols(NULL, NULL);\n\n    if (!sap->protocols) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    contexts = av_mallocz(sizeof(AVFormatContext*) * s->nb_streams);\n\n    if (!contexts) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    s->start_time_realtime = av_gettime();\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        URLContext *fd;\n\n\n\n        ff_url_join(url, sizeof(url), \"rtp\", NULL, host, base_port,\n\n                    \"?ttl=%d\", ttl);\n\n        if (!same_port)\n\n            base_port += 2;\n\n        ret = ffurl_open(&fd, url, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL,\n\n                         sap->protocols);\n\n        if (ret) {\n\n            ret = AVERROR(EIO);\n\n            goto fail;\n\n        }\n\n        ret = ff_rtp_chain_mux_open(&contexts[i], s, s->streams[i], fd, 0, i);\n\n        if (ret < 0)\n\n            goto fail;\n\n        s->streams[i]->priv_data = contexts[i];\n\n        s->streams[i]->time_base = contexts[i]->streams[0]->time_base;\n\n        av_strlcpy(contexts[i]->filename, url, sizeof(contexts[i]->filename));\n\n    }\n\n\n\n    if (s->nb_streams > 0 && title)\n\n        av_dict_set(&contexts[0]->metadata, \"title\", title->value, 0);\n\n\n\n    ff_url_join(url, sizeof(url), \"udp\", NULL, announce_addr, port,\n\n                \"?ttl=%d&connect=1\", ttl);\n\n    ret = ffurl_open(&sap->ann_fd, url, AVIO_FLAG_WRITE,\n\n                     &s->interrupt_callback, NULL, sap->protocols);\n\n    if (ret) {\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n\n\n    udp_fd = ffurl_get_file_handle(sap->ann_fd);\n\n    if (getsockname(udp_fd, (struct sockaddr*) &localaddr, &addrlen)) {\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n    if (localaddr.ss_family != AF_INET\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n        && localaddr.ss_family != AF_INET6\n\n#endif\n\n        ) {\n\n        av_log(s, AV_LOG_ERROR, \"Unsupported protocol family\\n\");\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n    sap->ann_size = 8192;\n\n    sap->ann = av_mallocz(sap->ann_size);\n\n    if (!sap->ann) {\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n    sap->ann[pos] = (1 << 5);\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n    if (localaddr.ss_family == AF_INET6)\n\n        sap->ann[pos] |= 0x10;\n\n#endif\n\n    pos++;\n\n    sap->ann[pos++] = 0; /* Authentication length */\n\n    AV_WB16(&sap->ann[pos], av_get_random_seed());\n\n    pos += 2;\n\n    if (localaddr.ss_family == AF_INET) {\n\n        memcpy(&sap->ann[pos], &((struct sockaddr_in*)&localaddr)->sin_addr,\n\n               sizeof(struct in_addr));\n\n        pos += sizeof(struct in_addr);\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n    } else {\n\n        memcpy(&sap->ann[pos], &((struct sockaddr_in6*)&localaddr)->sin6_addr,\n\n               sizeof(struct in6_addr));\n\n        pos += sizeof(struct in6_addr);\n\n#endif\n\n    }\n\n\n\n    av_strlcpy(&sap->ann[pos], \"application/sdp\", sap->ann_size - pos);\n\n    pos += strlen(&sap->ann[pos]) + 1;\n\n\n\n    if (av_sdp_create(contexts, s->nb_streams, &sap->ann[pos],\n\n                      sap->ann_size - pos)) {\n\n        ret = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    av_freep(&contexts);\n\n    av_log(s, AV_LOG_VERBOSE, \"SDP:\\n%s\\n\", &sap->ann[pos]);\n\n    pos += strlen(&sap->ann[pos]);\n\n    sap->ann_size = pos;\n\n\n\n    if (sap->ann_size > sap->ann_fd->max_packet_size) {\n\n        av_log(s, AV_LOG_ERROR, \"Announcement too large to send in one \"\n\n                                \"packet\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_free(contexts);\n\n    sap_write_close(s);\n\n    return ret;\n\n}\n", "idx": 15001, "substitutes": {"s": ["details", "h", "fs", "l", "rs", "n", "series", "settings", "z", "S", "os", "service", "c", "sv", "ps", "ss", "conf", "p", "sys", "es", "r", "socket", "m", "ls", "sports", "hs", "aws", "gs", "ats", "b", "e", "js", "as", "ims", "spec", "w", "j", "t", "ds", "self", "cs", "ts", "o", "a", "v", "stats", "f", "qs", "ns", "sts"], "sap": ["sAP", "hsac", "unsap", "Saps", "unsAP", "hsap", "hsAP", "SAP", "saps", "unsac", "hsaps", "Sap", "sac", "unsaps", "Sac"], "host": ["pkg", "context", "h", "type", "Host", "address", "prefix", "container", "hd", "subject", "server", "ha", "node", "local", "ip", "hop", "addr", "http", " Host", "hw", "root", "loc", "ost", "org", "client", "socket", "key", "handle", "name", "port", "target", "mac", "hook", "home", "domain", "iter", "dev", "id", "dir", "str", "localhost", "conn", "handler", "link", "cmd", "base", "uri"], "path": ["pkg", "context", "kind", "l", "prefix", "type", "prop", "package", "PATH", "route", "history", "format", "local", "alias", "loc", "p", "pl", "message", "client", "filter", "key", "handle", "name", "port", "pattern", "Path", "spec", "id", "dir", "transform", "php", "data", "stream", "filename", "template", "file", "link", "config", "cmd", "stat", "lang", "text", "base", "href", "ath", "length", "uri", "query"], "url": ["ref", "l", "address", "sl", "server", "ip", "addr", "http", "src", "ul", "alias", "loc", "ssl", "cert", "id", "str", "https", "nl", "ll", "net", "file", "api", "link", "href", "URL", "base", "text", "uri"], "announce_addr": ["announced_adr", "announced_host", "announced2addr", "announce_address", "announced2host", "announce_adr", "announceableaddress", "announceipaddr", "announceipadd", "announceablehost", "announce2addr", "announce_host", "announced_link", "announce2host", "announced_address", "announced_addr", "announced2add", "announceiphost", "announced_add", "announce2add", "announce_link", "announceableaddr", "announce_add"], "option_list": ["option2cont", "optionListgroup", "option_LIST", "option_tree", "option_group", " option2set", "option_List", " option2single", " option2group", " option_data", " option_def", "option2list", "option2drop", " option2name", "option2group", "Option_listed", "option_name", " option_type", " option_drop", " option_set", "option67single", "optionitylen", "option7LIST", " option2type", "option_listed", "option7tag", " option_tag", " option2data", "option67drop", "option7list", "optionListname", "option_lists", "option_def", "option_single", " option2cont", "option0list", " option_single", "option67data", "Option_len", "option67cont", " option2drop", " option_tree", " option2list", "option67LIST", "option_drop", "option67type", "option2tree", "optionitylist", "option7lists", " option_lists", "option_status", "option_cont", "option2type", "option_data", "option2name", "option2single", " option_name", "option2data", " option_cont", "optionitydef", "optionListlist", "option67list", "option_type", "option_set", " option_LIST", " option2tree", "Option_List", "optionitylists", "option_len", "option_tag", " option2LIST", "option0type", " option_group", "option2set", "optionitylisted", "option0single", "option0data", "option2LIST", "optionityList", " option_status", "Option_list", "optionitystatus", "option7drop", "option7cont"], "i": ["l", "ii", "n", "k", "x", "ip", "c", "ti", "I", "p", "r", "m", "ia", "b", "e", "index", "id", "g", "it", "j", "t", "ix", "mi", "a", "pi", "f", "bi"], "contexts": ["Contextals", "Contextes", "logs", "textions", "logions", "textals", "contextes", "loges", "Contextions", "logals", "textes", "contextals", "Contexts", "texts", "contextions"], "localaddr": ["remoteaddr", "remotehost", "localip", "Localhost", "remoteip", " localaddress", "Localaddr", "localaddress", " localip", "remoteaddress", "Localip", "localhost", "Localaddress", " localhost"], "udp_fd": ["udport_dir", "udport2fin", "udport2dir", "udport_fin", "udp_FD", "udp8dir", "udp_dir", "udp2FD", "udp2dir", "udport_fd", "udp2fin", "udp8fin", "udport_FD", "udp8fd", "udp_fin", "udp8FD", "udport2FD", "udp2fd", "udport2fd"], "title": ["details", " entries", " metadata", " va", " alt", " titles", " tmp", " name", " parent", "alias", " t", " details", " header", "desc", "name", "Title", "feat", " foo", "itle", " entry", " tc", " msg", " conn", " desc", "ame", " info", " ti", " addr"], "buf": ["pkg", "orig", "xff", "bc", "history", "conv", "pool", "cat", "np", "cp", "cb", "pb", "mem", "fb", "pg", "cv", "caps", "Buffer", "text", "mu", "uf", "prop", "bar", "tmp", "txt", "br", "temp", "Buff", "bn", "vec", "img", " buffer", "vp", "tr", "cfg", "buffer", "cap", "bp", "cmd", "doc", "bytes", "page", "bt", "off", "rb", "tab", "browser", "comm", "err", "batch", "cam", "bag", "data", "seq", "proc", "bed", "var", "queue", "tx", "cur", "nm", "desc", "raw", "buff", "port", "b", "window", "box", "db", "iter", "font", "ctx", "act", "pad", "aka", "wb", "obj"], "ai": ["qi", "aki", "ii", "av", "aj", "am", "aii", "ali", "di", "aq", "ait", "aim", "aa", "ti", "AI", "hi", "li", "ei", "an", "si", "arm", "hai", "asi", "pai", "ia", "ati", "ami", "sa", "air", "ao", "aci", "ci", "ais", "au", "audi", "mi", "aka", "a", "ae", "bi"], "pos": ["rel", "ff", "ind", "ref", "pc", "priority", "prot", "cmp", "pid", "ps", "loc", "p", "position", "pose", "pro", "origin", "slice", "len", "index", "id", "limit", "offset", "seq", "po", "pt", "pi"]}}
{"project": "FFmpeg", "commit_id": "ef23bd939d955f53bc58696bbb68960784066894", "target": 1, "func": "static void hls_prediction_unit(HEVCContext *s, int x0, int y0,\n\n                                int nPbW, int nPbH,\n\n                                int log2_cb_size, int partIdx, int idx)\n\n{\n\n#define POS(c_idx, x, y)                                                              \\\n\n    &s->frame->data[c_idx][((y) >> s->sps->vshift[c_idx]) * s->frame->linesize[c_idx] + \\\n\n                           (((x) >> s->sps->hshift[c_idx]) << s->sps->pixel_shift)]\n\n    HEVCLocalContext *lc = s->HEVClc;\n\n    int merge_idx = 0;\n\n    struct MvField current_mv = {{{ 0 }}};\n\n\n\n    int min_pu_width = s->sps->min_pu_width;\n\n\n\n    MvField *tab_mvf = s->ref->tab_mvf;\n\n    RefPicList  *refPicList = s->ref->refPicList;\n\n    HEVCFrame *ref0, *ref1;\n\n    uint8_t *dst0 = POS(0, x0, y0);\n\n    uint8_t *dst1 = POS(1, x0, y0);\n\n    uint8_t *dst2 = POS(2, x0, y0);\n\n    int log2_min_cb_size = s->sps->log2_min_cb_size;\n\n    int min_cb_width     = s->sps->min_cb_width;\n\n    int x_cb             = x0 >> log2_min_cb_size;\n\n    int y_cb             = y0 >> log2_min_cb_size;\n\n    int x_pu, y_pu;\n\n    int i, j;\n\n\n\n    int skip_flag = SAMPLE_CTB(s->skip_flag, x_cb, y_cb);\n\n\n\n    if (!skip_flag)\n\n        lc->pu.merge_flag = ff_hevc_merge_flag_decode(s);\n\n\n\n    if (skip_flag || lc->pu.merge_flag) {\n\n        if (s->sh.max_num_merge_cand > 1)\n\n            merge_idx = ff_hevc_merge_idx_decode(s);\n\n        else\n\n            merge_idx = 0;\n\n\n\n        ff_hevc_luma_mv_merge_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                                   partIdx, merge_idx, &current_mv);\n\n    } else {\n\n        hevc_luma_mv_mpv_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                              partIdx, merge_idx, &current_mv);\n\n    }\n\n\n\n    x_pu = x0 >> s->sps->log2_min_pu_size;\n\n    y_pu = y0 >> s->sps->log2_min_pu_size;\n\n\n\n    for (j = 0; j < nPbH >> s->sps->log2_min_pu_size; j++)\n\n        for (i = 0; i < nPbW >> s->sps->log2_min_pu_size; i++)\n\n            tab_mvf[(y_pu + j) * min_pu_width + x_pu + i] = current_mv;\n\n\n\n    if (current_mv.pred_flag & PF_L0) {\n\n        ref0 = refPicList[0].ref[current_mv.ref_idx[0]];\n\n        if (!ref0)\n\n            return;\n\n        hevc_await_progress(s, ref0, &current_mv.mv[0], y0, nPbH);\n\n    }\n\n    if (current_mv.pred_flag & PF_L1) {\n\n        ref1 = refPicList[1].ref[current_mv.ref_idx[1]];\n\n        if (!ref1)\n\n            return;\n\n        hevc_await_progress(s, ref1, &current_mv.mv[1], y0, nPbH);\n\n    }\n\n\n\n    if (current_mv.pred_flag == PF_L0) {\n\n        int x0_c = x0 >> s->sps->hshift[1];\n\n        int y0_c = y0 >> s->sps->vshift[1];\n\n        int nPbW_c = nPbW >> s->sps->hshift[1];\n\n        int nPbH_c = nPbH >> s->sps->vshift[1];\n\n\n\n        luma_mc_uni(s, dst0, s->frame->linesize[0], ref0->frame,\n\n                    &current_mv.mv[0], x0, y0, nPbW, nPbH,\n\n                    s->sh.luma_weight_l0[current_mv.ref_idx[0]],\n\n                    s->sh.luma_offset_l0[current_mv.ref_idx[0]]);\n\n\n\n        chroma_mc_uni(s, dst1, s->frame->linesize[1], ref0->frame->data[1], ref0->frame->linesize[1],\n\n                      0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]);\n\n        chroma_mc_uni(s, dst2, s->frame->linesize[2], ref0->frame->data[2], ref0->frame->linesize[2],\n\n                      0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1]);\n\n    } else if (current_mv.pred_flag == PF_L1) {\n\n        int x0_c = x0 >> s->sps->hshift[1];\n\n        int y0_c = y0 >> s->sps->vshift[1];\n\n        int nPbW_c = nPbW >> s->sps->hshift[1];\n\n        int nPbH_c = nPbH >> s->sps->vshift[1];\n\n\n\n        luma_mc_uni(s, dst0, s->frame->linesize[0], ref1->frame,\n\n                    &current_mv.mv[1], x0, y0, nPbW, nPbH,\n\n                    s->sh.luma_weight_l1[current_mv.ref_idx[1]],\n\n                    s->sh.luma_offset_l1[current_mv.ref_idx[1]]);\n\n\n\n        chroma_mc_uni(s, dst1, s->frame->linesize[1], ref1->frame->data[1], ref1->frame->linesize[1],\n\n                      1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0]);\n\n\n\n        chroma_mc_uni(s, dst2, s->frame->linesize[2], ref1->frame->data[2], ref1->frame->linesize[2],\n\n                      1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1]);\n\n    } else if (current_mv.pred_flag == PF_BI) {\n\n        int x0_c = x0 >> s->sps->hshift[1];\n\n        int y0_c = y0 >> s->sps->vshift[1];\n\n        int nPbW_c = nPbW >> s->sps->hshift[1];\n\n        int nPbH_c = nPbH >> s->sps->vshift[1];\n\n\n\n        luma_mc_bi(s, dst0, s->frame->linesize[0], ref0->frame,\n\n                   &current_mv.mv[0], x0, y0, nPbW, nPbH,\n\n                   ref1->frame, &current_mv.mv[1], &current_mv);\n\n\n\n        chroma_mc_bi(s, dst1, s->frame->linesize[1], ref0->frame, ref1->frame,\n\n                     x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 0);\n\n\n\n        chroma_mc_bi(s, dst2, s->frame->linesize[2], ref0->frame, ref1->frame,\n\n                     x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 1);\n\n    }\n\n}\n", "idx": 15002, "substitutes": {"s": ["bs", "details", "fs", "rs", "changes", "ashes", "n", "sb", "serv", "ops", "z", "ses", "conv", "sim", "os", "S", "bes", "c", "sv", "ps", "comm", "p", "sys", "es", "args", "ls", "sports", "xs", "hs", "aws", "gs", "ats", "in", "ports", "js", "its", "as", "ims", "sts", "w", "spec", "sw", "sets", "less", "gets", "ex", "t", "ds", "times", "states", "cs", "ts", "sc", "se", "is", "a", "south", "v", "f", "ins", "qs", "stats", "scl", "ns", "params", "ss"], "x0": ["x2", "y3", "ox1", "ex0", " x4", "path00", "ix_", "y1", "rx0", " x2", "ix0", "x00", " x3", "ix4", " x_", "path0", "y4", "ox00", "ex1", "ix1", "ix3", "ox0", "ix2", " x1", "rx00", "x4", "ex2", "ex_", "x1", "x_", "x3"], "y0": ["oy2000", "yZero", "ryZero", " y30", " y1", "skyarg", "y1", "cy30", " y000", "sky000", "yElement", "y30", "gy0", "ay0", "ry2", " y2", "Y0", " yarg", "ny0", "ry0", "gyZero", "y2", "ny2", "oyElement", "ay000", "sky0", "ayarg", "gyElement", "oy0", "cy0", "gy1", "y03", "gy2000", "yarg", "Y1", "y2000", "ry2000", " y03", "Y30", "y000", "ry03", "x1", "oyZero", "ny03", "cy1", "ryElement"], "nPbW": ["nPww", "nPwWidth", "nNnW", "nNnw", "nPcWidth", "nPwV", "nPnw", "nPbWidth", "nNbw", "nPcw", "nPnV", "nNbW", "nPbV", "nNbV", "nPcV", "nPwW", "nPcW", "nNnWidth", "nNnV", "nNbWidth", "nPnW", "nPbw", "nPnWidth"], "nPbH": ["nPPbH", "nPPbW", "nPpH", "nPcH", "nPPbY", "nPcY", "nPPpY", "nPbHeight", "nPPpHeight", "nPcHeight", "nPdHeight", "nPPbHeight", "nPpW", "nPdH", "nPpY", "nPcW", "nPpHeight", "nPdW", "nPdY", "nPPpW", "nPPpH", "nPbY"], "log2_cb_size": ["log2_cb_SIZE", "log2_rb_scale", "log2_cb2scale", "log2_cb2Size", "log2_rb_SIZE", "log2_cbPscale", "log2_rb_size", "log2_cbPsize", "log2_cbPSIZE", "log2_cbPSize", "log2_rb_Size", "log2_cb2size", "log2_cb2SIZE", "log2_cb_scale", "log2_cb_Size"], "partIdx": ["Partidn", "PartIdX", "Partidz", "PartIdx", "PartidX", "PartIdn", "partIndz", "partIDX", "partidX", "Partidx", "partIDn", "partIndn", "partIdz", "partIdn", "partIdX", "partIndX", "PartIdz", "partIDx", "partidn", "partidx", "partIndx", "partIDz", "partidz"], "idx": ["ridxc", "idxf", "ridxf", "ridx", "IdX", "idX", "midxf", "idxc", "midx", "ridX", "midX", "Idxc", "midxc", "Idx", "Idxf"], "lc": ["LC", "dl", "vc", "l", "lp", "tl", "sb", "pc", "bc", "unc", "ctl", "dc", "ctrl", "cm", "lb", "c", "cp", "cb", "xc", "mc", "kl", "ls", "cell", "ln", "tc", "cc", "hl", "lv", "ctx", "gc", "cv", "cf", "lf", "rl", "cl", "ec", "lua", "ll", "fc", "cs", "sc", "lr", "cow"], "tab_mvf": ["tab_Mvfile", "tab_mavfile", "tab_Mvef", "tab_mvcf", "tab_pavp", "tab_movp", "tab_Mvf", "tab_mvcfile", "tab_mavp", "tab_mvfield", "tab_pvf", "tab_mvcfield", "tab_pvfield", "tab_mvp", "tab_mvcF", "tab_mvefield", "tab_Mvfield", "tab_MveF", "tab_muvf", "tab_pavfield", "tab_mavf", "tab_Mvefile", "tab_mveF", "tab_mvefile", "tab_mavfield", "tab_muvp", "tab_movfield", "tab_mvef", "tab_mvF", "tab_muvfield", "tab_mvfile", "tab_movf", "tab_Mvefield", "tab_pvp", "tab_mavF", "tab_pavf", "tab_MvF"], "refPicList": ["RefpicCache", "tabPicList", "refpicList", "refPropGroup", "refCapCache", "refPicGroup", "refpicCache", "tabParL", "refPropSet", "refPictureList", "refPicL", "refpiclist", "refPicCache", "refPicturelist", "refParL", "RefpicList", "refPropCache", "tabPiclist", "refCapList", "refParList", "refpicSet", "refCapGroup", "RefPicGroup", "refPiclist", "refPropList", "refPictureL", "RefPicSet", "RefPicList", "RefpicGroup", "RefPicCache", "tabParlist", "tabPicL", "RefpicSet", "refpicGroup", "refCapSet", "refPicSet", "refpicL", "refParlist", "tabParList"], "ref0": ["Ref1", "reference1", " ref2", "reference0", "reference2", "ref2", "Ref0", "Ref2"], "ref1": ["Ref1", "reference1", "refOne", " refOne", " ref2", "reference2", "ref2", "RefOne", "Ref2", "referenceOne"], "dst0": ["dst5", "dstr1", "Dst1", "ddest5", "dST0", "DST0", "Dst5", "dstr5", "ddest0", "dstr0", "DST5", "dST1", "dST5", "Dst0", "ddest1", "DST1"], "dst1": ["dnd0", "Dst01", "dST01", "dst01", "Dst1", "DstG", "dST0", "dndG", "dsts01", "DST1", "dstsG", "DST0", "dnd1", "dnd01", "dsts1", "DST01", "dST1", "dstG", "Dst0", "DSTG", "dsts0", "dSTG"], "dst2": ["dST4", "dST7", "dst4", "Dst3", "ddest3", "ddest2", "Dst7", "dst7", "DST7", "Dst2", "drest3", "ddest7", "dST3", "drest4", "ddest4", "DST2", "Dst4", "dST2", "dst3", "DST3", "drest7", "DST4", "drest2"], "x_pu": ["y2cpu", "y_cpu", "x42pu", "y2pro", "y2pu", "x2gpu", "x_gpu", "x42pro", "x_pro", "x2pu", "x42cpu", "x2pro", "x42gpu", "y_gpu", "y_pro", "x2cpu", "x_cpu", "y2gpu"], "y_pu": ["y__pu", "y2pu", " y2cp", "y2pa", " y2po", "y2po", "y__pa", "y2cp", " y_cp", " y_po", "y_cp", "y__cp", " y_pa", "y_pa", " y2pu", " y2pa", "y__po", "y_po"], "i": ["l", "ii", "x", "ij", "ip", "c", "li", "I", "p", "r", "m", "in", "b", "e", "it", "ci", "xi", "ic", "ix", "mi", "o", "pi", "v", "y", "f", "io"], "j": ["jp", "l", "ji", "aj", "n", "k", "z", "ij", "c", "q", "p", "jump", "jj", "m", "b", "ja", "js", "note", "g", "it", "uj", "kj", "J", "jc", "v", "f", "jl"]}}
{"project": "qemu", "commit_id": "2906cddfecff21af20eedab43288b485a679f9ac", "target": 0, "func": "static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n    VirtIOBlockReq *req;\n\n    MultiReqBuffer mrb = {};\n\n\n\n    /* Some guests kick before setting VIRTIO_CONFIG_S_DRIVER_OK so start\n\n     * dataplane here instead of waiting for .set_status().\n\n     */\n\n    if (s->dataplane) {\n\n        virtio_blk_data_plane_start(s->dataplane);\n\n        return;\n\n    }\n\n\n\n    blk_io_plug(s->blk);\n\n\n\n    while ((req = virtio_blk_get_request(s))) {\n\n        virtio_blk_handle_request(req, &mrb);\n\n    }\n\n\n\n    if (mrb.num_reqs) {\n\n        virtio_blk_submit_multireq(s->blk, &mrb);\n\n    }\n\n\n\n    blk_io_unplug(s->blk);\n\n}\n", "idx": 15016, "substitutes": {"vdev": [" vdiv", "vDEV", " vdevice", "svev", "vmdev", "svde", "fDEV", "svdiv", "vmdiv", "hDEV", "vmev", "svdev", "hserv", "fserv", "vmde", " vev", "vev", "vdevice", " vDEV", "vde", "vserv", " vserv", "hdev", "fdevice", "hdevice", "vdiv", " vde", "fdev"], "vq": ["vrequ", " vrequ", "invrequ", "invq", "vtq", " vqi", "vqi", "invqi", "vtrequ", "vtqi"], "s": ["bs", "details", "h", "fs", "l", "rs", "changes", "sol", "sb", "n", "ties", "sl", "ops", "ses", "ears", "S", "os", "sv", "c", "comm", "ps", "conf", "p", "sys", "set", "store", "es", "m", "an", "ls", "sports", "sam", "r", "hs", "aws", "gs", "b", "its", "js", "as", "ims", "sp", "spec", "sts", "g", "j", "sq", "sw", "ex", "t", "self", "ds", "se", "cs", "ts", "is", "source", "sm", "south", "v", "y", "stats", "sis", "command", "ins", "simple", "ns", "ss"], "req": ["pkg", "rel", "dist", "requ", "ind", "iq", "ref", "jp", "usr", "comp", "aux", "tx", "rib", "rb", "need", "compl", "cur", "Requ", "q", "comm", "def", "r", "err", "ire", "urg", "pro", "desc", "rx", "qq", "md", "rr", "request", "res", "require", "sq", "msg", "seq", "dq", "try", "rol", "quest", "crit", "pr", "resp", "cmd", "que", "form", "qt", "call"]}}
{"project": "FFmpeg", "commit_id": "0c32e19d584ba6ddbc27f0a796260404daaf4b6a", "target": 0, "func": "static void av_noinline filter_mb_edgeh( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]];\n\n        tc[1] = tc0_table[index_a][bS[1]];\n\n        tc[2] = tc0_table[index_a][bS[2]];\n\n        tc[3] = tc0_table[index_a][bS[3]];\n\n        h->s.dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->s.dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 15051, "substitutes": {"pix": ["piv", " pixels", " pIX", " pik", "mpx", "Px", "mpik", "px", " pfx", "Pix", "PIX", "pfx", "wpiv", "Pfx", "pixels", "cpfx", "cpIX", " px", " piv", "pik", "Pixels", "mpix", "pIX", "wpx", "cpx", "cpixels", "cpix", "mpiv", "wpik", "wpix"], "stride": ["swope", " strride", "strine", "strope", "strade", "stide", "strride", " strine", "swue", "Strite", "stringine", "strite", "divend", " strider", " strope", "slend", "slice", "divider", " strue", "stringite", "stringade", "swide", " strice", "stope", "Strade", "stringide", " strite", "Strine", "strice", "divide", "strider", "Stride", "divice", "swride", " strend", "strend", " strade", "slide", "strue", "stue", "slider"], "bS": ["bSU", " bUS", "bINS", " bBS", "nbFS", "nbN", "bR", "bbR", "bV", "sbFS", "nbUS", "bbJS", "bFS", "nbS", " bV", "bbBS", "nbB", " bL", "bbN", " bN", "fbUS", "nbJS", "fbL", " bJS", "bgINS", " bOS", " bFS", " bSU", " bINS", "bdS", "sbV", "nbP", "fbS", "bbOS", " bR", "nbINS", "bOS", "nbL", "sbS", "bP", "biSP", "bbS", "sbBS", "bUS", "bL", " bSP", "bSP", "biSU", " bP", "bbB", "nbOS", "fbP", "bgS", "bB", " bB", "bbFS", "bdSP", "bN", "biS", "bJS", "nbR", "bgR", "bgOS", "bBS", "bbV", "bdSU"], "qp": [" qpc", " qP", "qm", "qupad", "iqpc", "quP", "qum", "qqcp", "QP", "qpad", "qupc", " qpad", " qnp", "qcp", "qqpc", "iqp", "qup", "iqm", "Qpc", "qpc", "qqpad", "iqnp", "qqp", "qunp", " qcp", "qP", "Qm", "qucp", "Qp", "qnp", " qm"], "h": ["ch", "cache", "l", "hh", "hd", "n", "th", "k", "header", "history", "x", "hash", "http", "c", "q", "hw", "comm", "bh", "hi", "hz", "H", "p", "s", "m", "host", "handle", "hs", "kh", "b", "e", "ah", "he", "hl", "ctx", "rh", "ih", "g", "it", "sh", "j", "hp", "help", "php", "hal", "t", "oh", "a", "hm", "pp", "v", "f", "ph", "w", "ht"], "tc": ["LC", "oc", "cache", "pc", "tmp", "asc", "bc", "tu", "unc", "lc", "cas", "temp", "dc", "cot", "ctrl", "etc", "uca", "cm", "cca", "tim", "c", "cu", "tif", "currency", "mc", "tf", "pb", "TC", "cci", "cc", "rc", "ctx", "gc", "cv", "toc", "tic", "cus", "cf", "tx", "https", "ci", "aco", "ic", "ec", "ctr", "css", "t", "fee", "tt", "times", "fc", "cs", "ts", "uc", "acc", "sc", "ui", "td", "icc", " TC", "ta"]}}
{"project": "qemu", "commit_id": "f5babeacc4abccbb32f318278135a43477bdaa20", "target": 0, "func": "static void realize(DeviceState *d, Error **errp)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    Object *root_container;\n\n    char link_name[256];\n\n    gchar *child_name;\n\n    Error *err = NULL;\n\n\n\n    trace_spapr_drc_realize(spapr_drc_index(drc));\n\n    /* NOTE: we do this as part of realize/unrealize due to the fact\n\n     * that the guest will communicate with the DRC via RTAS calls\n\n     * referencing the global DRC index. By unlinking the DRC\n\n     * from DRC_CONTAINER_PATH/<drc_index> we effectively make it\n\n     * inaccessible by the guest, since lookups rely on this path\n\n     * existing in the composition tree\n\n     */\n\n    root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);\n\n    snprintf(link_name, sizeof(link_name), \"%x\", spapr_drc_index(drc));\n\n    child_name = object_get_canonical_path_component(OBJECT(drc));\n\n    trace_spapr_drc_realize_child(spapr_drc_index(drc), child_name);\n\n    object_property_add_alias(root_container, link_name,\n\n                              drc->owner, child_name, &err);\n\n    g_free(child_name);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,\n\n                     drc);\n\n    qemu_register_reset(drc_reset, drc);\n\n    trace_spapr_drc_realize_complete(spapr_drc_index(drc));\n\n}\n", "idx": 15055, "substitutes": {"d": ["dn", "h", "device", "l", "dm", "n", "dt", "di", "dc", "draw", "c", "ed", "p", "s", "r", "m", "dr", "b", "e", "md", "pd", "dev", "dd", "fd", "D", "j", "ad", "sd", "data", "t", "ds", "du", "o", "v", "f", "w", "da"], "errp": [" errcp", "orderpat", "ererp", " errP", "arrp", "erP", " errper", "erp", "ererpat", "errcp", "arrcp", "orderp", "errP", "orderP", " errpat", "ererP", "errpat", "orderper", "errper", "ercp", "ererper", "arrP"], "drc": ["mirc", "varc", "dorec", "mroc", "ddrc", "drt", "ddarc", " dsrc", "narc", "disirc", "ddirc", "wrc", "mrc", "sdrc", "dorc", "drb", "Droc", "larc", "dnarc", "ddpc", "sdroc", "Drs", "mrec", "wpc", "dirc", " drec", "disarc", "sync", "virc", "sRC", " dync", "drl", "vrc", "mRC", "dotrt", "DRC", "nrc", "vroc", "dpc", " dirc", " darc", " drt", "nroc", "Dsrc", "wRC", "darc", "Drt", "dnrt", "doarc", "dync", "ddrb", "dsRC", "doRC", "wirc", " drs", "src", "lirc", "dotrc", " dpc", "dnrc", "lrt", "ddrt", "wrs", "marc", "dsync", "dissrc", "nirc", "lsrc", "diRC", "dnrb", "drec", "lrc", "Drec", "drs", "sdrl", " droc", "wsrc", "droc", "ddsrc", "dotsrc", " drl", "dotirc", "dsrc", " drb", "dRC", "Drc", "disrc", " dRC", "sdrs", "wrec", "Darc", "Drl", "sdrt", "dsroc", "sroc", "sdRC"], "root_container": ["internal_cover", "rootlydocker", "rootingcover", "internal_object", "internal_Container", "rootnetContainer", "internalingcover", "rootingcontainer", " root_parent", "root_cover", "internalingContainer", "rootlyContainer", " root_docker", "rootnetparent", "rootnetcont", " root_component", "rootlycontainer", "root_object", "rootingContainer", "root_docker", " root_Container", "root_Container", "root_component", "root_cont", "internalingcontainer", " root_cont", "internalingobject", "rootlycomponent", "root_parent", "rootingobject", "rootnetcontainer", "internal_container"], "link_name": [" link_Name", "path_name", "child_info", "link2order", "linketyname", "linketyName", "link2id", "linktname", "linktorder", "child_id", "linkNamelink", "pathNameName", "link_pair", "link_link", "path_link", "pathNamefamily", "child_no", "linktno", "link09Name", "link_family", "link_id", "pathNamename", "link_order", "link_names", " link_pair", "childtorder", "link2no", "child_Name", "link_no", "pathNamelink", "link09family", "link_info", "child_order", "linkNameName", "linketynames", "childtid", "linkNamefamily", "path_Name", "path_family", "linketypair", "linktid", "childtno", "child_names", "link_Name", "link09link", "link2name", "linkNamename", " link_names", "link09name", "childtname"], "child_name": [" child2Name", "child_NAME", "childlytitle", "child_path", " child_Name", "childlyName", "child2path", "child2Name", "child_size", "link_size", "child_node", "childlyname", "child_data", " child_node", "childresourcesize", "child_title", "link_names", "Child_Name", "child_Name", "child2names", "childlynames", "link_data", "child2name", " child2names", "childresourcenames", "child2title", "childresourcename", " child_names", " child2name", " child_NAME", " child2title", "Child_name", "childresourcedata", "child_names", "Child_path", " child_title"], "err": ["usr", "Error", "or", "n", "elt", "esp", "die", "txt", "br", "rb", "error", "cli", "gz", "buf", "cur", "result", "cb", "conf", "er", "notice", "s", "arr", "r", "sys", "cfg", "dr", "nil", "e", "rev", "trace", "rr", "iter", "erd", "aaa", "exc", "inner", "rn", "res", "ev", "erb", "str", "msg", "fr", "mr", "ec", "attr", "fee", " Err", "resp", "kr", "cr", "errors", "obj", "lr", "ere", "eas", "Er", "eor"]}}
{"project": "qemu", "commit_id": "7ec1e5ea4bd0700fa48da86bffa2fcc6146c410a", "target": 0, "func": "static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,\n\n                       int insn, int size, int sign)\n\n{\n\n    TCGv_i32 r_asi, r_size, r_sign;\n\n\n\n    r_asi = gen_get_asi(dc, insn);\n\n    r_size = tcg_const_i32(size);\n\n    r_sign = tcg_const_i32(sign);\n\n#ifdef TARGET_SPARC64\n\n    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);\n\n#else\n\n    {\n\n        TCGv_i64 t64 = tcg_temp_new_i64();\n\n        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);\n\n        tcg_gen_trunc_i64_tl(dst, t64);\n\n        tcg_temp_free_i64(t64);\n\n    }\n\n#endif\n\n    tcg_temp_free_i32(r_sign);\n\n    tcg_temp_free_i32(r_size);\n\n    tcg_temp_free_i32(r_asi);\n\n}\n", "idx": 15061, "substitutes": {"dc": ["oc", "vc", "d", "dm", "pc", "dt", "bc", "dp", "DC", "di", "lc", "cm", "c", "xc", "cp", "mc", "dk", "dr", " DC", "tc", "cc", "rc", "ctx", "gc", "ci", "dq", "ec", "ds", "nc", "fc", "ca", "sc", "cs", "ac", "cd", "doc", "icc"], "dst": ["adST", "adset", "Dset", "dests", "dsts", "adst", "sdest", "Dest", "deST", "dest", "adnd", " dest", "Dst", "dset", "dST", "sdct", "adest", "sdsts", " dsts", "Dct", "Dsts", "dct", "adsts", " dset", "DST", "Dnd", "sdst", "dend", "dnd", " dct"], "addr": ["usr", "ref", "address", "map", "ag", "alloc", "tx", "x", "ip", "init", "src", "np", "hw", "st", "adr", "loc", "set", "r", "start", "add", "ptr", "err", "host", "dr", "store", "name", "mem", "rc", "hl", "ctx", "eth", "ack", "id", "at", "rn", "str", "ad", "offset", "gate", " address", "nl", "attr", "align", "ace", "a", "ac"], "insn": ["ainsn", "ainssn", " insl", "Insz", "insgn", "insnp", "insm", "ainsl", "inssn", "linsz", "linsn", " inssn", "linsnp", "insl", "linssn", "Insm", " insnp", " insz", "linsm", " insgn", "ainsnp", " insm", "linsgn", "Insgn", "Insn", "linsl", "insz"], "size": ["shape", "ize", "sum", "l", "sn", "type", "address", "send", "n", "SIZE", "style", "small", "city", "scale", "eng", "message", "loc", "capacity", "sy", "si", "empty", "storage", "name", "code", "count", "len", "iz", "id", "sh", "see", "use", "en", "ose", "align", "pi", "Size", "length", "area"], "sign": ["shape", "kind", "sum", "type", "address", "ign", "draw", "cmp", "SIGN", "scale", "p", "tag", "operator", "start", "add", "dig", "pay", "round", "close", "pos", "sa", "sp", "sk", "sh", "act", "cap", "mod", "pack", "se", "ig", "align", "grad", "sc", "form", "mask", "Sign", "shift"], "r_asi": ["rr_iat", "r_ois", "r1ski", "rYasi", "rLasi", "r_azi", "u___ami", "r_ali", "u___asi", "rr_ski", "rYami", "rgrasio", "u_ami", "rgrazi", "u_azi", "r___asi", "rr_aci", "r_ski", " r_azi", "r__ati", "r___ois", "rrLski", "rr_asi", "r_asio", "ref_azi", " r_ami", "r___asis", " r_asis", "rLiat", "u___asio", "rrLaci", "rgrami", "ref_ati", "rLski", "rLaci", "r_iat", "r___ami", "u___azi", "r_ini", "rYali", "r__asi", "r__ini", "r_asis", " r_ali", "r_ami", "u_asio", "ref_asi", "rrLasi", "r___asio", "r1asi", "r1aci", "r_aci", "r_ati", "u_asi", "r__azi", " r_ois", "r1iat", "ref_ini", "r___azi", "rYazi", "rrLiat", "rgrasi"], "r_size": ["r_ize", "vr_sent", "mr_width", "vr_size", "tr_Size", "r_space", "mr_Size", "tr_size", "r\u05bcsent", "r_sn", "r\u05bcset", "r_width", "tr_see", "r\u05bcSize", "r_sum", "tr_sum", "vr\u05bcSize", "m_size", "mr_sum", "r_sent", "m_sn", "r\u05bcsize", "vr_Size", "m_ize", " r_Size", "vr_set", "m_space", "vr\u05bcset", "vr\u05bcsize", "vr\u05bcsent", "r_see", "r_Size", "r_set", "mr_size"], "r_sign": ["r___scale", "r_ig", "r_pres", "r7Sign", "r___sign", " r_space", "fr_Sign", "r_space", "res_size", "res_sk", "fr_ig", "r_spec", "r___pres", "tr_sign", "r_san", "tr_Sign", "fr_sign", "r_scale", "res_sign", "res_ign", "tr_san", "r_Sign", "r__size", "fr_san", " r_transform", "r7transform", "R_sign", "r__sk", "r_ign", "r___signed", " r_Sign", "r_signed", "r__ign", "r_transform", "R_pres", "r_sk", "tr_spec", "r__sign", "R_scale", "R_signed", "r7space", "r7sign"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "static inline float64 ucf64_itod(uint64_t i)\n\n{\n\n    union {\n\n        uint64_t i;\n\n        float64 d;\n\n    } v;\n\n\n\n    v.i = i;\n\n    return v.d;\n\n}\n", "idx": 15066, "substitutes": {"i": ["qi", "d", "info", "ai", "ii", "ji", "n", "gi", " di", " ni", "di", "iti", "ij", "iy", "abi", "u", "ti", " bi", "li", "\u0438", "ei", "I", "p", "si", "ri", "oi", "m", "asi", "ia", "ati", "ami", "fi", "iu", "it", "j", "ci", "ity", "xi", "ic", "ki", "ik", "phi", "zi", "mi", "is", "iri", "pi", "y", "ui", "bi", "ini", "f", "iat"], "v": ["h", "d", "tv", "l", "ve", "av", "n", "V", "z", "conv", "x", "value", "nv", "sv", "u", "q", "p", "uv", "r", "m", "vs", "vp", "b", "vt", "lv", "mint", "cv", "g", "va", "ev", "j", "it", "qv", "ov", "vv", "vol", "vr", "val", "f", "var", "w", "vm"]}}
{"project": "qemu", "commit_id": "23dceda62a3643f734b7aa474fa6052593ae1a70", "target": 0, "func": "int tcg_gen_code(TCGContext *s, tcg_insn_unit *gen_code_buf)\n\n{\n\n    int i, oi, oi_next, num_insns;\n\n\n\n#ifdef CONFIG_PROFILER\n\n    {\n\n        int n;\n\n\n\n        n = s->gen_last_op_idx + 1;\n\n        s->op_count += n;\n\n        if (n > s->op_count_max) {\n\n            s->op_count_max = n;\n\n        }\n\n\n\n        n = s->nb_temps;\n\n        s->temp_count += n;\n\n        if (n > s->temp_count_max) {\n\n            s->temp_count_max = n;\n\n        }\n\n    }\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP))) {\n\n        qemu_log(\"OP:\\n\");\n\n        tcg_dump_ops(s);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->opt_time -= profile_getclock();\n\n#endif\n\n\n\n#ifdef USE_TCG_OPTIMIZATIONS\n\n    tcg_optimize(s);\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->opt_time += profile_getclock();\n\n    s->la_time -= profile_getclock();\n\n#endif\n\n\n\n    tcg_liveness_analysis(s);\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->la_time += profile_getclock();\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP_OPT))) {\n\n        qemu_log(\"OP after optimization and liveness analysis:\\n\");\n\n        tcg_dump_ops(s);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    tcg_reg_alloc_start(s);\n\n\n\n    s->code_buf = gen_code_buf;\n\n    s->code_ptr = gen_code_buf;\n\n\n\n    tcg_out_tb_init(s);\n\n\n\n    num_insns = -1;\n\n    for (oi = s->gen_first_op_idx; oi >= 0; oi = oi_next) {\n\n        TCGOp * const op = &s->gen_op_buf[oi];\n\n        TCGArg * const args = &s->gen_opparam_buf[op->args];\n\n        TCGOpcode opc = op->opc;\n\n        const TCGOpDef *def = &tcg_op_defs[opc];\n\n        uint16_t dead_args = s->op_dead_args[oi];\n\n        uint8_t sync_args = s->op_sync_args[oi];\n\n\n\n        oi_next = op->next;\n\n#ifdef CONFIG_PROFILER\n\n        tcg_table_op_count[opc]++;\n\n#endif\n\n\n\n        switch (opc) {\n\n        case INDEX_op_mov_i32:\n\n        case INDEX_op_mov_i64:\n\n            tcg_reg_alloc_mov(s, def, args, dead_args, sync_args);\n\n            break;\n\n        case INDEX_op_movi_i32:\n\n        case INDEX_op_movi_i64:\n\n            tcg_reg_alloc_movi(s, args, dead_args, sync_args);\n\n            break;\n\n        case INDEX_op_insn_start:\n\n            if (num_insns >= 0) {\n\n                s->gen_insn_end_off[num_insns] = tcg_current_code_size(s);\n\n            }\n\n            num_insns++;\n\n            for (i = 0; i < TARGET_INSN_START_WORDS; ++i) {\n\n                target_ulong a;\n\n#if TARGET_LONG_BITS > TCG_TARGET_REG_BITS\n\n                a = ((target_ulong)args[i * 2 + 1] << 32) | args[i * 2];\n\n#else\n\n                a = args[i];\n\n#endif\n\n                s->gen_insn_data[num_insns][i] = a;\n\n            }\n\n            break;\n\n        case INDEX_op_discard:\n\n            temp_dead(s, args[0]);\n\n            break;\n\n        case INDEX_op_set_label:\n\n            tcg_reg_alloc_bb_end(s, s->reserved_regs);\n\n            tcg_out_label(s, arg_label(args[0]), s->code_ptr);\n\n            break;\n\n        case INDEX_op_call:\n\n            tcg_reg_alloc_call(s, op->callo, op->calli, args,\n\n                               dead_args, sync_args);\n\n            break;\n\n        default:\n\n            /* Sanity check that we've not introduced any unhandled opcodes. */\n\n            if (def->flags & TCG_OPF_NOT_PRESENT) {\n\n                tcg_abort();\n\n            }\n\n            /* Note: in order to speed up the code, it would be much\n\n               faster to have specialized register allocator functions for\n\n               some common argument patterns */\n\n            tcg_reg_alloc_op(s, def, opc, args, dead_args, sync_args);\n\n            break;\n\n        }\n\n#ifndef NDEBUG\n\n        check_regs(s);\n\n#endif\n\n        /* Test for (pending) buffer overflow.  The assumption is that any\n\n           one operation beginning below the high water mark cannot overrun\n\n           the buffer completely.  Thus we can test for overflow after\n\n           generating code without having to check during generation.  */\n\n        if (unlikely((void *)s->code_ptr > s->code_gen_highwater)) {\n\n            return -1;\n\n        }\n\n    }\n\n    tcg_debug_assert(num_insns >= 0);\n\n    s->gen_insn_end_off[num_insns] = tcg_current_code_size(s);\n\n\n\n    /* Generate TB finalization at the end of block */\n\n    tcg_out_tb_finalize(s);\n\n\n\n    /* flush instruction cache */\n\n    flush_icache_range((uintptr_t)s->code_buf, (uintptr_t)s->code_ptr);\n\n\n\n    return tcg_current_code_size(s);\n\n}\n", "idx": 15067, "substitutes": {"s": ["bs", "fs", "sg", "ties", "ids", "ments", "styles", "pers", "ps", "strings", "r", "tools", "ms", "ports", "js", "locks", "g", "services", "sw", "utils", "se", "tests", "sm", "y", "ins", "details", "h", "d", "changes", "sb", "results", "os", "als", "ands", "sv", "set", "an", "m", "ers", "as", "tags", "j", "t", "states", "is", "parts", "ities", "ns", "rs", "x", "ies", "S", "c", "eps", "comm", "sys", "ls", "vs", "hs", "ats", "its", "scripts", "ims", "sq", "sets", "steps", "properties", "ts", "o", "bits", "types", "qs", "sts", "ss", "ants", "z", "ses", "rors", "p", "es", "aws", "gs", "e", "spec", "eds", "less", "ds", "self", "ings", "cs", "comments", "v", "stats", "w"], "gen_code_buf": ["gen_co_buf", "gen_code_cap", "gen_Code_buff", "gen_code2uf", "gen_co_cap", "gen_Code_buf", "gen_code2cap", "gen_code_buff", "gen_code2buffer", "gen_co_bu", "gen_code2bu", "gen_co_buffer", "gen_Code_uf", "gen_Code_buffer", "gen_co_uf", "gen_code2buf", "gen_code_buffer", "gen_code_bu", "gen_code_uf"], "i": ["ai", "ii", "x", "ip", " bi", "ti", "li", "I", "p", "si", "m", "in", "ni", " ii", "it", "j", "ci", "xi", "ic", "t", "phi", "o", "pi", "y", "v", "bi"], "oi": ["ai", "ii", "imi", "eta", "oxy", "oin", "osi", "uno", "avi", "abi", "ti", "uci", "tif", "ei", "oid", "odi", "ori", "ois", "ilo", "oj", "asi", "eric", "oa", "ati", "obi", "ot", "ami", "ni", "bis", "obo", "eni", "xi", "ico", "wei", "coe", "iso", "oni", "ki", "phi", "ogi", "igi", "ovi", "mi", "o", "iri", "pi", "ui", "bi", "ini", "iat"], "oi_next": ["eni_next", "mi___rel", "oi___rel", "oi____rel", "oi____ne", "oi__next", "eni_new", "oi__bi", "oi____bi", "oi_ne", "mi___bi", "oi_new", "oi___next", "mi___ne", "oi__rel", "oi_bi", "oi___bi", "oi_rel", "mi_next", "mi_rel", "oi____next", "oi__ne", "oi___ne", "mi_bi", "mi___next", "eni_extra", "mi_ne", "oi_extra"], "num_insns": ["num_insps", "num_inins", "num_inons", "num_inns", "num_inscs", "num_rsons", "num_nsps", "num_insn", "num_insons", "num_inn", "num_rsins", "num_insins", "num_nsns", "num_inps", "num_nsn", "num_incs", "num_nscs", "num_rsn", "num_rsns"], "n": ["dn", "un", "h", "d", "ind", "sn", "l", "z", "x", "node", "gn", "nan", "nu", "np", "number", "c", "new", "cn", "an", "m", "nm", "mn", "ne", "N", "ren", "name", "ln", "nt", "names", "count", "network", "len", "ng", "fn", "note", "na", "no", "none", "ni", "g", "cont", "inner", "j", "nn", "after", "nor", "num", "en", "conn", "nia", "nl", "nb", "t", "non", "net", "nc", "all", "v", "y", "on", "ns"], "op": ["oc", "info", "prop", "pop", "ops", "node", "ip", "loc", "p", "pro", "name", "oper", "sp", "ype", "Op", "it", "bit", "msg", "OP", "arg", "ep", "prev", "expr", "pr", "o", "var", "up"]}}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static int ehci_process_itd(EHCIState *ehci,\n\n                            EHCIitd *itd)\n\n{\n\n    USBPort *port;\n\n    USBDevice *dev;\n\n    int ret;\n\n    uint32_t i, j, len, pid, dir, devaddr, endp;\n\n    uint32_t pg, off, ptr1, ptr2, max, mult;\n\n\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n\n\n    for(i = 0; i < 8; i++) {\n\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n\n            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);\n\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n\n\n            if (len > max * mult) {\n\n                len = max * mult;\n\n            }\n\n\n\n            if (len > BUFF_SIZE) {\n\n                return USB_RET_PROCERR;\n\n            }\n\n\n\n            qemu_sglist_init(&ehci->isgl, 2);\n\n            if (off + len > 4096) {\n\n                /* transfer crosses page border */\n\n                uint32_t len2 = off + len - 4096;\n\n                uint32_t len1 = len - len2;\n\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n\n            } else {\n\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n\n            }\n\n\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n\n\n            usb_packet_setup(&ehci->ipacket, pid, devaddr, endp);\n\n            usb_packet_map(&ehci->ipacket, &ehci->isgl);\n\n\n\n            ret = USB_RET_NODEV;\n\n            for (j = 0; j < NB_PORTS; j++) {\n\n                port = &ehci->ports[j];\n\n                dev = port->dev;\n\n\n\n                if (!(ehci->portsc[j] &(PORTSC_CONNECT))) {\n\n                    continue;\n\n                }\n\n\n\n                ret = usb_handle_packet(dev, &ehci->ipacket);\n\n\n\n                if (ret != USB_RET_NODEV) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            usb_packet_unmap(&ehci->ipacket);\n\n            qemu_sglist_destroy(&ehci->isgl);\n\n\n\n#if 0\n\n            /*  In isoch, there is no facility to indicate a NAK so let's\n\n             *  instead just complete a zero-byte transaction.  Setting\n\n             *  DBERR seems too draconian.\n\n             */\n\n\n\n            if (ret == USB_RET_NAK) {\n\n                if (ehci->isoch_pause > 0) {\n\n                    DPRINTF(\"ISOCH: received a NAK but paused so returning\\n\");\n\n                    ehci->isoch_pause--;\n\n                    return 0;\n\n                } else if (ehci->isoch_pause == -1) {\n\n                    DPRINTF(\"ISOCH: recv NAK & isoch pause inactive, setting\\n\");\n\n                    // Pause frindex for up to 50 msec waiting for data from\n\n                    // remote\n\n                    ehci->isoch_pause = 50;\n\n                    return 0;\n\n                } else {\n\n                    DPRINTF(\"ISOCH: isoch pause timeout! return 0\\n\");\n\n                    ret = 0;\n\n                }\n\n            } else {\n\n                DPRINTF(\"ISOCH: received ACK, clearing pause\\n\");\n\n                ehci->isoch_pause = -1;\n\n            }\n\n#else\n\n            if (ret == USB_RET_NAK) {\n\n                ret = 0;\n\n            }\n\n#endif\n\n\n\n            if (ret >= 0) {\n\n                if (!dir) {\n\n                    /* OUT */\n\n                    set_field(&itd->transact[i], len - ret, ITD_XACT_LENGTH);\n\n                } else {\n\n                    /* IN */\n\n                    set_field(&itd->transact[i], ret, ITD_XACT_LENGTH);\n\n                }\n\n\n\n                if (itd->transact[i] & ITD_XACT_IOC) {\n\n                    ehci_record_interrupt(ehci, USBSTS_INT);\n\n                }\n\n            }\n\n            itd->transact[i] &= ~ITD_XACT_ACTIVE;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 15077, "substitutes": {"ehci": ["ehcci", "ohcheck", "echcci", "ohpi", "ehsee", "ehcom", "ehcheck", "phercoe", "etherdi", "ethci", "ohci", "ihcom", "ethcheck", "ethersee", "ihci", "echci", "htmc", "ohdi", "phercheck", "ethpi", "ethercci", "etherpi", "htmpi", "hc", "ethercom", "ehpi", "echcoe", "ethercu", "ethercoe", "ethsee", " ehc", "ehcu", " ehpi", "ehli", "ethcom", "echcheck", "hci", "hpi", "ihcu", "ehdi", "ethdi", "htmli", "htmci", "pherci", "phercci", "ehcoe", "ehc", "ethcu", "hli", "etherci", " ehli", "ethercheck", "ihsee"], "itd": ["ITdc", " itsd", " itda", "latds", "optld", "ITdo", "iterdb", " itr", "iterf", "litd", " itm", "itde", "latdb", "itf", " itld", "itbd", "itermod", "initsd", "aitdo", "ritsd", " itf", "initw", "ITD", "optf", " itw", "iterself", "initld", "itdc", "iterda", "latda", "utf", "itersd", "itdo", "utself", "iterdid", " itbd", "itdb", "Itsd", "iterds", "ITd", "aitl", "optd", " itn", "utd", "ietD", "itr", "itda", "mitds", "itD", "mitbd", "Itd", "iterD", "itsl", "itm", "itn", " itD", "pitf", "aitdc", "Itds", "itw", "iterdo", "pitsd", "ritf", "itmod", "itern", "ITm", "ritd", " itdid", "ietd", "ietl", "iterdc", "pitd", "litsd", "itdid", "itsd", " itself", "litld", "iterld", "pitD", "itself", "itsD", "litde", "itsr", " itds", "initde", "iterr", "Itbd", "ietr", "utda", " itdo", "initf", "iterde", "iterl", "iterw", "ITl", "itsdb", "ritdo", "initd", "latd", "itsds", "itsn", "itds", "itl", "iterm", "mitd", "iterd", " itmod", "optdid", "mitsd", "itsda", " itl", "ritD", "itld", "ITr", "aitd", "ritmod"], "port": ["type", "parent", "pc", "serv", "ip", "priority", "state", "PORT", "Port", "cp", "ort", "bridge", "p", "bus", "client", "pos", "ports", "index", "id", "P", "conn", "t", "pt", "pr", "pp", "pi", "policy"], "dev": ["device", "ch", "priv", "DEV", "serv", "buf", "hw", "ver", "loc", "def", "cam", "pro", "mem", "nt", "des", "Dev", "ev", "res", "sd", "iv", "conn", "proc", "val", "wd", "adv", "obj", "pub"], "ret": ["RET", "status", "out", " mem", "Ret", "result", " result", " RET", " r", "mem", "b", "nt", " resp", "fi", " out", "res", " count", "t", "il", " Ret", " status", " res", "rt", "val"], "i": ["qi", "ind", "info", "jp", "ai", "ii", "ji", "gi", "status", "z", "di", "x", "sim", "cli", "ij", "ip", "pa", "ti", "li", "hi", "\u0438", "I", "p", "si", "m", "ri", "asi", "ia", "im", "in", "multi", "ami", "index", "iu", "id", "ni", "g", "it", "ias", "me", "uri", "ci", "xi", "ic", "il", "zi", "ix", "mi", "is", "o", "pi", "y", "bi", "ini", "ui", "iat", "io"], "j": ["rel", "ind", "jp", "ii", "ji", "n", "z", "json", "ij", "p", "jump", "r", "m", "pos", "b", "js", "index", "ni", "job", "it", "uj", "lock", "J", "t", "jc", "bi", "jl", "iat"], "len": ["lis", "rel", "dl", "l", "ell", "lp", "n", "elt", "bytes", "trans", "sl", "la", "conv", "full", "compl", "cmp", "gl", "yn", "li", "del", "loc", "pl", "kl", "vec", "list", "ls", "mn", "min", "pos", "mem", "ln", "alt", "nt", "count", "iter", "lon", "sp", "fun", "size", "str", "lf", "coll", "limit", "wid", "num", "lim", "den", "en", "ml", "el", "fl", "L", "nl", "late", "ll", "il", "fin", "vol", "lib", "lang", "val", "ld", "le", "Len", "all", "length", "lan"], "pid": ["rel", "ind", "pri", "parent", "pc", "pa", "sid", "priority", "os", "ps", "p", "uid", "vid", "pn", "pos", "ctx", "index", "mid", "id", "res", "proc", "typ", "po", "mi", "pp", "pi", "process"], "dir": ["rel", "dist", "kind", "d", "direction", "directory", "trans", "di", "direct", "addr", "orient", "del", "loc", "p", "tr", "dr", "dim", "ir", "DIR", "db", "dial", "mode", "fd", "dep", "dd", "rot", "den", "driver", "Dir", "order", "ds", "vol", "grad", "wd", "diff"], "devaddr": ["evip", "evref", "devref", "Devaddress", " devaddress", "DEVaddress", " devptr", " devref", "deviceip", "devip", "evaddr", "Devptr", "deviceaddr", "devptr", "DEVaddr", " devip", "deviceref", "Devaddr", "devaddress", "DEVptr"], "endp": ["endP", "endedP", "endpt", " endP", "rendP", "Endpos", "endpoint", "rendpt", " endpoint", "Endpt", "endpid", "Endpid", "rendp", "Endpoint", " endpos", "EndP", "rendpid", "endedpoint", "lastp", "Endp", "endpos", "endedp", "lastpt", "lastP", "lastpid", "endedpos"], "pg": ["pkg", "mph", "PG", "jp", "gi", "pc", "ag", "gm", "ha", "gn", "pa", "ip", "gg", "buf", "prot", "np", "cp", "ps", "pas", "pl", "p", "wp", "loc", "tg", "ug", "gp", "kk", "pn", "Pg", "ia", "db", "tp", "ng", "mp", "sp", "gc", "eg", "g", "rg", "um", "gate", "po", "bp", "ig", "pt", "pp", "rog", "peg", "ph", "ping", "gb", "pm"], "off": ["ff", "ind", "end", "ow", "point", "Offset", "out", "os", "ip", "buf", "hop", "addr", "offer", "ap", "ext", "loc", "set", "zero", "err", "from", "ptr", "origin", "now", "oa", "pos", "mem", "nt", "ot", "of", "Off", "no", "offs", "over", "ok", "op", "id", "after", "offset", "en", "ex", "det", "open", "el", "ox", "order", "opp", "OFF", "pt", "o", "pad", "cmd", "obj", "length", "on", "shift"], "ptr1": ["lenOne", " ptr51", "tp0", "prime1", "pt2", "prime51", "tp3", "ptr5", " ptr5", "ptr51", "ptr11", "pt01", "Ptr1", "len1", "pt5", "pt51", "ptr0", "prime11", "Ptr01", "pt1", "pt11", "ptrOne", " ptr11", "ptr01", "len2", "addr01", "PtrOne", "Ptr2", "tp1", "pt0", "len01", "addr3", "pt3", "ptOne", "addr0", "addr1", "tp01", "ptr3", "prime5"], "ptr2": ["ptr02", "pr01", "prime2", "pt42", "prime1", "addr15", "rod2", "addr5", "addr02", "pt2", "addr42", "tip2", "ptr5", "pt02", "ptr42", "Ptr4", "tip3", "prime15", "Ptr01", "addr2", "pr2", "ptr01", "addr01", "Ptr2", "rod15", "ptr15", "pr3", "tip42", "addr4", "rod1", "rod5", "addr3", "pt3", "tip02", "ptr3", "addr1", "prime5", "pr4", "ptr4", "Ptr3"], "max": ["sum", "con", "end", "Max", "ax", "n", "map", "last", "med", "best", "full", "top", "co", "cp", "scale", "conf", "prime", "p", "m", "MAX", "recent", "huge", "ms", "min", "box", "final", "total", "mid", "size", "res", "act", "limit", "range", "grow", "cap", "lim", "quant", "mx", "mod", "inv", "master", "all", "rest", "high", "base", "up"], "mult": ["usr", "norm", "trans", "dom", "tu", "fac", "conv", "util", "compl", "cmp", "multiple", "Mult", "ul", "pl", "mut", "p", "sub", "m", "tr", "mn", "mk", "min", "factor", "mem", "multi", "nom", "total", "mid", "per", "multipl", "cap", "msg", "quant", "broad", "mod", "comb", "phi", "vol", "gr", "mix", "mess", "inv", "perm", "mat", "ipl", "mu"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_pop(Visitor *v, void **obj)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    StackObject *tos = QSLIST_FIRST(&qiv->stack);\n\n\n\n    assert(tos && tos->qapi == obj);\n\n    QSLIST_REMOVE_HEAD(&qiv->stack, node);\n\n    qmp_input_stack_object_free(tos);\n\n}\n", "idx": 15082, "substitutes": {"v": ["i", "h", "vc", "l", "tv", "av", "n", "vy", "V", "conv", "nv", "sv", "q", "c", "u", "ver", "vim", "uv", "m", "vs", "vp", "b", "verb", "vt", "vi", "cv", "g", "ev", "j", "iv", "qv", "ov", "vati", "t", "nov", "vv", "vr", "o", "y", "f", "w", "vm"], "obj": ["pkg", "ref", "tmp", "txt", "tk", "bj", "os", "addr", "src", "oid", "ht", "oj", "key", "bo", "pos", "nt", "js", "ot", "xy", "ctx", "instance", "object", "id", "str", "act", "res", "j", "iv", "inst", "attr", "po", "typ", "expr", "vol", "vr", "pr", "resp", "o", "rt", "ob", "cmd", "gov", "Obj"], "qiv": ["qIv", " qIv", "qiro", "Qiro", "qiver", "qqivable", "qive", "qIV", "dqiver", "QIv", "dqIv", "dqiv", "Qiv", "quiv", "qqiv", " qivable", "dqive", " qive", "qqiver", " qIV", "quivable", "dqIV", "quIV", "dqiro", "qqIV", " qiver", " qiro", "quiver", "quive", "qivable", "Qiver"], "tos": ["Toms", "nos", "ptoms", "toores", " toses", " tot", "toS", "ptoes", "Toes", "tsos", "ptot", " toos", "ptoses", "toms", "not", "tors", "ptos", "toos", " tors", "ptores", "tsors", " toes", " tores", "toows", "no", "tooses", "to", " toms", "noes", "toses", "ptoS", "ToS", "tsoos", "tores", "pto", "Toos", " to", "tot", "Tos", "Tors", "tows", "ptows", "toes", " tows", "tsoes", " toS"]}}
{"project": "FFmpeg", "commit_id": "a443a2530d00b7019269202ac0f5ca8ba0a021c7", "target": 1, "func": "static int vmd_read_header(AVFormatContext *s,\n\n                           AVFormatParameters *ap)\n\n{\n\n    VmdDemuxContext *vmd = (VmdDemuxContext *)s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    AVStream *st;\n\n    unsigned int toc_offset;\n\n    unsigned char *raw_frame_table;\n\n    int raw_frame_table_size;\n\n    offset_t current_offset;\n\n    int i, j;\n\n    unsigned int total_frames;\n\n    int64_t video_pts_inc = 0;\n\n    int64_t current_video_pts = 0;\n\n    unsigned char chunk[BYTES_PER_FRAME_RECORD];\n\n    int lastframe = 0;\n\n\n\n    /* fetch the main header, including the 2 header length bytes */\n\n    url_fseek(pb, 0, SEEK_SET);\n\n    if (get_buffer(pb, vmd->vmd_header, VMD_HEADER_SIZE) != VMD_HEADER_SIZE)\n\n        return AVERROR_IO;\n\n\n\n    vmd->audio_sample_counter = 0;\n\n    vmd->audio_frame_divisor = 1;\n\n    vmd->audio_block_align = 1;\n\n\n\n    /* start up the decoders */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR_NOMEM;\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    vmd->video_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_VMDVIDEO;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n    st->codec->width = LE_16(&vmd->vmd_header[12]);\n\n    st->codec->height = LE_16(&vmd->vmd_header[14]);\n\n    st->codec->time_base.num = 1;\n\n    st->codec->time_base.den = 10;\n\n    st->codec->extradata_size = VMD_HEADER_SIZE;\n\n    st->codec->extradata = av_mallocz(VMD_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    memcpy(st->codec->extradata, vmd->vmd_header, VMD_HEADER_SIZE);\n\n\n\n    /* if sample rate is 0, assume no audio */\n\n    vmd->sample_rate = LE_16(&vmd->vmd_header[804]);\n\n    if (vmd->sample_rate) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR_NOMEM;\n\n        av_set_pts_info(st, 33, 1, 90000);\n\n        vmd->audio_stream_index = st->index;\n\n        st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n        st->codec->codec_id = CODEC_ID_VMDAUDIO;\n\n        st->codec->codec_tag = 0;  /* no fourcc */\n\n        st->codec->channels = vmd->audio_channels = (vmd->vmd_header[811] & 0x80) ? 2 : 1;\n\n        st->codec->sample_rate = vmd->sample_rate;\n\n        st->codec->block_align = vmd->audio_block_align =\n\n            LE_16(&vmd->vmd_header[806]);\n\n        if (st->codec->block_align & 0x8000) {\n\n            st->codec->bits_per_sample = 16;\n\n            st->codec->block_align = -(st->codec->block_align - 0x10000);\n\n            vmd->audio_block_align = -(vmd->audio_block_align - 0x10000);\n\n        } else {\n\n            st->codec->bits_per_sample = 8;\n\n\n        st->codec->bit_rate = st->codec->sample_rate *\n\n            st->codec->bits_per_sample * st->codec->channels;\n\n\n\n        /* for calculating pts */\n\n        vmd->audio_frame_divisor = st->codec->channels;\n\n\n\n        video_pts_inc = 90000;\n\n        video_pts_inc *= st->codec->block_align;\n\n        video_pts_inc /= st->codec->sample_rate;\n\n        video_pts_inc /= st->codec->channels;\n\n    } else {\n\n        /* if no audio, assume 10 frames/second */\n\n        video_pts_inc = 90000 / 10;\n\n\n\n\n    toc_offset = LE_32(&vmd->vmd_header[812]);\n\n    vmd->frame_count = LE_16(&vmd->vmd_header[6]);\n\n    vmd->frames_per_block = LE_16(&vmd->vmd_header[18]);\n\n    url_fseek(pb, toc_offset, SEEK_SET);\n\n\n\n    raw_frame_table = NULL;\n\n    vmd->frame_table = NULL;\n\n    raw_frame_table_size = vmd->frame_count * 6;\n\n    raw_frame_table = av_malloc(raw_frame_table_size);\n\n\n\n\n\n    vmd->frame_table = av_malloc(vmd->frame_count * vmd->frames_per_block * sizeof(vmd_frame_t));\n\n    if (!raw_frame_table || !vmd->frame_table) {\n\n        av_free(raw_frame_table);\n\n        av_free(vmd->frame_table);\n\n        return AVERROR_NOMEM;\n\n\n    if (get_buffer(pb, raw_frame_table, raw_frame_table_size) !=\n\n        raw_frame_table_size) {\n\n        av_free(raw_frame_table);\n\n        av_free(vmd->frame_table);\n\n        return AVERROR_IO;\n\n\n\n\n    total_frames = 0;\n\n    for (i = 0; i < vmd->frame_count; i++) {\n\n\n\n        current_offset = LE_32(&raw_frame_table[6 * i + 2]);\n\n\n\n        /* handle each entry in index block */\n\n        for (j = 0; j < vmd->frames_per_block; j++) {\n\n            int type;\n\n            uint32_t size;\n\n\n\n            get_buffer(pb, chunk, BYTES_PER_FRAME_RECORD);\n\n            type = chunk[0];\n\n            size = LE_32(&chunk[2]);\n\n            if(!size)\n\n                continue;\n\n            switch(type) {\n\n            case 1: /* Audio Chunk */\n\n                vmd->frame_table[total_frames].frame_offset = current_offset;\n\n                vmd->frame_table[total_frames].stream_index = vmd->audio_stream_index;\n\n                vmd->frame_table[total_frames].frame_size = size;\n\n                memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);\n\n                total_frames++;\n\n                break;\n\n            case 2: /* Video Chunk */\n\n                vmd->frame_table[total_frames].frame_offset = current_offset;\n\n                vmd->frame_table[total_frames].frame_size = size;\n\n                vmd->frame_table[total_frames].stream_index = vmd->video_stream_index;\n\n                memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);\n\n                vmd->frame_table[total_frames].pts = current_video_pts;\n\n                if (lastframe) {\n\n                    vmd->frame_table[lastframe].pts = current_video_pts - video_pts_inc;\n\n\n                lastframe = total_frames;\n\n                total_frames++;\n\n                break;\n\n\n            current_offset += size;\n\n\n        current_video_pts += video_pts_inc;\n\n\n\n\n    av_free(raw_frame_table);\n\n\n\n    vmd->current_frame = 0;\n\n    vmd->frame_count = total_frames;\n\n\n\n    return 0;\n", "idx": 15094, "substitutes": {"s": ["bs", "h", "fs", "d", "rs", "sg", "sb", "n", "S", "os", "c", "sv", "ps", "ss", "p", "sys", "es", "r", "m", "ls", "vs", "hs", "ms", "aws", "gs", "ats", "e", "b", "js", "in", "sa", "sp", "g", "t", "ds", "cs", "ts", "sc", "o", "a", "is", "v", "ins", "ns", "sts"], "ap": [" ps", " map", "am", "map", " pu", "pa", "ip", " cp", "ar", " sap", "pl", " par", "att", "mp", "tap", "tp", "al", "sp", "op", "aps", "cap", "ep", "bp", "pp", " af", "ac", " sp", " mp"], "vmd": ["evdm", "vcmn", "evmk", "Vcmd", "servasured", "gMD", "vvmn", "vcasured", "vdm", "Vnd", "wmand", " vmt", " vasured", " vdd", " vod", "mcmd", "vMD", "vasured", "wcmd", "evmt", "vvod", "devmt", " vMD", "wmd", "wmt", "vvmd", "ivmd", "vcmd", "nvmd", "gmn", "valcmd", "avcmd", "gmd", "vermn", "vermd", "vod", "devmn", "avmand", " vmn", "Vdm", "vmt", " vmk", "valmt", "verdd", " vdm", "ivmn", "ivcd", " vmm", "vcd", "avmd", "mmd", "devmd", "evmd", "nvmn", "evod", "ivdd", "avdd", "vmk", "vmand", "mdm", " vcd", "Vmd", "valmand", "avmn", "wnd", "valmd", "vmn", "vdd", "vvmk", "mnd", "vmm", "vnd", "avmt", "servmd", " vcmd", "avmm", "avcd", "servcmd", "vermm", "nvMD", "devdm", "gcmd", "wdm", "evmn", "vccmd", "vermt", "nvcmd", "servmn"], "pb": ["pkg", "uf", "bs", "jp", "fp", "lp", "sb", "pc", "dp", "conv", "tk", "rb", "bj", "pa", "buf", "aus", "np", "lb", "cp", "cb", "ps", "pl", "p", "wp", "gp", "vp", "mb", "b", "fb", "tc", "pg", "tp", "mp", "buffer", "ctx", "sp", "bb", "cv", "sw", "PB", "proc", "typ", "bp", "pt", "ts", "pp", "ob", "wb", "ab", "td", "pm", "ub"], "st": ["ST", "usr", "ft", "sn", "ut", "std", "stop", "sb", "St", "tmp", "th", "nd", "sl", "stack", "ck", "art", "status", "ast", "ist", "sv", "ste", "stan", "ost", "interface", "set", "ust", "r", "sty", "start", "store", "tr", "et", "storage", "nt", "no", "sa", "sp", "stable", "sts", "fd", "form", "cont", "str", "sw", "stage", "step", "ct", "mt", "sta", "inst", "t", "sth", "tt", "se", "ts", "pt", "sc", "rt", "put", "sm", "stat", "rest", "stru", "td", "first", "mont", "irst", "est"], "toc_offset": ["meta_offset", "metaameposition", "tocamepos", "toc_position", "meta_position", "meta_table", "toc_table", "metaamepos", "tocametable", "toc__pos", "tocameoffset", "toc__offset", "metaameoffset", "toc__table", "toc_pos", "tocameposition", "toc__position", "metaametable", "meta_pos"], "raw_frame_table": ["raw_frames_map", "raw_frames_buffer", "raw_frames_table", "raw_frames_list", "raw_frame_buffer", "raw_frame_map", "raw_frame_list"], "raw_frame_table_size": ["raw_frame_buffer_len", "raw_frame_table_len", "raw_frame_table2count", "raw_frame_table2size", "raw_frame_table2length", "raw_frame_buffer_length", "raw_frame_buffer_count", "raw_frame_table2len", "raw_frame_table_length", "raw_frame_table_count", "raw_frame_buffer_size"], "current_offset": ["stream_offset", "current_pos", "current_page", "current_position", "stream_pos", "stream_page", "stream_position"], "i": ["h", "d", "l", "ii", "n", "k", "x", "c", "ti", "li", "I", "p", "r", "si", "m", "b", "e", "it", "ci", "ic", "t", "mi", "o", "pi", "v", "f", "y"], "j": ["jp", "l", "ii", "ji", "n", "aj", "k", "z", "ij", "q", "p", "jump", "r", "jj", "m", "pos", "b", "ja", "js", "count", "sp", "g", "J", "t", "jc", "v", "f"], "total_frames": ["total_images", " total_videos", " total_images", "total_videos"], "chunk": ["bunks", "chunks", "bip", "CHord", "chord", "CHunk", "bunk", "Chord", "CHunks", "Chunks", "CHip", "Chip", "Chunk", "bord", "chip"]}}
{"project": "FFmpeg", "commit_id": "99e5a9d1ea2a61ac9429427431e5b9c2fefb76a5", "target": 0, "func": "void dsputil_init_arm(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n    int idct_algo= avctx->idct_algo;\n\n\n\n    ff_put_pixels_clamped = c->put_pixels_clamped;\n\n    ff_add_pixels_clamped = c->add_pixels_clamped;\n\n\n\n    if (avctx->lowres == 0) {\n\n        if(idct_algo == FF_IDCT_AUTO){\n\n#if   HAVE_IPP\n\n            idct_algo = FF_IDCT_IPP;\n\n#elif HAVE_NEON\n\n            idct_algo = FF_IDCT_SIMPLENEON;\n\n#elif HAVE_ARMV6\n\n            idct_algo = FF_IDCT_SIMPLEARMV6;\n\n#elif HAVE_ARMV5TE\n\n            idct_algo = FF_IDCT_SIMPLEARMV5TE;\n\n#else\n\n            idct_algo = FF_IDCT_ARM;\n\n#endif\n\n        }\n\n\n\n        if(idct_algo==FF_IDCT_ARM){\n\n            c->idct_put= j_rev_dct_ARM_put;\n\n            c->idct_add= j_rev_dct_ARM_add;\n\n            c->idct    = j_rev_dct_ARM;\n\n            c->idct_permutation_type= FF_LIBMPEG2_IDCT_PERM;\n\n        } else if (idct_algo==FF_IDCT_SIMPLEARM){\n\n            c->idct_put= simple_idct_ARM_put;\n\n            c->idct_add= simple_idct_ARM_add;\n\n            c->idct    = simple_idct_ARM;\n\n            c->idct_permutation_type= FF_NO_IDCT_PERM;\n\n#if HAVE_ARMV6\n\n        } else if (idct_algo==FF_IDCT_SIMPLEARMV6){\n\n            c->idct_put= ff_simple_idct_put_armv6;\n\n            c->idct_add= ff_simple_idct_add_armv6;\n\n            c->idct    = ff_simple_idct_armv6;\n\n            c->idct_permutation_type= FF_LIBMPEG2_IDCT_PERM;\n\n#endif\n\n#if HAVE_ARMV5TE\n\n        } else if (idct_algo==FF_IDCT_SIMPLEARMV5TE){\n\n            c->idct_put= simple_idct_put_armv5te;\n\n            c->idct_add= simple_idct_add_armv5te;\n\n            c->idct    = simple_idct_armv5te;\n\n            c->idct_permutation_type = FF_NO_IDCT_PERM;\n\n#endif\n\n#if HAVE_IPP\n\n        } else if (idct_algo==FF_IDCT_IPP){\n\n            c->idct_put= simple_idct_ipp_put;\n\n            c->idct_add= simple_idct_ipp_add;\n\n            c->idct    = simple_idct_ipp;\n\n            c->idct_permutation_type= FF_NO_IDCT_PERM;\n\n#endif\n\n#if HAVE_NEON\n\n        } else if (idct_algo==FF_IDCT_SIMPLENEON){\n\n            c->idct_put= ff_simple_idct_put_neon;\n\n            c->idct_add= ff_simple_idct_add_neon;\n\n            c->idct    = ff_simple_idct_neon;\n\n            c->idct_permutation_type = FF_PARTTRANS_IDCT_PERM;\n\n        } else if ((CONFIG_VP3_DECODER || CONFIG_VP5_DECODER || CONFIG_VP6_DECODER || CONFIG_THEORA_DECODER) &&\n\n                   idct_algo==FF_IDCT_VP3){\n\n            c->idct_put= ff_vp3_idct_put_neon;\n\n            c->idct_add= ff_vp3_idct_add_neon;\n\n            c->idct    = ff_vp3_idct_neon;\n\n            c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;\n\n#endif\n\n        }\n\n    }\n\n\n\n    c->put_pixels_tab[0][0] = put_pixels16_arm;\n\n    c->put_pixels_tab[0][1] = put_pixels16_x2_arm;\n\n    c->put_pixels_tab[0][2] = put_pixels16_y2_arm;\n\n    c->put_pixels_tab[0][3] = put_pixels16_xy2_arm;\n\n    c->put_no_rnd_pixels_tab[0][0] = put_pixels16_arm;\n\n    c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_arm;\n\n    c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_arm;\n\n    c->put_no_rnd_pixels_tab[0][3] = put_no_rnd_pixels16_xy2_arm;\n\n    c->put_pixels_tab[1][0] = put_pixels8_arm;\n\n    c->put_pixels_tab[1][1] = put_pixels8_x2_arm;\n\n    c->put_pixels_tab[1][2] = put_pixels8_y2_arm;\n\n    c->put_pixels_tab[1][3] = put_pixels8_xy2_arm;\n\n    c->put_no_rnd_pixels_tab[1][0] = put_pixels8_arm;\n\n    c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_arm;\n\n    c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_arm;\n\n    c->put_no_rnd_pixels_tab[1][3] = put_no_rnd_pixels8_xy2_arm;\n\n\n\n#if HAVE_ARMV5TE\n\n    c->prefetch = ff_prefetch_arm;\n\n#endif\n\n\n\n#if HAVE_IWMMXT\n\n    dsputil_init_iwmmxt(c, avctx);\n\n#endif\n\n#if HAVE_ARMVFP\n\n    ff_float_init_arm_vfp(c, avctx);\n\n#endif\n\n#if HAVE_NEON\n\n    ff_dsputil_init_neon(c, avctx);\n\n#endif\n\n}\n", "idx": 15106, "substitutes": {"c": ["abc", "ch", "d", "l", "con", "cache", "pc", "bc", "content", "lc", "conv", "unc", "out", "dc", "etc", "cm", "cp", "cb", "conf", "cu", "xc", "u", "p", "mc", "err", "cam", "C", "b", "e", "tc", "cc", "rc", "com", "chain", "ctx", "gc", "cv", "ce", "cont", "at", "cf", "g", "coll", "ci", "arc", "cl", "ct", "anc", "enc", "ic", "ec", "t", "nc", "cs", "fc", "sc", "config", "ac", "cr", "v", "f", "w", "can", "call", "co"], "avctx": ["avercontext", "AVsys", "avesys", " avcrit", "avecur", "avkw", "AVctl", "avcrit", "AVcontext", "avparams", "AVctx", "aveparams", "avcur", "avcontext", "avecrit", "avekw", "averparams", " avcontext", "averctx", " avctl", "avctl", "savctx", "avectx", "avecontext", "avectl", "savcur", "AVparams", "savcontext", "avsys", "AVkw", "averkw", " avsys", " avcur", "savcrit"]}}
{"project": "FFmpeg", "commit_id": "7a4f74eed51f914e9bbfebaffd4a92ac6791f819", "target": 0, "func": "av_cold void ff_h264_free_context(H264Context *h)\n\n{\n\n    int i;\n\n\n\n    ff_h264_free_tables(h);\n\n\n\n    if (h->DPB) {\n\n        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)\n\n            ff_h264_unref_picture(h, &h->DPB[i]);\n\n        av_freep(&h->DPB);\n\n    }\n\n\n\n    h->cur_pic_ptr = NULL;\n\n\n\n    for (i = 0; i < h->nb_slice_ctx; i++)\n\n        av_freep(&h->slice_ctx[i].rbsp_buffer);\n\n    av_freep(&h->slice_ctx);\n\n    h->nb_slice_ctx = 0;\n\n\n\n    for (i = 0; i < MAX_SPS_COUNT; i++)\n\n        av_freep(h->sps_buffers + i);\n\n\n\n    for (i = 0; i < MAX_PPS_COUNT; i++)\n\n        av_freep(h->pps_buffers + i);\n\n}\n", "idx": 15108, "substitutes": {"h": ["event", "ch", "cache", "info", "l", "hd", "th", "k", "z", "history", "here", "x", "go", "hash", "header", "http", "c", "q", "hw", "comm", "bh", "dh", "has", "H", "p", "gh", "host", "m", "handle", "hs", "kh", "ah", "b", "window", "mem", "dev", "hz", "he", "ih", "eh", "hl", "w", "rh", "it", "sh", "j", "hp", "help", "sw", "proc", "oh", "o", "hm", "pp", "v", "y", "ph", "policy", "rec", "obj", "hh", "ht", "rem"], "i": [" ki", "status", "ski", "cli", "gu", "u", "this", "oi", "uli", " m", " ii", "it", "g", "ci", "ie", "ex", "ki", "zi", " mi", " iter", "mi", "y", " multi", " li", "eu", "info", "ii", "ji", " si", " di", "ij", "init", "hi", "er", "mc", "client", " pi", "ri", "m", "cgi", "name", "ia", "multi", "to", "at", "j", "xi", "t", "ix", "is", "print", "by", "ui", "ini", "qi", "ind", "ai", "di", "x", " all", "q", "ti", " bi", "li", "\u0438", "I", "err", "si", "batch", "im", "in", "ims", "fi", "index", "ico", "phi", " vi", "pi", "bi", "io", "iq", "gi", " ni", "z", "json", "sim", " wi", "ip", "ei", "p", " j", " I", "us", "e", "ami", "iter", "remote", "iu", "um", "me", "ic", " c", "MI", " info", " err", " ti"]}}
{"project": "qemu", "commit_id": "4a1cba3802554a3b077d436002519ff1fb0c18bf", "target": 1, "func": "bool aio_poll(AioContext *ctx, bool blocking)\n\n{\n\n    AioHandler *node;\n\n    int i, ret;\n\n    bool progress;\n\n    int64_t timeout;\n\n\n\n    aio_context_acquire(ctx);\n\n    progress = false;\n\n\n\n    /* aio_notify can avoid the expensive event_notifier_set if\n\n     * everything (file descriptors, bottom halves, timers) will\n\n     * be re-evaluated before the next blocking poll().  This is\n\n     * already true when aio_poll is called with blocking == false;\n\n     * if blocking == true, it is only true after poll() returns,\n\n     * so disable the optimization now.\n\n     */\n\n    if (blocking) {\n\n        atomic_add(&ctx->notify_me, 2);\n\n    }\n\n\n\n    ctx->walking_handlers++;\n\n\n\n    assert(npfd == 0);\n\n\n\n    /* fill pollfds */\n\n\n\n    if (!aio_epoll_enabled(ctx)) {\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->pfd.events\n\n                && aio_node_check(ctx, node->is_external)) {\n\n                add_pollfd(node);\n\n            }\n\n        }\n\n    }\n\n\n\n    timeout = blocking ? aio_compute_timeout(ctx) : 0;\n\n\n\n    /* wait until next event */\n\n    if (timeout) {\n\n        aio_context_release(ctx);\n\n    }\n\n    if (aio_epoll_check_poll(ctx, pollfds, npfd, timeout)) {\n\n        AioHandler epoll_handler;\n\n\n\n        epoll_handler.pfd.fd = ctx->epollfd;\n\n        epoll_handler.pfd.events = G_IO_IN | G_IO_OUT | G_IO_HUP | G_IO_ERR;\n\n        npfd = 0;\n\n        add_pollfd(&epoll_handler);\n\n        ret = aio_epoll(ctx, pollfds, npfd, timeout);\n\n    } else  {\n\n        ret = qemu_poll_ns(pollfds, npfd, timeout);\n\n    }\n\n    if (blocking) {\n\n        atomic_sub(&ctx->notify_me, 2);\n\n    }\n\n    if (timeout) {\n\n        aio_context_acquire(ctx);\n\n    }\n\n\n\n    aio_notify_accept(ctx);\n\n\n\n    /* if we have any readable fds, dispatch event */\n\n    if (ret > 0) {\n\n        for (i = 0; i < npfd; i++) {\n\n            nodes[i]->pfd.revents = pollfds[i].revents;\n\n        }\n\n    }\n\n\n\n    npfd = 0;\n\n    ctx->walking_handlers--;\n\n\n\n    /* Run dispatch even if there were no readable fds to run timers */\n\n    if (aio_dispatch(ctx, ret > 0)) {\n\n        progress = true;\n\n    }\n\n\n\n    aio_context_release(ctx);\n\n\n\n    return progress;\n\n}\n", "idx": 15115, "substitutes": {"ctx": ["pkg", "bc", "conv", "pool", "cmp", "cm", "np", "addr", "cp", "cb", "kl", "org", "cv", "acl", "expr", "ca", "pt", "sc", "context", "vc", "kw", "tmp", "ck", "txt", "ctrl", "init", "cu", "jac", "height", "cfg", "mk", "tz", "tc", "gc", "kt", "cf", "conn", "anc", "tm", "resp", "cmd", "dl", "jp", "prefix", "req", "unc", "x", "cas", "dc", "etc", "buf", "exec", "comm", "sys", "cam", "nt", "cc", "ka", "ct", "proc", "gt", "fw", "wcs", "wd", "co", "xp", "nz", "tx", "lc", "ctl", "setup", "xc", "hw", "conf", "xs", "window", "xy", "ce", "act", "cl", "ctr", "func", "nc", "crit", "config", "wx", "cd", "obj", "qt"], "blocking": ["packing", "warning", "excluding", "poll", " blocked", "starting", "status", "training", "padding", "server", "restricted", "confirmed", "joining", " locking", "background", "enabled", "speaking", "balanced", "available", "forcing", "boxing", "necessary", "blocks", "using", "fully", "block", "locked", "buffer", "always", "exclusive", "latest", "ocking", "lock", "calling", "ending", "loading", "broad", "watching", "ordering", "period", "running", "negative", "rolling", "checked", "majority", "sync", "locking", "playing", "checking", "testing", "saving"], "node": ["event", "worker", "ind", "cache", "ref", "child", "parent", "n", "image", "component", "tmp", "k", "nd", "status", "nw", "server", "slave", "x", "peer", "local", "cmp", "np", "addr", "c", "cp", "new", "root", "tree", "list", "host", "Node", "key", "desc", "name", "entry", "nt", "holder", "none", "instance", "note", "path", "fn", "index", "id", "gc", "station", "nn", "primary", "item", "msg", "row", "normal", "proc", "nb", "handler", "link", "source", "master", "wife", "cd", "obj", "process", "post", "edge"], "i": ["qi", "ind", "l", "ai", "ii", "ji", "n", "gi", "k", "di", "x", "sim", "cli", "ip", "init", "c", "ti", "li", "\u0438", "I", "p", " j", "ei", "r", "si", "batch", "m", "mc", " I", "ri", "set", "e", "multi", "chain", "iter", "ami", "fi", "index", "iu", "id", " ii", "it", "j", "ci", "ite", "xi", "ic", "ki", "t", "phi", "zi", "ix", "MI", "s", "mi", "pi", "v", "y", "bi", "ini", "ui", "fire", "io"], "ret": ["ft", "RET", "elt", "dt", "tmp", "lt", "success", "txt", "re", "reply", "number", "Ret", "result", "ext", "xt", "def", "r", "err", "ptr", "tr", "flag", "alt", "repl", "nt", "rev", "ert", "iter", "len", "fi", "done", "res", "back", "after", "rm", "mt", "pat", "gt", "unt", "arg", "t", "ll", "rets", "resp", "rt", "cmd", "val", "got", "reset", "rem"], "progress": ["details", "fast", "finished", "dist", " progression", "poll", "pc", "status", "success", "summary", "history", "complete", "trust", "error", "memory", "ait", "confirmed", "state", "priority", "depth", "result", "usage", "exec", "p", "err", "dirty", "pro", "valid", "recent", "push", "tip", "good", "flag", "mem", "Progress", "final", "remote", "active", "distance", "total", "done", "res", "help", "lock", "step", "bool", " Progress", "assert", "quick", "debug", "putable", "resp", "print", "performance", "command", "process", "wait"], "timeout": ["tv", "timer", "status", "padding", "history", "sequence", "error", "password", "frequency", "unit", "region", "period", "elta", "TIME", "never", "option", "sync", "term", "ta", "wait", "warning", "directory", "tmp", "txt", "slot", "number", "socket", "tf", "height", "ssl", "course", "buffer", "sp", "Timeout", "size", " seconds", "duration", "limit", "disabled", "t", "negative", "policy", "length", "delay", "ns", "script", "shape", "resolution", "type", "format", "olerance", "service", "seconds", "alt", "nt", "locked", "lock", "max", "required", "ts", "io", "itness", "time", "out", "confirmed", "capacity", "callback", "window", "none", "network", "interrupted", "exclusive", "uration", "span", "tt", "beta", "qt"], "walking_handlers": ["walking_Handlers", "walking_transling", "walking_handolds", "walking_candodes", "walking_manodes", "walking_manlers", "walking_wareling", "walking_wareles", "walking_translers", "walking_Handrollers", "walking_handodes", "walking_manolds", "walking_candles", "walking_transrollers", "walking_handling", "walking_Handles", "walking_handrollers", "walking_warelers", "walking_manles", "walking_candolds", "walking_handles", "walking_transles", "walking_Handolds", "walking_Handling", "walking_warerollers", "walking_Handodes", "walking_candlers"], "epoll_handler": ["epoll_wrapper", "epoll_hander", "epollingloader", "epoll_Handler", "epol_inner", "epollptinner", "epll_loader", "epow_handler", "epoll_folder", "epollingclient", "epow_wrapper", "epock_wrapper", "epollptmanager", "epll_handler", "epollinghandler", "epol_handler", "epollpthandle", "epllinghandler", "epollerhander", "epollinghandle", "epoll_manager", "epll_client", "epll_handle", "epol_manager", "epllingloader", "epollerwrapper", "epoll_client", "epllingclient", "epollerhandler", "epoll_inner", "epock_Handler", "epow_folder", "epock_handler", "epoll_handle", "epoll_loader", "epol_handle", "epow_hander", "epollpthandler", "epllinghandle", "epollerfolder"]}}
{"project": "FFmpeg", "commit_id": "252c0bfdc014c1fb6ad4fe06242c7beca58a6b41", "target": 1, "func": "int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)\n\n{\n\n    av_assert0(0);\n\n\n}", "idx": 15124, "substitutes": {"s": ["h", "i", "fs", "d", "n", "sb", "S", "os", "c", "p", "es", "m", "b", "e", "js", "w", "sq", "t", "ds", "cs", "ts", "sc", "o", "a", "v", "ns", "ss"], "pic": ["fps", "fx", "ff", "fp", "fm", "image", " fps", "pc", " p", "q", "ps", "picture", "p", " fr", "fif", "fn", "fi", "res", "fr", "fl", "FR", "fc", " fl", "pr", "o", "F", " fn", " fram"]}}
{"project": "FFmpeg", "commit_id": "d1a58afb95f68c5375b4a7556317d835108509ed", "target": 1, "func": "static int latm_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    PutBitContext bs;\n\n    int i, len;\n\n    uint8_t loas_header[] = \"\\x56\\xe0\\x00\";\n\n    uint8_t *buf = NULL;\n\n\n\n    if (s->streams[0]->codec->codec_id == CODEC_ID_AAC_LATM)\n\n        return ff_raw_write_packet(s, pkt);\n\n\n\n    if (pkt->size > 2 && pkt->data[0] == 0xff && (pkt->data[1] >> 4) == 0xf) {\n\n        av_log(s, AV_LOG_ERROR, \"ADTS header detected - ADTS will not be incorrectly muxed into LATM\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (pkt->size > 0x1fff)\n\n        goto too_large;\n\n\n\n    buf = av_malloc(pkt->size+1024);\n\n    if (!buf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    init_put_bits(&bs, buf, pkt->size+1024);\n\n\n\n    latm_write_frame_header(s, &bs);\n\n\n\n    /* PayloadLengthInfo() */\n\n    for (i = 0; i <= pkt->size-255; i+=255)\n\n        put_bits(&bs, 8, 255);\n\n\n\n    put_bits(&bs, 8, pkt->size-i);\n\n\n\n    /* The LATM payload is written unaligned */\n\n\n\n    /* PayloadMux() */\n\n    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {\n\n        // Convert byte-aligned DSE to non-aligned.\n\n        // Due to the input format encoding we know that\n\n        // it is naturally byte-aligned in the input stream,\n\n        // so there are no padding bits to account for.\n\n        // To avoid having to add padding bits and rearrange\n\n        // the whole stream we just remove the byte-align flag.\n\n        // This allows us to remux our FATE AAC samples into latm\n\n        // files that are still playable with minimal effort.\n\n        put_bits(&bs, 8, pkt->data[0] & 0xfe);\n\n        avpriv_copy_bits(&bs, pkt->data + 1, 8*pkt->size - 8);\n\n    } else\n\n        avpriv_copy_bits(&bs, pkt->data, 8*pkt->size);\n\n\n\n    avpriv_align_put_bits(&bs);\n\n    flush_put_bits(&bs);\n\n\n\n    len = put_bits_count(&bs) >> 3;\n\n\n\n    if (len > 0x1fff)\n\n        goto too_large;\n\n\n\n    loas_header[1] |= (len >> 8) & 0x1f;\n\n    loas_header[2] |= len & 0xff;\n\n\n\n    avio_write(pb, loas_header, 3);\n\n    avio_write(pb, buf, len);\n\n\n\n    av_free(buf);\n\n\n\n    return 0;\n\n\n\ntoo_large:\n\n    av_log(s, AV_LOG_ERROR, \"LATM packet size larger than maximum size 0x1fff\\n\");\n\n    av_free(buf);\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 15125, "substitutes": {"s": ["pkg", "h", "fs", "rs", "sg", "n", "sb", "z", "ses", "os", "S", "c", "sv", "ps", "ss", "p", "sys", "es", "r", "ssl", "m", "ls", "sports", "xs", "hs", "aws", "gs", "ats", "b", "its", "js", "sa", "ctx", "sp", "j", "sq", "t", "ds", "cs", "ts", "sc", "is", "south", "stats", "qs", "scl", "ns", "sts"], "pkt": ["pkg", "Pett", "patchkl", "paacket", "cpmsg", "patacket", " pmit", "pdu", "tk", "opkg", "pfeat", " pet", "paymsg", "prmsg", "opacket", "mwk", "patkt", "pet", "ppkt", "prdu", "prkat", "prounit", "spet", "payct", " pk", "parpt", "cpnt", "compct", "spkt", "paunit", "pkl", "pk", "postwk", "parett", "npct", "pwk", " pwp", "patk", "patdu", " pmsg", "Pnt", "postct", "paywk", "tkt", "postcmd", " pfeat", " pnt", "patchct", "ppnt", "mkt", "npfeat", " pkg", "Packet", "ppt", "cpdu", "spnt", " pett", "cpkt", "patct", "proacket", "pkat", " pct", "patchkt", "ppkg", "upkt", "npkl", "mfeat", "cpwp", "punit", " pdu", "pakt", "repnt", " punit", "postkt", "upct", "payacket", "prokt", "Ppt", "repkg", "paykt", "opnt", "compacket", "wpcmd", "pett", "Pwk", "wpkg", " pkat", "Pmit", "pcmd", "postacket", "pront", "repacket", "prokg", "wpdu", " pkl", "tkg", "Pmsg", "upacket", "updu", "pnt", "procmd", "ppacket", "pmit", "patkg", "ppet", "wpkt", "repkt", "patchfeat", "patchwk", "prekt", "parkt", "pwp", "prect", "patwp", "tct", "compkt", " ppt", " packet", "pant", "parwk", "compnt", "ppdu", "npkt", "predu", "Pct", "Pkat", "macket", "cpacket", "prkt", "Pkt", "spacket", "opkt", "packet", " pwk", "preacket", "pct", "postkg", "Pdu", " pcmd", "pmsg", "paymit", "patchacket", "ppcmd"], "pb": ["uf", "pkg", "jp", "fp", "lp", "sb", "pc", "tx", "conv", "tk", "aus", "cm", "np", "lb", "cp", "bh", "cb", "ps", "cn", "p", "gp", "vp", "b", "tc", "pg", "tp", "mp", "ctx", "bb", "cv", "cpp", "conn", "PB", "soc", "typ", "bp", "pt", "ts", "cmd", "ub"], "bs": ["bos", "fs", "nos", "rs", " blocks", "sb", "bytes", "aos", "Bs", "bc", " buffers", "os", "als", "bes", "aus", "bys", "bh", "cb", "ps", " outs", " ss", " ts", "sys", " os", "outs", "vs", "us", " bl", "ls", " bits", "ms", "blocks", "gs", "b", "ats", "its", " bases", "js", "uts", "lbs", "bles", "bb", "bis", "boxes", "bas", "caps", " BS", " fs", "cks", " sands", "css", "bps", "bed", "BS", "ubs", " cs", "bsp", "cs", "ts", "bits", " bos", "base", "qs", " bounds", "obs", " buffs", "ns", " ns"], "i": ["qi", " li", "h", "ind", "d", "l", "ai", "ii", " si", "n", "gi", " di", " e", " ni", "di", "z", "x", "sim", "cli", "ip", "gu", "c", "u", " bi", "ti", "li", "hi", "I", "p", "ei", "r", "si", "m", " pi", "im", "multi", "e", "b", "ami", "iter", "ims", "index", "iu", " m", " ii", "it", "g", "j", "ci", "xi", "t", "phi", "zi", " mi", "ix", "MI", " iter", "mi", "pi", "y", "v", "bi", "ini", "ui", "f", " multi", " ti"], "len": ["lis", "dl", "l", "lp", "n", "elt", "bytes", "Length", "la", "lc", "conv", "compl", "cmp", "els", "gl", "li", "del", "loc", "kl", "vec", "ls", "pos", "mem", "ln", "alt", "nt", "iter", "lon", "gen", "hl", "total", "lic", "ni", "size", "fun", "html", "lf", "coll", "cod", "offset", "L", "wid", "lim", "en", "num", "seq", "el", "fl", "nl", "t", "ll", "fin", "resp", "ld", "val", "Len", "length", "lan"], "loas_header": ["loas_byte", "loAS_info", "loas_extra", "loAS_header", "loac_header", "loas_number", "loas_head", "loas___info", "loas___extra", "loAS_data", "loas_info", "loas_data", "loas___data", "loAS_head", "loAS_byte", "loas___header", "loac_head", "loas___byte", "loAS_extra", "loac_channel", "n", "loas_channel", "loas___head", "loac_number", "cont", "w"], "buf": ["uf", "queue", "ff", "bytes", "xff", "bl", "tmp", "bc", "alloc", "br", "conv", "rb", "out", "txt", "gz", "Buff", "off", "np", "cb", "vec", "err", "arr", "ptr", "bound", "raw", "buff", "mem", "b", "window", "db", "box", "eb", "buffer", "block", "rc", "w", "cv", "done", "uffy", "str", "Buffer", "limit", "cap", "msg", "data", "bin", "max", "BU", "broad", "used", "func", "t", "rw", "aka", "cmd", "ob", "v", "wb", "length", "doc"]}}
{"project": "qemu", "commit_id": "9e559533bd825a3e371497875576137a8586c831", "target": 1, "func": "static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = g_malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        g_free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n\n    g_free(ctx);\n\n}", "idx": 15132, "substitutes": {"opaque": ["OPac", "imque", "OPaque", "oaque", "imaques", "imlay", "oque", "poplay", "copac", "olay", "popque", "copacity", "imaque", "opac", "opque", "popaque", "opacity", "copque", "OPacity", " opacity", " opque", "opaques", " opac", "OPque", "oaques", "oplay", "copaque", "popaques"], "ret": ["ft", "ref", "jp", "RET", "elt", "nz", "status", "x", "out", "re", "reply", "Ret", "ext", " RET", "def", "err", "tf", "et", "tr", "ry", "mem", "alt", "code", "nt", "count", "len", "xy", "fun", "res", "back", "rm", "ct", "mt", "det", "gt", "try", "pat", "t", "magic", "inter", "ter", "rets", " Ret", "resp", "rt", "cmd", "val", "deg", "aux"], "ctx": ["pkg", "history", "tk", "bj", "cmp", "cm", "addr", "np", "cp", "cb", "check", "kl", "org", "urg", "pause", "pg", "cv", "expr", "ca", "pt", "sc", "td", "context", "kw", "std", "ck", "txt", "ctrl", "cu", "def", "jac", "cfg", "timeout", "tz", "tc", "gc", "kt", "cf", "conn", "pat", "tm", "resp", "cmd", "abc", "dl", "jp", "prefix", "pri", "unc", "dc", "etc", "exec", "batch", "ppo", "nt", "cc", "index", "ct", "kj", "proc", " cx", "work", "rt", "aux", "co", "xp", "tx", "ctl", "cur", "xc", "hw", "conf", "jj", " context", "desc", "window", "dad", "act", "mom", "cl", "inst", "func", "crit", "fc", "nc", "wx", "obj", "qt"], "t2": [" pt2", "T4", "m5", "T2", "pt4", " tidmsg", " tpl", "ttwo", " t1", "f2", "titletwo", " tid1", "pt2", "p02", " tid2", "pttwo", "t1", " tmsg", " t5", "title4", "f3", "T3", "T02", "title2", "titleTwo", "m2", "ptTwo", "T5", "f1", "p2", " pt1", " tTwo", "tTwo", "t3", " t02", " ptpl", "fpl", "p3", "m4", "t4", "T1", " tidpl", "p1", "tmsg", " ptmsg", " ttwo", " t3", "t02", "t5", " t4", "m1", "Tpl", "tpl"], "cmp_buf": ["cmp2cb", "cmp_loc", "eq____loc", "cmp_vec", "comp_bu", "eq____buf", "cmp____bu", "eq_loc", "cmpxvec", "eq_buf", "comp_buff", "cmp_buff", "comp_pkg", "comp_cb", "eq____bu", "cmpmemmat", "cmpxbuf", "cmp____buffer", "cmp2mat", "cmpmembuf", "eq_buffer", "cmpxpkg", "eq_bu", "cmpmemloc", "comp_buffer", "cmpmembu", "cmp_buffer", "cmpmembuffer", "cmp_mat", "eq____buffer", "cmp2buf", "comp_vec", "cmp_pkg", "cmpxbuffer", "comp_buf", "cmp2buff", "cmp2bu", "cmp____buf", "cmp_bu", "cmp2buffer", "cmp____loc", "comp_mat", "cmp_cb"]}}
{"project": "FFmpeg", "commit_id": "3a54c221d574ec944db1eddf9df895808f32bf9e", "target": 1, "func": "static const char *read_ts(const char *buf, int *ts_start, int *ts_end,\n\n                           int *x1, int *y1, int *x2, int *y2)\n\n{\n\n    int i, hs, ms, ss, he, me, se;\n\n\n\n    for (i=0; i<2; i++) {\n\n        /* try to read timestamps in either the first or second line */\n\n        int c = sscanf(buf, \"%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d\"\n\n                       \"%*[ ]X1:%u X2:%u Y1:%u Y2:%u\",\n\n                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,\n\n                       x1, x2, y1, y2);\n\n        buf += strcspn(buf, \"\\n\") + 1;\n\n        if (c >= 8) {\n\n            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;\n\n            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;\n\n            return buf;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 15133, "substitutes": {"buf": ["uf", "pkg", "queue", "bur", "ref", "end", "bar", "bytes", "tmp", "bt", "bc", "fg", "br", "conv", "rb", "out", "Buff", "cat", "np", "cp", "cb", "bh", "q", "new", "this", "p", "vec", "err", "batch", "img", "pb", "vp", "raw", "buff", "port", "read", "mem", "b", "db", "pg", "iter", "buffer", "block", "ctx", "gc", "cv", "uffy", "paste", "str", "Buffer", "cf", "msg", "data", "bin", "doc", "func", "aka", "cmd", "ob", "v", "text", "w"], "ts_start": ["ts_first", "ts_open", "ts_range", "ps_start", "ps_begin", "ats_end", "ts__end", "ts__begin", "ats_Start", "ts_step", "pt_start", "ts1end", "ts1start", "ats_range", "pt_open", "ts1first", "pt_first", "uts_start", "ts_Start", "uts_step", "ts1open", "ats_start", "ts__start", "uts_begin", "ts_begin", "ps_end", "uts_end", "pt_end"], "ts_end": ["ats_range", "ats_start", "ts__start", "ts_stop", "ts__end", "ats_ended", "ts__roll", "ps_END", "ps_roll", "ts_range", "ps_end", "ts_END", "ps_start", "ats_fin", "ats_end", "ts_ended", "ts_roll", "ats_line", "ts_line", "ts_fin", "ats_stop", "ts__END"], "x1": ["y3", "ex0", "x01", "ex3", " x3", "x0", "ix01", "ex01", " x0", "ex1", "ix1", "ix3", "y0", "ix2", "ex2", " x01", "x3"], "y1": ["y3", "my1", " y0", "ty3", "my3", "Y3", "Y0", "my01", "y01", "my2", "ny0", "ny2", "ty2", "ty01", "Y01", " y5", "Y1", "Y5", "y0", "ty1", "ny1", "Y2", "ny5", "y5"], "x2": ["ex4", "y3", " x4", "ixTwo", "ex3", " x3", "xt8", "exTwo", "y4", "x8", "ex1", "ix3", "ix8", "ix2", "xtTwo", "x4", "ex2", "xt2", "ex8", "xTwo", "x3", "xt3"], "y2": ["x6", "y3", "z3", " y4", "y6", "z2", " ytwo", "ty4", "ty6", " y3", "y4", "ty2", "ztwo", "z1", "ty1", " y6", "x4", "ytwo", "xtwo", "x3"], "i": ["qi", "ind", "info", "ai", "ii", "n", "di", "conv", "sim", "go", "out", "ip", "init", "gu", "c", " bi", "ti", "li", "conf", "hi", "I", "ei", " j", "mc", "r", "si", "m", "us", "im", "e", "multi", "chain", "in", "fi", "index", "iu", " ii", "it", "j", "ci", "ie", "xi", "inter", "ic", "t", "phi", " c", "ix", "mi", "is", "pi", "y", "v", "bi", " err", "ini", "ui"], "hs": ["bs", "h", "fs", "rs", "hd", "hh", "HS", "mes", "ks", "ha", "inters", "heads", "ps", "his", "hi", "ires", "s", "es", "ls", "vs", "xs", "mn", "gs", "its", "windows", "hl", "ims", "sts", "rh", "sh", "hes", "ems", "cks", "ys", "maps", "ds", "hy", "cs", "ts", "ils", "hm", "hn", "ins", "ths", "ns"], "ms": ["bs", "mis", "fs", "mys", "rs", "mes", "ks", "MS", "les", "mins", "ps", "s", "sys", "es", "mc", "ma", "m", "ls", "vs", "us", "mn", "mb", "mp", "js", "ims", "mas", "ems", "ml", "mx", "ys", "mus", "mt", "mm", "mos", "cs", "ts", "mi", "is", "sm", "ns"], "ss": ["bs", "fs", "rs", "mes", "SS", "ks", "ses", "sim", "ress", "sv", "ps", "s", "sys", "ess", "es", "si", "sy", "ls", "ser", "gs", "iss", "js", "rss", "sh", "sd", "sw", "ys", "sr", "css", "pse", "cs", "ts", "sc", "su", "ns"], "he": ["h", "hem", "ile", "ve", "hd", "mes", "pe", "ale", "ha", "spe", "che", "him", "ime", "sche", "sv", "het", "hi", "ma", "mn", "te", "He", "ene", "e", "her", "she", "eh", "sh", "hes", "en", "hen", "ke", "we", "em", "HE", "ose", "hy", "oh", "pse", "ue", "le", "ae", "aste"], "me": ["hem", "ge", "mes", "mer", "ve", "dem", "pe", "ale", "mie", "ME", "sche", "es", "ma", "m", "mn", "te", "Me", "mite", "mem", "e", "mate", "mp", "ome", "de", "ems", "lem", "sem", "ml", "mx", "mus", "mt", "ke", "eme", "we", "em", "mit", "pse", "men", "mi", "ue", "le", "aste", "gre"], "se": ["ch", "ge", "mes", "ve", "sb", "pe", "th", "sl", "ses", "SE", "so", "sv", "sche", "st", "ape", "es", "si", "ma", "ser", "te", "ne", "e", "she", "sa", "sk", "sle", "de", "sh", "sd", "sem", "fr", "sr", "ke", "ese", "pse", "sex", "ase", "sc", "le", "sea", "be", "sis", "su", "ze"]}}
{"project": "qemu", "commit_id": "3f2cbf0d1a1340bed4a63e05b044c46df93f4768", "target": 1, "func": "target_phys_addr_t cpu_get_phys_page_debug(CPUState *env, target_ulong addr)\n\n{\n\n    target_ulong pde_addr, pte_addr;\n\n    uint64_t pte;\n\n    target_phys_addr_t paddr;\n\n    uint32_t page_offset;\n\n    int page_size;\n\n\n\n    if (env->cr[4] & CR4_PAE_MASK) {\n\n        target_ulong pdpe_addr;\n\n        uint64_t pde, pdpe;\n\n\n\n#ifdef TARGET_X86_64\n\n        if (env->hflags & HF_LMA_MASK) {\n\n            uint64_t pml4e_addr, pml4e;\n\n            int32_t sext;\n\n\n\n            /* test virtual address sign extension */\n\n            sext = (int64_t)addr >> 47;\n\n            if (sext != 0 && sext != -1)\n\n                return -1;\n\n\n\n            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pml4e = ldq_phys(pml4e_addr);\n\n            if (!(pml4e & PG_PRESENT_MASK))\n\n                return -1;\n\n\n\n            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK))\n\n                return -1;\n\n        } else\n\n#endif\n\n        {\n\n            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK))\n\n                return -1;\n\n        }\n\n\n\n        pde_addr = ((pdpe & ~0xfff) + (((addr >> 21) & 0x1ff) << 3)) &\n\n            env->a20_mask;\n\n        pde = ldq_phys(pde_addr);\n\n        if (!(pde & PG_PRESENT_MASK)) {\n\n            return -1;\n\n        }\n\n        if (pde & PG_PSE_MASK) {\n\n            /* 2 MB page */\n\n            page_size = 2048 * 1024;\n\n            pte = pde & ~( (page_size - 1) & ~0xfff); /* align to page_size */\n\n        } else {\n\n            /* 4 KB page */\n\n            pte_addr = ((pde & ~0xfff) + (((addr >> 12) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            page_size = 4096;\n\n            pte = ldq_phys(pte_addr);\n\n        }\n\n        if (!(pte & PG_PRESENT_MASK))\n\n            return -1;\n\n    } else {\n\n        uint32_t pde;\n\n\n\n        if (!(env->cr[0] & CR0_PG_MASK)) {\n\n            pte = addr;\n\n            page_size = 4096;\n\n        } else {\n\n            /* page directory entry */\n\n            pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) & env->a20_mask;\n\n            pde = ldl_phys(pde_addr);\n\n            if (!(pde & PG_PRESENT_MASK))\n\n                return -1;\n\n            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {\n\n                pte = pde & ~0x003ff000; /* align to 4MB */\n\n                page_size = 4096 * 1024;\n\n            } else {\n\n                /* page directory entry */\n\n                pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & env->a20_mask;\n\n                pte = ldl_phys(pte_addr);\n\n                if (!(pte & PG_PRESENT_MASK))\n\n                    return -1;\n\n                page_size = 4096;\n\n            }\n\n        }\n\n        pte = pte & env->a20_mask;\n\n    }\n\n\n\n    page_offset = (addr & TARGET_PAGE_MASK) & (page_size - 1);\n\n    paddr = (pte & TARGET_PAGE_MASK) + page_offset;\n\n    return paddr;\n\n}\n", "idx": 15136, "substitutes": {"env": ["dn", "context", "event", "worker", "eve", "ve", "end", "server", "here", "nv", "eng", "conf", "er", "enter", "environment", "forge", "shell", " environment", "err", "operator", "vs", "et", "ner", "vp", "te", "console", "viron", "ah", "e", "dev", "window", "response", "network", "entry", "vt", "eh", "ctx", "cv", "estate", "erd", "exc", "door", "ev", "manager", "ew", "engine", "sw", "era", "msg", "conn", "en", "den", "ov", "gear", "param", "ec", "ef", "esc", "attr", "ter", "vert", "Environment", "config", "equ", "inv", "v", "ener", "vm"], "addr": ["oc", "usr", "ord", "ref", "l", "rs", "address", "adj", "ash", "asm", "elt", "Address", "ether", "ha", "hash", "ip", "src", "sha", "ar", "hw", "adr", "er", "oad", "arr", "r", "err", "start", "add", "ptr", "dr", "mem", "alt", "rc", "rr", "len", "hl", "iter", "ack", "index", "eth", "id", "size", "res", "act", "ad", "offset", "msg", "gate", "gt", "order", "attr", "ix", "resp", "rt", "a", "cmd", "arp", "wd", "adv"], "pde_addr": ["pdis_ack", "pne_ptr", "pde__addr", "pde_conn", "pde__adr", "pne__err", "pne__addr", "pne__adr", "pde_ptr", "pne__ptr", "pde_ack", "ple_addr", "pne_err", "pde_err", "ple_add", "pne_adr", "pne_addr", "pdis_conn", "ple_address", "pde_add", "pde__err", "pdis_address", "pde_address", "pde__ptr", "pdis_addr", "pde_adr"], "pte_addr": ["ptee_address", "ptee_add", "pte_address", "pte_id", "pte_add", "ptee_addr", "ptee_id"], "pte": ["apte", "cmdee", "cmdes", "cmdE", "ntE", "ptE", "ntes", "cmde", "ptes", "ntee", "aptE", "ptee", "nte", "aptee", "aptes"], "paddr": ["padd", "_addr", "Paddress", "_ptr", "_address", "paddress", "Paddr", "_add", " paddress", "Padd", " padd", " pptr", "pptr", "Pptr"], "page_offset": ["page_no", " page_pos", " page_no", "page_pos"], "page_size": [" page_len", "page_ize", " page_ize", "page_len"], "pdpe_addr": ["pdpe_sha", "pdpe__pkg", "pdje___addr", "pdje_pad", "pdje___inter", "pdperenpad", "pdpe_pkg", "pdpe__addr", "pdpe_url", "pdje_url", "pdpe_add", "pdperenaddr", "pdje___pad", "pdpe_src", "pdpe2pkg", "pderensha", "pdple2ptr", "pdle_mem", "pde_pad", "pdped_pkg", "pdje___url", "pdped_ref", "pdpe__add", "pdpe__url", "pdped_conn", "pdped_addr", "pdpe___pad", "pdpe___addr", "pdperensha", "pdple2addr", "pdpe__ptr", "pdpe_conn", "pdje_addr", "pdpe____ref", "pderenaddr", "pdle_addr", "pdpe2url", "pdpe2addr", "pdpe____url", "pdle_address", "pdle_add", "pdpe2ptr", "pdpe___inter", "pdpe_address", "pde_src", "pdpe_pad", "pdpe__mem", "pdple_pkg", "pdple_ptr", "pdperensrc", "pdpe__address", "pdpe____pad", "pdje_inter", "pdpe___url", "pdpe_____addr", "pderensrc", "pdpe____pkg", "pdpe____inter", "pdple2pkg", "pderenpad", "pdple_url", "pdpe_ref", "pdple2url", "pdpe____addr", "pdpe____conn", "pdpe_____sha", "pdple_addr", "pdpe_ptr", "pdpe_inter", "pde_sha", "pdpe_____src", "pdpe_mem", "pdpe_____pad"], "pde": ["pddef", "apdes", "pdef", "pene", "pidde", "pcde", "pdu", "ddef", "piddef", " pdem", "pddem", "pidene", "apne", "dde", "prde", "prdef", "pcne", "prdu", "pcdel", "pdes", "pdne", "apde", " pdef", "pdel", "pdene", "ddu", "piddem", "pddel", "pdde", "pne", "pdem", "pddes", " pdu", "pcdes", "apdel", "dene", "prene", " pene"], "pdpe": ["cdpes", "pdfpe", "dpest", "phpfle", "phppes", "PDpe", "ddppe", "pxde", "djpl", "pmpe", "djppe", "PDPe", "PDene", "pidfle", "pedke", "pdene", "dppe", "pedfe", "pdpse", "pdfPE", "pdces", "pdPe", "ddpei", "pnces", "cdpe", "pdest", "pdfke", "pedpes", "pdfde", "dpde", "dppee", "ddpl", "pxest", "pdppe", "pdPE", "pidpes", "dlpl", "cdfe", "pdpl", "dppei", "pdfpse", "pdfle", "phpces", "pdfest", "dlppe", "PDPE", "pdke", "phppe", "dpPE", "dpene", "ddPe", "pdfene", "ddpee", "pnpes", "pdfpes", "pmpei", "cdke", "pmpee", "pnfle", "dpPe", "pmde", "pdffe", "pdpei", "pidpe", "pdfPe", "dlPe", "dppse", "pedpe", "djPe", "pnpe", "pdpes", "dlpe", "pxpe", "ddde", "pdfe", "ddpe", "djpe", "pxpse", "pdpee", "pdde", "pidces"], "pml4e_addr": ["pml4pe__ptr", "pml4e__add", "pml4e__attr", "pml4e_rev", "pml4e_add", "pml4pe_ptr", "pml4e2add", "pml4e_attr", "pml4pe__address", "pml4se_attr", "pml4se_addr", "pml4e__ptr", "pml4e__addr", "pml4e_ptr", "pml4eu_ptr", "pml4e2attr", "pml4eu_address", "pml4eu_addr", "pml4e_address", "pml4pe_addr", "pml4e2addr", "pml4eu_rev", "pml4se_add", "pml4pe__addr", "pml4e__address", "pml4pe_address"], "pml4e": ["pmil49ee", "pmil4ge", "pml3er", "pnl4te", "pml3e", "pml6ee", "pkl4e", "pml3ee", "pkl4se", "pml49ee", "pml3se", "pmil4ee", "pml246ee", "pml3ea", "pml4te", "pnl4pe", "pml246se", "pml8me", "pml2pe", "pnl6pe", "pML5ee", "pml4ge", "pml3te", "pml4me", "pml8e", "pml5me", "pML5me", "pml4ee", "pml49me", "pML4me", "pml6me", "pmil49e", "pml3pe", "pml6pe", "pml246ea", "pnl4er", "pkl4ea", "pkl5e", "pML4e", "pml3me", "pml2er", "pml4ea", "pnl6te", "pkl5ea", "pnl6e", "pmil49ge", "pml5se", "pml2e", "pml5ea", "pml246e", "pmil4e", "pnl6er", "pml5ge", "pml5e", "pml6te", "pml8ee", "pml49e", "pml6ge", "pml2te", "pML4ee", "pkl5ee", "pmil4me", "pmil49me", "pkl4ee", "pnl4e", "pml6er", "pml4se", "pkl5se", "pml4pe", "pml4er", "pML5e", "pml6e", "pml49ge", "pml5ee"], "sext": ["seux", "sexit", " Sexit", "psexp", "leux", " Sext", " sex", "SExt", " Sexp", "leext", "pseft", " Sex", "psext", "peext", "speft", "pext", "SEux", "lext", "pseext", "psex", "teft", "seext", "pexp", "sexp", "spexp", " sexit", "SEext", "seft", "peft", "SEft", "lex", "sex", "teext", " seux", "texp", " seft", " sexp", "text", "SEx", " seext", "speext", "spext", "psexit", "SExp"]}}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "void spapr_pci_rtas_init(void)\n\n{\n\n    spapr_rtas_register(\"read-pci-config\", rtas_read_pci_config);\n\n    spapr_rtas_register(\"write-pci-config\", rtas_write_pci_config);\n\n    spapr_rtas_register(\"ibm,read-pci-config\", rtas_ibm_read_pci_config);\n\n    spapr_rtas_register(\"ibm,write-pci-config\", rtas_ibm_write_pci_config);\n\n    if (msi_supported) {\n\n        spapr_rtas_register(\"ibm,query-interrupt-source-number\",\n\n                            rtas_ibm_query_interrupt_source_number);\n\n        spapr_rtas_register(\"ibm,change-msi\", rtas_ibm_change_msi);\n\n    }\n\n}\n", "idx": 15147, "substitutes": {}}
{"project": "qemu", "commit_id": "8ec14402029d783720f4312ed8a925548e1dad61", "target": 0, "func": "static void compare_sec_rs_finalize(SocketReadState *sec_rs)\n\n{\n\n    CompareState *s = container_of(sec_rs, CompareState, sec_rs);\n\n\n\n    if (packet_enqueue(s, SECONDARY_IN)) {\n\n        trace_colo_compare_main(\"secondary: unsupported packet in\");\n\n    } else {\n\n        /* compare connection */\n\n        g_queue_foreach(&s->conn_list, colo_compare_connection, s);\n\n    }\n\n}\n", "idx": 15173, "substitutes": {"sec_rs": ["sec___RS", " sec_res", "sec___res", "sec___rs", "sect_rs", " sec_rd", "sec_RS", "sect_ris", "sect_res", "sec_ris", "sec_ros", " sec_ros", "sect_rt", "sec_rt", " sec_RS", "sec_rd", "sec___ros", "sec_res"], "s": ["sing", "h", "fs", "d", "l", "rs", "sb", "sl", "z", "ses", "S", "os", "sv", "c", "ps", "comm", "p", "sys", "r", "es", "ssl", "m", "ls", "sports", "syn", "hs", "gs", "ats", "b", "e", "js", "sa", "sts", "w", "sp", "g", "sq", "sw", "sf", "less", "copy", "t", "self", "ds", "se", "ts", "is", "a", "sm", "south", "y", "v", "stats", "sis", "qs", "ns", "ss"]}}
{"project": "qemu", "commit_id": "b47b35250fbfa062aedf6ab6e5faab84c4a76f4f", "target": 1, "func": "FDCtrl *fdctrl_init_isa(DriveInfo **fds)\n\n{\n\n    ISADevice *dev;\n\n\n\n    dev = isa_create(\"isa-fdc\");\n\n    if (fds[0]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveA\", fds[0]->bdrv);\n\n    }\n\n    if (fds[1]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveB\", fds[1]->bdrv);\n\n    }\n\n    if (qdev_init(&dev->qdev) < 0)\n\n        return NULL;\n\n    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);\n\n}\n", "idx": 15201, "substitutes": {"fds": ["qdds", " faults", "frets", "fdat", "prs", "feedcks", " feps", "fyds", "qcks", "tydds", " fls", " frs", "fdates", "fabrets", "feps", "fortds", "tyds", "pds", "qeps", "feedrets", " fdates", "goodds", "gooddds", "fabds", "fdds", "fortdates", "feedds", "vrs", "pd", "tyaults", "fabaults", "qds", "qrs", "gooddat", "fls", "fd", " fd", "feeddocs", "fydocs", "fabdds", "faults", "forteps", "goodrets", " fdds", "vls", "pls", "frs", "fabdat", "tyrs", "fortrs", "vds", "fyrets", "qrets", "fdocs", "qdocs", "fycks", "vd", "fcks", "qdat", "fabrs", "qdates"], "dev": ["device", "d", "dem", "ve", "end", "adj", "DEV", "ow", "priv", "serv", "di", "die", "go", "temp", "buf", "gu", "new", "hw", "eng", "ver", "del", "develop", "def", "cam", "ach", "fo", "add", "tr", "desc", "tech", "pay", "mem", " Dev", "nt", "db", "des", "Dev", "env", "w", "dd", "de", "ev", "ad", "sd", "cho", "data", "conn", "den", "det", "enc", "comment", "debug", "cmd", "val", "v", "var", "adv", "wd", "doc", "obj", "dat", "rem"]}}
{"project": "FFmpeg", "commit_id": "c571424c7f6276a6374e1784ce2a33d4b6a4292d", "target": 1, "func": "static int asf_read_picture(AVFormatContext *s, int len)\n\n{\n\n    ASFContext *asf       = s->priv_data;\n\n    AVPacket pkt          = { 0 };\n\n    const CodecMime *mime = ff_id3v2_mime_tags;\n\n    enum  AVCodecID id    = AV_CODEC_ID_NONE;\n\n    char mimetype[64];\n\n    uint8_t  *desc = NULL;\n\n    AVStream   *st = NULL;\n\n    int ret, type, picsize, desc_len;\n\n    ASFStream *asf_st;\n\n\n\n    /* type + picsize + mime + desc */\n\n    if (len < 1 + 4 + 2 + 2) {\n\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture size: %d.\\n\", len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* picture type */\n\n    type = avio_r8(s->pb);\n\n    len--;\n\n    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) {\n\n        av_log(s, AV_LOG_WARNING, \"Unknown attached picture type: %d.\\n\", type);\n\n        type = 0;\n\n    }\n\n\n\n    /* picture data size */\n\n    picsize = avio_rl32(s->pb);\n\n    len    -= 4;\n\n\n\n    /* picture MIME type */\n\n    len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype));\n\n    while (mime->id != AV_CODEC_ID_NONE) {\n\n        if (!strncmp(mime->str, mimetype, sizeof(mimetype))) {\n\n            id = mime->id;\n\n            break;\n\n        }\n\n        mime++;\n\n    }\n\n    if (id == AV_CODEC_ID_NONE) {\n\n        av_log(s, AV_LOG_ERROR, \"Unknown attached picture mimetype: %s.\\n\",\n\n               mimetype);\n\n        return 0;\n\n    }\n\n\n\n    if (picsize >= len) {\n\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture data size: %d >= %d.\\n\",\n\n               picsize, len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* picture description */\n\n    desc_len = (len - picsize) * 2 + 1;\n\n    desc     = av_malloc(desc_len);\n\n    if (!desc)\n\n        return AVERROR(ENOMEM);\n\n    len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len);\n\n\n\n    ret = av_get_packet(s->pb, &pkt, picsize);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    st  = avformat_new_stream(s, NULL);\n\n    if (!st) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));\n\n    asf_st = asf->asf_st[asf->nb_streams];\n\n    if (!asf_st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;\n\n    st->codec->codec_type         = asf_st->type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id           = id;\n\n    st->attached_pic              = pkt;\n\n    st->attached_pic.stream_index = asf_st->index = st->index;\n\n    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n\n\n\n    asf->nb_streams++;\n\n\n\n    if (*desc) {\n\n        if (av_dict_set(&st->metadata, \"title\", desc, AV_DICT_DONT_STRDUP_VAL) < 0)\n\n            av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n    } else\n\n        av_freep(&desc);\n\n\n\n    if (av_dict_set(&st->metadata, \"comment\", ff_id3v2_picture_types[type], 0) < 0)\n\n        av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_freep(&desc);\n\n    av_free_packet(&pkt);\n\n    return ret;\n\n}\n", "idx": 15206, "substitutes": {"s": ["bs", "i", "h", "fs", "l", "rs", "changes", "n", "simple", "ops", "z", "ses", "sql", "os", "S", "http", "c", "q", "sv", "ps", "comm", "conf", "er", "p", "set", "r", "an", "sys", "m", "es", "vs", "sports", "ls", "us", "hs", "aws", "ms", "gs", "ats", "b", "its", "js", "as", "ims", "sts", "w", "bis", "g", "j", "sq", "sw", "ex", "t", "ds", "cs", "is", "a", "south", "bits", "v", "f", "stats", "ins", "y", "qs", "sync", "ns", "ss"], "len": ["conv", "cmp", "kl", "ptr", "mn", " length", "oln", "pos", "mem", "hl", "fn", "L", "den", "lang", "all", "Len", "h", "mun", "la", "full", "del", "ln", "lon", "size", "limit", "num", "ml", "wid", "en", "enc", "nl", "t", "lib", "ld", "length", "dl", "l", "bytes", "sl", "trans", "compl", "li", "ellen", "pl", "loc", "err", "ls", "syn", "nt", "gen", "total", "lf", "data", "seq", "fl", "il", "val", "lan", "lis", "ref", "lp", "n", "elt", "lt", "ail", " l", "list", "iter", "fun", "str", "lim", "el", "ll", "fin", "vol", "lit", "le"], "asf": [" esf", "Asfo", "Asft", " asft", "asft", " esft", " esfo", "Asfe", " esfe", "Asf", " asfo", "asfe", "asfo", " asfe"], "mime": ["amie", "MIME", " mature", "Mature", "gmimet", "mIME", "amime", "mie", "pIME", "gmie", "mim", "gmime", "smie", "amature", "cmim", "cmie", " mim", "Mie", "mature", "gmIME", "mimet", "amIME", "Mimet", "smim", "pim", "cmime", "Mime", "pime", "Mim", " mie", " mIME", " mimet", "smime", "cmIME", "amim", "smIME", "pie"], "mimetype": ["mrimenamepen", "mimeleype", "mimenameme", "mimagitypen", "mimetyse", "mimetyop", "mimagitytype", "memetytype", "mimetrypes", "mimestylepse", "mimetyme", "mimelepe", "mimetpe", "mimemepl", "mimagestyleme", "mrimenameme", "mimetytype", "mimetyp", "memetme", "mimeletype", "mimeryse", "mimeryme", "mimetyype", "mimitypen", "mimeleme", "mimagetypen", "mimenamepl", "mimetypes", "mimelistpes", "mrimetype", "mimetme", "mimettype", "mimetp", "mimelistpen", "mimemepen", "mimityop", "mimetrype", "mimicyse", "mimetypl", "mimiype", "mrimetypl", "memetype", "mimagitypse", "mrimetyme", "mimitytype", "mimestylese", "mrimetypen", "mimagetypse", "mimagetytype", "mimagetyop", "mimityp", "mimestylep", "mimitypl", "mimityme", "mimetypen", "mimagitype", "mimagestylese", "mimicype", "mimestyleype", "mimagitypes", "mimerype", "mimitype", "mimenamepe", "memetpe", "mimicyme", "mimitypse", "mimagetype", "mimetypse", "mrimenamepe", "mimestylepes", "memetyme", "mimetpes", "mimagetyme", "mimestyleme", "mimelistop", "mimestyletype", "mimelistpe", "mimestylepe", "mimitypes", "mimiypse", "mimiytype", "mimagetyse", "mimagestylepe", "memetyype", "mimiypes", "mimagetypes", "mimetrypen", "mrimenamepl", "memettype", "mimagityop", "mimenamepen", "mimememe", "mimemepe", "mimetryop"], "desc": ["uf", "dist", "ref", "dict", "comp", "asc", "bc", "summary", "txt", "alloc", "buf", "Desc", "cmp", "ext", "sub", "def", "disc", "ptr", "tr", "raw", "buff", "pos", "dev", "nt", "sec", "des", "id", "cont", "res", "str", "feat", "description", "msg", "pres", "seq", "meta", "comment", "enc", "ec", "esc", "ds", "sc", "resp", "cmd", "text", "rec", "obj", "doc", "DES", "label"], "st": ["ST", "std", "stop", "St", "th", "sl", "so", "src", "ist", "ste", "start", "nt", "sp", "stable", "it", "str", "sh", "sw", "ct", "inst", "sta", "t", "sth", "se", "sc", "rest", "stream", "est"], "ret": ["l", " alt", "RET", "elt", "Ret", " code", " ans", "tag", "err", "flag", "alt", "rev", "nt", "rc", " resp", "en", " fmt", " num", " flag", " reply", " Ret", " val", " res", "rt", "lit", "val"], "type": ["shape", "kind", "role", "info", "color", "pe", "time", "ty", "status", "style", "null", "format", "error", "title", "byte", "ime", "cmp", "ver", "Type", "check", "tag", "family", "start", "p", "r", "key", "name", "pos", "code", "tp", "count", "none", "block", "al", "field", "ype", "id", "size", "at", "token", "ico", "like", "class", "t", "typ", "test", "date", "file", "types", "length", "ping", "TYPE"], "picsize": ["micsiz", " picsizer", "picIZE", "Picsizer", "apicsiz", "pICSizer", "apicsize", " pinsiz", "pinsizer", "pinsize", "piquesense", "pickingizer", "Picsiz", "Picsize", "mickingizer", "Picksiz", "picosize", "apickingiz", "apickingze", "picksiz", " picze", " picize", "picoize", "piqueszie", "micsense", "pickingize", " picssize", "micsize", " piciz", "picksIZE", "picsiz", "mickingiz", "picketsense", "pickingsize", "piquesize", "Picksize", "picsense", "piquesiz", "piczie", "picizer", "pICSze", "mickingIZE", "micszie", "micketsense", "pickingiz", "micketsiz", "micsizer", "picssize", "picsze", "PicsIZE", "apickingize", "picksizer", "pickingIZE", "picze", "pinsIZE", "mickingize", "apicsze", "pICSize", " pinsize", "piciz", "picketsize", " pinsizer", "micsIZE", "picsIZE", "picize", " picsze", " picsIZE", "picense", "pickingze", "pinsiz", "micketsize", "picketszie", "PicksIZE", " pinsIZE", "micketszie", "picoiz", "picketsiz", " picsiz", "apickingizer", "apicsizer", "picszie", "Picksizer", "pICSIZE", "picoze", "pICSiz", "picsizer", "picksize"], "desc_len": ["desc_loc", "desc2en", "esc_length", "desc_ln", "esc_loc", " desc_length", "esc_len", "desc_l", "esc_gen", "desc_lon", " desc_ln", "disc_len", "desc2len", "desc2lon", "desc_length", "desc_mem", "desc2mem", "desc_gen", " desc_gen", "disc_mem", "disc_en", "disc_lon", "desc_en", " desc_l"], "asf_st": ["asfo_stream", "asfo_sp", "asf_stream", "asfo_src", "asfo_st", "asf_src", "asf_sp"]}}
{"project": "qemu", "commit_id": "c0f4af171999eda4e49de5169906ce98246457f0", "target": 1, "func": "void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)\n{\n    const ARMCPRegInfo *ri = rip;\n    switch (ri->accessfn(env, ri)) {\n    case CP_ACCESS_OK:\n    case CP_ACCESS_TRAP:\n        break;\n    case CP_ACCESS_TRAP_UNCATEGORIZED:\n        env->exception.syndrome = syn_uncategorized();\n        break;\n    default:\n        g_assert_not_reached();", "idx": 15209, "substitutes": {"env": ["context", "jp", "sb", "pe", "server", "EN", "En", "state", "nv", "hw", "eng", "er", "enter", "environment", "vs", "et", "vp", "te", "viron", "mem", "e", "window", "dev", "shell", "network", "erd", "ctx", "estate", "vt", "eh", "ce", "ev", "me", "en", "conn", "ov", "ef", "ec", "ep", "em", "nc", "Environment", "sc", "config", "pp", "v", "obj", "w", "vm"], "rip": ["ring", "xp", "tri", "rep", "ra", "jp", "rin", "rib", "pa", "ip", "rain", "ps", "gra", "strip", "RIP", "rd", "rem", "ipp", "ripp", "rh", "rim", "rup", "rig", "rid", "piece", "rap", "trip", "roy", "pr", "pp", "par", "rub", "RI", "ping", "rack", "rob"], "syndrome": ["syntchrome", "syindroma", "cyntroma", " syntritic", "syordchrome", " syndrom", " syntroma", "syindrom", "cyntrom", "syindrome", "cyntchrome", "symondritic", " syntrome", "cyntrome", "symondrom", "cyndroma", "syindritic", "syindchrome", "syndchrome", "syntritic", " syntrom", "syndroma", "syordroma", "cyndrome", "symondrome", "syndrom", "syntrome", " syndritic", "symondroma", "syntroma", "syordrom", "syntrom", "cyndchrome", "syndritic", "syordrome", "cyndrom", " syndroma"], "ri": ["ani", "i", "tri", "udi", "raf", "rs", "ra", "pri", "rin", "gi", "pa", "rf", "ti", "hi", "ru", "r", "si", "rx", "ry", "ir", "rd", "ami", "rh", "vi", "na", "rir", "ni", "ro", "rus", "rn", "rl", "rive", "rm", "xi", "rid", "sr", "ric", "ki", "rap", "iro", "riv", "rio", "mi", "rt", "iri", "pi", "rub", "RI", "ris", "ini", "gra", "rob"]}}
{"project": "qemu", "commit_id": "b7c8c35f0afb62efcacd18a64067fe164e3206b6", "target": 1, "func": "static char *scsibus_get_dev_path(DeviceState *dev)\n\n{\n\n    SCSIDevice *d = DO_UPCAST(SCSIDevice, qdev, dev);\n\n    DeviceState *hba = dev->parent_bus->parent;\n\n    char *id = NULL;\n\n\n\n    if (hba && hba->parent_bus && hba->parent_bus->info->get_dev_path) {\n\n        id = hba->parent_bus->info->get_dev_path(hba);\n\n    }\n\n    if (id) {\n\n        return g_strdup_printf(\"%s/%d:%d:%d\", id, d->channel, d->id, d->lun);\n\n    } else {\n\n        return g_strdup_printf(\"%d:%d:%d\", d->channel, d->id, d->lun);\n\n    }\n\n}\n", "idx": 15239, "substitutes": {"dev": ["device", "h", "ch", "info", "dem", "ve", "av", "am", "DEV", "serv", "priv", "die", "out", "os", "buf", "hw", "ver", "def", "p", "cam", "add", "cast", "pro", "desc", "raw", "mem", "att", "nt", "db", "des", "Dev", "vt", "env", "dd", "de", "ev", "ad", "conn", "unknown", "dis", "ex", "doc", "ds", "test", "debug", "pt", "o", "cmd", "v", "obj", "w"], "d": ["dn", "dl", "ind", "ord", "l", "dm", "dict", "dx", "di", "dc", "out", "c", "did", "dh", "del", "dra", "bd", "p", "def", "r", "dr", "dim", "md", "pd", "db", "des", "dd", "done", "de", "D", "j", "ad", "sd", "dj", "dis", "dq", "mod", "t", "ds", "du", "debug", "ld", "dot", "f", "ded", "w", "dat", "da"], "hba": ["shbo", "shBA", "Hba", "habal", "rhda", "haben", "hbo", "hdha", "hdba", "ohBA", "hbu", "heha", "hda", "hebo", "hrca", "habu", "shva", "ehbre", "hca", "rhbra", "hrba", "ehca", " hbra", " hbu", " hBA", "hbal", "heba", "Hca", "hbre", "ehbu", "hha", "heca", "haba", " hbo", " hda", "shba", "ohba", "haca", "ohda", "hbc", "rhba", "ohbra", " hca", "hbra", "hdbo", " hva", "hva", "hBA", "HBA", " hbre", " hbc", "hrbal", " hha", " hben", "ohbc", "Hbc", "hrben", "ehba", "habre", "ohbo", "ohva", "rhca", "ohca", " hbal", "hdca", "hben"], "id": ["event", "i", "h", "entity", "and", "ref", "l", "end", "info", "channel", "bid", "n", "ids", "ident", "sid", "ip", "init", "pid", "c", "q", "oid", "ID", "p", "r", "tag", "start", "uid", "m", "key", "hide", "iden", "name", "aid", "vid", "with", "target", "md", "in", "iter", "no", "len", "path", "index", "mid", "ide", "fd", "it", "str", "url", "ad", "show", "bit", "num", "en", "rid", "el", "like", "t", "Id", "hid", "kid", "link", "a", "source", "f", "cd"]}}
{"project": "FFmpeg", "commit_id": "5e65f5df0e0cd91eed74cce87c5d65b19e176595", "target": 0, "func": "static int eval_lpc_coeffs(const float *in, float *tgt, int n)\n\n{\n\n    int x, y;\n\n    double f0, f1, f2;\n\n\n\n    if (in[n] == 0)\n\n        return 0;\n\n\n\n    if ((f0 = *in) <= 0)\n\n        return 0;\n\n\n\n    in--; // To avoid a -1 subtraction in the inner loop\n\n\n\n    for (x=1; x <= n; x++) {\n\n        f1 = in[x+1];\n\n\n\n        for (y=0; y < x - 1; y++)\n\n            f1 += in[x-y]*tgt[y];\n\n\n\n        tgt[x-1] = f2 = -f1/f0;\n\n        for (y=0; y < x >> 1; y++) {\n\n            float temp = tgt[y] + tgt[x-y-2]*f2;\n\n            tgt[x-y-2] += tgt[y]*f2;\n\n            tgt[y] = temp;\n\n        }\n\n        if ((f0 += f1*f2) < 0)\n\n            return 0;\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 15249, "substitutes": {"in": ["un", "i", "o", "inf", "sum", "ind", "l", "con", "ai", "rin", "serv", "inc", "inn", "null", "win", "out", "nan", "input", "old", "vin", "new", "pin", "add", "inside", "raw", "ne", "min", "din", "att", "window", "ine", "ln", "as", "al", "gin", "inner", "In", "at", "it", "nn", "bin", "en", "ex", "el", "ic", "nin", "doc", "t", "IN", "is", "all", "by", "ins", "f", "pp", "mat", "ac", "isin", "on", "one"], "tgt": ["tgz", "tjs", " tgr", "fTarget", "farge", "tttarget", "frt", "tgb", " target", "matgz", "ngb", "ttgt", "ngt", "ttgr", "ttbt", "ncp", "tbt", "wtgt", " tls", "tTarget", "wtgest", "targe", " tout", "Targ", "wtjs", "tmp", "ttbs", " tmp", "ttrt", "Tgs", "ttgz", "ttarge", " tgs", "Tgt", "tgr", "target", " telt", "tcp", "tout", " tgz", "ntarget", "tsgt", " tgest", "tsmp", "tsls", " targ", " targe", "fgt", " tbs", "pgs", "Tgn", "tenout", "tgs", "ttTarget", "tenjs", "tgest", "matarget", "ttarget", "targ", "felt", "telt", "nmp", " tjs", "parg", " tgb", "fbt", " ttarget", " tgn", "fgb", "matgr", "fls", "pgn", "pgt", "ttgb", " tbt", "wtout", " tcp", "ttelt", "nbs", "tgn", "ttls", "ttcp", "tengest", "trt", "tengt", " tTarget", "matgt", " trt", "tbs", "tsgb", "tls", "nls"], "n": ["dn", "i", "d", "l", "sn", " N", "k", "nw", "nan", "np", "c", "q", "cn", "p", "m", "nm", "mn", "ne", "N", "name", "nt", "no", "ng", "len", "nr", "na", "ni", "g", "j", "nn", "num", "nor", "nl", "nb", "t", "net", "nc", "v", "f", "w", "ns", " ns"], "x": ["ey", "column", "k", "lat", "xe", "px", "u", "xml", "read", "ry", "att", "my", " ax", "xd", "ex", "cross", "scroll", "X", "xx", "h", "ax", "draw", "full", "xt", "m", "height", "name", "at", "j", "xi", "try", "t", "ix", " xx", "by", "f", " i", "yx", " dx", "fx", "ind", "l", "pe", "page", "xf", "batch", "key", "xes", "al", "index", "inx", "xxx", "mx", "ct", " cx", "lex", "axis", "o", "i", "xp", "dx", "time", "z", "tx", "ar", "xc", "p", " w", "xa", "rx", "xs", "dr", "e", "chain", "xy", "ctx", "id", "row", "ox", "wx", "ick", "v", "wh", "w", "on"], "y": ["ey", "entity", "ch", "vy", "dy", "ed", "uy", "ym", "year", "ish", "ry", "my", "ay", "it", "g", "pt", "xx", "h", "py", "ye", "ady", "iy", "yo", "yn", "hot", "sy", "m", "height", "ot", "j", "try", "t", "ery", "by", "yx", "yt", "ny", "one", "wy", "l", "ly", "ty", "di", "ies", "cy", "zy", "key", "no", "axy", "gy", "oy", "yr", "o", "sky", "i", "yi", "z", "kit", "col", "yes", "p", "s", "hey", "b", "yer", "xy", "yu", "ya", "yl", "ys", "ic", "yy", "Y", "v", "iny"], "f0": ["fc512", "f512", "F50", "t2", "xf0", "xf9", "fcold", "told", "f9", "F8", " f8", "fa0", "F512", "t1", "fa1", "fa50", "fc1", "fc2", "F2", "F1", "xf1", "t8", "fc0", "fold", " f50", "xf50", "pold", "F0", "fc50", "p0", "f8", "p1", "fc9", "fa512", "t0", " f9", "p2", "f50"], "f1": ["field01", "t2", "field1", "F01", " f8", "F8", "f9", "F4", " f4", "sf2", "t1", "f01", " f3", "f3", "F2", "F1", " fone", " f01", "fone", "p2", "F9", "sf1", "h4", "h0", "tone", "sfone", "F0", " fart", "fieldart", "p0", "f8", "p1", "field3", "fart", "h2", "F3", "sf0", "t9", "p8", "t0", "h1", " f9", "Fart", "f4"], "f2": ["e2", "p7", "t2", " f02", "c10", "l1", "l2", "e3", "fc10", " fTwo", "f10", "p02", "f02", "t1", "float1", " f7", "e0", "t7", "f3", "fTwo", "fc1", "F2", "fc2", "F1", "t3", "c2", "fcTwo", "F0", " f10", "float02", "float2", "float0", "c1", "p1", "l02", "F3", "l0", "t02", "t0", "f7", "e1", "p2", "cTwo"]}}
{"project": "FFmpeg", "commit_id": "71a1f76d3cc937fc1a47f501fc4866f95b74d0b0", "target": 0, "func": "int swr_init(struct SwrContext *s){\n\n    s->in_buffer_index= 0;\n\n    s->in_buffer_count= 0;\n\n    s->resample_in_constraint= 0;\n\n    free_temp(&s->postin);\n\n    free_temp(&s->midbuf);\n\n    free_temp(&s->preout);\n\n    free_temp(&s->in_buffer);\n\n    free_temp(&s->dither);\n\n    swri_audio_convert_free(&s-> in_convert);\n\n    swri_audio_convert_free(&s->out_convert);\n\n    swri_audio_convert_free(&s->full_convert);\n\n    swri_rematrix_free(s);\n\n\n\n    s->flushed = 0;\n\n\n\n    if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested input sample format %d is invalid\\n\", s->in_sample_fmt);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested output sample format %d is invalid\\n\", s->out_sample_fmt);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    //FIXME should we allow/support using FLT on material that doesnt need it ?\n\n    if(av_get_planar_sample_fmt(s->in_sample_fmt) <= AV_SAMPLE_FMT_S16P || s->int_sample_fmt==AV_SAMPLE_FMT_S16P){\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_S16P;\n\n    }else\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_FLTP;\n\n\n\n    if(   s->int_sample_fmt != AV_SAMPLE_FMT_S16P\n\n        &&s->int_sample_fmt != AV_SAMPLE_FMT_S32P\n\n        &&s->int_sample_fmt != AV_SAMPLE_FMT_FLTP){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is not supported internally, S16/S32/FLT is supported\\n\", av_get_sample_fmt_name(s->int_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    set_audiodata_fmt(&s-> in, s-> in_sample_fmt);\n\n    set_audiodata_fmt(&s->out, s->out_sample_fmt);\n\n\n\n    if (s->out_sample_rate!=s->in_sample_rate || (s->flags & SWR_FLAG_RESAMPLE)){\n\n        s->resample = swri_resample_init(s->resample, s->out_sample_rate, s->in_sample_rate, s->filter_size, s->phase_shift, s->linear_interp, s->cutoff, s->int_sample_fmt);\n\n    }else\n\n        swri_resample_free(&s->resample);\n\n    if(    s->int_sample_fmt != AV_SAMPLE_FMT_S16P\n\n        && s->int_sample_fmt != AV_SAMPLE_FMT_S32P\n\n        && s->int_sample_fmt != AV_SAMPLE_FMT_FLTP\n\n        && s->resample){\n\n        av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16/s32/flt\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n\n\n    if(s->used_ch_count && s-> in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s-> in_ch_layout)){\n\n        av_log(s, AV_LOG_WARNING, \"Input channel layout has a different number of channels than the number of used channels, ignoring layout\\n\");\n\n        s-> in_ch_layout= 0;\n\n    }\n\n\n\n    if(!s-> in_ch_layout)\n\n        s-> in_ch_layout= av_get_default_channel_layout(s->used_ch_count);\n\n    if(!s->out_ch_layout)\n\n        s->out_ch_layout= av_get_default_channel_layout(s->out.ch_count);\n\n\n\n    s->rematrix= s->out_ch_layout  !=s->in_ch_layout || s->rematrix_volume!=1.0 ||\n\n                 s->rematrix_custom;\n\n\n\n#define RSC 1 //FIXME finetune\n\n    if(!s-> in.ch_count)\n\n        s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout);\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n    if(!s->out.ch_count)\n\n        s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\n    if(!s-> in.ch_count){\n\n        av_assert0(!s->in_ch_layout);\n\n        av_log(s, AV_LOG_ERROR, \"Input channel count and layout are unset\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if ((!s->out_ch_layout || !s->in_ch_layout) && s->used_ch_count != s->out.ch_count && !s->rematrix_custom) {\n\n        av_log(s, AV_LOG_ERROR, \"Rematrix is needed but there is not enough information to do it\\n\");\n\n        return -1;\n\n    }\n\n\n\nav_assert0(s->used_ch_count);\n\nav_assert0(s->out.ch_count);\n\n    s->resample_first= RSC*s->out.ch_count/s->in.ch_count - RSC < s->out_sample_rate/(float)s-> in_sample_rate - 1.0;\n\n\n\n    s->in_buffer= s->in;\n\n\n\n    if(!s->resample && !s->rematrix && !s->channel_map && !s->dither_method){\n\n        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0);\n\n        return 0;\n\n    }\n\n\n\n    s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt,\n\n                                             s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0);\n\n    s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                             s->int_sample_fmt, s->out.ch_count, NULL, 0);\n\n\n\n\n\n    s->postin= s->in;\n\n    s->preout= s->out;\n\n    s->midbuf= s->in;\n\n\n\n    if(s->channel_map){\n\n        s->postin.ch_count=\n\n        s->midbuf.ch_count= s->used_ch_count;\n\n        if(s->resample)\n\n            s->in_buffer.ch_count= s->used_ch_count;\n\n    }\n\n    if(!s->resample_first){\n\n        s->midbuf.ch_count= s->out.ch_count;\n\n        if(s->resample)\n\n            s->in_buffer.ch_count = s->out.ch_count;\n\n    }\n\n\n\n    set_audiodata_fmt(&s->postin, s->int_sample_fmt);\n\n    set_audiodata_fmt(&s->midbuf, s->int_sample_fmt);\n\n    set_audiodata_fmt(&s->preout, s->int_sample_fmt);\n\n\n\n    if(s->resample){\n\n        set_audiodata_fmt(&s->in_buffer, s->int_sample_fmt);\n\n    }\n\n\n\n    s->dither = s->preout;\n\n\n\n    if(s->rematrix || s->dither_method)\n\n        return swri_rematrix_init(s);\n\n\n\n    return 0;\n\n}\n", "idx": 15252, "substitutes": {"s": ["bs", "fs", "esm", "ears", "pers", "ps", "r", "args", "ms", "ports", "js", "des", "g", "services", "sw", "gets", "se", "tests", "y", "ins", "grades", "details", "h", "changes", "sb", "ops", "terms", "results", "als", "os", "sv", "has", "ches", "set", "m", "sports", "ges", "events", "ers", "as", "ags", "t", "is", "south", "parts", "ns", "tes", "mods", "l", "rs", "ads", "ies", "S", "c", "eps", "comm", "sys", "ls", "vs", "reads", "hs", "ats", "in", "its", "ims", "ts", "a", "bits", "wcs", "ows", "qs", "params", "sts", "ss", "i", "n", "z", "ses", "conf", "p", "es", "sam", "us", "aws", "gs", "b", "spec", "eds", "less", "ds", "self", "cs", "comments", "v", "stats", "obj", "w"]}}
{"project": "qemu", "commit_id": "8de433cb0820dc1f387a2d580d255744aacd60cc", "target": 1, "func": "void pc_hot_add_cpu(const int64_t id, Error **errp)\n{\n    DeviceState *icc_bridge;\n    int64_t apic_id = x86_cpu_apic_id_from_index(id);\n    if (cpu_exists(apic_id)) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", it already exists\", id);\n    if (id >= max_cpus) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", max allowed: %d\", id, max_cpus - 1);\n    icc_bridge = DEVICE(object_resolve_path_type(\"icc-bridge\",\n                                                 TYPE_ICC_BRIDGE, NULL));\n    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);", "idx": 15260, "substitutes": {"id": ["h", "i", "worker", "and", "bid", "ref", "created", "end", "d", "ids", "time", " fid", "status", "ident", "tx", "x", "error", "ip", "pid", "c", " tid", "ID", "oid", "p", "tag", "start", " pid", "uid", "key", "m", "hide", "vid", "name", "aid", "code", "md", "in", "db", "count", "no", "index", "mid", "ide", "fd", "url", "it", "ad", "show", "wid", "num", "rid", "t", "Id", "hid", "kid", "ick", "f", "length", "one"], "errp": ["errr", "errphp", "eorping", "ererp", "errorphp", " errP", "tracep", "errorr", "tracepa", "ererps", "eorphp", "arrps", " errps", "arrpa", "errorm", "arrp", "erP", " errper", " errpa", "erp", "errorpa", "errm", "ererpre", "errps", "err", "errorper", "eorp", "errP", "eorpa", "errorP", "errorps", " errr", "erm", "errping", " errping", "traceping", "errorpre", " errm", "errorp", "errpa", "ererping", "errper", "errpre", "errorping", "tracephp", "arrper", " errpre"], "icc_bridge": ["ic_link", "ic_Bridge", "icc_interface", "ic_ridge", "ic_interface", "ic_bridge", "icc_link", "icc_Bridge", "icc_ridge"]}}
{"project": "qemu", "commit_id": "5b4a047fbe8ceb68ad1a78d51f0fadbe2bb12af7", "target": 1, "func": "static void xlnx_ep108_init(MachineState *machine)\n\n{\n\n    XlnxEP108 *s = g_new0(XlnxEP108, 1);\n\n    Error *err = NULL;\n\n\n\n    object_initialize(&s->soc, sizeof(s->soc), TYPE_XLNX_ZYNQMP);\n\n    object_property_add_child(OBJECT(machine), \"soc\", OBJECT(&s->soc),\n\n                              &error_abort);\n\n\n\n    object_property_set_bool(OBJECT(&s->soc), true, \"realized\", &err);\n\n    if (err) {\n\n        error_report(\"%s\", error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    if (machine->ram_size > EP108_MAX_RAM_SIZE) {\n\n        error_report(\"WARNING: RAM size \" RAM_ADDR_FMT \" above max supported, \"\n\n                     \"reduced to %llx\", machine->ram_size, EP108_MAX_RAM_SIZE);\n\n        machine->ram_size = EP108_MAX_RAM_SIZE;\n\n    }\n\n\n\n    if (machine->ram_size <= 0x08000000) {\n\n        qemu_log(\"WARNING: RAM size \" RAM_ADDR_FMT \" is small for EP108\",\n\n                 machine->ram_size);\n\n    }\n\n\n\n    memory_region_allocate_system_memory(&s->ddr_ram, NULL, \"ddr-ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(get_system_memory(), 0, &s->ddr_ram);\n\n\n\n    xlnx_ep108_binfo.ram_size = machine->ram_size;\n\n    xlnx_ep108_binfo.kernel_filename = machine->kernel_filename;\n\n    xlnx_ep108_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    xlnx_ep108_binfo.initrd_filename = machine->initrd_filename;\n\n    xlnx_ep108_binfo.loader_start = 0;\n\n    arm_load_kernel(s->soc.boot_cpu_ptr, &xlnx_ep108_binfo);\n\n}\n", "idx": 15288, "substitutes": {"machine": ["computer", "device", "server", "memory", "managed", "message", "smart", "instance", "display", "engine", "description", "maker", "sm", "y", "virtual", "Machine", "vm", "event", "worker", "power", "series", "component", "hello", "division", "connection", "alias", "mc", "m", "host", "model", "money", "zone", "comment", "template", "net", "link", "policy", "command", "kind", "channel", "menu", "direction", "problem", "node", "serial", "session", "service", "achine", "interface", "spin", "cell", "console", "controller", "domain", "shell", "volume", "mode", "agent", "unknown", "hard", "handler", "keeper", "sample", "owner", "dm", "monitor", "sim", "state", "chain", "network", "remote", "manager", "module", "me", "magic", "iso", "table", "scope", "mouse"], "s": ["sg", "space", "http", "ps", "args", "ms", "js", "my", "services", "g", "sd", "se", "sm", "y", "sis", "details", "h", "d", "changes", "sb", "series", "serv", "os", "sv", "set", "store", "client", "m", "sports", "sp", "j", "t", "times", "is", "source", "su", "ns", "rs", "sl", "S", "session", "service", "comm", "sys", "ess", "ls", "vs", "hs", "sq", "ts", "a", "qs", "sts", "ss", "i", "ses", "sim", "p", "es", "sam", "aws", "gs", "b", "sand", "spec", "less", "self", "ds", "cs", "v", "stats", "scope", "w", "sample"], "err": ["usr", "rs", "norm", "Error", "n", "elt", "esp", "die", "txt", "cli", "error", "out", "gz", "buf", "cb", "er", "cer", "notice", "arr", "r", "riot", "dr", "cfg", "e", "rr", "erd", "aaa", "der", "exc", "inner", "rn", "ev", "res", "erb", "msg", "fr", "conn", "mr", "attr", "fee", "gr", " terr", "resp", "kr", "cr", "errors", "obj", "or", "eas", "Er", "ns", "eor"]}}
{"project": "FFmpeg", "commit_id": "00b3ca3c7a779e3b062d6ef0c5067c60c8f8a357", "target": 1, "func": "static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,\n\n                        AVFilterInOut **open_outputs, AVClass *log_ctx)\n\n{\n\n    int pad = 0;\n\n\n\n    while (**buf == '[') {\n\n        char *name = parse_link_name(buf, log_ctx);\n\n        AVFilterInOut *match;\n\n\n\n        if (!name)\n\n            return AVERROR(EINVAL);\n\n\n\n        /* First check if the label is not in the open_outputs list */\n\n        match = extract_inout(name, open_outputs);\n\n\n\n        if (match) {\n\n            av_free(name);\n\n        } else {\n\n            /* Not in the list, so add it as an input */\n\n            match = av_mallocz(sizeof(AVFilterInOut));\n\n            match->name    = name;\n\n            match->pad_idx = pad;\n\n        }\n\n\n\n        insert_inout(curr_inputs, match);\n\n\n\n        *buf += strspn(*buf, WHITESPACES);\n\n        pad++;\n\n    }\n\n\n\n    return pad;\n\n}\n", "idx": 15290, "substitutes": {"buf": ["uf", "bu", "pkg", "queue", "ref", "end", "bar", "ptr", "bytes", "xff", "tmp", "bc", "brace", "txt", "br", "rb", "off", "conv", "cur", "cat", "Buff", "addr", "cb", "err", "batch", "cam", "img", "bound", "nm", "cast", "pb", "raw", "buff", "now", "bag", "port", "mem", "b", "pos", "window", "read", "rc", "iter", "buffer", "block", "ctx", "cv", "str", "Buffer", "caps", "cap", "msg", "data", "seq", "pack", "doc", "aw", "cmd", "text", "wb", "wd", "w"], "curr_inputs": ["curr_tabs", "curr_contextts", "curr_inputeds", "curr_configs", "curr_output_", "curr_outputes", "curr_outputs", "curr_configeds", "curr_contextes", "curr_contexts", "curr_outputeds", "curr_outputjs", "curr_tabjs", "curr_contextjs", "curr_inputts", "curr_inputjs", "curr_configes", "curr_input_", "curr_contexteds", "curr_inputes", "curr_outputts", "curr_tabts", "curr_tab_", "curr_context_", "curr_configts"], "open_outputs": ["open_inputsets", "open_streamjs", "open_inputes", "open2outputjs", "open_logts", "open2inputts", "open2inputjs", "open_Outputes", "open2outputs", "open2outputsets", "open_Outputjs", "open_streamts", "open_columnsets", "open_outputsets", "open_outputts", "open_columnjs", "open_logs", "open_logjs", "open_Outputs", "open_Outputts", "open_inputts", "open_outputes", "open_inputjs", "open_columns", "open2outputts", "open_streams", "open2inputsets", "open_inputs", "open_streames", "open_columnts", "open_logsets", "open_outputjs", "open2inputs"], "log_ctx": ["log_obj", "logkcontext", " log_params", "logkparams", "log_context", " log2pkg", "log2params", " log2params", "logCparams", "logkpkg", "logCcontext", "log2pkg", "log2context", " log_pkg", " log_obj", "log_params", "logCpkg", " log2ctx", " log2context", "log2ctx", " log_context", "log_pkg", "logCctx", "logkctx"], "name": ["search", "info", "type", "prefix", "version", "parent", "n", "Name", "nam", "ident", "word", "title", "group", "local", "out", "value", "NAME", "full", "new", "ver", "alias", "def", "tag", "start", "ma", "nm", "m", "key", "add", "qual", "good", "mem", "common", "code", "names", "none", "no", "len", "path", "index", "id", "size", "str", "me", "cap", "msg", "data", "comment", "class", "filename", "part", "ame", "link", "source", "base", "var", "length", "call", "label"], "match": ["bind", "select", "send", "map", "image", "atch", "reply", "cmp", "patch", "message", "check", "valid", "same", "parse", "apply", "exist", "material", "rule", "record", "mark", "ame", "make", "look", "pair", "detail", "info", "cache", "join", "complete", "matched", "filter", "tag", "m", "pattern", "buffer", "try", "comment", "copy", "get", "link", "part", "print", "mat", "fire", "sum", "parent", "save", "replace", "connect", "allow", "mut", "change", "key", "trace", "mp", "field", "move", "mask", "call", "equal", "search", "comp", "result", "scale", "find", "mate", "me", "see", "watch", "Match", "test", "mount", "diff"], "pad": ["bind", "d", "ind", "prefix", "dx", "map", "ads", "padding", "added", "cmp", "depth", "addr", "np", "new", "scale", "patch", "alias", "p", "pick", "pre", "append", "start", "batch", "add", "ptr", " Pad", "port", "pos", "Pad", "dev", "len", "adder", "ack", "index", "paste", "id", " padd", "crop", "size", "ad", "prep", "grow", "offset", "pod", "num", "max", "mod", "coord", "pat", "pack", "bug", "stroke", "ix", "cmd", "print", "quad", "pend", "length", "delay", "pair"]}}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "void vp8_mc_chroma(VP8Context *s, VP8ThreadData *td, uint8_t *dst1, uint8_t *dst2,\n\n                   ThreadFrame *ref, const VP56mv *mv, int x_off, int y_off,\n\n                   int block_w, int block_h, int width, int height, int linesize,\n\n                   vp8_mc_func mc_func[3][3])\n\n{\n\n    uint8_t *src1 = ref->f->data[1], *src2 = ref->f->data[2];\n\n\n\n    if (AV_RN32A(mv)) {\n\n        int mx = mv->x&7, mx_idx = subpel_idx[0][mx];\n\n        int my = mv->y&7, my_idx = subpel_idx[0][my];\n\n\n\n        x_off += mv->x >> 3;\n\n        y_off += mv->y >> 3;\n\n\n\n        // edge emulation\n\n        src1 += y_off * linesize + x_off;\n\n        src2 += y_off * linesize + x_off;\n\n        ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 3, 0);\n\n        if (x_off < mx_idx || x_off >= width  - block_w - subpel_idx[2][mx] ||\n\n            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {\n\n            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src1 - my_idx * linesize - mx_idx, linesize,\n\n                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n\n                                     x_off - mx_idx, y_off - my_idx, width, height);\n\n            src1 = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n            mc_func[my_idx][mx_idx](dst1, linesize, src1, linesize, block_h, mx, my);\n\n\n\n            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src2 - my_idx * linesize - mx_idx, linesize,\n\n                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n\n                                     x_off - mx_idx, y_off - my_idx, width, height);\n\n            src2 = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n            mc_func[my_idx][mx_idx](dst2, linesize, src2, linesize, block_h, mx, my);\n\n        } else {\n\n            mc_func[my_idx][mx_idx](dst1, linesize, src1, linesize, block_h, mx, my);\n\n            mc_func[my_idx][mx_idx](dst2, linesize, src2, linesize, block_h, mx, my);\n\n        }\n\n    } else {\n\n        ff_thread_await_progress(ref, (3 + y_off + block_h) >> 3, 0);\n\n        mc_func[0][0](dst1, linesize, src1 + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n        mc_func[0][0](dst2, linesize, src2 + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n    }\n\n}\n", "idx": 15301, "substitutes": {"s": ["h", "fs", "d", "rs", "sg", "sb", "sl", "ses", "S", "os", "c", "sv", "ps", "st", "p", "sys", "ssl", "js", "sa", "sp", "sts", "spec", "sd", "sf", "t", "ds", "cs", "ts", "sc", "a", "v", "stats", "f", "w", "ns", "ss"], "td": ["dl", "d", "ind", "std", "dt", "tn", "TD", "th", "nd", "cz", "pc", "tmp", "ctl", "dc", "st", "bd", "def", "disc", "tf", "ptr", "pb", "tr", "ssl", "edd", "md", "tc", "nt", "pd", "db", "SD", "vt", "ctx", "dd", "fd", "tic", "ad", "sd", "ct", "t", "ds", "ts", "pt", "rt", "ld", "cd", "ht"], "dst1": ["Dest3", "drc_", "dist3", "dst4", "Dest1", "Dst3", "dsrc_", " dsrc_", "Dst1", " dsrc2", "dest4", "Dest2", "dest2", "dest_", "Dst2", "dest1", "dost1", "drc3", " dst_", "drc2", "dsrc1", "dsrc3", "dost4", "dsrc2", "Dest4", "dest3", "Dst4", "dost2", "dst3", "dst_", "drc1", " dsrc3", " dsrc1", "dist4", " dst3", "dist2", "dist1", "dost3"], "dst2": ["Dest3", "Dsttwo", "Dest1", "dlytwo", "Dst3", "dly3", "Dst1", "dly1", "desttwo", "Dest2", "dest2", "Dst2", "dest1", "dsrc1", "dsrc3", "dsrctwo", "dsrc2", "dest3", "dst3", "dsttwo", "dly2", "Desttwo"], "ref": ["ff", "fs", "ft", "ind", "req", "pc", "th", "k", "null", "bf", "thread", "error", "re", "tab", "frame", "q", "conf", "p", "def", "r", "tf", "ptr", "pb", "add", "tr", "flow", "tip", "close", "mem", "fb", "in", "db", "rc", "Ref", "reference", "fi", "pointer", "af", "index", "ctx", "id", "ro", "g", "sp", "j", "lf", "range", "act", "fr", "inter", "ef", "t", "Reference", "self", "fc", "link", "resp", "rt", "val", "v", "f", "rec", "obj", "diff", "call", "reset"], "mv": ["MV", "pvm", " mh", "matvt", "Mv", "mvp", "matvm", "dv", "mvm", "dV", "mh", "mf", "Mvm", "vV", "matV", "matvi", "pvc", "mvt", "vvm", "mvi", " mvc", "Mvp", "gmv", "tmV", "tmv", "df", "mV", "matvp", "pvp", "Mf", "vvt", "pV", "gmV", "tmvm", "tmvc", "Mvt", " mV", "gmvm", "dvp", "Mvi", "mvc", "gmvi", "tmva", " mvp", "matv", " mva", "vv", "mva", "Mh", "ph", "matva", " mvm", "tmvp", "pv", " mf"], "x_off": ["xipoff", "rx_off", "x67after", "x67exp", "xipOFF", "xipOff", "x_opp", "m_over", "path_opp", "rx_OFF", "xPoff", "x2Off", "path_exp", "x__off", "x_after", "xzoffer", "x2off", "item67off", "x2OFF", "item_att", "xzoff", "item67att", "x_offs", "x_OFF", "x__OFF", "rx_offer", "x67off", "xxOFF", "xPover", "x_on", "x67att", "xipon", "ox_off", "ex_off", "xzoffs", "x2on", "item_off", "x__Off", "ox_Off", "xxOff", "x_offer", "x_over", "path67off", "ox_on", "ox_OFF", "path67exp", "m_off", "xxoff", "x67opp", "path_off", " x_Off", "x_att", "xPleft", "ex_Off", "item_after", "item67after", "x_Off", " x_OFF", "m_left", "path67opp", "xzOFF", "rx_offs", "ex_OFF", "x_left", "x_exp"], "y_off": ["y2new", "Y_Off", "yy_Off", "Y_off", " y_opp", "y_offer", "y_OFF", " y_old", "y_new", "y_offs", "yJdown", "Y_offs", "yy_off", " y_new", "yJOff", "y2offs", "y2Off", "y_down", " y_open", " y_offset", "yy_offer", "y_open", "y2offset", "y_offset", " y_Off", " y_offs", "yJoff", "ymoff", "y_Off", "ymnew", "z_off", "Y_offset", "y_opp", " y_OFF", "y_old", " y_of", "y2OFF", "z_Off", "z_opp", "z_down", "y2off", "y_of", "yJopp", "ymOFF", "ymoffset"], "block_w": ["block00h", "lock_h", "block__w", "block__h", "block__wr", "block00wr", "block00W", " block_W", "block00w", "block_wr", "block_W", "block__W", "lock_w", " block_wr", "lock_W"], "block_h": [" block_H", "block67hi", "blocklingoh", "block67w", "block2H", "block2h", "block5h", "block_v", "Block_h", "block_width", "block_H", " block_width", "block2w", "block67h", "blocklingh", " block_oh", "block_hi", "block5height", "Block_w", "block_oh", "Block_hi", "blocklingw", " block_height", " block_v", "block_height", "block5w"], "height": ["shape", "h", "rank", "resolution", "ch", "power", "angle", "acity", "th", "ty", "style", "radius", "padding", "history", "hash", "depth", "density", " Height", "capacity", "Height", "hang", "flow", "window", "count", "gravity", "volume", "size", "html", "rows", "grow", "amount", "gy", "bottom", "ows", "y", "wh", "length", "w", "build"], "linesize": ["inesIZE", "namesIZE", "linesIZE", "linsizer", "linesization", "levelsized", "levelsIZE", "timesize", "facessize", "linesized", "cyclesizer", "codesize", "namesizer", "linsize", "codesization", "timesIZE", "linsized", " linesized", "setsization", "pointsize", "linsization", "valsization", "cyclesization", "inesizer", "headsization", "linesizer", "timesization", "cyclesize", "setsizer", "linesze", "codesIZE", " linesze", "facesIZE", "linssize", "valsizer", "valsize", "inesized", "worksizer", "pointsizer", "namesization", " linesization", "levelsizer", "headsize", "worksize", "worksization", "pointsization", "timesizer", "facesized", "setsized", "codesze", "pointsIZE", "setsize", "inesization", "inesze", "linsIZE", "cyclesIZE", "setsIZE", "worksIZE", "headsizer", " linesIZE", "facesize", "namesize", "linessize", "valsIZE", "inesize", "levelsize", " linessize", "headsIZE"], "mc_func": ["mc2function", "mc2kw", "mc_fun", " mc_unc", " mc2fun", " mc_kw", "mc__unc", "mc_kw", "mc__func", "mc2func", "mc_unc", "mc__kw", " mc2func", "mc_function", " mc2function", "mc__function", "mc__fun", " mc_fun", "mc2fun", " mc_function", " mc2kw"], "src1": ["sr2", "source3", "usr1", "source1", " src4", "rc2", "sr1", "source4", "dest2", " srcOne", "dest1", "srOne", " src3", " src10", "rcOne", "src3", "usr2", "sr3", "srcOne", "rc3", "source2", " src01", "dest10", "rc0", "dest0", "rc1", "src01", "src10", "rc10", "src4", "usr01", " src0", "usr0", "rc01", "rc4", "source0", "source01", "src0"], "src2": ["addrtwo", " srctwo", " src4", "rc2", "dest4", "dest2", "dest1", "addr2", "rc0", "dest0", "rc1", "src4", "rctwo", " src0", "addr4", "rc4", "addr1", "src0", "srctwo"]}}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,\n\n                             int width, int height)\n\n{\n\n    int src_wrap, x, y;\n\n    int r, g, b;\n\n    uint8_t *lum, *cb, *cr;\n\n    const uint8_t *p;\n\n\n\n    lum = dst->data[0];\n\n    cb = dst->data[1];\n\n    cr = dst->data[2];\n\n\n\n    src_wrap = src->linesize[0] - width * BPP;\n\n    p = src->data[0];\n\n    for(y=0;y<height;y++) {\n\n        for(x=0;x<width;x++) {\n\n            RGB_IN(r, g, b, p);\n\n            lum[0] = RGB_TO_Y_CCIR(r, g, b);\n\n            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);\n\n            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);\n\n            cb++;\n\n            cr++;\n\n            lum++;\n\n        }\n\n        p += src_wrap;\n\n        lum += dst->linesize[0] - width;\n\n        cb += dst->linesize[1] - width;\n\n        cr += dst->linesize[2] - width;\n\n    }\n\n}\n", "idx": 15321, "substitutes": {"dst": [" dination", "delst", "rmit", "dtdest", "Dv", "dv", " dv", "lest", "sdest", "lst", "ldest", "Dest", "sdoe", "dmit", "dest", "daination", "dtictionary", "dtination", "doe", "thest", "deldest", "thect", "delmit", " dest", "dination", "edst", "Dst", " ddest", "dictionary", "sddest", "ddest", "Ddest", "theest", "rst", " dmit", "lmit", "daest", "lv", "dtst", "lictionary", "rv", "edination", "rdest", "dct", "lination", "theination", "delest", "sdst", "edictionary", "dast", "loe", "eddest", "dact", " dct", " doe"], "src": ["mph", "sn", "rs", "sb", "tmp", "sl", "via", "rb", "init", "SOURCE", "input", "sv", "st", "s", "sys", "scan", "start", "img", "syn", "nil", "ser", "now", "sur", "rc", "sec", "sp", "inner", "sh", "rl", "sq", "supp", "iv", "sr", "inst", "sc", "sup", "source", "rt", "Source", "sort", "ins", "sync", "bg"], "height": ["h", "ch", "resolution", "th", "ty", "style", "radius", "padding", "history", "above", "depth", "density", " Height", "H", "Height", "through", "hang", "ish", "kh", "window", "gravity", "count", "he", "total", "volume", "ih", "tight", "size", "html", "ight", "row", "inches", "stroke", "bottom", "hei", "wh", "visible", "high", "length", "ht"], "src_wrap": ["src2rap", "src_rap", "rc_box", "src2wra", "src_wra", "rc_wra", " src_rap", " src_wrapper", "src2wrapper", "src_wrapper", "rc_wrapper", "src2wrap", " src_box", "rc_wrap", "rc_rap", "src2box", "src_box"], "x": ["fx", "i", "xp", "ch", "l", "ax", "dx", "n", "time", "z", "tx", "lat", "xc", "q", "xf", "xt", "check", "m", "ux", "through", "rx", "xs", "key", "any", "ry", "e", "xy", "inx", "inner", "at", "act", "php", "mx", "xi", "ex", "el", "ox", "t", "X", "ix", "wx", "o", "ace", "v", "f", "yx", "w", "xx", "on"], "y": ["wy", "h", "i", "ey", "ch", "py", "ady", "vy", "ty", "z", "ies", "cy", "iy", "dy", "asy", "very", "uy", "sy", "sys", "ym", "year", "any", "ry", "ot", "xy", "my", "ay", "yet", "j", "html", "it", "at", "ny", "ya", "gy", "axy", "ys", "oy", "t", "yy", "yr", "o", "Y", "sky", "v", "by", "yt"], "r": ["i", "h", "usr", "d", "rate", "l", "rs", "ra", "n", "rin", "k", "ur", "br", "rb", "re", "ar", "c", "u", "q", "er", "err", "m", "ri", "R", "rx", "dr", "ir", "rd", "e", "rc", "rr", "rh", "ro", "rg", "rad", "fr", "sr", "mr", " c", "gr", "vr", "pr", "o", "a", "rt", "v", "f", "var", "rec", "or"], "g": ["gd", "h", "i", "d", "l", "ge", "sg", "n", "gi", "k", "fg", "ag", "gm", "app", "z", "go", "group", "gg", "reg", "gu", "c", "u", "gh", "yg", "vg", "tg", "m", "ger", "org", "cfg", "gs", "e", "ang", "pg", "greg", "G", "gin", "gc", "eg", "rg", "j", "og", "msg", "gy", "gt", "arg", "gr", "ig", "erg", "v", "bg", "mg", "gb"], "b": ["bu", "bs", "h", "i", "l", "sb", "n", "app", "bc", "z", "br", "rb", "c", "u", "ib", "m", "pb", "mb", "fb", "db", "eb", "bb", "bis", "bas", "it", "j", "B", "nb", "t", "ba", "ob", "v", "bi", "base", "bg", "be", "wb", "by", "ab", "emb", "f"], "lum": [" lau", "ulum", " lur", "lau", "Lm", "llumb", "lom", "iolim", "llumi", "lamd", " lums", " lumi", "klums", "lnuminum", " lamd", "lumb", "llom", "lumi", "iolumb", "llum", "tlumb", "lnum", "iolum", " luma", "luma", "klur", "lm", "tlum", "ilum", "ilumm", "klumm", "lnau", "llamd", " lom", "luminum", "lnums", "lums", "Luma", "tluma", "lim", "liau", " lumb", "lium", "lur", " lumm", "klum", "ilur", "lumm", "Lumb", "liuminum", "ulom", "ulumi", "ilums", " lm", "tlm", " lim", " luminum", "llim", "ulumb", "Lum", "liums", "iolamd"], "cb": ["ch", "sb", "abb", "bc", "ck", "bf", "conv", "rb", "ctrl", "dc", "buf", "cur", "np", "lb", "c", "cp", "conf", "cn", "cu", "ib", "pb", "callback", "fb", "cc", "rc", "obb", "eb", "db", "bb", "cv", "zb", "gc", "cf", "erb", "CU", "ci", "cks", "ctr", "nb", "nc", "ub", "cmd", "ob", "wb", "cd", "obs", "CB", "rob"], "cr": ["ch", "pc", "bc", "br", "rb", "ctrl", "dc", "cur", "cy", "cm", "ar", "c", "cp", "core", "adr", "wp", "mc", "arr", "hr", "tr", "rx", "dr", "cc", "rc", "Cr", "rh", "gc", "cv", "car", "ocr", "ro", "CR", "arc", "fr", "rm", "sr", "try", "mr", "ctr", "vol", "crit", "cs", "pr", "sc", "gr", "ca", "cmd", "kr", "cd", "cycle", "rob"], "p": ["pkg", "h", "i", "d", "jp", "rep", "l", "lp", "n", "pc", "z", "dp", "pa", "c", "cp", "u", "ps", "q", "ap", "wp", "m", "pb", "pos", "e", "tp", "sp", "P", "j", "t", "pr", "pt", "o", "a", "pp", "pi", "v", "f", "w"]}}
{"project": "qemu", "commit_id": "a5cf8262e4eb9c4646434e2c6211ef8608db3233", "target": 0, "func": "static char *pcibus_get_fw_dev_path(DeviceState *dev)\n\n{\n\n    PCIDevice *d = (PCIDevice *)dev;\n\n    char path[50], name[33];\n\n    int off;\n\n\n\n    off = snprintf(path, sizeof(path), \"%s@%x\",\n\n                   pci_dev_fw_name(dev, name, sizeof name),\n\n                   PCI_SLOT(d->devfn));\n\n    if (PCI_FUNC(d->devfn))\n\n        snprintf(path + off, sizeof(path) + off, \",%x\", PCI_FUNC(d->devfn));\n\n    return strdup(path);\n\n}\n", "idx": 15341, "substitutes": {"dev": ["device", "dem", "ve", "dm", "av", "n", "DEV", "serv", "priv", "di", "buf", "hw", "ver", "def", "p", "sys", "cam", "cast", "pro", "raw", "mem", "md", "att", "nt", "home", "des", "Dev", "dd", "de", "ev", "ad", "sd", "data", "conn", "ie", "dis", "det", "test", "ds", "debug", "cmd", "val", "v", "wd", "obj", "w"], "d": ["gd", "dn", "ind", "l", "ord", "info", "dm", "hd", "n", "dx", "dom", "nd", "z", "di", "dc", "c", "did", "dh", "p", "def", "dr", "dim", "md", "pd", "db", "od", "dd", "done", "fd", "D", "ad", "sd", "dj", "dis", "det", "mod", "t", "ds", "du", "debug", "o", "ld", "v", "f", "td", "w", "dat", "da"], "path": ["pkg", "context", "kind", "l", "ref", "prefix", "parent", "PATH", "n", "th", "time", "route", " PATH", "history", "x", "out", "value", "full", "temp", "c", "dest", "patch", "root", "tree", "loc", "p", "zip", "this", "list", "key", "desc", "walk", "binding", "spec", "read", "trace", "window", "chain", "ATH", "pointer", "Path", "index", "id", "dir", "inner", "url", "str", "transform", "html", "rect", "data", "ex", "template", "self", "test", "file", " Path", "pt", "mount", "cmd", "text", "wd", "ath", "length", "output"], "name": ["info", "l", "prefix", "type", "version", "parent", "n", "Name", "nam", "word", "title", "error", "out", "NAME", "new", "alias", "named", "r", "nm", "key", "mem", "names", "no", "len", "id", "size", "str", "description", "item", " Name", "data", "normal", "comment", "filename", "part", "ame", "a", "all", "base", "f", "user", "length", "w", "on", "label"], "off": ["before", "low", "ff", "ord", "ref", "end", "n", "opt", "miss", " on", "then", " OFF", "out", "along", "offer", "new", "hot", "hand", "def", "set", "zero", "start", "from", "m", " Off", "raw", "now", "pos", "window", "of", "nt", "Off", "offs", "over", "ot", "no", "op", "j", "after", "offset", "ex", "open", "det", " offset", "t", "OFF", "down", "o", "pad", " af", "length", "on", "one", "shift"]}}
{"project": "qemu", "commit_id": "f69a8bde29354493ff8aea64cc9cb3b531d16337", "target": 1, "func": "static int qio_channel_websock_handshake_send_response(QIOChannelWebsock *ioc,\n\n                                                       const char *key,\n\n                                                       Error **errp)\n\n{\n\n    char combined_key[QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n                      QIO_CHANNEL_WEBSOCK_GUID_LEN + 1];\n\n    char *accept = NULL, *response = NULL;\n\n    size_t responselen;\n\n\n\n    g_strlcpy(combined_key, key, QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + 1);\n\n    g_strlcat(combined_key, QIO_CHANNEL_WEBSOCK_GUID,\n\n              QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n              QIO_CHANNEL_WEBSOCK_GUID_LEN + 1);\n\n\n\n    /* hash and encode it */\n\n    if (qcrypto_hash_base64(QCRYPTO_HASH_ALG_SHA1,\n\n                            combined_key,\n\n                            QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n                            QIO_CHANNEL_WEBSOCK_GUID_LEN,\n\n                            &accept,\n\n                            errp) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    response = g_strdup_printf(QIO_CHANNEL_WEBSOCK_HANDSHAKE_RESPONSE, accept);\n\n    responselen = strlen(response);\n\n    buffer_reserve(&ioc->encoutput, responselen);\n\n    buffer_append(&ioc->encoutput, response, responselen);\n\n\n\n    g_free(accept);\n\n    g_free(response);\n\n\n\n    return 0;\n\n}\n", "idx": 15368, "substitutes": {"ioc": [" ioh", "iocy", "iroc", "iOC", "dioci", "iioc", "iiocon", "piocon", "iooc", " ioco", "IOC", "ioocon", " iocy", "ioocy", "ioh", "Iocy", "pioci", "iioco", "dioh", "pioc", "ioroc", "ioci", " iroc", " ioci", "dioc", " iOC", "iooco", "ioOC", "iiroc", "Ioc", "iocon", "diocon", "Ioco", "ioco", "pioh", " iocon"], "key": ["context", "ey", "prefix", "type", "pri", "k", "keys", "server", "json", "hash", "value", "password", "ip", "q", "Key", "client", "host", "name", "code", "mac", "id", "ay", " KEY", "lock", "data", "KEY", "conn", "ice", "token", "ek", "ssh", "link", "sky", "y", "base", "query", "pair"], "errp": ["errr", "errpe", "aerp", " errps", "derpe", "aerpa", "erp", " errpa", "err", "derp", "errps", "aerr", "derpa", "derr", " errbp", "erps", " errr", "derbp", " errpe", "errpa", "erbp", "aerpe", "derps", "errbp"], "combined_key": ["combed_link", "combinedlykey", "combpleted_message", "combinedptlink", "combined_Key", "combinedlyKEY", "combpleted_keys", "combed_key", "combinedopKey", "combined_link", "combinated_query", "combpletedlyKEY", "combine_key", "combine_Key", "combined_KEY", "combpletedlykeys", "combinedptquery", "combined_query", "combinedlykeys", "combed_name", "combed_Key", "combined_name", "combine_KEY", "combinedoplink", "combinedPkeys", "combinedlymessage", "combpletedlymessage", "combinedPkey", "combinedopname", "combined_keys", "combinated_link", "combinated_key", "combinedopkey", "combinedPKEY", "combined_message", "combpletedlykey", "combinedptkey", "combpleted_key", "combinedPmessage", "combpleted_KEY"], "accept": ["event", "own", "view", "req", "select", "send", "ax", "opt", "serv", "success", "hello", "content", "json", "answer", "off", "ait", "feed", "buf", "escape", "input", "claim", "result", "offer", "except", "account", "connect", " Accept", "allow", "pass", "update", "valid", "acceptable", "upload", "match", "iter", "apply", "request", "ack", "ok", "cont", "alert", "access", "seq", "open", "el", "Accept", "pack", "release", "control", "aw", "crit", "acc", "resp", "ac", "rec", "agree", "process", "adapt", "wait"], "response": ["version", "type", "ve", "bytes", "image", "route", "success", "hello", "server", "json", "answer", "secret", "complete", "error", "value", "reply", "connection", "sequence", "hash", "next", "result", "service", "frame", "offer", "respons", "tree", "message", "xml", "def", "verse", "timeout", "application", "entry", "query", "block", "remote", "buffer", "request", "res", "description", "data", "Response", "vector", "body", "bye", "resp", "command", "relation", "example", "output", "onse", "out"], "responselen": ["responselun", "responserun", "responscellen", "responsoleer", "responslize", "responsolelen", "responseren", "responsselern", "responslength", "responcelon", "responscelength", "responcilength", "responscelen", "responselon", "responscelize", "responcentength", "responsoleen", "responserern", "responcentun", "responcelern", "responcelun", "responselize", "responseler", "responsselength", "responscelens", "responslon", "responcilize", "responcelize", "responselens", "responsceler", "responsseler", "responssellen", "responselern", "responsselize", "responcelen", "responselslen", "responcentern", "responcilen", "responselsun", "responscelun", "responsselun", "responslen", "responcelens", "responselsength", "responcilon", "responselsen", "responcellen", "responcelength", "responselength", "responsselen", "responslens", "responscelon", "responceler", "responsselon", "responcenten", "responsoleength", "responsselens", "responserength", "responselser", "responselsens", "responsellen", "responslun", "responscelern"]}}
{"project": "qemu", "commit_id": "50628d3479e4f9aa97e323506856e394fe7ad7a6", "target": 1, "func": "void dpy_gfx_copy(QemuConsole *con, int src_x, int src_y,\n\n                  int dst_x, int dst_y, int w, int h)\n\n{\n\n    DisplayState *s = con->ds;\n\n    DisplayChangeListener *dcl;\n\n\n\n    if (!qemu_console_is_visible(con)) {\n\n        return;\n\n    }\n\n    QLIST_FOREACH(dcl, &s->listeners, next) {\n\n        if (con != (dcl->con ? dcl->con : active_console)) {\n\n            continue;\n\n        }\n\n        if (dcl->ops->dpy_gfx_copy) {\n\n            dcl->ops->dpy_gfx_copy(dcl, src_x, src_y, dst_x, dst_y, w, h);\n\n        } else { /* TODO */\n\n            dcl->ops->dpy_gfx_update(dcl, dst_x, dst_y, w, h);\n\n        }\n\n    }\n\n}\n", "idx": 15373, "substitutes": {"con": ["un", "cal", "cache", "CON", "pc", "bc", "win", "txt", "conv", "x", "fac", "ctrl", "connection", "acon", "cur", "col", "screen", "c", "xc", "cp", "comm", "cn", "pen", "cons", "conf", "connect", "ver", "an", "pl", "client", "anon", "ran", "console", "icon", "ln", "ain", "cc", "com", "db", "gen", "fn", "ctx", "cv", "cont", "act", "Con", "num", "en", "conn", "anc", "soc", "ocon", "enc", "open", "func", "nc", "fc", "ca", "sc", "cs", "master", "ins", "obj", "can", "on", "current", "co"], "src_x": ["rc_rx", "rc_ix", "src_rx", "rc_x", " src_ex", "src__xp", "src_ix", "rc_xp", " src_xp", "src_ex", "src__x", "src_xp", "src__ex"], "src_y": ["rc_yy", "pkg_yy", "rc_x", "src_xy", "rc_xy", "src__y", "src__yy", "src__xy", "pkg_ny", "src_yy", "pkg_ch", "src_ny", "rc_y", "pkg_y", "src__ch", "src__x", "src_ch", "src__ny"], "dst_x": ["ddest_mm", "ddest_y", "dst__x", "dst_mm", "dst__rx", "dst__y", "ddest_x", "dst_ex", "ddest_ex", "dst_rx", "dst__ex", "ddest_rx"], "dst_y": ["dst_Y", "dsrc_ry", "dst_yy", "dtmp_ies", "dtmp_ty", "dsrc_ya", "ddest_y", "dst__x", "dst___ies", "dtmp___ty", "dsrc_y", "dsrc_Y", "dst___ry", "dst___y", "dst_ya", "dtmp_ry", "dst__y", "ddest_x", "dtmp___ies", "dst_ies", "dst_ty", "dtmp_y", "ddest_yy", "dst_ry", "dtmp___ry", "ddest_i", "dst__yy", "dst_i", "dtmp___y", "dst___ty", "dst__i"], "w": ["wl", "d", "kw", "ow", "nw", "wal", "win", "x", "wi", "hw", "wp", " dw", "m", "whe", "wr", "window", "W", "wa", "wt", "ew", "sw", "wid", "wn", "iw", "we", "widget", "fw", "work", "aw", "rw", "wx", "wcs", "wh", "wb", "wd"], "h": ["ch", "l", "hh", "hd", "th", "ha", "hash", "c", "q", "bh", "dh", "hz", "hi", "H", " H", "height", "m", "hr", "ish", "kh", "b", "ho", "ah", "hl", "rh", "ih", "he", "html", "it", "sh", "help", "uh", "oh", "hei", "o", "v", "wh", "ph", "high", "length", "ht", "hold"], "s": ["bs", "fs", "rs", "sol", "n", "sb", "serv", "sl", "spe", "ses", "S", "os", "so", "ar", "c", "sv", "st", "p", "set", "sys", "ssl", "ls", "gs", "ats", "b", "iss", "js", "sts", "sq", "t", "ds", "cs", "ts", "sc", "sis", "scl", "ns", "ss"], "dcl": ["doblock", "madctr", "sdCL", " dblock", "ddlr", " dacl", "dwl", "dpl", " dbl", " dwl", "dfl", "sdcl", "dCL", "daacl", "adbl", " dCL", "pdcl", " dca", "ddcl", "deCL", "debugcl", "adCL", "dlc", "docl", "dlf", "adcl", "dnl", "debugbl", "calcl", "ddpl", "ddca", "sdbl", "debugcom", "dbl", "pdpl", "dolc", "madlf", "Dpl", "Dbl", "pdcom", "dctr", "ddCL", "dca", " dlc", "Dctr", " dctr", "doCl", "dofl", "delr", "decl", "Dcl", "dobl", "danl", "depl", "dCl", "calCl", "Dlf", "ddlc", " dlf", "debugwl", "dlr", " dCl", "pdbl", " dfl", "madbl", "madcl", "dacl", " dpl", "dcom", "Dfl", "adfl", "pdacl", "pdwl", "calbl", "doca", "pdnl", "calblock", "DCL", "ddfl", " dnl", "madpl", "sdfl", "dapl", "dblock", " dlr", " dcom"]}}
{"project": "qemu", "commit_id": "3c94193e0bbdd855bcbedabd27e3cbe1e6bc6242", "target": 1, "func": "static TCGArg *tcg_constant_folding(TCGContext *s, uint16_t *tcg_opc_ptr,\n                                    TCGArg *args, TCGOpDef *tcg_op_defs)\n{\n    int i, nb_ops, op_index, nb_temps, nb_globals, nb_call_args;\n    TCGOpcode op;\n    const TCGOpDef *def;\n    TCGArg *gen_args;\n    TCGArg tmp;\n    TCGCond cond;\n    /* Array VALS has an element for each temp.\n       If this temp holds a constant then its value is kept in VALS' element.\n       If this temp is a copy of other ones then the other copies are\n       available through the doubly linked circular list. */\n    nb_temps = s->nb_temps;\n    nb_globals = s->nb_globals;\n    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n    nb_ops = tcg_opc_ptr - gen_opc_buf;\n    gen_args = args;\n    for (op_index = 0; op_index < nb_ops; op_index++) {\n        op = gen_opc_buf[op_index];\n        def = &tcg_op_defs[op];\n        /* Do copy propagation */\n        if (op == INDEX_op_call) {\n            int nb_oargs = args[0] >> 16;\n            int nb_iargs = args[0] & 0xffff;\n            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {\n                if (temps[args[i]].state == TCG_TEMP_COPY) {\n                    args[i] = find_better_copy(s, args[i]);\n        } else {\n            for (i = def->nb_oargs; i < def->nb_oargs + def->nb_iargs; i++) {\n                if (temps[args[i]].state == TCG_TEMP_COPY) {\n                    args[i] = find_better_copy(s, args[i]);\n        /* For commutative operations make constant second argument */\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(mul):\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(eqv):\n        CASE_OP_32_64(nand):\n        CASE_OP_32_64(nor):\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n        CASE_OP_32_64(brcond):\n            if (temps[args[0]].state == TCG_TEMP_CONST\n                && temps[args[1]].state != TCG_TEMP_CONST) {\n                tmp = args[0];\n                args[0] = args[1];\n                args[1] = tmp;\n                args[2] = tcg_swap_cond(args[2]);\n        CASE_OP_32_64(setcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state != TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n                args[3] = tcg_swap_cond(args[3]);\n        CASE_OP_32_64(movcond):\n            cond = args[5];\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state != TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n                cond = tcg_swap_cond(cond);\n            /* For movcond, we canonicalize the \"false\" input reg to match\n               the destination reg so that the tcg backend can implement\n               a \"move if true\" operation.  */\n            if (args[0] == args[3]) {\n                tmp = args[3];\n                args[3] = args[4];\n                args[4] = tmp;\n                cond = tcg_invert_cond(cond);\n            args[5] = cond;\n        /* Simplify expressions for \"shift/rot r, 0, a => movi r, 0\" */\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[1]].val == 0) {\n        /* Simplify expression for \"op r, a, 0 => mov r, a\" cases */\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n        CASE_OP_32_64(or):\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                /* Proceed with possible constant folding. */\n            if (temps[args[2]].state == TCG_TEMP_CONST\n                && temps[args[2]].val == 0) {\n                if (temps_are_copies(args[0], args[1])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n        /* Simplify expression for \"op r, a, 0 => movi r, 0\" cases */\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(mul):\n            if ((temps[args[2]].state == TCG_TEMP_CONST\n                && temps[args[2]].val == 0)) {\n        /* Simplify expression for \"op r, a, a => mov r, a\" cases */\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(and):\n                if (temps_are_copies(args[0], args[1])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n        /* Propagate constants through copy operations and do constant\n           folding.  Constants will be substituted to arguments by register\n           allocator where needed and possible.  Also detect copies. */\n        CASE_OP_32_64(mov):\n            if (temps_are_copies(args[0], args[1])) {\n                args += 2;\n                gen_opc_buf[op_index] = INDEX_op_nop;\n            if (temps[args[1]].state != TCG_TEMP_CONST) {\n                tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n                args += 2;\n            /* Source argument is constant.  Rewrite the operation and\n               let movi case handle it. */\n            op = op_to_movi(op);\n            gen_opc_buf[op_index] = op;\n            args[1] = temps[args[1]].val;\n            /* fallthrough */\n        CASE_OP_32_64(movi):\n            tcg_opt_gen_movi(gen_args, args[0], args[1]);\n            args += 2;\n        CASE_OP_32_64(not):\n        CASE_OP_32_64(neg):\n        CASE_OP_32_64(ext8s):\n        CASE_OP_32_64(ext8u):\n        CASE_OP_32_64(ext16s):\n        CASE_OP_32_64(ext16u):\n        case INDEX_op_ext32s_i64:\n        case INDEX_op_ext32u_i64:\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding(op, temps[args[1]].val, 0);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n            args += 2;\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(mul):\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n        CASE_OP_32_64(andc):\n        CASE_OP_32_64(orc):\n        CASE_OP_32_64(eqv):\n        CASE_OP_32_64(nand):\n        CASE_OP_32_64(nor):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding(op, temps[args[1]].val,\n                                          temps[args[2]].val);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args += 3;\n        CASE_OP_32_64(setcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding_cond(op, temps[args[1]].val,\n                                               temps[args[2]].val, args[3]);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args += 4;\n            args += 4;\n        CASE_OP_32_64(brcond):\n            if (temps[args[0]].state == TCG_TEMP_CONST\n                && temps[args[1]].state == TCG_TEMP_CONST) {\n                if (do_constant_folding_cond(op, temps[args[0]].val,\n                                             temps[args[1]].val, args[2])) {\n                    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n                    gen_opc_buf[op_index] = INDEX_op_br;\n                    gen_args[0] = args[3];\n                    gen_args += 1;\n                } else {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n            } else {\n                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args += 4;\n            args += 4;\n        CASE_OP_32_64(movcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding_cond(op, temps[args[1]].val,\n                                               temps[args[2]].val, args[5]);\n                if (temps_are_copies(args[0], args[4-tmp])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else if (temps[args[4-tmp]].state == TCG_TEMP_CONST) {\n                    tcg_opt_gen_movi(gen_args, args[0], temps[args[4-tmp]].val);\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[4-tmp]);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args[4] = args[4];\n                gen_args[5] = args[5];\n                gen_args += 6;\n            args += 6;\n        case INDEX_op_call:\n            nb_call_args = (args[0] >> 16) + (args[0] & 0xffff);\n            if (!(args[nb_call_args + 1] & (TCG_CALL_CONST | TCG_CALL_PURE))) {\n                for (i = 0; i < nb_globals; i++) {\n                    reset_temp(i);\n            for (i = 0; i < (args[0] >> 16); i++) {\n                reset_temp(args[i + 1]);\n            i = nb_call_args + 3;\n            while (i) {\n                *gen_args = *args;\n                args++;\n                gen_args++;\n                i--;\n            /* Default case: we do know nothing about operation so no\n               propagation is done.  We trash everything if the operation\n               is the end of a basic block, otherwise we only trash the\n               output args.  */\n            if (def->flags & TCG_OPF_BB_END) {\n                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n            } else {\n                for (i = 0; i < def->nb_oargs; i++) {\n                    reset_temp(args[i]);\n            for (i = 0; i < def->nb_args; i++) {\n                gen_args[i] = args[i];\n            args += def->nb_args;\n            gen_args += def->nb_args;\n    return gen_args;", "idx": 15388, "substitutes": {"tcg_constant_folding": ["tcg_constant_creating", "tcg_constant_creatling", "tcg_constant_foldding", "tcg_constant_foldending", "tcg_constant_constructending", "tcg_constant_drawending", "tcg_constant_drawing", "tcg_constant_constructding", "tcg_constant_foldling", "tcg_constant_drawling", "tcg_constant_creatending", "tcg_constant_drawding", "tcg_constant_creatding", "tcg_constant_constructing", "tcg_constant_constructling"], "TCGContext": ["tcGObject", "TCGUContext", "TCGUHandle", "tcGCObject", "TCGUObject", "TCGUcontext", "TCCObject", "tcGCHandle", "tcGcontext", "TCCHandle", "TCGCContext", "tcGHandle", "tcGCContext", "TCGCHandle", "TCGCObject", "tcGCcontext", "TCGHandle", "TCGCcontext", "TCGObject", "tcGContext", "TCCcontext", "TCCContext", "TCGcontext"], "s": ["h", "d", "fs", "rs", "sg", "n", "sb", "app", "z", "ses", "S", "os", "space", "c", "sv", "ps", "comm", "p", "sys", "r", "es", "m", "xs", "hs", "gs", "b", "e", "its", "js", "ats", "in", "ims", "sts", "w", "ctx", "g", "sq", "ex", "t", "ds", "self", "times", "cs", "ts", "source", "a", "is", "v", "y", "ins", "stats", "scl", "ns", "ss"], "uint16_t": ["uint16__2", "uint16__T", "uint32_T", "uint16__t", "uint16_p", "uint32_t", "uint16__p", "uint32_2", "uint16_2", "uint32_p", "uint16_T"], "tcg_opc_ptr": ["tcg_opc_pointers", "tcg_opc2ptr", "tcg_opC_ptr", "tcg_opC_pointers", "tcg_opf_pointer", "tcg_opc_pointer", "tcg_opc2buf", "tcg_opC_addr", "tcg_opC_pointer", "tcg_opc_buf", "tcg_opc_addr", "tcg_opc2ctx", "tcg_opc2pointer", "tcg_opc_ctx", "tcg_opf_buf", "tcg_opf_ptr", "tcg_opf_ctx"], "TCGArg": ["TFGDef", "TCCGParam", "TCCGVar", "TFGArg", "TFCGVar", "TCgArgs", "TCCGTag", "TCGVar", "TFCGParam", "TCGPArgs", "TCGUContext", "TCGCArg", "TCGUArg", "TCCarg", "TCGarg", "TCgContext", "LCGTag", "LCGCTag", "TCgArg", "TCGCTag", "TCGIArg", "TCCArg", "TCGPArg", "TCgarg", "TCGCArgs", "TCGPParam", "TCPGArgs", "TCCGarg", "TCgVar", "TCGUarg", "TCGParg", "LCGCArg", "LCGarg", "TCCGDef", "TCGParam", "TCCGArg", "TFGarg", "TCCGContext", "TCGArgs", "LCGCArgs", "TFCGArg", "LCGArgs", "TCPGArg", "TCgDef", "LCGArg", "TFCGContext", "TCGTag", "TFGParam", "TFCGDef", "TCGCarg", "TFCGarg", "TFGContext", "TFGVar", "TCGUVar", "TCGITag", "TCGIArgs", "TFCGArgs", "LCGCarg", "TFGArgs", "TCCParam", "TCCArgs", "TCCGArgs", "TCPGDef", "TCGIarg", "TCPGarg", "TCGDef"], "args": ["bs", "fs", "ids", "flags", "amps", "ps", "alls", "ms", "ports", "names", "js", "vals", "rows", "ex", "tests", "ins", "grades", "posts", "issues", "uments", "cache", "limits", "points", "terms", "results", "ands", "ams", "atts", "as", "ags", "tags", "ians", "apps", "parts", "ns", "rs", "bytes", "jobs", "ads", "words", "eps", "sys", "arr", "bugs", "vs", "seconds", "modules", "its", "members", "uns", "ims", "facts", "values", "ents", "frames", "orders", "arg", "ts", "items", "bits", "qs", "ras", "Args", "params", "arms", "settings", "aus", "__", "fields", "weights", "users", "xs", "aws", "gs", "ctx", "workers", "aps", "ds", "actions", "stats", "docs"], "TCGOpDef": ["TCGOtpdef", "TCGOxpDecl", "TCGUopdef", "TCGUopDef", "TCGUpdef", "TCGOcpGen", "TCGOpGen", "TCGOxpDef", "TCGOopGen", "TCGOopDecl", "TCGOtpDecl", "TCGOtpDesc", "TCGOpdef", "TCGOopdef", "TCGEtpdef", "TCGEtpDecl", "TCGUpGen", "TCGEpDesc", "TCGOpDecl", "TCGOopDesc", "TCGUopDesc", "TCGOcpdef", "TCGUpDesc", "TCGOxpdef", "TCGOcpDesc", "TCGUpDef", "TCGOopDef", "TCGOtpGen", "TCGOtpDef", "TCGEpdef", "TCGOpDesc", "TCGOxpDesc", "TCGEpDecl", "TCGEtpDef", "TCGOcpDef", "TCGUopGen", "TCGEtpDesc", "TCGEpDef"], "tcg_op_defs": ["tcg_op__defeds", "tcg_op_declds", "tcg_op2defs", "tcg_op_decls", "tcg_op_devs", "tcg_op__defs", "tcg_op_Defeds", "tcg_op_efs", "tcg_op2defers", "tcg_op_declinitions", "tcg_op_defers", "tcg_op__efs", "tcg_op_devds", "tcg_op_Defers", "tcg_op__definitions", "tcg_op_efinitions", "tcg_op_declers", "tcg_op__efts", "tcg_op_defds", "tcg_op2Defds", "tcg_op__efeds", "tcg_op_devinitions", "tcg_op_Defds", "tcg_op__efinitions", "tcg_op_Defs", "tcg_op2Definitions", "tcg_op_definitions", "tcg_op_defeds", "tcg_op2Defers", "tcg_op2definitions", "tcg_op_Definitions", "tcg_op2Defs", "tcg_op__defts", "tcg_op_devers", "tcg_op_Defts", "tcg_op_efts", "tcg_op_defts", "tcg_op2defds", "tcg_op_efeds"], "i": ["status", "cli", "oi", " m", " ii", "it", "ci", "ite", "ki", "zi", " mi", " iter", "mi", "y", "uri", "h", "info", "ii", "ji", "series", "ij", "iy", " pi", "m", "ri", "multi", "to", "j", "xi", "t", "ix", "is", "print", "ui", "ini", "qi", "ai", "parent", "di", "x", " bi", "ti", "li", "\u0438", "I", "si", "batch", "im", "in", "ims", "fi", "index", "phi", "pi", "bi", "io", "iq", "gi", " ni", "point", "sim", "ip", "ei", " j", "list", "slice", "iter", "ami", "remote", "iu", "me", "ice", "ic", " ti"], "nb_ops": ["NB_opens", "nb_apps", "nb___ints", "nb___ips", "unique_cats", "NB_OPS", "nbxobs", "NB_ops", "nb_xs", "nb_cats", "nb_ips", "nb___OPS", "NB_apps", "nb_OPS", "NB_ints", "nb2apps", "unique_ops", "nb___xs", "nb_ints", "unique_ips", "nb___tops", "nb_opens", "nb_obs", "nb___cats", "nbxops", "NB_obs", "nbxapps", "NB_xs", "unique_tops", "nb_tops", "nb___ops", "nb2obs", "nb2opens", "nbxopens", "nb2ops"], "op_index": ["opp_iterator", "op_request", "opp_label", "opityconnection", "op_connection", "opityx", "op_offset", "mop_ind", "oplindex", "opLEiterator", "op__index", "opp_level", "opp_index", "opp_Index", " op_ind", "op_iterator", "opp_offset", "mop_info", "opLElevel", "op_Index", "opityindex", "mop_index", "OP_connection", "op_info", "opLEindex", " op_Index", "oplind", "mop_request", "opLEcolumn", "op_x", "OP_x", "op_label", "OP_index", "opp_column", "op__ind", "op_column", "oplconnection", "op_level", "op__request", "op_ind", "opityind", "op__info", "OP_ind", "oplx"], "nb_temps": ["nb_timts", "nb_timples", "nb__temps", "nb_tempo", "nb2tmms", "nb2tmples", "nb_temples", "nb__temms", "nb2temms", "nb_limps", "nb_limts", "nb_typs", "nb_tyms", "nb_temports", "nb_simports", "nb_simples", "nb_threadms", "nb_threadts", "nb__typles", "nb_timms", "nb_threadps", "nb_TemPS", "nb__temPS", "nb_threadpo", "nb_Temms", "nb_tmms", "nb_timps", "nb__temples", "nb_tmts", "nb_Temples", "nb_temms", "nb2temps", "nb_typo", "nb__typs", "nb_tyports", "nb_limms", "nb__tyPS", "nb2temples", "nb_timpo", "nb_simms", "nb_typles", "nb_simPS", "nb_tmports", "nb2tmps", "nb2temts", "nb_temPS", "nb_tmps", "nb_tyPS", "nb_tmples", "nb_simps", "nb_limples", "nb_temts", "nb2tmts", "nb__tyms", "nb_Temps", "nb_tyts"], "nb_globals": ["nb_glimals", "nb_globales", "nb_Globales", "nb_climales", "nb_gllocals", "nb_global", "nb_globally", "nb_glipally", "nb_glonulates", "nb_globulates", "nb_glonALS", "nb_glocols", "nb_clobulates", "nb_glimALS", "nb_glonales", "nb_Globals", "nb_gllocALS", "nb_glocals", "nb_Globally", "nb_globALS", "nb_Glimally", "nb_glimally", "nb_Glimales", "nb_glocales", "nb_gllocales", "nb_clobal", "nb_glipals", "nb_GlobALS", "nb_glipols", "nb_climals", "nb_cllocALS", "nb_glocal", "nb_glimols", "nb_cllocales", "nb_globols", "nb_glonals", "nb_glipALS", "nb_glloculates", "nb_clobALS", "nb_cllocals", "nb_climal", "nb_clloculates", "nb_glimal", "nb_Glimals", "nb_clobals", "nb_clobols", "nb_glimales", "nb_glipal", "nb_climols", "nb_clobales", "nb_glipales", "nb_GlimALS"], "nb_call_args": ["nb_all_frames", "nb_call_arg", "nb_all_flags", "nb_call2flags", "nb_callallargs", "nb_all_arg", "nb_all2frames", "nb_call_flags", "nb_all_args", "nb_call_frames", "nb_all2args", "nb_callallflags", "nb_callallframes", "nb_all2flags", "nb_call2args", "nb_call2arg", "nb_call2frames", "nb_all2arg", "nb_callallarg"], "op": ["oc", "jp", "comp", "opt", "pop", "inc", "k", "app", "ops", " ip", "oe", "alg", "ip", "cmp", " cop", "hop", "top", "cat", "cp", " top", "loc", "p", "operator", "pre", "key", "bo", "omp", "oper", "mp", "oop", "block", "sp", "spec", "ok", "Op", "operation", "it", "cod", "bit", "pat", "OP", "ep", "typ", "t", "arg", " prev", "opp", "expr", "o", "cmd", "pp", "lit", "var", "up", " ops", "co"], "def": ["Def", "dl", "info", "ref", "diff", "d", "kw", "comp", "defined", "dict", "prop", "eval", "req", "dist", "aux", "tx", "off", "col", "conf", "del", "df", "DE", "pro", "desc", "pos", "dev", "block", "decl", "spec", "de", "fun", "dep", "red", "act", "feat", "range", "define", "ex", "ef", "func", "ds", "crit", "lib", "DEF", "cmd", "f", "wd", "form", "definition", "da"], "gen_args": ["eval___Args", "eval___fields", "eval___params", "gen___params", "gen_Args", "eval_args", "genallargs", "genallgs", "gen_fields", "eval_params", "eval_fields", "eval___args", "gen___fields", " gen_Args", "genallArgs", "gen___args", " gen_gs", "gen_params", "eval_Args", "gen___Args", "gen_gs"], "tmp": [" ind", " rep", " prep", " dep", " parent", " input", " term", " match", " cur", "mp", " resp", " dst", "sp", " cached", " ret", " proc", " comp", " ref", " offset", " num", " prev", " expr", " np", " seq", " sp", " err", " pre"], "cond": ["ond", " conditions", "condition", "eff", "rupt", "tx", "Cond", "pos", "code", "ressed", "no", "door", "itionally", " condition", "red", "str", " conditional", " Cond", "resp", "Condition", "obj", "da"], "gen_opc_buf": ["gen_opcs_buf", "gen_opcs_ptr", "gen_opC_buffer", "gen_opC__buf", "gen_opc__buffer", "gen_opc_buff", "gen_opC_buf", "gen_opc__buf", "gen_opc_buffer", "gen_opC_buff", "gen_opC__buff", "gen_opc_ptr", "gen_opcs_buff", "gen_opC_ptr", "gen_opc__ptr", "gen_opc__buff", "gen_opC__buffer", "gen_opC__ptr", "gen_opcs_buffer"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "static void vnc_connect(VncDisplay *vd, int csock,\n\n                        bool skipauth, bool websocket)\n\n{\n\n    VncState *vs = g_malloc0(sizeof(VncState));\n\n    int i;\n\n\n\n    vs->csock = csock;\n\n    vs->vd = vd;\n\n\n\n    if (skipauth) {\n\n\tvs->auth = VNC_AUTH_NONE;\n\n\tvs->subauth = VNC_AUTH_INVALID;\n\n    } else {\n\n        if (websocket) {\n\n            vs->auth = vd->ws_auth;\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        } else {\n\n            vs->auth = vd->auth;\n\n            vs->subauth = vd->subauth;\n\n        }\n\n    }\n\n    VNC_DEBUG(\"Client sock=%d ws=%d auth=%d subauth=%d\\n\",\n\n              csock, websocket, vs->auth, vs->subauth);\n\n\n\n    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));\n\n    }\n\n\n\n    VNC_DEBUG(\"New client on socket %d\\n\", csock);\n\n    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n\n    qemu_set_nonblock(vs->csock);\n\n    if (websocket) {\n\n        vs->websocket = 1;\n\n        if (vd->ws_tls) {\n\n            qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io, NULL, vs);\n\n        } else {\n\n            qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);\n\n        }\n\n    } else\n\n    {\n\n        qemu_set_fd_handler(vs->csock, vnc_client_read, NULL, vs);\n\n    }\n\n\n\n    vnc_client_cache_addr(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);\n\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);\n\n\n\n    if (!vs->websocket) {\n\n        vnc_init_state(vs);\n\n    }\n\n\n\n    if (vd->num_connecting > vd->connections_limit) {\n\n        QTAILQ_FOREACH(vs, &vd->clients, next) {\n\n            if (vs->share_mode == VNC_SHARE_MODE_CONNECTING) {\n\n                vnc_disconnect_start(vs);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 15389, "substitutes": {"vd": ["gd", "dl", "vc", "d", "udi", "hd", "ve", "dm", "idd", "dt", "dri", "nd", "di", "etc", "nv", "sv", "dh", "bd", "uv", "df", "dk", "pb", "vp", "vid", "rd", "md", "pd", "od", "vt", "lv", "xd", "dd", "VD", "sd", "ud", "ved", "dj", "rid", "ds", "vv", "du", "uds", "vr", "vol", "ld", "kb", "v", "wd", "td", "cd", "vm"], "csock": ["cssocked", "lsock", "dsocked", "dsock", "cusocket", "CSock", "insocket", "insick", "csocks", "bsoin", "CSocker", "cusickle", "cslock", "lsocket", "cssocks", " cslock", "csvock", "csoker", "cksoin", "dsick", "csocked", "csvocker", " csocks", "rsocker", "cssock", "rsick", "cusocks", "CSoker", "cksink", "cusocked", "capsock", "bsink", "insock", "dsickle", "cksocker", "csocket", "cssoker", "bsOCK", "csvOCK", "capsocket", "cksong", "dsocker", "acsink", "cusick", "cssong", "rsocks", "insocker", "cusocker", "lsocked", "rsock", "cksock", "acsocker", "csong", "ckslock", "csOCK", "acsocks", "dsocket", "capsocker", "csickle", "csink", "acsickle", "lsOCK", "CSOCK", "csslock", "cusink", "acsock", "capsick", " csong", "csocker", "cssocker", "nsock", "acsocked", " csocker", "cssocket", "csvoker", "rsocket", "cksocket", "cssOCK", "csoin", "bsocked", "bsock", "csick", "nsoin", "nsink", "cusock", "bsick", "bsocker", " csocket", "nsocket", "bsocket", " csink"], "skipauth": ["skipconn", "Skiphack", "withoutauth", "skipAuth", "withouthack", "Skipauth", "Skipconn", " skipconn", "SkipAuth", "skiauth", "Skipauthor", " skipauthor", "skiAuth", " skipAuth", "withoutconn", "skipauthor", "skiauthor", "skiconn", "skiphack", " skiphack"], "websocket": ["hebssocket", "weBSock", "weysockets", "weboxesocket", "wecksource", "kebsocket", "hebsock", "kecksource", "weboxessocket", "weisocket", "ressocket", "keckssocket", "weosocket", "weBSockets", "weversock", "weyssocket", "weblheet", "heBSocket", "kebssocket", "weysock", "seosheet", "weosession", " weresocket", "kebsheet", "weadsource", "weboxesheet", "weposockets", "webswitch", "websource", "webssocket", "sebsocket", "weressocket", "heBSockets", "seosession", "wessocket", "weposheet", "wecksheet", "weposocket", "weadsocket", " weressocket", "wessice", " websheet", " weresheet", "weisockets", "seossocket", "weboxesession", "weckssocket", "weadsheet", "websice", "weresocket", "heBSsocket", "weosheet", "wereswitch", "seosocket", "weverssocket", "weblwitch", "weosource", "sebsession", "weadssocket", "kebsource", "weversheet", " webssocket", "rebsockets", "weversocket", "weysocket", "kecksocket", "rebsocket", "ressockets", "sebsheet", "weisheet", "ressice", "weresheet", "weblocket", "weisice", "weBSsocket", "sebssocket", "weBSocket", "heBSock", "wessockets", "weossocket", "weblsocket", "rebsheet", "websock", " webswitch", "weposice", "weversession", "hebsocket", "hebsockets", "rebsice", "websession", "wecksocket", "ressheet", "weversockets", " wereswitch", "websheet", "websockets", "kecksheet", "wessheet"], "vs": ["bs", "fs", "flags", "ves", "px", "views", "ps", "args", "irms", "ms", "ports", "js", "names", "VS", "blogs", "pps", "vi", "services", "Vs", "vals", "caps", "gets", "vers", "inv", "plays", "ins", "vm", "posts", "lists", "vc", "changes", "ops", "terms", "sv", "atts", "vp", "vt", "res", "vr", "is", "lines", "ns", "rs", "ks", "ads", "ies", "eps", " ss", "uv", "ls", "hs", "its", "lv", "ims", "ues", "values", " sv", "ts", "ows", "wcs", "var", "qs", "sts", "ss", "pages", "ver", "otes", "links", "s", "es", "xs", "gs", "nets", "ys", "ds", "vv", " cs", "uds", "cs", "v", "stats", "docs", "obj", "obs"], "i": ["qi", "ind", "ai", "ii", "n", "gi", "z", "di", "x", "sim", "cli", "ip", "c", "ti", "li", "I", "p", " j", " I", "ei", "si", "batch", "m", "oi", "key", "us", "ri", "port", "in", "multi", "ami", "index", "inner", " ii", "it", "j", "me", "ci", "xi", "ic", "t", "phi", "zi", "span", "ix", "mi", "is", "pi", "v", "y", "bi", "ini", "ui", "f", " ti"]}}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_current_dir(FTPContext *s)\n\n{\n\n    char *res = NULL, *start = NULL, *end = NULL;\n\n    int i;\n\n    const char *command = \"PWD\\r\\n\";\n\n    const int pwd_codes[] = {257, 0};\n\n\n\n    if (!ftp_send_command(s, command, pwd_codes, &res))\n\n        goto fail;\n\n\n\n    for (i = 0; res[i]; ++i) {\n\n        if (res[i] == '\"') {\n\n            if (!start) {\n\n                start = res + i + 1;\n\n                continue;\n\n            }\n\n            end = res + i;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (!end)\n\n        goto fail;\n\n\n\n    if (end > res && end[-1] == '/') {\n\n        end[-1] = '\\0';\n\n    } else\n\n        *end = '\\0';\n\n    av_strlcpy(s->path, start, sizeof(s->path));\n\n\n\n    av_free(res);\n\n    return 0;\n\n\n\n  fail:\n\n    av_free(res);\n\n    return AVERROR(EIO);\n\n}\n", "idx": 15401, "substitutes": {"s": ["bs", "h", "fs", "d", "rs", "n", "sb", "ses", "S", "c", "sv", "ps", "conf", "eps", "p", "an", "r", "sys", "m", "ls", "erences", "aws", "hs", "gs", "b", "ats", "its", "js", "ctx", "sts", "g", "sq", "less", "ex", "t", "ds", "cs", "ts", "o", "a", "v", "f", "qs", "obj", "w", "scl", "ns", "ss"], "res": ["ch", "status", "re", "addr", "resource", "ps", "r", "ms", "pos", "mem", "js", "ret", "vals", "expr", "base", "ins", "rem", "details", "con", "serv", "results", "os", "full", "init", "next", "def", "ri", "rc", "ro", "resh", "conn", "pres", "net", "ix", "resp", "cmd", "rel", "resolution", "rs", "prefix", "req", "resy", "ress", "q", "sys", "arr", "err", "min", "nt", "response", "windows", "rez", "red", "range", "max", "rt", "bits", "Res", "val", "tx", "out", "reg", "result", "upper", "rx", "raw", "rev", "chain", "RES", "fresh", "str", "uds", "gr", "cs", "rest", "ris", "obj", "reset"], "start": ["wind", "before", "kind", "ST", "req", "stop", "starting", "art", "time", "style", "trans", "started", "group", "next", "need", "init", "space", " Start", "top", "addr", "begin", "st", "p", "set", "r", "from", "store", "key", "name", "ish", "pos", "iter", "sp", "path", "id", "size", "it", "str", "range", "offset", "step", "try", "Start", "t", "part", "rest", "base", "first", "length", "reset", "shift"], "end": ["wind", "ment", "send", "then", "dest", "add", "nil", "ish", "close", "it", "use", "ENDED", "offset", "ending", "se", "End", "all", "last", "nd", "next", "except", "append", "set", "rend", "final", "hend", "to", "size", "line", "after", "en", "fail", "END", "east", "length", "edge", "tail", "off", "ist", "begin", "st", "ort", "ext", "ent", "range", "max", "gate", "ender", "be", "can", "est", "ff", "stop", "endif", "point", "until", "out", "bound", "e", "chain", "window", "len", "path", "id", "str", "ended", "fin", "rest", "pend", "reset"], "i": ["qi", "ind", "info", "ai", "ii", "ji", "n", "gi", "k", "di", "json", "ski", "x", "sim", "cli", "ij", "ip", "u", "ti", "li", "hi", "\u0438", "I", "p", " j", "ei", "si", "m", "ori", "ri", "oi", "asi", "ia", "im", "multi", "iter", "slice", "ims", "fi", "index", "iu", "id", "imm", " ii", "it", "j", "me", "ci", "xi", "ie", "ic", "t", "mini", "phi", "zi", "ix", "mi", "is", "iri", "pi", "v", "y", "bi", "ini", "ui", "uri"], "command": ["prefix", "power", "address", "direction", "directory", "type", "menu", "three", "sword", "history", "word", "sequence", "password", "service", "message", "Command", "action", "controller", "code", "method", "pattern", "buffer", "reason", "attribute", "request", "rule", "mode", "operation", "transform", "description", "minute", "comment", "template", "which", " Command", "cmd", "function", "process", "query", "call", "execute"], "pwd_codes": ["pwd2odes", "pWD_codes", "pwd2code", "pw_lines", "pwd_lines", "pWD_code", "pwd2lines", "pw_code", "pwd_odes", "pwd_code", "pwd2codes", "pw_codes", "pWD_odes"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opts_print(QemuOpts *opts, void *dummy)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    fprintf(stderr, \"%s: %s:\", opts->list->name,\n\n            opts->id ? opts->id : \"<noid>\");\n\n    TAILQ_FOREACH(opt, &opts->head, next) {\n\n        fprintf(stderr, \" %s=\\\"%s\\\"\", opt->name, opt->str);\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n    return 0;\n\n}\n", "idx": 15411, "substitutes": {"opts": ["OPs", "opns", "opars", "opcs", "iopts", "OPts", "ops", "optuts", "opTS", "OPTS", " opars", " opTS", "optds", " optars", " opns", " opcs", "opgs", "Oprs", " optents", " oputs", "opds", "OPds", "optcs", "Opgs", "Opts", " opgs", "optgs", "optts", "Opcs", "opents", "optns", "iopTS", " optls", " oprs", "OPuts", "iops", "oprs", "iopps", " optts", "opps", "optTS", "Opls", " opps", " opents", "OPns", "oputs", " opls", "optrs", "OPps", " opds", "Opents", "Opars", "opls", " ops"], "dummy": ["sdatum", "Datum", " datum", "Dummy", "sdummies", "datum", " dummies", "Dummies", "sdummy", "dummies"], "opt": ["pkg", "let", "tv", "prop", "req", "select", "lt", "tmp", "eff", "aux", "txt", "out", "slot", "buf", "tab", "cat", "init", "col", "ext", "anon", "xml", "def", "ver", "tag", "list", "Opt", "timeout", "name", "mem", "alt", "nt", "trial", "iter", "block", "ret", "sp", "op", "kt", "j", "cho", "num", "max", "proc", "gt", "t", "arg", "prev", "optim", "gr", "pt", "cmd", "plot", "val", "option", "var", "obj", "term"]}}
{"project": "FFmpeg", "commit_id": "fe448cd28d674c3eff3072552eae366d0b659ce9", "target": 0, "func": "static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,\n\n                                AVFrame *picture)\n\n{\n\n    int compno, reslevelno, bandno;\n\n    int x, y;\n\n\n\n    uint8_t *line;\n\n    Jpeg2000T1Context t1;\n\n\n\n    /* Loop on tile components */\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n\n        Jpeg2000Component *comp     = tile->comp + compno;\n\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n\n\n        /* Loop on resolution levels */\n\n        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\n\n            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n\n            /* Loop on bands */\n\n            for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n                int nb_precincts, precno;\n\n                Jpeg2000Band *band = rlevel->band + bandno;\n\n                int cblkno = 0, bandpos;\n\n\n\n                bandpos = bandno + (reslevelno > 0);\n\n\n\n                if (band->coord[0][0] == band->coord[0][1] ||\n\n                    band->coord[1][0] == band->coord[1][1])\n\n                    continue;\n\n\n\n                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n\n                /* Loop on precincts */\n\n                for (precno = 0; precno < nb_precincts; precno++) {\n\n                    Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n                    /* Loop on codeblocks */\n\n                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n\n                        int x, y;\n\n                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n                        decode_cblk(s, codsty, &t1, cblk,\n\n                                    cblk->coord[0][1] - cblk->coord[0][0],\n\n                                    cblk->coord[1][1] - cblk->coord[1][0],\n\n                                    bandpos);\n\n\n\n                        x = cblk->coord[0][0];\n\n                        y = cblk->coord[1][0];\n\n\n\n                        if (codsty->transform == FF_DWT97)\n\n                            dequantization_float(x, y, cblk, comp, &t1, band);\n\n                        else\n\n                            dequantization_int(x, y, cblk, comp, &t1, band);\n\n                   } /* end cblk */\n\n                } /*end prec */\n\n            } /* end band */\n\n        } /* end reslevel */\n\n\n\n        /* inverse DWT */\n\n        ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);\n\n    } /*end comp */\n\n\n\n    /* inverse MCT transformation */\n\n    if (tile->codsty[0].mct)\n\n        mct_decode(s, tile);\n\n\n\n    if (s->cdef[0] < 0) {\n\n        for (x = 0; x < s->ncomponents; x++)\n\n            s->cdef[x] = x + 1;\n\n        if ((s->ncomponents & 1) == 0)\n\n            s->cdef[s->ncomponents-1] = 0;\n\n    }\n\n\n\n    if (s->precision <= 8) {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            Jpeg2000Component *comp = tile->comp + compno;\n\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n            float *datap = comp->f_data;\n\n            int32_t *i_datap = comp->i_data;\n\n            int cbps = s->cbps[compno];\n\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n\n            int planar = !!picture->data[2];\n\n            int pixelsize = planar ? 1 : s->ncomponents;\n\n            int plane = 0;\n\n\n\n            if (planar)\n\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n\n\n\n\n            y    = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            line = picture->data[plane] + y * picture->linesize[plane];\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint8_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = line + x * pixelsize + compno*!planar;\n\n\n\n                if (codsty->transform == FF_DWT97) {\n\n                    for (; x < w; x += s->cdx[compno]) {\n\n                        int val = lrintf(*datap) + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        *dst = val << (8 - cbps);\n\n                        datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                } else {\n\n                    for (; x < w; x += s->cdx[compno]) {\n\n                        int val = *i_datap + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        *dst = val << (8 - cbps);\n\n                        i_datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                }\n\n                line += picture->linesize[plane];\n\n            }\n\n        }\n\n    } else {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            Jpeg2000Component *comp = tile->comp + compno;\n\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n            float *datap = comp->f_data;\n\n            int32_t *i_datap = comp->i_data;\n\n            uint16_t *linel;\n\n            int cbps = s->cbps[compno];\n\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n\n            int planar = !!picture->data[2];\n\n            int pixelsize = planar ? 1 : s->ncomponents;\n\n            int plane = 0;\n\n\n\n            if (planar)\n\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n\n\n            y     = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint16_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = linel + (x * pixelsize + compno*!planar);\n\n                if (codsty->transform == FF_DWT97) {\n\n                    for (; x < w; x += s-> cdx[compno]) {\n\n                        int  val = lrintf(*datap) + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        /* align 12 bit values in little-endian mode */\n\n                        *dst = val << (16 - cbps);\n\n                        datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                } else {\n\n                    for (; x < w; x += s-> cdx[compno]) {\n\n                        int val = *i_datap + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        /* align 12 bit values in little-endian mode */\n\n                        *dst = val << (16 - cbps);\n\n                        i_datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                }\n\n                linel += picture->linesize[plane] >> 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 15420, "substitutes": {"s": ["i", "h", "d", "fs", "l", "rs", "sg", "n", "sb", "ses", "os", "S", "space", "src", "c", "sv", "comm", "ps", "p", "sys", "es", "m", "ls", "gs", "b", "e", "js", "ims", "sts", "spec", "g", "sq", "cpp", "sf", "css", "t", "ds", "self", "se", "cs", "ts", "sc", "v", "stats", "ns", "ss"], "tile": ["gem", "skill", "cache", "ile", "ve", "map", "component", "image", "ty", "style", "util", "tab", "frame", "tle", "Tile", "ti", "sel", "tif", "tag", "tf", "cell", "te", "target", "profile", "league", "buffer", "ele", "slice", "unit", "shot", "bit", "mt", "try", "coord", "layer", "t", "template", "test", "pixel", "file", "phy", "metadata", "peg", "table", "term", "grid", "query", "texture", "chip"], "picture": ["fps", "fx", "ff", "fp", "fm", "image", " fps", " frames", "fac", "face", "frame", "video", "media", "img", "pic", "movie", "rame", "fb", "Picture", " framing", " f", "record", "iframe", "original", " Frame", " framed", " fram", "profile"], "compno": ["compdo", "compname", "compeno", "parno", "cmpeno", " compNO", "compnos", "parnr", " compname", "compko", " compyes", "condeno", "cmdmo", "cpno", "cmpno", "parmo", "ompnos", "conddo", "commnos", "commpo", "comeno", "cmpyes", "cmpNO", "cmpname", "comppo", "compnr", "expko", "expeno", "ompno", "componentko", " compeno", "comname", "commnone", "cmpko", "cpyes", "componentno", "cmpnr", "componenteno", "ompnone", "cmpnos", "compNO", "expno", "comno", "commno", "condno", "cmdno", "comdo", "cmdyes", "omppo", "compmo", "componentyes", "comyes", "compyes", "cmdnr", "cmpmo", "cmppo", "condyes", "cpdo", "cpeno", "componentNO", "paryes", "comNO", "compnone", "cmpnone", "expyes"], "reslevelno": ["resolutionlvleno", "resslevelco", "rescompno", "resslayerno", " reslevelyes", "resvelyes", " reslayertoo", "reslevelzero", "reslevelyes", "reslayerco", "resLevelmo", "resscopenumber", "resolutionlevelno", "preslvlno", "reslayeryes", "reslevelna", "conslevelano", "restiertoo", "reslvlNO", "rescompna", "reslayerNO", "resslayerco", " reslayernos", "resscopeno", "resLevelno", "reslvlco", " reslayerno", " reslevelne", "reslevelnos", "preslvllo", "resgroupzero", "resgroupnumber", "reslvlnos", "reslevelmo", "reslevelnumber", "resveltoo", "reslevelne", "reslvlnumber", "resleveltoo", "resLevelNO", "reslocklo", "conslevelNO", "reslvleno", "preslevelno", "reslvlyes", "reslvlne", "preslevello", "restieryes", "reslvlna", "reslayermo", "reslocknos", "resolutionlevelnumber", "reslevello", "resolutionlvlnumber", " reslayeryes", "reslvllo", "resvelnos", "resscopezero", "resLevelco", "reslockne", "rescompano", "reslvlmo", "reslayerne", "resslevelNO", "resslayerNO", "reslvlano", " reslevelnos", "preslevelyes", "resslayermo", " resleveltoo", " reslayerNO", "conslevelno", "resslevelmo", "resolutionlevelzero", "resleveleno", "conscompna", "rescompNO", "reslevelco", "resgroupeno", " reslayerne", "reslayerno", "resolutionlvlno", "resolutionlvlzero", "reslockno", "reslayerlo", "resolutionleveleno", "restierno", "conslevelna", "reslevelano", "conscompNO", "reslevelNO", "resvelno", "resscopeeno", " reslevelNO", "reslvlzero", "reslockyes", "conscompno", "reslayernos", "reslayertoo", "restiernos", "conscompano", "resgroupno", "preslvlyes", "resslevelno", "reslockNO", "reslvlno"], "bandno": ["roadNO", "brandgo", "brandty", "roadno", "wordmo", "brandyes", "batchmo", "brandid", "brandno", "roadna", " bandyes", "brandna", "batchyes", "bitno", "bandio", "bandmo", "brandpo", "levelno", " bandid", "batchno", " bandio", "bandyes", "batchNo", "rankNo", "levelty", " bandna", " bandNO", "brandne", "bandna", "bitna", "brandNo", "batchnos", " bandne", "rankne", "bandNo", "batchio", "bandpo", " bandty", "bitNo", "broadio", "brandnos", "bandty", "broadyes", "batchgo", "bandgo", "batchpo", "bandnos", "bitNO", "bandNO", "bindnos", "bindpo", "broadno", "brandmo", "rankno", "wordgo", "bindno", "bandne", "wordpo", "levelna", "bandid", "wordno", " bandNo", "broadNo", "rankid", "bindyes", "roadNo"], "x": ["fx", "i", "xp", "l", "n", "dx", "z", "tx", "lat", "px", "top", "xc", " tx", "p", "xt", " w", " dx", "m", "xa", "rx", "xs", "xy", " ax", "lon", "my", "at", "xi", "ex", "ox", "coord", "t", "X", "ix", " xx", "o", "f", "v", " i", "yx", "w", "xx", "on"], "y": ["i", "ey", "ch", "py", "ye", "jpg", "ly", "n", "vy", "ty", "fy", "conv", "ies", "cy", "iy", "dy", "yo", "c", "new", "p", "def", "sy", "m", "ym", "img", "ry", "b", "im", "com", "xy", "ay", "cont", "j", "record", "yt", "ya", "ys", "gy", "func", "t", "yy", "o", "Y", "sky", "v", "_", "obj", "ny"], "line": ["l", "LINE", "image", "level", "style", "lc", "byte", "frame", "lin", "scale", "cell", " lines", "code", "entry", "ine", "rule", "block", "buffer", "len", "record", "row", "file", "Line", "link", "text", "base", "lines"], "t1": ["t2", "T4", "T2", " tOne", "cOne", "pOne", "T3", "m2", "t3", "c2", "p3", "m4", "c1", "p4", "c3", "T1", "t4", "m3", "p1", "tOne", " t2", " t3", "m1", "p2"], "comp": ["ch", "rep", "prop", "con", "om", "component", "app", "conv", "compl", "cmp", "col", "tab", "Comp", "reg", "c", "cp", "comm", "conf", "def", "rend", "cell", "pro", "buff", "pos", "omp", "cc", "mp", "com", "sec", "ctx", "agg", "op", "cod", "bit", "coll", "prep", "comb", "proc", "Component", "mod", "prof", "crit", "fc", "lib", "cond", "resp", "cmd", "par", "co"], "codsty": ["cdsty", "ccstyle", "cellsys", "codsys", "codestyle", "codedstro", "condstyles", "condstyle", "codstyles", "codety", "cdsys", "codesy", "Codstyles", "cdzz", " codless", "condety", " codst", "cdst", " codzz", " codstyle", "codesty", "codstro", "cellst", "codedsy", "ccsy", "Codstyle", "codedstyle", "cellzz", "cledty", "codstyle", "codty", "codestro", "cledsty", " codety", "cellsty", "codless", "codedsty", " codsys", "codsy", "ccstro", " codty", "cledstyle", "Codsty", "Codty", "cledless", "condsty", "Codety", "Codless", "codst", " codstyles", "ccsty", "codzz"], "rlevel": ["reline", "rlayer", "rrrole", "rlevels", "srlayer", "hday", "rtlevel", " rgroup", "resday", "vrrole", "rrpass", "rstage", "rline", "rclevel", "hlvl", "rrlevel", "rrday", " rday", "rmode", "srlevel", "hvel", "rtlayer", "rcstage", "rarwall", "rrole", "rtstage", "rewall", " rpass", "relevel", "srpass", "rrlvl", "rrgroup", "rrmode", "srvel", "rvel", "rtvel", "reslevel", "srstage", "rlvl", "srmode", "vrvel", " rmode", "rarlevel", "rarlevels", "rday", "hlevel", "rclayer", "vrlevel", "rpass", " rvel", " rlevels", "resvel", " rrole", "rwall", "rarline", " rwall", "relevels", "vrgroup", "rrvel", "reslvl", "srday", "rcvel", "rgroup", " rline"], "nb_precincts": ["nb_prefunctes", "nb_prefincted", "nb_precributers", "nb_precuixtxs", "nb_precsixts", "nb_precointxs", "nb_precuncters", "nb_precinctS", "nb_precinctes", "nb_precuinctxs", "nb_precixtls", "nb_prefincts", "nb_precointeds", "nb_precsinctls", "nb_precixtS", "nb_precuixts", "nb_precributls", "nb_precsincteds", "nb_precuncted", "nb_precunctls", "nb_prefinctes", "nb_precinctings", "nb_precuincteds", "nb_precuincts", "nb_precuixtS", "nb_precixts", "nb_precincters", "nb_prefuncters", "nb_precixtxs", "nb_precointS", "nb_precinctls", "nb_precributxs", "nb_prefuncted", "nb_precsixtings", "nb_precributs", "nb_precixtings", "nb_precincteds", "nb_precributings", "nb_precuinctS", "nb_precsixtls", "nb_precributes", "nb_precuncteds", "nb_precributeds", "nb_precunctings", "nb_precinctxs", "nb_precoints", "nb_precributS", "nb_prefuncts", "nb_precsincts", "nb_precsixteds", "nb_precributed", "nb_precsinctings", "nb_precixteds", "nb_prefincters", "nb_precunctes", "nb_precuncts", "nb_precincted", "nb_precuixteds"], "precno": ["prekNo", "PrecNO", "preblen", "recNO", "prekdo", "precorno", "prefnum", "Preknum", "prefeno", "receno", "prerlen", "Precno", " precorno", "prefno", "prerno", "Precnum", "pricdo", "precnumber", "precdo", "prebNo", "prefcNO", " preborno", "pricko", "PrekNo", "prepceno", "preceno", "Prekno", "preccno", "precnum", "prepcno", "pricNo", "prifeno", "prebno", "prefdo", "pricNO", "prifko", "repcno", "recyes", "prefyes", " preclen", "prerorno", "prefcNo", "prikdo", " prebnumber", "preclen", "prikNo", "prepcyes", "prevNO", "prebnumber", "prefko", "precko", "prevno", "precNo", "prevyes", " preblen", "prefcdo", "pricno", "PrecNo", "precNO", "repcNO", " prebno", "prepcNO", "prikNO", "prefcno", "prebnum", "prefNO", "recno", "prifNo", "preborno", "prekno", "prernumber", "prebNO", "prebko", "precyes", "preccnumber", "prifno", "repcyes", "prebeno", "prekko", "prefNo", "prekNO", "preveno", "prikno", "precclen", "preknum", "preccorno", "priceno", "repceno", "prekeno", " precnumber", "PrekNO"], "band": ["low", "bind", "sound", "bd", "display", "prep", "bor", "chrom", "pair", "power", "bar", "component", "dom", "br", "word", "group", "boot", "bridge", "filter", "tag", "bright", "beam", "flag", "bb", "bands", "broad", "comb", " Band", "cmd", "library", "lag", "channel", "ble", "day", "ber", "node", "byte", "tab", "Band", "batch", "disc", "cell", "light", "cand", "block", "road", "bit", "amp", "binary", "bed", "work", "pixel", "rom", "pp", "val", "be", "high", "plane", "co", "ond", "flash", "way", "reg", "raid", "mon", "bo", "buff", "b", "ang", "window", "db", "gain", "rad", "bin", "bart", "allowed", "brand"], "bandpos": ["domPos", "bandloc", "broadpos", "Bandloc", "barinfo", " bandoffset", "bandPos", " bandPos", "Bandpos", "bandoffset", "domloc", "bindpos", "barno", "bindoffset", "grouploc", " bandinfo", "barpos", "broadno", "bandinfo", "BandPos", "groupoffset", "grouppos", "dompos", "bindPos", "broadinfo", " bandloc", "groupPos", "bindloc"], "prec": [" preco", "prov", "recam", "gek", "sep", "pric", "rep", "notecc", " precam", "priv", "prik", " prep", "notec", "Pref", "Preco", "reco", " prech", "seco", "preb", "Preb", " pref", " preb", "preco", "sec", "prif", "notef", " precc", " prek", "prep", "prib", "pref", "secam", "noteco", "prico", "precc", "proc", "pricc", "Prev", "prev", "prof", "gef", "brek", "brec", "proco", " prev", "prek", "precam", "Prec", "Prek", "gec", "rec", "prech", "brech", "bref", "gech"], "cblkno": ["cblogkpos", "cblogkyno", "cblkidcro", "cblekno", "cbrarkna", "cbrknone", "cbltkno", "cBLckNo", "cbrarkorno", "cblkyno", "cblkNo", "cblekidlo", "cBLckmo", "cblckNo", "cblaksha", "clabelkmo", "clabelukmo", "cblukne", "cblckpos", "clabelkne", "cblkne", "cblukNo", "cblukmo", "cBLknos", "cbrkno", "cblkidno", "cbldknone", "cblarkNo", "clabelkNo", "cBLcknos", "cblckne", "clabelukne", "cblekidna", "cblcksha", "cblknone", "cblekidcro", "cblunkno", "cbltkna", "cblckmo", "cblkypos", "cblakpos", "cbltklo", "cblkkno", "cblkidlo", "cblkkmo", "cblakmo", "cbrkna", "cblkecro", "cblakNo", "cblknos", "cBLkno", "cblogkysha", "cblekcro", "cblkna", "cbldkorno", "cblukno", "cblarkno", "cblogkno", "cblksha", "clabelukNo", "cblekna", "cbldkna", "cblunkorno", "cblklo", "cbltkcro", "cblkelo", "cblarkna", "cblarkmo", "cblunkna", "cblkpos", "cbrkorno", "cblkcro", "cblakno", "cblekidno", "cbldkno", "cblkorno", "cblunknone", "clabelkno", "cblarknone", "cblarkorno", "cblogkyNo", "cblogksha", "cblckno", "cblkysha", "cblkkNo", "clabelukno", "cBLckno", "cblkmo", "cBLkNo", "cbleklo", "cblkeno", "cblarknos", "cblogkNo", "cBLkmo", "cblcknos", "cblkknos", "cblkidna", "cblkena", "cbrarkno", "cblogkypos", "cblkyNo", "cblakne", "cbrarknone"], "cblk": ["dcblk", " cBLck", "cbrunk", " cblks", "cBLak", "dcblq", "cbrak", "cplkt", "canblk", "cblkk", "cplks", "cluks", " cplak", " cBLkin", "cluak", " cBLks", "crelkar", "crelck", "canblke", "lcblk", " cblck", "crelk", "dcbrak", " cBLak", "cllk", "cBlak", "cplkid", "rblks", "cplck", "cbrkk", "cuchck", "cbrks", "cbleck", "cblekid", "cBLks", "cplj", "rblek", "cuchk", "cblke", "cBlks", "cblekt", "cblc", "cblck", "cplak", " cBLc", "cBLkk", "cblks", "cblkar", "canuchke", "lcbrak", "cuchke", " cplj", "cBLkin", "cblec", "crelke", "cBlck", "cBlunk", "cbrk", "dcblkk", "lcblks", "cbrq", "cblj", "cblunk", "cBLc", "dcbrkk", "cuchkar", "dcbrq", "cllq", "cllkk", "rblkt", "cBlj", "dcblak", "cblej", "rblk", "rbleks", "cBLq", "cBlk", " cBLk", "cblak", "cbrkt", " cplk", "lcbrk", "cblek", "lcblunk", "canblck", "cblkid", "cluk", "cllak", "crelak", "cplk", "rblekt", "cluc", "cBLk", " cplck", "canuchck", "cuchkin", "cbleks", " cblc", "canuchk", "crelunk", "cblkin", "cblkt", "lcblak", "lcbrunk", "canblkar", " cblkin", "canuchkar", "cBLck", "crelks", "dcbrk", "cblq", "rblkid", "cbrkid", "cbleak", " cblj", "rblekid", " cblak", "lcbrks"]}}
{"project": "qemu", "commit_id": "158fd3ce98afd21f2e2639600f6414ea703a9121", "target": 0, "func": "void qemu_run_all_timers(void)\n\n{\n\n    alarm_timer->pending = 0;\n\n\n\n    /* rearm timer, if not periodic */\n\n    if (alarm_timer->expired) {\n\n        alarm_timer->expired = 0;\n\n        qemu_rearm_alarm_timer(alarm_timer);\n\n    }\n\n\n\n    /* vm time timers */\n\n    qemu_run_timers(vm_clock);\n\n    qemu_run_timers(rt_clock);\n\n    qemu_run_timers(host_clock);\n\n}\n", "idx": 15434, "substitutes": {}}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "static struct XenDevice *xen_be_get_xendev(const char *type, int dom, int dev,\n\n                                           struct XenDevOps *ops)\n\n{\n\n    struct XenDevice *xendev;\n\n\n\n    xendev = xen_be_find_xendev(type, dom, dev);\n\n    if (xendev) {\n\n        return xendev;\n\n    }\n\n\n\n    /* init new xendev */\n\n    xendev = g_malloc0(ops->size);\n\n    xendev->type  = type;\n\n    xendev->dom   = dom;\n\n    xendev->dev   = dev;\n\n    xendev->ops   = ops;\n\n\n\n    snprintf(xendev->be, sizeof(xendev->be), \"backend/%s/%d/%d\",\n\n             xendev->type, xendev->dom, xendev->dev);\n\n    snprintf(xendev->name, sizeof(xendev->name), \"%s-%d\",\n\n             xendev->type, xendev->dev);\n\n\n\n    xendev->debug      = debug;\n\n    xendev->local_port = -1;\n\n\n\n    xendev->evtchndev = xen_xc_evtchn_open(NULL, 0);\n\n    if (xendev->evtchndev == XC_HANDLER_INITIAL_VALUE) {\n\n        xen_be_printf(NULL, 0, \"can't open evtchn device\\n\");\n\n        g_free(xendev);\n\n        return NULL;\n\n    }\n\n    fcntl(xc_evtchn_fd(xendev->evtchndev), F_SETFD, FD_CLOEXEC);\n\n\n\n    if (ops->flags & DEVOPS_FLAG_NEED_GNTDEV) {\n\n        xendev->gnttabdev = xen_xc_gnttab_open(NULL, 0);\n\n        if (xendev->gnttabdev == XC_HANDLER_INITIAL_VALUE) {\n\n            xen_be_printf(NULL, 0, \"can't open gnttab device\\n\");\n\n            xc_evtchn_close(xendev->evtchndev);\n\n            g_free(xendev);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        xendev->gnttabdev = XC_HANDLER_INITIAL_VALUE;\n\n    }\n\n\n\n    QTAILQ_INSERT_TAIL(&xendevs, xendev, next);\n\n\n\n    if (xendev->ops->alloc) {\n\n        xendev->ops->alloc(xendev);\n\n    }\n\n\n\n    return xendev;\n\n}\n", "idx": 15449, "substitutes": {"type": ["rel", "kind", "role", "info", "ref", "version", "color", "pe", "ty", "time", "pc", "style", "x", "error", "value", "title", "ime", "core", "ver", "pl", "Type", "sys", "tag", "family", "p", "def", "key", "name", "port", "controller", "tp", "Ty", "domain", "index", "ype", "id", "op", "size", "data", "ico", "class", "t", "typ", "test", "debug", "file", "phy", "rt", "cmd", "stat", "types", "y", "var", "by", "ping", "TYPE"], "dom": ["dist", "rank", "d", "iam", "DOM", "dem", "dm", "doms", "om", "ty", "virt", "node", "util", "session", "depth", "orm", "prom", "ver", "admin", "loc", "def", "root", "img", "host", "tech", "pro", "dr", "mon", "mn", "valid", "height", "dim", "im", "db", "domain", "window", "deep", "len", "des", "mode", "id", "dir", "Dom", "num", "driver", "coord", "debug", "du", "rom", "deg", "cmd", "lang", "cd", "form"], "dev": ["device", "dist", "d", "ch", "info", "prop", "dem", "ve", "end", "av", "DEV", "priv", "app", "alloc", "off", "serial", "util", "buf", "depth", "eng", "conf", "ver", "develop", "loc", "def", "ach", "tech", "pro", "desc", "raw", "name", "mem", "db", " Dev", "nt", "des", "Dev", "od", "stable", "mode", "id", "len", "size", "ev", "cho", "iv", "data", "normal", "conn", "den", "oy", "attr", "debug", "lib", "pad", "cmd", "val", "v", "var", "wd", "adv", "w"], "ops": ["bs", "abilities", "rs", "changes", "opt", "orts", "settings", "keys", "flags", "checks", "OPS", "os", "ips", "ands", "als", "ps", "eps", "fields", "arts", "ups", "args", "outs", "vs", "tools", "options", "opens", "xs", "rots", "oper", "its", "Ops", "tags", "op", "services", "caps", "vals", "values", "aps", "asts", "sets", "hops", "orders", "opers", "oops", "utils", "apps", "ds", "actions", "cs", "ts", "items", "bits", "wcs", "types", "tops", "stats", "obs", "ns", "params"], "xendev": ["rxendedserv", "wxendeddev", "lexenddev", "xfenderiver", "wxentev", "wxendsserv", "wxendseg", " xenddev", " xbeginech", "xendef", "xendiv", "xsendev", "eyenderer", "xandell", "xbeginever", "xENDev", "oxendec", "expendep", "xenerv", "xendsserv", "xentserv", "xENDell", "xenderel", " xentev", "xentdev", "xendedee", "xentog", "oxendedec", "Xendederv", "xidev", "eyendiver", "xndeg", "xentever", "xenderserv", "wendev", "xengav", "exendek", "xtendev", "oxendev", "xbeginell", "xendval", "rxenditem", "xentev", "txendedov", "xidek", "xendedval", "yendev", "Xenderv", "rxendedov", "txendedev", "lexendedek", "zendedev", "wxendsv", "xaddoc", "Xendek", "xendsiver", "oxendew", "xentep", "xentrec", "wenddev", "xider", " xendel", "exaddev", "lexendedev", "rxendev", "nexendiver", "wxenderv", "wxendever", "xexceptiver", "wbeginiv", "xandel", "xenterev", "exendov", "xendell", "zendiv", "rxenderev", "xendav", "eyentererer", " xaddev", "wbeginev", "exendserv", "xsendeg", "xexceptef", "xenderech", "xbeginoc", " xadddev", "rxendeddev", "yendserv", "xsendec", "rxendoc", "xaddem", "exendev", " xendserv", "wxendew", "xenderapter", "xendeserv", "expendever", "wxentapter", "xentek", "xaddel", "rxendediver", "xaddov", "xendec", "xndek", "xendederv", "Xendedev", "nexenderer", "oxenterv", "xideever", "xtenderv", "eyenterev", "oxexceptever", "xender", "xtendoc", "xendex", "xendediver", "xtender", "expendev", "xentell", "xendeg", "xentapter", "yentserv", " xenterv", "exendever", "exentev", "xengval", "exentec", "exenderv", "xentel", "xenterever", "xentiv", "yentev", "xenderev", "xandev", "xiddev", "xexceptov", " xaddem", "xenderval", "exadddev", " xbeginel", "yenderv", "rxendiver", "rxendserv", "nexendereg", "xENDerv", "xendiver", "yentdev", "xidedev", "xendoc", "xenderdev", "exentserv", "xendedev", "xenderiv", " xadderv", "rxenderech", "wxendv", "xengec", "oxexceptev", "wbeginerv", "xsenddev", "xideev", "xendeoc", "xadditem", " xendem", "wendedev", "xideeg", "exaddel", "xbeginech", "zendell", "xandov", " xentdev", "xendedov", "eyendever", "xENDex", "xenderog", "exenterv", "xENDov", "zendee", "xengem", "xndem", "xstopdev", "xendsv", "xendedapter", "xndev", "xendedserv", "xENDel", "wendog", "wendov", "xendek", "xaddev", "xfenderev", " xenderv", "wendect", "xndever", "exaddov", "xtbeginev", "txendedell", "xendedek", "xendserv", " xender", "xanderv", "wxendev", "lexendeddev", "xenderex", "expenderever", "xengew", "xaddever", "xendeder", "xstopem", "xendeitem", "xengep", "eyendev", " xaddel", "xadderv", "xbeginel", "xbeginef", "xenditem", "xandek", "wenderv", "xendever", "zendep", "oxentev", "xenek", "xenderiver", " xaddrec", "Xendedek", "zendev", "xtbeginoc", "xsendew", "xendeditem", "oxendav", "xeastiver", "zenderee", "xexcepterv", "oxendedew", "xaddserv", "xendsev", "xendedex", "wendiv", "xendech", "rxenderserv", "xeastev", "xentew", "xexceptev", "zendedval", "xendedell", "xbeginog", "xendererer", "xendel", "xnddev", "wendedov", "xendeev", "xenterav", "wxendsev", "xenderer", "xeastov", "xanddev", "exendec", "xendem", "exenddev", "xenterec", "nexendev", "xexceptever", "xfendev", "xenddev", "wxendeg", "nexenderiver", "wxentew", "xendseg", "xendedever", "wxenddev", "expenderev", "xfenderec", "xbeginserv", "eyenteriver", "wendedect", "zenderiv", "oxengev", "xenderem", "exadderv", "yenterv", "xsenderer", "rxendech", "xendew", "zendedem", "xenderew", "rxendeditem", "xendedew", "oxexceptef", "oxendef", "xfenderov", "oxengav", "zendedep", "xenter", "xfendiver", "xbeginer", "xendee", "oxendeddev", "xbeginee", "yenddev", "xendedeg", "xendeddev", "Xendedell", "txendov", "xENDrec", "xendedel", "expendererv", "xtbeginerv", "xendapter", "txendell", "xenterv", "xenderee", "xfendov", "xinitep", "xinitev", "xendedep", "xendedoc", "xstopev", "nexenderev", "xenev", "Xendell", "xexceptserv", "xbeginerv", "oxengew", "wbeginog", "xengev", "xenteriver", "exentdev", "wendeddev", "lexenderv", "xbeginiv", "xendect", "xexcepteg", "xenderef", "xendediv", "xbeginev", "lexendev", "oxendever", "xendep", "wxendedever", "xeastdev", "xendsel", "rxenderel", "oxengec", "zenderell", "rxendedev", "xendererv", "wxendapter", " xenter", "expenderep", "xnderv", "xendsec", "xenderever", "xenderav", "zenderev", "nexendeg", " xbeginserv", " xendrec", "xsendiver", "xendog", "oxentov", "Xendev", "oxenderv", "xenderect", "rxendedoc", "xenterew", "xndov", "xfendec", "txendev", "lexendederv", "xentov", "wxendedev", "xstoperv", "xendedec", "rxendel", "xtbeginer", "xendedech", " xbeginev", "xendedem", "xiderv", "xendereg", "xenderv", " xendech", "xendrec", "xendsov", "xentererer", "exaddever", "lexendek", "rxendov", "oxendedev", "eyenterever", "xbeginov", "oxexceptov", "nexendererer", "xentec", "xexceptv", "xiniterv", "oxendov", "xenderec", "xenderell", "zendval", "xendv", "xendedect", "oxentdev", "xndiver", "oxenddev", "xadddev", "wxendserv", "xndserv", "xendov", "rxenddev", "txendedex", "xenderov", "xbegindev", "xexcepterer", "exentek", "txendex", "expenderv", "wxendedeg", "xentech", "exentel", "zendem", "xenderoc", "exendel", "xinitever", "xaddrec", "xenderep", "wxenterv"]}}
{"project": "qemu", "commit_id": "c54616608af442edf4cfb7397a1909c2653efba0", "target": 0, "func": "static void json_message_process_token(JSONLexer *lexer, QString *token, JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    QDict *dict;\n\n\n\n    if (type == JSON_OPERATOR) {\n\n        switch (qstring_get_str(token)[0]) {\n\n        case '{':\n\n            parser->brace_count++;\n\n            break;\n\n        case '}':\n\n            parser->brace_count--;\n\n            break;\n\n        case '[':\n\n            parser->bracket_count++;\n\n            break;\n\n        case ']':\n\n            parser->bracket_count--;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    QINCREF(token);\n\n    qdict_put(dict, \"token\", token);\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += token->length;\n\n\n\n    qlist_append(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     */\n\n    QDECREF(parser->tokens);\n\n    parser->tokens = NULL;\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    parser->emit(parser, parser->tokens);\n\n    if (parser->tokens) {\n\n        QDECREF(parser->tokens);\n\n    }\n\n    parser->tokens = qlist_new();\n\n    parser->token_size = 0;\n\n}\n", "idx": 15457, "substitutes": {"lexer": ["come", "calle", "lexe", "scane", "comener", "ntaxe", "callaer", "scaner", " lexe", "comter", " lexaer", "mailer", "ntaxaer", "lexiter", "lexaer", " lexener", "maile", "uploade", "mailener", "scanener", " lexp", "scanter", "callp", "uploaditer", "ntaxp", "ntaxer", "lexp", "mailiter", "comer", "lexener", " lexter", "caller", "uploadener", "lexter", " lexiter", "uploader"], "token": ["event", "context", "column", "prefix", "tn", "k", "trans", "null", "json", "header", "txt", "word", "node", "translation", "local", "error", "atom", "value", "number", "format", "tree", "language", "message", "tag", "operator", "start", "list", "p", "key", "statement", "raw", "now", "name", "target", "element", "Token", "parse", "field", "initial", "rule", "buffer", "attribute", "KEN", "len", "ok", "kt", "variable", "trigger", "wt", "item", "data", "normal", "piece", "character", "single", "t", "template", "tool", "text", "table", "length", "oken", "pair"], "type": ["kind", "role", "info", "color", "pe", "ty", "time", "status", "style", "format", "error", "title", "state", "top", "otype", "new", "ver", "message", "Type", "s", "set", "start", "key", "action", "name", "port", "pos", "code", "tp", "choice", "rule", "no", "index", "ype", "id", "op", "size", "at", "class", "t", "typ", "test", "file", "part", "types", "by", "length", "ping", "TYPE"], "x": ["fx", "i", "xp", "l", "ax", "dx", "tx", "px", "xc", "xf", "loc", "xt", "p", "ux", "xa", "rx", "xs", "pos", "xes", "xy", "index", "mx", "xi", "ex", "ox", "t", " cx", "lex", "X", "ix", " xx", "wx", " i", " dx", "xx", "on"], "y": ["ey", "i", "ch", "py", "ye", "ly", "ady", "vy", "fy", "ty", "ies", "sim", "cy", "iy", "yo", "hot", "asy", "sy", " py", "ym", "year", "b", "yer", "xy", "my", "ay", "ny", "ya", "gy", "ys", "axy", "ic", "oy", "t", "yy", "ery", "Y", "sky", "by", "yt", " ty"], "parser": ["view", "timer", "jack", "server", "conv", "pool", "loader", "http", "tree", "message", "this", "scan", "storage", "writer", "parse", "tp", "rule", "instance", "engine", "function", "plant", "context", "worker", "player", "package", "oder", "peer", "connection", "processing", "number", "processor", "er", "Parser", "filter", "operator", "client", "store", "tag", "upload", "buffer", "disk", "consumer", "file", "part", "metadata", "policy", "command", "definition", "parts", "bird", "parent", "arser", "node", "format", "language", "kernel", "student", "book", "volume", "job", "iterator", "unknown", "proc", "layer", "class", "handler", "lex", "plugin", "wrapper", "program", "master", "process", "can", "params", "reader", "runner", "json", "local", "finder", "state", "document", "builder", "p", "machine", "production", "action", "upper", "ner", "callback", "raw", "now", "yer", "remote", "inner", "manager", "bank", "driver", "magic", "rer", "chart", "func", "self", "older", "test", "table", "adder"], "dict": ["details", "bind", "pkg", "dl", "inf", "d", "ind", "sum", "build", "hd", "con", "defined", "map", "tmp", "nd", "di", "local", "hash", "draw", "direct", "conf", "dh", "bd", "def", "df", "client", "list", "add", "key", "md", "pd", "window", "db", "nt", "dd", "dir", "ict", "D", "ad", "back", "data", "ud", "ct", "det", "func", "ds", "debug", "cond", "metadata", "ld", "cmd", "table", "dot", "td", "wd", "doc", "cd", "dat", "da", "obj", "pair"], "brace_count": ["braceablescore", "bracelemust", "scope_count", "scopelechain", "brace67hash", "brace64const", "trace_success", "brace_score", "brace_amount", "brace67limit", "brace_max", "scope_chain", "brace_cache", "track_count", "brace64amount", "caseablecount", "brace67score", "caseablehash", "bone_must", "braceetystatus", "bracefulcycle", "brace_cycle", "brace9const", "brace9count", "bone_count", "brace_coll", "bridge_count", "brace_chain", "brace_limit", "brace_status", "bracefulhash", "brace_success", "bracefulscore", "trace_status", "brace67count", "track_const", "track_weight", "brace_Count", "bracelecount", "brace9weight", "bracelechain", "brace_hash", "braceetysuccess", "braceleamount", "trace_max", "caseablelimit", "case_limit", "brace_const", "brace9amount", "braceablelimit", "bone_amount", "brace_weight", "bracefulcount", "bracefullimit", "braceablecount", "brace64count", "bridge_cycle", "brace_must", "braceetymax", "scope_amount", "scopeleamount", "braceetycount", "case_count", "case_hash", "track_amount", "bone_coll", "bridge_Count", "scopelecount", "case_score", "bridge_cache", "bracefulCount", "bracefulcache", "trace_count", "bracelecoll", "braceablehash", "brace64weight", "caseablescore"], "bracket_count": ["bracketetycount", "branch_state", "bracket2left", "bracket_left", "branch_count", "bracket_counter", "bracket64cache", "brack_code", "bracket64c", "brackets_left", "bracket_num", "brack_Count", "bracket_c", "bracket_Count", "bracketetyCount", "brackets_cache", "brack_count", "bracketetynum", "bracket64Count", "brwall_limit", "bracket_comment", "brwall_count", "bracket_state", "brackets_counter", "bracket_total", "bracket2count", "brwall_carry", "brack_num", "bracket_carry", "bracket_limit", "bracket_code", "brackets_comment", "brackets_Count", "brackets_count", "bracket64total", "branch_Count", "bracket64count", "brwall_Count", "branch_limit", "bracket2counter", "bracket_cache", "bracket64comment", "bracketetycode"]}}
{"project": "qemu", "commit_id": "076b35b5a56bca57c4aa41044ed304fe9c45d6c5", "target": 0, "func": "static void set_memory_options(uint64_t *ram_slots, ram_addr_t *maxram_size)\n\n{\n\n    uint64_t sz;\n\n    const char *mem_str;\n\n    const char *maxmem_str, *slots_str;\n\n    const ram_addr_t default_ram_size = (ram_addr_t)DEFAULT_RAM_SIZE *\n\n                                        1024 * 1024;\n\n    QemuOpts *opts = qemu_find_opts_singleton(\"memory\");\n\n\n\n    sz = 0;\n\n    mem_str = qemu_opt_get(opts, \"size\");\n\n    if (mem_str) {\n\n        if (!*mem_str) {\n\n            error_report(\"missing 'size' option value\");\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        sz = qemu_opt_get_size(opts, \"size\", ram_size);\n\n\n\n        /* Fix up legacy suffix-less format */\n\n        if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {\n\n            uint64_t overflow_check = sz;\n\n\n\n            sz <<= 20;\n\n            if ((sz >> 20) != overflow_check) {\n\n                error_report(\"too large 'size' option value\");\n\n                exit(EXIT_FAILURE);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* backward compatibility behaviour for case \"-m 0\" */\n\n    if (sz == 0) {\n\n        sz = default_ram_size;\n\n    }\n\n\n\n    sz = QEMU_ALIGN_UP(sz, 8192);\n\n    ram_size = sz;\n\n    if (ram_size != sz) {\n\n        error_report(\"ram size too large\");\n\n        exit(EXIT_FAILURE);\n\n    }\n\n\n\n    /* store value for the future use */\n\n    qemu_opt_set_number(opts, \"size\", ram_size, &error_abort);\n\n    *maxram_size = ram_size;\n\n\n\n    maxmem_str = qemu_opt_get(opts, \"maxmem\");\n\n    slots_str = qemu_opt_get(opts, \"slots\");\n\n    if (maxmem_str && slots_str) {\n\n        uint64_t slots;\n\n\n\n        sz = qemu_opt_get_size(opts, \"maxmem\", 0);\n\n        slots = qemu_opt_get_number(opts, \"slots\", 0);\n\n        if (sz < ram_size) {\n\n            error_report(\"invalid value of -m option maxmem: \"\n\n                         \"maximum memory size (0x%\" PRIx64 \") must be at least \"\n\n                         \"the initial memory size (0x\" RAM_ADDR_FMT \")\",\n\n                         sz, ram_size);\n\n            exit(EXIT_FAILURE);\n\n        } else if (sz > ram_size) {\n\n            if (!slots) {\n\n                error_report(\"invalid value of -m option: maxmem was \"\n\n                             \"specified, but no hotplug slots were specified\");\n\n                exit(EXIT_FAILURE);\n\n            }\n\n        } else if (slots) {\n\n            error_report(\"invalid value of -m option maxmem: \"\n\n                         \"memory slots were specified but maximum memory size \"\n\n                         \"(0x%\" PRIx64 \") is equal to the initial memory size \"\n\n                         \"(0x\" RAM_ADDR_FMT \")\", sz, ram_size);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        *maxram_size = sz;\n\n        *ram_slots = slots;\n\n    } else if ((!maxmem_str && slots_str) ||\n\n            (maxmem_str && !slots_str)) {\n\n        error_report(\"invalid -m option value: missing \"\n\n                \"'%s' option\", slots_str ? \"maxmem\" : \"slots\");\n\n        exit(EXIT_FAILURE);\n\n    }\n\n}\n", "idx": 15482, "substitutes": {"ram_slots": ["ram_plot", "ram_plores", "ram_slot", "ram_blobs", "ram_plots", "ram_lots", "ram_blores", "ram_blots", "ram_lobs", "ram_lot", "ram_slores", "ram_lores", "ram_plobs", "ram_blot", "ram_slobs"], "maxram_size": ["maxram_name", "maxramaxysize", "maxramaxyname", "maxgram_size", "maxgram_mode", "maxgram_name", "maxramaxywidth", "maxram_width", "maxram_mode", "maxgram_SIZE", "maxgram_width", "maxram_SIZE", "maxramaxySIZE"], "sz": ["szi", "Szi", " szer", "inszi", "bytesze", "szer", "bytesz", "osnz", "bytesiz", "imsz", "Siz", "rsnz", "Size", "imsld", "Sze", "insze", "snz", "haszer", "jsiz", "jsz", "ssZ", "Sld", "ssiz", "imszer", "gesz", "ssld", "gesnz", "size", "jszi", "ssze", "sszi", "tsZ", "SZ", "insZ", "tsiz", "psz", "imsze", " siz", "insz", " szi", "rszi", "gesiz", "oszi", "sZ", "insiz", "haszi", "siz", "psze", "rsiz", "jsZ", " sze", "sze", "rsz", "osz", "insld", "geszi", " sld", "hasz", "psiz", "insize", "ssz", "gesize", "imszi", "imsiz", "tsz", " sZ", "pszi", "Sz", "tszi", "hasiz", "geszer", "jsze", "sld", "byteszi", "Szer", "osiz"], "mem_str": [" mem_Str", "mem2dr", " mem_buf", " mem_br", "memogctr", "mem2arr", "mem_string", "mem_buf", "memaxydr", "mem_arr", " mem_ctr", "mem_format", " mem_dat", "mem_dat", "mem_Str", "memaxystri", "memogStr", " mem_dr", "memogstr", " mem_format", "mem2string", "mem_br", "mem_dr", "mem_stri", "memogstring", " mem_string", "memaxystr", "mem2str", "memaxybuf", "mem_ctr", " mem_arr", " mem_stri"], "maxmem_str": ["maxmemaxystring", "maxmem___rs", "maxmemaxystr", "maxgram_string", "maxmem_stick", "maxmemaxystick", "maxmem___br", "maxmemory_dr", "maxmem___str", "maxgram_dr", "maxmem_string", "maxmemory_str", "maxmem_rs", "maxgramaxydr", "maxmemaxydr", "maxgram_stick", "maxmemory_string", "maxgramaxystick", "maxmem_br", "maxmemory_rs", "maxgram_str", "maxgramaxystr", "maxmemory_br", "maxmem_dr", "maxgramaxystring", "maxmem___string"], "slots_str": ["slots_arr", "slots_list", "slores_br", "slores_list", "slops_string", "slores_str", "slops_str", "slores_string", "slots_STR", "slores_arr", "slots_strings", "slots_br", "slores_STR", "slops_dr", "slops_strings", "slots_dr", "slots_string"], "opts": ["OpTS", " optorts", "opcs", "experTS", "opTS", "okfs", "Opfs", " optes", "copts", "opents", "iopTS", "oprs", "oktions", "copcs", " opents", "popTS", "prouts", "proTS", "opss", "popsts", "operks", " copts", "opns", "popcs", " opns", "copsts", " oputs", "attts", "attorts", "popts", "optTS", "opsts", " coptes", " oports", "okts", "operts", "opks", "copfs", " opouts", "Options", "opters", "opttions", "experters", " copTS", " opters", "prots", "copouts", "attents", "oports", "opfs", " optents", "options", "Opts", "optts", "prors", " copks", " opfs", " opss", "operlets", "iopks", " coptions", "opouts", " coplets", "ioplets", "experts", "optss", "optfs", "iopts", "iopcs", "optuts", "experss", "optters", " opTS", " opcs", "copns", "optouts", "copTS", "oplets", "optns", " options", " oprs", " optts", " optcs", "opttes", " copters", "oputs", "optrs", "attcs", "iopsts", "okTS", "operTS", "optes"], "slots": ["klows", "islashes", "plotted", "klugs", " slows", "plbs", "plots", "blots", "blashes", "slbs", "plashes", " sliders", " slugs", "blotted", "islbs", "islotted", "lows", "lots", "kliders", "slugs", "slotted", "sliders", "lugs", "islots", "klots", "blbs", "slows", "liders", "slashes"]}}
{"project": "qemu", "commit_id": "b9f7855a50a7cbf04454fa84e9d1f333151f2259", "target": 0, "func": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    /* We don't actually refresh here, but just return data queried in\n\n     * iscsi_open(): iscsi targets don't change their limits. */\n\n\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;\n\n\n\n    bs->request_alignment = iscsilun->block_size;\n\n\n\n    if (iscsilun->bl.max_xfer_len) {\n\n        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);\n\n    }\n\n\n\n    if (max_xfer_len * iscsilun->block_size < INT_MAX) {\n\n        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->lbp.lbpu) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff) {\n\n            bs->bl.max_discard =\n\n                sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun);\n\n        }\n\n        bs->bl.discard_alignment =\n\n            sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun);\n\n    } else {\n\n        bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS;\n\n    }\n\n\n\n    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {\n\n        bs->bl.max_pwrite_zeroes =\n\n            iscsilun->bl.max_ws_len * iscsilun->block_size;\n\n    }\n\n    if (iscsilun->lbp.lbpws) {\n\n        bs->bl.pwrite_zeroes_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;\n\n    }\n\n    if (iscsilun->bl.opt_xfer_len &&\n\n        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {\n\n        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *\n\n                                        iscsilun->block_size);\n\n    }\n\n}\n", "idx": 15486, "substitutes": {"bs": ["bos", "fs", "sb", "bl", "aos", "bt", "bc", "blog", "bes", "aus", "ubis", "hz", "bh", "ps", "bn", "bd", "ib", "pb", "ls", "vs", "irms", "hs", "gs", "b", "ats", "its", "js", "eb", "ports", "lbs", "sts", "bb", "zb", "bles", "bis", "boxes", "vals", "cks", "css", "acs", "bps", "BS", "ds", "ubs", "bp", "bsp", "cs", "ts", "bits", "stats", "bi", "qs", "bg", "ins", "bm", "obs", "ns", "banks", "ss"], "errp": ["erp", "ErP", "Erpb", "lerp", "errP", "Erp", "lerpb", "lerP", "errpb", "erpb", "erP"], "iscsilun": ["ischslun", "ascchlorun", "iscsevereu", "miscsilun", "descgiluna", "iscosilon", "rissilund", "ionicsilune", "iscosentmun", "nickillun", "iscmilon", "misckillun", "iscslmun", "iscosilgun", "usercsilun", "ionicspellund", "miscsentan", "sicmilunt", "icsevereun", "iscmilune", "iscsentut", "iscsevereund", "iscsilcon", "iscsuccessfuluna", "misckillut", "isecesiune", "uscsilgun", "iscesiunt", "iscsuccessfulune", "uscsiluna", "iscsilu", "iscurityunt", "iscidentunt", "iscsilou", "uscvaleun", "nicsidune", "iscosentut", "nicsilan", "iscryptu", "sicsilun", "iscselune", "iscinelund", "isecsilunt", "iscilunk", "internationalsilun", "iscmilout", "icsilunt", "nickillgun", "nicsiduna", "rissevereund", "uscvaleunk", "uscvaleune", "iscsuun", "iscsevereut", "iscgilmun", "iscsentune", "iscsentan", "ionicspelluna", "iscchlorgun", "iscsilon", "iscgilun", "uscsinuna", "iscvaleune", "iscinelou", "iscsnun", "ionicsilun", "iscsolunc", "iscsentun", "iscSilgun", "isckillmun", "iscurityune", "iscgilan", "iscsolgun", "iscsilmun", "isckillun", "isctilun", "iscpixelun", "iscmilgun", "rissevereun", "isecsilun", "iscsnunt", "internationalsucon", "ionicspellune", "isckillum", "iscosilut", "iscgilut", "isculenceund", "iscosilout", "ascchlorgun", "iscillut", "uscsilmun", "descsilune", "isculentun", "miscsentune", "ascsiluna", "iscseverecon", "icseveremun", "iscsingun", "nickillunc", "iscinelcon", "isctiluna", "iscselung", "usercsentoul", "iscsentout", "iscsinune", "miscsentun", "uscsilur", "iscsolunt", "iscvaleunk", "iscselund", "iscosilu", "iscsolun", "iscriticalum", "iscosentgun", "isckillgun", "descsiluna", "iscsilunk", "iscsinun", "iscsinu", "iscinelun", "iscitisu", "miscsilunk", "iscsolunk", "ionicsilund", "iscsolune", "icsilmun", "iscesiund", "iscsilur", "iscsluna", "iscsentuna", "iscinelunk", "iscsilum", "iscsnmun", "misckillmun", "iscsinund", "iscsidu", "iscidentgun", "internationalsilund", "iscsslune", "iscsilung", "isctilur", "rissilum", "miscsilut", "iscsevereuna", "sicsilmun", "iscvaleunt", "isculenceuna", "nicsilgun", "iscgilu", "iscseveremun", "isecsilu", "iscspellune", "sicsilunt", "uscsilunc", "internationalsuund", "iscriticalmun", "isecineluna", "isclitun", "descgilunc", "descgilun", "uscsilan", "miscinelun", "ischsilun", "iscsentunk", "iscSilun", "ischsilut", "iscryptun", "iscillunt", "iscinelunt", "iscsevereun", "iscslun", "isculentmun", "iscsilout", "iscsentund", "iscsilUN", "isecsiluna", "iscsevereou", "ascsilunt", "iscilun", "iscgilunc", "iscsilune", "iscselunt", "ischslut", "uscsinur", "iscurityun", "iscosentun", "iscsevereum", "usercsentund", "iscsentgun", "rissilun", "isculentunt", "internationalsilcon", "iscsuou", "iscgiluna", "iscsentum", "descsilunc", "iscsuund", "usercsilund", "uscsilunt", "iscosenton", "descgilune", "sicsiluna", "iscspellund", "ascsilun", "iscurityung", "iscsinan", "iscinelmun", "iscchloru", "iscittengun", "iscsinunc", "uscvaleunt", "uscsinmun", "icsilun", "uscsilund", "iscchlorun", "uscsinu", "nicsilun", "isculenceun", "internationalsilou", "iscSilon", "iscsilan", "iscsinmun", "iscsloul", "miscsilund", "iscslund", "iscinelum", "iscillmun", "nicsidunc", "iscsinuna", "uscsilune", "isclitmun", "nicsidun", "miscsiluna", "rissilu", "iscsilund", "uscsilunk", "iscmilan", "iscriticalut", "iscsinung", "iscittenund", "ischsilunt", "miscsilan", "descsilun", "uscsinunc", "isculentuna", "isecsilune", "isctilan", "iscsslund", "isckillan", "isecinelund", "iscmilmun", "uscsinung", "iscsentunt", "iscmiluna", "isecsilund", "miscinelund", "iscsilunc", "iscinelut", "iscpixelund", "isecesiunt", "iscsenton", "iscsidund", "iscryptune", "sicmilmun", "nicsilune", "iscspelluna", "iscsilunt", "isckillut", "usercsentun", "ischslmun", "isctilunt", "iscseluna", "uscsinund", "iscosentu", "miscsilum", "isecesiun", "iscsentu", "uscsilu", "nickillan", "iscsentoul", "sicmilun", "iscvaleun", "iscsidunc", "iscsidun", "miscinelune", "iscpixelune", "ascchloruna", "iscidentun", "iscsinUN", "isclituna", "iscinelune", "nicsilunc", "iscsolUN", "isclitunt", "nicsiluna", "iscsnuna", "iscSilout", "iscslunt", "iscsucon", "internationalsuun", "iscsinunt", "rissevereum", "ischsilmun", "iscryptmun", "uscsingun", "iscselun", "iscchlorund", "isckillunc", "iscesiuna", "icsevereuna", "iscsiloul", "iscsilut", "usercsiloul", "iscmilun", "icsevereunt", "iscineluna", "iscidentUN", "ischslunt", "usercsentuna", "iscosilmun", "iscsoluna", "isecinelu", "miscsilune", "iscgilune", "iscilunt", "iscsuccessfulund", "misckillum", "iscosilun", "iscsevereunt", "iscsslun", "ionicsiluna", "iscsiduna", "uscsinune", "uscsilUN", "iscryptgun", "uscsinUN", "iscchloruna", "iscmilunt", "ionicspellun", "uscsilun", "miscineluna", "uscsilung", "uscsinun", "iscryptunt", "isecinelun", "iscryptuna", "iscittenune", "iscesiun", "iscsentmun", "uscsinan", "iscesiune", "iscchlorunt", "iscsilgun", "miscsentunk", "iscsinur", "ascchlorunt", "iscitismun", "usercsiluna", "iscitisune", "sicmiluna", "isecesiuna", "uscsinunt", "iscmilunc", "internationalsuou", "iscillun", "iscosentout", "iscpixeluna", "iscittenun", "iscesigun", "iscspellun", "iscsidune", "iscsslunc", "isculenceoul", "iscgilur", "rissevereu", "icsiluna", "iscsinunk", "iscilune", "ascsilgun", "iscitisun", "iscsentunc", "iscsiluna", "iscslut", "iscinelu", "iscinelan", "isctilgun", "iscsuccessfulun", "miscsilmun", "iscriticalun"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)\n\n{\n\n    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);\n\n}\n", "idx": 15492, "substitutes": {"env": ["dn", "context", "bind", "end", "ve", "sb", "stack", "server", "rb", "buf", "nv", "cb", "conf", "er", "environment", "uv", "te", "viron", "ah", "code", "window", "db", "e", "dev", "entry", "shell", "ctx", "project", "cv", "buffer", "ev", "iv", "conn", "en", "ov", "param", "ef", "ec", "ped", "esc", "nc", "config", "v", "ee"], "m": ["i", "d", "l", "menu", "dm", "om", "n", "gm", "managed", "cm", "M", "c", "p", "mc", "nm", "wm", "ms", "mem", "mac", "e", "b", "g", "module", "j", "msg", "mt", "mm", "km", "t", "em", "tm", "mi", "man", "sm", "v", "perm", "vm", "mu"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void ide_atapi_cmd(IDEState *s)\n\n{\n\n    uint8_t *buf;\n\n\n\n    buf = s->io_buffer;\n\n#ifdef DEBUG_IDE_ATAPI\n\n    {\n\n        int i;\n\n        printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8));\n\n        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {\n\n            printf(\" %02x\", buf[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n    /*\n\n     * If there's a UNIT_ATTENTION condition pending, only command flagged with\n\n     * ALLOW_UA are allowed to complete. with other commands getting a CHECK\n\n     * condition response unless a higher priority status, defined by the drive\n\n     * here, is pending.\n\n     */\n\n    if (s->sense_key == UNIT_ATTENTION &&\n\n        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {\n\n        ide_atapi_cmd_check_status(s);\n\n        return;\n\n    }\n\n    /*\n\n     * When a CD gets changed, we have to report an ejected state and\n\n     * then a loaded state to guests so that they detect tray\n\n     * open/close and media change events.  Guests that do not use\n\n     * GET_EVENT_STATUS_NOTIFICATION to detect such tray open/close\n\n     * states rely on this behavior.\n\n     */\n\n    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&\n\n        !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {\n\n\n\n        if (s->cdrom_changed == 1) {\n\n            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n            s->cdrom_changed = 2;\n\n        } else {\n\n            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);\n\n            s->cdrom_changed = 0;\n\n        }\n\n\n\n        return;\n\n    }\n\n\n\n    /* Report a Not Ready condition if appropriate for the command */\n\n    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&\n\n        (!media_present(s) || !bdrv_is_inserted(s->bs)))\n\n    {\n\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n        return;\n\n    }\n\n\n\n    /* Execute the command */\n\n    if (atapi_cmd_table[s->io_buffer[0]].handler) {\n\n        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);\n\n        return;\n\n    }\n\n\n\n    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);\n\n}\n", "idx": 15495, "substitutes": {"s": ["bs", "fs", "esm", "ties", "http", "ps", "r", "args", "ms", "js", "g", "services", "sw", "gets", "se", "y", "ins", "sis", "details", "h", "changes", "sb", "ops", "terms", "results", "os", "als", "sv", "has", "er", "m", "sports", "events", "as", "w", "j", "t", "times", "states", "is", "source", "ains", "ns", "rs", "asm", "sl", "ies", "S", "c", "comm", "sys", "ls", "vs", "hs", "ats", "its", "ims", "sq", "https", "ts", "a", "bits", "errors", "qs", "params", "ss", "sts", "aunts", "n", "z", "ses", "conf", "p", "es", "aws", "gs", "b", "spec", "bis", "less", "ds", "self", "cs", "comments", "v", "stats", "simple"], "buf": ["uf", "pkg", "h", "queue", "ff", "cache", "ref", "bar", "map", "bytes", "tmp", "orig", "bc", "txt", "br", "conv", "rb", "Buff", "pool", "cur", "cb", "p", "vec", "err", "batch", "img", "cast", "pb", "tr", "cam", "buff", "bag", "pay", "mem", "b", "fb", "buffer", "len", "ctx", "cv", "uffy", "Buffer", "cap", "seq", "BU", "proc", "pack", "rw", "cmd", "v", "wb", "w"], "i": ["qi", "l", "ai", "ii", "n", "gi", "io", "di", "point", "x", "sim", "cli", "ip", "init", "u", " bi", "ti", "li", "hi", "\u0438", "I", "p", " j", " I", "si", "ei", "m", "oi", "client", "list", "ms", "in", "multi", "im", "ami", "my", " v", "index", "iu", " m", "it", "j", "me", "ci", "xi", "ki", "t", "phi", "zi", "span", "ix", "MI", "mi", "o", "a", "is", "pi", "y", "bi", "ini", "ui", "length", " multi", " ti", "PI"]}}
{"project": "FFmpeg", "commit_id": "d208d1eba3799c58fd6d3602d31de3e686f14aec", "target": 1, "func": "void ff_hevc_luma_mv_merge_mode(HEVCContext *s, int x0, int y0, int nPbW,\n\n                                int nPbH, int log2_cb_size, int part_idx,\n\n                                int merge_idx, MvField *mv)\n\n{\n\n    int singleMCLFlag = 0;\n\n    int nCS = 1 << log2_cb_size;\n\n    LOCAL_ALIGNED(4, MvField, mergecand_list, [MRG_MAX_NUM_CANDS]);\n\n    int nPbW2 = nPbW;\n\n    int nPbH2 = nPbH;\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n\n\n    memset(mergecand_list, 0, MRG_MAX_NUM_CANDS * sizeof(*mergecand_list));\n\n\n\n    if (s->pps->log2_parallel_merge_level > 2 && nCS == 8) {\n\n        singleMCLFlag = 1;\n\n        x0            = lc->cu.x;\n\n        y0            = lc->cu.y;\n\n        nPbW          = nCS;\n\n        nPbH          = nCS;\n\n        part_idx      = 0;\n\n    }\n\n\n\n    ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);\n\n    derive_spatial_merge_candidates(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                                    singleMCLFlag, part_idx,\n\n                                    merge_idx, mergecand_list);\n\n\n\n    if (mergecand_list[merge_idx].pred_flag[0] == 1 &&\n\n        mergecand_list[merge_idx].pred_flag[1] == 1 &&\n\n        (nPbW2 + nPbH2) == 12) {\n\n        mergecand_list[merge_idx].ref_idx[1]   = -1;\n\n        mergecand_list[merge_idx].pred_flag[1] = 0;\n\n    }\n\n\n\n    *mv = mergecand_list[merge_idx];\n\n}\n", "idx": 15515, "substitutes": {"s": ["bs", "h", "i", "fs", "l", "rs", "sg", "sn", "n", "sb", "cli", "S", "os", "aus", "c", "sv", "ps", "p", "sys", "r", "es", "m", "ls", "gs", "b", "e", "its", "js", "ims", "sts", "g", "j", "acs", "t", "ds", "cs", "sc", "o", "a", "is", "v", "f", "w", "ns", "ss"], "x0": ["x2", "ox2", "ixfe", "x10", "ex0", "xx0", "xml14", "oxfe", "tx5", "X3", " x2", "ex3", "x7", "ix0", "xZero", "ix7", " x14", "ox10", " x3", " xZero", "ox3", "tx0", "X0", "ox7", "xml0", "txfe", " x7", "tx10", "ex1", "ix3", "xfe", "X1", "ox0", " x1", "ix2", "x5", "xx14", "ix5", "xmlZero", "X2", "ex2", "ix10", "ox5", "x1", "x14", "xxZero", "x3"], "y0": ["yy1", "yZero", "ty06", "ny180", " y1", "y1", "dy180", "YZero", " y06", "yy0", " yZero", "hZero", " y2", "Y0", "yt0", "h0", "yy180", "dyZero", "ny0", "y2", "dy0", "ty2", "h06", "y06", "yyZero", "ty0", "Y1", "h2", "tyZero", "ytZero", "y180", "nyZero"], "nPbW": ["nPbWA", "nPabL", "nPortcL", "nvPbpL", "nPchW", "nPEdbW", "nPortcY", "nPortbL", "nPchWH", "nPbHT", "nPbVW", "nPabWR", "nPwbWH", "nPEdbWe", "nPnbVW", "nPDbL", "nPortcWH", "nPxVW", "nvPbW", "nPDbVW", "nPDbV", "nPcW", "nPortcW", "nvPbpW", "nPortcWR", "nPlbWA", "nPbrV", "nPwbW", "nPEbHT", "nPDnbV", "nPbpW", "nPcL", "nPbpWin", "nPdbV", "nPbpWA", "nPbrW", "nPwbWR", "nPcWH", "nPEdbV", "nPEdbHT", "nPcV", "nPsbV", "nPdWin", "nPsbW", "nPortbWR", "nPdW", "nPbpL", "nPdWA", "nPbWH", "nPcVW", "nPEbV", "nPnbV", "nPcY", "nvPbWin", "nPbWR", "nPbrHT", "nPbWe", "nPortbW", "nPdbWe", "nPDbW", "nPwbL", "nPortbWH", "nPbL", "nPnbW", "nPxL", "nPabY", "nPnbL", "nvPbL", "nPsbHT", "nPabW", "nPlbWin", "nvPbWA", "nPbrWe", "nvPbpWin", "nPortbY", "nPEbW", "nPdL", "nPwbY", "nPlbL", "nPbWin", "nPxV", "nPchWR", "nPdbW", "nPDnbL", "nPDnbW", "nPbV", "nPlbW", "nPsbWe", "nPxW", "nvPbpWA", "nPEbWe", "nPcWR", "nPDnbVW", "nPdbHT", "nPbY"], "nPbH": ["nPbtHA", "nPvMH", "nPbtH", "nPvT", "nPbaHB", "nPvH", "nPbaH", "nPbHE", "nPobH", "nNbHis", "nNvW", "nPcW", "nPbT", "nPUbHA", "nPUbHE", "nPUbpHA", "nPobRH", "nPvRH", "nNvHis", "nPUbpHB", "nPosbRH", "nPcMH", "nPcT", "nPabHis", "nPbHA", "nPwbW", "nNvH", "nPbaHE", "nPbpHB", "nMbW", "nPayfbW", "nPfbHD", "nPosbHa", "nPbaHA", "nNbH", "nPbpH", "nPbpHA", "nPayfbH", "nPsbW", "nPUbHB", "nPaybH", "nPfbMH", "nPbHa", "nPfbW", "nPfbH", "nPayfbHD", "nPbHis", "nPosbH", "nMbH", "nPosbW", "nPfbY", "nPobHa", "nPbtHB", "nPabY", "nPvHa", "nPabH", "nPabT", "nPvHis", "nPvW", "nMvH", "nPsbHa", "nPsbRH", "nPabW", "nPayfbMH", "nPwbH", "nPbMH", "nPvHD", "nPvY", "nNbY", "nMvW", "nPaybHD", "nPfbHis", "nPcH", "nPobW", "nPcHD", "nPaybMH", "nPbRH", "nPbtHE", "nMvT", "nPUbH", "nPaybW", "nNbW", "nPwbRH", "nPwbHa", "nPsbH", "nPbpHE", "nPbHD", "nPbHB", "nPUbpHE", "nMbT", "nNvY", "nPUbpH", "nPbY"], "log2_cb_size": ["log2_cb_sum", "log2_cb_SIZE", "log2_cb1Size", "log2_cb1SIZE", "log2_cv_SIZE", "log2_rb_scale", "log2_cb_set", "log2_cv_size", "log2_rb_SIZE", "log2_rb_size", "log2_cb1size", "log2_cbptsize", "log2_cbptscale", "log2_cbptsum", "log2_cb1sum", "log2_rb_Size", "log2_cb_scale", "log2_rb_sum", "log2_cb_Size", "log2_cv_set"], "part_idx": ["part_indexxf", "part_indexx", "part_sidv", "part_Idxc", "part_Idv", "part_Idx", "part_pidv", "part_ridx", "part_idey", "part_idexs", "part_pidx", "part_indexv", "part___sidxc", "part_idsx", "part___sidv", "part_idv", "part___idy", "part_iden", "part___sidx", "part_ridy", "part_Idy", "part_idex", "part_idn", "part_pidxf", "part___idv", "part_idxf", "part_idsy", "part___sidy", "part_idsn", "part_Idn", "part___idxc", "part_Idxs", "part_ridv", "part_idy", "part_sidxc", "part_sidy", "part_ridxc", "part_sidx", "part___idx", "part_idxs", "part_idsxs", "part_idxc"], "merge_idx": ["merge_idxf", "merge_idsxe", "merge___statn", "merge___idxf", "merge_randy", "mergeptheadxb", "merge_indexy", "merge__idxe", "merge_itd", "merge_randx", "merge_namen", "merge_Idy", "merge_ridx", "merge_dix", "merge_methodxb", "merge_idl", "merge_ridz", "merge_idw", "merge_headx", "merge__idw", "merge__midw", "merge_headd", "merge_indexn", "merge__midr", "merge_idz", "merge_idex", "merge___statd", "merge_idxe", "merge_idd", "mergeptidex", "merge_idsx", "merge_Idx", "merge_did", "merge_midw", "merge_linz", "merge_midxe", "mergeptidx", "merge_randxb", "merge_ridd", "mergeptidxb", "merge_idsz", "merge_endr", "merge_indexl", "merge_kidxf", "merge_midx", "merge_randix", "merge_headex", "merge__midx", "merge_partr", "merge___statx", "merge_Idix", "merge_statd", "merge___idx", "merge_idn", "merge_dixb", "merge_statn", "merge_linx", "merge___idn", "merge_methodx", "merge_endxe", "merge_kidy", "merge_methodix", "merge_idsn", "merge_itn", "merge_statxb", "merge_idy", "merge_namey", "merge_itx", "merge_namel", "merge_statx", "merge_namex", "merge_endw", "merge__midxe", "merge_itxf", "merge_linn", "merge_headxb", "merge_idr", "merge__idr", "merge_ridxf", "merge_idxb", "merge_statxf", "merge_partxe", "merge_kidx", "merge_partx", "merge_endx", "merge_kidix", "mergeptheadd", "merge_midr", "merge_statex", "merge_diex", "merge___statxf", "merge_ridn", "merge_Idxf", "mergeptheadx", "merge_methody", "merge_idix", "merge_indexx", "merge___idd", "mergeptidd", "merge_partw", "merge_linxe", "merge__idx", "merge_ridxe", "mergeptheadex"], "mv": ["MV", "mw", "vV", "mf", "mV", "Mf", "Mq", "Mav", "pV", "vq", " mq", " mV", "Mw", "vav", "mq", "vv", "mav", "pw", " mw", "pv", "pf", " mav", "Mv", " mf"], "lc": ["LC", "dl", "vc", "l", "lp", "tl", "pc", "bc", "unc", "cli", "ctl", "cm", "lb", "c", "cp", "xc", "cu", "uci", "mc", "kl", "jac", "ls", "cci", "lvl", "ln", "tc", "cc", "lv", "gc", "gru", "lf", "rl", "acl", "ci", "cl", "soc", "lu", "ec", "func", "ll", "fc", "cs", "lib", "lr", "icc"]}}
{"project": "qemu", "commit_id": "5f706fdc164b20b48254eadf7bd413edace34499", "target": 1, "func": "int s390_cpu_write_elf64_note(WriteCoreDumpFunction f, CPUState *cs,\n\n                              int cpuid, void *opaque)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    return s390x_write_all_elf64_notes(\"CORE\", f, cpu, cpuid, opaque);\n\n}\n", "idx": 15517, "substitutes": {"f": ["uf", "fx", "fs", "d", "l", "fp", "fm", "n", "bf", "rf", "c", "exec", "xf", "p", "df", "tf", "b", "fb", "fn", "fi", "fab", "fd", "fun", "cf", "lf", "sf", " ff", "ef", "func", "t", "fc", "function", "v", "F", "w"], "cs": ["bs", "fs", "rs", "CS", "pc", "ks", "cas", "c", "cp", "cu", "ps", "s", "mc", "ls", "cc", "js", "sts", "gc", "cus", "cf", "caps", "Cs", "ci", "css", "acs", "ec", "ds", "fc", "sc", "ts", "wcs", "ics", "ac", "ns", "ss"], "cpuid": ["CPu", "cuid", " cpud", "ctxuid", "cUID", "pkgu", "ctxuu", "cu", "pkgud", "cuu", "cpud", "ctxud", "cpuu", " cpUID", "CPuid", "pkguu", "CPuu", "CPUID", "cpUID", "ctxu", "pkguid", " cpuu"], "opaque": ["oplent", " opaco", "obent", "oplaque", "obacity", "obaque", "oplacity", "hopque", "hopica", "Opacity", "ocaco", "opent", "Opaques", "oplaques", "opque", "Opent", "hopaco", "opica", "opacity", "hopaque", "ocque", "obaques", " opque", "opaques", "opaco", "ocica", " opica", "ocaque", "Opaque"], "cpu": ["pkg", "cal", "clock", "cache", "lan", "runner", "pc", "gpu", "alloc", "cum", " computer", "util", "local", "pu", " cp", "processor", "cp", "c", "cu", "core", "physical", "linux", "gp", "ctx", "gc", " proc", " nu", "nic", "ka", "proc", "CPU", "phys", "prof", "net", "phy", "sky", "base", "process", " gorilla", "uu", "mu", "current", "gra", "ull"]}}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void encode_clnpass(Jpeg2000T1Context *t1, int width, int height, int bandno, int *nmsedec, int bpno)\n\n{\n\n    int y0, x, y, mask = 1 << (bpno + NMSEDEC_FRACBITS);\n\n    for (y0 = 0; y0 < height; y0 += 4)\n\n        for (x = 0; x < width; x++){\n\n            if (y0 + 3 < height && !(\n\n            (t1->flags[y0+1][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n\n            (t1->flags[y0+2][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n\n            (t1->flags[y0+3][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n\n            (t1->flags[y0+4][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG))))\n\n            {\n\n                // aggregation mode\n\n                int rlen;\n\n                for (rlen = 0; rlen < 4; rlen++)\n\n                    if (t1->data[y0+rlen][x] & mask)\n\n                        break;\n\n                ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_RL, rlen != 4);\n\n                if (rlen == 4)\n\n                    continue;\n\n                ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI, rlen >> 1);\n\n                ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI, rlen & 1);\n\n                for (y = y0 + rlen; y < y0 + 4; y++){\n\n                    if (!(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))){\n\n                        int ctxno = ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1], bandno);\n\n                        if (y > y0 + rlen)\n\n                            ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, t1->data[y][x] & mask ? 1:0);\n\n                        if (t1->data[y][x] & mask){ // newly significant\n\n                            int xorbit;\n\n                            int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit);\n\n                            *nmsedec += getnmsedec_sig(t1->data[y][x], bpno + NMSEDEC_FRACBITS);\n\n                            ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, (t1->flags[y+1][x+1] >> 15) ^ xorbit);\n\n                            ff_jpeg2000_set_significance(t1, x, y, t1->flags[y+1][x+1] >> 15);\n\n                        }\n\n                    }\n\n                    t1->flags[y+1][x+1] &= ~JPEG2000_T1_VIS;\n\n                }\n\n            } else{\n\n                for (y = y0; y < y0 + 4 && y < height; y++){\n\n                    if (!(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))){\n\n                        int ctxno = ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1], bandno);\n\n                        ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, t1->data[y][x] & mask ? 1:0);\n\n                        if (t1->data[y][x] & mask){ // newly significant\n\n                            int xorbit;\n\n                            int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit);\n\n                            *nmsedec += getnmsedec_sig(t1->data[y][x], bpno + NMSEDEC_FRACBITS);\n\n                            ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, (t1->flags[y+1][x+1] >> 15) ^ xorbit);\n\n                            ff_jpeg2000_set_significance(t1, x, y, t1->flags[y+1][x+1] >> 15);\n\n                        }\n\n                    }\n\n                    t1->flags[y+1][x+1] &= ~JPEG2000_T1_VIS;\n\n                }\n\n            }\n\n        }\n\n}\n", "idx": 15520, "substitutes": {"t1": ["tae", "t2", " tasso", "t91", "yah", "T11", "att9", "y001", "tt9", "tron", "treeanta", "template2", "bt01", "type1", "t81", "at11", "att001", "Tron", "tyasso", "T1", "template25", "att1", "wtau", "tsav", "y81", "at001", "t9", "attau", "tdae", "tdons", "attasso", "tav", "T3", "wtanta", "tree25", "attanta", "wt91", "td25", "ttasso", "atae", "ty1", "ht91", "bt001", "t11", "htau", "atasso", "bt1", "treeau", "btae", "tyae", "t6", "t001", "htasso", "tree11", "tsau", " t9", "typeanta", "ts1", "Tau", "at1", "tanta", "templateau", "tau", "tree1", "ht1", "tt1", "ttah", "ttanta", "t3", "template1", "y2", "wt1", "T81", "tt001", "ttae", "ttau", "tons", " t2", " t3", "td01", "at2", "templateons", "ts2", "treeons", "tt6", "T2", "tree2", "t01", "y1", "ty001", "tt3", "tt2", "templateav", "Tah", "template81", "td1", "tah", " tau", "td001", "templateah", " t6", "t25", "treeron", "type001", "Tav", "yae", "wtasso", "attah", "htanta", "atron", "templateanta", "tasso", "T6", "typeah", " t91", "y01"], "height": ["shape", "h", "view", "resolution", "angle", "image", "th", "ty", "radius", "padding", "history", "header", "above", "depth", "input", "density", "gh", "border", "Height", "hang", "beam", "hs", "read", "window", "count", "xy", "ih", "volume", "size", "html", "rows", "row", "inches", "bottom", "hei", "high", "base", "wh", "length", "w", "ht"], "bandno": ["bbno", " bitno", " bandnumber", "bandnum", "bbnum", " bitNo", "bbnumber", " bandNo", "bandnumber", " bitnumber", " bitnum", "bandNo", "bbNo", " bandnum"], "nmsedec": ["nmdedEC", "nmsedtc", "nmsedEC", "nmsEDec", "nmssedec", "nmsededtc", "nmsededraw", "nmssedraw", "nmdsedraw", "nmdedec", "nmdedraw", "nmssedEC", "nmdsedtc", "nmdsedec", "nmsEDEC", "nmsedraw", "nmdedtc", "nmssedtc", "nmsededEC", "nmsEDtc", "nmsededec", "nmsEDraw", "nmdsedEC"], "bpno": ["fpNo", "bgno", "lporno", "bporno", "bbNo", "fpnumber", "lpno", "bborno", "fpno", "bgNo", "bgNO", "bbnos", "bbnumber", "bpnumber", "bgorno", "bpNO", "BPnumber", "lpNo", "BPnos", "bpNo", "bbno", "lpNO", "bpnos", "BPno", "bbNO", "BPNo", "fpnos"], "y0": ["yZero", "Y2", "ty17", "py00", "iy0", "ye000", "yfrom", "dy000", "ty00", "pyZero", "y00", "ye25", "cy83", "t83", " yZero", "yElement", "ry180", "ny17", "ry83", "iy25", "ny00", "oy0", "ryem", "yyZero", "ty0", "py000", "ytBeg", "y83", "y150", "link050", "t0", "_", "cy000", "ny03", "ryElement", "ryZero", "yt000", "vystart", "vyaddr", "YZero", "yBeg", "ry255", "xy0", "y17", "yt00", "iy050", "cyZero", "uy00", "y050", "tZero", "fy047", "sy83", "sy150", "cy25", "yem", "uy0", "wy17", "y03", "oy000", "yaddr", "cy255", "yeZero", "y180", "wy0", "oyZero", "nyfrom", "y047", "xyBeg", "nyZero", "ny180", "cyem", "t150", "nyaddr", "iyfrom", "fyBeg", "iystart", "xyZero", "yy0", "cy050", "y25", "wy00", "dy00", "ye0", "sy0", "wy03", "syZero", "syBeg", "yt0", "fyZero", "y2", "y255", "vyfrom", "dy0", "oyBeg", "ye050", "bit", "link0", "uy000", "fy0", "ry150", "link83", "y000", "yeElement", "iyaddr", "yyem", "ry050", "cy180", "uyZero", "ystart", "dyBeg", "linkem", "oy00", "xy047", "iy000", "yyElement", " y2", "Y0", "ny0", "ry0", "vy0", "ty03", "nystart", "cy0", "sy047", "py0", "w", "ny255", "cy2", "yeem"], "x": ["fx", "i", "column", "h", "xp", "l", "color", "ax", "dx", "time", "z", "ident", "tx", "lat", "xe", "px", "xc", "u", "ext", "xf", "xml", "xt", "p", "r", "m", "ux", "key", "rx", "xs", "xa", "name", "read", "xes", "im", "att", "chain", "e", "xy", "index", "xd", "inx", "path", "inner", "to", "at", "sw", "mx", "xi", "ex", "el", "ox", "ct", "axis", "X", "ix", "pt", "wx", "o", "v", "yx", "w", "xx", "on"], "y": ["wy", "i", "h", "ey", "ch", "py", "ye", "ly", "ady", "vy", "ty", "fy", "ies", "iy", "cy", "col", "dy", "yo", "yn", "hot", "uy", "sy", "icy", "ym", "b", "yer", "xy", "my", "ay", "j", "ny", "ya", "ys", "gy", "yl", "axy", "oy", "t", "yy", "yr", "hy", "Y", "ley", "sky", "yx", "yt"], "rlen": [" rsl", "rtfin", "rrlimit", "rclen", "rrcmp", "rlimit", "vld", "llen", "rrld", "nlen", "lval", "rgl", "ranklan", "rrln", " rlan", "rcmp", " rll", "dval", "rlvl", "qld", "qmem", "nrlen", "mrlen", " rmem", "rtcmp", "ranklvl", "rlin", "rtler", "rlength", "rtll", "rline", " rlimit", "ranklin", "vden", "rrlan", "rcler", "rrlen", "rtline", "rtgl", "nlan", "Rln", "ranklen", "rden", "llength", "rvals", "rln", "mrgl", "lvals", "rrmem", "pln", "rarlen", "nrlan", "psl", "rlan", " rcompl", "rtmem", "rtcompl", "vln", "rmem", "rcompl", "rarll", " rval", "qlen", "rtpl", "lline", "rtld", "dlength", "rll", "rrlin", "nrlvl", " rln", " rcmp", " rpl", "qpl", "Rsl", "rtden", "rsl", "rtlimit", " rld", "lfin", "mrden", " rvals", "rcden", "rrden", "rarval", "Rlen", " rfin", "rtlen", "rler", "plen", "rrlvl", "nval", "rval", "dlen", "rfin", "rcgl", "nln", "mrler", "Rmem", "nrlin", "dvals", " rden", "rld", "dln", "rarcompl", " rlength", "vlen", "dlan", "rtval", "pmem", "rpl", " rline"]}}
{"project": "qemu", "commit_id": "aea390e4be652d5b5457771d25eded0dba14fe37", "target": 0, "func": "static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,\n\n                                       target_ulong *pte1p,\n\n                                       int ret, int rw)\n\n{\n\n    int store = 0;\n\n\n\n    /* Update page flags */\n\n    if (!(*pte1p & HPTE64_R_R)) {\n\n        /* Update accessed flag */\n\n        *pte1p |= HPTE64_R_R;\n\n        store = 1;\n\n    }\n\n    if (!(*pte1p & HPTE64_R_C)) {\n\n        if (rw == 1 && ret == 0) {\n\n            /* Update changed flag */\n\n            *pte1p |= HPTE64_R_C;\n\n            store = 1;\n\n        } else {\n\n            /* Force page fault for first write access */\n\n            ctx->prot &= ~PAGE_WRITE;\n\n        }\n\n    }\n\n\n\n    return store;\n\n}\n", "idx": 15521, "substitutes": {"ctx": ["pkg", "context", "jp", "kw", "con", "req", "bc", "ck", "history", "tx", "tk", "ctrl", "buf", "cm", "xc", "cp", "c", "cu", "hw", "Context", "loc", "p", "mc", "jac", " context", "kh", "tc", "mem", "nt", "cc", "rc", "cv", "kt", "act", "cf", "conn", "ct", "ctr", " cx", "sc", "resp", "cmd", "obj", "iat"], "pte1p": ["ptetime128p", "ptpe1lp", "pter5pc", "pte191php", "pte1q", "pter1p", "pte191ip", "pte128php", "pte001lp", "pte2n", "ptetime1P", "pter1c", "pte0d", "pte1001lp", "pter5q", "pte1001pi", "pte01g", "ptpe1pp", "pte5c", "pter1pc", "ptoe0g", "pte41pi", "pte1ip", "pte1pc", "pte5pc", "ptoe1pc", "ptetime1ip", "pte001pi", "pte0p", "pte0pc", "pte191P", "ptpe1p", "ptoe1P", "pte4pc", "pte4p", "ptoe1g", "ptpe41p", "ptoe2P", "pte01p", "ptoe2p", "pte3p", "ptetime1php", "pte1lp", "ptoe1p", "pte41pp", "pte3d", "pte41p", "pte1g", "ptoe1d", "pte0P", "pte5q", "pte5ip", "pte1n", "pter1q", "ptoe0pc", "pte01pc", "ptpe41pi", "pte41lp", "pte1001pp", "pte4c", "pte1pp", "pte2P", "pte1php", "pte1P", "pter5p", "ptoe0p", "ptetime128php", "pte001p", "pte0n", "pte001pp", "pte3n", "pte1pi", "pte1d", "ptetime128ip", "pte1001p", "pte5P", "ptoe2n", "pte5php", "ptpe1pi", "pte4q", "pte1c", "pte128ip", "ptoe1n", "pte3pc", "pte2d", "pte128P", "pte191p", "pte3c", "pte3P", "pte3q", "ptpe41pp", "pte128p", "ptpe41lp", "ptetime1p", "pter5c", "pte5p", "ptoe2d", "ptetime128P", "pte0g", "pte2p", "pte3g"], "ret": ["ft", "ref", "RET", "nz", "tmp", "re", "reply", "etc", "Ret", "result", "rf", "cb", "rew", "def", "not", "desc", "ne", "read", "flag", "alt", "mem", "att", "nt", "des", "vt", "res", "conn", "rm", "ct", "mt", "gt", "rets", "resp", "rt", "pert", "lit", "cmd", "aux", "reset"], "rw": ["usr", "ft", "kw", "ard", "nz", "nw", "rb", "rf", "hw", "rew", "wp", "r", "urg", "rx", "writ", "mb", "rd", "wr", "rc", "rss", "rh", "nr", "wa", "rn", "sw", "wn", "sr", "iw", "dq", "RW", "shr", "aw", "vr", "write", "rt", "wx", "wb", "aux", "w", "rob"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,\n\n                           QEMUSGList *sg, uint64_t sector,\n\n                           void (*cb)(void *opaque, int ret), void *opaque)\n\n{\n\n    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,\n\n                       DMA_DIRECTION_TO_DEVICE);\n\n}\n", "idx": 15524, "substitutes": {"bs": ["bos", "bu", "fs", "sb", "bl", "bt", "bc", "bf", "blog", "bh", "bn", "ss", "bd", "es", "pb", "ls", "gs", "b", "its", "js", "lbs", "bb", "bis", "bas", "cks", "bps", "BS", "ds", "ns", "bp", "cs", "bits", "bi", "bg", "bm", "obs", "gb", "ba"], "sg": [" GS", "gb", "sol", "sb", "GS", "ag", "gm", "sch", "gu", "sv", "s", "yg", "vg", "si", "tg", "ssl", "sam", "gp", "cfg", "hs", "gs", "igm", "sa", "sbm", "ags", "rg", "g", "sd", "sq", "sr", " SG", "ds", "erg", "sels", "bg", "eas", "igs", "ss"], "sector": ["tor", "area", "address", "river", "sb", "sect", "ifer", "component", " sectors", "serial", "ection", " Sector", "ar", "ctors", " se", "sel", "er", "acker", "ector", "ser", "Section", "storage", "sec", "selection", "sa", "spec", " sec", "tier", "row", "vector", " scanner", " sensor", "se", "erial", "part", "section", "sea", " segment", "fat", "or", " section"], "cb": ["fp", "sb", "bc", "ck", "bf", "unc", "rb", "ctrl", "dc", "buf", "lb", "c", "cp", "pb", "cfg", "callback", "fb", "b", "db", "cc", "eb", "rc", "ctx", "fn", "bb", "cv", "fun", "cf", "erb", "nb", "func", "cmd", "cr", "CB", "cd", "gb"], "opaque": ["operacity", "ipaque", "popacity", "ipatile", "operque", "Opaco", " opaques", "operatile", "pacity", "Opacity", "popque", "pque", "operaque", "popatile", "opque", "popaque", "paque", "opacity", "opatile", " opacity", " opque", "opaques", "paco", "opaco", "ipacity", "paques", "ipque", "Opque", "Opaque", "operaco", "ipaques"]}}
{"project": "qemu", "commit_id": "b6d36def6d9e9fd187327182d0abafc9b7085d8f", "target": 0, "func": "static int discard_single_l2(BlockDriverState *bs, uint64_t offset,\n\n    unsigned int nb_clusters, enum qcow2_discard_type type, bool full_discard)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_l2_entry;\n\n\n\n        old_l2_entry = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /*\n\n         * If full_discard is false, make sure that a discarded area reads back\n\n         * as zeroes for v3 images (we cannot do it for v2 without actually\n\n         * writing a zero-filled buffer). We can skip the operation if the\n\n         * cluster is already marked as zero, or if it's unallocated and we\n\n         * don't have a backing file.\n\n         *\n\n         * TODO We might want to use bdrv_get_block_status(bs) here, but we're\n\n         * holding s->lock, so that doesn't work today.\n\n         *\n\n         * If full_discard is true, the sector should not read back as zeroes,\n\n         * but rather fall through to the backing file.\n\n         */\n\n        switch (qcow2_get_cluster_type(old_l2_entry)) {\n\n            case QCOW2_CLUSTER_UNALLOCATED:\n\n                if (full_discard || !bs->backing_hd) {\n\n                    continue;\n\n                }\n\n                break;\n\n\n\n            case QCOW2_CLUSTER_ZERO:\n\n                if (!full_discard) {\n\n                    continue;\n\n                }\n\n                break;\n\n\n\n            case QCOW2_CLUSTER_NORMAL:\n\n            case QCOW2_CLUSTER_COMPRESSED:\n\n                break;\n\n\n\n            default:\n\n                abort();\n\n        }\n\n\n\n        /* First remove L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (!full_discard && s->qcow_version >= 3) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        } else {\n\n            l2_table[l2_index + i] = cpu_to_be64(0);\n\n        }\n\n\n\n        /* Then decrease the refcount */\n\n        qcow2_free_any_clusters(bs, old_l2_entry, 1, type);\n\n    }\n\n\n\n    qcow2_cache_put(bs, s->l2_table_cache, (void **) &l2_table);\n\n\n\n    return nb_clusters;\n\n}\n", "idx": 15530, "substitutes": {"bs": ["bos", "fs", "ash", "ashes", "sb", "bytes", "aos", "bl", "ks", "bc", "bt", "ses", "blog", "os", "bes", "aus", "ubis", "hz", "bh", "outs", "pb", "ls", "vs", "hs", "aws", "ms", "gs", "b", "its", "js", "iss", "uts", "lbs", "sts", "asis", "bis", "boxes", "cks", "bps", "BS", "ds", "ubs", "bp", "cs", "ts", "bits", "obs", "ns", "banks", "ss"], "offset": ["ref", "prefix", "end", "address", "padding", "Offset", "off", "error", "os", "slot", "top", " offsets", "oid", "set", "zero", "start", "pos", "seek", "count", "slice", "block", "buffer", "pointer", "index", "attribute", "seed", "op", "size", "id", "at", "range", "lock", "o", "base", "location", "mask", "reset", "shift"], "nb_clusters": ["nb_plers", "nb_clocations", "nb___clusodes", "nb_clients", "nb_lusters", "nb_ploci", "nb_custers", "nb_custer", "nb_declodes", "nb_cliders", "nb_declocations", "nb_Clores", "nb_Clusters", "nb_clusosures", "nb_luster", "nb_splusters", "nb_collusters", "nb_cients", "nb_clers", "nb___cluster", "nb7clocations", "nb___clusters", "nb7blodes", "nb_pluster", "nb___clususter", "nb_plodes", "nb_clodes", "nb_slocations", "nb_declers", "nb_Closures", "nb7blusters", "nb_collores", "nb_slusters", "nb_colluster", "nb_plients", "nb_slodes", "nb_Cluster", "nb_slards", "nb_declusters", "nb_collers", "nb_plores", "nb7clards", "nb_blodes", "nb_blusters", "nb_declards", "nb_clores", "nb_declients", "nb7clusters", "nb___clusosures", "nb_collients", "nb_spluster", "nb_Cliders", "nb_cloci", "nb_blocations", "nb_cluster", "nb_loci", "nb_declores", "nb_plusters", "nb_clususters", "nb_Clodes", "nb_lients", "nb7blocations", "nb7blards", "nb_colliders", "nb_closures", "nb_blards", "nb7clodes", "nb___closures", "nb_clususter", "nb___clususters", "nb_clards", "nb_clusodes", "nb_plosures", "nb_splores", "nb_spliders", "nb___clodes", "nb_coci"], "type": ["kind", "info", " TYPE", " field", "pe", "ty", " how", "dt", "style", "out", "error", "state", " name", " change", " t", "Type", "set", "p", " event", "name", " Type", " format", "index", "ype", "to", " out", "unit", "size", " timeout", "range", " kind", " fmt", " tree", "t", " types", "test", "file", " pt", " size", "o", " error", "types", " other", " template", "TYPE", " ty"], "full_discard": ["full_regarded", "full_dcarded", "full_Discards", "full_decard", "full_continarded", "full_failal", "full_dcard", "full_iscard", "full_iscarding", "full_Discarded", "full_iscment", "full_failure", "full_decarded", "full_regard", "full_discarding", "full_iscarded", "full_discal", "full_cacheard", "full_discure", "full_Discause", "full_cacheards", "full_regrip", "full_failard", "full_cacheause", "full_continarding", "full_continrip", "full_continard", "full_dcure", "full_dcal", "full_discause", "full_discment", "full_regarding", "full_iscure", "full_iscards", "full_Discment", "full_discarded", "full_discrip", "full_discards", "full_failarded", "full_cachement", "full_decards", "full_decarding", "full_iscause", "full_iscal", "full_Discard", "full_Discrip", "full_Discarding"], "s": ["h", "rs", "sn", "sb", "serv", "sl", "ses", "S", "space", "http", "c", "sv", "ps", "p", "sys", "ess", "store", "ssl", "sam", "ls", "vs", "hs", "aws", "gs", "b", "ats", "its", "js", "sa", "ims", "sts", "bis", "less", "t", "ds", "cs", "ts", "is", "bits", "stats", "ins", "oss", "parts", "ns", "ss"], "l2_table": ["lopher_public", "l2_manager", "l2Ptab", "l2_try", "l2_tab", "l2_chain", "l3_tree", "l2_TABLE", "lopher_table", "l3_source", "l4_table", "lopher_TABLE", "l2_cache", "l102_trace", "l2Ptable", "l2_public", "l2Pchain", "lTwo_tab", "l2_term", "l4_TABLE", "l2_container", "l4_container", "l3_manager", "l2_tr", "l102_cache", "l102_table", "l2Ptr", "l2_entry", "l3_table", "l3_tab", "lTwo_tr", "lTwo_table", "lTwo_chain", "l2_trace", "l4_try", "l102_tab", "l3_TABLE", "l2_source", "l3_entry", "l3_cache", "l2_tree", "lopher_term"], "l2_index": ["l2_Index", "ltwo_loc", "l2_loc", "l1_num", "l10_error", "l2___error", "l2zindex", "l2___set", "l2_iter", "l2_start", "l3_start", "l2zIndex", "ltwo_index", "l10___set", "l2znode", "l10___list", "ltwo_root", "l2_set", "ltwo_iter", "ltwo_ind", "l2__index", "l2__Index", "l2_root", "ltwo_info", "l10___error", "l2zstart", "l2___index", "l2___list", "l3_index", "l10_index", "l2_list", "l2__pos", "l1_Index", "l2_error", "l1_pos", "l3_Index", "l2_node", "l3_node", "l2_data", "l2_ind", "l1_data", "l1_index", "l10_list", "l2_num", "l2_info", "l10_set", "l10___index", "ltwo_Index", "l2_pos"], "ret": ["uf", "ref", "RET", "elt", "last", "txt", "ber", "trust", "out", "re", "value", "Ret", "result", "ext", " RET", "prime", "def", "jump", "r", "err", "tf", "tr", "ry", "Return", "flag", "alt", "b", "nt", "count", "iter", "final", "len", "fi", "cont", "it", "res", "j", "limit", "red", "try", "utils", "gt", "mt", "t", "ter", "rets", "resp", "rt", "deg", "val", "print", "v", "lit", "aux", "reset", "rem"], "i": ["qi", "ind", "info", "l", "ai", "ii", "n", "gi", "io", "di", "x", "sim", "out", "cli", "ip", "ij", "c", " bi", "ti", "li", "hi", "u", "I", "ei", " j", " I", "si", "batch", "m", "ri", "key", "im", "multi", "e", "in", "fi", "instance", "index", "iu", "id", " ii", "it", "j", "me", "ci", "xi", "print", "ic", "ki", "phi", "zi", "span", "ix", "mi", "o", "is", "pi", "y", "v", "bi", "ini", "ui", "by", "uri", " ti"], "old_l2_entry": ["old_l3_record", "old_l2_row", "old_l1_word", "old_l2pword", "old_l1_row", "old_l2___key", "old_l3_field", "old_l3_Entry", "old_l2pentry", "old_l1_entry", "old_l2_word", "old_l1_key", "old_l2_key", "old_l1_Entry", "old_l2_system", "old_l2___row", "old_l2tentry", "old_l1_obj", "old_l3_entry", "old_l2tsystem", "old_l2___entry", "old_l3_key", "old_l2prow", "old_l3_system", "old_l2___record", "old_l2_Entry", "old_l2_field", "old_l3_row", "old_l2tfield", "old_l2_obj", "old_l2_record", "old_l2pEntry", "old_l2tEntry"]}}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int64_t qemu_archipelago_getlength(BlockDriverState *bs)\n\n{\n\n    int64_t ret;\n\n    BDRVArchipelagoState *s = bs->opaque;\n\n\n\n    ret = archipelago_volume_info(s);\n\n    return ret;\n\n}\n", "idx": 15534, "substitutes": {"bs": ["bos", "fs", "rs", "ashes", "sb", "aos", "bl", "ks", "bc", "ses", "bes", "aus", "ps", "sys", "vs", "hs", "ms", "gs", "b", "ats", "its", "iss", "js", "lbs", "sts", "sbm", "bis", "bps", "BS", "ds", "ubs", "bp", "cs", "ts", "qs", "bm", "obs", "ns", "ss"], "ret": ["uf", "usr", "ft", "RET", "elt", "opt", "nz", "lt", "txt", "out", "re", "rat", "Ret", "result", "oret", "pas", " RET", "urt", "xt", "err", "tr", "alt", "att", "rev", "nt", "ert", "fi", "cont", "it", "res", "limit", "rm", "mt", "gt", "t", "ll", "ter", "rets", " Ret", "ts", "pert", "rt", "val", "print", "lit", "rem"], "s": ["fs", "rs", "sb", "ses", "ies", "S", "als", "sv", "ps", " ss", "p", "sys", "es", "sam", "ls", "vs", "us", "gs", "ats", "b", "its", "js", "as", "sts", "sq", "less", "ys", "ds", "se", "cs", "ts", "is", "ins", "qs", "sis", "ns", "ss"]}}
{"project": "qemu", "commit_id": "47445c80fb57035331574ac1ac0bcee67fb84aeb", "target": 0, "func": "static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu,\n\n                                    sPAPRMachineState *spapr,\n\n                                    uint32_t token, uint32_t nargs,\n\n                                    target_ulong args, uint32_t nret,\n\n                                    target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    PCIDevice *pdev;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n    int ret;\n\n\n\n    if ((nargs != 4) || (nret != 1)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = rtas_ldq(args, 1);\n\n    addr = rtas_ld(args, 0);\n\n    option = rtas_ld(args, 3);\n\n\n\n    sphb = spapr_pci_find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    pdev = pci_find_device(PCI_HOST_BRIDGE(sphb)->bus,\n\n                           (addr >> 16) & 0xFF, (addr >> 8) & 0xFF);\n\n    if (!pdev || !object_dynamic_cast(OBJECT(pdev), \"vfio-pci\")) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_set_option) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_set_option(sphb, addr, option);\n\n    rtas_st(rets, 0, ret);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 15535, "substitutes": {"cpu": ["con", "pc", "gpu", "cli", "pu", "nu", " cp", "processor", "cp", "hw", "core", "cu", "np", "sys", "linux", "gp", "pai", "mem", "ctx", "gc", " proc", "conn", "proc", "CPU", "phys", "nc", "process", "cow"], "spapr": ["spapsr", "spaphrs", "apaprc", "spappr", " spapR", "spcaprs", "apappro", "spaprc", "apapprc", "spcapr", "spapsrs", "spapers", "spapero", "apapprs", "spapir", "spapprs", "spaprs", " spaprs", "spapsR", "apappr", "spapro", " spapir", "spaperc", "spaper", "spaphro", "apapro", "spcapR", "spcapir", "spapprc", "apaprs", "spapR", "apapr", "spappro", "spaphr", "spaphrc", "spapsir"], "token": ["prop", "opt", "tn", "secret", "node", "os", "random", "hat", "password", "arn", "root", "tree", "callback", "target", "alt", "Token", "field", "fn", "ok", "wt", "auth", "t", "ts", "ens", "rt", "oken", "call"], "nargs": ["numargs", "jarg", "nnarg", "nnargs", "jns", " narg", "nnrows", "nns", " nrets", "NArgs", " nrows", "narg", " nArgs", "numrets", "nArgs", "Narg", "jargs", "nnArgs", "numarg", " nns", "nrets", "nrows", "Nargs", "Nrows", "numns", "jrets"], "args": [" arguments", "arms", "limits", "ties", "GS", "settings", "keys", "terms", "flags", "ars", "ames", "amps", "reg", "words", "fields", "arr", "es", "atts", "bugs", "ls", "options", "xs", "aws", "ms", "gs", "names", "js", "uns", "ims", "ags", "vals", "rows", "values", "orders", "ys", "gets", "days", "css", "arg", "ds", "dates", "icks", "cs", "ts", "tests", "is", "cmd", "all", "stats", "qs", "parts", "ras", "Args", "ns", "params", "uments"], "nret": ["numreturn", "numres", "nreturn", "Nres", "tret", "Nrets", "trets", " nRet", "nres", " nres", "tRet", "Nret", " nalt", "nalt", " nrets", "nRet", "numrets", "Nalt", "numret", "NRet", "Nreturn", " nreturn", "nrets", "talt"], "rets": ["fs", "rs", "ids", "fts", "terms", "runs", "results", "als", "ets", "aus", "els", "ires", "outs", "fits", "ls", "aws", "urs", "gs", "events", "its", "uts", "des", "uns", "vals", "res", "rows", "values", "asts", "ints", "gets", "ds", "uds", "states", "ts", "ens", "ows", "qs", "ras", "ns", "lists", "tes", "sts"], "sphb": [" sphy", "skhba", "sPhB", "smphbar", "saphbar", "sphB", "sPhb", "sfxy", "ssophb", "spho", "ssopha", "sha", "sphiB", " sphub", "siphbb", "aspha", "sapha", "shb", "ssphb", "skhb", "ssphbe", "asphB", "ssophbb", "sophbb", " smphy", "sphy", "askhb", "sptb", "siphb", "smphc", "sphub", " sphB", " smphub", "askhbe", "sphbe", "sophB", "asphbb", "smphy", "sphic", "asphb", "smphB", " spho", "smphba", "shbb", "skhB", "sophba", "sspha", "asptb", " smpho", "spta", "askhba", "ssophbe", "smphbb", "skhbe", "sfxv", "asptba", "splo", "sPhub", "saphbb", " smphv", "smphub", " smphB", " sphv", "askhB", "saphy", "ssphbb", "asptbb", "saphbe", "saphb", "spha", "sphiub", "sipha", "sopha", "sfxb", "sptba", "sophbe", "sphv", "sptbb", "splb", "sophb", " sphc", "sphba", "shbe", " smphb", "sPhc", "sphbar", "sply", "sfxo", "sphib", "smphv", "sphibe", "asphba", " smphc", "smpho", "smpha", "sphiba", "sphbb", "aspta", "asphbe", "siphba", "splv", "sphc", " sphbar", "smphb"], "spc": ["ppci", "psc", " esppc", "Spct", "SpC", "sppc", " espcc", "peac", "specc", "apcc", "splce", " spl", "splac", " spac", "spcc", " spch", "pscc", "spl", "splch", "splc", "Spcc", " espc", "Spc", "apl", "psci", "ppct", "spac", " spce", "spch", " spct", "ppl", "spec", "pece", "apci", "pec", "appc", "ppcc", "spct", "spci", "speC", "spce", "ppC", "apc", "apct", "pech", "pspc", " espci", "ppc", "spC", "spect", " spci"], "pdev": ["pprof", "pedevice", " pdevice", "pedo", " pdo", "pcdev", "Pev", "mpev", "dprof", "pcDE", "lpdata", "pconn", "mdev", "pcconn", "mmy", " pmy", " pdem", "Pdem", "Pdevice", "dDE", "ddev", "padevice", "pdevice", "Pdev", "mpdevice", "pcdo", "pdata", " pdata", "lpdevice", "pdo", " pconn", "pcdevice", "lpmy", "padev", "pedev", "mpdem", "pDE", "lpdev", "paDE", " pev", "ddevice", "paprof", "mdevice", "mdata", "pev", "pmy", "pdem", "peconn", "pcprof", "mpdev"], "addr": ["bind", "usr", "ord", "ref", "rs", "address", "opt", "Address", "ident", "tx", "x", "off", "ress", "ip", "hash", "src", "ar", "hw", "adr", "alias", "ext", "loc", "oad", "arr", "err", "start", "ptr", "host", "add", "dr", "key", "port", "pos", "alt", "mem", "att", "rc", "len", "ctx", "eth", "ack", "id", "size", "url", "rn", "at", "ad", "act", "offset", " address", "coord", "order", "attr", "arg", "grad", "align", "ix", "pad", "cmd", "var", "arp", "obj"], "option": ["event", "type", "prop", " Option", "ption", "opt", "condition", " opt", "off", "error", "value", "slot", "ion", "offer", "weight", "alias", "tag", "key", "action", "options", "name", "alt", "field", "attribute", "index", "mode", "op", "Option", "description", "offset", "comment", "param", "mod", "arg", "attr", "tion", "section", "command", "term", "optional", "label", "operation"], "buid": ["BUuid", "buId", " buId", "suId", "cuid", "buID", "suID", "cuID", "suid", "guuid", "suuid", "BUids", " buids", "cuuid", "buuid", "guId", "BUID", "guid", "uuids", "buids", "uuid", "uuId", "BUId", "BUid", "guID", "cuId"], "ret": ["ft", "ref", "rs", "RET", "elt", "out", "re", "Ret", "result", " RET", "def", "set", "err", "ptr", "tr", "Return", "flag", "alt", "mem", "nt", "ert", "len", "fun", "it", "res", "back", "rm", "det", "mt", "gt", "arg", "t", " fut", "ts", "get", "resp", "rt", " Ret", "val", "print", "rem"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_acl_remove(qemu_acl *acl,\n\n                    const char *match)\n\n{\n\n    qemu_acl_entry *entry;\n\n    int i = 0;\n\n\n\n    TAILQ_FOREACH(entry, &acl->entries, next) {\n\n        i++;\n\n        if (strcmp(entry->match, match) == 0) {\n\n            TAILQ_REMOVE(&acl->entries, entry, next);\n\n            return i;\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 15537, "substitutes": {"acl": ["wl", "iam", "l", "abilities", "hip", "esi", "elt", "iana", "asc", "wal", "lc", "cas", "util", "compl", "ast", "etc", "las", "closure", "ifa", "aud", "ael", "kl", "client", "ma", "qa", "storage", "elist", "al", "arch", "lease", "load", "layout", "auth", "aci", "ity", "cl", "anc", "aco", "acs", "game", "rol", "fc", "aka", "ace", "ac", "policy", "scl", "co"], "match": ["equal", "ment", "search", "ATCH", "cache", "type", "address", "route", "atch", "replace", "word", "re", "hash", "cmp", "patch", "find", "force", "message", "filter", "check", "tag", "pre", "m", "key", "valid", "target", "field", "apply", "pattern", "rule", "path", "id", "lock", "like", "Match", "test", "link", "text", "mat", "length", "matched", "fire", "mask", "query"], "entry": ["event", "entity", "search", "view", "queue", "or", "term", "image", "component", "server", "word", "next", "connection", "escape", "byte", "q", "enter", "list", "key", "cell", "ent", "ry", "element", "name", "existent", "e", "nt", "member", "instance", "index", "import", "Entry", "ce", "it", "record", "line", "job", "inner", "ant", "item", "row", "ie", "inter", "comment", "try", "se", "link", "ace", "print", "table", "command", "obj", "form"], "i": ["ind", "d", "l", "info", "ai", "ii", "n", "k", "di", "sim", "x", "ij", "ip", "next", "iy", "c", "u", "li", "hi", "ei", "I", "p", "r", "si", "start", "m", "oi", "im", "multi", "count", "ims", "index", "iu", "id", " ii", "j", "ci", "xi", "phi", "zi", "ix", "mi", "is", "a", "pi", "v", "f", "ui", "ini", "y"]}}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void ac97_initfn (PCIDevice *dev)\n\n{\n\n    PCIAC97LinkState *d = DO_UPCAST (PCIAC97LinkState, dev, dev);\n\n    AC97LinkState *s = &d->ac97;\n\n    uint8_t *c = d->dev.config;\n\n\n\n    s->pci_dev = &d->dev;\n\n    pci_config_set_vendor_id (c, PCI_VENDOR_ID_INTEL); /* ro */\n\n    pci_config_set_device_id (c, PCI_DEVICE_ID_INTEL_82801AA_5); /* ro */\n\n\n\n    c[0x04] = 0x00;      /* pcicmd pci command rw, ro */\n\n    c[0x05] = 0x00;\n\n\n\n    c[0x06] = 0x80;      /* pcists pci status rwc, ro */\n\n    c[0x07] = 0x02;\n\n\n\n    c[0x08] = 0x01;      /* rid revision ro */\n\n    c[0x09] = 0x00;      /* pi programming interface ro */\n\n    pci_config_set_class (c, PCI_CLASS_MULTIMEDIA_AUDIO); /* ro */\n\n    c[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; /* headtyp header type ro */\n\n\n\n    c[0x10] = 0x01;      /* nabmar native audio mixer base\n\n                            address rw */\n\n    c[0x11] = 0x00;\n\n    c[0x12] = 0x00;\n\n    c[0x13] = 0x00;\n\n\n\n    c[0x14] = 0x01;      /* nabmbar native audio bus mastering\n\n                            base address rw */\n\n    c[0x15] = 0x00;\n\n    c[0x16] = 0x00;\n\n    c[0x17] = 0x00;\n\n\n\n    c[0x2c] = 0x86;      /* svid subsystem vendor id rwo */\n\n    c[0x2d] = 0x80;\n\n\n\n    c[0x2e] = 0x00;      /* sid subsystem id rwo */\n\n    c[0x2f] = 0x00;\n\n\n\n    c[0x3c] = 0x00;      /* intr_ln interrupt line rw */\n\n    c[0x3d] = 0x01;      /* intr_pn interrupt pin ro */\n\n\n\n    pci_register_bar (&d->dev, 0, 256 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    pci_register_bar (&d->dev, 1, 64 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    register_savevm (\"ac97\", 0, 2, ac97_save, ac97_load, s);\n\n    qemu_register_reset (ac97_on_reset, s);\n\n    AUD_register_card (\"ac97\", &s->card);\n\n    ac97_on_reset (s);\n\n}\n", "idx": 15549, "substitutes": {"dev": ["dn", "device", "ch", "av", "server", "devices", "develop", "mem", "des", "sd", "den", "debug", "adv", "vo", "h", "info", "prop", "end", "serv", "boot", "def", "store", "pro", "any", "env", "disk", "conn", "link", "ve", "app", "die", "serial", "off", "buf", "sys", "cam", "DE", "nt", "gen", "block", "de", "ev", "ad", "data", "det", "o", "a", "pp", "pub", "da", "dist", "dem", "DEV", "priv", "go", "reg", "hw", "ver", "p", "desc", "raw", "Device", "db", "Dev", "spec", "dd", "nav", "dis", "pad", "v", "obj", "w", "build"], "d": ["dn", "i", "dl", "ind", "dm", "n", "dx", "dt", "z", "di", "dc", "did", "dh", "bd", "p", "r", "m", "dr", "rd", "md", "pd", "e", "db", "b", "dd", "done", "de", "D", "j", "ad", "sd", "dq", "t", "ds", "dos", "du", "ld", "a", "v", "f", "w", "dat", "da"], "s": ["bs", "i", "h", "fs", "l", "rs", "sb", "n", "S", "os", "so", "sv", "ps", "ss", "st", "p", "sys", "es", "r", "m", "ls", "gs", "ats", "b", "js", "w", "g", "j", "sq", "t", "ds", "cs", "ts", "is", "source", "o", "a", "v", "y", "stats", "sis", "ns", "sts"], "c": ["abc", "h", "vc", "ch", "l", "con", "cache", "n", "xc", "pc", "bc", "content", "lc", "unc", "dc", "etc", "cm", "cp", "cb", "cu", "conf", "u", "loc", "p", "set", "r", "mc", "list", "m", "C", "b", "code", "tc", "cc", "rc", "chain", "e", "gc", "cv", "spec", "csv", "ce", "cont", "at", "cf", "cod", "arc", "ci", "ct", "enc", "ic", "ec", "t", "ca", "cs", "fc", "sc", "api", "o", "a", "nc", "all", "v", "f", "uc", "ac", "config", "call", "co"]}}
{"project": "FFmpeg", "commit_id": "68900bf16bb4dda35cf5f2801ce72c15056f1939", "target": 0, "func": "static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,\n\n                      const uint8_t **poutbuf, int *poutbuf_size,\n\n                      const uint8_t *buf, int buf_size)\n\n{\n\n    CookParseContext *s = s1->priv_data;\n\n\n\n    if (s->duration)\n\n        s1->duration = s->duration;\n\n    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)\n\n        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;\n\n\n\n    /* always return the full packet. this parser isn't doing any splitting or\n\n       combining, only setting packet duration */\n\n    *poutbuf      = buf;\n\n    *poutbuf_size = buf_size;\n\n    return buf_size;\n\n}\n", "idx": 15552, "substitutes": {"s1": ["ps5", " s01", "ts0", "ts1", "ts4", "s2", "s10", "s0", "ps1", "ns0", "ts10", "ss01", "ss2", "ss1", " s0", "s5", "ts2", " s4", "ps2", "ps01", " s2", "ss4", "s01", " s5", "ns1", "ns2", "s4", " s10", "ns10", "ts01"], "avctx": [" avjac", "averjac", "avetmp", " avcc", "varcv", "avepkg", "avtxt", "varpkg", "avertmp", "wavcontext", "afcontext", "avtx", " avct", "wavtxt", "avcontext", "avetxt", "aveca", "afctl", "wavct", "avpkg", " avcontext", "wavctl", "averctx", "avetx", " avctl", "avctl", "avecc", "aftx", " avtx", "wavctx", "avectx", "avecontext", "avercv", "avertx", "avectl", "wavconn", "avercc", "afctx", "afca", "avcv", "avconn", "wavpkg", " avtmp", "aveconn", " avca", " avpkg", "avcc", "avect", "avct", " avtxt", " avconn", "varjac", "averpkg", "varctx", "avjac", "avtmp", " avcv", "avca"], "poutbuf": ["poutqueue", "pinbuffer", "p_buf", "pOutbuff", "Poutbuf", "p_queue", "Poutqueue", "poutvec", "potvec", "pOutbuf", "pinqueue", "Pinvec", "Pinbuf", "p_buffer", "pOutbuffer", "pOutqueue", "Pinbuff", "pinbuff", "pinbuf", "poutbuff", "Poutbuff", "potqueue", "potbuf", "Pinbuffer", "potbuffer", "pOutvec", "pinvec", "poutbuffer", "p_buff", "Poutvec", "Pinqueue", "Poutbuffer"], "poutbuf_size": ["poutbuffer_size", "poutbuffer_fee", "poutbuf2Size", "poutbuffer_loss", "poutbuffer_len", "poutbuf2fee", "poutbuf2size", "poutbuffer_SIZE", "poutbuf2len", "poutbuf_len", "poutbuf_Size", "poutbuffer_count", "poutbuf_count", "poutbuf_loss", "poutbuffer_Size", "poutbuf_fee", "poutbuf_SIZE"], "buf": ["uf", "pkg", "queue", "ff", "cache", "bar", "xff", "tmp", "alloc", "br", "conv", "rb", "out", "Buff", "pool", "np", "offer", "cb", "bridge", "p", "foo", "vec", "batch", "pb", "raw", "buff", "bag", "mem", "b", "fb", "box", "db", "buffer", "block", "cv", "Buffer", "cap", "msg", "data", "seq", "func", "pipe", "cmd", "wb"], "buf_size": ["buf2len", " buf_SIZE", "queue_string", "buf_code", "buf__length", " buf_length", " buf2code", "queue_len", " buf2size", "buf2code", "buf__code", "buf_SIZE", " buf_code", "buf_string", " buf_len", "queue_size", " buf2len", "buf2length", " buf2length", "buf_len", "buf__size", "buf2size", "buf__len", "queue_SIZE", "buf_length", "buf2string", "buf2SIZE"], "s": ["bs", "h", "fs", "rs", "changes", "n", "local", "S", "os", "als", "ar", "c", "pers", "has", "eps", "ss", "ps", "p", "sys", "ess", "es", "m", "ls", "sports", "hs", "ms", "aws", "gs", "ats", "js", "as", "ims", "w", "g", "sq", "less", "gets", "ares", "ds", "self", "cs", "ts", "comments", "is", "ins", "qs", "scl", "ns", "tes", "sts"]}}
{"project": "FFmpeg", "commit_id": "2f4233614a7fbe176b81de0ef14bf38bad8e6693", "target": 0, "func": "static void add_codec(FFServerStream *stream, AVCodecContext *av,\n\n                      FFServerConfig *config)\n\n{\n\n    AVStream *st;\n\n    AVDictionary **opts, *recommended = NULL;\n\n    char *enc_config;\n\n\n\n    if(stream->nb_streams >= FF_ARRAY_ELEMS(stream->streams))\n\n        return;\n\n\n\n    opts = av->codec_type == AVMEDIA_TYPE_AUDIO ?\n\n           &config->audio_opts : &config->video_opts;\n\n    av_dict_copy(&recommended, *opts, 0);\n\n    av_opt_set_dict2(av->priv_data, opts, AV_OPT_SEARCH_CHILDREN);\n\n    av_opt_set_dict2(av, opts, AV_OPT_SEARCH_CHILDREN);\n\n    if (av_dict_count(*opts))\n\n        av_log(NULL, AV_LOG_WARNING,\n\n               \"Something is wrong, %d options are not set!\\n\", av_dict_count(*opts));\n\n\n\n    if (config->stream_use_defaults) {\n\n    //TODO: reident\n\n    /* compute default parameters */\n\n    switch(av->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        if (av->bit_rate == 0) {\n\n            av->bit_rate = 64000;\n\n            av_dict_set_int(&recommended, \"ab\", av->bit_rate, 0);\n\n        }\n\n        if (av->sample_rate == 0) {\n\n            av->sample_rate = 22050;\n\n            av_dict_set_int(&recommended, \"ar\", av->sample_rate, 0);\n\n        }\n\n        if (av->channels == 0) {\n\n            av->channels = 1;\n\n            av_dict_set_int(&recommended, \"ac\", av->channels, 0);\n\n        }\n\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        if (av->bit_rate == 0) {\n\n            av->bit_rate = 64000;\n\n            av_dict_set_int(&recommended, \"b\", av->bit_rate, 0);\n\n        }\n\n        if (av->time_base.num == 0){\n\n            av->time_base.den = 5;\n\n            av->time_base.num = 1;\n\n            av_dict_set(&recommended, \"time_base\", \"1/5\", 0);\n\n        }\n\n        if (av->width == 0 || av->height == 0) {\n\n            av->width = 160;\n\n            av->height = 128;\n\n            av_dict_set(&recommended, \"video_size\", \"160x128\", 0);\n\n        }\n\n        /* Bitrate tolerance is less for streaming */\n\n        if (av->bit_rate_tolerance == 0) {\n\n            av->bit_rate_tolerance = FFMAX(av->bit_rate / 4,\n\n                      (int64_t)av->bit_rate*av->time_base.num/av->time_base.den);\n\n            av_dict_set_int(&recommended, \"bt\", av->bit_rate_tolerance, 0);\n\n        }\n\n\n\n        if (!av->rc_eq) {\n\n            av->rc_eq = av_strdup(\"tex^qComp\");\n\n            av_dict_set(&recommended, \"rc_eq\", \"tex^qComp\", 0);\n\n        }\n\n        if (!av->rc_max_rate) {\n\n            av->rc_max_rate = av->bit_rate * 2;\n\n            av_dict_set_int(&recommended, \"maxrate\", av->rc_max_rate, 0);\n\n        }\n\n\n\n        if (av->rc_max_rate && !av->rc_buffer_size) {\n\n            av->rc_buffer_size = av->rc_max_rate;\n\n            av_dict_set_int(&recommended, \"bufsize\", av->rc_buffer_size, 0);\n\n        }\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    } else {\n\n        switch(av->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if (av->bit_rate == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"audio bit rate is not set\\n\");\n\n            if (av->sample_rate == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"audio sample rate is not set\\n\");\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (av->width == 0 || av->height == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"video size is not set\\n\");\n\n            break;\n\n        default:\n\n            av_assert0(0);\n\n        }\n\n    }\n\n\n\n    st = av_mallocz(sizeof(AVStream));\n\n    if (!st)\n\n        return;\n\n    av_dict_get_string(recommended, &enc_config, '=', ',');\n\n    av_dict_free(&recommended);\n\n    av_stream_set_recommended_encoder_configuration(st, enc_config);\n\n    st->codec = av;\n\n    stream->streams[stream->nb_streams++] = st;\n\n}\n", "idx": 15555, "substitutes": {"stream": ["context", "shape", "view", "channel", "tv", "version", "sl", "stack", "server", "out", "pool", "http", "src", "video", "ost", "client", "host", "ream", "console", "now", "read", "port", "window", "count", "network", "buffer", "REAM", "form", "ocr", "cf", "transform", "sw", "iterator", "row", "data", "driver", "sc", "metadata", "v", "table", "length", "Stream"], "av": ["pkg", "iam", "tv", "aver", "liv", "conv", "ap", "mem", "att", "wav", "cv", "ann", "sav", "craft", "ua", "fax", "ame", "ob", "man", "audio", "uf", "must", "apt", "aj", "am", "util", "sv", "img", "vp", "Av", "ah", "aut", "aval", "iv", "cap", "enc", "ave", "em", "van", "net", "vr", "au", "ab", "ee", "ai", "web", "aft", "comm", "aud", "uv", "cam", "imp", "com", "ev", "auth", "ka", "aw", "acc", "var", "aux", "iq", "AV", "aus", "hw", "ver", "us", "dev", "af", "um", "nav", "act", "ov", "aka", "ac", "v"], "config": ["context", "cal", "cache", "con", "fig", "settings", "bc", "server", "connection", "etc", "setup", "apache", "about", "c", "exec", "conf", "comm", "filter", "client", "args", "cfg", "desc", "support", "storage", "tc", "cc", "sec", "rc", "network", "ctx", "spec", "gc", "cont", "cf", "access", "auth", "cap", "conn", "unknown", "anc", "enc", "ct", "param", "ec", "control", "net", "crit", "fc", "acc", "lib", "program", "cmd", "Config", "man", "ac", "option", "command", "metadata"], "st": ["ST", "sn", "std", "St", "serv", "sl", "ast", "ist", "sv", "ste", "ost", "ust", "sam", "sp", "str", "sw", "fr", "est", "stage", "ct", "mt", "inst", " ST", "se", "sc", "rest", "irst", "sts"], "opts": ["Opams", "ioptx", "opcs", "optmitted", " copfs", "opms", "OPmitted", "Opt", " opms", "poprs", "opents", "OPrs", "oprs", " coprs", "otts", "opps", " optr", " opents", "OPals", "OPtr", "popats", "ioprs", " copts", "popt", " opt", " opte", "Opct", " opams", "popts", "optte", "otams", "OPt", "okts", " opmitted", "OPps", " opals", "Options", "opct", "opats", "OPct", "opmitted", "opt", "OPts", "opttr", "okms", "opfs", "options", "Opts", "optals", "optts", "Opcs", "OPte", " opfs", "optt", "Opls", "optx", "iopents", "oktx", " opats", " opct", "opls", "otls", "OPcs", "iopts", "ottions", " opcs", "optr", "opals", " options", " oprs", "opams", " opps", "iopats", " opls", "opte", "OPfs", "iopt", "iopms", "okents", " optx", " copps"], "recommended": ["comENDED", "suggestmented", "recommender", "comferred", "suspended", "friendened", "comending", "gemmented", "commended", "suggestented", "recommened", "suggestferred", "suspmented", "extended", "gemENDED", "commender", "virtualented", "optimends", "friendassed", "extened", "recommented", "suggestential", "gemened", "commmented", "replended", "recommculated", "gemender", "friendential", "comends", "comened", "suggestended", "virtualened", "recommassed", "recommENDED", "suspened", "challended", "suspadded", "challened", "recentend", "suggestender", "recentculated", "recommential", "recommferred", "optimened", "optimented", "recentended", "replends", "gemferred", "optimended", "comculated", "commened", "optimENDED", "suggestENDED", "recommending", "recentened", "suggestassed", "virtualENDED", "challassed", "virtualmented", "browseradded", "browsermented", "browserended", "recommend", "recommadded", "virtualadded", "comend", "replened", "gemended", "comended", "recommends", "friendended", "extculated", "recommmented", "virtualended", "replending", "suggestened", "challential", "optimending", "extend", "browserened"], "enc_config": ["ev_config", "enc_cfg", "ev_desc", "enc_desc", "ev_conf", "enc_conf", "ev_cfg"]}}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qmp_output_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    QObject *value = qmp_output_pop(qov);\n\n    assert(qobject_type(value) == QTYPE_QDICT);\n\n}\n", "idx": 15582, "substitutes": {"v": ["h", "i", "vc", "d", "l", "tv", "av", "n", "V", "conv", "x", "nv", "c", "q", "u", "sv", "p", "vim", "r", "uv", "m", "vs", "b", "vt", "vi", "cv", "g", "ev", "j", "iv", "qv", "ov", "t", "nov", "vv", "vr", "o", "inv", "f", "w", "vm"], "errp": ["erp", "rp", "rr", "errr", "errP", " errr", " errP", "err", "rP", "erP"], "qov": ["qOV", " qhov", "qaven", "dqov", "qova", " queryhov", "dqgov", "dqOV", "quaven", "sqov", "quOV", " qova", "sqOV", " queryova", " queryOV", "quov", "dqhov", " queryov", "dqova", "sqgov", "dqaven", " qOV", "sqaven", "qugov", "qgov", "qhov"], "value": ["version", "select", "bar", "image", "component", "hello", "json", "server", "null", "serial", "result", "create", "tree", "property", "language", "position", "key", "raw", "now", "Value", "ward", "field", "initial", "buffer", "remote", "total", "instance", "unit", "object", "attribute", "values", "VALUE", "item", "model", "unknown", "other", "widget", "val", "python"]}}
{"project": "FFmpeg", "commit_id": "ae4c9ddebc32eaacbd62681d776881e59ca6e6f7", "target": 1, "func": "void compute_images_mse_16bit(PSNRContext *s,\n\n                        const uint8_t *main_data[4], const int main_linesizes[4],\n\n                        const uint8_t *ref_data[4], const int ref_linesizes[4],\n\n                        int w, int h, double mse[4])\n\n{\n\n    int i, c, j;\n\n\n\n    for (c = 0; c < s->nb_components; c++) {\n\n        const int outw = s->planewidth[c];\n\n        const int outh = s->planeheight[c];\n\n        const uint16_t *main_line = (uint16_t *)main_data[c];\n\n        const uint16_t *ref_line = (uint16_t *)ref_data[c];\n\n        const int ref_linesize = ref_linesizes[c] / 2;\n\n        const int main_linesize = main_linesizes[c] / 2;\n\n        uint64_t m = 0;\n\n\n\n        for (i = 0; i < outh; i++) {\n\n            for (j = 0; j < outw; j++)\n\n                m += pow2(main_line[j] - ref_line[j]);\n\n            ref_line += ref_linesize;\n\n            main_line += main_linesize;\n\n        }\n\n        mse[c] = m / (double)(outw * outh);\n\n    }\n\n}\n", "idx": 15589, "substitutes": {"s": ["fs", "d", "rs", "n", "sb", "sl", "ses", "sim", "S", "os", "sv", "ps", "comm", "conf", "p", "set", "r", "an", "m", "sam", "hs", "gs", "b", "e", "ats", "js", "ims", "sts", "spec", "g", "sq", "sw", "less", "ex", "t", "span", "se", "cs", "ts", "sc", "a", "v", "f", "ins", "stats", "scl", "ns", "ss"], "main_data": [" main_device", "main__lines", "mainxdata", "mainxdevice", "ref__data", " main_dat", "ref__dat", "main_dat", "ref_dat", "mainitydata", "main__dat", "mainitydat", "main_DATA", "main_devices", "main__DATA", "ref_DATA", "mainxdevices", "mainmopdat", "mainmopdevices", " main_devices", "main__data", "mainxdat", "ref__DATA", "main_device", "ref__lines", "mainmopdata", "ref_lines", "mainitylines", "mainmopdevice", "mainityDATA", "main_lines"], "main_linesizes": ["main_pointsize", "main_lineize", "main_inesize", "main_linesizers", "main_lineizers", "main_pointsizes", "main_linesizations", "main_lineizes", "main_setsize", "main_inesizes", "main_setsizers", "main_inesizers", "main_inesizations", "main_setsizes", "main_linesize", "main_pointsizations", "main_setsizations", "main_pointsizers", "main_lineizations"], "ref_data": ["ref___data", "ref___table", "ref___bytes", "ref_dat", "reference_points", "reference_table", "alt_results", "reference_bytes", "ref___points", "alt_dat", "alt_data", "ref_table", "ref_points", "ref_bytes", "ref_results", "alt_table", "reference_data"], "ref_linesizes": ["ref_linesize", "ref_linsizes", "ref_linesights", "ref_linesizations", "ref_lineizers", "ref_lineize", "ref_inesights", "ref_linsize", "ref_linsights", "ref_inesizes", "ref_linsizations", "ref_inesizers", "ref_linesizers", "ref_lineizes", "ref_linizations", "ref_linizers", "ref_linizes", "ref_inesize", "ref_linize", "ref_linights", "ref_inesizations"], "w": ["wl", "l", "n", "nw", "win", "x", "wi", "hw", "wp", "wr", "W", "wa", "wt", "ew", "sw", "wid", "wn", "iw", "we", "fw", "aw", "rw", "v", "wh", "wd"], "h": ["ch", "l", "th", "k", "z", "how", "hw", "bh", "hi", "H", "gh", "height", "zh", "ish", "kh", "ho", "hl", "ih", "he", "oh", "o", "v", "high", "wh", "length", "hh", "ht"], "mse": ["mnsex", "mnae", "mze", " mze", "smge", "cmge", "smse", "mrsex", "mae", "cmse", " mae", "mrse", "cmze", " msem", "msem", "mge", " mge", "mnsem", " msex", "cmsem", "mrae", "msex", "smze", "smsem", "mnse", "mrsem"], "i": ["qi", "ind", "l", "ai", "ii", "n", "gi", "k", "z", "di", "x", "out", "ij", "ip", "u", "ti", "li", "hi", "I", "p", "ei", "r", "si", "m", "ia", "b", "multi", "im", "ami", "index", "iu", "id", "g", "at", "it", "ci", "ie", "xi", "ex", "ic", "ki", "t", "phi", "zi", "ix", "mi", "pi", "y", "v", "bi", "ini", "ui", "io"], "c": ["abc", "ch", "cache", "cor", "con", "category", "l", "n", "pc", "bc", "lc", "unc", "dc", "cy", "col", "cm", "cat", "ar", "xc", "cp", "cu", "conf", "u", "p", "mc", "r", "cam", "C", "tc", "e", "chain", "cc", "count", "rc", "ctx", "gc", "cv", "ce", "g", "cont", "cf", "coll", "cus", "ci", "ct", "\u00e7", "anc", "ec", "t", "ca", "cs", "fc", "sc", "nc", "uc", "ac", "cr", "v", "f", "cation", "cd", "co"], "j": ["ch", "ind", "jp", "l", "ge", "ji", "n", "aj", "k", "z", "json", "di", "br", "bj", "out", "ij", "jo", "q", "p", "jj", "r", "jump", "m", "oj", "key", "jac", "ne", "bo", "kh", "b", "e", "ja", "js", "ng", "xy", "note", "g", "it", "str", "je", "job", "uj", "dj", "jas", "kj", "J", "t", "jc", "ix", "pt", "kid", "o", "y", "v", "_", "obj", "jl", "jit"], "main_line": ["main_block", "main_Line", "ref_Line", "main_channel", "main_row", " main_Line", "main_lin", "ref_cell", "main_link", "main___lin", "ref_lin", "main_cell", "main___row", " main_block", "main___line", "main___Line", "ref_link", "ref_row", " main_channel"], "ref_line": ["ref___data", "rel_block", "orig_Line", "ref_Line", "rel___data", "rel_data", "ref___page", "orig_entry", " ref_page", "rel_page", "ref___block", "orig_line", "ref_entry", "ref_page", "rel___block", "rel___page", "ref___path", "orig_path", "ref___Line", "ref___entry", "ref_path", "ref_block", "rel_line", "rel___line", "ref___line"]}}
{"project": "qemu", "commit_id": "0dacea92d26c31d453c58de2e99c178fee554166", "target": 1, "func": "putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)\n\n{\n\n    uint32_t sum;\n\n\n\n    if (cse && cse < n)\n\n        n = cse + 1;\n\n    if (sloc < n-1) {\n\n        sum = net_checksum_add(n-css, data+css);\n\n        stw_be_p(data + sloc, net_checksum_finish(sum));\n\n    }\n\n}\n", "idx": 15594, "substitutes": {"sum": ["mean", "cal", "h", "cache", "ut", "am", "tu", "summary", "fac", "score", "sim", "cum", "hash", "cmp", "result", "ul", " summ", "si", "add", "sam", "us", "umm", "mem", "gam", "match", "count", "sa", "total", " Sum", "g", "um", " total", "Sum", "num", "mm", " num", "vol", "se", "aw", "acc", "mix", "v", "ass", "gram", "su", "alph", " summed", "ss"]}}
{"project": "qemu", "commit_id": "84aa07f109f0afaeeec63c159f3a578b955c3de9", "target": 0, "func": "uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,\n\n                       uint32_t r3)\n\n{\n\n    uintptr_t ra = GETPC();\n\n    uint64_t destlen = get_length(env, r1 + 1);\n\n    uint64_t dest = get_address(env, r1);\n\n    uint64_t srclen = get_length(env, r3 + 1);\n\n    uint64_t src = get_address(env, r3);\n\n    uint8_t pad = a2 & 0xff;\n\n    uint32_t cc = 0;\n\n\n\n    if (!(destlen || srclen)) {\n\n        return cc;\n\n    }\n\n\n\n    if (srclen > destlen) {\n\n        srclen = destlen;\n\n    }\n\n\n\n    for (; destlen || srclen; src++, dest++, destlen--, srclen--) {\n\n        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;\n\n        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;\n\n        if (v1 != v2) {\n\n            cc = (v1 < v2) ? 1 : 2;\n\n            break;\n\n        }\n\n    }\n\n\n\n    set_length(env, r1 + 1, destlen);\n\n    /* can't use srclen here, we trunc'ed it */\n\n    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);\n\n    set_address(env, r1, dest);\n\n    set_address(env, r3, src);\n\n\n\n    return cc;\n\n}\n", "idx": 15615, "substitutes": {"env": ["pkg", "outer", "esm", "server", "EN", "nv", "np", "cb", "eng", "org", "ptr", "et", "pg", "hl", "cv", "den", "ager", "esc", "vm", "event", "context", "worker", "info", "end", "sb", "dt", "stack", "here", "init", "er", "enter", "forge", "vp", "ah", "code", "rc", "erd", "eh", "vt", "era", "msg", "en", "conn", "enc", "net", "cmd", "req", "ve", "pe", "nw", "En", "buf", "err", "vs", "te", "console", "shell", "ev", "ew", "gate", "proc", "ec", "pp", "queue", "tx", "hw", "environment", "desc", "ner", "entry", "e", "dev", "window", "db", "estate", "ctx", "manager", "erb", "gear", "config", "v", "obj", "w"], "r1": ["rt0", "ar5", "r0", "mr4", " r01", "rc2", "ar01", "ar0", "r4", "R2", "R4", " r91", "mr01", "rt91", " r2", "r2", "ar7", "mr1", " r7", " r4", "R1", "mr3", " r5", "r5", "R7", "ar2", "r7", " r0", "r91", "rc3", "rc0", "rc5", "rt2", "rc1", "rc7", "rc01", "rc4", "ar1", "r01", "rt1", "rc91", "R01"], "a2": ["sha2", "w02", "w4", "tatwo", "wtwo", "c5", "ca2", "ca4", "ca5", "atwo", "aa2", "ta4", "aa02", "c2", "a02", "sha5", "aatwo", "a4", "ta2", "a5", "w2", "aa4", "sha4", "ta02", "c4"], "r3": [" r03", "r0", "r53", "prThree", " r43", "r03", "rc2", "rc03", "ar0", "rthree", "rThree", "nrUST", " rUST", " rThree", "R2", "r4", "r21", " r21", " rthree", "R5", " r30", "r43", "r2", " r2", "nr7", "ar3", " r7", " r4", "pr53", "rc21", "r6", " r5", "r5", "rcthree", "ar2", "rUST", "r7", " r0", "arThree", "rc30", "ar53", "rc53", "rc3", "rc0", "rc5", "usr7", "p3", "usr3", "nr4", "rc1", "rc7", "nr21", "rc6", "pr0", "nr03", " r6", "usr43", "pr3", "r30", "p1", "p30", "rc43", "usrthree", "rc4", "R6", "R3", "p5", "rcUST", " r53", "nr3"], "src": ["sing", "rel", "dist", "usr", "ource", "sn", "rs", "comp", "pri", "sb", "serv", "tmp", "sl", "trans", "ur", "rib", "rb", "via", "cur", "addr", "input", "st", "sel", "loc", "sub", "sys", "from", "ptr", "syn", "desc", "ser", "origin", "pos", "in", "sur", "rc", "iter", "tp", "sp", "rl", "supp", "iv", "sr", "proc", "inst", "ctr", "attr", "sc", "source", "rt", "rest", "ins", "rec", "stream", "rob"], "dest": ["rel", "dist", "usr", "prop", "end", "orig", "priv", "trans", "win", "out", "Dest", "addr", "result", "st", "pas", "del", "loc", "pl", "ptr", "tr", "desc", "origin", "ser", "port", "target", "pos", "dev", "home", "sur", "iter", "gen", " dst", "des", "sp", "decl", "dir", "cont", "dep", "sw", "data", "dis", "gt", "sc", "source", "master", "rest", "v", "est"], "destlen": ["Destl", "destelt", " destcoll", " destln", "destcoll", "estlength", "Desten", " destcompl", "disten", "srccompl", "sourcelength", " destlon", "DestLen", "estlen", "desclen", "devenc", "targetl", "distlength", "targeten", "destenc", " destlan", "srclength", "devl", "sourcelen", "srcl", "destLen", "targetLen", "targetlength", "estelt", " destl", " deststr", " destenc", " destlength", "desten", "estlan", "descln", "srcln", "descen", "descl", "targetcoll", "targetlen", "Destcompl", "estln", "Destlength", " desten", "desclon", "srcstr", "descelt", "destln", "Destlen", "srccoll", "destcompl", " destelt", "distlen", "destlan", "srclan", "targetstr", "devlen", "destlength", "distLen", "esten", "sourcelon", "destlon", "devln", " destLen", "destl", "descenc", "deststr", "estl", "srcLen", "desclength"], "srclen": ["srpleng", "slscleng", " srselower", "ctrclens", "ctrcilen", "srflener", "srcollog", "rncollar", "srchens", "srcloc", "srceloen", "srblim", "srcline", "rgcilen", "rnclen", "serclim", " srclower", "srchEN", "srplener", "rnclog", "rlchen", "rgcilener", "rnclar", "srchower", "srfcower", "srbline", "rncloen", "srclist", "srdeclim", "srcilens", " srselist", "srplog", "rgcleng", "srceleng", "srflog", "slcloc", " srclist", "rncolloen", "srcolene", "rlchoen", "srcilen", "ctrclen", "srdeclen", "srcollar", "srchen", "slclog", "serclen", "srsclog", "srsclen", "srClener", "srcolower", " srselen", "srselen", "srdeclene", "slsclen", "srclower", "srcilog", "ctrcilener", "srcolen", "srselist", "srblene", " srclEN", "srcellen", "srClens", "srClen", "srscleng", "srclEN", "srcelleng", "srcelen", "srselEN", "srcoline", "sercolen", "srdecline", "slcleng", "slscloc", "srplist", "slclen", " srselEN", "srcleng", "srclener", "rncollen", "rlclower", "rlchent", "sercolene", "srfcent", "srcolim", "rlcloen", "srcellog", "srcolloen", "srploen", "srcelog", "serclene", "sercoline", "srcelar", "rncollog", "srcilEN", "srplen", "srcelower", "srfcoen", "srflen", "srblen", "srcloen", "srClEN", "srplar", "srfcen", "srplEN", "srchoen", "srcolent", "srplower", "srcelloc", "srclent", "sercolim", "srcollen", "ctrcilEN", "ctrcilens", "sercline", "srselower", "ctrclener", "ctrclEN", "srcoloen", "rlclent", "rgclener", "rgclog", "srcelEN", "rgcileng", "rgclen", "srclene", "srscloc", "rgcilog", "srceloc", "rlclen", "rlchower", "srchener", "srcelist", "srclim", "srcileng", "srcilener", "srclog", "srclens", "slsclog", "srchent", "srclar", "srfleng"]}}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "void *bios_linker_loader_cleanup(GArray *linker)\n\n{\n\n    return g_array_free(linker, false);\n\n}\n", "idx": 15634, "substitutes": {"linker": ["linke", "streamor", "streamener", "inkler", "loader", " linkger", "inked", "streamer", "linkener", "linked", "loaded", " linked", "streamger", " linke", "inke", "inker", " linkor", "linkler", "inkener", "linkger", " linkler", "loade", " linkener", "inkger", "inkor", "linkor", "loadler"]}}
{"project": "qemu", "commit_id": "36778660d7fd0748a6129916e47ecedd67bdb758", "target": 0, "func": "const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,\n\n                                             hwaddr ptex, int n)\n\n{\n\n    ppc_hash_pte64_t *hptes = NULL;\n\n    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;\n\n\n\n    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {\n\n        /*\n\n         * HTAB is controlled by KVM. Fetch into temporary buffer\n\n         */\n\n        hptes = g_malloc(HASH_PTEG_SIZE_64);\n\n        kvmppc_read_hptes(hptes, ptex, n);\n\n    } else if (cpu->env.external_htab) {\n\n        /*\n\n         * HTAB is controlled by QEMU. Just point to the internally\n\n         * accessible PTEG.\n\n         */\n\n        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);\n\n    } else if (cpu->env.htab_base) {\n\n        hwaddr plen = n * HASH_PTE_SIZE_64;\n\n        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,\n\n                                 &plen, false);\n\n        if (plen < (n * HASH_PTE_SIZE_64)) {\n\n            hw_error(\"%s: Unable to map all requested HPTEs\\n\", __func__);\n\n        }\n\n    }\n\n    return hptes;\n\n}\n", "idx": 15644, "substitutes": {"cpu": ["pkg", "apache", "clock", "jp", "runner", "pc", "gpu", "aux", "component", "ck", "cli", "cum", "ruby", "aq", "thread", "pool", "pu", "nu", "np", "processor", "cp", "c", "cu", "core", "cn", "rpm", "pid", "hz", "sys", "ram", "machine", "p", "linux", "us", "bench", "gp", "pai", "ork", "boot", "parse", "tp", "ctx", "hw", "gc", "exec", "gnu", "nic", "php", "num", "lock", "conn", "anc", "proc", "upt", "CPU", "phys", "prof", "du", "nc", "phy", "rom", "sc", "cmd", "onet", "library", "sync", "process", "uu", "mu", "call", "execute"], "ptex": ["iptrx", "petex", "pointhex", "ptyrx", "eptex", " ptEX", " ptext", "iptEX", "pointex", "ptyEx", "ptext", "ptyex", "pointEX", "ptEX", "petexe", "iptEx", "ptxe", "pointEx", "petEX", "iptex", "eptxe", "eptexe", "eptEX", "iptext", "ptrx", "ptyEX", "pthex", "iptexe", "ptEx", " pthex", "iptxe", "ptexe", "petxe", "pointext", "pointrx", "ipthex"], "n": ["dn", "i", "d", "sn", "l", " N", "k", "nw", "nan", "nu", "number", "np", "nv", "c", "u", "cn", "p", "nm", "m", "mn", "ne", "N", "name", "b", "nt", "count", "ng", "note", "na", "nr", "ni", "g", "j", "nn", "num", "nor", "en", "ity", "nl", "nb", "t", "non", "net", "nc", "o", "y", "v", "w", "ns"], "hptes": ["hpointices", " hptises", "phptes", "hplises", "hpse", "hepointzes", " hmintves", "hpteps", " hptES", "hepointese", "hpredes", "phported", "hiptises", "hpeteps", "hapted", "htopes", "htopices", "hportves", "hpledes", "hples", "hepointes", "hportes", " haptes", "hiptis", "hptese", "haptes", " hpointis", "haptises", "hpted", "htopese", "hposves", "heptese", "hptices", "hmintES", "phpte", "hpetES", "hpointies", "haptedes", "hpointese", "hpointeps", "hposses", "hporties", "hcertzes", " haptedes", "hpointses", "hpres", "hportES", "phporte", "hpred", "hmintves", " hpete", "hportis", " hptves", " hmintES", " hptedes", "hportses", "hptedes", "phpted", "hiptses", "phptedes", " hptis", "hptves", "hapte", "hipties", "hpre", "hipte", " haptises", "hposES", "hpties", "hpete", " hmintses", "hepointices", "hpetes", "hposes", "hptzes", "hpte", "hptES", "hmintses", "hpointe", " hpteps", "hpointes", " hapte", " hmintes", "hcertes", " hpte", "hmintes", "htopzes", "hpsES", " hpeteps", "hcertese", "hiptes", "phportedes", " hpointes", "hporte", "hpseps", " hpetES", "hpointis", "hcertices", " hpointies", "hportedes", " hpetes", "hpointES", "heptes", " hpties", "hptis", "hpses", "hple", "hptses", "phportes", " hpointses", " hptses", "hiptedes", "hpointzes", "hported", "heptzes", "heptices", "hptises"]}}
{"project": "qemu", "commit_id": "ecf5e8eae8b0b5fa41f00b53d67747b42fd1b8b9", "target": 0, "func": "static inline bool regime_translation_disabled(CPUARMState *env,\n\n                                               ARMMMUIdx mmu_idx)\n\n{\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        switch (env->v7m.mpu_ctrl &\n\n                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK:\n\n            /* Enabled, but not for HardFault and NMI */\n\n            return mmu_idx == ARMMMUIdx_MNegPri ||\n\n                mmu_idx == ARMMMUIdx_MSNegPri;\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:\n\n            /* Enabled for all cases */\n\n            return false;\n\n        case 0:\n\n        default:\n\n            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but\n\n             * we warned about that in armv7m_nvic.c when the guest set it.\n\n             */\n\n            return true;\n\n        }\n\n    }\n\n\n\n    if (mmu_idx == ARMMMUIdx_S2NS) {\n\n        return (env->cp15.hcr_el2 & HCR_VM) == 0;\n\n    }\n\n    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;\n\n}\n", "idx": 15653, "substitutes": {"env": ["dn", "context", "worker", "end", "sb", "server", "here", "state", "nv", "cb", "eng", "er", "enter", "environment", "age", "forge", "def", "ei", "vs", "et", "vp", "ner", "te", "viron", "ah", "e", "dev", "window", "entry", "network", "pg", "erd", "estate", "eh", "cv", "ctx", "door", "ev", "manager", "ew", "engine", "sw", "era", "ten", "en", "ov", "ef", "ec", "esc", "em", "nc", "Environment", "config", "cmd", "v", "emb", "w", "up"], "mmu_idx": ["mmu_idxc", "mmu_pidx", "mmu_idew", "mmu_Idz", "mmu_inxc", "mmu_pidxc", "mmu_idw", "mmu_Idc", "mmu_wifeex", "mmu_Idxf", "mmu_Idp", "mmu_midX", "mmu_pidxf", "mmu_midex", "mmu_idxf", "mmu_midz", "mmu_idc", "mmu_Idw", "mmu_inxf", "mmu_Idxc", "mmu_inc", "mmu_wifeX", "mmu_inx", "mmu_Idx", "mmu_idz", "mmu_idp", "mmu_idex", "mmu_midxf", "mmu_midk", "mmu_midp", "mmu_idk", "mmu_idX", "mmu_midx", "mmu_wifek", "mmu_idez", "mmu_idexf", "mmu_wifex"]}}
{"project": "qemu", "commit_id": "2adba0a18a7950d14827e82d8068c1142ee87789", "target": 0, "func": "static void build_processor_devices(Aml *sb_scope, unsigned acpi_cpus,\n\n                                    AcpiCpuInfo *cpu, AcpiPmInfo *pm)\n\n{\n\n    int i;\n\n    Aml *dev;\n\n    Aml *crs;\n\n    Aml *pkg;\n\n    Aml *field;\n\n    Aml *ifctx;\n\n    Aml *method;\n\n\n\n    /* The current AML generator can cover the APIC ID range [0..255],\n\n     * inclusive, for VCPU hotplug. */\n\n    QEMU_BUILD_BUG_ON(ACPI_CPU_HOTPLUG_ID_LIMIT > 256);\n\n    g_assert(acpi_cpus <= ACPI_CPU_HOTPLUG_ID_LIMIT);\n\n\n\n    /* create PCI0.PRES device and its _CRS to reserve CPU hotplug MMIO */\n\n    dev = aml_device(\"PCI0.\" stringify(CPU_HOTPLUG_RESOURCE_DEVICE));\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A06\")));\n\n    aml_append(dev,\n\n        aml_name_decl(\"_UID\", aml_string(\"CPU Hotplug resources\"))\n\n    );\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->cpu_hp_io_base, pm->cpu_hp_io_base, 1,\n\n               pm->cpu_hp_io_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(sb_scope, dev);\n\n    /* declare CPU hotplug MMIO region and PRS field to access it */\n\n    aml_append(sb_scope, aml_operation_region(\n\n        \"PRST\", AML_SYSTEM_IO, aml_int(pm->cpu_hp_io_base), pm->cpu_hp_io_len));\n\n    field = aml_field(\"PRST\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n    aml_append(field, aml_named_field(\"PRS\", 256));\n\n    aml_append(sb_scope, field);\n\n\n\n    /* build Processor object for each processor */\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        dev = aml_processor(i, 0, 0, \"CP%.02X\", i);\n\n\n\n        method = aml_method(\"_MAT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call1(CPU_MAT_METHOD, aml_int(i))));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"_STA\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call1(CPU_STATUS_METHOD, aml_int(i))));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"_EJ0\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call2(CPU_EJECT_METHOD, aml_int(i), aml_arg(0)))\n\n        );\n\n        aml_append(dev, method);\n\n\n\n        aml_append(sb_scope, dev);\n\n    }\n\n\n\n    /* build this code:\n\n     *   Method(NTFY, 2) {If (LEqual(Arg0, 0x00)) {Notify(CP00, Arg1)} ...}\n\n     */\n\n    /* Arg0 = Processor ID = APIC ID */\n\n    method = aml_method(AML_NOTIFY_METHOD, 2, AML_NOTSERIALIZED);\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        ifctx = aml_if(aml_equal(aml_arg(0), aml_int(i)));\n\n        aml_append(ifctx,\n\n            aml_notify(aml_name(\"CP%.02X\", i), aml_arg(1))\n\n        );\n\n        aml_append(method, ifctx);\n\n    }\n\n    aml_append(sb_scope, method);\n\n\n\n    /* build \"Name(CPON, Package() { One, One, ..., Zero, Zero, ... })\"\n\n     *\n\n     * Note: The ability to create variable-sized packages was first\n\n     * introduced in ACPI 2.0. ACPI 1.0 only allowed fixed-size packages\n\n     * ith up to 255 elements. Windows guests up to win2k8 fail when\n\n     * VarPackageOp is used.\n\n     */\n\n    pkg = acpi_cpus <= 255 ? aml_package(acpi_cpus) :\n\n                             aml_varpackage(acpi_cpus);\n\n\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        uint8_t b = test_bit(i, cpu->found_cpus) ? 0x01 : 0x00;\n\n        aml_append(pkg, aml_int(b));\n\n    }\n\n    aml_append(sb_scope, aml_name_decl(CPU_ON_BITMAP, pkg));\n\n}\n", "idx": 15654, "substitutes": {"sb_scope": ["sblddevice", "sbpttrigger", "sbjscript", "lb_scope", "sbjScope", "sblyscope", "sg_Scope", "sg_style", "sb_script", "sg_scope", "sbldtrigger", "cb_buffer", "sblyproject", "sb_Scope", "sg_script", "SB_scope", "sbfscript", "cb_scope", "sblyScope", "sb_device", "sbptdevice", "sb_stack", "sb_root", "sbldbuffer", "sb__stack", "sbptscope", "sb_store", "sb__store", "sbjscope", "sb_buffer", "sbfstyle", "sb_project", "sbldscope", "lb_trigger", "sb__root", "sb_trigger", "SB_root", "sblybuffer", "SB_stack", "sbldScope", "cb_project", "SB_store", "sbfscope", "sb__scope", "sbjstyle", "sbldproject", "sbfScope", "cb_Scope", "sb_style", "lb_device"], "acpi_cpus": ["acpi_cpis", "acpi_processu", "acpi_capu", "acpi_caputes", "acpi_caps", "acpi_plu", "acpi_puores", "acpi_puus", "acpi_CPu", "acpi_processores", "acpi_CPis", "acpi_capis", "acpi_CPus", "acpi_cps", "acpi_cpins", "acpi_puu", "acpi_capus", "acpi_plins", "acpi_processut", "acpi_capins", "acpi_plutes", "acpi_cpu", "acpi_plus", "acpi_compus", "acpi_cput", "acpi_puut", "acpi_comps", "acpi_cpores", "acpi_compu", "acpi_cputes", "acpi_processus", "acpi_compis", "acpi_CPs"], "cpu": ["uu", "clock", "pc", "gpu", "cum", "pa", "util", "cmp", "pu", " cp", "processor", "cp", "pid", "core", "cu", "hw", "ram", "mem", "gc", "ci", "proc", "CPU", "prof", "uda", "phy", "pi", "process", "vm"], "pm": ["gem", "py", "dem", "dm", "am", "asm", "pc", "gm", "sim", "pa", "px", "pu", "cm", "rpm", "pid", "cp", "ps", "p", "wp", "ram", "m", "nm", "pb", "sam", "vp", "ym", "PM", "ms", "mp", "per", "prem", "mx", "rm", "mr", "mm", "mt", "po", "em", "prof", "tm", "pt", "pr", "mi", "pp", "pi", "vm", "hm", "perm", "ph", "master", "process", "bm"], "i": [" ki", " e", "gu", "r", " hi", " m", " ii", "it", "ci", "ex", " my", "ki", "zi", " mi", " iter", "mi", "y", " multi", " li", "ii", " si", " di", "init", "er", "hi", "mc", " pi", "m", "multi", "j", "xi", "t", "ix", "f", "ui", "ini", "qi", "ind", "l", "ai", "di", "x", "c", " bi", "ti", "li", "I", "si", "batch", "im", "in", "ims", "index", "o", "pi", "bi", "io", "n", "gi", " ni", "sim", " wi", "ip", "p", " j", " I", "e", " index", "iu", "id", "me", "ic", "v", " ti"], "dev": ["device", "av", "devices", "gu", "nv", "eng", "develop", "scan", "ach", "add", "push", "mem", "des", "stable", "dep", "sd", "debug", "adv", "info", "package", "util", "def", "tr", "pro", "name", "env", "res", "iv", "disk", "conn", "roll", "cmd", "hd", "ve", "ow", "app", "off", "serial", "DE", "nt", "index", "de", "ev", "data", "normal", "proc", "val", "pi", "var", "dem", "reader", "DEV", "priv", "go", "pu", "hw", "ver", "p", "tech", "handle", "raw", "Device", "md", "Dev", "spec", "dd", "cho", "row", "el", "attr", "api", "pad", "v", "w"], "crs": ["lcs", "CRS", "acps", "scs", "acrs", " crc", "acRS", " ccs", "Crd", "cps", "cws", "sres", "crc", " cres", " cws", "cRS", "lcRS", " cps", "acws", "ccs", "cres", "acrc", "sps", "lrs", "lrd", "Cres", "lcrs", "lcws", " cRS", "lRS", "Ccs", " crd", "srs", "lccs", "Cps", "accs", "crd", "lcrc", "lcps", "Crs"], "pkg": ["rel", "kind", "fp", "prefix", "req", "lp", "package", "tmp", "conv", "util", "buf", "kg", "cmp", "init", "cp", "sys", "pos", "db", "ctx", "spec", "ack", "dir", "module", "msg", "pod", "proc", "pack", "lib", "packages"], "field": ["uf", "ment", "ff", "info", "Field", "type", "kw", "prefix", "map", "term", "FIELD", "bf", "util", "input", "fields", "message", "def", "tag", "list", "add", "key", "name", "flag", "spec", "dd", "op", "fe", "lf", "offset", "lock", "row", "data", "comment", "arg", "attr", "handler", "file", "fc", "mount", "part", "link", "ld", " Field", "v", "table", "var", "f", "function", "form", "w", "label", "pair"], "ifctx": ["IFcontext", "ifconfig", "iffkw", "IFconfig", "Ifkw", "iffctx", "Ifcontext", "IFctx", "IFkw", "iffcontext", "ifkw", "Ifconfig", "Ifctx", "iffconfig", "ifcontext"], "method": ["package", "sim", "util", "cmp", "result", "service", "property", "message", "interface", "Method", "def", "m", "tr", "name", "mem", "md", "mp", "member", "eth", "spec", "path", "sp", "fd", "fun", "module", "manager", "hod", "access", "METHOD", "magic", "proc", "utils", "mm", "func", "attr", "handler", "tm", "mount", "metadata", "cmd", "function", "man", "table", "command", "sm", "f", "call", "profile"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    E1000State *s = opaque;\n\n    unsigned int index = (addr & 0x1ffff) >> 2;\n\n\n\n    if (index < NREADOPS && macreg_readops[index])\n\n    {\n\n        return macreg_readops[index](s, index);\n\n    }\n\n    DBGOUT(UNKNOWN, \"MMIO unknown read addr=0x%08x\\n\", index<<2);\n\n    return 0;\n\n}\n", "idx": 15655, "substitutes": {"s": ["i", "h", "fs", "rs", "n", "sb", "sl", "z", "S", "state", "c", "sv", "ps", "p", "set", "ess", "r", "es", "ms", "hs", "gs", "b", "e", "iss", "js", "g", "sq", "t", "ds", "ts", "o", "a", "is", "v", "stats", "f", "qs", "w", "ns", "ss"]}}
{"project": "qemu", "commit_id": "c7dfbf322595ded4e70b626bf83158a9f3807c6a", "target": 1, "func": "static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)\n\n{\n\n    uint32_t len;\n\n\n\n    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {\n\n        DPRINTF(s, 1,\n\n                \"usb-ccid: not sending apdu to client, no card connected\\n\");\n\n        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);\n\n        return;\n\n    }\n\n    len = le32_to_cpu(recv->hdr.dwLength);\n\n    DPRINTF(s, 1, \"%s: seq %d, len %d\\n\", __func__,\n\n                recv->hdr.bSeq, len);\n\n    ccid_add_pending_answer(s, (CCID_Header *)recv);\n\n    if (s->card) {\n\n        ccid_card_apdu_from_guest(s->card, recv->abData, len);\n\n    } else {\n\n        DPRINTF(s, D_WARN, \"warning: discarded apdu\\n\");\n\n    }\n\n}\n", "idx": 15664, "substitutes": {"s": ["bs", "details", "h", "aunts", "fs", "rs", "changes", "n", "sb", "settings", "z", "ses", "ies", "S", "os", "c", "sv", "has", "ps", "ss", "comm", "conf", "p", "sys", "es", "r", "ssl", "ls", "us", "sports", "hs", "ms", "aws", "gs", "ats", "common", "its", "js", "as", "ims", "sp", "spec", "bis", "sq", "sw", "t", "ds", "cs", "ts", "is", "source", "south", "sm", "stats", "qs", "sync", "ns", "sts"], "recv": [" recvd", "recordV", "recvr", "priv", "acceptq", "recmsg", "conv", "Recsv", "Recmsg", "Recvs", "formv", "rcV", " recV", "acceptV", " recvc", "convr", "recq", "acceptcv", " recq", "rcvr", "conq", "recordv", "recvd", " recmsg", "rcq", "formvr", "conmsg", "formvd", "rcvs", "recvc", "acceptv", " reccv", "recsv", "recordq", "rcvc", " recvs", " recsv", "primsg", "rccv", "rcsv", "priV", " recvr", "RecV", "reccv", "recvs", "recordsv", "Recvd", "privc", "Recv", "recV", "Recvr", "Recq", "rcv", "formsv", "rcmsg"], "len": ["lis", "l", "lp", "n", "elt", "bl", "sl", "Length", "lc", "oe", " l", "pl", "loc", "vec", " clen", "ls", " bl", "mn", " length", "pos", "mem", "ln", "nt", "js", "count", "lon", "ret", "lic", "fun", "size", "lf", "coll", "offset", "L", "num", "lim", "en", "msg", "seq", "fil", "el", "fl", "ec", "nl", "t", "ll", "il", "fin", "lib", "resp", "ld", "val", "lang", "Len", "length", "lan"]}}
{"project": "FFmpeg", "commit_id": "17dc7c7a60798d3e1f78bad97423fb49c8dc1c1d", "target": 0, "func": "void ff_h264_pred_init_x86(H264PredContext *h, int codec_id)\n\n{\n\n    mm_flags = mm_support();\n\n\n\n#if HAVE_YASM\n\n    if (mm_flags & FF_MM_MMX) {\n\n        h->pred16x16[VERT_PRED8x8] = ff_pred16x16_vertical_mmx;\n\n        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_mmx;\n\n        h->pred8x8  [VERT_PRED8x8] = ff_pred8x8_vertical_mmx;\n\n        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_mmx;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_tm_vp8_mmx;\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_mmx;\n\n            h->pred4x4  [TM_VP8_PRED  ] = ff_pred4x4_tm_vp8_mmx;\n\n        }\n\n    }\n\n\n\n    if (mm_flags & FF_MM_MMX2) {\n\n        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_mmxext;\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_mmxext;\n\n        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_mmxext;\n\n        h->pred4x4  [DC_PRED     ] = ff_pred4x4_dc_mmxext;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_tm_vp8_mmxext;\n\n            h->pred8x8  [DC_PRED8x8   ] = ff_pred8x8_dc_rv40_mmxext;\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_mmxext;\n\n            h->pred4x4  [TM_VP8_PRED  ] = ff_pred4x4_tm_vp8_mmxext;\n\n            h->pred4x4  [VERT_PRED    ] = ff_pred4x4_vertical_vp8_mmxext;\n\n        }\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSE) {\n\n        h->pred16x16[VERT_PRED8x8] = ff_pred16x16_vertical_sse;\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_sse;\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSE2) {\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_sse2;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_tm_vp8_sse2;\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_sse2;\n\n        }\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSSE3) {\n\n        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_ssse3;\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_ssse3;\n\n        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_ssse3;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_ssse3;\n\n            h->pred4x4  [TM_VP8_PRED  ] = ff_pred4x4_tm_vp8_ssse3;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 15679, "substitutes": {"h": ["event", "ch", "cache", "l", "info", "hd", "th", "ow", "z", "header", "history", "go", "br", "hash", "x", "http", "c", "bh", "dh", "hw", "comm", "q", "H", "p", "u", "er", "host", "m", "hr", "dr", "console", "hs", "kh", "ah", "mem", "window", "hz", "he", "hl", "eh", "ih", "w", "rh", "each", "g", "html", "sh", "it", "hp", "help", "sw", "php", "uh", "oh", "ssh", "head", "hm", "pp", "v", "ph", "y", "hh", "ht"], "codec_id": ["codecEid", "codecOdir", "codcam_dir", "codec_ids", "codec__ID", "codisc_type", "codec_ID", "codec_init", "codecixid", "codec3vid", "codec_vid", "codec__id", "codec__type", "codec2id", "codcamOkid", "codec_type", "codec__ids", "codcam_kid", "codect_source", "codecixhash", "codisc_id", "codect_id", "codecixkid", "codec_hash", "codecixdir", "codisc_ID", "codec_kid", "codec2ids", "codcam_id", "codec_dir", "codect_vid", "codecOhash", "codecEdir", "codcam_hash", "codec3init", "codecEkid", "codecNamevid", "codecNameinit", "codecOkid", "codecNamesource", "codecOid", "codec2ID", "codisc_ids", "codect_init", "codcamOdir", "codcamOid", "codec3source", "codecEhash", "codec_source", "codecNameid", "codcamOhash", "codec2type", "codec3id"]}}
{"project": "qemu", "commit_id": "c7e35da348e2e4df072e6979c48fa5283e07d1db", "target": 1, "func": "static inline abi_long target_to_host_timespec(struct timespec *host_ts,\n\n                                               abi_ulong target_addr)\n\n{\n\n    struct target_timespec *target_ts;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))\n\n        return -TARGET_EFAULT;\n\n    host_ts->tv_sec = tswapal(target_ts->tv_sec);\n\n    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);\n\n    unlock_user_struct(target_ts, target_addr, 0);\n\n    return 0;\n\n}\n", "idx": 15690, "substitutes": {"host_ts": ["hostTheps", "consoleTheps", "hostptms", " host_sts", "console_ps", "consoleTheptr", "consoleThets", "host_tes", "host_ps", " host_times", " host_tes", "consoleThett", "hostpttes", " host_tt", "host_ptr", "hostptts", "console_ts", "console_tt", " host_ms", "host_sts", "console_ptr", "host_tt", "host_times", "hostThett", "hostptsts", "hostTheptr", " host_ptr", "hostThets", "host_ms"], "target_addr": ["target_ptr", "target__addr", "target_address", " target_mt", "target__cb", " target_adr", " target_ad", "target_mt", "target__ptr", "target_adr", "target_ad", "target_cb", " target_address", " target_cb", " target_ptr", "target__address"], "target_ts": ["target_uts", "arget_ts", "host_cs", "host_ps", "arget____tp", "host_ptr", "targetThetp", "target____tim", "target_ss", "arget____tim", "arget_sta", "arget_tp", "target____ts", "target_mt", "target_times", "targetThets", "targetThetis", "host_ats", "target_tes", "target_ats", "arget____ts", "target_tis", "targetThetim", "target_tp", "target_sta", "target_ps", "arget_ss", "host_tes", "arget_tim", "host_mt", "target_ptr", "target_cs", "host_uts", "target____tp", "arget____tis", "host_times", "target_tim", "target____tis", "arget_tis"]}}
{"project": "qemu", "commit_id": "5039d6e23586fe6bbedc5e4fe302b48a66890ade", "target": 0, "func": "void DMA_init(int high_page_enable, qemu_irq *cpu_request_exit)\n\n{\n\n}\n", "idx": 15696, "substitutes": {"high_page_enable": [" cpu_memory_start", " cpu_memory_enabled", " cpu_page_disable", " cpu_memory_enable", " cpu_page_enable", " cpu_page_start", " cpu_page_enabled", " cpu_memory_disable"], "cpu_request_exit": ["cpu_requestlyexit", "cpu_request_enable", "cpu_request_start", "cpu_request_limit", "cpu_page_start", "cpu_page_limit", "cpu_page_enable", "cpu_requestlyenable", "cpu_requestlystart", "cpu_requestlylimit", "cpu_page_exit"]}}
{"project": "FFmpeg", "commit_id": "51a1c1c6ac98d1d0d0a654f066782707af092fed", "target": 0, "func": "static void decode_delta_l(uint8_t *dst,\n\n                           const uint8_t *buf, const uint8_t *buf_end,\n\n                           int w, int flag, int bpp, int dst_size)\n\n{\n\n    GetByteContext off0, off1, dgb, ogb;\n\n    PutByteContext pb;\n\n    unsigned poff0, poff1;\n\n    int i, k, dstpitch;\n\n    int planepitch_byte = (w + 7) / 8;\n\n    int planepitch = ((w + 15) / 16) * 2;\n\n    int pitch = planepitch * bpp;\n\n\n\n    if (buf_end - buf <= 64)\n\n        return;\n\n\n\n    bytestream2_init(&off0, buf, buf_end - buf);\n\n    bytestream2_init(&off1, buf + 32, buf_end - (buf + 32));\n\n    bytestream2_init_writer(&pb, dst, dst_size);\n\n\n\n    dstpitch = flag ? (((w + 7) / 8) * bpp): 2;\n\n\n\n    for (k = 0; k < bpp; k++) {\n\n        poff0 = bytestream2_get_be32(&off0);\n\n        poff1 = bytestream2_get_be32(&off1);\n\n\n\n        if (!poff0)\n\n            continue;\n\n\n\n        if (2LL * poff0 >= buf_end - buf)\n\n            return;\n\n\n\n        if (2LL * poff1 >= buf_end - buf)\n\n            return;\n\n\n\n        bytestream2_init(&dgb, buf + 2 * poff0, buf_end - (buf + 2 * poff0));\n\n        bytestream2_init(&ogb, buf + 2 * poff1, buf_end - (buf + 2 * poff1));\n\n\n\n        while ((bytestream2_peek_be16(&ogb)) != 0xFFFF) {\n\n            uint32_t offset = bytestream2_get_be16(&ogb);\n\n            int16_t cnt = bytestream2_get_be16(&ogb);\n\n            uint16_t data;\n\n\n\n            offset = ((2 * offset) / planepitch_byte) * pitch + ((2 * offset) % planepitch_byte) + k * planepitch;\n\n            if (cnt < 0) {\n\n                bytestream2_seek_p(&pb, offset, SEEK_SET);\n\n                cnt = -cnt;\n\n                data = bytestream2_get_be16(&dgb);\n\n                for (i = 0; i < cnt; i++) {\n\n                    bytestream2_put_be16(&pb, data);\n\n                    bytestream2_skip_p(&pb, dstpitch - 2);\n\n                }\n\n            } else {\n\n                bytestream2_seek_p(&pb, offset, SEEK_SET);\n\n                for (i = 0; i < cnt; i++) {\n\n                    data = bytestream2_get_be16(&dgb);\n\n                    bytestream2_put_be16(&pb, data);\n\n                    bytestream2_skip_p(&pb, dstpitch - 2);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 15723, "substitutes": {"dst": ["dndest", "dsts", "lst", "ldest", "Dost", "sdost", "Dst", " ddest", "dost", "ddest", "sddest", "Ddest", "Dsrc", "dsrc", "sdsts", "lust", " dsts", "Dsts", "dnsrc", "Dust", "dust", "dnust", " dost", "lsrc", "dnst", "sdst"], "buf": ["pkg", "orig", "bl", "gz", "pool", "np", "cp", "cb", "ptr", "pos", "mem", "fb", "pg", "hl", "cv", "Buffer", "pt", "text", "que", "uf", "h", "end", "tmp", "txt", "br", "temp", "Buff", "vec", "img", "good", "buffer", "uffy", "limit", "cap", "msg", "broad", "nb", "bp", "phy", "rw", "cmd", "length", "doc", "req", "bytes", "bf", "rb", "off", "src", "arr", "err", "uv", "batch", "cam", "block", "max", "seq", "fl", "deg", "queue", "ff", "ref", "fp", "cur", "nm", "bound", "desc", "MAX", "raw", "buff", "port", "b", "window", "db", "box", "dev", "iter", "um", "act", "lim", "bin", "aka", "v", "wb"], "buf_end": ["fb_close", "fb_end", "uf_size", "uf_start", "buf_size", "buffer_END", "buf_END", " buf0ended", "buf_ended", "buf00after", "buf_off", "fb_ended", "uf_after", "buf_ends", "buf_stop", "buf0end", " buf_ends", " buf_ended", "buffer_end", "buf00END", " buf_END", "cmd_end", "cmd_ending", " buf0end", "uf_END", "buffer_start", "uf_off", "buf_ender", "cmd_END", "buf00off", "cmd_start", "buf0END", "fb_END", "buf0ended", "buf_after", "uf_ender", "buf0ends", "uf_stop", "uf_end", " buf0ends", "buf_start", " buf0END", "buffer_size", "buf_close", "buf00end", "buf_ending"], "w": ["wind", "wl", "h", "d", "kw", "win", "wal", "word", "x", "out", "c", "q", "hw", "weight", "p", "wp", "r", "m", "wr", "window", "W", "wa", "wt", "ew", "sw", "iw", "t", "we", "fw", "aw", "rw", "wx", "wcs", "v", "wb", "wh", "wd"], "flag": ["sign", "type", "ag", "status", "flags", "bf", "FLAG", "weight", "age", "p", "set", "tag", "valid", "flow", "count", "fi", "lv", "af", "gc", "done", "bit", "act", "offset", "lock", "enable", "fl", "Flag", "bug", "leaf", "fc", "link", "cond", "cmd", "f", "command", "lag", "sync", "needed", "agged"], "bpp": ["bipp", "bcpp", "Bsupp", "bpcp", "bsupp", "rbcp", "bff", " bcp", "biscp", "bbPP", "biPP", "bbpp", "nbsupp", "bppl", "bbff", " bps", "bpPP", " bPP", "bips", "BPP", "bpl", "bismp", "nbff", " bpl", "bppp", "bmp", "nbps", "bpc", "Bpl", "nbPP", "Bcp", "bispp", "rbpp", "bicpp", "bPP", "bps", "rbpc", "Bpp", " bcpp", " bpc", "Bff", "bcp", " bmp", "nbpp", "bispc", "rbmp", "bbsupp", "nbcpp"], "dst_size": ["dstnetize", "dstnetsum", "dst_ize", "dest_ize", "dstnetsize", "dest_size", "dstnetSize", "dst_Size", "dest_sum", "dst_sum", "dest_Size"], "off0": ["off5", "ext1", "Offi", "offer0", "offerzero", " off5", "offer5", "Offzero", "Off1", " offzero", "Off5", "exti", "ext0", "offi", "Off0", "offzero", " offi", "offer1"], "off1": ["offer0", "offset1", "on0", "offset2", "Off2", "OffOne", "Off1", "Off4", "off4", "offOne", "offset4", "offerOne", " offOne", "off2", " off4", "offset0", "on1", "Off0", " off2", "offer1", "offer2", "on2", "onOne"], "dgb": ["Dgb", "bdgt", " dgt", "dgt", "sdgb", "rgd", "dgg", "sdgt", "sdgc", "rgb", "sdbg", "sdgg", "Dbg", "dgd", " dgd", "dgc", "bdgc", "bdgb", "rbg", "dbg", " dgc", "rgg", "Dgg", "sdgd", "bdgd", "Dgd"], "ogb": ["ighb", "obbe", "obc", "obl", "gobbe", "logd", "obd", "OGbl", "ogbl", "ogd", "ugbc", "ogl", "obt", "logbb", "ighbl", "logt", "ugl", "OGbase", "gobb", "ggc", "gobd", "oadbe", "oadb", "ocbb", "ighbe", "ogsbe", "ogsl", "ggl", "obb", "ojbe", "ugbe", "obbb", "ojbc", "ogbb", "ogbc", "OGbe", "ogbase", "logb", "gobbc", "obbc", "ogsb", "ggb", "ogsc", "oadbl", "ocbe", "ighbase", "oadbase", "ocbc", "ggbe", "ocl", "ojl", "OGb", "ocb", "ogt", "ojb", "ugb", "ocd", "ogbe", "ogc"], "pb": ["uf", "jp", "fp", "lp", "sb", "pc", "tmp", "dp", "bf", "tk", "xb", "bj", "rb", "pool", "np", "lb", "cp", "bh", "cb", "p", "wp", "vp", "buff", "b", "tc", "pd", "tp", "pg", "mp", "ctx", "bb", "PB", "pak", "nb", "bp", "wb", "td"], "poff0": ["paoff9", "pond047", "padon9", "pond0", "poffset8", "ponent0", "pOffNo", "poffset4", "pOff1", "pend9", "poff047", "bonentNo", "ponent08", "pdon02", "pond08", "pnot0", "pOff4", "pOff_", "pdefNo", "ponent047", "boffNo", " poffn", " poff8", "pdef4", "pdesNo", " pOff1", "pom08", "poff9", "pom0", "bonent08", " patt0", " poffsetNo", "poff02", " pOff8", "pdes1", "pnot1", "paoff0", " poff4", "pdef0", "bonent0", " pOff4", "poffNo", "poffset1", "padon0", " pOffNo", "pend00", "pOff0", "poff00", " pOff_", "boff047", "padon02", "pdes4", "bonent047", "pdon00", "poff8", "pondNo", "poffset_", " poffset1", "pnotn", "patt1", "pend02", "poa0", "pdes0", "poffsetNo", " pattn", "poa02", " poffset4", "poff_", "pattn", "pom047", "pdef1", "poa00", "pdon0", "pomNo", "poffn", "ponentNo", "paoff00", "pend0", " poffNo", "padon00", "boff08", "patt0", "poa9", "poff08", "boff0", "paoff02", " poffset0", " poff_", "poff4", "pdon9", " pOff0", "poffset0", " patt1", "pOff8"], "poff1": ["poff512", " pobj1", "poff3", "pon1", "pod1", "poffOne", "pon0", "pserverOne", "poaone", "tpoffer2", "poff11", " pobjn", "opoa1", "peoff3", "pon01", "pehead0", "pof1", "phead1", "poffer1", "ponOne", "pof0", "pehead3", "tpoff2", "moff01", "phead0", "poffsetn", " poffn", "pserverone", "ponn", "poffsetone", "tpoff001", "opoaone", "pon001", "opoffG", "pobj0", "peheadOne", " pobj11", "opoaOne", "tpoff1", "poffer001", " pobj0", "poffsetG", "peoffOne", "poaOne", "opoaG", "pobj1", "poa1", "poffset1", "moffOne", "poffer512", "pobj11", "poffset01", "pon11", "moff1", "peoff1", "poffset11", "moffsetOne", "pserverG", "pdev2", "pdev1", "tpoffer1", "poffer2", "pofOne", "opoff1", "pdev512", "pdev001", "pod0", "poaG", "pod01", "phead3", "pehead1", "moffset0", "poffn", "opoffone", "podOne", "poffsetOne", "pobjn", "moffset1", "poff2", "pof3", "tpoffer512", "opoffOne", "pheadOne", "poffG", "pon2", "tpoff512", "peoff0", "poffone", "pon512", "poff001", "pserver1", "moff0", "poff01", "tpoffer001", "poffset0", "moffset01", " poff11"], "i": ["d", "l", "info", "ii", "n", "z", "x", "ip", "c", "q", "I", "p", " j", "m", "in", "id", "it", "j", "ci", "t", "ix", "mi", "o", "pi", "v", "y", "f"], "k": ["kind", "ch", "kw", "n", "kn", "ku", "ko", "ks", "isk", "ck", "z", "tk", "x", "wk", "ikk", "c", "q", "ask", "p", "jj", "kl", "m", "key", "kk", "mk", "kh", "b", "kick", "sk", "ijk", "ok", "g", "uk", "j", "num", "ka", "kj", "ke", "km", "ik", "ek", "t", "ak", "work", "acc", "kid", "o", "K", "kan", "v", "unk", "kr"], "dstpitch": ["ddestppitched", "drestppitches", "dstPulse", "dstcpitch", "drestpitches", "dstcpip", "drestppulse", "dstcphop", "dstppitches", "dstepip", "dstppulse", "dstPitch", "drestppitch", "ddestpitch", "ddestphop", "ddestppip", "dstopitches", "drestppitched", "dstppitch", "ddestppitch", "dstpphop", "dstopitch", "dstpitched", "dstPitches", "ddestpip", "dstpip", "dstppitched", "dstpitches", "drestpitched", "dstopitched", "ddestpitched", "dstpulse", "ddestpphop", "drestpulse", "dstppip", "drestpitch", "dstephop", "dstcpitched", "dstopulse", "dstPitched", "dstepitch", "dstepitched", "dstphop"], "data": ["rel", "type", "extra", "Data", "DATA", "value", "next", "ata", "batch", "key", "raw", "pos", "buffer", "final", "no", "offset", "amount", "bin", "step", "coord", "pad", "val", "text", "area", "stream", "shift"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xff);\n\n}\n", "idx": 15728, "substitutes": {"opaque": ["Opus", "boaque", "boade", "mopus", " opade", "mopaque", "Opane", "opus", " oplay", "bolay", "mopque", "opane", "boque", "mopane", " opus", "pque", "opade", "opque", "play", "paque", " opque", " opane", "Opque", "pade", "oplay", "Opaque"], "addr": ["ord", "ref", "rs", "address", "trans", "Address", "tx", "x", "src", "ar", "hw", "dh", "adr", "oad", "loc", "err", "r", "add", "ptr", "host", "tr", "dr", "handle", "now", "pos", "eth", "ack", "id", "dir", "at", "act", "ad", "offset", "inter", " address", "mt", "coord", "attr", "work", "pad", "cmd", "rt"], "val": [" value", "cal", "Val", "ref", "sol", "serv", "pol", "tx", "value", "buf", "state", "sel", " cal", " tx", "loc", "VAL", "ival", " eval", " bl", "valid", " pref", " valid", "mem", "b", "db", "al", " v", "ret", " arg", "vt", " vol", " weight", "ctx", "bal", "it", "vals", "bit", "aval", "abl", " msg", "rol", "vol", " seq", "v", "lit", " slot", " ty"], "d": ["dn", "h", "cal", "ind", "l", "dm", "dict", "n", "di", "dc", "draw", "c", "bd", "p", "s", "r", "m", "b", "pd", "e", "db", "od", "dd", "fd", "done", "D", "g", "de", "j", "ad", "sd", "dq", "t", "ds", "debug", "ade", "o", "ld", "f", "w", "dat", "da"], "reg": ["rel", "ref", "br", "Reg", "re", "ress", "tab", "loc", "tag", "r", "REG", "disc", "ptr", "tr", "mb", "mem", "db", "rr", "ret", "eg", "region", "ro", "g", "rg", "red", "res", "fr", "rm", "ric", "rol", "gr", "ig", "rt", "rec", "rem"]}}
{"project": "qemu", "commit_id": "1a29cc8f5ebd657e159dbe4be340102595846d42", "target": 0, "func": "void serial_realize_core(SerialState *s, Error **errp)\n\n{\n\n    if (!qemu_chr_fe_backend_connected(&s->chr)) {\n\n        error_setg(errp, \"Can't create serial device, empty char device\");\n\n        return;\n\n    }\n\n\n\n    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);\n\n\n\n    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);\n\n    qemu_register_reset(serial_reset, s);\n\n\n\n    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,\n\n                             serial_event, NULL, s, NULL, true);\n\n    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);\n\n    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);\n\n    serial_reset(s);\n\n}\n", "idx": 15775, "substitutes": {"s": ["bs", "fs", "ties", "k", "ps", "r", "ms", "ports", "js", "services", "g", "sw", "se", "sc", "y", "ins", "sis", "sync", "details", "h", "changes", "sb", "results", "os", "als", "sv", "er", "set", "store", "ssl", "m", "sports", "as", "sp", "j", "t", "states", "is", "south", "ns", "l", "rs", "save", "S", "c", "comm", "sys", "ls", "hs", "ats", "its", "ims", "sq", "ts", "o", "a", "qs", "params", "ss", "sts", "i", "n", "z", "ses", "ar", "p", "es", "aws", "gs", "b", "e", "spec", "less", "ds", "cs", "v", "stats", "w"], "errp": ["ererp", " errP", "ererps", "erpb", " errps", "erP", "erp", " errpb", "errps", "rrP", "errpb", "errP", "rrp", "erps", "rrpb", "ernp", "erernp", "rrps", " errnp", "errnp"]}}
{"project": "qemu", "commit_id": "44bc910794eff956ceba0030f0751a26bed748b5", "target": 0, "func": "static int get_physical_address(CPUPPCState *env, mmu_ctx_t *ctx,\n\n                                target_ulong eaddr, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n#if 0\n\n    qemu_log(\"%s\\n\", __func__);\n\n#endif\n\n    if ((access_type == ACCESS_CODE && msr_ir == 0) ||\n\n        (access_type != ACCESS_CODE && msr_dr == 0)) {\n\n        if (env->mmu_model == POWERPC_MMU_BOOKE) {\n\n            /* The BookE MMU always performs address translation. The\n\n               IS and DS bits only affect the address space.  */\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n        } else if (env->mmu_model == POWERPC_MMU_BOOKE206) {\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                                   access_type);\n\n        } else {\n\n            /* No address translation.  */\n\n            ret = check_physical(env, ctx, eaddr, rw);\n\n        }\n\n    } else {\n\n        ret = -1;\n\n        switch (env->mmu_model) {\n\n        case POWERPC_MMU_32B:\n\n        case POWERPC_MMU_601:\n\n            /* Try to find a BAT */\n\n            if (env->nb_BATs != 0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                /* We didn't match any BAT entry or don't have BATs */\n\n                ret = get_segment32(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n        case POWERPC_MMU_SOFT_6xx:\n\n        case POWERPC_MMU_SOFT_74xx:\n\n            /* Try to find a BAT */\n\n            if (env->nb_BATs != 0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                /* We didn't match any BAT entry or don't have BATs */\n\n                ret = get_segment_6xx_tlb(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n#if defined(TARGET_PPC64)\n\n        case POWERPC_MMU_64B:\n\n        case POWERPC_MMU_2_06:\n\n        case POWERPC_MMU_2_06d:\n\n            ret = get_segment64(env, ctx, eaddr, rw, access_type);\n\n            break;\n\n#endif\n\n\n\n        case POWERPC_MMU_SOFT_4xx:\n\n        case POWERPC_MMU_SOFT_4xx_Z:\n\n            ret = mmu40x_get_physical_address(env, ctx, eaddr,\n\n                                              rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE:\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE206:\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                               access_type);\n\n            break;\n\n        case POWERPC_MMU_MPC8xx:\n\n            /* XXX: TODO */\n\n            cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n            break;\n\n        case POWERPC_MMU_REAL:\n\n            cpu_abort(env, \"PowerPC in real mode do not do any translation\\n\");\n\n            return -1;\n\n        default:\n\n            cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n#if 0\n\n    qemu_log(\"%s address \" TARGET_FMT_lx \" => %d \" TARGET_FMT_plx \"\\n\",\n\n             __func__, eaddr, ret, ctx->raddr);\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 15779, "substitutes": {"env": ["pkg", "server", "tk", "nv", "addr", "cb", "eng", "org", "et", "cv", "engine", "sw", "param", "esc", "inv", "vm", "event", "context", "worker", "usr", "kw", "end", "here", "init", "er", "enter", "forge", "vp", "code", "ah", "vt", "eh", "erd", "era", "iv", "en", "conn", "cmd", "query", "req", "nw", "exec", "ext", "err", "kernel", "vs", "te", "viron", "ev", "ew", "proc", "ec", "work", "rod", "hw", "conf", "environment", "desc", "e", "dev", "db", "network", "estate", "exc", "act", "erb", "ov", "ect", "gear", "attr", "actor", "config", "equ", "v", "obj"], "ctx": ["pkg", "context", "worker", "jp", "kw", "std", "ck", "stack", "txt", "tx", "tk", "conv", "ctl", "cas", "gz", "setup", "cmp", "pool", "buf", "np", "etc", "xc", "cp", "hw", "conf", "cu", "HK", "loc", "sys", "org", "jac", "util", " context", "cfg", "handle", "mem", "tc", "nt", "cc", "cv", "kt", "act", "msg", "data", "conn", "ka", "ct", "proc", "fw", "net", "ca", "lib", "sc", "resp", "rt", "cmd", "wx", "vm", "obj", "aux", "qt", "iat", "co"], "eaddr": [" eldder", "eeddress", "eyptr", "adderdress", "eadler", "ielddr", "eadder", "rolller", "rolldr", "asyrd", "eadrd", "ieldric", "aeddro", "dlller", "ieldrd", "eddDR", "dllder", "reamdr", " edrs", "ieldDR", "eedptr", "aeddel", "ielddel", "ellrd", "reammr", "elldel", "edddr", "rolldress", "aedadr", "oaddr", "eadbr", "addydr", "rollder", " eldrs", "eddyder", "eadr", "addyrect", "ielddro", " eddr", "reamder", "eedtr", "ieldr", "ieldler", "adderric", "eadadr", "eyder", "eadric", "elldress", "ieldder", "ezdr", "reamrect", "eeddr", "addymr", "eddder", "adderdr", "ewayder", "ellhr", "eddyptr", " edbr", "eydress", "ieldtr", "asyhr", " edder", " eldbr", "eadptr", "oadr", "asydr", "eadhr", "eydr", "eaddress", "eadmr", " elddr", "oadder", "eaddel", "aeddr", "ezp", "eadtr", "eddydress", "adderder", "eadDR", "eaddro", "dddr", "oadDR", "ellder", "elldro", "ielddress", "ieldhr", "ieldadr", "eadp", "ddbr", "ddrs", "ewaydr", "dlldr", "ezder", "ewayrect", "eztr", "addyder", "eadrs", "ellric", "elldr", "elladr", "eddydr", "eedp", "dlldress", "ewaymr", "eddr", "ddder", "eedder", "eadrect", "ieldp", "asyadr"], "rw": ["wind", "wl", "kw", "rs", " wr", "ow", "nw", "wal", "rb", "wk", "rf", "hw", "rew", "wp", "ru", "r", " w", "ptr", "rx", "writ", " ro", "rd", "writer", "wr", "window", "tw", "rss", "rh", "nr", "w", "wa", "NW", "workers", "wt", "ew", "rl", "erb", "wo", "wn", "iw", "RW", "work", "fw", "aw", "vr", "wx", "rt", "resp", "writers", "wb", "wh", "wd", "rack"], "access_type": ["access_color", "accessproType", "accessetyunit", "escape_desc", "accessiontype", "accessertype", "issue_table", "accessingtype", "access_label", "access_error", "accessetytype", "ACC_rel", "accessetyfunction", " access_ype", "access_group", "attributeingtype", "accessabletype", "accessTyperole", "issue_Type", "accesserfunction", "accessingerror", "access_rel", "attribute_function", "accessionoperator", "accesseterType", "access_role", "accessingfunction", "accesseterfunction", "access_desc", "accessionype", "accessTypecolor", " access_field", "accessTypeType", "access00type", "access_Type", "escape_type", "accessprotable", " access_typ", "accessopType", "issue_type", "accessabilityfunction", "accesserrel", "accessetertype", "accessetyType", "accessoplabel", "access00TYPE", "accessionstatus", "accessabilitytype", "accessetyoptions", "accessionrel", "accessabilityoperator", "accessoptype", "access_ype", "ACC_function", "accessableerror", " access_options", "accessitytype", "access00desc", "accessTypetype", "escape_TYPE", "accessprotype", "accessopype", "accessetyoperator", "ACCerfunction", "issue_group", "access_operator", "accesseroperator", "accessuretype", "accessingoperator", "access_num", "accessetytyp", "accessitytyp", "accessurenum", "attributeingerror", "accessureoptions", "attribute_type", "ACC_type", "access_TYPE", " access_status", "access_field", "access_typ", "access_options", " access_num", "access_unit", " access_unit", "access_status", "accessionfunction", "accessityType", "accessionType", "ACCertype", "accessureType", "escape_typ", "accesseterstatus", "access00typ", "ACCerrel", "ACC_operator", "access_table", "accessetyfield", "ACCeroperator", "accessabilityerror", "accessprogroup", " access_function", " access_role", "accessionlabel", "accessetyrel", "attribute_error", "accessableoperator", " access_Type", " access_color", "accessityfunction", "attributeingoperator", " access_label", "attribute_operator", "accessetynum", "attributeingfunction", "accessablefunction", "access_function"], "ret": ["re", "gz", "cat", "Ret", "tif", "r", "et", "att", "rect", "url", "urn", "inter", "utils", "ter", "expr", "rets", " res", "quad", "rem", "eu", "prop", " alt", "dt", "br", "hash", "pas", "def", "jump", "tr", "final", "res", "try", "get", "resp", "cmd", "print", "rel", "jp", "req", "RET", "ext", "sys", "arr", "err", "Return", "alt", "nt", "cert", "rm", "mt", "det", "gt", "il", "rt", "val", "aux", "ft", "ref", "elt", "lt", "out", "reg", "result", "oret", "desc", "rev", "ert", "len", "iter", "fun", "cont", "back", "ll", " Ret", "mel", "lit", "lr", "obj", "reset", "backed"]}}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static uint8_t eeprom24c0x_read(void)\n\n{\n\n    logout(\"%u: scl = %u, sda = %u, data = 0x%02x\\n\",\n\n        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);\n\n    return eeprom.sda;\n\n}\n", "idx": 15788, "substitutes": {}}
{"project": "qemu", "commit_id": "6a8f9661dc3c088ed0d2f5b41d940190407cbdc5", "target": 0, "func": "static void blockdev_do_action(int kind, void *data, Error **errp)\n\n{\n\n    TransactionAction action;\n\n    TransactionActionList list;\n\n\n\n    action.kind = kind;\n\n    action.data = data;\n\n    list.value = &action;\n\n    list.next = NULL;\n\n    qmp_transaction(&list, errp);\n\n}\n", "idx": 15791, "substitutes": {"kind": ["nick", "context", "rank", "ind", "Kind", "ark", "type", "th", "ko", "k", "style", "when", "what", "need", "school", "priority", "state", "important", "family", "key", "desc", "topic", "mk", "name", "concept", "md", "kids", "code", "kick", "sk", "index", "spec", "mode", "id", "dir", "mid", "IND", "msg", "cost", "ke", "conduct", "kid", "config", "cmd", "metadata", "K", "needed", "brand"], "data": ["context", "device", "rel", "d", "info", "type", " DATA", "image", "bytes", "Data", "partial", "json", "DATA", "content", "what", "error", "value", "only", "feed", "results", "input", "result", "ata", "rew", "message", "p", "def", "batch", "m", "empty", "any", "key", "timeout", "raw", "name", "response", "initial", "buffer", "no", "done", "size", "load", "missing", "latest", "bin", "step", "attr", "snap", "source", "val", "text", "table", "dat", "mu", "ns"], "errp": ["dieps", " errcp", " extrpar", " errP", " extrpad", "diepar", " erps", " errps", "erP", "erp", "errcp", "errpad", "errps", " erp", "errP", "diepad", "erps", "errpar", " erP", " ercp", " extrp", " errpar", "diep", "ercp", " extrps", " errpad"], "action": ["event", "role", "view", "version", "type", "package", "image", "process", "ACTION", "payment", "tx", "task", "out", "value", "state", "alias", "admin", "create", "Action", "set", "operator", "edit", "article", "controller", "cart", "entry", "rule", "commit", "attribute", "op", "act", "ACT", "acl", "item", "msg", "lock", "step", "aco", "comment", "t", "actor", "test", "file", "ction", "ace", "cmd", "ac", "a", "function", "policy", "command", "print", "link", "form", "relation", "call", "operation"], "list": ["detail", "label", "queue", "l", "parent", "map", "level", "status", "null", "summary", "out", "sequence", "group", "pool", "local", "state", "result", "ist", "st", "li", "pl", "filter", "set", "batch", "add", "entry", "block", "LIST", "collection", "index", "spec", "id", "act", "load", "layout", "item", "lists", "lock", "seq", "t", "template", "part", "listed", "all", "print", "table", "v", "form", "relation", "List", "pair"]}}
{"project": "FFmpeg", "commit_id": "659d4ba5af5d72716ee370bb367c741bd15e75b4", "target": 0, "func": "static void h263_h_loop_filter_mmx(uint8_t *src, int stride, int qscale)\n\n{\n\n    if (CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {\n\n        const int strength = ff_h263_loop_filter_strength[qscale];\n\n        DECLARE_ALIGNED(8, uint64_t, temp)[4];\n\n        uint8_t *btemp = (uint8_t*)temp;\n\n\n\n        src -= 2;\n\n\n\n        transpose4x4(btemp,     src,              8, stride);\n\n        transpose4x4(btemp + 4, src + 4 * stride, 8, stride);\n\n        __asm__ volatile (\n\n            H263_LOOP_FILTER // 5 3 4 6\n\n\n\n            : \"+m\"(temp[0]),\n\n              \"+m\"(temp[1]),\n\n              \"+m\"(temp[2]),\n\n              \"+m\"(temp[3])\n\n            : \"g\"(2 * strength), \"m\"(ff_pb_FC)\n\n            );\n\n\n\n        __asm__ volatile (\n\n            \"movq      %%mm5, %%mm1         \\n\\t\"\n\n            \"movq      %%mm4, %%mm0         \\n\\t\"\n\n            \"punpcklbw %%mm3, %%mm5         \\n\\t\"\n\n            \"punpcklbw %%mm6, %%mm4         \\n\\t\"\n\n            \"punpckhbw %%mm3, %%mm1         \\n\\t\"\n\n            \"punpckhbw %%mm6, %%mm0         \\n\\t\"\n\n            \"movq      %%mm5, %%mm3         \\n\\t\"\n\n            \"movq      %%mm1, %%mm6         \\n\\t\"\n\n            \"punpcklwd %%mm4, %%mm5         \\n\\t\"\n\n            \"punpcklwd %%mm0, %%mm1         \\n\\t\"\n\n            \"punpckhwd %%mm4, %%mm3         \\n\\t\"\n\n            \"punpckhwd %%mm0, %%mm6         \\n\\t\"\n\n            \"movd      %%mm5, (%0)          \\n\\t\"\n\n            \"punpckhdq %%mm5, %%mm5         \\n\\t\"\n\n            \"movd      %%mm5, (%0, %2)      \\n\\t\"\n\n            \"movd      %%mm3, (%0, %2, 2)   \\n\\t\"\n\n            \"punpckhdq %%mm3, %%mm3         \\n\\t\"\n\n            \"movd      %%mm3, (%0, %3)      \\n\\t\"\n\n            \"movd      %%mm1, (%1)          \\n\\t\"\n\n            \"punpckhdq %%mm1, %%mm1         \\n\\t\"\n\n            \"movd      %%mm1, (%1, %2)      \\n\\t\"\n\n            \"movd      %%mm6, (%1, %2, 2)   \\n\\t\"\n\n            \"punpckhdq %%mm6, %%mm6         \\n\\t\"\n\n            \"movd      %%mm6, (%1, %3)      \\n\\t\"\n\n            :: \"r\"(src),\n\n               \"r\"(src + 4 * stride),\n\n               \"r\"((x86_reg)stride),\n\n               \"r\"((x86_reg)(3 * stride))\n\n            );\n\n    }\n\n}\n", "idx": 15804, "substitutes": {"src": ["ind", "sn", "rs", "sb", "sl", "trans", "secure", "strength", "out", "cur", "init", "SOURCE", "input", "addr", "dest", "st", "loc", "sub", "s", "sys", "scan", "start", "r", "ptr", "from", "syn", "ser", "origin", "img", "pos", "b", "in", "sur", "rc", "iter", "sec", "slice", "sp", "index", "seed", "str", "sq", "offset", "supp", "iv", "sr", "rid", "inst", "ctr", "sc", "source", "sup", "uint", "rest", "ins", "sync", "RC", "stream"], "stride": ["presider", "STRade", " strride", "stringider", "STRure", "strine", "strade", "stide", "STRate", "spend", "strride", "presride", "depthice", "spide", "STRice", "depthride", "grider", "grimate", "slride", "strate", "stider", "depthide", "percentride", "STRine", "gride", " strure", "spider", " strate", "charide", "charride", "slend", "charider", "STRride", "spine", " strice", "strure", "charade", "stend", "sline", "stringide", "spride", "percentimate", "sture", "percentider", " strade", "divide", "strice", "strider", "divride", "STRide", "divice", "stade", "strimate", "divate", "stine", "stringice", "depthider", "STRimate", "percentide", "preside", "strend", "presine", "grride", "slide", "STRider", "stringride"], "qscale": ["qtlevel", "Qscale", "qtpad", "qqScale", "qScale", "qlevel", "qpad", "_Scale", "Qpad", " qScale", "_scale", "qqpad", "qtscale", "_cale", "qcale", " qcale", "Qcale", "qqlevel", "qqscale", "qtScale", "Qlevel", "QScale"], "btemp": ["ptemplate", "ptem", "fstem", "ptemp", "bbtem", "btemplate", "sbtemplate", "sbtemp", " bresult", "btmp", " btemplate", " bstem", "bbtemplate", "ftemplate", "ftemp", "ptmp", "dresult", "bbtemp", " btem", "dtemp", "bptr", "bstem", "dptr", "btem", "ttmp", " bptr", "ttemp", "bbptr", "ttemplate", "bbtmp", "dtem", "bresult", "ftem", "sbstem", "sbtem", "bbresult", "ttem"], "H263_LOOP_FILTER": ["H263_LOOP_AFGER", "H263_LOOP_FILOP", "H263_LOOP_VALTER", "H263_LOOP_VALGER", "H263_LOOP_VALER", "H263_LOOP_AFTER", "H263_LOOP_FILGER", "H263_LOOP_FILER", "H263_LOOP_VALOP", "H263_LOOP_AFER", "H263_LOOP_AFOP"], "m": ["h", "i", "d", "l", "mmm", "n", "k", "gm", "x", "cm", "M", "c", "u", "q", "p", "mc", "r", "arm", "ms", "md", "b", "mp", "g", "module", "j", " M", "mt", "mm", "mod", "t", "tm", "mi", "o", "a", "sm", "hm", "v", "f", "perm", "y", "w", "vm", "pm"]}}
{"project": "qemu", "commit_id": "b63c7f6b77145c109d66a62bb3b6efe12b80d62b", "target": 0, "func": "static void bootp_reply(struct bootp_t *bp)\n\n{\n\n    BOOTPClient *bc;\n\n    struct mbuf *m;\n\n    struct bootp_t *rbp;\n\n    struct sockaddr_in saddr, daddr;\n\n    struct in_addr dns_addr;\n\n    int dhcp_msg_type, val;\n\n    uint8_t *q;\n\n\n\n    /* extract exact DHCP msg type */\n\n    dhcp_decode(bp->bp_vend, DHCP_OPT_LEN, &dhcp_msg_type);\n\n    dprintf(\"bootp packet op=%d msgtype=%d\\n\", bp->bp_op, dhcp_msg_type);\n\n\n\n    if (dhcp_msg_type == 0)\n\n        dhcp_msg_type = DHCPREQUEST; /* Force reply for old BOOTP clients */\n\n\n\n    if (dhcp_msg_type != DHCPDISCOVER &&\n\n        dhcp_msg_type != DHCPREQUEST)\n\n        return;\n\n    /* XXX: this is a hack to get the client mac address */\n\n    memcpy(client_ethaddr, bp->bp_hwaddr, 6);\n\n\n\n    if ((m = m_get()) == NULL)\n\n        return;\n\n    m->m_data += IF_MAXLINKHDR;\n\n    rbp = (struct bootp_t *)m->m_data;\n\n    m->m_data += sizeof(struct udpiphdr);\n\n    memset(rbp, 0, sizeof(struct bootp_t));\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n    new_addr:\n\n        bc = get_new_addr(&daddr.sin_addr);\n\n        if (!bc) {\n\n            dprintf(\"no address left\\n\");\n\n            return;\n\n        }\n\n        memcpy(bc->macaddr, client_ethaddr, 6);\n\n    } else {\n\n        bc = find_addr(&daddr.sin_addr, bp->bp_hwaddr);\n\n        if (!bc) {\n\n            /* if never assigned, behaves as if it was already\n\n               assigned (windows fix because it remembers its address) */\n\n            goto new_addr;\n\n        }\n\n    }\n\n\n\n    if (bootp_filename)\n\n        snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), \"%s\",\n\n                 bootp_filename);\n\n\n\n    dprintf(\"offered addr=%08x\\n\", ntohl(daddr.sin_addr.s_addr));\n\n\n\n    saddr.sin_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_ALIAS);\n\n    saddr.sin_port = htons(BOOTP_SERVER);\n\n\n\n    daddr.sin_port = htons(BOOTP_CLIENT);\n\n\n\n    rbp->bp_op = BOOTP_REPLY;\n\n    rbp->bp_xid = bp->bp_xid;\n\n    rbp->bp_htype = 1;\n\n    rbp->bp_hlen = 6;\n\n    memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, 6);\n\n\n\n    rbp->bp_yiaddr = daddr.sin_addr; /* Client IP address */\n\n    rbp->bp_siaddr = saddr.sin_addr; /* Server IP address */\n\n\n\n    daddr.sin_addr.s_addr = 0xffffffffu;\n\n\n\n    q = rbp->bp_vend;\n\n    memcpy(q, rfc1533_cookie, 4);\n\n    q += 4;\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPOFFER;\n\n    } else if (dhcp_msg_type == DHCPREQUEST) {\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPACK;\n\n    }\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER ||\n\n        dhcp_msg_type == DHCPREQUEST) {\n\n        *q++ = RFC2132_SRV_ID;\n\n        *q++ = 4;\n\n        memcpy(q, &saddr.sin_addr, 4);\n\n        q += 4;\n\n\n\n        *q++ = RFC1533_NETMASK;\n\n        *q++ = 4;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0x00;\n\n\n\n        if (!slirp_restrict) {\n\n            *q++ = RFC1533_GATEWAY;\n\n            *q++ = 4;\n\n            memcpy(q, &saddr.sin_addr, 4);\n\n            q += 4;\n\n\n\n            *q++ = RFC1533_DNS;\n\n            *q++ = 4;\n\n            dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n\n            memcpy(q, &dns_addr, 4);\n\n            q += 4;\n\n        }\n\n\n\n        *q++ = RFC2132_LEASE_TIME;\n\n        *q++ = 4;\n\n        val = htonl(LEASE_TIME);\n\n        memcpy(q, &val, 4);\n\n        q += 4;\n\n\n\n        if (*slirp_hostname) {\n\n            val = strlen(slirp_hostname);\n\n            *q++ = RFC1533_HOSTNAME;\n\n            *q++ = val;\n\n            memcpy(q, slirp_hostname, val);\n\n            q += val;\n\n        }\n\n    }\n\n    *q++ = RFC1533_END;\n\n\n\n    m->m_len = sizeof(struct bootp_t) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n    udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n}\n", "idx": 15811, "substitutes": {"bp": ["bs", "fp", "jp", "lp", "sb", "asm", "pc", "bt", "bf", "bj", "rb", "br", "blog", "BP", "np", "lb", "cp", "bh", "cb", "p", "wp", "bitcoin", "batch", "pb", "gp", "vp", "arb", "b", "pd", "tp", "lbs", "sp", "bb", "osp", "BIP", "hp", "php", "bps", "nb", "bsp", "snap", "phy", "pp", "kb", "arp", "bi", "bg", "bm", "isp"], "bc": ["bs", "abc", "vc", "con", "butt", "sb", "pc", "bt", "bec", "lc", "bf", "unc", "dc", "c", "cb", "bn", "bridge", "comm", "bd", "mc", "bitcoin", "pb", "console", "bo", "arb", "tc", "b", "cc", "eb", "rc", "ng", "sec", "bb", "gc", "exc", "cf", "arc", "conn", "soc", "anc", "broad", "ic", "ec", "BC", "clus", "nc", "fc", "sc", "uc", "mi", "bi", "gov", "bg", "bm", "ba"], "m": ["h", "i", "d", "l", "esm", "dm", "n", "am", "gm", "bm", "cm", "M", "c", "p", "mc", "r", "mb", "mo", "mn", "ms", "mem", "md", "b", "im", "mp", "g", "um", "module", "j", "msg", "mx", "rm", "mt", "mr", "mm", "mail", "mod", "t", "em", "tm", "mi", "man", "sm", "v", "hm", "perm", "mat", "f", "vm", "mu", "pm", "rem"], "rbp": ["bblp", "rblp", "rubyp", "erbpm", "rbpy", "rbP", "srcpy", "rbpa", "rbcp", "bbP", "fbcp", "bbv", "rbpm", "srcp", "gbpy", "rbgp", "rubyps", "erblp", "dbp", "fbp", "fblp", "nrv", "bbgp", "dbcp", "erbg", "erbv", "erbcp", "gbp", "robpc", "robg", "rbps", "dbP", "srcpa", "rbv", "rubypm", "erbpc", "rbg", "nrpy", "erbpp", "erbP", "rbpp", "dbpm", "fbP", "dbpp", "nrp", "erbps", "erbgp", "dbpc", "rbpc", "gbpa", "erbp", "bbpc", "srcv", "bbg", "dbps", "robv", "robp", "fbpc", "rubypp", "gbv", "nrpa", "bbp", "fbgp"], "saddr": ["sadr", "dref", "salign", "daddress", "saddress", "sadd", "scoord", "sref", "sscoord", "ssalign", "dattr", "dscoord", "dadd", " sattr", "dsaddress", " salign", "dsaddr", "sattr", "ssaddr", "dalign", " sadr", "ssadr", " saddress", "dsadr", " sref", "ssref", " sadd", "ssaddress", " scoord"], "daddr": [" dattr", "waddress", "daddress", "sint", "saddress", "gattr", "sadd", "dsint", " dobj", "wattr", "sitem", "waddr", "dattr", "wconn", "dsobj", "radd", "ditem", "gaddress", "dint", "ddaddr", "dsattr", "gaddr", " dconn", "ddaddress", "dsadd", "dobj", "ddattr", "dadd", "wadr", "ddadr", "raddr", "dsaddress", " daddress", "dadr", "dconn", " dadd", "wadd", "dsaddr", "raddress", "sattr", "gitem", "wobj", "dsadr", " dint", "rattr", "dsconn", " ditem"], "dns_addr": ["dnsgaddr", "dns_address", "dnsgaddress", "dNS_address", "dnsgmsg", "dns_msg", "dnsipmsg", "dnsipaddr", "dNS_addr", "dNS_msg", "dnsipaddress"], "dhcp_msg_type": ["dhcp_msg_style", "dhcp_msg_num", "dhcp_msg_class", "dhcp_message_num", "dhcp_message_length", "dhcp_cmd_TYPE", "dhcp_message_TYPE", "dhcp_cmd_type", "dhcp_msg_desc", "dhcp_msg_Type", "dhcp_message_type", "dhcp_cmd_name", "dhcp_message_style", "dhcp_Msg_style", "dhcp_req_class", "dhcp_msg_name", "dhcp_Msg_Type", "dhcp_message_Type", "dhcp_Msg_id", "dhcp_msg_id", "dhcp_message_no", "dhcp_req_name", "dhcp_Msg_type", "dhcp_message_name", "dhcp_msg_TYPE", "dhcp_Msg_name", "dhcp_cmd_Type", "dhcp_msg_length", "dhcp_req_no", "dhcp_msg_no", "dhcp_req_type", "dhcp_message_desc"], "val": ["rel", "cal", "vc", "Val", "eval", "pol", "extra", "tx", "local", "value", "aud", "VAL", "key", "valid", "pos", "mem", "len", "al", "ctx", "ret", "bal", "vals", "res", "msg", "seq", "typ", "v", "base"], "q": ["qi", "iq", "h", "ch", "quote", "z", "Q", "c", "u", "p", "qa", "qq", "eq", "e", "buffer", " v", "cv", "g", "j", "sq", "dq", "qu", "o", "v", "f", "qs", "w", "query"]}}
{"project": "qemu", "commit_id": "4445b1d27ee65ceee12b71bc20242996c8eb5cf8", "target": 0, "func": "static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)\n\n{\n\n    switch (drc->state) {\n\n    case SPAPR_DRC_STATE_PHYSICAL_POWERON:\n\n        return RTAS_OUT_SUCCESS; /* Nothing to do */\n\n    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:\n\n        break; /* see below */\n\n    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:\n\n        return RTAS_OUT_PARAM_ERROR; /* not allowed */\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    /* if the guest is configuring a device attached to this DRC, we\n\n     * should reset the configuration state at this point since it may\n\n     * no longer be reliable (guest released device and needs to start\n\n     * over, or unplug occurred so the FDT is no longer valid)\n\n     */\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;\n\n\n\n    if (drc->unplug_requested) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_isolation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n", "idx": 15818, "substitutes": {"drc": ["sdsc", "tdrc", "daisco", " disco", "didrs", "mroc", "dsc", "lrec", " dsrc", "tdsrc", "lRC", "Dric", "tdRC", "mrc", "sdrc", "Droc", "didisco", "rdarc", "dnsrc", "sdroc", "Drs", "sdrec", "mrec", "dirc", "didrc", " drec", "didcol", "adroc", "mRC", "dbrc", "DRC", "docr", " dirc", " darc", "lroc", "Dsrc", "darc", "daxc", "dbric", "didRC", "didocr", "dric", "Dirc", " dric", " drs", " docr", "dnrc", "adrc", "dacol", "rdrc", "proc", "parc", "Dxc", "rdroc", "daRC", "drec", "lrc", "pRC", "drs", "dbRC", " droc", "droc", "adrec", "disco", "dasrc", "prec", "dxc", "adsc", "rdRC", "dsrc", "dcol", "dRC", "tdxc", "prc", "dnroc", "Docr", "Drc", " dsc", " dRC", "dbsrc", "dnirc", " dcol"]}}
{"project": "qemu", "commit_id": "2e6a64cb8d7506ad27d3b6c8000bc8d773936932", "target": 0, "func": "static void input_linux_event_mouse(void *opaque)\n\n{\n\n    InputLinux *il = opaque;\n\n    struct input_event event;\n\n    int rc;\n\n\n\n    for (;;) {\n\n        rc = read(il->fd, &event, sizeof(event));\n\n        if (rc != sizeof(event)) {\n\n            if (rc < 0 && errno != EAGAIN) {\n\n                fprintf(stderr, \"%s: read: %s\\n\", __func__, strerror(errno));\n\n                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);\n\n                close(il->fd);\n\n            }\n\n            break;\n\n        }\n\n\n\n        input_linux_handle_mouse(il, &event);\n\n    }\n\n}\n", "idx": 15823, "substitutes": {"opaque": ["oplent", "oplaque", "ropula", "obacity", "epacity", "obaque", "compent", "composit", "oplacity", "ropaque", "compacity", "oplosit", "obubis", "Opacity", "opent", "obula", "ropubis", "eposit", "opacity", "epent", "epaque", "compaque", "Opubis", "opubis", "Opula", "opula", "Opaque", "oposit", "ropacity"], "il": ["lis", "wl", "inel", " pil", " sil", "l", "sil", "ile", "ilt", "mil", "ql", "ilk", "ail", "sql", "util", "bil", "til", "ill", "ool", "lin", "ul", "illa", "kl", "icol", "ssl", "IL", "ilo", "nil", "ili", "gil", "hl", "pel", "iler", "acl", "ml", "yl", "fil", "rol", "ll", "iol", "intel", "ils", "ial", "irin", "fol", "mi", "cil", "jl", "ipl", "ull"], "event": ["device", "entity", "view", "image", "header", "oe", "error", "frame", "vent", "argument", "xml", "message", " input", " cue", "rule", " operation", "ex", " error", "all", "term", "info", "tag", " exc", "request", "ack", "msg", "other", "comment", "cmd", "command", "doc", "ee", " image", "claim", "exec", " waiter", "ext", "change", " signal", "ent", " command", "field", "block", "index", "object", "ev", "item", "data", " address", " msg", "arg", " emit", " argument", "archive", "call", "cal", "extra", "json", "task", "out", "result", "input", "document", "age", "action", "raw", " exception", " entity", "e", "window", " message", "exc", "Event", "row", "press", "test", "config", " ev"], "rc": ["ch", " cr", "cor", "rs", "con", "ra", "comp", "rin", "pc", "bc", "ck", "rb", "re", "dc", "cur", "cmp", "src", "c", "cb", "err", "r", "rx", " r", "ry", " ro", "cc", " RC", "rr", "len", "nr", "gc", "ack", "ce", "ro", "rn", "res", "coll", "arc", "cre", "row", "ras", "ctr", "ec", "nc", "cs", "fc", "sc", "rys", "rt", "roc", "ac", "cr", "rec", "sync", "cd", "RC", "erc", "co"]}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int float64_eq( float64 a, float64 b STATUS_PARAM )\n\n{\n\n\n\n    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )\n\n         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )\n\n       ) {\n\n        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {\n\n            float_raise( float_flag_invalid STATUS_VAR);\n\n        }\n\n        return 0;\n\n    }\n\n    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );\n\n\n\n}\n", "idx": 15833, "substitutes": {"a": ["h", "i", "l", "aj", "am", "A", "la", "x", "out", "aq", "ga", "ar", "ata", "ed", "aa", "u", "ap", "p", "s", "an", "r", "ma", "ach", "oa", "ia", "b", "e", "att", "as", "sa", "al", "isa", "aaa", "at", "era", "ao", "el", "ak", "t", "ca", "ea", "au", "o", "ac", "aka", "ae", "y", "f", "ab", "w", "eas", "da", "ba"], "STATUS_PARAM": ["STATUS_PARUS", "STATUS_ARA", "STATUS_NORAMS", "STATUS_PARAMS", "STATUS_TAGA", "STATUS_TAGUS", "STATUS_NORA", "STATUS_NORAM", "STATUS_ARAM", "STATUS_ARAMS", "STATUS_PARA", "STATUS_NORUS", "STATUS_TAGAM", "STATUS_TAGAMS", "STATUS_ARUS"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_cmp(TCGCond cond,\n\n                                  int ra, int rb, int rc,\n\n                                  int islit, uint8_t lit)\n\n{\n\n    int l1, l2;\n\n    TCGv tmp;\n\n\n\n    if (unlikely(rc == 31))\n\n    return;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n\n\n    if (ra != 31) {\n\n        tmp = tcg_temp_new(TCG_TYPE_I64);\n\n        tcg_gen_mov_i64(tmp, cpu_ir[ra]);\n\n    } else\n\n        tmp = tcg_const_i64(0);\n\n    if (islit)\n\n        tcg_gen_brcondi_i64(cond, tmp, lit, l1);\n\n    else\n\n        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);\n\n\n\n    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_movi_i64(cpu_ir[rc], 1);\n\n    gen_set_label(l2);\n\n}\n", "idx": 15840, "substitutes": {"cond": ["ond", "bind", "ind", "ref", "con", "comp", " flock", "condition", "dict", " prep", " def", "bf", "tx", " cont", "init", "cmp", "reg", "c", "conf", "Cond", "pred", "def", "pre", " pred", "jac", " ex", "cell", " exc", " cmd", " uncond", " condition", "ctx", "imm", "cont", "cod", "red", " conditional", "lock", "ct", " inf", "circ", "like", " Cond", "expr", " con", "resp", "cmd", "mat", "cd", "obj", "call", "co"], "ra": ["i", "rel", "ror", "ara", "raf", "tri", "rs", "area", "ur", "la", "re", "rat", "run", "ar", "hi", "dra", "ru", "r", "ri", "ran", "ir", "rd", "rr", "rh", "ica", "ro", "rn", "range", "Ra", "rad", "rar", "row", "rap", "po", "pr", "rom", "rt", "a", "RA", "cr", "tra", "rise", "or", "rav", "ras", "rac", "alpha", "co", "ta"], "rb": ["raf", "reb", "br", "ruby", "RB", "lb", "rf", "src", "cb", "ru", "r", "ri", "pb", "rd", "b", "db", "rr", "bb", "rg", "erb", "rl", "rar", "rm", "rid", "mr", "nb", "iro", "bp", "vr", "rt", "ob", "wb", "ab", "lr", "gb", "rob"], "rc": ["ror", "raf", "rs", "con", "rin", "pc", "lc", "br", "rib", "src", "c", "rf", "cb", "loc", "ru", "r", "ri", "rx", "irc", "ry", "rd", "tc", "rev", "isc", "rr", "ica", "cv", "ro", "rn", "rl", "ci", "row", "arc", "rar", "rid", "ec", "fc", "cs", "sc", "uc", "rt", "rw", "cr", "cd", "lr", "RC", "ras", "ron", "co"], "islit": ["gelite", "itolocation", "gelit", "lestolit", "selist", "selitted", "itollit", "slitted", "itololit", "selit", "slist", "itolit", "islocation", "islolit", "lestocation", "slolit", "lestlit", "slocation", "slite", "sllit", "slit", "islitted", "gelist", "lestit", "gelitted", "islite", "isllit", "selite", "islist"], "lit": ["rel", "ind", "l", "ref", "tl", "lt", "la", "bf", "local", "init", "buf", "sel", "loc", "def", "ptr", "pos", "alt", "iter", "fi", "unit", "cont", "it", "bit", "limit", "lock", "rot", "ite", "abl", "lim", "t", "typ", "late", " literal", "il", "expr", "test", "lib", "rt", "lang", "val", "eral", "iat", "label"], "l1": ["Lau", " lau", "fl1", "lau", " l51", "L5", "j5", "v1", "l51", "li01", "tl81", "j1", "v0", "fl01", "li9", "L2", "L0", " l3", "tl2", "fl9", "l81", "li2", "L1", "v81", "tl51", " l9", "l5", " l81", "li0", "l3", "liau", " l01", "j0", "li1", "v51", "l0", "fl0", "v2", "l9", "l01", "tl1", "L3", " l0", "v3", "j2", " l5"], "l2": ["sl2", "v3", " l02", "v1", " l7", "ltwo", "eltwo", "v0", "L02", "L2", "li3", "l7", "sl02", "sl1", "c0", " l3", "L0", " lge", "ctwo", "lige", "Lge", "li2", "c2", "L1", "el4", "l3", " ltwo", "lge", "l02", "sl7", " l4", "l0", "L7", "l4", "li1", "v2", "c4", "el0", " l0", "L3", "el2"], "tmp": ["pkg", "uf", "cache", "py", "tv", "emp", "term", "tn", "tem", "txt", "temp", "xb", "ip", "etc", "tab", "buf", "node", "np", "util", "new", "cp", "cb", "trap", "loc", "p", "mut", "tg", "m", "ptr", "tf", "mb", "mk", "buff", "mem", "b", "tc", "nt", "mp", "box", "xy", "vt", "ctx", "sp", "mint", "cv", "tar", "ret", "j", "rl", "copy", "rap", "nb", "t", "attr", "template", "tt", "tm", "lib", "rt", " np", "resp", "perm", "var", "td", "obj", "aux"]}}
{"project": "qemu", "commit_id": "e3c9d76acc984218264bbc6435b0c09f959ed9b8", "target": 1, "func": "static int virtio_scsi_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIOSCSI *s = VIRTIO_SCSI(qdev);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);\n\n\n\n    unregister_savevm(qdev, \"virtio-scsi\", s);\n\n    return virtio_scsi_common_exit(vs);\n\n}\n", "idx": 15846, "substitutes": {"qdev": ["iqproc", "quediv", "qublock", "iqev", "qupad", "dqdef", "qdevice", "sqpad", "sqdev", "Qdev", "qpad", "gdef", "quedev", "iqdiv", "qreg", "qudev", "qdiv", "sqev", "qblock", "qqdevice", "qualreg", " qpad", "queev", "sqdef", "gdiv", "qualdev", "qualdef", "gev", "qualdevice", "gproc", "sqdevice", "qdef", "dqdev", "qproc", "iqdev", " qblock", "queproc", "gdev", "Qdevice", "Qreg", "qqdef", "qqreg", "dqev", "qqdev", "qev", "sqblock", "dqdevice", "Qdef", "gdevice"], "s": ["i", "h", "fs", "l", "rs", "n", "ses", "S", "sv", "c", "ss", "p", "ess", "si", "ls", "hs", "ms", "gs", "ats", "b", "iss", "js", "w", "g", "sq", "gets", "t", "ds", "cs", "ts", "is", "a", "o", "v", "f", "qs", "ns", "sts"], "vs": ["bs", "vc", "fs", "rs", "ks", "ies", "ves", "nv", "sv", "ps", "ls", "xs", "vp", "hs", "ms", "gs", "js", "VS", "vt", "sts", "Vs", "ds", " cs", "vr", "cs", "ts", "v", "ins", "qs", "obs", "ns", "ss"]}}
{"project": "qemu", "commit_id": "7d6e771f49c36f4388798ce25bde1dede40cda74", "target": 0, "func": "static int pci_vpb_init(SysBusDevice *dev)\n\n{\n\n    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);\n\n    PCIBus *bus;\n\n    int i;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        sysbus_init_irq(dev, &s->irq[i]);\n\n    }\n\n    bus = pci_register_bus(&dev->qdev, \"pci\",\n\n                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,\n\n                           get_system_memory(), get_system_io(),\n\n                           PCI_DEVFN(11, 0), 4);\n\n\n\n    /* ??? Register memory space.  */\n\n\n\n    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-selfconfig\", 0x1000000);\n\n    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-config\", 0x1000000);\n\n    if (s->realview) {\n\n        isa_mmio_setup(&s->isa, 0x0100000);\n\n    }\n\n\n\n    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);\n\n\n\n    pci_create_simple(bus, -1, \"versatile_pci_host\");\n\n    return 0;\n\n}\n", "idx": 15879, "substitutes": {"dev": ["device", "h", "d", "dem", "ve", "DEV", "priv", "serv", "go", "devices", "local", "os", "serial", "gu", "hw", "ver", "def", "p", "sys", "cam", "pro", "Device", "mem", "md", "nt", "db", "home", "des", "Dev", "window", "dd", "de", "g", "ev", "ad", "sd", "disk", "data", "conn", "dis", "driver", "proc", "t", "ds", "debug", "vol", "pad", "cmd", "v", "stick", "wd", "obj", "w"], "s": ["bs", "h", "fs", "rs", "sb", "serv", "sl", "ses", "S", "so", "sv", "c", "has", "ps", "ss", "comm", "p", "sys", "es", "store", "m", "sam", "ls", "syn", "vs", "args", "hs", "aws", "gs", "ats", "b", "js", "sp", "spec", "g", "services", "sh", "j", "res", "sq", "sw", "sd", "less", "t", "ds", "self", "se", "cs", "ts", "tests", "sc", "is", "cmd", "sm", "v", "stats", "f", "sis", "qs", "obj", "ns", "params", "sts"], "bus": ["bs", "device", "vc", "card", "bar", "join", "bc", "out", "local", "way", "buf", "boot", "cat", "usb", "util", "c", "http", "bridge", "hand", "trap", "loc", "root", "host", "cast", "us", "handle", "port", "b", " BUS", "chain", "box", "home", "block", "buffer", "loop", "ack", "book", "back", "lock", "data", "disk", "board", "bug", "proxy", "vol", "Bus", "mount", "BUS", "base", "stick", "user"], "i": ["qi", "ind", "l", "ai", "ii", "io", "gi", " ni", " e", "di", "x", "sim", "ip", "gu", " p", "c", "u", "ti", "li", "hi", "\u0438", "I", "p", " j", " I", "client", "si", "m", " pi", "key", "ms", "im", "multi", "chain", "in", "e", "iter", "my", "ami", " v", "fi", "index", "id", " m", " ii", "it", "g", "j", "ias", "me", "ci", "ie", "ex", "ic", "t", "phi", " c", " mi", "ix", "mi", "o", "is", "pi", "v", "y", "ui", "ini", "print", " multi", " ti"]}}
{"project": "qemu", "commit_id": "feced894fb6c474eb56daeb2b2d1f99bae87677f", "target": 0, "func": "static void rng_random_set_filename(Object *obj, const char *filename,\n\n                                 Error **errp)\n\n{\n\n    RngBackend *b = RNG_BACKEND(obj);\n\n    RndRandom *s = RNG_RANDOM(obj);\n\n\n\n    if (b->opened) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    if (s->filename) {\n\n        g_free(s->filename);\n\n    }\n\n\n\n    s->filename = g_strdup(filename);\n\n}\n", "idx": 15883, "substitutes": {"obj": ["bs", "h", "ref", "tmp", "objects", "ck", "bj", "rb", "tk", "os", "cur", "ist", "bh", "hw", "this", "oid", "org", "ht", "oj", "et", "handle", "bo", "nt", "js", "ot", "window", "xy", "db", "ctx", "object", "rect", "cont", "it", "act", "og", "j", "ex", "t", "attr", "po", "self", "expr", "o", "cmd", "onet", "ob", "Object", "inv", "v", "Obj"], "filename": ["Filename", "ames", "sequence", "managed", "til", "kl", "forth", "nil", "journal", "held", "names", "fn", "wav", "url", "dump", "description", "release", "username", "doi", "ame", "text", "that", "directory", "png", "partial", "subject", "txt", "title", "gettable", "severe", "append", "bite", "name", "fired", "println", "generation", "ename", "sbm", "FIL", "fil", "file", "metadata", "length", "location", "folder", "fps", "prefix", "jpg", "knife", "summary", "whatever", "origin", "seek", "licensed", "csv", "stem", "fle", "frames", "kj", "written", "mpeg", "fp", "n", "json", "files", "p", "nm", "path", "finals", "original", "output"], "errp": [" errP", " errpun", "errpr", "ErP", "riskp", "Erp", " errpc", "lerP", "errP", "eorp", "errpc", "errorP", "lerp", "Erpr", "lerpd", "eorpd", "riskpun", "Erpd", "riskpc", "riskP", "lerpr", "errpun", "eorP", "eorpr", "errorp", "errorpun", "errorpc", "errpd"], "b": ["bs", "h", "i", "d", "l", "sb", "bt", "bc", "br", "rb", "c", "bh", "cb", "p", "r", "ib", "pb", "mb", "fb", "eb", "db", "bb", "g", "j", "B", "nb", "t", "bp", "o", "a", "y", "f", "v", "ab", "bg", "bi", "wb", "bm", "base", "be", "gb"], "s": ["bs", "details", "i", "fs", "rs", "sn", "changes", "sb", "n", "settings", "sl", "z", "ses", "S", "os", "sv", "q", "ps", "p", "sys", "r", "es", "sam", "ls", "vs", "hs", "ms", "gs", "ats", "its", "js", "sa", "sp", "sts", "g", "sq", "sf", "sr", "self", "ds", "se", "cs", "ts", "is", "v", "stats", "qs", "parts", "ns", "ss"]}}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,\n\n                                           sPAPRMachineState *spapr,\n\n                                           uint32_t token, uint32_t nargs,\n\n                                           target_ulong args, uint32_t nret,\n\n                                           target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    PCIDevice *pdev;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n\n\n    if ((nargs != 4) || (nret != 2)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = rtas_ldq(args, 1);\n\n    sphb = spapr_pci_find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    if (!spapr_phb_eeh_available(sphb)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    /*\n\n     * We always have PE address of form \"00BB0001\". \"BB\"\n\n     * represents the bus number of PE's primary bus.\n\n     */\n\n    option = rtas_ld(args, 3);\n\n    switch (option) {\n\n    case RTAS_GET_PE_ADDR:\n\n        addr = rtas_ld(args, 0);\n\n        pdev = spapr_pci_find_dev(spapr, buid, addr);\n\n        if (!pdev) {\n\n            goto param_error_exit;\n\n        }\n\n\n\n        rtas_st(rets, 1, (pci_bus_num(pdev->bus) << 16) + 1);\n\n        break;\n\n    case RTAS_GET_PE_MODE:\n\n        rtas_st(rets, 1, RTAS_PE_MODE_SHARED);\n\n        break;\n\n    default:\n\n        goto param_error_exit;\n\n    }\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 15885, "substitutes": {"cpu": ["pkg", "pc", "gpu", "cli", "pu", "nu", " cp", "processor", "cp", "hw", "core", "cu", "pid", "np", "nice", "linux", "gp", "mem", "boot", "ctx", "gc", " proc", "proc", "CPU", "phys", "du", "process", "cow"], "spapr": ["smapr", "sparrt", "spapsr", "apapR", "spamprt", "smarr", "Spaprs", "spaprt", "spappr", "apappro", "apapprb", "spappR", "spapsro", "spapert", "spapprb", "Spapr", "spampor", "spapers", "spraprb", "smarrb", "spapprs", "Spapp", "spaprs", "spaprb", "spapp", "apaprb", "spipp", "sprapR", "spapep", "Spappp", "sparr", "spapsR", "apappr", "spapro", "spappp", "sparrb", "spipr", "spamprb", "sprapr", "Spappr", "Spapprs", "spaper", "smaprt", "spapeor", "sparor", "smarrt", "spampr", "smaror", "sprapro", "apappR", "apapro", "spapR", "spaperb", "apapr", "spappro", "spapor", "spapsrb", "smaprb", "smapor", "spiprs"], "token": ["event", "opt", "tn", "status", "json", "secret", "next", "random", "session", "password", "os", "root", "tree", "sys", "store", "callback", "aws", "features", "alt", "Token", "ok", "wt", "auth", "lock", "ts", "ens", "oken", "initialized"], "nargs": ["numargs", " nparams", "targ", "norparams", "gnarg", "norarg", "norargs", " nrows", "trows", "narg", "Narg", "numparams", "gnargs", "Nparams", "nparams", "numarg", "tparams", "gnparams", "norrows", "nrows", "targs", "gnrows", "numrows", "Nargs", "Nrows", " narg"], "args": ["nuts", "rs", "arms", "bytes", "ties", "settings", "keys", "terms", "flags", "als", "ires", "fields", "s", "es", "atts", "ls", "xs", "options", "ms", "aws", "gs", "urs", "its", "js", "uns", "ret", "ags", "facts", "vals", "rows", "frames", "roots", "gets", "arg", "ares", "ds", "icks", "cs", "ts", "tests", "uds", "bits", "cmd", "stats", "ins", "qs", "parts", "ras", "Args", "ns", "params", "uments"], "nret": ["numreturn", "numres", "nreturn", "Nres", "tret", "Nrets", "trets", " nRet", "nres", " nres", "tRet", "Nret", "treturn", " nrets", "nRet", "numrets", "numret", "NRet", "Nreturn", " nreturn", "nrets"], "rets": ["details", "fs", "urses", "rs", "RET", "ants", "ties", "fts", "ads", "terms", "ses", "runs", "results", "als", "ress", "ets", "els", "ires", "ails", "def", "outs", "fits", "ls", "aws", "urs", "gs", "events", "ats", "its", "uts", "des", "uns", "ret", "res", "vals", "rows", "tails", "ints", "gets", "acs", "ds", "uds", "states", "ts", "ards", "ocks", "rt", "bits", "unts", "qs", "aux", "ras", "ns", "lists", "tes", "sts"], "sphb": ["smphw", "sPhB", "smphr", "sPhb", "sphB", "sphrb", "sphe", "speh", "smph", "sphw", "sper", "speb", "gesphe", "sphp", "smphc", "smprb", "smphe", " sphrb", "shpc", "smphB", "sPhnb", "sephr", "sphnb", "saphp", "saphe", "shpp", "shpe", "sphr", " sphw", " sphr", "sperb", "sephnb", "sphh", "smpb", "gesphb", "sphalc", "sphalw", "sphalb", "saphb", " smphw", "geshpe", "sephb", "sephB", "geshpb", "shpw", " sphc", " smphb", "smphp", "geshpp", " sphh", " smphc", "smphnb", "shpb", "smpr", "sPhr", "sphc", "gesphp", "smphb"], "pdev": [" pdevice", "predev", "pdef", "pcdev", "Pev", "premem", "pvar", "pcden", "pconn", "ppdev", "pcmem", "PDev", "hvar", "hden", "Pdevice", "pDev", "pden", "ddev", "dDev", " pden", "ppconn", "pdevice", "Pdev", "Pconn", "pcvar", "predef", " pconn", " pDev", "pcdevice", " pdef", "predevice", " pvar", "ppev", "hdev", " pev", "ddevice", "ppdevice", " pmem", "pcdef", "pev", "hdevice", "pmem"], "addr": ["dist", "usr", "ord", "ref", "prefix", "address", "map", "opt", "ag", "Address", "ress", "hash", "ip", "adr", "alias", "loc", "arr", "err", "host", "ptr", "add", "tr", "dr", "handle", "port", "name", "news", "pos", "mem", "rev", "rc", "eth", "ack", "id", "url", "rn", "at", "ad", "offset", " address", "aro", "attr", "align", "ix", "pad", "rt", "cmd", "ace", "var", "arp"], "option": ["event", "category", "type", "prop", "package", "ption", "opt", "condition", "status", "style", "error", "value", "slot", "ion", "important", "offer", "weight", "alias", "change", "tag", "setting", "action", "key", "options", "name", "flag", "alt", "field", "choice", "attribute", "index", "mode", "op", "Option", "offset", "comment", "param", "feature", "sort", "function", "command", "TION", "term", "relation", "optional", "operation"], "buid": ["buId", " buId", "cuid", "buID", " buID", "bufId", "cuID", "ausId", "ausid", "bufid", "bufID", "uuID", " buids", "boId", "buuid", "boID", "BUID", " buuid", "uuids", "buids", "uuid", "uuId", "BUId", "BUid", "ausids", "boid", "uuuid", "ausuid", "cuId"]}}
{"project": "qemu", "commit_id": "a3fa1d78cbae2259491b17689812edcb643a3b30", "target": 0, "func": "static void migrate_fd_completed(MigrationState *s)\n\n{\n\n    DPRINTF(\"setting completed state\\n\");\n\n    migrate_fd_cleanup(s);\n\n    if (s->state == MIG_STATE_ACTIVE) {\n\n        s->state = MIG_STATE_COMPLETED;\n\n        runstate_set(RUN_STATE_POSTMIGRATE);\n\n    }\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n", "idx": 15890, "substitutes": {"s": ["bs", "details", "i", "h", "fs", "p", "rs", "sol", "sb", "serv", "sl", "z", "ses", "S", "os", "als", "state", "sv", "ps", "ss", "st", "eps", "an", "es", "sys", "set", "m", "store", "ls", "sports", "r", "hs", "aws", "gs", "ats", "b", "its", "js", "in", "w", "g", "sq", "sw", "less", "t", "ds", "se", "states", "cs", "ts", "is", "o", "south", "y", "stats", "ins", "qs", "v", "ns", "sts"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_adds_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tint size = memsize_z(dc);\n\n\tDIS(fprintf (logfile, \"adds.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(size),\n\n\t\t    dc->op1, dc->op2));\n\n\n\n\tcris_cc_mask(dc, CC_MASK_NZVC);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\t/* Size can only be qi or hi.  */\n\n\tt_gen_sext(t0, cpu_R[dc->op1], size);\n\n\tcris_alu(dc, CC_OP_ADD,\n\n\t\t    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 15897, "substitutes": {"dc": ["oc", "dl", "vc", "d", "kw", "dm", "pc", "bc", "dp", "DC", "di", "lc", "ctl", "draw", "cca", "cm", "c", "exec", "cu", "def", "mc", "df", "mic", "sys", "disc", "currency", "wp", "dr", "desc", "dim", " DC", "tc", "mac", "cc", "rc", "db", "ctx", "gc", "dd", "de", "central", "cus", "dir", "ci", "arc", "conn", "ic", "mm", "ec", "ds", "du", "nc", "fc", "cs", "sc", "ca", "ac", "rec", "cd", "doc", "dat", "da", "design", "co", "ga"], "t0": ["T0", "t2", "tempoval", "T4", "tn1", "T2", " Tnull", "temp2", "txt0", " t1", " tZero", "c5", "t1", " tnull", " t5", "tnoval", "tnull", "toval", "t2000", " T1", "T3", "c0", "tZero", "T5", " toval", " pt0", " pt1", " t2000", "tn0", "t3", " ptnull", "temp0", "temp1", " T0", "c1", "txt1", "tnZero", "c3", "T1", "t4", "TZero", "txt4", "Toval", " t2", " t3", "txt2000", "t5", "T2000", " t4"]}}
{"project": "FFmpeg", "commit_id": "02055b6d40d0cff867a9e41cad48edcaf6e10f2f", "target": 0, "func": "static void create_map(vorbis_context *vc, unsigned floor_number)\n\n{\n\n    vorbis_floor *floors = vc->floors;\n\n    vorbis_floor0 *vf;\n\n    int idx;\n\n    int blockflag, n;\n\n    int32_t *map;\n\n\n\n    for (blockflag = 0; blockflag < 2; ++blockflag) {\n\n        n = vc->blocksize[blockflag] / 2;\n\n        floors[floor_number].data.t0.map[blockflag] =\n\n            av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel\n\n\n\n        map =  floors[floor_number].data.t0.map[blockflag];\n\n        vf  = &floors[floor_number].data.t0;\n\n\n\n        for (idx = 0; idx < n; ++idx) {\n\n            map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *\n\n                             (vf->bark_map_size / BARK(vf->rate / 2.0f)));\n\n            if (vf->bark_map_size-1 < map[idx])\n\n                map[idx] = vf->bark_map_size - 1;\n\n        }\n\n        map[n] = -1;\n\n        vf->map_size[blockflag] = n;\n\n    }\n\n\n\n    for (idx = 0; idx <= n; ++idx) {\n\n        av_dlog(NULL, \"floor0 map: map at pos %d is %d\\n\", idx, map[idx]);\n\n    }\n\n}\n", "idx": 15906, "substitutes": {"vc": ["fp", "voc", "av", "pc", "vy", "bc", "lc", "conv", "dc", "nv", "xc", "c", "sv", "cu", "cp", "vd", "uv", "vec", "vl", "von", "vs", "vp", "vor", "cc", "vt", "vi", "lv", "ctx", "cv", "cf", "ct", "ic", "vv", "il", "vert", "vr", "fc", "nc", "cs", "wx", "v", "VC", "vm", "vo"], "floor_number": ["flo_num", "floorityNumber", "floor___year", "primeityway", "floor_length", "floortway", "floorptlength", "floorptNumber", "floor2byte", "floor_bridge", "floor_byte", "oral_given", "floor_given", "flo_byte", "floortnumber", "prime_Number", "flo_Number", "floorityway", "primeityNumber", "floor_Number", "floorablenumber", "floorityobject", "floorptyear", "oral_Number", " floor_year", "floor_way", "floor___number", "primeitynumber", "floor___Number", "prime_object", " floor_length", "flooritynumber", " floor_Number", "flo_number", "floorablegiven", "oral_number", "oral_bridge", "floortobject", "floorablebridge", "floor2number", "prime_way", "floorableNumber", "prime_number", "floorptnumber", "floortNumber", "floor_num", "floor_year", "floor2Number", "primeityobject", "floor_object", "floor2num", "floor___length"], "floors": [" floctors", "boctors", "boores", "floores", "floORS", " floers", "boORS", "Floor", "FloORS", "floours", "flers", " floores", "Floers", "Floators", "floers", "floctors", "Flovers", "loours", " floators", " floORS", "boors", "boor", "flors", "lovers", " flovers", "loors", "floators", "Floores", "loores", "Floors", "loers", "flores", "loctors", "boours", "flovers", "Floours", "boers", "Floctors", "flor", "boators"], "vf": ["hif", " vfa", "cvm", "vcf", " vcf", " vF", "visualfo", "visualf", "svcf", "ffc", "mcf", "vrfs", "svf", "avcf", "avif", "vF", " vfc", "avf", "cvfo", "fn", "hf", "cvf", "vh", "vfe", "evcf", "uvcf", "svfc", "uvif", "vm", " vn", "mf", "vn", "visualh", "vfs", "verf", "vrfe", "Vf", "vfa", "svfo", " vfo", "cvn", "vmfs", "fm", "vif", "vac", "hfc", "vef", "uvfc", "Vfa", " vac", " vm", "evif", "uvac", "cvcf", "vrfc", "vmfc", "vercf", "vfo", "avfo", "uvrf", "avF", "Vh", "verfo", " vfe", "ff", "visualfa", "uvf", " vif", "hac", "Vfo", "cvfc", "vmf", "mfc", "evfo", "vfc", " vfs", "vrf", "vefc", "verF", "evf", "vmfe", " vh", "vecf", "mrf"], "idx": ["ixe", "inix", "Idex", "idlex", "likexx", "Idix", " idlex", "tryinx", "likexes", "likex", "uidxe", " idz", "IDxy", " idix", "midxi", "pidx", "idxy", "pidy", "IDxf", " idxx", "likedx", "midx", "Idy", "uidex", "midix", "idindex", "identxf", "indx", "idinx", "ridxe", "idxa", "indxi", "ordx", "ix", "indlex", "idex", "identindex", "indinx", "inxx", "tryx", "IDex", "ordix", "ideex", "identix", "identx", "indz", " idy", "identxes", "inex", "identxa", " idex", "iix", "trylex", " idxes", "index", "ridx", "IDix", "midz", "tryix", "inx", "likeix", "idxe", "idz", "uidx", "ordz", "IDx", "ordxi", "idxf", " idxe", "iddx", "ridix", " idxf", "idy", "identxe", "indix", " idinx", "Idx", "uidix", "idexy", "indy", "ridex", " idindex", "pidex", "pidix", "likez", "idxx", "IDxa", "identdx", "Idz", " idxy", "idxes", "idxi", " idxa", "ideix", "IDindex", " iddx", "inz", "idix"], "blockflag": [" blockattribute", "isktag", "iskFlag", "lockattribute", "Blockflag", "bllag", "lockstyle", "blocksFlag", "blocklag", "busFlag", "busflag", "blockFlag", "labelFlag", "lockflags", "blockstyle", "chainlag", "labelattribute", "isklag", "locklag", "blockslag", "labellag", " blockflags", "blflag", "Blockflags", "blocktag", "chainflag", "lockFlag", "BlockFlag", "labelflag", "blocksflag", "blockattribute", "lockflag", "iskflag", "chainflags", " blockstyle", "busstyle", "blFlag", "blockflags", "chainFlag", " blockFlag", " blocktag", "Blocktag", " blocklag", "Blocklag"], "n": ["dn", "un", "i", "h", "d", "sn", "l", " N", "k", "nw", "x", "gn", "nan", "nu", "np", "number", "c", "ul", "cn", "p", "s", "an", "r", "nm", "m", "mn", "ne", "N", "name", "ln", "b", "nt", "names", "network", "no", "ng", "len", "na", "ni", "size", "g", "j", "nn", "num", "nor", "en", "nia", "nl", "nb", "t", "ll", "net", "nat", "nc", "o", "all", "v", "y", "f", "ns"], "map": ["Map", "view", "ash", "ap", "tree", "message", "ape", "add", "mem", "use", "show", "mm", "pack", "snap", "make", "ace", "stream", "pair", "cache", "MAP", "group", "hash", "filter", "set", "store", "m", "mb", "code", "buffer", "sp", "size", "cap", "ml", "open", "copy", "link", "metadata", "print", "mat", "form", "query", "one", "shape", "sum", "type", "ve", "app", "save", "replace", "node", "split", "ask", "allow", "pre", "pose", "batch", "cast", "where", "trace", "mp", "tap", "block", "index", "lock", "data", "max", "mt", "master", "mask", "search", "dict", "ip", "place", "result", "list", "embed", "collect", "mate", "window", "match", "transform", "load", "row", "maps", "write", "mount", "pad", "le", "table", "user", "grid"]}}
{"project": "qemu", "commit_id": "b6866fee58bc25b01485dcfcf8be44a915c5f573", "target": 0, "func": "static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,\n\n                                  VirtIOSCSIReq *req)\n\n{\n\n    assert(req->elem.out_num && req->elem.in_num);\n\n    req->vq = vq;\n\n    req->dev = s;\n\n    req->sreq = NULL;\n\n    req->req.buf = req->elem.out_sg[0].iov_base;\n\n    req->resp.buf = req->elem.in_sg[0].iov_base;\n\n\n\n    if (req->elem.out_num > 1) {\n\n        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],\n\n                               &req->elem.out_addr[1],\n\n                               req->elem.out_num - 1);\n\n    } else {\n\n        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],\n\n                               &req->elem.in_addr[1],\n\n                               req->elem.in_num - 1);\n\n    }\n\n}\n", "idx": 15911, "substitutes": {"s": ["i", "h", "fs", "d", "rs", "n", "x", "out", "S", "os", "c", "p", "sys", "r", "si", "m", "ms", "in", "e", "dev", "b", "js", "g", "sq", "t", "ds", "ts", "is", "a", "v", "f", "w", "ns", "ss"], "vq": ["vdq", "vispe", "Vue", "vqq", "veue", "quque", "vpe", "Vreq", "fue", "Vqq", " vdq", "vqu", " vue", "Vq", "veq", "lue", "quue", "visue", "visdq", "vequ", "fq", "lreq", "veque", "freq", "lqq", "ququ", "svue", "visq", "vque", "fque", "lq", "fqu", "vue", "fqq", "quq", "svpe", "vreq", "svq", " vpe", "svdq"], "req": ["pkg", "requ", "history", "cmp", "http", "org", "r", "urg", "push", "rd", "eq", "rr", "ret", "dep", "require", "quest", "expr", "debug", "inv", "worker", "usr", "rep", "temp", "init", "start", "pro", "cfg", "tek", "flow", "good", "repl", "request", "each", "res", "msg", "fr", "conn", "coord", "fee", "resp", "rw", "cmd", "form", "query", "rel", "ind", "jp", "etc", "compl", "buf", "tab", "q", "exec", "comm", "ext", "err", "decl", "sq", "range", "seq", "dq", "arg", "required", "work", "deg", "wcs", "pp", "rec", "var", "aux", "call", "iq", "dist", "ref", "comp", "progress", "tx", "task", "reg", "rpm", "conf", "p", "desc", "raw", "qq", "ctx", "spec", "load", "grab", "ctr", "attr", "test", "quick", "crit", "gr", "config", "wx", "rest", "qt"]}}
{"project": "qemu", "commit_id": "5eb6d9e3ef1fac096ab5b3f5c14e1f4079dd7367", "target": 0, "func": "static void usb_uas_task(UASDevice *uas, uas_ui *ui)\n\n{\n\n    uint16_t tag = be16_to_cpu(ui->hdr.tag);\n\n    uint64_t lun64 = be64_to_cpu(ui->task.lun);\n\n    SCSIDevice *dev = usb_uas_get_dev(uas, lun64);\n\n    int lun = usb_uas_get_lun(lun64);\n\n    UASRequest *req;\n\n    uint16_t task_tag;\n\n\n\n    req = usb_uas_find_request(uas, be16_to_cpu(ui->hdr.tag));\n\n    if (req) {\n\n        goto overlapped_tag;\n\n    }\n\n\n\n    switch (ui->task.function) {\n\n    case UAS_TMF_ABORT_TASK:\n\n        task_tag = be16_to_cpu(ui->task.task_tag);\n\n        trace_usb_uas_tmf_abort_task(uas->dev.addr, tag, task_tag);\n\n        if (dev == NULL) {\n\n            goto bad_target;\n\n        }\n\n        if (dev->lun != lun) {\n\n            goto incorrect_lun;\n\n        }\n\n        req = usb_uas_find_request(uas, task_tag);\n\n        if (req && req->dev == dev) {\n\n            scsi_req_cancel(req->req);\n\n        }\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);\n\n        break;\n\n\n\n    case UAS_TMF_LOGICAL_UNIT_RESET:\n\n        trace_usb_uas_tmf_logical_unit_reset(uas->dev.addr, tag, lun);\n\n        if (dev == NULL) {\n\n            goto bad_target;\n\n        }\n\n        if (dev->lun != lun) {\n\n            goto incorrect_lun;\n\n        }\n\n        qdev_reset_all(&dev->qdev);\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);\n\n        break;\n\n\n\n    default:\n\n        trace_usb_uas_tmf_unsupported(uas->dev.addr, tag, ui->task.function);\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_NOT_SUPPORTED, 0);\n\n        break;\n\n    }\n\n    return;\n\n\n\noverlapped_tag:\n\n    usb_uas_queue_response(uas, req->tag, UAS_RC_OVERLAPPED_TAG, 0);\n\n    return;\n\n\n\nbad_target:\n\n    /* FIXME: correct?  [see long comment in usb_uas_command()] */\n\n    usb_uas_queue_response(uas, tag, UAS_RC_INVALID_INFO_UNIT, 0);\n\n    return;\n\n\n\nincorrect_lun:\n\n    usb_uas_queue_response(uas, tag, UAS_RC_INCORRECT_LUN, 0);\n\n}\n", "idx": 15924, "substitutes": {"uas": ["ueasis", "ujaz", "puias", "uast", "uaser", "ouas", "ulaser", "cuas", "uats", "uuasha", "uuase", "uuis", "puaser", "ouap", "ueats", "tuaos", "uasm", "cuass", "uuasa", "uuacon", "uasha", "ulias", "uuasis", "tuase", "cuads", "ueaz", "uis", "ujAS", "uuaos", "ueAS", "puase", "uuades", "uades", "cuasis", "tuas", "uacon", "uuads", "uaos", "ouasis", "ueasm", "ouacon", "ueap", "uias", "uase", "ulas", " uasha", " uast", "uass", "uuap", "ueas", "uuass", "uuast", "ujas", "cuap", "puas", "ouasa", "tuasis", "puis", " uasm", "tuasa", "puass", "ueast", "puasha", "cuast", " uAS", " uaz", "cuasy", "uuas", "ueads", "uaz", "ujasm", "cuase", "uuaser", " uap", "ueasha", "tuasy", "ulaos", "uap", " uasis", "ulades", "tuacon", "tuades", "ulis", "uasis", "uAS", "cuasha", "ulasis", " uats", "ouats", "uasy", "uasa", "uads", "uuias", "uuasy"], "ui": ["i", "eu", "iq", "menu", "esi", "ii", "imi", "tu", "ali", "di", "sim", "ou", "cli", "util", "UI", "pu", "wu", "gu", "u", "cu", "uci", "hi", "ei", "si", "asu", "jac", "uni", "ia", "ami", "vi", "iu", "gru", "html", "uri", "zu", "uj", "ci", "ju", "lu", "ki", "eas", "ua", "agi", "zi", "au", "umi", "una", "gui", "mi", "api", "sup", "ini", "qt", "uu", "isu", "mu"], "dev": ["device", "med", "devices", "gu", "dest", "develop", "warn", "ptr", "mem", "des", "der", "dep", "sd", "den", "debug", "development", "adv", "vo", "d", "info", "prop", "serv", "temp", "del", "def", "tag", "jump", "tr", "pro", "vid", "env", "res", "disk", "conn", "dj", "enc", "comment", "cmd", "doc", "ve", "app", "off", "buf", "prom", "sys", "err", "cam", "disc", "nt", "de", "ev", "ad", "data", "max", "unknown", "det", "proc", "head", "val", "var", "wd", "pub", "dist", "dem", "priv", "DEV", "task", "go", "hw", "conf", "ver", "tech", "desc", "md", "db", " Dev", "Dev", "remote", "spec", "dd", "attr", "test", "pad", "v", "obj", "w"], "req": ["pkg", "requ", "need", "gz", "cmp", "Requ", "r", "urg", "ptr", "js", "rr", "tar", "dep", "require", "quest", "expr", "pr", "cr", "needed", "rem", "rep", "esp", "jump", "tek", "request", "res", "j", "fr", "msg", "fee", "resp", "cmd", "perm", "query", "friend", "rel", "ind", "jp", "pri", "q", "exec", "comm", " requ", "err", "seek", "rez", "ev", "seq", "dq", "required", "cond", "rec", "iq", "dist", "ref", "comp", "tx", "task", "cur", "reg", "rpm", "result", "rx", "desc", "qq", "ctx", "feat", "ctr", "attr", "quick", "crit", "gr", "wx", "qt"], "task_tag": ["ask_TAG", "taskingTag", "task2id", "taskzid", "ask_hash", "result_id", "task__match", "taskmatdat", "task2bug", "task2num", "task_cat", "taskztarget", "task_num", "result_target", "result_num", "resultztarget", "task_hash", "tasklytag", "taskingtag", "ask_tag", "tasklybit", "resultzid", "taskletbit", "task2tag", "tasklytags", "resultznum", "task__bug", "taskletstring", "ask_Tag", "task_id", " task_dat", "tasklystring", "task__tag", "tasklettags", " task_tags", "task_match", " task_code", "task_target", "task_dat", "task_TAG", "ask_cat", "taskmatcode", "taskztag", "task_bug", "taskmattags", "taskingcat", "ask_match", "task_string", " task_bit", "task__TAG", " task_string", "task2target", "task_Tag", "taskznum", "task_tags", "resultztag", "taskinghash", "task2TAG", "result_tag", "taskmattag", "task_code", "task_bit", "ask_bug", "task2match", "tasklettag"]}}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)\n\n{\n\n    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);\n\n    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);\n\n    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);\n\n\n\n    if (!dev->conf.dinfo) {\n\n        fprintf(stderr, \"%s: no drive specified\\n\", qdev->info->name);\n\n        goto err;\n\n    }\n\n    if (dev->unit == -1) {\n\n        dev->unit = bus->master ? 1 : 0;\n\n    }\n\n    switch (dev->unit) {\n\n    case 0:\n\n        if (bus->master) {\n\n            fprintf(stderr, \"ide: tried to assign master twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->master = dev;\n\n        break;\n\n    case 1:\n\n        if (bus->slave) {\n\n            fprintf(stderr, \"ide: tried to assign slave twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->slave = dev;\n\n        break;\n\n    default:\n\n        goto err;\n\n    }\n\n    return info->init(dev);\n\n\n\nerr:\n\n    return -1;\n\n}\n", "idx": 15929, "substitutes": {"qdev": ["eqvar", "qublock", " qdef", "qbus", "eqblock", "quDev", "quev", "qqblock", " qDev", "qqvar", "qupad", "dqdef", "sqpad", "eqdev", "qdevice", "sqdev", "qvar", " qev", "Qdev", "quvar", "qpad", "sqvar", "questdev", "qudef", "questbus", "sqDev", "qudev", "qqserv", "Qev", "qubus", "sqev", "qblock", "qDev", "qqbus", "sqdef", "eqpad", "qqpad", "qudevice", " qvar", "Qserv", "qdef", "dqdev", " qserv", " qdevice", "qqev", "qqdef", "dqpad", "dqev", "qqdev", "qev", "questpad", "qserv", "dqdevice", "questblock", "Qdef", "dqDev"], "base": ["i", "h", "type", "Base", "parent", "extra", "server", "local", "out", "create", "check", "set", "family", "p", "raw", "name", "based", "b", "common", "buffer", "basic", "unit", "id", "bas", "use", "show", "help", "normal", "used", "ase", "file", "kb", "f", "bi", "ui", "profile"], "dev": ["device", "av", "gu", "patch", "develop", "scan", "mem", "des", "der", "dep", "pack", "debug", "vo", "event", "prov", "prop", "end", "serv", "draw", "util", "train", "del", "def", "pro", "env", "res", "disk", "conn", "van", "cmd", "form", "doc", "ve", "app", "di", "die", "off", "serial", "buf", "loc", "cam", "cast", "nt", "de", "ev", "ad", "data", "unknown", "det", "val", "stick", "var", "wd", "dem", "DEV", "priv", "tx", "go", "local", "hw", "conf", "ver", "tech", "desc", "raw", "db", "Dev", "spec", "cho", "watch", "dis", "test", "pad", "v", "obj", "build"], "info": ["details", "kind", "inf", "sum", "py", "type", "bar", "time", "extra", "app", "status", "di", "history", "out", "os", "init", "INFO", "about", "conf", "hi", "def", "si", "fo", "Info", "key", "name", "mem", "in", "iter", "buffer", "block", "fi", "spec", "index", "to", "op", "inner", "id", "it", "ci", "data", "det", " inf", "ki", "order", "file", "api", "config", "is", "val", "f", "by", "doc", "io"], "bus": ["bs", "rel", "cache", "prop", "parent", "hub", "bc", "local", "group", "util", "pool", "buf", "boot", "train", "bridge", "hand", "alias", "loc", "store", "host", "cast", "us", "where", "bo", "pos", "box", "db", "book", "block", "bolt", "chain", "loop", "buffer", "ack", "home", "back", "lock", "disk", "data", "board", "driver", "bug", "test", "proxy", "vol", "Bus", "lib", "mount", "BUS", "master", "stick", "sync", "aux"]}}
{"project": "qemu", "commit_id": "b2c98d9d392c87c9b9e975d30f79924719d9cbbe", "target": 0, "func": "static int tcg_match_ori(TCGType type, tcg_target_long val)\n\n{\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        if (type == TCG_TYPE_I32) {\n\n            /* All 32-bit ORs can be performed with 1 48-bit insn.  */\n\n            return 1;\n\n        }\n\n    }\n\n\n\n    /* Look for negative values.  These are best to load with LGHI.  */\n\n    if (val < 0) {\n\n        if (val == (int16_t)val) {\n\n            return 0;\n\n        }\n\n        if (facilities & FACILITY_EXT_IMM) {\n\n            if (val == (int32_t)val) {\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 15943, "substitutes": {"type": ["kind", "role", "info", "pe", "ty", "time", "style", "error", "state", "otype", "ver", "Type", "p", "family", "key", "name", "port", "tp", "rule", "ype", "id", "range", "ct", "inter", "like", "class", "t", "typ", "test", "tool", "file", "types", "y", "base", "var", "length", "ping", "TYPE"], "val": [" value", "eval", "status", "nil", "valid", "unit", "it", "vals", "grad", "pr", "prop", "sol", "slot", "def", "ele", "vt", "res", "aval", "fail", "t", " x", "stat", " ty", "rel", " Val", "l", "pol", "x", "value", "buf", "old", "pl", "loc", "err", "update", "alt", "al", " v", " arg", " aval", "item", "arg", "viol", "cal", "Val", " interval", "elt", "point", "tx", "bil", " l", "sel", "p", "VAL", "ival", " eval", "dev", "iter", "xy", "cho", "el", "func", "rol", "test", "vol", "crit", "v"]}}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "void OPPROTO op_addq_EDI_T0(void)\n\n{\n\n    EDI = (EDI + T0);\n\n}\n", "idx": 15962, "substitutes": {}}
{"project": "qemu", "commit_id": "af08a58f0ca338eafee855921859a8c1ace0175b", "target": 0, "func": "static void hypercall_register_types(void)\n\n{\n\n    /* hcall-pft */\n\n    spapr_register_hypercall(H_ENTER, h_enter);\n\n    spapr_register_hypercall(H_REMOVE, h_remove);\n\n    spapr_register_hypercall(H_PROTECT, h_protect);\n\n    spapr_register_hypercall(H_READ, h_read);\n\n\n\n    /* hcall-bulk */\n\n    spapr_register_hypercall(H_BULK_REMOVE, h_bulk_remove);\n\n\n\n    /* hcall-dabr */\n\n    spapr_register_hypercall(H_SET_DABR, h_set_dabr);\n\n\n\n    /* hcall-splpar */\n\n    spapr_register_hypercall(H_REGISTER_VPA, h_register_vpa);\n\n    spapr_register_hypercall(H_CEDE, h_cede);\n\n\n\n    /* processor register resource access h-calls */\n\n    spapr_register_hypercall(H_SET_SPRG0, h_set_sprg0);\n\n    spapr_register_hypercall(H_SET_MODE, h_set_mode);\n\n\n\n    /* \"debugger\" hcalls (also used by SLOF). Note: We do -not- differenciate\n\n     * here between the \"CI\" and the \"CACHE\" variants, they will use whatever\n\n     * mapping attributes qemu is using. When using KVM, the kernel will\n\n     * enforce the attributes more strongly\n\n     */\n\n    spapr_register_hypercall(H_LOGICAL_CI_LOAD, h_logical_load);\n\n    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);\n\n    spapr_register_hypercall(H_LOGICAL_CACHE_LOAD, h_logical_load);\n\n    spapr_register_hypercall(H_LOGICAL_CACHE_STORE, h_logical_store);\n\n    spapr_register_hypercall(H_LOGICAL_ICBI, h_logical_icbi);\n\n    spapr_register_hypercall(H_LOGICAL_DCBF, h_logical_dcbf);\n\n    spapr_register_hypercall(KVMPPC_H_LOGICAL_MEMOP, h_logical_memop);\n\n\n\n    /* qemu/KVM-PPC specific hcalls */\n\n    spapr_register_hypercall(KVMPPC_H_RTAS, h_rtas);\n\n\n\n    /* ibm,client-architecture-support support */\n\n    spapr_register_hypercall(KVMPPC_H_CAS, h_client_architecture_support);\n\n}\n", "idx": 15965, "substitutes": {}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n    BlockConf *conf = &s->conf.conf;\n\n    struct virtio_blk_config blkcfg;\n\n    uint64_t capacity;\n\n    int blk_size = conf->logical_block_size;\n\n\n\n    bdrv_get_geometry(s->bs, &capacity);\n\n    memset(&blkcfg, 0, sizeof(blkcfg));\n\n    virtio_stq_p(vdev, &blkcfg.capacity, capacity);\n\n    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);\n\n    virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls);\n\n    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);\n\n    virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size / blk_size);\n\n    virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);\n\n    blkcfg.heads = conf->heads;\n\n    /*\n\n     * We must ensure that the block device capacity is a multiple of\n\n     * the logical block size. If that is not the case, let's use\n\n     * sector_mask to adopt the geometry to have a correct picture.\n\n     * For those devices where the capacity is ok for the given geometry\n\n     * we don't touch the sector value of the geometry, since some devices\n\n     * (like s390 dasd) need a specific value. Here the capacity is already\n\n     * cyls*heads*secs*blk_size and the sector value is not block size\n\n     * divided by 512 - instead it is the amount of blk_size blocks\n\n     * per track (cylinder).\n\n     */\n\n    if (bdrv_getlength(s->bs) /  conf->heads / conf->secs % blk_size) {\n\n        blkcfg.sectors = conf->secs & ~s->sector_mask;\n\n    } else {\n\n        blkcfg.sectors = conf->secs;\n\n    }\n\n    blkcfg.size_max = 0;\n\n    blkcfg.physical_block_exp = get_physical_block_exp(conf);\n\n    blkcfg.alignment_offset = 0;\n\n    blkcfg.wce = bdrv_enable_write_cache(s->bs);\n\n    memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));\n\n}\n", "idx": 15977, "substitutes": {"vdev": [" vdevice", "uvserial", "mrad", "voldev", "uvdes", "wdb", "volserver", "vmdiv", "vhost", "vmend", "volver", " vaddr", " vend", "vmdevice", " vrad", "vtdevice", "vde", "vtdb", "vmhost", "vaddr", "vdiv", "vdes", " vver", " vserver", " vdiv", "uvdev", "vdat", "vmdev", "mdev", " vhost", "uvdat", " vbus", "vtver", "vserial", "vmde", "uvaddr", "uvenv", " vpro", "vdb", "vmserial", "hdev", "vcdevice", "veraddr", "vtdev", "mdevice", "uvver", "verdes", "vpro", " vde", "vcbus", "wcam", "uvpro", "vtloc", "volenv", " venv", "uvend", "hdiv", "vend", "vcdev", "hhost", "vmdat", "vserver", "vmpad", " vcam", "uvde", "vdevice", "wdev", "venv", " vpad", " vdes", "vbus", "verdev", " vdat", "vloc", "vtdat", "uvserver", "wdevice", " vdb", "vpad", "verpro", "vmenv", "vrad", "vtcam", "vcrad", "uvloc", " vserial", "uvpad", " vloc", "vcam", "mbus", "hdevice", "vver"], "config": ["info", "cache", "con", "fig", "map", "settings", "bc", "content", "out", "dc", "etc", "input", "c", "m", "cfg", "storage", "options", "tc", "count", "buffer", "rc", "cont", "cf", "data", "conn", "ct", "comment", "ic", "t", "fc", "sc", "cmd", "Config", "ac", "text", "f", "command"], "s": ["bs", "i", "h", "fs", "d", "rs", "sb", "n", "serv", "app", "settings", "ses", "conv", "sim", "S", "os", "service", "c", "sv", "ps", "comm", "p", "sys", "r", "m", "ls", "hs", "gs", "b", "its", "js", "sp", "sts", "spec", "g", "j", "sq", "t", "self", "ds", "ts", "is", "a", "v", "stats", "y", "f", "qs", "ins", "w", "ns", "ss"], "conf": ["rank", "ch", "fs", "map", "bc", "conv", "fre", "cmp", "cm", "cp", "cb", "core", "check", "scan", "aff", "pb", "param", "ca", "Conf", "info", "cache", "con", "prop", "serv", " cz", " Conf", "def", "cfg", "cf", "cap", "conn", "comment", "lib", "cmd", "f", "command", "query", "ns", "inf", "fam", "app", "fg", "dc", "c", "exec", "comm", "err", "disc", "cast", "irm", "com", "block", "range", "acc", "can", "cal", "ref", "comp", "priv", "go", "confirmed", "state", "share", "cons", "p", "dev", "db", "ctx", "spec", "nav", "crit"], "blkcfg": ["blkwfg", "blakmsg", "blvbg", "blkcf", " blckcf", "blckimg", "blickconfig", "blvfg", "blKconf", "bltkcmd", "bltkconn", "blikfg", "blkerfg", "blkconf", "blekcfg", "blkmsg", "blkerinit", "blncf", "blmkmsg", "blekfg", "blckconf", "blckconfig", "bleckcss", "plkconf", " blkbg", "blkercmd", "blkkcss", "bleckcmd", "blakgz", "blackfg", "blkerconn", "blkcgi", "blckconn", " blkcmd", "blkkcmd", "blKfg", "blKcss", "bleckcfg", "blekgc", "blackcfg", "blekcgi", "blikbg", " blckcss", "blmkcgi", "blickfg", "blakcmd", "plkfg", "blakconfig", "blkkcfg", "blckinit", " blckmsg", " blckcb", "blkconn", "blkercfg", " blkfg", "plkcfg", "bltkcfg", "blkwbg", "bleckcgi", "blvcfg", "blkwcf", "blunkimg", "blmkcfg", "blikimg", " blckconfig", "blkbg", " blkgz", "blakcf", "blnfg", "blckmsg", "blckcf", "blkwcfg", " blckfg", " blckimg", "blkkcf", "blikinit", " blckgz", "blickgc", "blakfg", "blKcf", "blkwconn", "blckgz", "blkcmd", " blkinit", "bleckcf", "blKconfig", "blckgc", "blunkcfg", " blkcss", "blkcb", "blckercfg", "blekconfig", "blekmsg", "blkkconf", "blakcfg", "blKgc", " blckconf", "blckerconfig", "blakcgi", "blkkmsg", "blunkfg", "blunkcmd", "blkgz", "blekcss", " blckinit", "blakconf", "blunkbg", "blikcmd", " blkconn", "blvcmd", "bleckmsg", " blkimg", "blekcf", "blkgc", "blackcf", "blKcfg", "blekgz", "blncfg", " blkconfig", " blckconn", " blkcf", "blkkcb", "blickcfg", " blkcb", "blkimg", "blckfg", "blckcss", "blkcss", "blkfg", "bleckconf", "blnconfig", "blckcfg", " blckbg", "blkwcmd", "blikcfg", "blkinit", "blekcmd", " blkmsg", "bltkcss", " blckcfg", "blckercss", "bleckgc", "bltkfg", "blckcb", "blkconfig", " blckcmd", "bleckfg", "blackconn", "blckbg", "blckerfg", "blkkfg", "blckcmd", "bltkcb", "blekconf", "bleckconfig", "blckcgi", "blmkfg", "plkmsg", " blkconf"], "capacity": ["shape", "abilities", "power", "type", "largest", "acity", "ption", "condition", "SIZE", "status", "bc", "capital", "history", "alloc", "slave", "devices", " Capacity", "sequence", "slot", "units", "lc", "usage", "density", "c", "dest", "city", "available", "currency", "position", "ape", "height", "growth", "pieces", "demand", "CAP", "cci", "powers", "ENGTH", "count", "buffer", "generation", "volume", "spec", "region", "size", "VERSION", "cap", "ci", "uration", "max", "character", "clus", " capacities", "command", "length"]}}
{"project": "qemu", "commit_id": "aea14095ea91f792ee43ee52fe6032cd8cdd7190", "target": 0, "func": "static void decode_opc (CPUMIPSState *env, DisasContext *ctx)\n\n{\n\n    int32_t offset;\n\n    int rs, rt, rd, sa;\n\n    uint32_t op, op1;\n\n    int16_t imm;\n\n\n\n    /* make sure instructions are on a word boundary */\n\n    if (ctx->pc & 0x3) {\n\n        env->CP0_BadVAddr = ctx->pc;\n\n        generate_exception(ctx, EXCP_AdEL);\n\n        return;\n\n    }\n\n\n\n    /* Handle blikely not taken case */\n\n    if ((ctx->hflags & MIPS_HFLAG_BMASK_BASE) == MIPS_HFLAG_BL) {\n\n        int l1 = gen_new_label();\n\n\n\n        MIPS_DEBUG(\"blikely condition (\" TARGET_FMT_lx \")\", ctx->pc + 4);\n\n        tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n        tcg_gen_movi_i32(hflags, ctx->hflags & ~MIPS_HFLAG_BMASK);\n\n        gen_goto_tb(ctx, 1, ctx->pc + 4);\n\n        gen_set_label(l1);\n\n    }\n\n\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n        tcg_gen_debug_insn_start(ctx->pc);\n\n    }\n\n\n\n    op = MASK_OP_MAJOR(ctx->opcode);\n\n    rs = (ctx->opcode >> 21) & 0x1f;\n\n    rt = (ctx->opcode >> 16) & 0x1f;\n\n    rd = (ctx->opcode >> 11) & 0x1f;\n\n    sa = (ctx->opcode >> 6) & 0x1f;\n\n    imm = (int16_t)ctx->opcode;\n\n    switch (op) {\n\n    case OPC_SPECIAL:\n\n        decode_opc_special(env, ctx);\n\n        break;\n\n    case OPC_SPECIAL2:\n\n        decode_opc_special2_legacy(env, ctx);\n\n        break;\n\n    case OPC_SPECIAL3:\n\n        decode_opc_special3(env, ctx);\n\n        break;\n\n    case OPC_REGIMM:\n\n        op1 = MASK_REGIMM(ctx->opcode);\n\n        switch (op1) {\n\n        case OPC_BLTZL: /* REGIMM branches */\n\n        case OPC_BGEZL:\n\n        case OPC_BLTZALL:\n\n        case OPC_BGEZALL:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        case OPC_BLTZ:\n\n        case OPC_BGEZ:\n\n            gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);\n\n            break;\n\n        case OPC_BLTZAL:\n\n        case OPC_BGEZAL:\n\n            if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                if (rs == 0) {\n\n                    /* OPC_NAL, OPC_BAL */\n\n                    gen_compute_branch(ctx, op1, 4, 0, -1, imm << 2, 4);\n\n                } else {\n\n                    generate_exception(ctx, EXCP_RI);\n\n                }\n\n            } else {\n\n                gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);\n\n            }\n\n            break;\n\n        case OPC_TGEI ... OPC_TEQI: /* REGIMM traps */\n\n        case OPC_TNEI:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            gen_trap(ctx, op1, rs, -1, imm);\n\n            break;\n\n        case OPC_SYNCI:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            /* Break the TB to be able to sync copied instructions\n\n               immediately */\n\n            ctx->bstate = BS_STOP;\n\n            break;\n\n        case OPC_BPOSGE32:    /* MIPS DSP branch */\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_BPOSGE64:\n\n#endif\n\n            check_dsp(ctx);\n\n            gen_compute_branch(ctx, op1, 4, -1, -2, (int32_t)imm << 2, 4);\n\n            break;\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DAHI:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            check_mips_64(ctx);\n\n            if (rs != 0) {\n\n                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 32);\n\n            }\n\n            MIPS_DEBUG(\"dahi %s, %04x\", regnames[rs], imm);\n\n            break;\n\n        case OPC_DATI:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            check_mips_64(ctx);\n\n            if (rs != 0) {\n\n                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 48);\n\n            }\n\n            MIPS_DEBUG(\"dati %s, %04x\", regnames[rs], imm);\n\n            break;\n\n#endif\n\n        default:            /* Invalid */\n\n            MIPS_INVAL(\"regimm\");\n\n            generate_exception(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case OPC_CP0:\n\n        check_cp0_enabled(ctx);\n\n        op1 = MASK_CP0(ctx->opcode);\n\n        switch (op1) {\n\n        case OPC_MFC0:\n\n        case OPC_MTC0:\n\n        case OPC_MFTR:\n\n        case OPC_MTTR:\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DMFC0:\n\n        case OPC_DMTC0:\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n            gen_cp0(env, ctx, op1, rt, rd);\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_C0_FIRST ... OPC_C0_LAST:\n\n#ifndef CONFIG_USER_ONLY\n\n            gen_cp0(env, ctx, MASK_C0(ctx->opcode), rt, rd);\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_MFMC0:\n\n#ifndef CONFIG_USER_ONLY\n\n            {\n\n                uint32_t op2;\n\n                TCGv t0 = tcg_temp_new();\n\n\n\n                op2 = MASK_MFMC0(ctx->opcode);\n\n                switch (op2) {\n\n                case OPC_DMT:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_dmt(t0);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_EMT:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_emt(t0);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_DVPE:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_dvpe(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_EVPE:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_evpe(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_DI:\n\n                    check_insn(ctx, ISA_MIPS32R2);\n\n                    save_cpu_state(ctx, 1);\n\n                    gen_helper_di(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    /* Stop translation as we may have switched the execution mode */\n\n                    ctx->bstate = BS_STOP;\n\n                    break;\n\n                case OPC_EI:\n\n                    check_insn(ctx, ISA_MIPS32R2);\n\n                    save_cpu_state(ctx, 1);\n\n                    gen_helper_ei(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    /* Stop translation as we may have switched the execution mode */\n\n                    ctx->bstate = BS_STOP;\n\n                    break;\n\n                default:            /* Invalid */\n\n                    MIPS_INVAL(\"mfmc0\");\n\n                    generate_exception(ctx, EXCP_RI);\n\n                    break;\n\n                }\n\n                tcg_temp_free(t0);\n\n            }\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_RDPGPR:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_load_srsgpr(rt, rd);\n\n            break;\n\n        case OPC_WRPGPR:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_store_srsgpr(rt, rd);\n\n            break;\n\n        default:\n\n            MIPS_INVAL(\"cp0\");\n\n            generate_exception(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case OPC_BOVC: /* OPC_BEQZALC, OPC_BEQC, OPC_ADDI */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BOVC, OPC_BEQZALC, OPC_BEQC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_ADDI */\n\n            /* Arithmetic with immediate opcode */\n\n            gen_arith_imm(ctx, op, rt, rs, imm);\n\n        }\n\n        break;\n\n    case OPC_ADDIU:\n\n         gen_arith_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SLTI: /* Set on less than with immediate opcode */\n\n    case OPC_SLTIU:\n\n         gen_slt_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_ANDI: /* Arithmetic with immediate opcode */\n\n    case OPC_LUI: /* OPC_AUI */\n\n    case OPC_ORI:\n\n    case OPC_XORI:\n\n         gen_logic_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_J ... OPC_JAL: /* Jump */\n\n         offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n         gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n         break;\n\n    /* Branch */\n\n    case OPC_BLEZC: /* OPC_BGEZC, OPC_BGEC, OPC_BLEZL */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rt == 0) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            /* OPC_BLEZC, OPC_BGEZC, OPC_BGEC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_BLEZL */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        }\n\n        break;\n\n    case OPC_BGTZC: /* OPC_BLTZC, OPC_BLTC, OPC_BGTZL */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rt == 0) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            /* OPC_BGTZC, OPC_BLTZC, OPC_BLTC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_BGTZL */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        }\n\n        break;\n\n    case OPC_BLEZALC: /* OPC_BGEZALC, OPC_BGEUC, OPC_BLEZ */\n\n        if (rt == 0) {\n\n            /* OPC_BLEZ */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        } else {\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            /* OPC_BLEZALC, OPC_BGEZALC, OPC_BGEUC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        }\n\n        break;\n\n    case OPC_BGTZALC: /* OPC_BLTZALC, OPC_BLTUC, OPC_BGTZ */\n\n        if (rt == 0) {\n\n            /* OPC_BGTZ */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        } else {\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            /* OPC_BGTZALC, OPC_BLTZALC, OPC_BLTUC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        }\n\n        break;\n\n    case OPC_BEQL:\n\n    case OPC_BNEL:\n\n         check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_BEQ:\n\n    case OPC_BNE:\n\n         gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n         break;\n\n    case OPC_LWL: /* Load and stores */\n\n    case OPC_LWR:\n\n    case OPC_LL:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_LB ... OPC_LH:\n\n    case OPC_LW ... OPC_LHU:\n\n         gen_ld(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SWL:\n\n    case OPC_SWR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_SB ... OPC_SH:\n\n    case OPC_SW:\n\n         gen_st(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SC:\n\n         check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n         gen_st_cond(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_CACHE:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_cp0_enabled(ctx);\n\n        check_insn(ctx, ISA_MIPS3 | ISA_MIPS32);\n\n        /* Treat as NOP. */\n\n        break;\n\n    case OPC_PREF:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_insn(ctx, ISA_MIPS4 | ISA_MIPS32);\n\n        /* Treat as NOP. */\n\n        break;\n\n\n\n    /* Floating point (COP1). */\n\n    case OPC_LWC1:\n\n    case OPC_LDC1:\n\n    case OPC_SWC1:\n\n    case OPC_SDC1:\n\n        gen_cop1_ldst(ctx, op, rt, rs, imm);\n\n        break;\n\n\n\n    case OPC_CP1:\n\n        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {\n\n            check_cp1_enabled(ctx);\n\n            op1 = MASK_CP1(ctx->opcode);\n\n            switch (op1) {\n\n            case OPC_MFHC1:\n\n            case OPC_MTHC1:\n\n                check_insn(ctx, ISA_MIPS32R2);\n\n            case OPC_MFC1:\n\n            case OPC_CFC1:\n\n            case OPC_MTC1:\n\n            case OPC_CTC1:\n\n                gen_cp1(ctx, op1, rt, rd);\n\n                break;\n\n#if defined(TARGET_MIPS64)\n\n            case OPC_DMFC1:\n\n            case OPC_DMTC1:\n\n                check_insn(ctx, ISA_MIPS3);\n\n                gen_cp1(ctx, op1, rt, rd);\n\n                break;\n\n#endif\n\n            case OPC_BC1EQZ: /* OPC_BC1ANY2 */\n\n                if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                    /* OPC_BC1EQZ */\n\n                    gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),\n\n                                    rt, imm << 2);\n\n                } else {\n\n                    /* OPC_BC1ANY2 */\n\n                    check_cop1x(ctx);\n\n                    check_insn(ctx, ASE_MIPS3D);\n\n                    gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),\n\n                                    (rt >> 2) & 0x7, imm << 2);\n\n                }\n\n                break;\n\n            case OPC_BC1NEZ:\n\n                check_insn(ctx, ISA_MIPS32R6);\n\n                gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),\n\n                                rt, imm << 2);\n\n                break;\n\n            case OPC_BC1ANY4:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n                check_cop1x(ctx);\n\n                check_insn(ctx, ASE_MIPS3D);\n\n                /* fall through */\n\n            case OPC_BC1:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n                gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),\n\n                                    (rt >> 2) & 0x7, imm << 2);\n\n                break;\n\n            case OPC_PS_FMT:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            case OPC_S_FMT:\n\n            case OPC_D_FMT:\n\n                gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                           (imm >> 8) & 0x7);\n\n                break;\n\n            case OPC_W_FMT:\n\n            case OPC_L_FMT:\n\n            {\n\n                int r6_op = ctx->opcode & FOP(0x3f, 0x1f);\n\n                if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                    switch (r6_op) {\n\n                    case R6_OPC_CMP_AF_S:\n\n                    case R6_OPC_CMP_UN_S:\n\n                    case R6_OPC_CMP_EQ_S:\n\n                    case R6_OPC_CMP_UEQ_S:\n\n                    case R6_OPC_CMP_LT_S:\n\n                    case R6_OPC_CMP_ULT_S:\n\n                    case R6_OPC_CMP_LE_S:\n\n                    case R6_OPC_CMP_ULE_S:\n\n                    case R6_OPC_CMP_SAF_S:\n\n                    case R6_OPC_CMP_SUN_S:\n\n                    case R6_OPC_CMP_SEQ_S:\n\n                    case R6_OPC_CMP_SEUQ_S:\n\n                    case R6_OPC_CMP_SLT_S:\n\n                    case R6_OPC_CMP_SULT_S:\n\n                    case R6_OPC_CMP_SLE_S:\n\n                    case R6_OPC_CMP_SULE_S:\n\n                    case R6_OPC_CMP_OR_S:\n\n                    case R6_OPC_CMP_UNE_S:\n\n                    case R6_OPC_CMP_NE_S:\n\n                    case R6_OPC_CMP_SOR_S:\n\n                    case R6_OPC_CMP_SUNE_S:\n\n                    case R6_OPC_CMP_SNE_S:\n\n                        gen_r6_cmp_s(ctx, ctx->opcode & 0x1f, rt, rd, sa);\n\n                        break;\n\n                    case R6_OPC_CMP_AF_D:\n\n                    case R6_OPC_CMP_UN_D:\n\n                    case R6_OPC_CMP_EQ_D:\n\n                    case R6_OPC_CMP_UEQ_D:\n\n                    case R6_OPC_CMP_LT_D:\n\n                    case R6_OPC_CMP_ULT_D:\n\n                    case R6_OPC_CMP_LE_D:\n\n                    case R6_OPC_CMP_ULE_D:\n\n                    case R6_OPC_CMP_SAF_D:\n\n                    case R6_OPC_CMP_SUN_D:\n\n                    case R6_OPC_CMP_SEQ_D:\n\n                    case R6_OPC_CMP_SEUQ_D:\n\n                    case R6_OPC_CMP_SLT_D:\n\n                    case R6_OPC_CMP_SULT_D:\n\n                    case R6_OPC_CMP_SLE_D:\n\n                    case R6_OPC_CMP_SULE_D:\n\n                    case R6_OPC_CMP_OR_D:\n\n                    case R6_OPC_CMP_UNE_D:\n\n                    case R6_OPC_CMP_NE_D:\n\n                    case R6_OPC_CMP_SOR_D:\n\n                    case R6_OPC_CMP_SUNE_D:\n\n                    case R6_OPC_CMP_SNE_D:\n\n                        gen_r6_cmp_d(ctx, ctx->opcode & 0x1f, rt, rd, sa);\n\n                        break;\n\n                    default:\n\n                        gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                                                       (imm >> 8) & 0x7);\n\n                        break;\n\n                    }\n\n                } else {\n\n                    gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                               (imm >> 8) & 0x7);\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                MIPS_INVAL(\"cp1\");\n\n                generate_exception (ctx, EXCP_RI);\n\n                break;\n\n            }\n\n        } else {\n\n            generate_exception_err(ctx, EXCP_CpU, 1);\n\n        }\n\n        break;\n\n\n\n    /* Compact branches [R6] and COP2 [non-R6] */\n\n    case OPC_BC: /* OPC_LWC2 */\n\n    case OPC_BALC: /* OPC_SWC2 */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BC, OPC_BALC */\n\n            gen_compute_compact_branch(ctx, op, 0, 0,\n\n                                       sextract32(ctx->opcode << 2, 0, 28));\n\n        } else {\n\n            /* OPC_LWC2, OPC_SWC2 */\n\n            /* COP2: Not implemented. */\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n        }\n\n        break;\n\n    case OPC_BEQZC: /* OPC_JIC, OPC_LDC2 */\n\n    case OPC_BNEZC: /* OPC_JIALC, OPC_SDC2 */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rs != 0) {\n\n                /* OPC_BEQZC, OPC_BNEZC */\n\n                gen_compute_compact_branch(ctx, op, rs, 0,\n\n                                           sextract32(ctx->opcode << 2, 0, 23));\n\n            } else {\n\n                /* OPC_JIC, OPC_JIALC */\n\n                gen_compute_compact_branch(ctx, op, 0, rt, imm);\n\n            }\n\n        } else {\n\n            /* OPC_LWC2, OPC_SWC2 */\n\n            /* COP2: Not implemented. */\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n        }\n\n        break;\n\n    case OPC_CP2:\n\n        check_insn(ctx, INSN_LOONGSON2F);\n\n        /* Note that these instructions use different fields.  */\n\n        gen_loongson_multimedia(ctx, sa, rd, rt);\n\n        break;\n\n\n\n    case OPC_CP3:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {\n\n            check_cp1_enabled(ctx);\n\n            op1 = MASK_CP3(ctx->opcode);\n\n            switch (op1) {\n\n            case OPC_LWXC1:\n\n            case OPC_LDXC1:\n\n            case OPC_LUXC1:\n\n            case OPC_SWXC1:\n\n            case OPC_SDXC1:\n\n            case OPC_SUXC1:\n\n                gen_flt3_ldst(ctx, op1, sa, rd, rs, rt);\n\n                break;\n\n            case OPC_PREFX:\n\n                /* Treat as NOP. */\n\n                break;\n\n            case OPC_ALNV_PS:\n\n            case OPC_MADD_S:\n\n            case OPC_MADD_D:\n\n            case OPC_MADD_PS:\n\n            case OPC_MSUB_S:\n\n            case OPC_MSUB_D:\n\n            case OPC_MSUB_PS:\n\n            case OPC_NMADD_S:\n\n            case OPC_NMADD_D:\n\n            case OPC_NMADD_PS:\n\n            case OPC_NMSUB_S:\n\n            case OPC_NMSUB_D:\n\n            case OPC_NMSUB_PS:\n\n                gen_flt3_arith(ctx, op1, sa, rs, rd, rt);\n\n                break;\n\n            default:\n\n                MIPS_INVAL(\"cp3\");\n\n                generate_exception (ctx, EXCP_RI);\n\n                break;\n\n            }\n\n        } else {\n\n            generate_exception_err(ctx, EXCP_CpU, 1);\n\n        }\n\n        break;\n\n\n\n#if defined(TARGET_MIPS64)\n\n    /* MIPS64 opcodes */\n\n    case OPC_LDL ... OPC_LDR:\n\n    case OPC_LLD:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_LWU:\n\n    case OPC_LD:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_ld(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_SDL ... OPC_SDR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_SD:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_st(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_SCD:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_st_cond(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC, OPC_DADDI */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BNVC, OPC_BNEZALC, OPC_BNEC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_DADDI */\n\n            check_insn(ctx, ISA_MIPS3);\n\n            check_mips_64(ctx);\n\n            gen_arith_imm(ctx, op, rt, rs, imm);\n\n        }\n\n        break;\n\n    case OPC_DADDIU:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_arith_imm(ctx, op, rt, rs, imm);\n\n        break;\n\n#else\n\n    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            MIPS_INVAL(\"major opcode\");\n\n            generate_exception(ctx, EXCP_RI);\n\n        }\n\n        break;\n\n#endif\n\n    case OPC_DAUI: /* OPC_JALX */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n#if defined(TARGET_MIPS64)\n\n            /* OPC_DAUI */\n\n            check_mips_64(ctx);\n\n            if (rt != 0) {\n\n                TCGv t0 = tcg_temp_new();\n\n                gen_load_gpr(t0, rs);\n\n                tcg_gen_addi_tl(cpu_gpr[rt], t0, imm << 16);\n\n                tcg_temp_free(t0);\n\n            }\n\n            MIPS_DEBUG(\"daui %s, %s, %04x\", regnames[rt], regnames[rs], imm);\n\n#else\n\n            generate_exception(ctx, EXCP_RI);\n\n            MIPS_INVAL(\"major opcode\");\n\n#endif\n\n        } else {\n\n            /* OPC_JALX */\n\n            check_insn(ctx, ASE_MIPS16 | ASE_MICROMIPS);\n\n            offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n            gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n        }\n\n        break;\n\n    case OPC_MDMX:\n\n        check_insn(ctx, ASE_MDMX);\n\n        /* MDMX: Not implemented. */\n\n        break;\n\n    case OPC_PCREL:\n\n        check_insn(ctx, ISA_MIPS32R6);\n\n        gen_pcrel(ctx, rs, imm);\n\n        break;\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"major opcode\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n", "idx": 15980, "substitutes": {"env": ["pkg", "context", "h", "worker", "outer", "end", "esi", "sb", "pe", "serv", "esp", "server", "txt", "buf", "init", "setup", "state", "nv", "addr", "sv", "hw", "conf", "er", "environment", "org", "sys", "et", "vs", "pb", "vp", "viron", "code", "e", "dev", "window", "buffer", "vt", "erd", "cv", "ev", "ew", "en", "conn", "proc", "ec", "ef", "chart", "esc", "net", "vert", "config", "cmd", "v", "var", "obj", "w", "vm", "ee"], "ctx": ["pkg", "bc", "history", "conv", "tk", "wk", "gz", "cmp", "px", "cm", "np", "cp", "cb", "HK", "this", "check", "org", "warn", "kl", "canon", "pb", "pause", "parse", "cv", "grad", "sc", "context", "that", "kw", "std", "tmp", "ck", "txt", "alloc", "ctrl", "init", "Context", "cu", "def", "mc", "jac", "cfg", "timeout", "mk", "kh", "tc", "gc", "kt", "cf", "msg", "conn", "anc", "phys", "tm", "bp", "resp", "cmd", "stat", "kb", "abc", "dl", "kind", "jp", "prefix", "req", "x", "cas", "dc", "etc", "exec", "loc", "sys", "batch", "cookie", "nt", "cc", "index", "ka", "ct", "handler", "work", "fw", "wcs", "aux", "co", "xp", "json", "tx", "ctl", "setup", "xc", "hw", "conf", "xs", "desc", "handle", "window", "act", "mom", "cl", "inst", "ctr", "func", "crit", "fc", "nc", "config", "wx", "scope", "obj", "qt"], "offset": ["xp", " org", " cop", "addr", " opaque", " shr", "p", "s", "ptr", " ro", " cpu", " ox", "len", "sp", "osp", " off", " pos", " xp", " reg", " res", " sp", " loc", " esp", " oper", " ori"], "rs": ["bs", "pc", "ops", "ars", "ress", "os", "rors", "ps", "eps", "Rs", "r", "vs", "rx", "xs", "ls", "dr", "acks", "ats", "rc", "rr", "rss", "ims", "res", "aps", "mr", "RS", "ds", "vr", "cs", "rys", "ts", "ows", "ins", "ros", "ris", "ras", "obs", "ns"], "rt": ["RT", "ra", "rin", "dt", "art", "bt", "rb", "rat", "reg", "rf", "src", "r", "ptr", "rx", "tr", "nt", "rc", "rr", "rh", "ro", "red", "wt", "rl", "rn", "res", "fr", "rot", "rm", "rid", "ct", "tt", "vr", "pt", "pr", "rw", "rod"], "rd": ["dn", "usr", "d", "ra", "rin", "nd", "udd", "rb", "dra", "bd", "ru", "r", "ri", "ptr", "hr", "rx", "dr", "rc", "rr", "rss", "erd", "rh", "dd", "rn", "red", "rl", "sr", "rid", "mr", "ds", "rw", "rog", "cr", "cd", "rod"], "sa": ["ppa", "ai", "ra", "sb", "sl", "pa", "SA", "ar", "sha", "ata", "aa", "sv", "sys", "s", "si", "tha", "sam", "nas", "ain", "as", "na", "va", "sq", "sd", "sr", "sta", "ds", "ais", "pse", "nat", "se", "au", "a", "ba", "sm", "asa", "ns", "ss"], "op": ["nick", "oc", "jp", "rip", "type", "opt", "pop", "ops", " ip", "ip", "cmp", " cop", "hop", "top", "cat", "cop", " OP", "ort", "ap", "p", "operator", "pos", "omp", "oper", "oop", "ipp", "ot", "sp", "yp", "ype", "Op", "osp", "it", "act", "bit", "rop", "OP", "ep", "typ", "opp", "o", "cmd", "pp", "val", "lit", "ope", "opl", " ops", "operation"], "op1": ["Op1", "oper2", "Op2", "oper1", "OP1", "opOne", "op0", "optn", "OPOne", "op01", "ip1", "opn", "opaj", "ip0", "opern", " op01", " op0", "cop2", "OP01", "OPn", "ip2", "ipOne", "opt1", "optaj", " opOne", "Op0", "cop01", "OPaj", "opt2", "cop1", "OpOne", "operaj", "copOne", "OP2"], "imm": ["mun", "iam", "fm", "asm", "gm", "bm", "txt", "sim", "temp", "ip", "iat", "margin", "utm", "m", "ym", "imp", "pai", "dim", "mem", "im", "alt", "att", "mp", "ims", "mint", "ann", "rm", "mt", "mm", "attr", "em", "il", "tm", "vol", "tt", "amm", "pt", "mi", "sm", "perm", "vm"]}}
{"project": "qemu", "commit_id": "8f3a73bc57ea83e5b3930d14fc596ea51859987a", "target": 0, "func": "bool blk_dev_is_tray_open(BlockBackend *blk)\n\n{\n\n    if (blk->dev_ops && blk->dev_ops->is_tray_open) {\n\n        return blk->dev_ops->is_tray_open(blk->dev_opaque);\n\n    }\n\n    return false;\n\n}\n", "idx": 15985, "substitutes": {"blk": [" bln", "blak", "Blkt", " blq", "Blck", "bln", "blockk", "blockck", "Blq", "plq", " blak", "blck", "plck", " blj", "blj", " blc", "blq", "plb", "blks", "Blak", "plk", "plks", "Blc", "blockak", "Blks", "blb", "blockj", "Blk", " blck", "flck", " blks", " blb", "Blj", "plj", "pln", "blkt", "blc", "flb", "plak", "flk", "blockkt", "blockc", " blkt", "fln"]}}
{"project": "FFmpeg", "commit_id": "88ddcfa37f0067aae7457b44f433982f4c6d72ee", "target": 1, "func": "static av_cold int tdsc_init(AVCodecContext *avctx)\n\n{\n\n    TDSCContext *ctx = avctx->priv_data;\n\n    const AVCodec *codec;\n\n    int ret;\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_BGR24;\n\n\n\n    /* These needs to be set to estimate buffer and frame size */\n\n    if (!(avctx->width && avctx->height)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Video size not set.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* This value should be large enough for a RAW-only frame plus headers */\n\n    ctx->deflatelen = avctx->width * avctx->height * (3 + 1);\n\n    ret = av_reallocp(&ctx->deflatebuffer, ctx->deflatelen);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Allocate reference and JPEG frame */\n\n    ctx->refframe = av_frame_alloc();\n\n    ctx->jpgframe = av_frame_alloc();\n\n    if (!ctx->refframe || !ctx->jpgframe)\n\n        return AVERROR(ENOMEM);\n\n\n\n    /* Prepare everything needed for JPEG decoding */\n\n    codec = avcodec_find_decoder(AV_CODEC_ID_MJPEG);\n\n    if (!codec)\n\n        return AVERROR_BUG;\n\n    ctx->jpeg_avctx = avcodec_alloc_context3(codec);\n\n    if (!ctx->jpeg_avctx)\n\n        return AVERROR(ENOMEM);\n\n    ctx->jpeg_avctx->flags = avctx->flags;\n\n    ctx->jpeg_avctx->flags2 = avctx->flags2;\n\n    ctx->jpeg_avctx->dct_algo = avctx->dct_algo;\n\n    ctx->jpeg_avctx->idct_algo = avctx->idct_algo;;\n\n    ret = avcodec_open2(ctx->jpeg_avctx, codec, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Set the output pixel format on the reference frame */\n\n    ctx->refframe->format = avctx->pix_fmt;\n\n\n\n    return 0;\n\n}\n", "idx": 15987, "substitutes": {"avctx": ["ajcu", "vercu", " avcmp", "abcontext", "averconn", "avtx", "devcmp", "avecfg", "ajconn", " avreq", " avcoll", "ajpkg", "iverreq", "avcfg", " avcontext", "avecp", "avegc", "savcontext", "ajtx", "avtc", "avereq", "savcrit", "ajctx", "vercp", "avepkg", "vercontext", "afcontext", "averkl", "avcmd", "abcrit", "afctl", "avecrit", "avpkg", " avtc", "averctx", "devtx", "avectx", " avcp", "afctx", "avekl", " avpkg", "vercmd", " avconn", "abtx", "ajkl", " avcrit", "verctx", "avcu", "avergc", "avcontext", "avercfg", "vertc", "savctx", "avecontext", "abctx", "devkl", "avecoll", "devcontext", "afcmd", "ajcmp", "iverctx", "ajcfg", "ajcrit", "ajcmd", " avkl", "averreq", "averpkg", "ajcontext", "avcmp", "avcoll", "avgc", " avcmd", "ivercontext", "abreq", "abcmp", "avcp", "avcrit", "avercrit", " avcfg", "avetc", "avkl", "afpkg", "devctx", "afcmp", " avcu", "avetx", " avctl", "avctl", "savreq", " avtx", "ajgc", "avertx", "avectl", "avecmp", "avconn", "aveconn", "ivercoll", "vercmp", "avreq"], "ctx": ["pkg", "bc", "history", "tk", "pool", "cmp", "cm", "np", "addr", "cp", "cb", "check", "kl", "ptr", "na", "cv", "acl", "utils", "expr", "ca", "pt", "context", "kw", "ck", "txt", "alloc", "ctrl", "except", "jac", "cfg", "timeout", "mk", "tz", "tc", "gc", "cf", "kt", "msg", "conn", "tm", "resp", "cmd", "doc", "abc", "jp", "req", "prefix", "pc", "etc", "exec", "comm", "st", "loc", "sys", "cam", "nt", "cc", "coll", "mx", "ct", "proc", " cx", "lex", "rt", "wcs", "val", "aux", "xp", "iac", "tx", "lc", "ctl", "xc", "hw", "conf", " context", "desc", "qq", "act", "cl", "inst", "ctr", "func", "crit", "nc", "wx", "scope", "obj", "qt", "iat"], "codec": ["citEC", " codel", "odel", " codef", "codef", "codeek", "odEC", "candec", "cmdec", "odeca", "codpeg", "odeco", " coduc", "defEC", "odec", "codEC", "citec", " codeco", "defpeg", "cmdek", "Codec", "canderer", "CodEC", " codeca", "codeef", "Codpeg", "codeenc", " codek", "codel", "candEC", "codeel", "codeeco", "coduc", "oduc", "cmdenc", "citeca", "codeEC", " codpeg", "cmdef", "cituc", "codek", "codoc", "candeco", "codenc", " codenc", "defoc", "codeca", "coderer", "Codoc", " codEC", " codoc", "oderer", "Codeco", "codeec", "codeco", "Coderer", "defec"], "ret": ["usr", "ft", "ref", "RET", "elt", "tn", "status", "pret", "ber", "out", "re", "br", "rat", "compl", "reg", "value", "Ret", "result", "ext", " RET", "def", "pas", "arr", "err", "del", "tr", "ry", "flag", "alt", "mem", "att", "nt", "cert", "len", "fun", "cont", "it", "res", "back", "rm", "mt", "det", "gt", "try", "t", "ll", "ter", "rets", " fut", "get", " Ret", "resp", "rt", " res", "val", "print", "deg", "f", "lit", "reset", "rem"]}}
{"project": "qemu", "commit_id": "3010460fb99776bdf0a8b170555f2ab076382f9c", "target": 1, "func": "int hvf_vcpu_exec(CPUState *cpu)\n\n{\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n    CPUX86State *env = &x86_cpu->env;\n\n    int ret = 0;\n\n    uint64_t rip = 0;\n\n\n\n    cpu->halted = 0;\n\n\n\n    if (hvf_process_events(cpu)) {\n\n        return EXCP_HLT;\n\n    }\n\n\n\n    do {\n\n        if (cpu->vcpu_dirty) {\n\n            hvf_put_registers(cpu);\n\n            cpu->vcpu_dirty = false;\n\n        }\n\n\n\n        if (hvf_inject_interrupts(cpu)) {\n\n            return EXCP_INTERRUPT;\n\n        }\n\n        vmx_update_tpr(cpu);\n\n\n\n        qemu_mutex_unlock_iothread();\n\n        if (!cpu_is_bsp(X86_CPU(cpu)) && cpu->halted) {\n\n            qemu_mutex_lock_iothread();\n\n            return EXCP_HLT;\n\n        }\n\n\n\n        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);\n\n        assert_hvf_ok(r);\n\n\n\n        /* handle VMEXIT */\n\n        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);\n\n        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);\n\n        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,\n\n                                           VMCS_EXIT_INSTRUCTION_LENGTH);\n\n\n\n        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n\n\n        hvf_store_events(cpu, ins_len, idtvec_info);\n\n        rip = rreg(cpu->hvf_fd, HV_X86_RIP);\n\n        RFLAGS(env) = rreg(cpu->hvf_fd, HV_X86_RFLAGS);\n\n        env->eflags = RFLAGS(env);\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        update_apic_tpr(cpu);\n\n        current_cpu = cpu;\n\n\n\n        ret = 0;\n\n        switch (exit_reason) {\n\n        case EXIT_REASON_HLT: {\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            if (!((cpu->interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                (EFLAGS(env) & IF_MASK))\n\n                && !(cpu->interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                !(idtvec_info & VMCS_IDT_VEC_VALID)) {\n\n                cpu->halted = 1;\n\n                ret = EXCP_HLT;\n\n            }\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_MWAIT: {\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n            /* Need to check if MMIO or unmmaped fault */\n\n        case EXIT_REASON_EPT_FAULT:\n\n        {\n\n            hvf_slot *slot;\n\n            addr_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);\n\n\n\n            if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&\n\n                ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {\n\n                vmx_set_nmi_blocking(cpu);\n\n            }\n\n\n\n            slot = hvf_find_overlap_slot(gpa, gpa);\n\n            /* mmio */\n\n            if (ept_emulation_fault(slot, gpa, exit_qual)) {\n\n                struct x86_decode decode;\n\n\n\n                load_regs(cpu);\n\n                env->hvf_emul->fetch_rip = rip;\n\n\n\n                decode_instruction(env, &decode);\n\n                exec_instruction(env, &decode);\n\n                store_regs(cpu);\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        case EXIT_REASON_INOUT:\n\n        {\n\n            uint32_t in = (exit_qual & 8) != 0;\n\n            uint32_t size =  (exit_qual & 7) + 1;\n\n            uint32_t string =  (exit_qual & 16) != 0;\n\n            uint32_t port =  exit_qual >> 16;\n\n            /*uint32_t rep = (exit_qual & 0x20) != 0;*/\n\n\n\n#if 1\n\n            if (!string && in) {\n\n                uint64_t val = 0;\n\n                load_regs(cpu);\n\n                hvf_handle_io(env, port, &val, 0, size, 1);\n\n                if (size == 1) {\n\n                    AL(env) = val;\n\n                } else if (size == 2) {\n\n                    AX(env) = val;\n\n                } else if (size == 4) {\n\n                    RAX(env) = (uint32_t)val;\n\n                } else {\n\n                    VM_PANIC(\"size\");\n\n                }\n\n                RIP(env) += ins_len;\n\n                store_regs(cpu);\n\n                break;\n\n            } else if (!string && !in) {\n\n                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);\n\n                hvf_handle_io(env, port, &RAX(env), 1, size, 1);\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n#endif\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            VM_PANIC_ON(ins_len != decode.len);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n\n\n            break;\n\n        }\n\n        case EXIT_REASON_CPUID: {\n\n            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);\n\n            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);\n\n\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, rax);\n\n            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);\n\n            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);\n\n\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_XSETBV: {\n\n            X86CPU *x86_cpu = X86_CPU(cpu);\n\n            CPUX86State *env = &x86_cpu->env;\n\n            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            if (ecx) {\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n            env->xcr0 = ((uint64_t)edx << 32) | eax;\n\n            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_INTR_WINDOW:\n\n            vmx_clear_int_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_NMI_WINDOW:\n\n            vmx_clear_nmi_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_EXT_INTR:\n\n            /* force exit and allow io handling */\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_RDMSR:\n\n        case EXIT_REASON_WRMSR:\n\n        {\n\n            load_regs(cpu);\n\n            if (exit_reason == EXIT_REASON_RDMSR) {\n\n                simulate_rdmsr(cpu);\n\n            } else {\n\n                simulate_wrmsr(cpu);\n\n            }\n\n            RIP(env) += rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_CR_ACCESS: {\n\n            int cr;\n\n            int reg;\n\n\n\n            load_regs(cpu);\n\n            cr = exit_qual & 15;\n\n            reg = (exit_qual >> 8) & 15;\n\n\n\n            switch (cr) {\n\n            case 0x0: {\n\n                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 4: {\n\n                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 8: {\n\n                X86CPU *x86_cpu = X86_CPU(cpu);\n\n                if (exit_qual & 0x10) {\n\n                    RRX(env, reg) = cpu_get_apic_tpr(x86_cpu->apic_state);\n\n                } else {\n\n                    int tpr = RRX(env, reg);\n\n                    cpu_set_apic_tpr(x86_cpu->apic_state, tpr);\n\n                    ret = EXCP_INTERRUPT;\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                error_report(\"Unrecognized CR %d\\n\", cr);\n\n                abort();\n\n            }\n\n            RIP(env) += ins_len;\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_APIC_ACCESS: { /* TODO */\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TPR: {\n\n            ret = 1;\n\n            break;\n\n        }\n\n        case EXIT_REASON_TASK_SWITCH: {\n\n            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n            x68_segment_selector sel = {.sel = exit_qual & 0xffff};\n\n            vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,\n\n             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo\n\n             & VMCS_INTR_T_MASK);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TRIPLE_FAULT: {\n\n            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_RDPMC:\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, 0);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, 0);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        case VMX_REASON_VMCALL:\n\n            /* TODO: inject #GP fault */\n\n            break;\n\n        default:\n\n            error_report(\"%llx: unhandled exit %llx\\n\", rip, exit_reason);\n\n        }\n\n    } while (ret == 0);\n\n\n\n    return ret;\n\n}\n", "idx": 15999, "substitutes": {"cpu": ["pkg", "gpu", "cli", "pool", "cmp", "frame", "cat", "np", "cp", "core", "mac", "pause", "tp", "parse", "cv", "aco", "CPU", "que", "vm", "uu", "mu", "clock", "worker", "cache", "component", "ck", "util", "boot", "processor", "cu", "client", "socket", "ilo", "name", "common", "gc", "nic", "num", "conn", "bean", "copy", "upt", "exe", "net", "cmd", "stat", "library", "docker", "jp", "pc", "thread", "cum", "ruby", "hz", "c", "exec", "stan", "sys", "cam", "kernel", "linux", "trace", "home", "job", "mx", "ka", "ct", "proc", "prof", "pixel", "program", "rom", "pty", "aux", "python", "process", "queue", "runner", "comp", "nz", "local", "ctl", "nan", "pu", "rpm", "hw", "p", "window", "none", "ctx", "module", "nc", "config", "reset"], "x86_cpu": ["x86__comp", "x86__cpu", "x31_pu", "x86_ctx", "x87_comp", "x86_cp", "x31_cpu", "x86__pu", "x87_cpu", "x86_core", "x86_pu", "x31_cp", "x87_pu", "x87_core", "x31_ctx", "x86_comp", "x86__core"], "env": ["worker", "export", "priv", "extra", "esp", "nd", "win", "server", "oe", "buf", "nv", "hw", "eng", "except", "er", "ext", "environment", "def", "wp", "vec", "err", "ptr", "pb", "et", "ner", "origin", "cfg", "desc", "viron", "vp", "mem", "ah", "entry", "dev", "db", "window", "e", "vt", "ctx", "sp", "cv", "eg", "erd", "ev", "ew", "cap", "era", "en", "conn", "den", "pres", "proc", "el", "ef", "ec", "ep", "attr", "prev", "esc", "expr", "net", "ea", "equ", "inv", "v", "var", "gov", "obj", "doc", "eas", "ee"]}}
{"project": "FFmpeg", "commit_id": "332f9ac4e31ce5e6d0c42ac9e0229d7d1b2b4d60", "target": 0, "func": "int intel_h263_decode_picture_header(MpegEncContext *s)\n\n{\n\n    int format;\n\n\n\n    /* picture header */\n\n    if (get_bits_long(&s->gb, 22) != 0x20) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad picture start code\\n\");\n\n        return -1;\n\n    }\n\n    s->picture_number = get_bits(&s->gb, 8); /* picture timestamp */\n\n\n\n    if (get_bits1(&s->gb) != 1) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad marker\\n\");\n\n        return -1;\t/* marker */\n\n    }\n\n    if (get_bits1(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad H263 id\\n\");\n\n        return -1;\t/* h263 id */\n\n    }\n\n    skip_bits1(&s->gb);\t/* split screen off */\n\n    skip_bits1(&s->gb);\t/* camera  off */\n\n    skip_bits1(&s->gb);\t/* freeze picture release off */\n\n\n\n    format = get_bits(&s->gb, 3);\n\n    if (format != 7) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Intel H263 free format not supported\\n\");\n\n        return -1;\n\n    }\n\n    s->h263_plus = 0;\n\n\n\n    s->pict_type = I_TYPE + get_bits1(&s->gb);\n\n    \n\n    s->unrestricted_mv = get_bits1(&s->gb); \n\n    s->h263_long_vectors = s->unrestricted_mv;\n\n\n\n    if (get_bits1(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"SAC not supported\\n\");\n\n        return -1;\t/* SAC: off */\n\n    }\n\n    if (get_bits1(&s->gb) != 0) {\n\n        s->obmc= 1;\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Advanced Prediction Mode not supported\\n\");\n\n//        return -1;\t/* advanced prediction mode: off */\n\n    }\n\n    if (get_bits1(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"PB frame mode no supported\\n\");\n\n        return -1;\t/* PB frame mode */\n\n    }\n\n\n\n    /* skip unknown header garbage */\n\n    skip_bits(&s->gb, 41);\n\n\n\n    s->qscale = get_bits(&s->gb, 5);\n\n    skip_bits1(&s->gb);\t/* Continuous Presence Multipoint mode: off */\n\n\n\n    /* PEI */\n\n    while (get_bits1(&s->gb) != 0) {\n\n        skip_bits(&s->gb, 8);\n\n    }\n\n    s->f_code = 1;\n\n\n\n    s->y_dc_scale_table=\n\n    s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n\n\n    return 0;\n\n}\n", "idx": 16020, "substitutes": {"s": ["bs", "fs", "sg", "ties", "pers", "ps", "ms", "ports", "js", "des", "services", "se", "y", "ins", "grades", "details", "h", "changes", "sb", "serv", "ops", "results", "als", "os", "sv", "er", "set", "sports", "erences", "ers", "ords", "as", "ags", "times", "is", "ains", "south", "parts", "ns", "tes", "l", "rs", "ies", "S", "c", "comm", "eps", "sys", "ls", "vs", "uploads", "hs", "ats", "its", "ims", "sq", "acs", "ts", "qs", "params", "sts", "ss", "n", "ants", "ses", "conf", "p", "es", "us", "aws", "rates", "gs", "spec", "bis", "less", "ds", "cs", "comments", "stats", "w"], "format": ["details", "fp", "type", "version", " Format", "Format", "status", "style", "padding", "title", "error", "init", "top", "c", "MAT", "scale", "set", "tag", "zero", "ats", "count", "unit", "mode", "size", "it", "module", "feat", "act", "at", "data", "mt", "mod", "flat", "t", "debug", "fc", "feature", "AT", "print", "v", "function", "mat", "f", "option", "form", "base", "call", "fit"]}}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "int bdrv_pwrite(BlockDriverState *bs, int64_t offset,\n\n                const void *buf1, int count1)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (!drv->bdrv_pwrite)\n\n        return bdrv_pwrite_em(bs, offset, buf1, count1);\n\n    if (bdrv_wr_badreq_bytes(bs, offset, count1))\n\n        return -EDOM;\n\n    return drv->bdrv_pwrite(bs, offset, buf1, count1);\n\n}\n", "idx": 16047, "substitutes": {"bs": ["bos", "fs", "rs", "sb", "asm", "aos", "bl", "ks", "bc", "ads", "bf", "blog", "bes", "aus", "hz", "ubis", "bh", "ps", "outs", "ls", "vs", "hs", "ms", "gs", "b", "its", "iss", "js", "uts", "lbs", "ims", "bles", "bb", "sts", "gc", "locks", "bis", "boxes", "aps", "cks", "bps", "BS", "ds", "ubs", "bp", "bsp", "cs", "ts", "bits", "qs", "bm", "obs", "ns", "ss"], "offset": ["ref", "end", "address", "esi", "padding", "Offset", "bf", "off", "os", "util", "slot", "top", "addr", "offer", " offsets", "loc", "oid", "position", "set", "zero", "start", "bound", "key", "location", "et", "origin", "now", "article", "pos", "trace", "seek", "count", "slice", "block", "buffer", "pointer", "index", "offs", "sp", "size", "crop", "at", "mt", "coord", "o", "pad", "base", "command", "oss", "length", "area"], "buf1": [" buf01", " buffer0", "buf2", " buffer7", "buffer2", "buffer0", "buf01", "buffer1", "buffer4", " buf0", "fam01", " buffer1", " buffer2", "buff4", "fam2", "buff2", "buff1", "fam1", "buffer3", "buf4", "buffer7", "buf0", " buf4", "buffer01", "buf3", "buff0", "buf7", "fam3", " buf2", " buf3", " buf7"], "count1": ["Count1", " count2", "cmd2", " count0", "ount1", " countr", "countone", "Count0", "cmd512", "cmd1", "ount512", "cmd100", "countr", "count2", "ount2", " countN", "ountr", "counter2", "Countone", "counterr", "ountN", "ountone", "counterRes", "count512", " countRes", "ount0", "counter1", "count100", "ount100", "ountRes", "count0", "CountN", " countone", "countN", "Count2", "countRes", " count512", " count100"], "drv": ["DRh", "DRl", "driv", "Drve", "drl", "drw", "rdh", "urgv", "rdvd", "driva", "urgho", "rdb", "drvr", "Drh", "urgvc", "rrh", " drvd", "rrl", "Drva", "rdv", "drvd", "rrb", "drva", " drl", "Drw", "parvd", "drb", "DRvr", " drb", "drho", "urgl", " drvr", "drive", "Drvr", "drh", "rrho", "rrv", " drvc", "rrvd", "DRv", " drw", "rrvc", " drh", "drvc", "Drv", "DRw", "drivd", "parve", " drho", "drve", "Drvd", "Drl", "parva", "parv"]}}
{"project": "qemu", "commit_id": "ac125d993b461d4dee4d6df4d93ac3f2eb959d1d", "target": 1, "func": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n\n{\n\n    char *buffer;\n\n    int ret;\n\n    char *path = fs_path->data;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret = truncate(buffer, size);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 16057, "substitutes": {"ctx": ["pkg", "context", "jp", "kw", "req", "bc", "tx", "unc", "conv", "setup", "cmp", "px", "cm", "np", "xc", "cp", "exec", "bh", "hw", "cb", "loc", "jac", "xs", "mk", "tc", "cc", "rc", "gc", "cv", "kt", "cf", "conn", "cl", "anc", "ct", " cx", "nc", "fc", "sc", "wx", "cmd", "ac", "wd"], "fs_path": ["vs_Path", "vs_log", "fs_context", "fs_log", "cs_Path", "vs_path", "cs_path", "fs_spec", "cs_spec", "fs_Path", "vs_context"], "size": ["ize", "sum", "type", "sn", "send", "n", "SIZE", "time", "z", "out", "space", "scale", "s", "si", "m", "empty", "storage", "name", " length", "dim", "mem", "code", "e", "count", "len", "no", "iz", "sp", "offset", "zone", " Size", "t", "fee", "v", "Size", "sync", "length", " resize"], "buffer": ["uf", "context", "device", "queue", "phrase", "cache", "ref", "channel", "address", "bar", "map", "page", "bc", "null", "memory", "sequence", "byte", "face", "buf", "result", "input", "document", "message", "batch", "empty", "ptr", "tr", "buff", "read", "window", "chain", "response", "iter", "block", "attribute", "pointer", "output", "index", "Buffer", "variable", "data", "bin", "board", "binary", "copy", "program", "source", "ob", "text", "table", "f", "command", "area", "stream"], "ret": ["rel", "ft", " alt", "RET", "elt", "nz", "pret", "txt", "out", "re", "rat", "cat", "Ret", "result", "xt", "ptr", "tr", "Return", "flag", "alt", "att", "rev", "nt", "match", "fi", "cont", "it", "res", "j", "en", "inter", "mt", "gt", "t", "ter", " fut", "rets", " Ret", "rt", " res", "val", "print", "lit", "rem"], "path": ["pkg", "context", "ref", "prefix", "prop", "package", "PATH", "image", "th", "temp", "full", "c", "root", "alias", "p", "def", "key", "desc", "name", "entry", "chain", "pattern", "pointer", "index", "Path", "id", "dir", "rect", "str", "transform", "data", "anc", "template", "file", "pt", "link", "ac", "base", "ath", "stream"]}}
{"project": "qemu", "commit_id": "8ba2aae32c40f544def6be7ae82be9bcb781e01d", "target": 0, "func": "void uuid_unparse(const uuid_t uu, char *out)\n\n{\n\n    snprintf(out, 37, UUID_FMT,\n\n            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],\n\n            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);\n\n}\n", "idx": 16068, "substitutes": {"uu": ["pkg", "mmm", "punk", " gu", "gpu", "amps", "cmp", "gu", "np", "u", "uy", "ug", "gue", "nn", "hog", "ubuntu", " dat", "gent", "gb", "ucc", " du", "uf", "eu", "cache", "unique", "serv", "tu", "alloc", "util", " tv", "chu", "tim", "hu", "cu", " mum", "zero", "uid", " bu", "coin", "ele", "aaa", "ud", "cul", "au", " uh", "phy", "ui", "gram", "su", "upe", " tofu", " fuzz", "bu", "crypt", "ow", " su", " universal", "uv", "empty", " up", "uh", "lu", "du", "sky", "stick", "iq", "cup", "emp", "unch", "hum", "cur", " cu", "nu", " u", "hw", "qq", "ffe", "yu", "universal", "gru", " nu", " dup", " tou", "unt", " tu", "yy", "sup", "dat", " ut"], "out": ["h", "ch", "n", "tmp", "txt", "conv", "pool", "result", "c", "new", "OUT", "p", "set", "s", "client", "list", "err", "m", "outs", "in", "b", "buffer", "Out", "str", "j", "res", "msg", "bin", "copy", "t", "o", "print", "v", "f", "var", "table", "w", "output"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static int stellaris_enet_can_receive(void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n\n        return 1;\n\n\n\n    return (s->np < 31);\n\n}\n", "idx": 16083, "substitutes": {"opaque": ["oplatile", "oplaque", "obacity", " Opac", " Opois", "pvious", "obaque", "obatile", "opanse", "patile", "oppaque", "oppois", "obvious", "opvious", "opois", "oplacity", " Opaque", "pacity", "oppanse", "oplvious", " opois", "opac", "paque", "opacity", "opatile", " opac", " opanse", " Opanse", "oppac"], "s": ["bs", "h", "fs", "rs", "sol", "sb", "sl", "ops", "S", "als", "sv", "c", "q", "ps", "conf", "p", "sys", "r", "ess", "ls", "sports", "hs", "aws", "gs", "b", "js", "sts", "spec", "g", "j", "sq", "less", "t", "ds", "ts", "is", "cmd", "sm", "v", "stats", "sis", "ns", "ss"]}}
{"project": "qemu", "commit_id": "75f27498220e6ff6f78bf08fbe2cc662ec76ba89", "target": 0, "func": "void acpi_memory_unplug_cb(MemHotplugState *mem_st,\n\n                           DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    /* nvdimm device hot unplug is not supported yet. */\n\n    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));\n\n    mdev->is_enabled = false;\n\n    mdev->dimm = NULL;\n\n}\n", "idx": 16089, "substitutes": {"mem_st": ["memzst", "mem_src", "mem2est", " mem_sts", "mem_sts", "mem_est", " mem_est", " mem_src", "memzsrc", "mem2st", "memzsts", "mem2sts"], "dev": ["device", "d", "ch", "dem", "ve", "DEV", "priv", "serv", "app", "alloc", "go", "off", "devices", "serial", "buf", "gu", "exec", "hw", "new", "ver", "p", "def", "cam", "ptr", "tr", "raw", "mem", "md", "att", "db", "window", "des", "env", "Dev", "spec", "der", "de", "ev", "ad", "sd", "iv", "data", "proc", "test", "debug", "pad", "v", "adv", "w"], "errp": ["aerp", " errP", " errps", "rrpc", " errpb", " errpc", "errps", "aerpb", "errpb", "errP", "errorpb", "errpc", "errorP", "aerP", "rrp", "errorps", "errpar", "rrpb", "aerpar", "errorpar", "errorp", " errpar", "errorpc", "rrps"], "mdev": ["nev", "mtemp", " mvar", "dmev", "gmev", "ndevice", " mtemp", "gmdev", "gmdevice", "omev", "hmdevice", " mdevice", "mev", "Mserial", " mev", "dmdevice", "pDev", "gmdef", "Mdevice", "ddev", "dDev", "omvar", "ndef", "mserial", "pdev", "pserial", "pdevice", "hmdev", " mDev", "Mtemp", "mdef", "gmDev", " mserial", "Mdev", "ndev", "MDev", "hmtemp", "mvar", "mDev", "ddevice", "Mev", "dmdev", "mdevice", "dmvar", "omdev", " mdef", "omdevice", "hmev"]}}
{"project": "qemu", "commit_id": "a7824a886ed50eb4fe3c6fcd6afd8814a6973583", "target": 0, "func": "alloc_f(int argc, char **argv)\n\n{\n\n\tint64_t offset;\n\n\tint nb_sectors;\n\n\tchar s1[64];\n\n\tint num;\n\n\tint ret;\n\n\tconst char *retstr;\n\n\n\n\toffset = cvtnum(argv[1]);\n\n\tif (offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tif (argc == 3)\n\n\t\tnb_sectors = cvtnum(argv[2]);\n\n\telse\n\n\t\tnb_sectors = 1;\n\n\n\n\tret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);\n\n\n\n\tcvtstr(offset, s1, sizeof(s1));\n\n\n\n\tretstr = ret ? \"allocated\" : \"not allocated\";\n\n\tif (nb_sectors == 1)\n\n\t\tprintf(\"sector %s at offset %s\\n\", retstr, s1);\n\n\telse\n\n\t\tprintf(\"%d/%d sectors %s at offset %s\\n\",\n\n\t\t\tnum, nb_sectors, retstr, s1);\n\n\treturn 0;\n\n}\n", "idx": 16090, "substitutes": {"argv": [" argV", "Argv", "argsm", " argvs", "parV", "Argm", " argl", "argumentvs", "argsp", "Argvs", "argp", "argumentV", "argsc", "argm", " argp", " argm", "argumentv", "argsV", "ArgV", "argc", "argsv", " argc", "argsl", "argl", "argumentc", "argvs", "parl", "argV", "parc", "Argc", "Argp", "parv"], "offset": ["bs", "ref", "end", "address", "padding", "Offset", "point", "unc", "off", "error", "out", "slot", "util", "number", "addr", "result", "loc", "set", "s", "position", "start", "store", "et", "bound", "origin", "timeout", "tz", "pos", "alt", "trace", "seek", "slice", "len", "offs", "buffer", "sp", "index", "pointer", "attribute", "size", "url", "transform", "range", "layout", "mt", "scroll", "t", "o", "pad", "base", "f", "lag", "obj", "onto", "length", "location", "mask", "reset", "shift"], "nb_sectors": ["nb_seectors", "nb_vectors", "nb_shegments", "nb_esvers", "nb_seeers", "nb_nesections", "nb_vevers", "nb_suors", "nb2selements", "nb_sulements", "nb_meters", "nb_psegments", "nb_velements", "nb2vectors", "nb_spegments", "nb_bevers", "nb_sheors", "nb_veters", "nb_veers", "nb_neors", "nb_seers", "nb_SEctors", "nb2severs", "nb_psecs", "nb_pelements", "nb_negments", "nb_vecs", "nb_pectors", "nb_suctors", "nb_selements", "nb_suters", "nb_mectors", "nb2sesections", "nb_vesections", "nb_segments", "nb_SElements", "nb2seors", "nb_veors", "nb_sesections", "nb_lelements", "nb_spevers", "nb_meors", "nb_psectors", "nb_essections", "nb_specs", "nb_SEors", "nb2vevers", "nb_psevers", "nb_secs", "nb_besections", "nb_SEers", "nb_lectors", "nb_seters", "nb2sectors", "nb2veors", "nb_melements", "nb_vegments", "nb_seors", "nb_bectors", "nb_levers", "nb_leors", "nb_seeors", "nb_pevers", "nb_peors", "nb2vesections", "nb_shectors", "nb2velements", "nb_esors", "nb_esctors", "nb_seelements", "nb_spectors", "nb_shesections", "nb_severs", "nb_beors", "nb_nectors"], "s1": ["ts3", " s3", "sone", "S0", "params2", "ts0", "params0", "Sone", "ps3", "ts1", "s2", "s6", "s0", "gs0", "params1", "s3", "gs2", "ps1", "paramsone", "rs3", " s6", " s0", "rs0", "gs1", "ps2", "S6", " s2", "S2", "S3", "gs3", "rs1", "rs2", " sone", "ps6", "S1", "ts2"], "num": ["un", "sum", "info", "om", "n", "nam", "conv", "temp", "node", "local", "reg", "number", "np", "new", "ver", "set", "nm", "m", "mon", "valid", "Num", "dim", "im", "count", "no", "final", "nom", "index", "id", "um", "msg", "en", "NUM", "coord", "nb", "o", "var", "or"], "ret": ["ref", "RET", "n", "elt", "opt", "status", "success", "br", "ben", "out", "re", "reg", "Ret", "result", "def", "set", "tr", "flag", "alt", "repl", "nt", "rev", "sat", "iter", "final", "len", "rect", "cont", "it", "res", "j", "back", "bit", "red", "bool", "det", "mt", "gt", "try", "t", "arg", "ter", "rets", "get", " Ret", "rt", "val", "lit", "backed", "rem"], "retstr": ["retSTR", " retenc", "altStr", " retStr", "outenc", "defstring", "ret0", "returnst", "memstring", "memStr", "RetStr", "defst", "reenc", "mem0", "defStr", " ret0", "altstr", "returnstr", "Retstring", "retst", "altstring", " retSTR", "returnStr", "outstring", "retenc", "returnstring", "retname", "memstr", "restring", "returnSTR", "outstr", " retstring", "Retst", "retStr", "defstr", "restr", "altSTR", "Retstr", " retname", "return0", "retstring", "outname"]}}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "static void hmp_cont_cb(void *opaque, int err)\n\n{\n\n    if (!err) {\n\n        qmp_cont(NULL);\n\n    }\n\n}\n", "idx": 16093, "substitutes": {"opaque": ["operlay", "olay", "oaque", "opcode", "operaque", "ioplay", "ocode", "opercode", "iopa", "oplay", "opera", "iopaque", "oa", "opa", "iopcode"], "err": ["usr", "Error", "status", "die", "rupt", "error", "gz", "state", "result", "c", "cb", "conf", "er", "notice", "pl", "arr", "r", "urg", "any", "valid", "good", "code", "e", "rev", "count", "rr", "iter", "none", "nr", "ply", "ok", "aaa", "res", "msg", "proc", "try", "coord", "test", "fee", "resp", "kr", "cr", "Er", "eor"]}}
{"project": "qemu", "commit_id": "36fef36b91f7ec0435215860f1458b5342ce2811", "target": 1, "func": "static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n\n    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);\n\n    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);\n\n    struct mfi_ctrl_info info;\n\n    size_t dcmd_size = sizeof(info);\n\n    BusChild *kid;\n\n    int num_pd_disks = 0;\n\n\n\n    memset(&info, 0x0, cmd->iov_size);\n\n    if (cmd->iov_size < dcmd_size) {\n\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n\n                                            dcmd_size);\n\n        return MFI_STAT_INVALID_PARAMETER;\n\n    }\n\n\n\n    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);\n\n    info.pci.device = cpu_to_le16(pci_class->device_id);\n\n    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);\n\n    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);\n\n\n\n    /*\n\n     * For some reason the firmware supports\n\n     * only up to 8 device ports.\n\n     * Despite supporting a far larger number\n\n     * of devices for the physical devices.\n\n     * So just display the first 8 devices\n\n     * in the device port list, independent\n\n     * of how many logical devices are actually\n\n     * present.\n\n     */\n\n    info.host.type = MFI_INFO_HOST_PCIE;\n\n    info.device.type = MFI_INFO_DEV_SAS3G;\n\n    info.device.port_count = 8;\n\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n\n        SCSIDevice *sdev = DO_UPCAST(SCSIDevice, qdev, kid->child);\n\n        uint16_t pd_id;\n\n\n\n        if (num_pd_disks < 8) {\n\n            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);\n\n            info.device.port_addr[num_pd_disks] =\n\n                cpu_to_le64(megasas_get_sata_addr(pd_id));\n\n        }\n\n        num_pd_disks++;\n\n    }\n\n\n\n    memcpy(info.product_name, base_class->product_name, 24);\n\n    snprintf(info.serial_number, 32, \"%s\", s->hba_serial);\n\n    snprintf(info.package_version, 0x60, \"%s-QEMU\", qemu_hw_version());\n\n    memcpy(info.image_component[0].name, \"APP\", 3);\n\n    snprintf(info.image_component[0].version, 10, \"%s-QEMU\",\n\n             base_class->product_version);\n\n    memcpy(info.image_component[0].build_date, \"Apr  1 2014\", 11);\n\n    memcpy(info.image_component[0].build_time, \"12:34:56\", 8);\n\n    info.image_component_count = 1;\n\n    if (pci_dev->has_rom) {\n\n        uint8_t biosver[32];\n\n        uint8_t *ptr;\n\n\n\n        ptr = memory_region_get_ram_ptr(&pci_dev->rom);\n\n        memcpy(biosver, ptr + 0x41, 31);\n\n        memcpy(info.image_component[1].name, \"BIOS\", 4);\n\n        memcpy(info.image_component[1].version, biosver,\n\n               strlen((const char *)biosver));\n\n        info.image_component_count++;\n\n    }\n\n    info.current_fw_time = cpu_to_le32(megasas_fw_time());\n\n    info.max_arms = 32;\n\n    info.max_spans = 8;\n\n    info.max_arrays = MEGASAS_MAX_ARRAYS;\n\n    info.max_lds = MFI_MAX_LD;\n\n    info.max_cmds = cpu_to_le16(s->fw_cmds);\n\n    info.max_sg_elements = cpu_to_le16(s->fw_sge);\n\n    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);\n\n    if (!megasas_is_jbod(s))\n\n        info.lds_present = cpu_to_le16(num_pd_disks);\n\n    info.pd_present = cpu_to_le16(num_pd_disks);\n\n    info.pd_disks_present = cpu_to_le16(num_pd_disks);\n\n    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |\n\n                                   MFI_INFO_HW_MEM |\n\n                                   MFI_INFO_HW_FLASH);\n\n    info.memory_size = cpu_to_le16(512);\n\n    info.nvram_size = cpu_to_le16(32);\n\n    info.flash_size = cpu_to_le16(16);\n\n    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);\n\n    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |\n\n                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |\n\n                                    MFI_INFO_AOPS_MIXED_ARRAY);\n\n    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |\n\n                               MFI_INFO_LDOPS_ACCESS_POLICY |\n\n                               MFI_INFO_LDOPS_IO_POLICY |\n\n                               MFI_INFO_LDOPS_WRITE_POLICY |\n\n                               MFI_INFO_LDOPS_READ_POLICY);\n\n    info.max_strips_per_io = cpu_to_le16(s->fw_sge);\n\n    info.stripe_sz_ops.min = 3;\n\n    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);\n\n    info.properties.pred_fail_poll_interval = cpu_to_le16(300);\n\n    info.properties.intr_throttle_cnt = cpu_to_le16(16);\n\n    info.properties.intr_throttle_timeout = cpu_to_le16(50);\n\n    info.properties.rebuild_rate = 30;\n\n    info.properties.patrol_read_rate = 30;\n\n    info.properties.bgi_rate = 30;\n\n    info.properties.cc_rate = 30;\n\n    info.properties.recon_rate = 30;\n\n    info.properties.cache_flush_interval = 4;\n\n    info.properties.spinup_drv_cnt = 2;\n\n    info.properties.spinup_delay = 6;\n\n    info.properties.ecc_bucket_size = 15;\n\n    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);\n\n    info.properties.expose_encl_devices = 1;\n\n    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);\n\n    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |\n\n                               MFI_INFO_PDOPS_FORCE_OFFLINE);\n\n    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |\n\n                                       MFI_INFO_PDMIX_SATA |\n\n                                       MFI_INFO_PDMIX_LD);\n\n\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);\n\n    return MFI_STAT_OK;\n\n}\n", "idx": 16112, "substitutes": {"s": ["i", "h", "d", "fs", "rs", "n", "sb", "sl", "k", "ses", "ies", "S", "os", "state", "c", "sv", "ps", "ss", "p", "sys", "r", "es", "m", "ls", "xs", "hs", "gs", "b", "e", "its", "js", "spec", "g", "t", "ds", "self", "cs", "ts", "is", "a", "o", "v", "y", "stats", "sm", "ns", "sts"], "cmd": ["pkg", "ch", "ind", "req", "conv", "cli", "ctrl", "ctl", "setup", "cmp", "cm", "c", "cp", "cb", "comm", "conf", "exec", "def", "sys", "batch", "m", "args", "cfg", "handle", "mk", "raw", "controller", "news", "md", "nt", "cc", "com", "gen", "ctx", "mode", "job", "cont", "cf", "help", "msg", "conn", "cl", "ct", "dq", "Cmd", "ctr", "control", "crit", "phy", "config", "command", "obj", "call"], "pci_dev": ["pciableev", "pciabledev", "ppi_dev", "pdi_def", "pci_obj", "pdi_dev", "pci_ev", "pciablecmd", "pci_device", "pci_def", "pci_cmd", "pdi_device", "ppi_cmd", "ppi_ev", "pdi_obj"], "pci_class": ["pci2classes", "pci2class", "pcgi___cell", "pclietydef", "pcgi___cc", "pciolyclass", "pciproclass", "pci_cell", "pci_case", "pcgi_desc", "pci2client", "pcgi___class", "pci___cell", "pcietyclass", "pcgi_class", "pci___classes", "pcgi_cell", "pli_class", "pci_client", "pciablecell", "pcli_lass", "pciablecc", "pcietylass", "pcli_def", "pci2type", "pci___desc", "pci_type", "pci5class", "pcli_class", "pci_close", "pcu2classes", "pcgi___desc", "pciolycert", "pcgi_cc", "pciabledesc", "pcu_cert", "pci_cc", "pci_classes", "pcu_class", "pli___cell", "pcu_case", "pci___type", "pli_cell", "pci___close", "pcietydef", "pcu2client", "pci___class", "pci_cert", "pclietylass", "pcu_type", "pciprodef", "pci5cert", "pci___client", "pciolycase", "pli___class", "pcu2type", "pci___cc", "pcu_classes", "pciprolass", "pcu2class", "pci5case", "pcu_client", "pci_def", "pci_lass", "pli___close", "pci_desc", "pclietyclass", "pli_close", "pciableclass"], "base_class": ["baseproproc", "basepronum", "baseacclass", "serviceacproc", "baseproclass", "baseacproc", "service_num", "baseaclink", "baseclnum", "serviceacclass", "basecllink", "base_link", "service_link", "baseacnum", "base_proc", "service_proc", "service_class", "baseclproc", "baseclclass", "serviceacnum", "base_num", "baseprolink", "serviceaclink"], "info": ["image", "status", "success", "history", "error", "safe", "http", "information", " frame", "xml", "create", "check", "Info", " input", "close", "news", "mem", "ret", " accept", "it", "help", "show", "public", " follow", "report", "debug", " status", " error", " information", "event", "details", "h", "cache", "os", "ion", "init", "admin", "start", "fo", " hello", "name", "good", "to", "num", "conn", "try", "comment", " perf", "t", "order", "metadata", "stat", "by", "f", "Inf", "policy", " inform", "query", "kind", "inf", "type", "summary", "value", "about", "loc", "update", "trace", " report", "response", "no", "fi", " check", " doc", "index", "note", "op", "auth", "data", "unknown", "o", "rec", " output", "time", "json", "out", "state", "INFO", "conf", " about", "p", "list", "now", "entry", "e", "iter", "ok", "id", "cho", "row", " inf", "iso", "self", "test", " alert", " data", "config", "user"], "kid": ["kind", "jp", "kw", "kn", " ki", "ko", "k", "ks", "kit", "ck", "kie", "sid", "wk", "ker", "kg", "pid", "hw", "kl", "dk", "kk", "mk", "kh", "kids", "cc", "kick", "ctx", "sk", "id", "kt", "ka", "kj", "ke", "ek", "ak", "ki", "nb", "Kid", "ca", "kr", "unk", "kb", "K", "sky", "ked"], "sdev": ["sdef", "ssdes", "ssdev", "psdevice", "Sdes", "jsdev", "jsdef", "sdet", "dsdevice", "psde", "dsdev", "psdev", "dsdet", "ssde", "ssdevice", "ssdef", "sdes", "tsdev", "tsdef", "sdevice", "jsdes", "dsdef", "ssDEV", "tsdet", "tsdevice", " sdevice", "sDEV", "sde", "Sdef", " sdef", " sdet", "jsdevice", "psDEV", "Sdev", "Sdevice"], "pd_id": ["pdponum", "pdewkey", "dl_i", "PD_id", "pd_link", " PD_id", "pd67i", " PDewnum", "dl67i", "dl67ad", "pd_i", " PDewlink", "dl_kid", "pd___i", "PD_Id", "pd_ids", "pd_ad", "pdewid", "pdewlink", "pd___ad", "pd___kid", " PDewid", " PD_link", "pd_num", "pdpoid", "dl67id", "pd67ad", "PD_ids", "PD_class", "pd___id", "pd67kid", "dl67kid", "pdpokey", "pdjkey", "dl_id", "pd67id", " PD_key", "pdjid", " PD_num", "dl_ad", "pdjnum", "pd_key", "pdpolink", "pdjlink", "pd_class", " PDewkey", "pd_Id", "pdewnum", "pd_kid"], "num_pd_disks": ["num_pd_diskk", "num_pd_devks", "num_pd_DISks", "num_pd_hardk", "num_pd_disps", "num_pd_discs", "num_pd_hardcs", "num_pd_deks", "num_pd_Disds", "num_pd_hardms", "num_pd_sdks", "num_pd_diskms", "num_pd_Disps", "num_pd_diskks", "num_pd_diskcs", "num_pd_devms", "num_pd_deps", "num_pd_dek", "num_pd_Disas", "num_pd_DISas", "num_pd_disk", "num_pd_hardks", "num_pd_sdk", "num_pd_DISk", "num_pd_Discs", "num_pd_DISps", "num_pd_Disks", "num_pd_sdds", "num_pd_Disk", "num_pd_Disms", "num_pd_disas", "num_pd_disds", "num_pd_devk", "num_pd_deas", "num_pd_sdms", "num_pd_devds", "num_pd_disms"]}}
{"project": "FFmpeg", "commit_id": "f4aaf987a588fcf5978e636edf2193df35b3e83b", "target": 1, "func": "int ff_thread_video_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *frame, int *got_packet_ptr){\n\n    ThreadContext *c = avctx->internal->frame_thread_encoder;\n\n    Task task;\n\n    int ret;\n\n\n\n    av_assert1(!*got_packet_ptr);\n\n\n\n    if(frame){\n\n        if(!(avctx->flags & CODEC_FLAG_INPUT_PRESERVED)){\n\n            AVFrame *new = avcodec_alloc_frame();\n\n            if(!new)\n\n                return AVERROR(ENOMEM);\n\n            pthread_mutex_lock(&c->buffer_mutex);\n\n            ret = c->parent_avctx->get_buffer(c->parent_avctx, new);\n\n            pthread_mutex_unlock(&c->buffer_mutex);\n\n            if(ret<0)\n\n                return ret;\n\n            new->pts = frame->pts;\n\n            new->quality = frame->quality;\n\n            new->pict_type = frame->pict_type;\n\n            av_image_copy(new->data, new->linesize, (const uint8_t **)frame->data, frame->linesize,\n\n                          avctx->pix_fmt, avctx->width, avctx->height);\n\n            frame = new;\n\n        }\n\n\n\n        task.index = c->task_index;\n\n        task.indata = (void*)frame;\n\n        pthread_mutex_lock(&c->task_fifo_mutex);\n\n        av_fifo_generic_write(c->task_fifo, &task, sizeof(task), NULL);\n\n        pthread_cond_signal(&c->task_fifo_cond);\n\n        pthread_mutex_unlock(&c->task_fifo_mutex);\n\n\n\n        c->task_index = (c->task_index+1) % BUFFER_SIZE;\n\n\n\n        if(!c->finished_tasks[c->finished_task_index].outdata && (c->task_index - c->finished_task_index) % BUFFER_SIZE <= avctx->thread_count)\n\n            return 0;\n\n    }\n\n\n\n    if(c->task_index == c->finished_task_index)\n\n        return 0;\n\n\n\n    pthread_mutex_lock(&c->finished_task_mutex);\n\n    while (!c->finished_tasks[c->finished_task_index].outdata) {\n\n        pthread_cond_wait(&c->finished_task_cond, &c->finished_task_mutex);\n\n    }\n\n    task = c->finished_tasks[c->finished_task_index];\n\n    *pkt = *(AVPacket*)(task.outdata);\n\n    av_freep(&c->finished_tasks[c->finished_task_index].outdata);\n\n    c->finished_task_index = (c->finished_task_index+1) % BUFFER_SIZE;\n\n    pthread_mutex_unlock(&c->finished_task_mutex);\n\n\n\n    *got_packet_ptr = 1;\n\n\n\n    return task.return_code;\n\n}\n", "idx": 16135, "substitutes": {"avctx": ["navca", "avercontext", " avcmd", "avercb", "averconf", "Avconn", " avcmp", "awcontext", "wavcontext", "avercmp", "Avctx", "avcontext", "avcmd", " avcfg", "averctl", "navcmp", "aveca", "avetc", "avercmd", "avcfg", "Avcfg", " avcontext", "averctx", "avecb", " avtc", "wavctl", " avctl", "avctl", "avcmp", "navctx", "wavctx", "avectx", "avecontext", " avconf", "awcfg", "awctx", " avcb", "Avcontext", "wavconn", "avectl", "avecmp", "avecmd", "avconn", "avconf", " avca", "aveconn", "avertc", " avconn", "avtc", "aveconf", "awconn", "avcb", "navcontext", "avca"], "pkt": ["pkg", "packet", "ppacket", "packacket", "packqt", " pqt", " pkg", " packet", "ppqt", "packkg", "ppkg", "packkt", "ppkt", "pqt"], "frame": ["framework", "image", "sequence", "error", "face", "message", "from", "movie", "close", "scene", "fb", "instance", "show", "feature", "function", "base", "text", "profile", "event", "context", "info", "component", "style", "Frame", "word", "draw", "next", "video", "force", "def", "filter", "position", "code", "buffer", "request", "cf", "fr", "zone", "t", "file", "part", "source", "f", "form", "one", "fps", "channel", "type", "value", "picture", "update", "rame", "in", "block", "fi", "object", "shot", "frames", "data", "normal", "fram", "process", "call", "ref", "time", "point", "state", "result", "df", "raw", "window", "none", "remote", "ce", "feat", "iframe", "original", "fc", "reset"], "got_packet_ptr": ["got_packET_pointer", "got_packET_addr", "got_packacket2obj", "got_packacket_ref", "got_packet2ref", "got_packET_Ptr", "got_packet__ptr", "got_packacket2pointer", "got_packET_ptr", "got_packacket_obj", "got_packacket2ref", "got_packacket_ptr", "got_packet2ptr", "got_packet_pointer", "got_packacket_pointer", "got_packet__addr", "got_packet2addr", "got_packacket2ptr", "got_packet_ref", "got_packet2pointer", "got_packet__Ptr", "got_packet__pointer", "got_packet_Ptr", "got_packet2obj", "got_packet_addr", "got_packet_obj", "got_packet2Ptr"], "c": ["abc", "vc", "cache", "l", "con", "comp", "pc", "bc", "lc", "unc", "conv", "dc", "etc", "cur", "cmp", "cm", "cp", "xc", "cu", "conf", "cn", "comm", "cb", "p", "mc", "this", "cam", "m", "C", "tc", "b", "chain", "cc", "rc", "com", "ctx", "gc", "cv", "ce", "g", "cont", "cf", "coll", "ci", "cl", "ct", "anc", "ic", "ec", "t", "ca", "cs", "fc", "nc", "sc", "uc", "config", "ac", "cr", "v", "f", "cd", "can", "call", "co"], "task": ["event", "worker", "bar", "package", "parent", "image", "component", "tmp", "null", "slave", "best", "node", "thread", "wrong", "out", "thing", "word", "byte", "result", "session", "error", "ask", "message", "tag", "tf", "empty", "action", "course", "article", "target", "tty", "tc", "trace", "nt", "window", "block", "remote", "commit", "ack", "tar", "form", "job", "feat", "bit", "missing", "msg", "unknown", "token", "piece", "craft", "func", "t", "unt", "Task", "work", "test", "net", "question", "part", "link", "master", "function", "table", "command", "process"], "ret": ["usr", "ft", "ref", "RET", "elt", "nz", "pret", "status", "git", "txt", "out", "re", "value", "ern", "Ret", "result", "ext", " RET", "def", "not", "arr", "tr", "flag", "Return", "alt", "att", "nt", "rev", "len", "fun", "cont", "url", "res", "back", "rm", "mt", "try", "gt", "nl", "arg", "t", "ll", "ter", "net", "rets", " Ret", "resp", "rt", "deg", "val", "cmd", "reset", "rem"], "new": ["export", "New", "shared", "re", "create", "this", "true", "from", "add", "private", "valid", "news", "g", "it", "record", "public", "make", "all", "vm", "NEW", "and", "bar", "unique", "package", "tmp", "alloc", "next", "full", "init", "draw", "root", "def", "set", "start", "ne", "name", "good", "common", "final", "to", "j", "other", "nl", "t", "again", "f", "first", "form", "or", "one", "save", "added", "small", "blank", "old", "empty", "ew", "missing", "normal", "non", "aw", "var", "call", "un", "created", "n", "null", "result", "global", "p", "nm", "raw", "big", "box", "remote", "fresh", "row", "el", "we", "self", "v", "foreign", "diff"]}}
{"project": "qemu", "commit_id": "fa3aad24d94a6cf894db52d83f72a399324a17bb", "target": 0, "func": "int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                       void *opaque, int version_id)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n\n\n    if (version_id > vmsd->version_id) {\n\n        return -EINVAL;\n\n    }\n\n    if (version_id < vmsd->minimum_version_id_old) {\n\n        return -EINVAL;\n\n    }\n\n    if  (version_id < vmsd->minimum_version_id) {\n\n        return vmsd->load_state_old(f, opaque, version_id);\n\n    }\n\n    while(field->name) {\n\n        if (field->version_id <= version_id) {\n\n            void *base_addr = opaque + field->offset;\n\n            int ret, i, n_elems = 1;\n\n\n\n            if (field->flags & VMS_ARRAY) {\n\n                n_elems = field->num;\n\n            } else if (field->flags & VMS_VARRAY) {\n\n                n_elems = *(size_t *)(opaque+field->num_offset);\n\n            }\n\n            if (field->flags & VMS_POINTER) {\n\n                base_addr = *(void **)base_addr;\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *addr = base_addr + field->size * i;\n\n\n\n                if (field->flags & VMS_STRUCT) {\n\n                    ret = vmstate_load_state(f, field->vmsd, addr, version_id);\n\n                } else {\n\n                    ret = field->info->get(f, addr, field->size);\n\n\n\n                }\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n            }\n\n        }\n\n        field++;\n\n    }\n\n    if (vmsd->run_after_load)\n\n        return vmsd->run_after_load(opaque);\n\n    return 0;\n\n}\n", "idx": 16147, "substitutes": {"f": ["uf", "fx", "h", "ff", "d", "fs", "l", "fp", "ile", "fm", "fac", "bf", "util", "rf", "c", "q", "xf", "p", "df", "r", "fo", "m", "tf", "b", "fb", "e", "buffer", "fi", "fd", "g", "cf", "lf", "fr", "sf", "ef", "t", "fw", "fed", "file", "fc", "o", "v", "F", "form"], "vmsd": ["vnsd", " vmsdb", "mmesds", "vailsdh", "vailsdo", "vmesd", "vmmsl", "vnsp", "vmsl", "revensionsdm", "vmssd", "vnsl", "vmsdm", "vcsl", "vmesl", "vomsld", "vjsde", "vemssd", "vailsdm", "vfsdt", "vailsd", "vainsdm", "ccsp", "vcsd", "vtsdb", "wmsdt", "vtsd", "vainsdid", " vmsde", "virtualmsd", "vpsdn", "mmesdt", "revensionsad", "vjssd", "vlsd", "vomsde", "wmsbd", "virtualmsdo", "vmtdo", "virtualmtdid", " vmsdh", "vensionsd", "vmsds", "vomsbd", "vinssd", "vmesdt", "vcsdo", "revmsdo", "ccsl", "virtualmtdm", "vmsdh", "ccsd", "vnsad", "revmsd", "virtualmsdm", "vomsdt", " vinsd", "vmessd", "vjsd", "vailsde", "ccssd", "vsssd", "mmsdn", "vomsdo", "vcsdm", "vnssd", "vmmssd", "wmesbd", "vomsdm", "revensionsdo", "mmsds", "wmesdt", "vmsld", "vomsd", "cmsp", "vmsbd", "cmsd", " vinsds", "vinsds", "vcsp", "vfsd", "vailsdid", "cmssd", "vpsd", "vmesld", "vmesbd", "virtualmtd", "wmesld", "vmsdn", "virtualmsdid", "vtssd", " vomsdh", "vimssd", "vmsp", "vssd", "vmsdt", "virtualmtdo", "mmesdn", "vmemssd", "vpsl", " vomssd", "revmsad", "vmmsad", "vinsd", "vailssd", "vemsad", " vomsd", "vmtdid", "vmesdn", "vainsdo", "vtsds", "vensionsdm", "mmesd", "vjsdh", "vfsbd", "revensionsd", "vtsp", "vpsdt", "vtsl", "vensionsdo", "vomsdh", "mmssd", " vmsds", "vmsdo", "vimsl", "vmesad", "vcssd", "vlsl", "wmesd", "vimsd", "vimsds", "vensionsad", "vomssd", "vmesds", "vinsdb", "vmsdid", "vlsdn", "mmsd", "vcsad", "vemsd", " vomsde", " vinsdb", "vssds", "vmtdm", "cmsl", "vlsdt", "wmsd", "vmtd", " vinssd", "mmesl", "vmmsd", " vmssd", "vfsld", "mmsdt", "mmessd", "vainsd", "vssdb", "vmsde", "revmsdm", "vomsad", "wmsld", "vmsdb", "vemsl", "mmsl", "vmsad", "vmemsad", "vmemsd", "vmemsl"], "opaque": ["alque", "Opaque", "ipoxy", "penter", "ipaque", " opatile", "obacity", "ogatile", "obaque", "obatile", "popesc", "openter", "oboxy", "ogesc", "alaco", "ompacity", "obque", " opaques", "ogaque", "pacity", "Opatile", "popque", "opesc", " opoxy", "popatile", "ompaques", "opque", "popaque", "paque", "opacity", "opatile", "alacity", " opacity", "obaques", "opaques", "opaco", "ipaco", "ipacity", "ompaque", "paques", "ipque", "Opque", "obaco", "ogque", "ipatile", "ompenter", "opoxy", "Opesc", "alaque", "ipaques", "ipenter"], "version_id": ["version_time", "video_id", "versionalityd", "build_oid", " version_ids", "versioningid", "Version_d", "vision_ids", "versionalityId", "versionalityid", "vision_id", "Version_r", "version_version", "build_version", "version8uid", "Version_Id", "version_md", "version_uid", "visionityname", "VERSION_ID", "versionityoid", "VERSION_info", "versioninguid", "version2num", "version_d", "video8uid", "version2d", "video8ids", "vision_pid", "version_ids", "versionityid", "video8id", "version_oid", "version_r", "version_ide", "versionIdids", "build_id", "version_name", "version8ide", "vision_ID", "version8version", "version_data", "VERSION_id", "versionIdend", "usage_id", "build_data", "version_ID", "versionalityr", "visionityi", " version_end", "versionedversion", "versioneddata", "version_info", "version8id", "versioningide", "Version_id", "versionityname", "versionedoid", "vision_oid", "version_i", "video_uid", "vision_i", "versioningids", "version_pid", "version2id", "vision_name", "version2md", "vision_mid", "version_Id", "versionIdid", "version8data", "visionityoid", "video_ide", "vision_time", "versionedid", "vision_d", "version_mid", "version8oid", "usage_md", "VERSION_Id", "video8ide", "version8ids", "visionityid", "video_ids", "version_end", "usage_d", "usage_num", "versionityi", "version_num"], "field": ["view", "server", "error", "resource", "message", "add", "rule", "dump", "record", "offset", "param", "feature", "man", "function", "option", "term", "pair", "event", "d", "Field", "info", "player", "end", "component", "FIELD", "word", "complete", "util", "def", "tag", "store", "name", "good", "flag", "member", "line", "comment", "file", "part", "link", "ld", "form", "type", "child", "prefix", "version", "node", "format", "service", "key", "cell", "domain", "volume", "index", "job", "lf", "variable", "item", "lock", "layer", "arg", "handler", "plugin", "master", "var", "address", "task", "sim", "lc", "local", "state", "fields", "machine", "list", "dr", "desc", "entry", "window", "match", "attribute", "pointer", "fe", "manager", "module", "load", "row", "test", "mount", "pad", "section", "table", "user", "relation", "label"], "base_addr": ["base_id", "balance____id", "base67align", "base_offset", "base_address", "base67addr", "base67alt", "base_alt", "base__offset", "base64src", "base__ref", "base_src", "base__addr", "Base_offset", "base_ptr", "base66id", "base_align", "base____id", "base64addr", "balance_alt", "Base_address", "balance_addr", "base64dr", "base_ref", "balance____alt", "base__src", "Base_src", "base_dr", "Base_dr", "base____align", "base64address", "Base_ptr", "base__ptr", "base67id", "base66addr", "balance____align", "balance_id", "base66alt", "Base_ref", "balance____addr", "base66align", "base64offset", "balance_align", "base____addr", "base64ptr", "base____alt", "Base_addr"], "ret": ["usr", "ft", "ref", "RET", "elt", "nz", "tmp", "success", "out", "re", "hash", "cat", "Ret", "result", "ext", " RET", "def", "jump", "err", "r", "tf", "ptr", "tr", "ry", "Return", "flag", "mem", "alt", "repl", "nt", "rev", "att", "iter", "len", "fun", "res", "str", "back", "rex", "rm", "mt", "try", "gt", "t", "ll", "ter", "rets", "ts", " Ret", "resp", "rt", "cmd", "val", "print", "rest", "lit", "aux", "reset", "rem"], "i": ["qi", "info", "l", "ai", "ii", "n", "gi", "di", "sim", "cli", "x", "ip", "c", "ti", "li", "hi", "\u0438", "I", "ei", "p", "si", "ori", "m", "batch", "im", "e", "multi", "in", "ims", "fi", "index", "iu", "id", "it", "j", "me", "ci", "ie", "xi", "ic", "ki", "phi", "zi", "ix", "MI", "mi", "o", "pi", "v", "y", "ui", "ini", "bi"], "addr": ["rel", "ord", "address", "alloc", "off", "ip", "adr", "loc", "arr", "add", "ptr", "arm", "dr", "mk", "pos", "iter", "rr", "ack", "index", "id", "url", "at", "act", "ad", "offset", "amp", "gate", "inter", "coord", "order", "attr", "work", "grad", "align", "ix", "ace", "pad", "ac", "a", "arp", "wd", "grid"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,\n\n                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)\n\n{\n\n    TCGReg tmp0 = TCG_TMP0;\n\n    TCGReg tmp1 = ret;\n\n\n\n    assert(ret != TCG_TMP0);\n\n    if (ret == ah || ret == bh) {\n\n        assert(ret != TCG_TMP1);\n\n        tmp1 = TCG_TMP1;\n\n    }\n\n\n\n    switch (cond) {\n\n    case TCG_COND_EQ:\n\n    case TCG_COND_NE:\n\n        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);\n\n        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);\n\n        break;\n\n\n\n    default:\n\n        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);\n\n        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);\n\n        tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);\n\n        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);\n\n        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);\n\n        break;\n\n    }\n\n}\n", "idx": 16155, "substitutes": {"s": ["context", "h", "i", "fs", "l", "rs", "sg", "sb", "n", "ties", "ses", "ies", "S", "os", "session", "c", "sv", "q", "ps", "comm", "p", "sys", "r", "an", "es", "ls", "us", "hs", "gs", "b", "its", "js", "ctx", "sts", "w", "ims", "g", "sw", "less", "t", "ds", "self", "ix", "cs", "ts", "is", "south", "v", "stats", "ins", "qs", "y", "ains", "scl", "ns", "ss"], "cond": ["ond", "bind", "ind", "con", "adj", "comp", "dict", "condition", "bc", " cont", "compl", "cmp", "init", "c", "conf", "Cond", "pred", "connect", "check", "def", " pred", "key", "pos", " cmd", "code", " condition", "ctx", "dd", "fun", "cont", "cod", "red", "cf", "act", " conditional", "bit", "lock", "conn", "ct", "like", " Cond", "func", " con", "crit", "resp", "cmd", "ld", "stick", "mat", "cd", "form", "call", "co"], "ret": ["ft", "ref", "jp", "req", "RET", "tmp", "x", "out", "re", "buf", "reg", "Ret", "result", "p", "def", "not", "r", "true", "xt", "store", "sys", "tr", "desc", "ald", "ry", "Return", "alt", "mem", "repl", "nt", "rev", "rc", "ert", "att", "cert", "gc", "len", "g", "it", "res", "red", "back", "rex", "conn", "det", "mt", "gt", "try", "t", "arg", "test", "ter", "net", "rets", "get", "resp", "rt", "cmd", "val", "ob", "lit", "f", "obj", "or", "reset", "rem"], "al": ["cal", "h", "l", "ell", "ax", "am", "ale", "ag", "ali", "alf", "alg", "la", "als", "phal", "ar", " ali", "ul", "alan", "ap", "isal", "ald", "AL", "alt", "sal", "Al", "af", "ele", "bal", "ay", "ad", "pal", "hal", "alid", "en", "el", "il", " hal", " tal", "ial", "ral", "alog", "ab", "aler", "alph"], "ah": ["abc", "igh", "h", "hab", "ash", "yah", "av", "am", "az", " ha", "ur", "ha", "orth", "buf", "ar", "ahi", "het", "ap", "hi", "gh", "aff", "ach", "hr", "hs", "kh", "athe", "asha", "AH", "ih", "eh", "hl", "eth", "af", "rh", "ay", "at", "sh", "erb", "aph", "hal", "amb", "uh", "Ah", " hal", "enh", "oh", "au", "Oh", "aka", "ob", "ac", "alog", "ph", "ab", "ahs"], "bl": ["bs", "h", "BL", "hab", "l", "lp", "tl", "sb", "sl", "bt", "bc", "br", "bf", "bj", "ber", "ill", "lb", "bn", "pl", "bd", "loc", "pb", "kh", "db", "Al", "hl", "bel", "bal", "ay", "sh", "Bl", "hal", "amb", "ml", "abl", "fl", "nl", "jl", "ll", "oh", "ab", "lr", "hist", "bg", "bm", "ba"], "bh": ["bs", "igh", "h", "hab", "sb", "ith", "bt", "bc", "hub", "bm", "bf", "bj", "br", "lb", "hz", "bn", "osh", "dh", "cb", "bd", "gh", "bang", "hr", "bo", "kh", "hl", "ih", "eth", "bb", "rh", "bel", "biz", "sh", "hp", "hal", "uh", "nb", "phi", "bp", "vr", "oh", "ob", "bg", "hh", "ht"]}}
{"project": "qemu", "commit_id": "28f4a7083dcca084243e313ab18fcdb20d60334e", "target": 0, "func": "static void display_mouse_define(DisplayChangeListener *dcl,\n\n                                 QEMUCursor *c)\n\n{\n\n    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);\n\n\n\n    qemu_mutex_lock(&ssd->lock);\n\n    if (c) {\n\n        cursor_get(c);\n\n    }\n\n    cursor_put(ssd->cursor);\n\n    ssd->cursor = c;\n\n    ssd->hot_x = c->hot_x;\n\n    ssd->hot_y = c->hot_y;\n\n    g_free(ssd->ptr_move);\n\n    ssd->ptr_move = NULL;\n\n    g_free(ssd->ptr_define);\n\n    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);\n\n    qemu_mutex_unlock(&ssd->lock);\n\n}\n", "idx": 16163, "substitutes": {"dcl": ["cld", "Dbl", "dnCL", "dnfl", " dscl", "dscl", "dnscl", " dkl", " dfl", "lCL", "dld", "sdCL", "lld", " dpl", "sdscl", "ckl", "dpl", "dncl", "dkl", "lkl", "ccl", "sdcr", " dbl", "dfl", "sdpl", "sdcl", " dcr", "Dcl", "dCL", " dld", "sdbl", "dbl", "dcr", "lcl", "sdfl", " dCL", "cCL", "Dpl", "Dcr"], "c": ["abc", "h", "oc", "vc", "d", "ch", "l", "con", "i", "cache", "n", "pc", "bc", "lc", "x", "unc", "dc", "etc", "cur", "cmp", "col", "cm", "cp", "u", "cu", "xc", "conf", "cb", "p", "mc", "r", "cam", "m", "C", "b", "tc", "e", "cc", "rc", "ctx", "gc", "spec", "ce", "g", "cont", "arc", "ct", "enc", "ic", "ec", "t", "nc", "cs", "fc", "sc", "ca", "ac", "cr", "v", "f", "or", "can", "co"], "ssd": ["csssd", "ssr", "ssbd", "ssdc", "skyd", "asssd", "essd", "ssdh", "assd", "esssd", "skyisd", "ssisd", " ssld", "wsd", "cssd", "wsld", "rsspd", "cssdi", "issds", "wswd", "rssdh", "hessld", " ssds", "hessr", "esswd", "isssd", "tsds", "rssds", "skydh", "rssl", " ssdi", " ssad", "hessmd", "tsbd", "issd", "sswd", "cssad", "hessad", "essdb", "ssl", "rssdb", "cssmd", "ssld", "cssr", " ssbd", "tssd", "ssad", "cssbd", "wsdc", "sssd", " sssd", "cssdb", "skysd", "cssld", "issr", "SSd", "rssld", "hessdh", "SSbd", "essds", "asspd", "hessisd", "rsssd", "ssdi", "cssds", "rssbd", "cssl", " ssdc", "rssad", "tsd", "essdc", "rssdi", "rssd", "SSad", "ssdb", "SSdi", "hessds", "rssisd", " ssmd", "essld", "ssmd", "rssr", " sswd", "hesssd", "essl", "ssds", "essbd", "sspd", "assds", "SSsd", "esspd", "hessd"]}}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "static inline void stw_phys_internal(hwaddr addr, uint32_t val,\n\n                                     enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!memory_region_is_ram(section->mr) || section->readonly) {\n\n        addr = memory_region_section_addr(section, addr);\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n#if defined(TARGET_WORDS_BIGENDIAN)\n\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#else\n\n        if (endian == DEVICE_BIG_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#endif\n\n        io_mem_write(section->mr, addr, val, 2);\n\n    } else {\n\n        unsigned long addr1;\n\n        addr1 = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, addr);\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            stw_le_p(ptr, val);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            stw_be_p(ptr, val);\n\n            break;\n\n        default:\n\n            stw_p(ptr, val);\n\n            break;\n\n        }\n\n        invalidate_and_set_dirty(addr1, 2);\n\n    }\n\n}\n", "idx": 16164, "substitutes": {"addr": ["i", "rel", "usr", "ind", "ord", "ref", "rs", "ash", "address", "map", "asm", "elt", "ag", "Address", "point", "alloc", "tx", "x", "off", "hash", "ip", "gz", "hop", "src", "hw", "adr", "alias", "loc", "p", "arr", "r", "err", "add", "host", "tr", "dr", "handle", "pos", "mem", "alt", "rc", "len", "ctx", "ret", "to", "id", "url", "rn", "at", "ad", "res", "act", "offset", "inter", " address", "mt", "coord", "attr", "work", "align", "ix", "pad", "rt", "ac", "a", "var", "arp", "lr", "obj"], "val": [" value", "eval", "pool", "valid", "mem", "ret", "bal", "vals", " num", "grad", "pr", "pt", " slot", "prop", "sol", "serv", "als", "slot", "util", "tag", "vec", " valid", " al", "buffer", "vt", "res", "aval", "msg", "fail", " buf", "resp", "stat", " ty", "rel", "pol", "x", "value", "buf", "pl", "loc", "arr", "err", "key", "alt", "al", " v", " arg", "values", "data", "cond", "var", "cal", "Val", "ref", "elt", "tx", "col", "sel", " tx", "p", "VAL", " eval", "ival", " bl", "len", "cho", "el", "func", "attr", "rol", "test", "vol", "crit", " data", "v"], "endian": ["Endians", "ENDserv", "endsendor", "endoen", "enderoen", "endsoen", "endIAN", "endsIAN", "endserv", "enderrian", "endingians", "ndserv", "ENDendor", " endserv", "endingrian", " endIAN", "ndendor", "endedIAN", "endedian", "ENDian", "ENDians", "endingoen", "endingian", "endedserv", "endsrian", "Endian", "endsians", "ndians", "enderians", "endians", "Endendor", "endsian", "ENDIAN", "enderian", "endedians", "ndian", "Endserv", "endedendor", " endians", " endendor", "endrian", "endendor"], "ptr": ["rel", "ind", "ref", "req", "address", "alloc", "point", "buf", "inters", "np", "dh", "ps", "adr", "loc", "p", "prime", "arr", "r", "err", "add", "tr", "dr", "handle", "pos", "mem", "seek", "tp", "iter", "ctx", "pointer", "sp", "index", "pointers", "rect", "fd", "dep", "offset", "fr", "inter", "proc", "ctr", "func", "attr", "po", "grad", "vr", "pr", "pt", "ts", "pad", "deg", "rt", "Ptr", "obj", "pair"], "section": ["second", "ment", "status", "server", "header", "our", "year", "journal", "element", "sec", "instance", "region", "description", "param", "se", "feature", "man", "function", "option", "portion", "term", "pair", "sections", "side", "division", "group", "connection", "slot", "admin", "position", "tag", "set", "Section", "name", "member", "size", "line", "comment", "mod", "net", "part", "link", "command", "definition", "prefix", "version", "page", "tab", "session", "usage", "service", "key", "ser", "block", "index", "mode", "job", "item", "character", "area", "search", "address", "sect", "local", "state", "result", "list", "setting", "action", "port", "entry", "network", "module", "row", "test", "table", "relation", "sector"], "addr1": ["address3", " addr31", " addrOne", "adr1", " address0", " address1", "address0", "adr2", "addrOne", "addressOne", "ptr2", "adr0", "addr31", "address2", "ptr1", "ptr0", "addr2", "loc2", "ptrOne", "address1", " addr2", "adr3", " address2", "loc1", "address31", "addr3", "addr0", " addr0", "ptr3", " address3", "loc0", "loc31", " addr3"]}}
{"project": "FFmpeg", "commit_id": "afa982fdae1b49a8aee00a27da876bba10ba1073", "target": 1, "func": "static void compute_scale_factors(unsigned char scale_code[SBLIMIT],\n\n                                  unsigned char scale_factors[SBLIMIT][3], \n\n                                  int sb_samples[3][12][SBLIMIT],\n\n                                  int sblimit)\n\n{\n\n    int *p, vmax, v, n, i, j, k, code;\n\n    int index, d1, d2;\n\n    unsigned char *sf = &scale_factors[0][0];\n\n    \n\n    for(j=0;j<sblimit;j++) {\n\n        for(i=0;i<3;i++) {\n\n            /* find the max absolute value */\n\n            p = &sb_samples[i][0][j];\n\n            vmax = abs(*p);\n\n            for(k=1;k<12;k++) {\n\n                p += SBLIMIT;\n\n                v = abs(*p);\n\n                if (v > vmax)\n\n                    vmax = v;\n\n            }\n\n            /* compute the scale factor index using log 2 computations */\n\n            if (vmax > 0) {\n\n                n = av_log2(vmax);\n\n                /* n is the position of the MSB of vmax. now \n\n                   use at most 2 compares to find the index */\n\n                index = (21 - n) * 3 - 3;\n\n                if (index >= 0) {\n\n                    while (vmax <= scale_factor_table[index+1])\n\n                        index++;\n\n                } else {\n\n                    index = 0; /* very unlikely case of overflow */\n\n                }\n\n            } else {\n\n                index = 63;\n\n            }\n\n            \n\n#if 0\n\n            printf(\"%2d:%d in=%x %x %d\\n\", \n\n                   j, i, vmax, scale_factor_table[index], index);\n\n#endif\n\n            /* store the scale factor */\n\n            assert(index >=0 && index <= 63);\n\n            sf[i] = index;\n\n        }\n\n\n\n        /* compute the transmission factor : look if the scale factors\n\n           are close enough to each other */\n\n        d1 = scale_diff_table[sf[0] - sf[1] + 64];\n\n        d2 = scale_diff_table[sf[1] - sf[2] + 64];\n\n        \n\n        /* handle the 25 cases */\n\n        switch(d1 * 5 + d2) {\n\n        case 0*5+0:\n\n        case 0*5+4:\n\n        case 3*5+4:\n\n        case 4*5+0:\n\n        case 4*5+4:\n\n            code = 0;\n\n            break;\n\n        case 0*5+1:\n\n        case 0*5+2:\n\n        case 4*5+1:\n\n        case 4*5+2:\n\n            code = 3;\n\n            sf[2] = sf[1];\n\n            break;\n\n        case 0*5+3:\n\n        case 4*5+3:\n\n            code = 3;\n\n            sf[1] = sf[2];\n\n            break;\n\n        case 1*5+0:\n\n        case 1*5+4:\n\n        case 2*5+4:\n\n            code = 1;\n\n            sf[1] = sf[0];\n\n            break;\n\n        case 1*5+1:\n\n        case 1*5+2:\n\n        case 2*5+0:\n\n        case 2*5+1:\n\n        case 2*5+2:\n\n            code = 2;\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        case 2*5+3:\n\n        case 3*5+3:\n\n            code = 2;\n\n            sf[0] = sf[1] = sf[2];\n\n            break;\n\n        case 3*5+0:\n\n        case 3*5+1:\n\n        case 3*5+2:\n\n            code = 2;\n\n            sf[0] = sf[2] = sf[1];\n\n            break;\n\n        case 1*5+3:\n\n            code = 2;\n\n            if (sf[0] > sf[2])\n\n              sf[0] = sf[2];\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n        \n\n#if 0\n\n        printf(\"%d: %2d %2d %2d %d %d -> %d\\n\", j, \n\n               sf[0], sf[1], sf[2], d1, d2, code);\n\n#endif\n\n        scale_code[j] = code;\n\n        sf += 3;\n\n    }\n\n}\n", "idx": 16177, "substitutes": {"scale_code": ["scaleityoperator", "scaleityfactor", " scale_operator", "scaleitycodes", " scale_factor", "scale_factor", " scale_codes", "scale_operator", "scale_codes", "scaleitycode"], "scale_factors": ["scale_ctories", "scale_formrees", "scale_Factores", "scale_factsters", "scale_ctorset", "scale_actters", "scale_actors", "scale_actorset", "scale_ctters", "scale_formores", "scale_factters", "scale_Factrees", "scale_factorset", "scale_factrees", "scale_actrees", "scale_factsories", "scale_factsorset", "scale_Factories", "scale_factsors", "scale_factores", "scale_formories", "scale_Factors", "scale_factories", "scale_formors", "scale_actores", "scale_actories", "scale_ctors"], "sb_samples": ["sb_exources", "sb_examples", "sb_tamps", "sb_seaces", "sb_sources", "sb_tources", "sb_examps", "sb_samamps", "sb_samamples", "sb_samps", "sb_saces", "sb_seamples", "sb2exores", "sb2samps", "sb_exores", "sb2examps", "sb_seores", "sb_taces", "sb2examples", "sb_ssores", "sb_seamps", "sb2exources", "sb_ssamples", "sb_ssources", "sb_tamples", "sb2sores", "sb_ssamps", "sb_samaces", "sb_seources", "sb_sores", "sb_samources", "sb2samples", "sb2sources"], "sblimit": ["sblimiter", "sflumit", "sblomit", "sblemit", "splemit", "splimIT", "sblIMIT", "sflumIT", "sflimit", "sblemiter", "sblimite", "sblumit", "splemIT", "sflumiter", "sflimite", "splemiter", "sblimalIT", "splimit", "splimitle", "splemitle", "sflimIT", "sblIMit", "sblumIT", "splimiter", "sblimaliter", "sblumite", "sblIMite", "sblemite", "sflimiter", "sblimitle", "sblimIT", "sblomitle", "sflumite", "sblimalitle", "sblumiter", "sblomIT", "sblemitle", "sblimalit", "sblemIT", "sblIMiter", "sblomiter"], "p": ["pkg", "d", "jp", "prop", "rep", "lp", "power", "pc", "pe", "point", "x", "pa", "ip", "pers", "cp", "q", "ps", "c", "ap", "u", "pl", "wp", "ping", "m", "pb", "vp", "tp", "parse", "op", "P", "g", "t", "bp", "pr", "pt", "part", "pp", "pi", "f", "par", "perm", "ph", "y", "pm", "pair"], "vmax": ["lvMax", "svax", "avmax", "svmin", " vrange", "valgt", "vemax", "lvMAX", "svMAX", " vmx", "Vax", "vmin", "avmin", "lvmin", "VMAX", "lvrange", "vopen", "Vright", "vMAX", "svopen", "vrange", "vegt", "vax", "vgt", "vconf", " vconf", " vax", "valmx", "nax", "Vmax", "avMAX", "VMax", " vMax", "avax", "Vmin", "avMax", "valconf", "nMax", " vopen", "vemx", "svrange", "valmax", " vmin", "svMax", "lvopen", "vright", "veconf", "vMax", "vmx", "nmax", " vright", "svmax", "nMAX", " vgt", "lvmax", "avright", " vMAX"], "v": ["h", "vc", "d", "tv", "l", "ve", "av", "V", "conv", "x", "value", "nv", "sv", "q", "u", "ver", "uv", "m", "vs", "vp", "dev", "vt", "vi", "lv", "cv", "va", "ev", "values", "iv", "qv", "ov", "vv", "vol", "vert", "vr", "inv", "val", "f", "y", "w", "vm", "vo"], "n": ["d", "sn", "l", " N", "nd", "nw", "x", "nan", "nv", "np", "nu", "c", "q", "cn", "r", "m", "nm", "mn", "ne", "N", "Ni", "b", "nt", "ot", "len", "no", "ng", "nr", "na", "size", "g", "nn", "num", "max", "nl", "nb", "t", "net", "nc", "y", "w", "ns"], "i": ["qi", "iq", "o", "ind", "l", "ai", "ii", "z", "di", "point", "x", "out", "ij", "ip", "init", "c", "q", "ti", "li", "I", "jj", "s", "si", "m", "ri", "ia", "im", "multi", "in", "e", "b", "ami", "my", "iu", "id", "it", "um", "at", "me", "ci", "ie", "xi", "ex", "ic", "ik", "ki", "t", "phi", "zi", "ix", "mi", "a", "is", "pi", "y", "bi", "ini", "by", "f", "iat", "io"], "j": ["bs", "h", "d", "ind", "jp", "l", "ji", "aj", "z", "json", "br", "x", "bj", "off", "ij", "ion", "jo", "c", "q", "jj", "jump", "r", "m", "key", "bo", "b", "e", "ja", "js", "ret", "to", "g", "it", "job", "str", "uj", "fr", "dj", "kj", "J", "t", "jc", "o", "y", "bi", "be", "obj", "jl", "f", "jit"], "k": ["kind", "kw", "kn", "ku", "ko", "ks", "z", "ck", "tk", "kin", "wk", "c", "q", "kl", "m", "key", "kk", "mk", "kh", "b", "kick", "sk", "ijk", "ok", "g", "uk", "kt", "ka", "kj", "ke", "km", "ik", "ak", "t", "ek", "ki", "kid", "K", "kr", "unk", "ac", "ph"], "code": ["event", "cause", "second", "ind", "ch", "codes", "type", "sign", "info", "condition", "component", "status", "content", "header", "error", "sequence", "next", "cmp", "state", "one", "c", "force", "message", "check", "change", "tag", "key", "action", "desc", "name", "close", "pos", "entry", "cc", "count", "reason", "note", " Code", "id", "ce", "size", "cod", "use", "description", "offset", "data", "try", "comment", "coe", "ode", "test", "function", "command", "length", "cycle", "definition", "call", "label", "Code"], "index": ["second", "status", "success", "error", "prime", "check", "scan", "close", "pos", "initial", "instance", "offset", "ex", "scroll", "option", "info", "connection", "ion", "draw", "number", "set", "position", "zero", "start", "timeout", "loop", "size", "num", "zone", "open", "order", "ix", "link", "is", "length", "location", "shape", "ind", "type", "condition", "page", "x", "node", "value", "connect", "loc", "change", "si", "Index", "empty", "key", "update", "count", "block", "note", "seed", "lock", "max", "val", "search", "address", "time", "level", "point", "out", "state", "result", "find", "capacity", "list", "port", "EX", "network", "iter", "slice", "id", "row", "ice", "iso", "test", "write", "cycle", "label"], "d1": ["d5", "bd5", " d3", "bd1", "v1", "D1", "n0", "n1", "pdone", " done", "d41", "f3", "n5", " d0", "Done", "pd41", "f1", "none", "pd2", "bd2", "done", "bd0", " d5", "dup", "vup", " dup", "d0", "bdone", " d7", "v7", "D2", "d7", "D41", "f7", "bd41", "pd1", "v3", "d3", "fup"], "d2": ["d5", "dt5", "bd5", "bd3", " d3", "D1", "d02", "dd3", "Dtwo", "dd02", "dd1", " dtwo", "d64", "D02", "dd2", "dtwo", " d64", "bd64", "dt3", "D3", "n2", "bd2", "ntwo", " d5", " d02", "dt2", "dt64", "D2", "n02", "d3"], "sf": ["uf", "fx", "dl", "stab", "fs", "sn", "fm", "sb", "sol", "fy", "sl", "ty", "bf", "alf", "bj", "ctl", "sql", "zz", "SF", "rf", "sv", "hw", "xf", "tif", "df", "sy", "si", "fo", "tf", "ssl", "pb", "vp", "hs", "buff", "qq", "gs", "tp", "ief", "fi", "sp", "sk", "fd", "csv", "cf", "sh", "rn", "sq", "sw", "supp", "lf", "sd", "see", "rm", "sr", "php", "ds", "fw", "fee", "ssh", "ze", "isf", "sm", "f", "scl", "ss"]}}
{"project": "FFmpeg", "commit_id": "b926b6282d3b9fc8115660ae013f74f4f8c06d30", "target": 0, "func": "static void opt_new_stream(const char *opt, const char *arg)\n\n{\n\n    AVFormatContext *oc;\n\n    if (nb_output_files <= 0) {\n\n        fprintf(stderr, \"At least one output file must be specified\\n\");\n\n        ffmpeg_exit(1);\n\n    }\n\n    oc = output_files[nb_output_files - 1];\n\n\n\n    if      (!strcmp(opt, \"newvideo\"   )) new_video_stream   (oc);\n\n    else if (!strcmp(opt, \"newaudio\"   )) new_audio_stream   (oc);\n\n    else if (!strcmp(opt, \"newsubtitle\")) new_subtitle_stream(oc);\n\n    else assert(0);\n\n}\n", "idx": 16183, "substitutes": {"opt": ["usr", "prop", "kw", "req", "lt", "aux", "eff", "txt", "etc", "init", "cat", "ver", "ost", "not", "org", "Opt", "tr", "options", "tip", "oop", "ot", "iter", "block", "nom", "ok", "op", "it", "str", "og", "help", "other", "rop", "proc", "gt", "OP", "attr", "typ", "expr", "net", "crit", "rt", "cmd", "stat", "text", "option", "var", "oss", "obj", "term"], "arg": ["event", "kw", "ax", "ag", "argument", "tag", "args", "key", "flag", "parse", "count", "block", "spec", "op", "g", "at", "og", "use", "Arg", "proc", "param", "ig", "config", "cmd", "command", "doc", "call"], "oc": ["vc", "ocation", "voc", "om", " ic", "pc", "bc", "aic", "alloc", "unc", "oe", "dc", "c", "cu", "ost", "oid", "mc", "org", "mic", "oco", "irc", "isc", "ot", "rc", "gc", "toc", "ocr", "OC", "orp", "og", "nic", "arc", "soc", "ov", "ico", "ox", "ec", "anc", "ic", "ocon", "ek", "osc", "nc", "cs", "uc", "roc", "o", "ac", "ob", "oci", "oss", "erc", "io", "co"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,\n\n\tunsigned int width, unsigned int height,\n\n\tint lumStride, int chromStride, int srcStride)\n\n{\n\n\tunsigned y;\n\n\tconst unsigned chromWidth= width>>1;\n\n\tfor(y=0; y<height; y+=2)\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\tasm volatile(\n\n\t\t\t\"xor %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\t\"pcmpeqw %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"psrlw $8, %%mm7\t\t\\n\\t\" // FF,00,FF,00...\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 64(%0, %%\"REG_a\", 4)\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\", 4), %%mm0\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq 8(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // U0V0 U0V0(0)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // U0V0 U0V0(4)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(0)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(4)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(0)\n\n\n\n\t\t\tMOVNTQ\" %%mm2, (%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"movq 16(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq 24(%0, %%\"REG_a\", 4), %%mm2\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq %%mm2, %%mm4\t\t\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // U0V0 U0V0(8)\n\n\t\t\t\"psrlw $8, %%mm2\t\t\\n\\t\" // U0V0 U0V0(12)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(8)\n\n\t\t\t\"pand %%mm7, %%mm4\t\t\\n\\t\" // Y0Y0 Y0Y0(12)\n\n\t\t\t\"packuswb %%mm2, %%mm1\t\t\\n\\t\" // UVUV UVUV(8)\n\n\t\t\t\"packuswb %%mm4, %%mm3\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm3, 8(%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // UVUV UVUV(8)\n\n\t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // V0V0 V0V0(0)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // V0V0 V0V0(8)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // U0U0 U0U0(0)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // U0U0 U0U0(8)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // VVVV VVVV(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // UUUU UUUU(0)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, (%2, %%\"REG_a\")\t\\n\\t\"\n\n\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth)\n\n\t\t\t: \"memory\", \"%\"REG_a\n\n\t\t);\n\n\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tasm volatile(\n\n\t\t\t\"xor %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 64(%0, %%\"REG_a\", 4)\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\", 4), %%mm0\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq 8(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"movq 16(%0, %%\"REG_a\", 4), %%mm2\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq 24(%0, %%\"REG_a\", 4), %%mm3\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"pand %%mm7, %%mm0\t\t\\n\\t\" // Y0Y0 Y0Y0(0)\n\n\t\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\" // Y0Y0 Y0Y0(4)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(8)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(12)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // YYYY YYYY(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%1, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, 8(%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth)\n\n\t\t\t: \"memory\", \"%\"REG_a\n\n\t\t);\n\n#else\n\n\t\tunsigned i;\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+0];\n\n\t\t\tudst[i] \t= src[4*i+1];\n\n\t\t\tydst[2*i+1] \t= src[4*i+2];\n\n\t\t\tvdst[i] \t= src[4*i+3];\n\n\t\t}\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+0];\n\n\t\t\tydst[2*i+1] \t= src[4*i+2];\n\n\t\t}\n\n#endif\n\n\t\tudst += chromStride;\n\n\t\tvdst += chromStride;\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\t}\n\n#ifdef HAVE_MMX\n\nasm volatile(   EMMS\" \\n\\t\"\n\n        \tSFENCE\" \\n\\t\"\n\n        \t:::\"memory\");\n\n#endif\n\n}\n", "idx": 16190, "substitutes": {"src": ["dist", "usr", "rs", "sn", "sb", "inc", "sl", "txt", "lat", "addr", "lb", "dest", "input", "st", "loc", "sub", "sys", "r", "scan", "img", "rx", "ser", "tr", "syn", "in", "sur", "rc", "hl", "rect", "str", "rl", "sq", "sw", "sr", "inst", "filename", "rol", "lib", "sc", "source", "rt", "ins", "lr", "RC", "ipl", "sym"], "ydst": ["xdist", "hydst", "xdost", "odST", "ynset", "hdnd", "hdsta", "ytSt", "ydSt", "ydste", "hydnd", "ytsta", "ytste", "ydsta", "ynst", "dysta", "odst", "odost", "xdST", "hdst", "yust", "dyst", "hydsta", "dySt", "ydost", "ydset", "xdst", "ynnd", "ynsta", "yuste", "hdset", "yusta", "odist", "ydST", "ldST", "dyste", "ytst", "ydnd", "yuSt", "hydset", "ldst", "ldost", "ydist", "ldist"], "udst": ["vdsrc", "odsrc", "odsta", "rodost", "rodst", "udsrc", "adst", "ubsc", "ubstr", "odsc", "adstr", "odnd", "udstr", "ubnd", "rodsrc", "udsc", "adnd", "odstr", "odst", "adsc", "odost", "ubst", "udsta", "vdost", "udost", "rodsta", "udnd", "vdsta"], "vdst": ["vdsrc", "odstart", "ldbl", "udsrc", "udset", "vdstr", "ldstr", "odbl", "udt", "vdstart", "odstr", "wdt", "odst", "pdsrc", "vdbl", "pdset", "ddbl", "pdst", "wdset", "ddst", "pdt", "wdsrc", "ddstart", "vdt", "ddstr", "ldst", "vdset", "wdst", "ldstart"], "height": ["shape", "h", "rank", "ch", "ty", "padding", "history", "x", "above", "depth", "density", "H", "capacity", "Height", "start", "zh", "hang", "flow", "hs", "window", "count", "block", "he", "total", "ih", "id", "size", "rows", "grow", "row", "max", "inches", "bottom", "hei", "high", "wh", "length", "w", "ht", "build"], "lumStride": ["lumaEstro", "lumaStride", "lumbRestride", "lumStide", "lumbStro", "lumstride", "lumStrip", "lumaEstrip", "lumRestrap", "lumaEstride", "lumRestro", "lumRrap", "lumStrr", "lumaStro", "lumStrro", "lumEstro", "lumRestrip", "lumRestide", "lumbRestr", "lumStro", "lumEstrap", "lumaEstrap", "lumaStrap", "lumRride", "lumRro", "lumstr", "lumstro", "lumEstride", "lumRrip", "lumbStride", "lumbStide", "lumbRestide", "lumbStr", "lumEstrip", "lumaStrip", "lumStr", "lumstide", "lumbRestro", "lumStrride", "lumRestr", "lumRestride", "lumStrap"], "chromStride": ["chromStide", "romStrrip", "chromStrrip", "romStrride", "chromRestrip", "chromRestape", "romStide", "romStride", "chromSTrip", "chromStrride", "chromRestride", "romStrape", "chromSTride", "chromSTape", "romStape", "chromStape", "romStrip", "chromStrip", "chromSTide", "chromStrape", "chromRestide"], "srcStride": ["srcstide", "srcRestride", " srcStack", "srcDestrobe", "srcStrwrite", " srcListride", "rcStrobe", "rcStrwrite", "srcstack", "srcListride", "srcDestwrite", "srcStrride", "srcRestide", "srcDestide", "srcstride", "srcStrobe", "srcDestride", "rcStide", "rcStwrite", "srcRestack", "srcSTide", "srcStrrobe", "srcSTwrite", "srcStriction", " srcStriction", "rcStrrobe", "srcSTrobe", " srcStide", "rcStrride", " srcListack", "srcstriction", " srcListide", " srcListriction", "srcStide", "srcSTride", "srcStwrite", "srcListriction", "rcStride", "srcRestriction", "srcListide", "srcListack", "srcStack"], "y": ["h", " Y", "ey", "ch", "py", "ly", "ady", "vy", "ty", "k", "aily", "ies", "x", "out", "cy", "iy", "dy", "top", "yo", "yn", "asy", "p", "sy", "ym", "m", "hey", "e", "count", "my", "xy", "index", "yp", "ay", "yet", "j", "yt", "ya", "ys", "gy", "axy", "yl", "oy", "t", "yy", "yr", "Y", "ley", "sky", "by", "w", "ny"]}}
{"project": "FFmpeg", "commit_id": "80b1e1c03d26ade05b0f53d0731aa7398d4ef6f9", "target": 1, "func": "static int huf_uncompress(GetByteContext *gb,\n\n                          uint16_t *dst, int dst_size)\n\n{\n\n    int32_t src_size, im, iM;\n\n    uint32_t nBits;\n\n    uint64_t *freq;\n\n    HufDec *hdec;\n\n    int ret, i;\n\n\n\n    src_size = bytestream2_get_le32(gb);\n\n    im = bytestream2_get_le32(gb);\n\n    iM = bytestream2_get_le32(gb);\n\n    bytestream2_skip(gb, 4);\n\n    nBits = bytestream2_get_le32(gb);\n\n    if (im < 0 || im >= HUF_ENCSIZE ||\n\n        iM < 0 || iM >= HUF_ENCSIZE ||\n\n        src_size < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    bytestream2_skip(gb, 4);\n\n\n\n    freq = av_calloc(HUF_ENCSIZE, sizeof(*freq));\n\n    hdec = av_calloc(HUF_DECSIZE, sizeof(*hdec));\n\n    if (!freq || !hdec) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0)\n\n        goto fail;\n\n\n\n    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {\n\n        ret = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n\n\n    if ((ret = huf_build_dec_table(freq, im, iM, hdec)) < 0)\n\n        goto fail;\n\n    ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst);\n\n\n\nfail:\n\n    for (i = 0; i < HUF_DECSIZE; i++) {\n\n        if (hdec[i].p)\n\n            av_freep(&hdec[i].p);\n\n    }\n\n\n\n    av_free(freq);\n\n    av_free(hdec);\n\n\n\n    return ret;\n\n}\n", "idx": 16197, "substitutes": {"gb": ["gd", "uf", "goo", "ch", "GB", "py", "sb", "io", "pc", "gpu", "bytes", "bt", "bc", "gm", "hub", "bf", "rb", "gz", "gg", "src", "cb", "bn", "gh", "sys", "ib", "tg", "img", "args", "pb", "cfg", "mb", "storage", "gs", "db", "pg", "eb", "xy", "ctx", "gin", "gc", "cv", "gow", "eg", "bb", "g", "csv", "html", "gnu", "rg", "range", "um", "msg", "gy", "gt", "nb", "phy", "gif", "deg", "kb", "wb", "gov", "emb", "bg", "Gb"], "dst": ["fct", " dux", "gst", "gnt", "dsts", "dnt", "dsdest", "dednt", "fsts", " ddest", "ddest", "deddest", " dsts", "gux", "dux", "fdest", "dsst", "fst", "dedux", "dct", "gdest", "dsct", "dedst", " dnt", "dssts", " dct"], "dst_size": ["dst2Size", "dst_ize", "dest_ize", "dest_size", "dest_name", "dst_name", "dst2size", "dst_Size", "dst2ize", "ddest_SIZE", "ddest_size", "ddest_Size", "dst2name", "dest_Size", "dst_SIZE"], "src_size": ["rc_size", "src2share", "src_len", "src__len", "src2size", " src_len", "src_length", "src__length", "src__size", "src_space", "rc_length", "src2SIZE", "src_SIZE", " src_length", " src_SIZE", "src__SIZE", " src_share", "rc_SIZE", " src_space", "rc_len", "src2space", "src2len", "src_share", "src2length"], "im": ["imming", "iem", "iam", "ai", "imi", "om", "fm", "am", "dom", "gm", "med", "sim", "ij", "ip", "ime", "him", "aim", "cm", "tim", "imet", "iman", "mic", "ib", "m", "imus", "imp", "arm", "ym", "irm", "ir", "dim", "ami", "com", "ims", "ih", "imm", "rim", "um", "iv", "anim", "ie", "IM", "ic", "em", "il", "ig", "rom", "umi", "mi", "Im"], "iM": ["iMB", " iJM", "iniMI", "tiM", "iuH", "iD", "iuMM", "iuMB", "itN", "IJM", "iMI", "iH", "iMT", "siD", "iuL", "iR", "iniM", "tiMT", "iMX", "itM", "iuD", "tiMX", " iN", "siH", "iuM", "tiMM", "iDM", "tiL", "iME", "iO", "IMM", "siMI", "iuMX", " iP", " iL", "iuN", "siMM", "ioP", " iDM", "tiME", "iMP", "iniN", " iMX", "uiM", "iP", "uiJM", "iniO", "IM", "oMP", "iuMT", "iL", "IN", "iuR", "iMM", "ioDM", " iMP", " iR", " iH", "iJM", "ioM", " iD", "iuME", "oDM", "siM", " iO", "iuO", "itMM", "iN", " iME", " iMT", " iMM", " iMB", "tiR", "itMI", "ioMP", "oM", "siN", "uiN", "iniMB", "oP", "iniMM", "uiMM"], "nBits": ["nBalins", " nbits", "nIBits", " nBins", "nUbins", "nBITS", " nIBins", "nBalugs", "nBacks", "nCBits", "nbits", "nBsbits", "nCBbits", " nBicks", "NButbits", " nbugs", "nAbits", "nCBITS", "nRbits", " nBITS", "nBins", "nBips", "nbicks", "nButits", "nBsits", "nIBicks", "NBbits", "nRITS", "nBbits", "nBsins", " nBugs", "nBicks", "nChugs", "nIBbits", " nbips", " nbins", "nbugs", "nAbbits", "nBalips", "nBugs", "nChins", "NBits", " nIBbits", "NBacks", "nUbbits", "nChips", "nCBins", "nButacks", "nBsacks", "nChits", "nRits", " nIBicks", "nRins", "NButacks", " nBbits", "nButins", "NBins", " nBips", " nIBits", "nbins", "nBalits", "nUbacks", "nbips", "nAbicks", "nIBins", "nbbits", "nUbits", "NButins", "NButits", "nAbins", "nButbits"], "freq": ["frqt", "feqt", "Freqs", "fireq", "falqq", "Frerequ", "auv", "broadq", "finq", "feqv", "produq", "frerequ", "freqi", "fireck", "auQ", "freqq", "falqv", "finck", " freqq", "frequencyq", "slerequ", "produQ", "freQ", " freux", "feqi", "Freck", "produrequ", "Freux", "produqs", "freeqs", "frev", "frequencyque", " freQ", "broadQ", "FreQ", "fev", "fireQ", "auq", "feqq", "freux", "fereq", "falq", "finqt", "sleq", "freeq", "freeQ", "freque", "aureq", "sleqq", "broadqq", "frequencyqv", " frerequ", "sleque", "frck", "freqs", " freck", "falqi", "frqs", "Freqq", " frereq", "frq", "freqv", "freqt", "feck", " freqs", "broadrequ", "feq", " frev", "feque", "frequencyqq", "frequencyqi", "freck", "finqs", "ferequ", "feQ", "Freq", "freeqq", "frequencyrequ", "frereq", "feqs", "fireux"], "hdec": ["htmldecl", "ihdecl", "shrec", "ihdel", "hneg", "hfunc", "htmldec", "ohdecl", " hneg", "rder", "ihDec", "hhdec", "hrnext", "hiDec", "hhdesc", " hDec", "ahdec", "hrdec", "htmlneg", "hrrec", "Hdecl", "hidecl", " hdecl", "ahdel", "hrec", "Hrec", "hdes", " hrec", " hdesc", "hhdecl", "hDec", "ohder", "ahdesc", "hrdecl", "shdecl", "hdecl", "ahdecl", "hidec", "rrec", "ehdes", "hde", "hdesc", "ohfunc", "ehdec", "htmlDec", "hnext", "ihde", "ohdec", "shder", "HDec", "ahdes", "Hdes", "hdel", "Hneg", "rdec", "ahde", "Hfunc", " hde", "Hdesc", "Hdec", "ihrec", "ihdes", "ohdesc", "hhfunc", "ihdec", "shdec", "ohde", " hnext", "Hde", "ohrec", "hineg", "ehdel", " hdes", "hder", "ihnext", "rdecl", "ehde", "ohDec"], "ret": ["rel", "ft", "ref", "jp", "RET", "elt", "dt", "status", "progress", "success", "summary", "complete", "alg", "out", "re", "full", "off", "Ret", "result", "ort", "ext", "pas", "del", "xt", "def", "sys", "et", "ry", "Return", "flag", "alt", "mem", "att", "nt", "rev", "cert", "ert", "iter", "fun", "cont", "it", "res", "url", "j", "back", "rm", "mt", "det", "gt", "nl", "arg", "ll", "net", "rets", " Ret", "resp", "rt", "deg", "val", "print", "cmd", "lit", "aux", "reset", "rem"], "i": ["qi", "ind", "info", "ai", "ii", "parent", "n", "gi", "di", "sim", "x", "wi", "cli", "ip", "q", "ti", "u", "li", "\u0438", "I", "p", "s", "ei", "mc", "si", "batch", "m", "oi", "ma", "ir", "b", "multi", "chain", "in", "iter", "ami", "index", "g", "it", "j", "me", "ci", "xi", "ic", "ki", "t", "phi", "zi", "ix", "mi", "o", "is", "pi", "v", "f", "bi", "ini", "y", "ui", "io"]}}
{"project": "FFmpeg", "commit_id": "b25e84b7399bd91605596b67d761d3464dbe8a6e", "target": 1, "func": "static int hevc_frame_start(HEVCContext *s)\n\n{\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n    int ret;\n\n\n\n    memset(s->horizontal_bs, 0, 2 * s->bs_width * (s->bs_height + 1));\n\n    memset(s->vertical_bs,   0, 2 * s->bs_width * (s->bs_height + 1));\n\n    memset(s->cbf_luma,      0, s->sps->min_tb_width * s->sps->min_tb_height);\n\n    memset(s->is_pcm,        0, s->sps->min_pu_width * s->sps->min_pu_height);\n\n\n\n    lc->start_of_tiles_x = 0;\n\n    s->is_decoded        = 0;\n\n\n\n\n    if (s->pps->tiles_enabled_flag)\n\n        lc->end_of_tiles_x = s->pps->column_width[0] << s->sps->log2_ctb_size;\n\n\n\n    ret = ff_hevc_set_new_ref(s, s->sps->sao_enabled ? &s->sao_frame : &s->frame,\n\n                              s->poc);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    ret = ff_hevc_frame_rps(s);\n\n    if (ret < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Error constructing the frame RPS.\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    ret = set_side_data(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    av_frame_unref(s->output_frame);\n\n    ret = ff_hevc_output_frame(s, s->output_frame, 0);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    ff_thread_finish_setup(s->avctx);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    if (s->ref)\n\n        ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);\n\n    s->ref = NULL;\n\n    return ret;\n\n}", "idx": 16203, "substitutes": {"s": ["bs", "fs", "ties", "styles", "views", "ps", "r", "ms", "ports", "js", "g", "services", "sw", "gets", "se", "sc", "tests", "plays", "ins", "details", "h", "changes", "sb", "serv", "ops", "results", "os", "als", "sv", "has", "ches", "sports", "erences", "events", "as", "ags", "tags", "j", "t", "times", "states", "is", "south", "parts", "ns", "tes", "l", "rs", "ies", "ars", "S", "reports", "c", "comm", "sys", "ls", "vs", "hs", "ats", "its", "ims", "sq", "sets", "acs", "ts", "o", "ows", "a", "qs", "params", "ss", "sts", "aunts", "n", "settings", "ses", "bes", "ar", "conf", "p", "es", "us", "xs", "aws", "gs", "b", "e", "ctx", "spec", "eds", "less", "ds", "self", "cs", "comments", "v", "stats", "w", "scl"], "lc": ["LC", "wl", "dl", "vc", "l", "lp", "tl", "pc", "bc", "unc", "cm", "lb", "c", "xc", "cp", "cb", "loc", "mc", "kl", "ls", "ln", "tc", "cc", "lv", "ctx", "gc", "lf", "rl", "coll", "cl", "lu", "ec", "nl", "ll", "fc", "cs", "lr", "icc"], "ret": ["tn", "status", "re", "reply", "Ret", "addr", "mem", "att", "vet", "url", "ter", "rets", "rem", "usr", " alt", "dt", "txt", "pas", " RET", "del", "def", "tr", "flag", "final", "gc", "res", "j", "try", "t", "net", "get", "resp", "cmd", "print", "f", "jp", "RT", "RET", "ber", "off", "ext", "arr", "err", "leg", "Return", "alt", "nt", "cert", "rm", "det", "mt", "gt", "rt", "deg", "val", "ft", "ref", "elt", "lt", "nz", "out", " jet", "result", "rev", "len", "fun", "cont", "back", "ll", " fut", " Ret", "mel", "reset"]}}
{"project": "qemu", "commit_id": "4ed7b2c3a78f785a1bcbe575e08c379b166723e3", "target": 1, "func": "static int local_open2(FsContext *fs_ctx, V9fsPath *dir_path, const char *name,\n\n                       int flags, FsCred *credp, V9fsFidOpenState *fs)\n\n{\n\n    char *path;\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n    V9fsString fullname;\n\n    char *buffer;\n\n\n\n    /*\n\n     * Mark all the open to not follow symlinks\n\n     */\n\n    flags |= O_NOFOLLOW;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    path = fullname.data;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(buffer, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set client credentials in .virtfs_metadata directory files */\n\n        err = local_set_mapped_file_attr(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n               (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    err = fd;\n\n    fs->fd = fd;\n\n    goto out;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(buffer);\n\n    errno = serrno;\n\n    g_free(buffer);\n\nout:\n\n    v9fs_string_free(&fullname);\n\n    return err;\n\n}\n", "idx": 16204, "substitutes": {"fs_ctx": ["fs___kw", "fs___ctx", "fs_addr", "fw___check", "sys_cp", "fw___ctx", "fts_addr", "cs_ctx", "fs__obj", "fspyca", "fsdbaddr", "fts_ctx", "cs_obj", "cs_ct", "fs_jp", "fspycontext", "fs__tx", "fs2ctl", "fsdtx", "uds_jp", "sys2cp", "fw___kw", "cs_ann", "fs8cp", "fspyctx", "fts_grad", "sys2ctx", "fw_kw", "fs2cp", "fsdbctx", "fs_resp", "cs_tx", "fs_cp", "fsdresp", "fs___check", "fs_ctl", "fw_ctx", "sys_obj", "obs_ctx", "fs2obj", "cs_ctl", "fs___cp", "fs_obj", "fs2ctx", "fs_kw", "fs8ctx", "fs8kw", "fsdctl", "fs_context", "fw_cp", "fs_pkg", "fs_tx", "obs_ctl", "fs8check", "fsdbkw", "sys2tx", "fs__ctx", "uds_context", "cs_pkg", "cs_context", "ftsdbaddr", "fs_grad", "fsdctx", "fs_ct", "fs_check", "fw_check", "uds_gc", "sys_ctx", "cs_resp", "sys_tx", "fs_gc", "obs_prefix", "fw___cp", "ftsdbgrad", "fs_prefix", "ftsdbctx", "obs_tx", "sys_context", "fspycp", "fts_kw", "sys2obj", "ftsdbkw", "fs__pkg", "fsdbgrad", "fs_ca", "sys_ca", "fs2tx", "fs_ann", "fs2prefix", "uds_ctx"], "dir_path": [" dir2path", " dir_Path", "dirxctx", "dir2path", " dir2Path", "dir___Path", " directory___Path", "dir2Path", " directory_path", "dir2context", " dir_context", "dir___case", " dir2ctx", " directory_Path", "dir_Path", "dir_case", "dir_ctx", "dirxpath", " dir2context", "dirxPath", "dirxcontext", "dir___path", "dir2ctx", " directory___ctx", " directory_ctx", " dir_ctx", " directory_case", " directory___case", "dir___ctx", " directory___path", "dir_context"], "name": ["info", "prefix", "type", "parent", "n", "package", "Name", "nam", "format", "local", "title", "NAME", "c", "alias", "root", "ext", "nm", "key", "mem", "names", "id", "dir", "size", "str", "cap", "data", "normal", "comment", "filename", "file", "part", "ame", "base", "mask", "label"], "flags": ["fps", "details", "limits", "ants", "settings", "status", "ops", "amps", "styles", "FLAG", "fields", "weights", "atts", "args", "posts", "options", "mates", "flag", "features", "faces", "Flags", "ats", "ports", "locks", "ags", "tags", "fd", "friendly", "vals", "tails", "pins", "finals", "frames", "ints", "utils", "properties", "actions", "times", "states", "cs", "ts", "comments", "includes", "cond", "bits", "types", "errors", "stats", "grades", "lag", "products", "parts", "mask", "headers", "lines", "params"], "credp": ["creddphp", "cedvp", "creedp", "accredp", "cedP", "chedvp", "credpad", "callredpc", " cedtp", "cribpad", "callredpa", "credcp", "cpredP", "creedpa", " credf", "kredcp", "cedp", "credf", "cdefpc", "callreedpa", "credn", "credvp", "kcedpre", "cledp", "icredps", "cpredf", "kredp", "cpredp", "ciedjp", " credpre", "cashedup", " chedp", "cdefp", "icredphp", "cdbpc", "convredjp", "cribpc", "ancdefcp", "cppedcp", "accredpc", "cdefpad", "accppedp", "accredcp", "convashedjp", "ccedn", "creedpb", "ancredp", "credP", "cdbpa", "credps", "cnedcp", " cedp", "credpre", "cdbp", "accredphp", "icredpt", "cdefcp", "cribp", " credvp", "accppedpc", "cledpre", "ancdefp", "kcedn", "credphp", "cpredcp", "convredpad", "ciedp", "cppedpad", "kcedp", "ciedpad", "cursedpt", "cribcp", "chedp", "kredpre", "ccedp", "cnedphp", "cppedpc", "credpc", "creddp", "ciedup", "convredp", " chedP", "convashedup", "credpt", "cppedp", "crcp", "icreddp", "cpredtp", "icreddps", "crodpre", "cledtp", "creedpc", " cedpre", "credup", "ancredpad", "cgedcp", "creddpt", "callredp", "cppedphp", "creddps", "convashedpad", "crodn", "ccedcp", "cashedpad", "ccedpre", "cursedps", " chedf", "ancdefpad", "crcpb", "callredpb", " chedvp", "accppedphp", "cpredn", "ancredcp", "cgedphp", "cgedp", "crodcp", "cpredpre", "convredup", "ancdefpc", "ancredpc", "ciedpt", "icredp", "cursedp", "ciedps", "crcpa", "callreedp", "credtp", "crcpc", "ciedphp", "cpredvp", "cursedphp", "credpb", "credjp", "kredn", "chedP", "convashedp", "ccedup", "kcedcp", "cashedp", "cedtp", "cdbpb", " credtp", "cnedp", " credP", "cedf", "crodp", "icreddphp", "credpa", "callreedpc", "cgedpc", "ccedpad", "chedf", "cnedpc", " cedP", "cledP", "cedpre", "cashedjp", "icreddpt", "ccedjp", "accppedcp", "callreedpb"], "fs": ["bs", "fps", "rs", "aos", "bf", "os", "ips", "ps", "sys", "ess", "irs", "ls", "ms", "gs", "ims", "cf", "ds", "fw", "Fs", "cs", "fc", "ts", "FS", "f", "ns", "ss"], "path": ["pkg", "context", "device", "ref", "prefix", "prop", "address", "parent", "PATH", "package", "th", "route", "padding", "history", "x", "temp", "node", "out", "full", "format", "c", "ata", "patch", "root", "alias", "p", "host", "empty", "key", "binding", "handle", "port", "target", "entry", "trace", "seek", "chain", "method", "pattern", "ctx", "pointer", "Path", "index", "id", "dir", "url", "str", "transform", "data", "filename", "t", "template", "test", "file", "pt", "mount", "link", "cmd", "text", "policy", "ath", "length", "w", "location", "stream"], "fullname": ["shortame", " fullame", " fullresource", "relName", "shortpath", "fullame", "longstring", " fullName", " fullpath", "shortname", "fullstring", "shortstring", " fullstring", "hostame", "hostName", "fulstring", "fullpath", "longnam", " fullnam", "relname", "shortName", "fulname", "longpath", "longresource", "longname", "fullnam", "hostnam", "relstring", "fulresource", "fulpath", "fullName", "hostname", "relame", "fullresource", "longName", "longame"], "buffer": ["device", "send", "memory", "header", "error", "sequence", "password", "message", "ptr", "tty", "read", "mem", "writer", "Buffer", "engine", "scroll", "filename", "function", "base", "text", "stream", "profile", "button", "uf", "context", "cache", "package", "directory", "txt", "temp", "draw", "gl", "uffer", "filter", "append", "store", "tr", "timeout", "code", "size", "comment", "template", "source", "f", "command", "length", "bytes", "page", "format", "buf", "blank", "batch", "empty", "database", "console", "response", "reference", "block", "fd", "data", "binary", "program", "queue", "phrase", "flash", "address", "null", "out", "result", "background", "document", "available", "handle", "raw", "callback", "buff", "port", "b", "window", "match", "iter", "pointer", "bin", "attr", "table"]}}
{"project": "FFmpeg", "commit_id": "63d6a6b91e4997737905bbd2cf5970ad90a31869", "target": 1, "func": "static void fix_coding_method_array (int sb, int channels, sb_int8_array coding_method)\n\n{\n\n    int j,k;\n\n    int ch;\n\n    int run, case_val;\n\n    int switchtable[23] = {0,5,1,5,5,5,5,5,2,5,5,5,5,5,5,5,3,5,5,5,5,5,4};\n\n\n\n    for (ch = 0; ch < channels; ch++) {\n\n        for (j = 0; j < 64; ) {\n\n            if((coding_method[ch][sb][j] - 8) > 22) {\n\n                run = 1;\n\n                case_val = 8;\n\n            } else {\n\n                switch (switchtable[coding_method[ch][sb][j]]) {\n\n                    case 0: run = 10; case_val = 10; break;\n\n                    case 1: run = 1; case_val = 16; break;\n\n                    case 2: run = 5; case_val = 24; break;\n\n                    case 3: run = 3; case_val = 30; break;\n\n                    case 4: run = 1; case_val = 30; break;\n\n                    case 5: run = 1; case_val = 8; break;\n\n                    default: run = 1; case_val = 8; break;\n\n                }\n\n            }\n\n            for (k = 0; k < run; k++)\n\n                if (j + k < 128)\n\n                    if (coding_method[ch][sb + (j + k) / 64][(j + k) % 64] > coding_method[ch][sb][j])\n\n                        if (k > 0) {\n\n                           SAMPLES_NEEDED\n\n                            //not debugged, almost never used\n\n                            memset(&coding_method[ch][sb][j + k], case_val, k * sizeof(int8_t));\n\n                            memset(&coding_method[ch][sb][j + k], case_val, 3 * sizeof(int8_t));\n\n                        }\n\n            j += run;\n\n        }\n\n    }\n\n}\n", "idx": 16205, "substitutes": {"sb": ["bs", "stab", "jp", "sn", "sg", "ji", "bt", "bc", "hap", "sch", "bf", "bj", "rb", "ij", "usb", "cb", "bn", "bh", "dh", "hw", "sys", "jj", "sy", "ib", "shop", "ach", "sit", "pb", "ssl", "ht", "arb", "kh", "b", "chron", "ja", "db", "eb", "shell", "sa", "ih", "sp", "bb", "zb", "sbm", "gc", "bis", "erb", "uj", "sf", "ebin", "nb", "bps", "sth", "ssh", "sc", "sm", "ob", "bi", "bg", "hh", "bm", "gb", "SB"], "channels": ["chunks", "chars", "chesunks", "chanunks", "chesasks", " chans", "achopes", "achasks", "chanopes", "chands", "cannels", "cans", "cars", " chars", "cands", " chands", "achunks", "chesopes", "chesannels", "Chars", "Channels", "chans", "chanasks", "achannels", "chasks", "chopes", "chanannels", "Chans", "Chands"], "coding_method": ["code_Method", "codingJMETHOD", "cording___handler", "coder_method", "coding08handler", "coder_process", "cording___method", "cording_handler", "cording___Method", "coding_hod", "coding_METHOD", "coding___method", "cording___function", "coding_handler", "code_nom", "coder_METHOD", "coder_temp", "coder_nom", "codingJtemp", "cording_method", "coding08function", "coding___function", "coding_process", "codingphpMETHOD", "coder_mem", "coding_function", "coding___Method", "coding_path", "coder_path", "codingphpprocess", "codingJmethod", "coding08method", "coding_code", "coder_Method", "cording_function", "coding_type", "coding_mem", "coder_code", "code_method", "coder_type", "codingJprocess", "coding_Method", "coding08Method", "coding_nom", "coder_hod", "coding___handler", "coding_temp", "cording_Method", "codingphpmethod", "codingphptemp", "code_METHOD"], "j": ["bs", "i", "ind", "jp", "l", "d", "ji", "n", "aj", "z", "json", "server", "br", "x", "bj", "off", "ij", "ion", "sim", "jo", "q", "li", "er", "p", "jj", "r", "jump", "err", "bo", "pos", "b", "im", "ja", "js", "ot", "db", "eg", "job", "it", "at", "g", "uj", "fr", "dj", "kj", "el", "J", "ek", "t", "ik", "jc", "ix", "pt", "pr", "v", "y", "bi", "be", "obj", "jl", "jit"], "k": ["i", "kind", "ark", "l", "kw", "n", "kn", "ku", "ko", "ks", "z", "ck", "isk", "tk", "kin", "x", "wk", "ikk", "cm", "c", "q", "ask", "p", "kl", "mc", "r", "dk", "an", "m", "ger", "key", "kk", "mk", "kh", "kick", "sk", "ack", "ijk", "ok", "uk", "it", "kt", "ka", "kj", "ke", "km", "ki", "ak", "ek", "ik", "work", "kid", "K", "kr", "v", "unk"], "ch": ["cor", "bc", "atch", "sch", "cp", "bh", "cb", "r", "ach", "Ch", "att", "her", "he", "hl", "ann", "sh", "mot", "cha", "sc", "y", "chrom", "ht", "gb", "h", "br", "zh", "kh", "ah", "chron", "ot", "ih", "sk", "fr", "conn", "CH", "cmd", "chan", "channel", "ble", "bt", "ur", "che", "c", "anch", "q", "batch", "count", "com", "chy", "arch", "chn", "tch", "cht", "work", "be", "ph", "chip", "co", "i", "reach", "th", "z", "ich", "col", "hw", "p", "chain", "cho", "ech", "chart", "we", "och", "cs", "gr", "ac", "v", "wh", "cd", "cycle"], "run": ["rank", "runs", "check", "r", "pass", "scan", "ach", "rule", "dir", "g", "record", "use", "UN", "sw", "running", "cr", "pair", "con", "render", "end", "ck", "group", "boot", "rain", "set", "m", "Run", "une", "rc", "loop", "ro", "line", "num", "play", "model", "try", "roll", "order", "length", "form", "su", "role", "channel", "version", "l", "ur", "win", "thread", "only", "c", "q", "batch", "ran", "round", "block", "index", "job", "bit", "range", "rm", "seq", "step", "work", "head", "val", "a", "process", "call", "un", "i", "runner", "n", "z", "task", "go", "reg", "ru", "chain", "db", "len", "load", "back", "row", "bin", "cycle"], "case_val": ["force_Val", "case_str", "case_Val", "cache_vol", "case2val", "Case_state", "caseetyv", "case_VAL", "case2value", "caselyval", "ase_val", "caseetyval", "ice_res", "case_value", "ase_dev", " case_eval", "case_item", "ice_val", "caseetyvol", "force_val", "case_bal", "cache_str", "case2vals", "case_res", "Case_value", "case_var", "case___val", "case_eval", "Case_VAL", "force_VAL", "Case_vals", "case_vol", " case_vals", "caselyvals", "force_vals", "Case_val", " case_value", "case_v", "ase_eval", "ase_vals", "cache_val", "ice_vol", "case___bal", "cache_v", "Case_eval", "caselystate", "case___vol", "case_vals", "ice_bal", "Case_Val", "case_state", "case___res", "caseetystr", "ase_vol", "Case_item", " case_var", "case_dev"], "switchtable": ["witchtable", "switchTABLE", "switchable", "changeTABLE", " switchable", "jumpTABLE", "switchtab", "witchable", "changetable", "Switchtable", "changeTable", "SwitchTable", "jumptable", "switchTable", " switchtab", "changetab", "changeable", "jumpTable", "SwitchTABLE", "witchtab", "witchTable", "Switchtab", "jumptab", " switchTable"]}}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtdcrx(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],\n\n                         cpu_gpr[rS(ctx->opcode)]);\n\n    /* Note: Rc update flag set leads to undefined state of Rc0 */\n\n#endif\n\n}\n", "idx": 16207, "substitutes": {"ctx": ["pkg", "voc", "bc", "history", "cmp", "cm", "np", "cp", "cb", "bh", "kl", "urg", "ork", "ca", "sc", "context", "kw", "std", "tmp", "ck", "txt", "ctrl", "cpu", "cu", "jac", "cfg", "mk", "tc", "gc", "kt", "cf", "conn", "anc", "tm", "bp", "resp", "cmd", "kb", "abc", "dl", "ind", "jp", "req", "prefix", "nw", "unc", "x", "etc", "loc", "batch", "nt", "cc", "today", "ct", "gt", "work", "wcs", "aux", "xp", "tx", "ctl", "cur", "setup", "xc", "hw", "xs", "desc", "act", "mom", "cl", "inst", "self", "nc", "crit", "wx", "obj", "qt", "iat"]}}
{"project": "qemu", "commit_id": "e2f89926f19d2940eda070542501f39f51a8c81f", "target": 1, "func": "int usb_packet_map(USBPacket *p, QEMUSGList *sgl)\n\n{\n\n    int is_write = (p->pid == USB_TOKEN_IN);\n\n    target_phys_addr_t len;\n\n    void *mem;\n\n    int i;\n\n\n\n    for (i = 0; i < sgl->nsg; i++) {\n\n        len = sgl->sg[i].len;\n\n        mem = cpu_physical_memory_map(sgl->sg[i].base, &len,\n\n                                      is_write);\n\n        if (!mem) {\n\n            goto err;\n\n        }\n\n        qemu_iovec_add(&p->iov, mem, len);\n\n        if (len != sgl->sg[i].len) {\n\n            goto err;\n\n        }\n\n    }\n\n    return 0;\n\n\n\nerr:\n\n    usb_packet_unmap(p);\n\n    return -1;\n\n}\n", "idx": 16211, "substitutes": {"p": ["pkg", "h", "d", "jp", "fp", "lp", "n", "pc", "pe", "k", "pa", "c", "q", "cp", "u", "ps", "ap", "wp", "s", "r", "m", "pb", "vp", "b", "e", "tp", "sp", "op", "P", "g", "j", "t", "bp", "pt", "o", "a", "pp", "pi", "v", "f", "ping", "post", "pm"], "sgl": ["nsGl", " sGL", "rsgn", " sbl", "rsly", "sbg", "sGL", " sGl", "sly", "esly", " sfl", "nsgl", "jsGl", "jsigl", "timesbg", "rsGL", " sbg", "sfl", "nsGL", "jsfl", "nsbg", "rsbl", "sigl", "rsgl", "rsGl", "sgn", "nsfl", "sGl", "timesgl", "timesfl", "rsigl", "esGL", "sbl", "esGl", "esgl", " sigl", "jsgn", "jsgl", "nsly", " sgn"], "len": ["bl", "gz", "cmp", "addr", "kl", "mn", " length", "pos", "js", "hl", " Len", "L", "den", "mi", "lang", "all", "base", "Len", "uf", "full", "gl", " tid", "del", "vec", " clen", "ln", "lon", "size", "limit", "lig", "num", "wid", "cap", "en", "nl", "lib", "ld", "length", "rel", "dl", "l", "bytes", "li", "pl", "loc", "err", "ls", "syn", "nt", "count", "gen", "lf", "coll", "data", "seq", "fl", "il", "val", "lan", "lis", "ref", "lp", "comp", "elt", "lt", "nz", " l", " bl", "rev", "lim", "bin", "el", "ll", "fin", "lit", "le"], "mem": ["ind", "iam", "ref", "map", "bytes", "met", "memory", "alloc", "med", "txt", "go", "byte", "buf", "reg", "addr", "cpu", "ram", "err", "Mem", "m", "nm", "ptr", "mb", "mn", "buff", "ms", "md", "mp", "buffer", "member", "ret", "imm", "me", "msg", "lim", "data", "rm", "mx", " Mem", "mt", "mm", "t", "em", "phys", "ll", "mi", "ame", "mat", "rem"], "i": ["qi", "ind", "info", "l", "ai", "ii", "ji", "n", "gi", "series", "di", "point", "x", "sim", "out", "ij", "ip", "init", "cli", "gu", "ti", "li", "hi", "\u0438", "I", " j", "ei", "this", "si", "ma", "m", "ri", "key", "oi", "asi", "im", "e", "multi", "chain", "in", "ims", "fi", "index", "iu", "id", " ii", "g", "it", "j", "at", "ci", "xi", "ex", "ic", "ki", "t", "phi", "zi", "span", "ix", "mi", "o", "is", "pi", "v", "y", "bi", "ini", "ui", "print", "f"]}}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "func": "static void get_sensor_evt_status(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(sens->reading);\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);\n\n}\n", "idx": 16216, "substitutes": {"ibs": [" ibfs", "zbs", "mbs", "mbts", "mbcs", "ebc", "ibcs", " ibts", "ijfs", "zbts", "IBc", "mbfs", "ijjs", "IBfs", "ijsol", "ebjs", "zbfs", "IBs", "IBsol", "ebs", " ibjs", "ibfs", "ibsol", "ibts", "ijs", "ibc", " ibsol", "iams", " ibcs", "ibjs", "iamc", "zbcs", "iamjs", "IBjs"], "cmd": ["pkg", "bind", "iq", "req", "prop", "send", "nd", "once", "cli", "ctrl", "ctl", "off", "cmp", "cp", "exec", "comm", "conf", "ext", "force", "forge", "check", "def", "patch", "cb", "batch", "args", "cfg", "desc", "raw", "pay", "good", "news", "md", "ctx", "op", "cont", "job", "rn", "act", "cod", "msg", "seq", "ct", "mt", "Cmd", "ctr", "control", "grad", "crit", "config", "command", "cd", "call"], "cmd_len": ["cmd_min", "Cmd_length", "cmdseqls", "Cmd_ls", "Cmd_len", "Cmd_min", "cmd_ls", "cmdseqlen", "cmdseqmin", "cmd_length", "cmdseqlength"], "rsp": ["rp", "rdsp", "rdpc", "rps", "rpc", "rcps", "Rps", "rcss", "Rresp", " rresp", "Rss", " rp", " rss", " rpc", "Rpc", "rss", " rSP", "rcsp", "rdresp", "Rsp", "rresp", "RSP", "rcp", "Rp", " rps", "rSP", "rdSP"], "rsp_len": ["rsp_gen", "rspPlimit", "rpt_len", "rsp_limit", "rpt_limit", "rspPlen", "rpt_gen", "rpt_ln", "rspPgen", "rsp_ln", "rspPln"], "max_rsp_len": ["max_rsp_gen", "max_rsp_length", "max_rsp_Len", "max_rsp2Len", "max_rresp_Len", "max_rsp2length", "max_rsp2gen", "max_rresp_length", "max_rresp_gen", "max_rsp2len", "max_rresp_len"], "sens": ["Sens", "sess", "pems", " sems", "cENS", "psens", "Sons", "vENS", "Sess", "Seng", "isens", "sons", "vent", "tents", "tENS", "Sents", "tens", "asans", "sems", "peng", "censor", "Sen", "pans", "pent", "psents", "pens", "SENS", "asens", "seng", "isensor", "sent", "isends", "sen", "pENS", " sess", "sents", "psensor", "sensor", "sans", "psess", " sans", "ten", "Sems", "tans", "cends", " sen", " sents", " sends", " sent", "tons", "isENS", "pents", " sensor", "Sensor", "sends", "sENS", " sENS", "asENS", "asons", "vens", " seng", "vans", "cens", "Sans", "tensor"]}}
{"project": "FFmpeg", "commit_id": "3e1507a9547ac09b6ff4372123cde09f19218f3d", "target": 0, "func": "void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[12][64])\n\n{\n\n    int i;\n\n    if (s->chroma_format == CHROMA_444) {\n\n        encode_block(s, block[0], 0);\n\n        encode_block(s, block[2], 2);\n\n        encode_block(s, block[4], 4);\n\n        encode_block(s, block[8], 8);\n\n        encode_block(s, block[5], 5);\n\n        encode_block(s, block[9], 9);\n\n\n\n        if (16*s->mb_x+8 < s->width) {\n\n            encode_block(s, block[1], 1);\n\n            encode_block(s, block[3], 3);\n\n            encode_block(s, block[6], 6);\n\n            encode_block(s, block[10], 10);\n\n            encode_block(s, block[7], 7);\n\n            encode_block(s, block[11], 11);\n\n        }\n\n    } else {\n\n        for(i=0;i<5;i++) {\n\n            encode_block(s, block[i], i);\n\n        }\n\n        if (s->chroma_format == CHROMA_420) {\n\n            encode_block(s, block[5], 5);\n\n        } else {\n\n            encode_block(s, block[6], 6);\n\n            encode_block(s, block[5], 5);\n\n            encode_block(s, block[7], 7);\n\n        }\n\n    }\n\n}\n", "idx": 16227, "substitutes": {"s": ["bs", "details", "h", "fs", "l", "rs", "n", "sb", "ties", "ses", "ies", "sql", "S", "als", "os", "ips", "c", "sv", "ps", "ss", "comm", "p", "sys", "r", "ches", "es", "m", "ls", "sports", "vs", "us", "erences", "hs", "ms", "aws", "gs", "b", "e", "its", "js", "ats", "ers", "as", "ims", "w", "spec", "bis", "g", "j", "sq", "sw", "less", "ex", "t", "ds", "se", "cs", "ts", "is", "a", "stats", "ins", "qs", "f", "ns", "tes", "sts"], "block": ["event", "view", "type", "dict", "condition", "image", "join", "map", "bl", "side", "panel", "pop", "point", "header", "word", "node", "group", "error", "byte", "ip", "hash", "frame", "clip", "number", "new", "def", "filter", "check", "list", "zero", "batch", "set", "tag", "name", "blocks", "chain", "window", "box", "buffer", "commit", "loop", "no", "object", "size", "record", "line", "load", "use", "bit", "back", "lock", "data", "bin", "model", "cl", "just", "step", "row", "pack", "snap", "part", "link", "Block", "all", "base", "table", "user", "sync", "obj", "post", "label"], "i": ["k", "status", "cli", "oi", "asi", " m", " ii", "it", "ci", "ki", "zi", " mi", " iter", "mi", " k", "y", " init", " multi", " li", "ii", "ij", "init", "iy", "hi", " pi", "m", "ri", "multi", "ni", "j", "xi", "try", "ix", "is", "ui", "ini", "qi", "ind", "ai", "di", "x", " bi", "ti", "li", "\u0438", "I", "si", "batch", "in", " v", "ims", "index", "phi", "a", "pi", "bi", "io", "iq", "n", "gi", " ni", "sim", "ip", "ei", "p", " j", " I", "us", " key", "e", "iter", " index", "iu", "me", "ic", "v", " err", " ti"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,\n\n                     int ret, int rw)\n\n{\n\n    int store = 0;\n\n\n\n    /* Update page flags */\n\n    if (!(*pte1p & 0x00000100)) {\n\n        /* Update accessed flag */\n\n        *pte1p |= 0x00000100;\n\n        store = 1;\n\n    }\n\n    if (!(*pte1p & 0x00000080)) {\n\n        if (rw == 1 && ret == 0) {\n\n            /* Update changed flag */\n\n            *pte1p |= 0x00000080;\n\n            store = 1;\n\n        } else {\n\n            /* Force page fault for first write access */\n\n            ctx->prot &= ~PAGE_WRITE;\n\n        }\n\n    }\n\n\n\n    return store;\n\n}\n", "idx": 16237, "substitutes": {"ctx": ["pkg", "context", "jp", "kw", "tmp", "bc", "ck", "tx", "tk", "cas", "ctrl", "setup", "cmp", "cm", "c", "cp", "xc", "Context", "hw", "loc", "p", "mc", "jac", "tc", "nt", "cc", "ack", "ok", "kt", "act", "cf", "ci", "conn", "ct", "anc", "ctr", " cx", "ca", "sc", "cmd", "obj", "iat"], "pte1p": ["pte101d", "ptee4r", "pte8P", "ptoe3b", "ptoe3p", "pte4sp", "pte101pc", "pte21jp", "pte1wp", "pte30cp", "pte60p", "pte60pr", "pte127pp", "pte101ap", "pte1jp", "pte1cp", "ptea1ap", "ptee4sp", "pte8w", "pte1pc", "ptea21jp", "ptec1w", "ptec01p", "ptoe1pc", "ptea21p", "pte30wp", "pte01c", "ptee1r", "pte0p", "pte3b", "ptea101p", "ptec01pc", "pte127ap", "pte4p", "pte8p", "pte01p", "pte0sp", "pte001wp", "pte3p", "ptec01c", "ptoe1p", "pte4P", "pte4r", "ptea21wp", "pte1pr", "pte0r", "ptoe1pr", "ptea1jp", "pte1sp", "ptec1p", "pte21cp", "pte101p", "ptea101pp", "pte21wp", "pte127d", "pte0P", "ptea1p", "ptee4p", "ptoe3pc", "pte101pr", "ptec01w", "pte4d", "pte01pc", "pte30p", "pte001cp", "ptec1pc", "pte1pp", "pte8pc", "pte01w", "pte30jp", "pte1P", "ptee1p", "pte001jp", "ptea21cp", "pte3w", "pte001p", "pte127p", "pte1d", "pte4ap", "ptea1d", "ptee4P", "pte101pp", "pte60pc", "pte4pp", "ptea101d", "pte8sp", "pte101b", "pte3pr", "pte1ap", "ptea1cp", "ptea1wp", "pte1c", "pte3pc", "pte60b", "pte21p", "ptea101ap", "ptee1P", "ptea1pp", "pte1r", "pte1b", "pte3c", "ptec1c", "pte1w", "ptoe1b", "ptee1sp", "pte8c", "pte8r", "ptoe3pr"], "ret": ["ft", "ref", "jp", "RET", "nz", "re", "reply", "etc", "reg", "Ret", "result", "rf", "cb", "def", "r", "ne", "read", "alt", "mem", "nt", "rev", "rc", "des", "vt", "lv", "res", "rm", "mt", "gt", "nl", "arg", "rets", "resp", "rt", "pert", "aux", "reset"], "rw": ["kw", "nz", "nw", "rb", "rf", "hw", "rew", "wp", "urg", "rx", "writ", "mb", "rd", "writer", "wr", "rr", "rh", "wa", "ro", "rn", "rl", "ew", "sw", "wn", "iw", "dq", "nb", "RW", "fw", "aw", "vr", "write", "rt", "wx", "wb", "wd", "w", "rob"]}}
{"project": "qemu", "commit_id": "5a2223ca26b1a34e131b5b9a63599d9426d2c25c", "target": 0, "func": "static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)\n\n{\n\n    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n}\n", "idx": 16246, "substitutes": {"s": ["h", "i", "fs", "rs", "sb", "n", "sl", "status", "ses", "S", "so", "sv", "c", "q", "ps", "ss", "p", "r", "m", "ls", "hs", "gs", "b", "sp", "g", "sh", "sq", "t", "ds", "ts", "is", "a", "o", "v", "ns", "sts"], "bsel": ["dsels", "pibl", "bpzh", "bsels", "bpsels", "bgsel", " bser", "bgzh", "bzh", " bibl", "dvey", "bser", "pser", "psel", " bsels", "bpser", "dzh", "bvey", "bpvey", "bpsel", "psels", "bibl", "dsel", "bpibl", "bgvey", "bgsels"], "slot": ["zo", "pot", "sl", "serial", "sid", "tab", "ots", "usage", "hold", "hot", "set", "kl", "binding", "timeout", "kh", "window", "sec", "slice", "locked", "sp", "loop", "unit", "pointer", "seed", "shot", "module", "hole", "bit", "spot", " Slot", "offset", "lock", "seq", "zone", "Slot", "lot", "snap", "kid", "pad", "label", "sector"]}}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,\n\n                                           stride, dst, stride, 16, 0);\n\n}\n", "idx": 16255, "substitutes": {"dst": ["pst", " dnd", "pest", "sdest", "ednd", "dput", "Dest", " dsrc", "dest", "pput", " dest", "edst", "sst", " dput", "edput", "Dst", " ddest", "sest", "ddest", "Ddest", "Dsrc", "dsrc", "pnd", "edest", "dnd", "ssrc"], "src": ["rs", "sn", "sb", "sl", "trans", "ur", "txt", "cur", "input", "np", "dest", "st", "loc", "s", "sys", "r", "img", "in", "b", "sur", "rc", "ipp", "sec", "hl", "gin", "inner", "str", "rl", "iv", "sr", "dq", "ctr", "sc", "source", "rt", "ins", "bg", "RC", "ipl"], "stride": ["specime", " strid", " strride", "strade", "stide", "Strime", " strrid", "strride", "divid", "shrice", "strime", "specides", " strime", "slride", " strack", "divend", "slade", "strack", "divue", "slend", "slice", "strrid", " strue", "specide", " strice", "shride", "slid", "shrade", "divide", "strice", "divride", "Stride", "Strides", "strides", " strides", " strend", "strend", "strid", "Strack", "specack", " strade", "slide", "strue", "stue", "divrid"]}}
{"project": "FFmpeg", "commit_id": "6221e2478c593a0ce1183eed929cb2101dbf5265", "target": 0, "func": "int av_parse_color(uint8_t *rgba_color, const char *color_string, int slen,\n\n                   void *log_ctx)\n\n{\n\n    char *tail, color_string2[128];\n\n    const ColorEntry *entry;\n\n    int len, hex_offset = 0;\n\n\n\n    if (color_string[0] == '#') {\n\n        hex_offset = 1;\n\n    } else if (!strncmp(color_string, \"0x\", 2))\n\n        hex_offset = 2;\n\n\n\n    if (slen < 0)\n\n        slen = strlen(color_string);\n\n    av_strlcpy(color_string2, color_string + hex_offset,\n\n               FFMIN(slen-hex_offset+1, sizeof(color_string2)));\n\n    if ((tail = strchr(color_string2, ALPHA_SEP)))\n\n        *tail++ = 0;\n\n    len = strlen(color_string2);\n\n    rgba_color[3] = 255;\n\n\n\n    if (!av_strcasecmp(color_string2, \"random\") || !av_strcasecmp(color_string2, \"bikeshed\")) {\n\n        int rgba = av_get_random_seed();\n\n        rgba_color[0] = rgba >> 24;\n\n        rgba_color[1] = rgba >> 16;\n\n        rgba_color[2] = rgba >> 8;\n\n        rgba_color[3] = rgba;\n\n    } else if (hex_offset ||\n\n               strspn(color_string2, \"0123456789ABCDEFabcdef\") == len) {\n\n        char *tail;\n\n        unsigned int rgba = strtoul(color_string2, &tail, 16);\n\n\n\n        if (*tail || (len != 6 && len != 8)) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Invalid 0xRRGGBB[AA] color string: '%s'\\n\", color_string2);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        if (len == 8) {\n\n            rgba_color[3] = rgba;\n\n            rgba >>= 8;\n\n        }\n\n        rgba_color[0] = rgba >> 16;\n\n        rgba_color[1] = rgba >> 8;\n\n        rgba_color[2] = rgba;\n\n    } else {\n\n        entry = bsearch(color_string2,\n\n                        color_table,\n\n                        FF_ARRAY_ELEMS(color_table),\n\n                        sizeof(ColorEntry),\n\n                        color_table_compare);\n\n        if (!entry) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Cannot find color '%s'\\n\", color_string2);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        memcpy(rgba_color, entry->rgb_color, 3);\n\n    }\n\n\n\n    if (tail) {\n\n        unsigned long int alpha;\n\n        const char *alpha_string = tail;\n\n        if (!strncmp(alpha_string, \"0x\", 2)) {\n\n            alpha = strtoul(alpha_string, &tail, 16);\n\n        } else {\n\n            alpha = 255 * strtod(alpha_string, &tail);\n\n        }\n\n\n\n        if (tail == alpha_string || *tail || alpha > 255) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Invalid alpha value specifier '%s' in '%s'\\n\",\n\n                   alpha_string, color_string);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        rgba_color[3] = alpha;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16256, "substitutes": {"rgba_color": ["rgba5type", "rgpha_value", "rgba2user", "rgba2type", "rgba00default", "rgbon_light", "rgba_channel", "rgba1color", "rgbon_type", "rgpi_field", "rgroma32private", "rgba______color", "rgba_col", "rggb_color", "rgba00color", "rgba_initial", "rgba00col", "rgpo_pixel", "rgba2actor", "rgroma_private", "rgaa00col", "rgba_actor", "rgba_type", "rgba_class", "rgaa_private", "rgba______theme", "rgbaJstyle", "rgba___cache", "rgba2value", "rgba32display", "rgba_image", "rgba_user", "rgelta_factor", "rgroma_color", "rgbaJvalue", "rgba1image", "rgbon5match", "rgba_theme", "rgbon_actor", "rggb2color", "rgelta_color", "rgbon5color", "rgba_light", "rggb2value", "rgba2color", "rgba_colour", "rgroma32display", "rgba_value", "rgaa_col", "rgbon_or", "rgpi_color", "rgba32rect", "rgroma_rect", "rgba_display", "rgba_factor", "rgba_rect", "rggb2col", "rgelta_type", "rgbon5col", "rggb_value", "rgba_field", "rgba2channel", "rgroma_display", "rgba___type", "rgbaJcolor", "rgba_match", "rgbon_match", "rgpha_style", "rgba1field", "rgba5match", "rgbaJinitial", "rgbon_color", "rgba_default", "rgba_private", "rgbaJpixel", "rgba___color", "rgba_cache", "rgaa00color", "rgba_pixel", "rgpi_image", "rgpi_class", "rgba1class", "rggb_col", "rgbaJcache", "rgba___pixel", "rgba______light", "rgba2col", "rgba5color", "rgba5col", "rgroma32color", "rgba2match", "rgpo_initial", "rgpo_color", "rgaa_color", "rgpha_total", "rgbaJtotal", "rgbon_col", "rgba___factor", "rgba___colour", "rgba00private", "rgba___match", "rgbon_channel", "rgaa00private", "rgba___col", "rgbon_user", "rgba_or", "rgbon5type", "rgaa00default", "rgroma32rect", "rgpha_color", "rgba______or", "rgpo_cache", "rgbon_theme", "rgaa_default", "rgba_style", "rgba___initial", "rgba32color", "rgelta_colour", "rgba_total", "rgba32private"], "color_string": [" color_strings", "erroriststring", "coloritytable", "originalitytable", "coloritypair", "coloritybyte", "coloriptable", "color_instance", "coloripiterator", "originalitystring", "coloriststring", "original_table", "feature_table", "feature5String", "color_type", "error_string", "coloristpair", "color__list", "feature5string", "coloristtype", "feature_String", "feature_string", " color_array", "original_iterator", "color_array", "color5table", "original_string", "color5byte", "color_iterator", "feature_byte", "feature5table", "color__string", "erroristpair", "color_strings", "color_pair", "color5string", "color_byte", "originalityinstance", "originalityiterator", " color_table", "colorityinstance", "colorityiterator", "error_type", "color__strings", "original_instance", "erroristtype", "error_pair", "color5String", "coloritytype", "colorityString", "coloripinstance", "color_list", "feature5byte", "coloritystring", "color_String", "color__table", " color_list", "color_table", "coloripstring"], "slen": ["sloen", "SLens", "shen", "slens", "klatten", "sslade", "latten", "slan", "sllen", "slon", "slenge", "SLeng", "llen", "plen", "SLen", "islatten", "elen", "ssleng", "selade", "sslan", "ploen", "sellen", "SLenge", "slade", "shon", "plon", "elan", "islenge", "SLan", "sslen", "sslon", "ssloen", "islens", "plens", "klens", "islen", "lade", "slatten", "shoen", "sleng", "elatten", "eleng", "sslens", "klenge", "shens", "selatten", "klen", "SLatten", "selen", "ssllen", "sslatten"], "log_ctx": ["log_obj", "logptctx", "logptcontext", "log_context", "og_context", "log_req", "Log_tx", "Log_context", "logpttx", "log2tx", "log2obj", "log2context", "og_obj", "log_tx", "logptreq", "log2ctx", "Log_req", "og_ctx", "og_tx", "Log_ctx"], "tail": ["foot", "wind", "detail", "sum", "neck", "prefix", "end", "term", "condition", "lt", "last", "style", "ail", "lead", "temp", "pillar", "tle", "depth", "wit", "ul", "tag", "zero", "ptr", "origin", "timeout", "tip", "lo", "alt", "chain", "slice", "iter", "shell", "loop", "index", "buffer", "seed", "size", "limit", "tails", "lig", "offset", "latest", "lock", "ignore", "gate", "scroll", "lift", "gt", "pipe", "pull", "il", "leaf", "tt", "ll", "align", "get", "body", "link", "head", "base", "table", "fat", "length", "tailed"], "color_string2": ["color_text12", "color_format2", "color_dataed", "color_request\t", "color_string1", "color___pair2", "color_file2", "color_table1", "coloritystring0", "colorationstring1", "colorationtable1", "color_String1", "color_sequence2", "color___pair02", "color___string2", "color_number2", "colorationstring2", "color_number32", "coloritysequence2", "color_name3", "color_buffer3", "color_format3", "coloritynumber0", "color_array32", "colorationstringed", "coloritysequence1", "color_ring2", "colorationtableed", "color_comment2", "color_word22", "color_pair\t", "color_number0", "color_list0", "color_array1", "color_request2", "color___string02", "color_data2", "color_component0", "color_String0", "color_string32", "color___string\t", "color_string0", "color_text1", "color_text2", "color_sequence0", "color_name0", "color_component32", "coloritynumber32", "color_comment02", "color_string02", "color_name22", "color_file12", "coloritystring2", "color___pair\t", "color_tableed", "color_string12", "color_file1", "color_list1", "coloritystring32", "color_strings2", "color_String3", "color_table2", "color_string22", "color_array3", "color_strings1", "color_word2", "color_sequence3", "color_String2", "color_comment\t", "coloritynumber2", "color_string3", "colorationtable2", "color_buffer2", "color_ring1", "color_data1", "color_sequence1", "color_stringed", "color_name2", "color_ring3", "color_word3", "color_word0", "color_pair02", "coloritystring1", "color_array2", "coloritystring3", "coloritysequence3", "color_component2", "color_list2", "color_pair2", "color_array0", "color_strings3", "color_Stringed", "color_request02"], "entry": ["cue", "search", "info", "tmp", "insert", "error", "result", "enter", "list", "ries", "r", "key", "cell", "ent", "ry", "match", "member", "instance", "index", "import", "Entry", "record", "see", "line", "RY", "row", "data", "ie", "ient", "inter", "comment", "ary", "rance", "link", "ace", "table", "obj", "or", "look"], "len": ["h", "l", "ell", "end", "lp", "n", "elt", "lt", "sl", "mil", "z", "ail", "full", "compl", "cmp", "li", "pl", "loc", "vec", "ls", "pos", "ln", "mem", "alt", "e", "count", "iter", "lon", "fn", "sp", "nt", "fun", "size", "str", "lf", "limit", "L", "lim", "en", "seq", "el", "fl", "nl", "t", "ll", "il", "fin", "lib", "val", "all", "lit", "Len", "length", "lan"]}}
{"project": "qemu", "commit_id": "22d5cd82e98b61b1dbd791fab9f4ae0f77c0ed14", "target": 0, "func": "static int raw_inactivate(BlockDriverState *bs)\n\n{\n\n    int ret;\n\n    uint64_t perm = 0;\n\n    uint64_t shared = BLK_PERM_ALL;\n\n\n\n    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);\n\n    return 0;\n\n}\n", "idx": 16274, "substitutes": {"bs": ["bos", "fs", "rs", "sb", "aos", "ks", "bc", "blog", "bes", "aus", "hz", "bh", "vs", "ls", "irms", "ms", "b", "its", "js", "iss", "lbs", "bles", "asis", "bb", "bis", "bas", "cks", "acs", "bps", "BS", "ds", "ubs", "bp", "bsp", "cs", "ts", "bits", "bm", "obs", "bing", "ns", "ss"], "ret": ["ft", "ref", " alt", "end", "RET", "elt", "nz", "pret", "status", "txt", "out", "re", "reg", "state", "Ret", "result", "def", "r", "tr", "leg", "ry", "alt", "code", "nt", "rev", "len", "cont", "it", "res", "j", "back", "rm", "bool", "mt", "try", "gt", "det", "t", "ll", "ter", " fut", "rets", " Ret", "resp", "rt", "deg", "val", "print", "v", "lit", "reset", "rem"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,\n\n                                Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qobject_incref(*obj);\n\n    qmp_output_add_obj(qov, name, *obj);\n\n}\n", "idx": 16276, "substitutes": {"v": ["h", "i", "vc", "d", "l", "tv", "av", "n", "V", "k", "conv", "nv", "c", "q", "u", "sv", "ver", "p", "vim", "r", "uv", "m", "vp", "b", "verb", "vt", "vi", "cv", "g", "ev", "j", "vis", "qv", "ov", "vr", "o", "inv", "y", "f", "or", "w", "vm"], "name": ["info", "type", "prefix", "n", "Name", "nam", "word", "local", "init", "NAME", "c", "new", "named", "p", "def", "ma", "nm", "m", "key", "code", "names", "no", "path", "id", "str", "j", " Name", "cap", "data", "t", "attr", "order", "ame", "val", "f", "var", "par", "w", "ns", "label"], "obj": ["ref", "adj", "elt", "utt", "tmp", "opt", "txt", "node", "out", "off", "buf", "cmp", "addr", "src", "hw", "sys", "arr", "err", "oj", "pos", "alt", "nt", "js", "ctx", "object", "str", "j", "act", "data", "conn", "seq", "proc", "inst", "func", "attr", "po", "expr", "resp", "o", "cmd", "ob", "obs", "ns", "Obj"], "errp": ["erp", "rp", "errpp", "rr", "errr", "lrp", "lrP", "erpp", "rpp", "err", "lrr", "lrpp", "rP", "errP", "erP"], "qov": ["mov", "qnov", "mnov", "qOV", " qovi", "dqov", "qova", "dqOV", "dqrov", "mova", "sqov", " qnov", " sqrov", " qova", "sqnov", "sqovi", " qrov", "qrov", "qog", " sqOV", " sqog", "qovi", "movi", " qOV", " qog", "sqova", "dqog", " sqov"]}}
{"project": "qemu", "commit_id": "41ecc72ba5932381208e151bf2d2149a0342beff", "target": 0, "func": "static int setup_sigcontext(struct target_sigcontext *sc,\n\n                            CPUSH4State *regs, unsigned long mask)\n\n{\n\n    int err = 0;\n\n    int i;\n\n\n\n#define COPY(x)         __put_user(regs->x, &sc->sc_##x)\n\n    COPY(gregs[0]); COPY(gregs[1]);\n\n    COPY(gregs[2]); COPY(gregs[3]);\n\n    COPY(gregs[4]); COPY(gregs[5]);\n\n    COPY(gregs[6]); COPY(gregs[7]);\n\n    COPY(gregs[8]); COPY(gregs[9]);\n\n    COPY(gregs[10]); COPY(gregs[11]);\n\n    COPY(gregs[12]); COPY(gregs[13]);\n\n    COPY(gregs[14]); COPY(gregs[15]);\n\n    COPY(gbr); COPY(mach);\n\n    COPY(macl); COPY(pr);\n\n    COPY(sr); COPY(pc);\n\n#undef COPY\n\n\n\n    for (i=0; i<16; i++) {\n\n        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);\n\n    }\n\n    __put_user(regs->fpscr, &sc->sc_fpscr);\n\n    __put_user(regs->fpul, &sc->sc_fpul);\n\n\n\n    /* non-iBCS2 extensions.. */\n\n    __put_user(mask, &sc->oldmask);\n\n\n\n    return err;\n\n}\n", "idx": 16281, "substitutes": {"sc": ["psc", "ch", "pc", "asc", "bc", "sch", "lc", "ctl", "dc", "c", "sche", "exec", "comm", "mc", "set", "scan", "cam", "disc", "pb", "desc", "sci", "sic", "irc", "usc", "tc", "isc", "cc", "rc", "sec", "ctx", "gc", "cv", "sh", "sq", "arc", "cl", "Sc", "craft", "ec", "capt", "esc", "osc", "cs", "cr", "scope", "sync", "scl", "SC", "ss"], "regs": ["reggs", "Reggs", "rogions", "regains", "gregs", "rogs", "reges", "roggs", "Regts", "registerS", "gregions", "ggs", "rogords", "registers", "gregS", "registerls", "rogts", "regS", "greges", "gregls", "Reges", "regions", "ggains", "gregts", "regts", "registerts", "regls", "privions", "privords", "Regs", "privgs", "roges", "gregains", "rogains", "gregords", "rogS", "rogls", "greggs", "regords", "privs", "gggs"], "mask": ["sum", "sign", "ch", "cache", "map", "ck", "z", " Mask", "flags", "clear", "cmp", "ask", "scale", "check", "mc", "tag", "zero", "scan", "ma", "m", "batch", "key", "tr", "hide", "mb", "ms", "flag", "code", "match", "Mask", "sk", "gc", "gray", "bit", "black", "lock", "gate", "mt", "mod", "pack", "mark", " masked", "label"], "i": ["qi", "ind", "ai", "ii", "ji", "n", "gi", "status", "z", "di", "x", "sim", "out", "go", "cli", "ij", "ip", "gu", "c", "u", "ti", " bi", "li", "hi", "\u0438", "I", "p", " j", "ei", "r", "si", "batch", "m", "oi", "ri", "dr", "b", "multi", "in", "e", "ami", " v", "index", "iu", "id", " ii", "g", "it", "j", "me", "ci", "xi", "ex", "ki", "t", " x", "phi", "zi", "ix", "mi", "is", "o", "pi", "v", "y", "bi", " err", "ini", "ui", "f"]}}
{"project": "qemu", "commit_id": "7c4228b4771acddcb8815079bc116007cec8a1ff", "target": 1, "func": "static void vfio_unmap_bar(VFIODevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    if (!bar->size) {\n\n        return;\n\n    }\n\n\n\n    vfio_bar_quirk_teardown(vdev, nr);\n\n\n\n    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);\n\n    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));\n\n\n\n\n    if (vdev->msix && vdev->msix->table_bar == nr) {\n\n        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);\n\n        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));\n\n\n    }\n\n\n\n    memory_region_destroy(&bar->mem);\n\n}", "idx": 16293, "substitutes": {"vdev": ["vgo", "vpay", " vdevice", "vgen", " vstream", " vaddr", "svdev", "svDEV", "vcpay", " vpay", "avdev", " vDEV", "evbuf", "avpay", "vaddr", "svaddr", " vbuf", "vdes", " vserver", "vDEV", "avdes", "uvdev", "vswitch", "svev", "svstream", "mdev", "svdevice", "vcdef", "vsys", "uvsys", "svenv", "evdev", "uvstream", "vstream", "vserial", "uvaddr", "avsys", "hdev", "avinfo", "uvgen", "mdevice", "uvver", "svserver", "vev", "svgo", "svpad", "Vver", "Vsys", " venv", "vcswitch", "vcdev", "vcbuf", "evswitch", "vserver", "hDEV", " vinfo", "vcinfo", "svserial", "avpad", "avserial", "avgen", "vdevice", "venv", " vpad", " vdef", " vdes", "Vdev", "henv", "vinfo", "mserver", "evdef", "uvDEV", "vcdes", "vbuf", "vctx", "hctx", "hev", "vpad", "mserial", "svctx", "avgo", "Vgen", " vserial", " vswitch", " vev", "vdef", "avver", " vctx", "hdevice", " vgo", "vver"], "nr": ["nick", "usr", "cor", "sn", "NR", "n", "tn", "nz", " nib", " ni", "nw", "radius", "br", "next", "ij", "our", "number", "nv", "np", "addr", "ti", "cb", " NR", "adr", "square", "r", "nm", "NH", " neighbor", "Ni", "rr", "no", "ng", "nom", " number", "eno", " nm", " sidx", "nn", "uj", "num", "nor", " numb", "inter", "mr", "arity", "coord", "ctr", "nb", "attr", "ter", "byter", "nc", "gr", "kr", "NPR", "gov"], "bar": [" bars", "cor", "hat", "cb", "ram", "pb", "track", "bench", "star", "mem", "camp", " ab", "report", "gob", "ca", "bor", "gb", "pair", "bury", "worker", "usr", "prop", "ax", "hub", "hello", "br", "bridge", "pas", "mb", "good", "cart", "tick", "arge", "request", "aaa", "rage", "broad", "comb", "coord", "docker", "menu", "tab", "buf", "foo", "arr", "batch", "cam", "cast", "bag", "trace", "block", "car", "job", " buck", "item", "arg", "aw", "bot", "var", "area", "bars", "az", "percent", "Bar", "ar", "builder", " barg", "bill", "b", " foo", "row", "grab", "watch", "bart", "bug", "rest", "hist"]}}
{"project": "qemu", "commit_id": "babfa20ca4721e950d8096f32b1dc091763a8837", "target": 0, "func": "static bool ept_emulation_fault(uint64_t ept_qual)\n\n{\n\n    int read, write;\n\n\n\n    /* EPT fault on an instruction fetch doesn't make sense here */\n\n    if (ept_qual & EPT_VIOLATION_INST_FETCH) {\n\n        return false;\n\n    }\n\n\n\n    /* EPT fault must be a read fault or a write fault */\n\n    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;\n\n    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;\n\n    if ((read | write) == 0) {\n\n        return false;\n\n    }\n\n\n\n    /*\n\n     * The EPT violation must have been caused by accessing a\n\n     * guest-physical address that is a translation of a guest-linear\n\n     * address.\n\n     */\n\n    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||\n\n        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 16318, "substitutes": {"ept_qual": ["ept_specific", "ept_pol", "ept___har", "ept9quality", "ept9qual", "ept___qual", "techn9pac", "vant_specific", "ept5val", "ept_quality", "ept___requ", "ept_compl", "techn9quality", "techn_pac", "techn_quality", "ept_cmd", "pent_qual", "vant_quality", "vant_requ", "apt_qual", "vant_qual", "ept_val", "ept_requ", " et_compl", " et_quant", "ept5qual", "ept9val", "ept_quant", "techn9qual", "techn_val", " et_quality", " et_qual", "techn_qual", "ept_har", "ept___quant", "pent_quick", "techn9val", "vant_compl", "ept9pac", "ept_pac", "apt_har", "pent_compl", "ept5quality", "ept_quick", "apt_requ", "ept5pac", "apt_quant", "vant_cmd", "pent_pol"], "read": ["before", "i", "rate", "ind", "READ", "info", "end", "address", "reader", "select", "x", "reading", "only", "out", "ip", "error", "run", "input", "find", "check", "set", "r", "start", "from", "reads", "in", "count", "len", "index", "ok", "id", "ro", "size", "load", "show", "access", "data", "open", "Read", "roll", "readable", "get", "print", "length", "hold", " Read"], "write": ["Write", "end", "send", "wrote", "cut", "save", "out", "draw", "force", "create", "check", "change", "set", "store", "update", "writ", "handle", "flow", "port", "close", "writer", "wr", "rite", "seek", "mem", "index", "use", "see", "move", "data", "enable", "scroll", "leave", "written", "vert", "put", "w", "output", "edit", "wait"]}}
{"project": "FFmpeg", "commit_id": "7cf22c79706d23d40d16cee37eb32d5797adcc2c", "target": 0, "func": "yuv2rgba64_full_X_c_template(SwsContext *c, const int16_t *lumFilter,\n\n                       const int32_t **lumSrc, int lumFilterSize,\n\n                       const int16_t *chrFilter, const int32_t **chrUSrc,\n\n                       const int32_t **chrVSrc, int chrFilterSize,\n\n                       const int32_t **alpSrc, uint16_t *dest, int dstW,\n\n                       int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    int i;\n\n    int A = 0xffff<<14;\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int j;\n\n        int Y  = -0x40000000;\n\n        int U  = -128 << 23; // 19\n\n        int V  = -128 << 23;\n\n        int R, G, B;\n\n\n\n        for (j = 0; j < lumFilterSize; j++) {\n\n            Y += lumSrc[j][i]  * (unsigned)lumFilter[j];\n\n        }\n\n        for (j = 0; j < chrFilterSize; j++) {;\n\n            U += chrUSrc[j][i] * (unsigned)chrFilter[j];\n\n            V += chrVSrc[j][i] * (unsigned)chrFilter[j];\n\n        }\n\n\n\n        if (hasAlpha) {\n\n            A = -0x40000000;\n\n            for (j = 0; j < lumFilterSize; j++) {\n\n                A += alpSrc[j][i] * (unsigned)lumFilter[j];\n\n            }\n\n            A >>= 1;\n\n            A += 0x20002000;\n\n        }\n\n\n\n        // 8bit: 12+15=27; 16-bit: 12+19=31\n\n        Y  >>= 14; // 10\n\n        Y += 0x10000;\n\n        U  >>= 14;\n\n        V  >>= 14;\n\n\n\n        // 8bit: 27 -> 17bit, 16bit: 31 - 14 = 17bit\n\n        Y -= c->yuv2rgb_y_offset;\n\n        Y *= c->yuv2rgb_y_coeff;\n\n        Y += 1 << 13; // 21\n\n        // 8bit: 17 + 13bit = 30bit, 16bit: 17 + 13bit = 30bit\n\n\n\n        R = V * c->yuv2rgb_v2r_coeff;\n\n        G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n        B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n        // 8bit: 30 - 22 = 8bit, 16bit: 30bit - 14 = 16bit\n\n        output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n        output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n        output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n        if (eightbytes) {\n\n            output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n            dest += 4;\n\n        } else {\n\n            dest += 3;\n\n        }\n\n    }\n\n}\n", "idx": 16335, "substitutes": {"i": ["qi", "h", "ind", "info", "l", "ai", "ii", "ji", "n", "gi", "z", "di", "x", "sim", "ij", "ip", "c", "q", "ti", "li", "hi", "I", "p", "ei", "si", "m", "ri", "name", "ia", "b", "e", "im", "multi", "in", "ami", "sp", "index", "iu", "id", "g", "it", "me", "ci", "ie", "xi", "ex", "ic", "ki", "ik", "t", "phi", "zi", "ix", "mi", "is", "a", "pi", "v", "y", "f", "ini", "bi", "by", "ui", "io"], "j": ["jack", "k", "bj", "r", "mn", "att", "js", "g", "it", "ie", "jc", "pt", "pr", "jit", "d", "ji", "aj", "br", "ij", "ion", "next", "er", "jump", "m", "oj", "jac", "tr", "name", "kh", "ah", "ja", "Ja", "at", "uj", "fr", "dj", "other", "try", "t", "ix", "kid", "by", "ind", "jp", "l", "adj", "x", "off", "q", "note", "job", "je", "ev", "ju", "kj", "J", "bot", "o", "a", "jl", "n", "z", "json", "out", "jo", "state", "p", "jj", "gh", "bo", "b", "ng", "ijk", "str", "el", "jet", "v", "obj"], "R": ["E", "RT", "MR", "V", "RGB", "RG", "A", "Q", "S", "RB", "GR", "RO", "M", "TR", "H", "I", "HR", "r", "T", "N", "C", "W", "BR", "P", "D", "CR", "L", "DR", "U", "RR", "X", "Y", "RA", "F"], "G": ["E", "GB", "V", "GG", "GH", "RG", "GV", "GT", "Q", "A", "GR", "M", "GA", "H", "I", "Gr", "GP", "N", "C", "W", "Ge", "Gs", "P", "g", "D", "GE", "L", "GI", "J", "U", "Y", "BG", "GD", "F"], "B": ["BL", "GB", "E", "V", "A", "BA", "Q", "M", "BY", "Bi", "AB", "I", "IB", "T", "BO", "C", "DB", "BB", "b", "W", "BR", "NB", "P", "D", "L", "Both", "BU", "J", "U", "BM", "BC", "Y", "BG", "BT", "BF", "WB"]}}
