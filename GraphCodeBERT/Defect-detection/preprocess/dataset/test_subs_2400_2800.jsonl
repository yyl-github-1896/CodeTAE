{"project": "qemu", "commit_id": "35c5a52d1d016c632aed6137549754ca53446c92", "target": 0, "func": "void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,\n\n                            FWCfgState *fw_cfg, Object *owner)\n\n{\n\n    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,\n\n                          \"nvdimm-acpi-io\", NVDIMM_ACPI_IO_LEN);\n\n    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);\n\n\n\n    state->dsm_mem = g_array_new(false, true /* clear */, 1);\n\n    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);\n\n    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,\n\n                    state->dsm_mem->len);\n\n}\n", "idx": 24100, "substitutes": {"state": ["see", "status", "that", "request", "command", "r", "monitor", "call", "task", "estate", "runner", "size", "info", "states", "history", "progress", "scope", "role", "parent", "i", "space", "store", "config", "value", "operator", "error", "spec", "next", "shape", "setup", "tag", "data", "offset", "lock", "type", "job", "update", "now", "comment", "area", "STATE", "view", "policy", "form", "art", "State", "rule", "print", "process", "test", "stats", "st", "version", "style", "stat", "it", "out", "power", "component", "event", "local", "row", "resource", "list", "cache", "org", "initial", "root", "up", "instance", "start", "port", "post", "check", "self", "trace", "t", "index", "init"], "io": ["it", "i", "lo", "out", "o", "rio", "ror", "conn", "os", "IO", "icon", "ie", "ami", "ex", "storage", "ilo", "ia", "oop", "ri", "row", "ior", "mode", "org", "util", "area", "ai", "image", "connection", "rit", "co", "info", "ip", "ico", "net", "ir", "timeout", "ro"], "fw_cfg": ["wiredbconfig", "wiredbcfg", "fw_conf", "hw_conf", "wiredbvirt", "fwdbvirt", "wire_urg", "wire_virt", "hw_log", "fw_virt", "fwJfg", "fw_config", "fwJconf", "fw_fg", "wiredburg", "fwJlog", "fwdbconfig", "fwdbcfg", "wire_config", "wire_cfg", "hw_fg", "fw_log", "hw_cfg", "fwJcfg", "fw_urg", "fwdburg"], "owner": ["handler", "parent", "server", " ownership", " owns", "component", "owners", "OWN", " owners", "er", "owned", "object", "member", "framework", "office", "org", "holder", "root", "loader", "origin", "own", "ctx", "instance", "older", "inner", "link", "Owner", " Owner", "user", "writer", "scope", "reader", "self", "manager", "shared"]}}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, bool *rebuild,\n\n                               void **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        int64_t old_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* encryption */\n\n    if (s->crypto_header.length) {\n\n        ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                            s->crypto_header.offset,\n\n                            s->crypto_header.length);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n", "idx": 24103, "substitutes": {"bs": ["flows", "ubis", "sb", "bas", "pb", "jac", "boxes", "bl", "lbs", "os", "bles", "bps", "fs", "bc", "oss", "rs", "bes", "BS", "ses", "ubs", "ds", "bm", "banks", "aos", "bos", "bis", "hz", "fps", "cs", "cks", "sts", "bytes", "bits", "vs", "iss", "js", "blocks", "ss", "outs", "b", "ts", "ns", "ps", "ims", "aus", "locks", "bh", "irms", "its", "gs", "bp", "obs", "ls", "blog"], "res": ["ms", "css", "red", "rest", "reset", "pas", "ref", "fresh", "re", "os", "sol", "rs", "ber", "def", "rc", "result", "rev", "reg", "rr", "pr", "ren", "report", "results", "RES", "details", "r", "resource", "pers", "cond", "rec", "gr", "resp", "rect", "rel", "usr", " Res", "rem", "resh", "inv", "vec", "vers", "js", "rt", "cons", "rez", "req", "response", "wcs", "ps", "mr", "rss", "vals", "expr", "stats", "ers", "aux", "Res", "pres", "resolution", "der", "ress", "ro"], "fix": [" enforce", "cmp", " wait", " diff", " dirty", " quiet", " mask", "bf", " msg", " only", " validate", " ops", " def", " fuse", " err", " conflict", " impl", " orig", " ptr", "Fix", "check", " report", " conf", "CHECK", " prefix", " pack", " clear"], "rebuild": ["Rebuild", " reuild", "Reuild", " reBuild", "ReBuild", "resbuild", "reuild", " rebuilt", "resbuilt", "rebuilt", "reBuild", "resBuild", "resuild", "Rebuilt"], "refcount_table": ["refclaim32tab", "refwrite_storage", "refrefpletable", "refref_trace", "refcountingdata", "refcountPtree", "refcountpledata", "refrefpletask", "refcountmterror", "refcount_trace", "refcount32global", "refcount_Table", "refcountmttotal", "refCount_table", "refcountpleTable", "refcountingtree", "refclaim32global", "reflist_table", "refcountingtable", "refmatch_Table", "refmatch_task", "refwrite_option", "refcount_term", "refcount_global", "refclaim_table", "refcountixTable", "refcount32table", "refcount_total", "refcount1task", "refcountPdata", "refcount_tab", "refcountsTable", "refclaim32entity", "refref_tab", "refcountmttab", "refcountPtable", "refcount2table", "refclaim_tab", "refcountingfunction", "refwrite_table", "refwrite_term", "refrefPtrace", "refcountsbatch", "refcount1tab", "refcountingtab", "refcount_function", "refcountptoption", "reflist2table", "refcountingerror", "reflist2total", "refcountixtable", "refcount2error", "refCount_cache", "refcount_cache", "refclaim_entity", "refcount_batch", "refrefPtable", "refcountpletree", "refcountPtab", "refcount32tab", "refcount2total", "refref_task", "refcount_TABLE", "refcount_list", "refcountptterm", "refrefpledata", "refcountixtask", "refcount1table", "refmatch_table", "refref_table", "refcountPtrace", "refcountpletable", "refcountixbatch", "refmatchixTable", "refcountmtentity", "refcountPtask", "refcount_task", "refcountpttable", "refcountmtterm", "refcountstable", "refcountingtotal", "refcount_tree", "refCount_Table", "refref_data", "refclaim32table", "refcountmttable", "refcountmtglobal", "refmatchixbatch", "refcountmtoption", "refcountstask", "refcountingtask", "reflist_error", "refmatch_batch", "refcount_entity", "refcount_option", "refcount1trace", "refcountmtstorage", "refcountplebatch", "refrefPtab", "refrefpletree", "refcount_data", "refcountptstorage", "refclaim_global", "refcount_error", "refcountingTable", "reflist2error", "refmatchixtable", "refcount32entity", "refcountingcache", "refrefPtask", "refref_tree", "refmatchixtask", "reflist_total", "refcountpletask", "refcount_storage"], "nb_clusters": ["nb_cluster", "nbolyclusters", "nbolychainsubes", "nbolyclubes", "nb_splores", "nb_chainsusters", "nb_gluster", "nb_CLusters", "nb_lients", "nbosecollannels", "nb_Cluster", "nb_filayers", "nb_caonents", "nb_flients", "nb_lusters", "nb_clodes", "nb_collayers", "nboseclumers", "nbosecollusters", "nb_clroups", "nbolychainsores", "nb_clids", "nb_clicans", "nb_clograms", "nboseclannels", "nb_plusters", "nb_glust", "nb_filonents", "nb_critids", "nb_contust", "nbLEconfigusters", "nb_critubes", "nb_curusters", "nb_curots", "nb_splubes", "nb_critockets", "nb_chonents", "nb_plroups", "nbolyclicans", "nb_histumers", "nb_clannels", "nb_clonents", "nb_clurs", "nb_shusters", "nb_CLiders", "nb_Cliders", "nb_critusters", "nbolyclores", "nb_splurs", "nbolyclonents", "nb_chusters", "nb_clubes", "nbLEconfigaves", "nb_clockets", "nb_Clust", "nbLEclroups", "nb_claves", "nb_archonents", "nb_configroups", "nb_declumers", "nb_flroups", "nb_blodes", "nb_flaves", "nbolyclayers", "nb_archograms", "nb_blusters", "nb_bliders", "nb_contusters", "nb_shust", "nb_criturs", "nboseclopes", "nb_declannels", "nb_collonents", "nb_causters", "nb_bluster", "nb_contockets", "nbLEclusters", "nb_contids", "nb_splusters", "nb_configusters", "nb_Clodes", "nb_clumers", "nb_caots", "nbLEconfigients", "nb_glusters", "nb_filicans", "nb_clopes", "nb_CLuster", "nb_collicans", "nb_histusters", "nb_declopes", "nb_plaves", "nbolychainsusters", "nb_collopes", "nb_Clusters", "nbolychainsurs", "nb_clores", "nb_configients", "nb_glients", "nb_chayers", "nb_collusters", "nb_archots", "nb_archusters", "nbolyfilonents", "nb_curonents", "nb_chicans", "nbLEclaves", "nb_critust", "nb_luster", "nb_histannels", "nb_chainsores", "nb_configaves", "nb_shockets", "nb_caograms", "nb_collumers", "nbosecollumers", "nb_clust", "nb_declusters", "nb_cliders", "nb_CLodes", "nb_clots", "nb_histopes", "nbLEclients", "nb_clients", "nb_plients", "nb_Clients", "nbolyfilicans", "nbolyfilusters", "nb_flusters", "nboseclusters", "nb_shids", "nb_curograms", "nbolyclurs", "nb_clayers", "nb_chainsubes", "nbolyfilayers", "nb_lust", "nbLEconfigroups", "nb_critores", "nbosecollopes", "nb_filusters", "nb_chainsurs", "nb_collannels"], "s": ["sys", "ms", "as", "sb", "ops", "args", "eps", "ins", "os", "comm", "fs", "v", "rs", "w", "sam", "ses", "ds", "hs", "scl", "sl", "conf", "details", "g", "spec", "times", "p", "changes", "bis", "cs", "sts", "aws", "bits", "sym", "vs", "S", "als", "js", "ss", "settings", "xs", "a", "ssl", "b", "ats", "ts", "ns", "ps", "is", "l", "ims", "states", "y", "stats", "qs", "es", "its", "sp", "gs", "sv", "less", "e", "parts", "h", "ls", "stat", "m", "sq"], "i": ["ji", "it", "ic", "inter", "x", "ui", "ki", " j", " di", "multi", "ie", "us", "pi", "ini", " ii", "index", "ia", "ri", "gu", "me", "gi", "I", "n", "p", "phi", " bi", "oi", "di", "zi", "sim", "j", "ai", "mi", "li", "ii", "hi", "is", "ti", "ind", "l", " ti", "bi", "ip", "y", "ij", "ci", "iter", "e", " si", "u", "iu", " I", "xi", "si", "t", "im", "m", "cli", "init", "qi", "ei", "ix"], "sn": ["sd", "sys", "sa", "sb", "news", "nn", "syn", "ski", "os", "sol", "ln", "nr", "sam", "sbm", "nl", "ds", "sl", "tn", "sr", "n", "fn", "cn", "ny", "sh", "cs", "sw", "pn", "span", "ne", "ss", "bn", "Sn", "ns", "ts", "sm", "txt", "wn", "mn", "dn", "snap", "gn", "sp", "sf", "sv", "si", "rn", "sq", "SN", "ssl"], "ret": ["alt", "ter", "ll", "att", "cont", "virt", "del", "r", "reply", "dt", "rem", "et", "rep", "nil", "rt", "expr", "grain", " RET", " Ret", "mt", "Ret", "der", "detail", "obj", "rm", "re", "try", "term", "plain", "gt", "value", "after", "rev", "cat", "det", "git", "fun", "eval", "net", "final", "format", "reset", "RET", "def", "ry", "get", "compl", "rect", "pret", "print", "back", "test", "url", "tr", "elt", "vet", "it", "prop", "lit", "out", "red", "web", "err", "ref", "len", "result", "reg", "report", "ext", "over", "cmd", "sr", "deg", "cert", "mat", "resp", "usr", "last", "nt", "rets", "vals", "txt", "ft", "val", "flag", "arg", "Return"], "check_errors": ["call_error", "call_err", "callCounterror", "checkCounterror", "check_err", "call_errors", "callCountrors", "check_rors", "check_error", "checkCounterrors", "call_rors", "checkCountrors", "callCounterr", "checkCounterr", "callCounterrors"]}}
{"project": "qemu", "commit_id": "025b168ca674e42896c573fdbddf3090c6dc0d8f", "target": 1, "func": "static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)\n\n{\n\n    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,\n\n                       get_field(qtd->token, QTD_TOKEN_TBYTES),\n\n                       get_field(qtd->token, QTD_TOKEN_CPAGE),\n\n                       get_field(qtd->token, QTD_TOKEN_CERR),\n\n                       get_field(qtd->token, QTD_TOKEN_PID),\n\n                       (bool)(qtd->token & QTD_TOKEN_IOC),\n\n                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),\n\n                       (bool)(qtd->token & QTD_TOKEN_HALT),\n\n                       (bool)(qtd->token & QTD_TOKEN_BABBLE),\n\n                       (bool)(qtd->token & QTD_TOKEN_XACTERR));\n\n}\n", "idx": 24123, "substitutes": {"q": ["ch", "Q", "quit", "dq", "queue", "d", "w", "qt", "c", "k", "requ", "g", "qu", "r", "p", "qq", "que", "pe", "iq", "b", "query", "qs", "e", "u", "eq", "ue", "h", "t", "v", "sq", "qi"], "addr": ["inter", "x", "ad", "tx", "obj", "adr", "address", "arp", "ref", "hash", "host", "dh", "pad", "rs", "kt", "at", "gate", "aser", "act", "r", "ar", "ace", "ack", "add", "to", "ctx", "aro", " address", "eth", "rt", "ag", "dr", "work", "Address", "mt", "ptr", "tr", "pat", "t"], "qtd": ["Qbd", " qdet", "thinkmont", "Qmd", "Qrd", "QTD", "qudl", "qqdat", "Qdl", "qqdp", "thinkdet", "qtar", "qqfd", "qds", "querydm", " qdp", "qdem", "iqdet", "qqmont", "qdl", "quTD", " qrd", "qqdm", " qdash", "sqsd", "Qtar", "eqsd", "qrd", " qdt", "querydet", "wTD", "sqbd", "querydp", "iqdat", "dqbd", "qcd", "thinktd", "qxd", "qudn", "qupb", "sqdt", "sqmont", "queryfd", "eqpb", "sqtd", "eqdet", "qqmd", "qmont", "querysd", "qdm", "qqdem", "qTD", "qudm", "Qdp", "tcd", "qdet", "dqsd", " qmd", "ttd", "qufd", " qtw", "qmd", "qbd", "querytd", "qqtw", "thinkdash", "qudp", "Qfd", "sqdp", "thinksd", "qdash", "Qsd", "eqmont", "qudem", "quds", "dqtd", "qqbd", "qutar", "dqxd", "wdl", "Qmont", "qdp", "qsd", "eqdat", " qsd", "qqtd", "wbd", "Qxd", "qpb", "qurd", "sqpb", "sqcd", "qubd", "querydash", "sqxd", "qdat", "sqdn", "qdt", "sqds", "thinktar", "Qtd", " qdn", "iqtd", "Qdn", "Qtw", "Qdat", "iqsd", "qutd", "Qdem", "qtw", "qdn", "tdt", "qfd", "eqds", " qcd", "tsd", "eqtd", "thinkfd", "qumont", " qdat", "wtd"]}}
{"project": "qemu", "commit_id": "afea4e1410654154018587dd35c1b250ba4d8ec4", "target": 1, "func": "static void megasas_scsi_uninit(PCIDevice *d)\n\n{\n\n    MegasasState *s = MEGASAS(d);\n\n\n\n    if (megasas_use_msix(s)) {\n\n        msix_uninit(d, &s->mmio_io, &s->mmio_io);\n\n    }\n\n    if (megasas_use_msi(s)) {\n\n        msi_uninit(d);\n\n    }\n\n}\n", "idx": 24141, "substitutes": {"d": ["f", "sd", "pd", "i", "ad", "ld", "out", "dis", "o", "dq", "dh", "w", "c", "done", "D", "dc", "debug", "ds", "dx", "g", "r", "ed", "db", "send", "p", "n", "dt", "dm", "di", "did", "da", "data", "dp", "l", "dl", "dr", "dd", "dat", "des", "de", "bd", "dn", "fd", "e", "du", "m", "dos"], "s": ["f", "sys", "sd", "i", "sa", "sb", "se", "os", "fs", "sports", "rs", "w", "v", "c", "sam", "ses", "ds", "hs", "sl", "g", "r", "n", "p", "state", "cs", "sts", "sw", "aws", "set", "S", "js", "ss", "a", "is", "b", "l", "ts", "ns", "data", "ps", "sm", "y", "stats", "south", "st", "sing", "gs", "sp", "sv", "e", "self", "h", "ls", "t", "stat", "m", "sq", "su", "conf"]}}
{"project": "FFmpeg", "commit_id": "70f9661542a581dfe93b636b1c55b5558e4a4e3c", "target": 0, "func": "static int jpeg2000_decode_frame(AVCodecContext *avctx, void *data,\n\n                                 int *got_frame, AVPacket *avpkt)\n\n{\n\n    Jpeg2000DecoderContext *s = avctx->priv_data;\n\n    ThreadFrame frame = { .f = data };\n\n    AVFrame *picture = data;\n\n    int tileno, ret;\n\n\n\n    s->avctx     = avctx;\n\n    s->buf       = s->buf_start = avpkt->data;\n\n    s->buf_end   = s->buf_start + avpkt->size;\n\n    s->curtileno = 0; // TODO: only one tile in DCI JP2K. to implement for more tiles\n\n\n\n    // reduction factor, i.e number of resolution levels to skip\n\n    s->reduction_factor = s->lowres;\n\n\n\n    ff_jpeg2000_init_tier1_luts();\n\n\n\n    if (s->buf_end - s->buf < 2)\n\n        return AVERROR(EINVAL);\n\n\n\n    // check if the image is in jp2 format\n\n    if ((AV_RB32(s->buf) == 12) &&\n\n        (AV_RB32(s->buf + 4) == JP2_SIG_TYPE) &&\n\n        (AV_RB32(s->buf + 8) == JP2_SIG_VALUE)) {\n\n        if (!jp2_find_codestream(s)) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"couldn't find jpeg2k codestream atom\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (bytestream_get_be16(&s->buf) != JPEG2000_SOC) {\n\n        av_log(avctx, AV_LOG_ERROR, \"SOC marker not present\\n\");\n\n        return -1;\n\n    }\n\n    if (ret = jpeg2000_read_main_headers(s))\n\n        goto end;\n\n\n\n    /* get picture buffer */\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"ff_thread_get_buffer() failed.\\n\");\n\n        goto end;\n\n    }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n\n    picture->key_frame = 1;\n\n\n\n    if (ret = jpeg2000_read_bitstream_packets(s))\n\n        goto end;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++)\n\n        if (ret = jpeg2000_decode_tile(s, s->tile + tileno, picture))\n\n            goto end;\n\n\n\n    *got_frame = 1;\n\n\n\nend:\n\n    jpeg2000_dec_cleanup(s);\n\n    return ret ? ret : s->buf - s->buf_start;\n\n}\n", "idx": 24148, "substitutes": {"avctx": [" avctl", "averctx", "ajreq", "avercb", "verconn", "avercp", "ajcfg", "ajcontext", "verobj", "verctx", "abcmp", "avectl", "avcfg", "aukl", "wavconn", "apconn", "avcmp", "ajcb", "avercf", "avcf", "avecmd", "aveobj", "avercontext", "cvctx", " avjac", "apctx", "afcontext", " avcontext", "avecf", "avecontext", "ajctx", "auctx", "avconf", "auconf", "avekl", " avcf", "avecm", "avectx", "afctx", "avtx", "avreq", "abctx", "cvcm", " avcfg", "wavcmd", "avcmd", "afcmp", "avecb", "avereq", "avetx", "afconn", " avcm", "avcb", "wavobj", "aveconn", "ajcp", "cvcontext", "avcontext", "averreq", "abcontext", "avkl", "averjac", "avobj", "apcontext", "avcp", "avctl", "apcmp", "vtx", "cvtx", "vercmd", " avcp", "avercfg", "wavctx", "vctl", "avjac", "aveconf", "avconn", "abconn", "averconf", "averkl", "vcontext", " avtx", "vctx", "avejac", "avcm"], "data": ["f", "block", "padding", "join", "i", "length", "rew", "ref", "ata", "len", "intel", "d", "def", "value", "first", "done", "id", "video", "buffer", "empty", "r", "p", "new", "initial", "feed", "bytes", "buf", "to", "extra", "message", "frame", "image", "Data", "raw", "next", "file", "a", "align", "start", "info", "size", "dat", "text", "window", "json", "bin", "DATA", "offset", "table", "t", "content", "format", "init", "name", "this", "res"], "got_frame": ["gotMemframe", "fetched_frames", "got___frame", "got42frame", "got___frames", "got42next", "got___fram", "fetched___fram", "got_space", "went____frame", "got____frame", "fetched___frame", "went____space", "fetched___frames", "got_frames", "went_next", "went_space", "got_fram", "got42space", "got_next", "went_frame", "went____next", "gotMemframes", "fetched_frame", "fetched_fram", "got____next", "gotMemfram", "got____space"], "avpkt": ["avspct", "avppkt", "avpcpt", "avespacket", "avPkt", "avpppt", "avcct", "avppt", "aveppkt", "avpck", "avPdu", "avpcdu", "avcvt", "avpcct", "avepct", "avpckt", "avPpt", "avspvt", "avppct", "avepacket", "avopck", "svcpt", "avpadacket", "avcck", "avopkt", "avespvt", "avppdu", "avpadck", "avckt", "avpacket", "avpadkt", "avepvt", "avespct", "avepdu", "svpck", "svpkt", "avpvt", "avpct", "avPacket", "avepppt", "avpadpt", "avopacket", "svcacket", "avPct", "aveppct", "avspacket", "avcacket", "svcck", "avcpt", "avspkt", "aveppdu", "avPvt", "avoppt", "svppt", "svpacket", "avespkt", "aveppt", "avpdu", "avepkt", "svckt"], "s": ["eps", "comm", "sports", "d", "c", "r", "p", "changes", "aws", "ctx", "vs", "S", "xs", "ns", "ies", "y", "less", "h", "v", "sq", "views", "ess", "space", "i", "sa", "sb", "args", "os", "rs", "sl", "spec", "n", "sc", "cs", "services", "j", "session", "als", "so", "ats", "ts", "ims", "styles", "its", "parts", "m", "sys", "as", "ins", "simple", "ses", "scripts", "ids", "bis", "sts", "sw", "bs", "a", "is", "b", "l", "ps", "stats", "gs", "ls", "this", "ssl", "f", "ports", "se", "fs", "w", "aunts", "ds", "hs", "params", "details", "g", "webkit", "set", "js", "ss", "settings", "https", "qs", "es", "sp", "e", "sv", "self", "t", "events", "utils", "conf"], "picture": ["photo", "peg", "bite", "statement", "media", "obj", "man", "feature", "pty", "piece", "vp", "gif", "profile", "video", "details", "pen", "fi", "friendly", "p", "pause", "camera", "iture", "img", "pdf", "performance", "j", "policy", "ctx", "frame", "image", "print", "file", "share", "info", "ive", "png", "document", "query", "feat", " Picture", "pict", "figure", "support", "style", "summary", "fp", "sharp", "Picture", "format", "point", "pic"], "tileno": ["filestyle", "huneny", "sitno", "hunno", "ylleno", "ileny", "tilno", " tilento", "tilestyle", "bilen", "iligo", "siteno", "huneno", "bilento", "siterno", "utilno", "ileno", "utileny", "fileno", "yllnette", "bilno", "yllento", "bilerno", "ilestyle", "hunnette", "bilenum", "hunen", " tilenum", "hunento", "tilogo", "tinenum", "utileno", "hunigo", "tiligo", "ilerno", "tinento", " tilogo", "tineno", "tilnette", "tilenum", " tilno", "tilerno", " tilerno", "ilogo", "tilen", "filno", " tilestyle", "tileny", "sitogo", "bilnette", "ilno", "bileno", "filogo", "bilogo", "yllen", "utiligo", "tinerno", "tilento"], "ret": ["it", "alt", "ter", "not", "reset", "ll", "RET", "ref", "re", "success", "status", "len", "try", "att", "tif", "gt", "def", "ber", "after", "rev", "cont", "nl", "result", "mem", "fin", "true", "get", "det", "deg", "mat", "rel", "resp", "rem", "print", "rt", "nt", "fun", "dr", "rets", "elf", "progress", "ft", " Ret", "val", "flag", "mt", "net", "Ret", "il", "tr", "jp", "elt", "format", "res"]}}
{"project": "qemu", "commit_id": "a22313deca720e038ebc5805cf451b3a685d29ce", "target": 0, "func": "static void vfio_platform_eoi(VFIODevice *vbasedev)\n\n{\n\n    VFIOINTp *intp;\n\n    VFIOPlatformDevice *vdev =\n\n        container_of(vbasedev, VFIOPlatformDevice, vbasedev);\n\n\n\n    qemu_mutex_lock(&vdev->intp_mutex);\n\n    QLIST_FOREACH(intp, &vdev->intp_list, next) {\n\n        if (intp->state == VFIO_IRQ_ACTIVE) {\n\n            trace_vfio_platform_eoi(intp->pin,\n\n                                event_notifier_get_fd(&intp->interrupt));\n\n            intp->state = VFIO_IRQ_INACTIVE;\n\n\n\n            /* deassert the virtual IRQ */\n\n            qemu_set_irq(intp->qemuirq, 0);\n\n\n\n            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {\n\n                /* unmasks the physical level-sensitive IRQ */\n\n                vfio_unmask_single_irqindex(vbasedev, intp->pin);\n\n            }\n\n\n\n            /* a single IRQ can be active at a time */\n\n            break;\n\n        }\n\n    }\n\n    /* in case there are pending IRQs, handle the first one */\n\n    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {\n\n        intp = QSIMPLEQ_FIRST(&vdev->pending_intp_queue);\n\n        vfio_intp_inject_pending_lockheld(intp);\n\n        QSIMPLEQ_REMOVE_HEAD(&vdev->pending_intp_queue, pqnext);\n\n    }\n\n    qemu_mutex_unlock(&vdev->intp_mutex);\n\n}\n", "idx": 24162, "substitutes": {"vbasedev": ["vbidiv", "vfacedev", "vfiredev", "hbaseiv", "vfacedel", " vndem", " vbasedriver", " vbackeddev", " vbackedriver", "vvardef", "vfacedele", "vbasedef", "vbaseem", "vbasedep", "vbackeddev", " vndef", " vbasedele", "vbasedem", " vndep", "vndep", "vbaseddev", " vbasedem", " vbasedep", "hbasedev", "vbasedriver", "vvardev", "vbidel", "vbaseel", "vbackedriver", "vbasedele", "hbaseel", "hbasedef", "hbaseev", "hbasedel", "vvardele", " vfacedele", "vbidef", "vbasedel", "vbaseep", "vbidep", "vbaseele", "vbaseriver", "vfireddev", "vbedev", "vbackedev", " vbasedel", " vbaseddev", "vfiredriver", "vbaseiv", "vbaseev", " vfacedev", " vndev", "vfacedef", "vbidem", "vbasediv", "vndev", "vbidev", " vfacedel", "vvardel", "vbediv", "vbedel", "vbedef", " vbasedef", "vndef", " vfacedef", "vbaseef", "hbasediv", "vndem", "hbaseef", " vbackedev"], "intp": ["strpa", "latping", "latpa", " intping", "intern", "alp", "pretpc", "intphp", "icpp", "antpress", "interpc", "intps", "incpid", "intpid", "uintcp", "inpkg", "intv", "latpc", "uintpa", "icp", "latpatch", "antv", "backp", "gtp", "inp", "instf", "strpatch", "uinth", "intn", " intphp", "intcp", "strpc", "printn", "entP", "intpt", "interp", " intsp", "incv", "icpress", "interP", "alpress", "intping", "gtP", "backf", "restpc", "pretpatch", "backping", "uintpatch", "interps", " intP", "printp", " intf", "inping", "latsp", "indpt", "interh", "instps", "restcp", "instp", "strp", "interpa", "incphp", "incpkg", "uintp", " intpatch", "intpp", "indp", "alpp", "interping", "antp", "resth", "pretpa", "instpa", "intpkg", "incping", "antphp", "antpp", "interfacep", " intv", "uintpc", "inth", "intpatch", "latpt", "entpa", "interfacepid", "icpa", "intercp", "intsp", "intP", "instping", " intn", "alpa", "intpc", "latp", "interfaceping", "entp", " intpa", "entps", "printP", "intpa", "indping", "inpid", "uintping", "incsp", "restp", "gtping", "indpc", "incpa", "pretp", "intpress", "gtpa", "instP", "backpa", "printpa", "intf", "incp", "incpatch", "interfacepkg", "antpa", "uintpt"], "vdev": ["vcam", "vdevices", "Vstable", "voltw", "vdevice", "avdevices", "verdevelop", "verconn", "virtualstable", "vcdevice", "verpay", "wiredev", "vserial", "vpay", "voltdiv", "wdevice", "VDEV", "voltstable", "avdev", "cvdb", " vdevice", "tvdev", "vcdev", "virtualdevelop", " vconn", "vDEV", "verserial", "mw", "voltdevice", "wireserial", "gdevelop", "avDEV", "mcam", "vcw", "vdevelop", "vbuild", "avpay", "vconn", "voltcam", "gstable", "tvconn", "cvdevice", "Vdev", "mdevice", "cvdev", "henv", "venv", " vdiv", "virtualdevice", "tvdevelop", "vdb", "cvdiv", "virtualdev", "verdevices", " venv", "voltenv", "voltbuild", "wdiv", "vdiv", "mdev", "avserial", "wdev", "hdiv", "vstable", "vccam", " vstable", "hdevice", "wdb", " vdb", "avstable", "verdev", "Vbuild", "wiredevices", "gdev", "voltdev", " vdevelop", "gdevice", "hdev", "wirepay", "vw", "voltDEV", "avbuild"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n", "idx": 24164, "substitutes": {"s": ["sys", "space", "as", "sa", "sb", "os", "fs", "v", "rs", "w", "c", "ses", "ds", "hs", "g", "r", "n", "p", "sc", "cs", "sts", "set", "ctx", "S", "js", "bs", "ss", "a", "is", "b", "ns", "ts", "sm", "y", "stats", "st", "e", "gs", "sp", "sg", "self", "h", "t", "q"], "rlow": ["vmin", "rtlow", "pmin", "rlower", "rloc", "rdloc", "rbegin", "orlower", "rmin", "plower", "vlower", "mrloc", "rdlocal", "rtloc", "mrlocal", "mrlow", "rtmin", "rdlow", "plow", "rdmin", "orbegin", "rlocal", "ormin", "vbegin", "rtlocal", "mrmin", "vlow", "pbegin", "orlow"], "rhigh": ["Rhigh", "RHigh", "bhighest", "rright", "bHigh", " rHigh", " rhighest", "Rhighest", "Rright", "Rmax", "vhighest", "bright", " rright", "vmax", "vhigh", " rmax", "rhighest", "rmax", "vHigh", "bhigh", "rHigh"], "val": ["pol", "it", "x", "alt", "out", "cal", "tx", "err", "xy", "al", "ref", "temp", "def", "value", "valid", "reg", "mem", "pr", "var", "sel", "func", "p", "vol", "buf", "bal", " v", "ctx", "vec", "data", "Val", "test", "VAL", "expr", "vals", "loc", "key", "ival", "eval", "alpha", "bin", "num", "serv", "ret", "vt", "t", "index", "v", "pt", "grad"], "tmp": ["tar", "cmp", "perm", "tm", "obj", "xy", "uf", "temp", "mb", "mp", "tv", "bo", "gt", "emp", "pot", "sam", "part", "tt", "grow", "tz", "var", "mk", "tn", "timeout", "cmd", "cp", "p", "tab", "new", "resp", "msg", "util", "cb", "proc", "buf", "mint", "j", "ctx", "td", "np", "orig", "rt", "tg", "b", "gm", "py", "attr", "nt", "lib", "txt", "snap", "gb", "sp", "etc", "buff", "ret", "pkg", "img", "vt", "uv", "m", "v", "t", "ptr", "jp", "cv", "pt", "split"]}}
{"project": "qemu", "commit_id": "29a6731afb20707ab0c1f9be997bef74cef34665", "target": 0, "func": "static void vararg_number(void)\n\n{\n\n    QObject *obj;\n\n    QInt *qint;\n\n    QFloat *qfloat;\n\n    int value = 0x2342;\n\n    int64_t value64 = 0x2342342343LL;\n\n    double valuef = 2.323423423;\n\n\n\n    obj = qobject_from_jsonf(\"%d\", value);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%\" PRId64, value64);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value64);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%f\", valuef);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n    qfloat = qobject_to_qfloat(obj);\n\n    g_assert(qfloat_get_double(qfloat) == valuef);\n\n\n\n    QDECREF(qfloat);\n\n}\n", "idx": 24179, "substitutes": {"obj": ["cur", "alt", "o", "po", "stick", "ie", "att", "ent", "cont", "og", "inst", "arr", "vol", " Obj", "rt", "ct", "attr", "ij", "y", "src", "expr", "pkg", "onet", "pt", "aq", "here", "xy", "rm", "br", "os", "oss", "db", "ob", "msg", "j", "Obj", "ht", "inv", "co", "ind", "con", "obs", "ist", "buff", "ot", "eff", "op", "iv", "yt", "obo", "def", "ck", "act", "gr", "rect", "sw", "go", "art", "oid", "addr", "rb", "adj", "off", "kl", "tmp", "elt", "str", "it", "opt", "typ", "ref", "utt", "tk", "bo", "object", "wo", "ext", "cmd", "img", "org", "resp", "rel", "cb", "np", "js", "req", "nt", "bj", "txt", "oj", "bh", "aux", "self", "t"], "qint": ["qclient", "qqconst", " qclient", "eqclient", "qindex", "requnet", "qualpoint", "iqclient", "qqnet", "eqint", "sqINT", "qpt", "qualinteger", "qinteger", "qtind", "qINT", "questioninit", "quint", "qtint", "qconst", "qualpt", "questint", "qin", "qualin", "qinit", "quinteger", "iqent", "questionent", "eqindex", "qqind", "qqpt", "qvert", "quin", "iqnet", "iqrec", "iqint", "qualINT", "qqint", "eqind", "qualvert", "dqINT", "qualconst", "sqent", "qtconst", "qualint", "qualind", "eqvert", "sqinit", "quind", "iqind", "questionint", "eqinit", "dqint", "qpoint", " qindex", "qrec", "requinit", "iqinit", "dqvert", "qtpoint", "dqrec", "eqpt", "sqint", " qnet", "qualrec", "questinteger", "iqINT", "qind", "qqinit", "requint", "questionINT", "questin", "eqnet", "qqpoint", "iqindex", "dqind", "qent", "requpt", "dqpt", "qnet", "questind"], "qfloat": ["gvar", "qbool", "aqfat", "qflat", "gdouble", "qfat", "sqvar", "sqfloat", "qvar", "quickfloat", "iqfloat", "gflat", "queryint", "aqdouble", "dqFloat", "dqflat", "gport", "queryfat", "quickbool", " qport", " qbool", " qfat", "iqflo", "qFloat", "iqbool", "aqfloat", "queryflat", " qflo", "qprint", "qvert", " qprint", " qflat", " qvar", "gFloat", "sqvert", "dqdouble", "sqport", "qdouble", "gvert", " qvert", "queryfloat", "iqprint", "aqFloat", "quickflo", "quickprint", "aqint", "qport", "aqflat", "dqfloat", "qflo", "gfloat"]}}
{"project": "qemu", "commit_id": "95ed56939eb2eaa4e2f349fe6dcd13ca4edfd8fb", "target": 0, "func": "static int ohci_service_ed_list(OHCIState *ohci, uint32_t head, int completion)\n\n{\n\n    struct ohci_ed ed;\n\n    uint32_t next_ed;\n\n    uint32_t cur;\n\n    int active;\n\n\n\n    active = 0;\n\n\n\n    if (head == 0)\n\n        return 0;\n\n\n\n    for (cur = head; cur; cur = next_ed) {\n\n        if (ohci_read_ed(ohci, cur, &ed)) {\n\n            trace_usb_ohci_ed_read_error(cur);\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n\n\n        next_ed = ed.next & OHCI_DPTR_MASK;\n\n\n\n        if ((ed.head & OHCI_ED_H) || (ed.flags & OHCI_ED_K)) {\n\n            uint32_t addr;\n\n            /* Cancel pending packets for ED that have been paused.  */\n\n            addr = ed.head & OHCI_DPTR_MASK;\n\n            if (ohci->async_td && addr == ohci->async_td) {\n\n                usb_cancel_packet(&ohci->usb_packet);\n\n                ohci->async_td = 0;\n\n                usb_device_ep_stopped(ohci->usb_packet.ep->dev,\n\n                                      ohci->usb_packet.ep);\n\n            }\n\n            continue;\n\n        }\n\n\n\n        while ((ed.head & OHCI_DPTR_MASK) != ed.tail) {\n\n            trace_usb_ohci_ed_pkt(cur, (ed.head & OHCI_ED_H) != 0,\n\n                    (ed.head & OHCI_ED_C) != 0, ed.head & OHCI_DPTR_MASK,\n\n                    ed.tail & OHCI_DPTR_MASK, ed.next & OHCI_DPTR_MASK);\n\n            trace_usb_ohci_ed_pkt_flags(\n\n                    OHCI_BM(ed.flags, ED_FA), OHCI_BM(ed.flags, ED_EN),\n\n                    OHCI_BM(ed.flags, ED_D), (ed.flags & OHCI_ED_S)!= 0,\n\n                    (ed.flags & OHCI_ED_K) != 0, (ed.flags & OHCI_ED_F) != 0,\n\n                    OHCI_BM(ed.flags, ED_MPS));\n\n\n\n            active = 1;\n\n\n\n            if ((ed.flags & OHCI_ED_F) == 0) {\n\n                if (ohci_service_td(ohci, &ed))\n\n                    break;\n\n            } else {\n\n                /* Handle isochronous endpoints */\n\n                if (ohci_service_iso_td(ohci, &ed, completion))\n\n                    break;\n\n            }\n\n        }\n\n\n\n        if (ohci_put_ed(ohci, cur, &ed)) {\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return active;\n\n}\n", "idx": 24200, "substitutes": {"ohci": ["ohca", "ohdi", " ohco", "Ohcont", "ehcci", "Ohcci", "OhCI", "ahc", "ohco", "ihdi", "ehpi", "Ohco", "ahco", "Ohdi", "ohcu", " ohdi", "ahpi", " ohpi", "Ohpi", "ohpi", "ahdi", "hci", "ihci", " ohcu", " ohCI", "Ohcu", "ihc", " ohcci", "ahcci", " ohcont", "hCI", "hdi", "ohcci", "ahci", "ahcu", "hcci", "ihca", "hpi", "ihcci", "ihpi", "Ohci", "ahca", "ohc", "ahcont", "ehdi", "ehc", "ehci", "ohCI", " ohca", "ohcont"], "head": ["run", "foot", "then", "host", "map", "id", "gate", "headers", "count", "origin", "pos", "frame", "size", "weight", "front", "link", "ptr", "h", "heads", "max", "parent", "ock", "headed", "header", "n", "next", "th", "shape", "tag", "window", "iter", "offset", "before", "point", "lock", "device", "length", "hold", "min", "HEAD", "pad", "body", "Head", "cycle", "ck", "form", "depth", "capacity", "back", "mean", "limit", "mask", "off", "sum", "block", "hash", "len", "bit", "flags", "row", "top", "md", "start", "shift", "port", "load", "post", "heading", "query", "wind", "position", "flag", "cap", "tail", "end", "loop", "index", "ahead"], "completion": ["Completing", "ompleting", " Completing", "Completion", "omplete", "completed", "ompletion", " Completion", "Completed", "complete", "completing", " Complete", "Complete", " Completed", "ompleted"], "ed": ["bed", " sent", "ized", "ez", "d", "ent", "ved", "ared", "done", "er", "or", "ar", "p", "elected", "et", "ended", "and", "used", " ke", "z", "ored", "embed", "h", "oned", " d", "ented", "ded", "ted", "ev", "ered", "Ed", " found", "reed", "ached", "db", "el", "ined", "fed", "ied", "ned", "created", "eded", "de", " parsed", "en", "eds", "ped", "ld", "led", "ing", "ued", "added", " ev", "started", "edited", "owed", " got", "ged", "sent", "loaded", " stored", "l", " added", "aled", "est", "hed", "eed", "ad", "sed", "red", "arted", "osed", "ated", "se", "edd", "ex", "ired", "acked", "med", "sh", " es", " e", " od", "aed", "eb", "ED", "es", "e", "em", "oted"], "next_ed": ["next_e", "nextSeted", "Next_ted", "nextSeED", " next_e", "next_ED", "Next_ED", "next_eb", "nextOffe", " next_er", "nextOffeds", "Next_er", " next_red", "nextTheeb", "nextOffred", "next_er", "next_ted", "nextSeer", "nextSeed", "nextTheeds", "next_eds", " next_eds", "next_red", " next_eb", "nextTheer", "nextOffed", "Next_ed", "nextTheed"], "cur": ["cmp", " curs", "c", "tc", "ctr", "cont", "dc", "or", "count", "pg", "ser", "open", "ctx", "ct", "loc", "track", "gc", "ptr", "ch", " now", "currently", "ce", "adr", "conn", "pri", "try", "bc", "occ", "ur", "rev", "ctrl", "cat", "ver", "cp", "close", "sc", "buf", "next", "ach", "desc", "bur", "sur", "handle", "con", "iter", "current", "sys", "ph", "col", "nr", "cycle", "ry", "seq", "now", " cursor", "Cur", "nc", "oc", "dr", "cr", "off", "tr", "q", "tmp", "cv", "err", "ok", " car", "cor", "rc", "car", "row", "cmd", "cb", "start", "unc", " Cur"], "active": ["charged", "action", "iguous", "alert", "Active", "status", "pc", "def", "c", "_", "cycle", "rev", "ctr", "cont", "activate", "seq", "act", "g", "func", " inactive", "activated", "enabled", "count", "mode", "connected", "le", "ended", "confirmed", "total", "sequence", "ac", "stable", "progress", "selected", "activity", "current", "track", "cap", "exec", "ptr", "all", "loop", "running", "index", "name"], "addr": ["inter", "cmp", "ad", "alt", "trans", "err", "obj", "adr", "address", "arp", "ref", "sta", "host", "from", "att", "id", "rc", "rev", "at", "dev", "tz", "r", "cmd", "ack", "ar", "ace", "arr", "ord", "add", "rel", "to", "et", "coord", "tag", "eth", "rt", "attr", "ag", "ip", "dr", "src", "loc", "ether", "url", "Address", "mt", "hl", "ret", "ptr", "tr", "offset", "elt", "t", "ress", "str", "name", "res"]}}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)\n\n{\n\n    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);\n\n    object_unparent(OBJECT(&pbdev->iommu_mr));\n\n    pbdev->iommu_enabled = false;\n\n}\n", "idx": 24201, "substitutes": {"pbdev": ["typdev", "pbgu", "bufserv", "PBDEV", "PBver", "ebdev", "typgu", "pdevice", "pkgDEV", "bbgu", "fbdev", "phydiv", "cbdiv", "ebdevice", "typdevice", "PBDev", "PBdevice", "pkgDev", "pbdiv", "fbdiv", "bufdevice", "pbDEV", "typver", "pbver", "fbdet", "phydev", "bufdev", "phydet", "pbve", "bbdev", "cbdet", "pdebug", "bufdebug", "pserv", "ebver", "phydevice", "ebDev", "pkgdev", "pkgve", "pyDEV", "pbdef", "bbver", "cbserv", "PBve", "fbdevice", "pydef", "PBgu", "pbdet", "pbserv", "pbdebug", "cbdebug", "bbdevice", "cbdev", "pkgdevice", "pdev", "pyve", "PBdev", "cbdevice", "pkgver", "pbDev", "pbdevice", "PBdef", "pkgdef", "pydev"]}}
{"project": "FFmpeg", "commit_id": "1dba8371d93cf1c83bcd5c432d921905206a60f3", "target": 0, "func": "int ffurl_connect(URLContext *uc, AVDictionary **options)\n\n{\n\n    int err =\n\n        uc->prot->url_open2 ? uc->prot->url_open2(uc,\n\n                                                  uc->filename,\n\n                                                  uc->flags,\n\n                                                  options) :\n\n        uc->prot->url_open(uc, uc->filename, uc->flags);\n\n    if (err)\n\n        return err;\n\n    uc->is_connected = 1;\n\n    /* We must be careful here as ffurl_seek() could be slow,\n\n     * for example for http */\n\n    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, \"file\"))\n\n        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)\n\n            uc->is_streamed = 1;\n\n    return 0;\n\n}\n", "idx": 24205, "substitutes": {"uc": ["cur", "urn", "ux", "userc", "eu", "ui", "tm", "cam", "cu", "uf", "ucc", "orc", "bc", "pc", "usc", "uch", "roc", "ur", "ow", "tc", "umi", "kt", "emp", "pac", "ul", "upt", "um", "ec", "sup", "ck", "lam", "clus", "aut", "UC", "ctl", "cus", "soc", "sc", "nc", "util", "ut", "eg", "lu", "up", "uci", "uk", "usb", "auc", "ac", "anc", "unc", "oc", "aus", "uph", "wp", "ou", "uh", "ocr", "ub", "mc", "fc", " unc", "uu", "utf", "ud", "u", "etc", "gc", "kw", "exec", "cc", "uv", "proc", "lc", "hw"], "options": ["option", "context", "opt", "other", "uploads", "ops", "values", "args", "fs", "config", "members", "tags", "flags", "params", "results", "details", "currency", "times", "metadata", "headers", "pdf", "policy", "foreign", "words", "ptions", "settings", "ption", "data", "ts", "types", "ps", "ims", "stats", "json", "styles", "es", "its", "Options", "features", "atts", "properties", "parts"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "uint8_t sd_read_data(SDState *sd)\n\n{\n\n    /* TODO: Append CRCs */\n\n    uint8_t ret;\n\n    int io_len;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable)\n\n        return 0x00;\n\n\n\n    if (sd->state != sd_sendingdata_state) {\n\n        fprintf(stderr, \"sd_read_data: not in Sending-Data state\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION))\n\n        return 0x00;\n\n\n\n    io_len = (sd->ocr & (1 << 30)) ? 512 : sd->blk_len;\n\n\n\n    switch (sd->current_cmd) {\n\n    case 6:\t/* CMD6:   SWITCH_FUNCTION */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 64)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 9:\t/* CMD9:   SEND_CSD */\n\n    case 10:\t/* CMD10:  SEND_CID */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 16)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 11:\t/* CMD11:  READ_DAT_UNTIL_STOP */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 13:\t/* ACMD13: SD_STATUS */\n\n        ret = sd->sd_status[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->sd_status))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 17:\t/* CMD17:  READ_SINGLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 18:\t/* CMD18:  READ_MULTIPLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 22:\t/* ACMD22: SEND_NUM_WR_BLOCKS */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 30:\t/* CMD30:  SEND_WRITE_PROT */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 51:\t/* ACMD51: SEND_SCR */\n\n        ret = sd->scr[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->scr))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 56:\t/* CMD56:  GEN_CMD */\n\n        if (sd->data_offset == 0)\n\n            APP_READ_BLOCK(sd->data_start, sd->blk_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sd->blk_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    default:\n\n        fprintf(stderr, \"sd_read_data: unknown command\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24206, "substitutes": {"sd": ["hd", "vd", "nd", "sta", "score", "d", "std", "cell", "storage", "sam", "dev", "s", "dt", "sim", "mod", "sec", "and", "SD", "dl", "sand", "bd", "draw", "ud", "si", "sy", "series", "sa", "sb", "dis", "ard", "sl", "good", "db", "send", "sc", "add", "dm", "eas", "ind", "desc", "lib", "sys", "ld", "amd", "reci", "def", "ell", "cd", "wd", "sch", "disc", "di", "sw", "sql", "form", "cod", "td", "df", " cd", "ssl", "od", "pd", "pm", "ad", "sea", "ay", "ma", "se", "sky", "ds", "details", "md", "ord", "sh", "dist", "gd", "ss", "dd", "south", "fd", "dk", "sv", "sg"], "ret": ["prop", "alt", "ter", "out", "lit", "rest", "reset", "ll", "rm", "RET", "re", "uf", "try", "tf", "att", "gt", "def", "result", "rev", "lt", "fin", "get", "det", "arr", "resp", "rel", "pret", "rem", "rep", "nz", "print", "fit", "ert", "rt", "back", "nt", "rets", "des", "url", "ft", " Ret", "aux", "mt", "Ret", "il", "tr", "t", "jp", "format", "arg", "elt", "utils", "res"], "io_len": [" io7els", " io_lan", "ioxlen", " io2l", "io8Len", "io_cap", " io2lif", " io_fin", "ao_len", "ci_vol", " io_elt", "io__len", "iolenseq", "io7ln", "io2lan", "ao_dir", " io_gen", "io55len", "io67elt", "io_vol", " io7gen", "io_lif", "io2data", " io_den", "io68len", " io2seq", "io_loc", "io_seq", " ioxlan", "io_els", "io_label", "io_lan", "iolendata", "io_den", "io67body", " ioxfin", " io2ln", "io__lif", "io55lif", "io_body", " io2lan", " io_ln", " io2len", "io68lit", "io__lan", "io8cap", "ioxbody", " ioxbody", "ci68lit", "io67lim", "ci68Len", "io_lim", " io7len", " io_seq", "ci_lit", "io33gen", "io2ln", "io67lit", "io67len", "io__ln", "ao_label", "io8loc", "io8len", " io_body", " io2data", "io7gen", "iolenl", "io_l", "io2l", " io_lim", "io67lan", " io_lit", " io_lif", "ci68len", "ci_Len", "ao_cap", "io7len", " io_Len", "ioxfin", "io8den", "io_lit", "io33len", " io_data", "io_Len", "io33els", "ao_loc", "ci_len", "ci68vol", "io8lan", "io2len", " io_els", "iolenlen", "io_elt", "io55lan", "io7els", "io68Len", " io7ln", "io2seq", " ioxlen", "io68vol", " io_l", "io55ln", "io_data", "io_fin", "ioxlan", "io67fin", "io_dir", "io_gen", "ao_ln", "io33ln", "ao_lan", "io_ln", "io2lif"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_int(TestOutputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    int64_t value = -42;\n\n    QObject *obj;\n\n\n\n    visit_type_int(data->ov, NULL, &value, &error_abort);\n\n\n\n    obj = visitor_get(data);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);\n\n}\n", "idx": 24212, "substitutes": {"data": ["device", "ic", "batch", "rew", "ad", "out", "o", "ata", "d", "att", "def", "map", "value", "id", "output", "zero", "debug", "ds", "dev", "mem", "reg", "command", "spec", "mode", "di", "to", "ctx", "session", "Data", "dal", "a", "da", "desc", "test", "info", "dat", "window", "json", "step", "missing", "dump", "reader", "DATA", "bus", "table", "t", "v", "aw", "this"], "unused": [" unavailable", " unuse", " unwuse", "sunused", "sunuse", " unwavailable", " unspecified", " unwspecified", "unuse", "unavailable", "sunspecified", "sunavailable", "unspecified", " unwused"], "obj": ["it", "opt", "cur", "x", "out", "o", "xy", "opp", "ref", "po", "stick", "eff", "op", "v", "ent", "obo", "bo", "tk", "object", "pr", "og", "act", "inst", "n", "arr", "org", "ob", "resp", "j", "Obj", "ctx", "ht", "cod", "np", "js", "vo", "instance", "ind", "oc", "nt", "attr", "bj", "ij", "txt", "oj", "con", "val", "obs", "adj", "buff", "t", "tmp", "elt", "oa", "ot", "pt", "res"]}}
{"project": "qemu", "commit_id": "9c12a6f24d8bfd0e0d81a4a77f515e32d15547c1", "target": 0, "func": "void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)\n\n{\n\n    struct in_addr host_addr = { .s_addr = INADDR_ANY };\n\n    int host_port;\n\n    char buf[256] = \"\";\n\n    const char *p = src_str;\n\n    int is_udp = 0;\n\n    int n;\n\n\n\n    if (!slirp_inited) {\n\n        monitor_printf(mon, \"user mode network stack not in use\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!src_str || !src_str[0])\n\n        goto fail_syntax;\n\n\n\n    get_str_sep(buf, sizeof(buf), &p, ':');\n\n\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    host_port = atoi(p);\n\n\n\n    n = slirp_remove_hostfwd(is_udp, host_addr, host_port);\n\n\n\n    monitor_printf(mon, \"removed %d host forwarding rules for %s\\n\", n,\n\n                   src_str);\n\n    return;\n\n\n\n fail_syntax:\n\n    monitor_printf(mon, \"invalid format\\n\");\n\n}\n", "idx": 24213, "substitutes": {"mon": ["den", "chan", "on", "ston", "Mon", "man", "min", "conn", "MON", " mu", "ann", "mut", "master", "mun", "mx", "mm", "mer", "chron", "cat", "rup", "fn", "wat", "mit", "vis", "dm", "san", "monitor", "mat", "util", "mint", "monkey", "coord", "mi", "hog", " monitor", " mem", "mn", "con", "met", "num", "mt", "mons", "mate", "m", "onet", "mont", "mu"], "src_str": ["src64list", "tmp___buf", "tmp___str", "src_buf", "src2str", "tmp_list", "tmp_buf", "src_Str", "tmp___list", "rc_string", "src_txt", "src___buf", "src64str", " src_Str", "src___str", "rc_trans", "tmp_str", " src_src", "src64string", "src2Str", "src_trans", "tmp_string", "src2br", "src_list", "src_src", "src2buf", " src_txt", "src_string", "rc_str", "rc_int", " src_buf", "src_int", "tmp___string", " src_br", "src64buf", "src_br", " src_string", "src___list", "src___string"], "host_port": ["hostzPORT", " host_Port", " hostzport", "host_host", "host_Port", "hostzport", "host_PORT", "host_ort", " hostzPORT", " host_offset", "host2PORT", " hostzports", "hostzoffset", "host_ports", " hostzoffset", "host_offset", " host_ports", "host2Port", " host_PORT", "host2port", " host_ort", "hostzports", "host2ort", " host_host"], "buf": ["cur", "pb", "queue", "ff", "vp", "array", "buffer", "mem", "pool", "count", "pg", "que", "ctx", "words", "pos", "raw", "orig", "page", "bt", " buffer", "pkg", "pack", "tx", "br", "font", "temp", "cat", "db", "cast", "cp", "Buff", "msg", "bar", "bag", "desc", "data", "dat", "aka", "window", "iter", "Buffer", "buff", "batch", "cam", "pad", "seq", "ah", "bytes", "vec", "doc", "b", "text", "rb", "kw", "rw", "off", "tmp", "q", "str", "cv", "mu", "block", "prop", "nm", "uf", "ann", "cmd", "list", "cache", "img", "cb", "paste", "np", "req", "port", "txt", "fd", "cap", "proc", "conv"], "p": ["f", "ping", "pre", "i", "pb", "pc", "d", "pad", "vp", "part", "c", "pp", "k", "pi", "at", "g", "r", "pool", "cp", "pid", "par", "j", "pos", "pe", "np", "a", "per", "b", "l", "ps", "port", "post", "pa", "progress", "sp", "bp", "tp", "u", "pard", "fp", "pkg", "P", "pat", "h", "t", "q", "m", "v", "jp", "lp", "pt"], "n": ["sn", "i", "x", "na", "o", "nn", "nm", "nan", "d", "nb", "nr", "ln", " i", " ni", "c", "k", "g", "r", "nc", "cn", " len", "j", "an", "nu", "np", "ne", "b", "l", "ns", "nt", "port", "y", "z", "N", "num", "gn", " fn", "en", "u", "number", "ni", "t", "no", "m", "v", " l"]}}
{"project": "qemu", "commit_id": "ab0997e0afdcb272fd04784a280b2df46b0c759f", "target": 1, "func": "static int qcow2_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                          int remaining_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster, n1;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset = 0;\n\n    uint64_t bytes_done = 0;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *cluster_data = NULL;\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        /* prepare next request */\n\n        cur_nr_sectors = remaining_sectors;\n\n        if (s->crypt_method) {\n\n            cur_nr_sectors = MIN(cur_nr_sectors,\n\n                QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n        }\n\n\n\n        ret = qcow2_get_cluster_offset(bs, sector_num << 9,\n\n            &cur_nr_sectors, &cluster_offset);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (!cluster_offset) {\n\n\n\n            if (bs->backing_hd) {\n\n                /* read from the base image */\n\n                n1 = qcow2_backing_read1(bs->backing_hd, &hd_qiov,\n\n                    sector_num, cur_nr_sectors);\n\n                if (n1 > 0) {\n\n                    BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING_AIO);\n\n                    qemu_co_mutex_unlock(&s->lock);\n\n                    ret = bdrv_co_readv(bs->backing_hd, sector_num,\n\n                                        n1, &hd_qiov);\n\n                    qemu_co_mutex_lock(&s->lock);\n\n                    if (ret < 0) {\n\n                        goto fail;\n\n                    }\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                qemu_iovec_memset(&hd_qiov, 0, 512 * cur_nr_sectors);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            ret = qcow2_decompress_cluster(bs, cluster_offset);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            qemu_iovec_from_buffer(&hd_qiov,\n\n                s->cluster_cache + index_in_cluster * 512,\n\n                512 * cur_nr_sectors);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                ret = -EIO;\n\n                goto fail;\n\n            }\n\n\n\n            if (s->crypt_method) {\n\n                /*\n\n                 * For encrypted images, read everything into a temporary\n\n                 * contiguous buffer on which the AES functions can work.\n\n                 */\n\n                if (!cluster_data) {\n\n                    cluster_data =\n\n                        g_malloc0(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n                }\n\n\n\n                assert(cur_nr_sectors <=\n\n                    QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_add(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n\n\n            BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                cur_nr_sectors, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n            if (s->crypt_method) {\n\n                qcow2_encrypt_sectors(s, sector_num,  cluster_data,\n\n                    cluster_data, cur_nr_sectors, 0, &s->aes_decrypt_key);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n                    cur_nr_sectors * 512);\n\n                qemu_iovec_from_buffer(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}", "idx": 24222, "substitutes": {"bs": ["sys", "ubis", "bb", "ms", "sb", "bas", "pb", "boxes", "bl", "lbs", "os", "bps", "fs", "bc", "rs", "bes", "BS", "ses", "bf", "ubs", "ds", "hs", "bm", "aos", "bos", "bis", "fps", "hz", "cs", "sts", "aws", "bits", "vs", "iss", "als", "js", "outs", "ss", "b", "ns", "ts", "aus", "locks", "bh", "bt", "its", "gs", "bp", "obs", "ls", "lb", "blog"], "sector_num": ["sector_NUM", "sector1norm", "sectorNamenorm", " sector_NUM", "section_num", " sector_number", "sector1number", "sector_Num", "section_um", "sector_mon", "section_number", "section_nom", "sectorNameNum", "sectorNamenumber", "sector1num", "sector_nom", "sector2NUM", "sector2number", " sector_Num", "section_NUM", "section_norm", "sector_number", "section_Num", "sector2Num", "sectorNamenum", "sector1Num", "sector_um", "sector_norm", "section_mon", "sector2mon", "sector2num"], "remaining_sectors": ["remaining_spectors", "remaining_sosections", "remaining_soivers", "remaining_secs", "remainingitysvors", "remainingityseors", "remainingitysvctors", "remaining_sesections", "remaining_veors", "remaining_tesections", "remaining_specs", "remaining_speapters", "remaining_svctors", "remaining_teors", "remaining_veapters", "remainingitysecs", "remaining_pevers", "remaining_soors", "remaining_vectors", "remainingityseapters", "remaining_pectors", "remaining_vecs", "remaining_severs", "remaining_teivers", "remaining_speors", "remaining_svors", "remaining_soctors", "remaining_spevers", "remainingitysvapters", "remaining_seivers", "remaining_seapters", "remaining_svcs", "remaining_svapters", "remainingitysectors", "remaining_pecs", "remaining_seors", "remaining_vesections", "remainingitysvcs", "remaining_vevers", "remaining_peors", "remaining_veivers", "remaining_tectors"], "qiov": ["iqiev", "qovi", "qiv", "qiev", "sqiov", "ckovi", "eqiv", " qiev", "ckconv", " qiop", "quiev", " qiour", "qdyl", "sqiop", "iqiov", "sqiev", " qovi", "qrolet", "eqiev", "qudyl", "quiop", "iqdyl", "eqdyl", "eqiov", "qiop", " qrolet", " qconv", "quovi", "sqrolet", "iqiv", "qconv", "quiour", "qurolet", "quiv", "quiov", "qiour", "quconv", "ckiov", "ckiour"], "s": ["sys", "ms", "i", "as", "sb", "args", "ins", "os", "comm", "fs", "rs", "w", "bes", "sam", "ses", "ds", "hs", "conf", "details", "spec", "p", "bis", "changes", "series", "cs", "sts", "sw", "set", "aws", "j", "vs", "S", "als", "js", "ss", "settings", "is", "b", "ats", "ns", "ts", "ps", "ims", "abilities", "states", "stats", "qs", "es", "its", "sp", "gs", "sv", "serv", "less", "self", "actions", "h", "ls", "t", "stat", "sq", "socket", "ssl"], "index_in_cluster": ["index_in_chusters", "index_in_chust", "index_in_clust", "index_in_clusters", "index_in_choser", "index_in_scusters", "index_in_plust", "index_in_Cluster", "index_in_scust", "index_in_ploser", "index_in_pluster", "index_in_scoser", "index_in_Closer", "index_in_plusters", "index_in_closer", "index_in_chuster", "index_in_Clusters", "index_in_Clust", "index_in_scuster"], "n1": [" nOne", "sn81", "dn1", "sn1", "anuber", "dnOnce", "r0", "fnones", "rn1", "rnuber", "an001", "nones", "nOne", "fn2", " nones", "n2", " n2", " NOne", "an1", " n0", " nuber", "dn2", "sn0", "fnOne", "snOne", " Nones", "cn1", " N1", " N2", "cnOnce", " nOnce", "nOnce", "r81", "rn001", "r1", "nuber", " n81", "rOne", "n001", "cn2", "dn81", "n81", "n0", "cn81", " n001", "fn1"], "ret": ["f", "job", "alt", "ter", "out", "red", "lit", "reset", "ll", "RET", "ref", "re", "rm", "len", "tf", "att", "gt", "def", "sub", "result", "rev", "cont", "after", "mem", "lt", "details", "get", "fi", "r", "cmd", "far", "deg", "cert", "rect", "et", "leg", "print", "rt", "back", "nt", "fun", "rets", "prot", "virtual", " RET", "ft", " Ret", "val", "net", "mt", "Ret", "il", "tr", "t", "elt", "final", "arg", "locked", "res"], "cur_nr_sectors": ["cur_nr_vellers", "cur_nr_beivers", "cur_nr_bectors", "cur_nr_speivers", "cur_nr_vevers", "cur_nr_begments", "cur_nr_spegments", "cur_nr_vegments", "cur_nr_mevers", "cur_nr_pegments", "cur_nr_segments", "cur_nr_bevers", "cur_nr_mectors", "cur_nr_pellers", "cur_nr_peors", "cur_nr_seivers", "cur_nr_veivers", "cur_nr_spellers", "cur_nr_vectors", "cur_nr_sellers", "cur_nr_severs", "cur_nr_speors", "cur_nr_spectors", "cur_nr_meivers", "cur_nr_bellers", "cur_nr_pectors", "cur_nr_veors", "cur_nr_pevers", "cur_nr_seors", "cur_nr_beors", "cur_nr_meors", "cur_nr_spevers"], "hd_qiov": ["hd_ekovi", "hd_iqiov", "hd_giour", "hd_dqiour", "hd_qunox", "hd_ueiev", "hd_qnox", "hd_qopted", "hdmyqiov", "hdmyqdyl", "hd_myiov", "hd_iqiev", "hd_qiv", "hd_zyon", "hdmyqiao", "hd_ziov", "hd_dqdyl", "hd_eriev", "hdmyacquiov", "hd_qdyl", "hd_ekiev", "hd_acquiao", "hd_qrolet", "hd_dqiever", "hdmyqkov", "hd_giv", "hd_iqiv", "hd_qiao", "hd_myiev", "hd_acquiev", "hd_dqiv", "hd_quiol", "hdmyacqukov", "hd_iqrolet", "hd_qovi", "hd_qiever", "hd_chnox", "hd_myiour", "hd_dqkov", "hd_eqkov", "hd_qiol", "hd_chiev", "hd_grolet", "hd_quopted", "hd_ziev", "hd_ekyon", "hd_quovi", "hd_acqukov", "hd_eqiao", "hdmyacquiao", "hd_dqiao", "hd_dqrolet", "hd_quiov", "hd_eriov", "hd_iqiever", "hd_qiour", "hd_ueiour", "hd_giov", "hd_dqiov", "hd_chopted", "hd_quiour", "hd_acquopted", "hd_eriol", "hd_ueiov", "hd_iqiour", "hdmyacqudyl", "hd_dqiev", "hd_ekiov", "hd_eqdyl", "hd_qyon", "hd_acqunox", "hd_qiev", "hd_quiev", "hd_myiever", "hd_ueiol", "hd_acqudyl", "hd_quyon", "hd_acquiov", "hd_eqiov", "hd_qkov", "hd_eriour", "hd_chiov", "hd_zovi"], "cluster_data": ["clusterityinfo", "cluster2info", "cluster2data", "cluster_offset", "clusters_offset", "cluster2error", "clusterityerror", "cluster_info", "clusters_info", "clusters_data", "clusteritydata", "cluster_error", "clusters_error", "cluster2offset", "clusterityoffset"]}}
{"project": "FFmpeg", "commit_id": "86dfcfd0e30d6645eea2c63c1c60a0550e7c97ea", "target": 1, "func": "static int read_kuki_chunk(AVFormatContext *s, int64_t size)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st      = s->streams[0];\n\n\n\n    if (size < 0 || size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)\n\n        return -1;\n\n\n\n    if (st->codec->codec_id == AV_CODEC_ID_AAC) {\n\n        /* The magic cookie format for AAC is an mp4 esds atom.\n\n           The lavc AAC decoder requires the data from the codec specific\n\n           description as extradata input. */\n\n        int strt, skip;\n\n        MOVAtom atom;\n\n\n\n        strt = avio_tell(pb);\n\n        ff_mov_read_esds(s, pb, atom);\n\n        skip = size - (avio_tell(pb) - strt);\n\n        if (skip < 0 || !st->codec->extradata ||\n\n            st->codec->codec_id != AV_CODEC_ID_AAC) {\n\n            av_log(s, AV_LOG_ERROR, \"invalid AAC magic cookie\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        avio_skip(pb, skip);\n\n    } else if (st->codec->codec_id == AV_CODEC_ID_ALAC) {\n\n#define ALAC_PREAMBLE 12\n\n#define ALAC_HEADER   36\n\n#define ALAC_NEW_KUKI 24\n\n        uint8_t preamble[12];\n\n        if (size < ALAC_NEW_KUKI) {\n\n            av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n            avio_skip(pb, size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        avio_read(pb, preamble, ALAC_PREAMBLE);\n\n\n\n        st->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.\n\n         * The new style cookie only contains the last 24 bytes of what was\n\n         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes\n\n         * in that case to maintain compatibility. */\n\n        if (!memcmp(&preamble[4], \"frmaalac\", 8)) {\n\n            if (size < ALAC_PREAMBLE + ALAC_HEADER) {\n\n                av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n                av_freep(&st->codec->extradata);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            avio_read(pb, st->codec->extradata, ALAC_HEADER);\n\n            avio_skip(pb, size - ALAC_PREAMBLE - ALAC_HEADER);\n\n        } else {\n\n            AV_WB32(st->codec->extradata, 36);\n\n            memcpy(&st->codec->extradata[4], \"alac\", 4);\n\n            AV_WB32(&st->codec->extradata[8], 0);\n\n            memcpy(&st->codec->extradata[12], preamble, 12);\n\n            avio_read(pb, &st->codec->extradata[24], ALAC_NEW_KUKI - 12);\n\n            avio_skip(pb, size - ALAC_NEW_KUKI);\n\n        }\n\n        st->codec->extradata_size = ALAC_HEADER;\n\n    } else {\n\n        st->codec->extradata = av_mallocz(size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n        avio_read(pb, st->codec->extradata, size);\n\n        st->codec->extradata_size = size;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24230, "substitutes": {"s": ["sys", "space", "as", "sb", "ops", "conv", "ins", "os", "se", "fs", "v", "rs", "c", "ses", "ds", "scl", "hs", "g", "r", "ar", "n", "p", "ans", "cs", "sts", "sw", "aws", "j", "ctx", "S", "js", "bs", "ss", "xs", "a", "is", "ats", "b", "ns", "ts", "ps", "l", "sm", "stats", "qs", "south", "es", "its", "gs", "sp", "sv", "sg", "h", "t", "ls", "sq", "ssl"], "size": ["sn", "padding", "length", "space", "x", "news", "large", "ce", "address", "network", "len", "fee", "c", "storage", "body", "after", "zero", "error", "buffer", "gz", "false", "now", "password", "empty", "g", "height", "send", "n", "count", "amount", "ize", "ze", "small", "sh", "bytes", "sw", "to", "too", "message", "total", "shape", "capacity", "data", "shift", "scale", "notice", "SIZE", "z", "south", "num", "sp", "e", "time", "Size", "number", "scroll", "offset", "max", "t", "sum", "format", "no", "name"], "pb": ["vm", "sys", "bb", "fb", "pm", "sb", "typ", "tm", "tx", "emb", "uf", "mp", "pc", "nb", "vp", "stab", "tk", "pp", "tc", "pr", "um", "func", "db", "pool", "cp", "p", "pg", "tab", "ob", "cb", "cm", "buf", "gp", "ctx", "span", "PB", "phys", "pl", "np", "td", "bs", "amp", "b", "ts", "dp", "wb", "pa", "wp", "snap", "BP", "ub", "bh", "pro", "px", "tp", "bp", "sp", "rb", "gb", "fp", "ib", "pkg", "lp", "jp", "proc", "lb", "cv", "pt"], "st": ["sn", "ost", "cl", "sb", "typ", "rest", "nd", "sta", "sty", "se", "std", "ste", "tt", "irst", "sl", "St", "inst", "sc", "sh", "sts", "ut", "set", "sw", "ust", "stage", "ast", "td", "stan", "th", "art", "ss", "stop", "rt", "ct", "ts", "nt", "must", "sm", "ind", "ST", "start", "stable", "step", "ft", "sp", "mt", "sv", "ist", "est", "t", "stat", "str", "pt"], "strt": ["strl", "strp", "sprte", "stringt", "chart", "iterg", "strte", " strdt", "strdt", " strct", "stringct", "charv", "charp", "iterdt", "sprv", "strct", " strte", "sprl", "Strdt", " strtt", "charl", "strv", "Strt", "Strpt", " strg", " strl", "strg", "stringp", "charct", "charte", "chartt", " strpt", "itert", "Strg", " strv", "strtt", " strp", "iterpt", "sprt", "strpt", "stringtt"], "skip": ["run", "trans", "sleep", "jump", "syn", "need", "then", "strip", "after", "zero", "wait", "miss", "ipp", "find", "sync", "row", "send", "count", "add", "move", "pos", "Skip", "sk", "pass", "scan", "share", "include", "delay", "ip", "seek", "link", "step", "snap", "limit", "num", "sp", "missing", "copy", "scroll", "iter", "slot", "trace", "offset", "check", "loop", "no"], "atom": ["tar", " moment", "prop", " contam", "orm", " symb", "typ", "nm", "xy", " om", "item", " electron", "term", "op", "from", "xml", " oxygen", "aton", "part", "at", " bom", "or", "cmd", " mate", "tab", "mat", "fam", "asm", " prop", "msg", " atomic", "node", "ym", "sym", " bond", "pair", "com", " partner", "attr", "element", "om", " emit", "orb", " plat", "mol", " matrix", "mate", " strat", "m", "format"], "preamble": ["ppreamble", "Pamler", "preamlet", "ppreambles", "preambles", "Pamle", "preamlist", "pamBLE", "Preamle", "Preambles", "prambled", "prewble", "preamle", "prewBLE", "pparmBLE", "pamlet", "parmlet", "prombled", "pambles", "pamler", "Preambled", "Preamlist", "prewbles", "pressobles", "prambles", "pressole", "Pamlist", "Pambled", "preamBLE", "preambled", "prombles", "pamlist", "promble", "pramble", "pressoler", "parmbles", "Pambles", "parmble", "Preamble", "ppreamlet", "pramle", "Preamler", "ppreamBLE", "promlist", "pparmlet", "pramler", "Pamble", "prewlet", "pamle", "pamble", "pambled", "parmBLE", "pressoble", "pparmbles", "preamler", "pparmble", "pramlist"]}}
{"project": "qemu", "commit_id": "728470bea15b11ba7b3e3db54f0d9939908e0e65", "target": 1, "func": "static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)\n\n{\n\n    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));\n\n\n\n    if (qemu_file_mode_is_not_valid(mode)) {\n\n        return NULL;\n\n    }\n\n\n\n    r->rdma = rdma;\n\n\n\n    if (mode[0] == 'w') {\n\n        r->file = qemu_fopen_ops(r, &rdma_write_ops);\n\n    } else {\n\n        r->file = qemu_fopen_ops(r, &rdma_read_ops);\n\n    }\n\n\n\n    return r->file;\n\n}\n", "idx": 24231, "substitutes": {"rdma": ["rustma", "rdman", "udsta", "ridmic", "rdmo", "erdmo", "rustsm", "rustna", "erdma", "rnsta", "udma", "ldsm", "erdman", "udmic", "ridma", "rdlia", "rnmic", "ldna", "drna", "rmu", "drlia", "rdmic", "rdsm", "rman", "rdna", "rdmu", "udmma", "drma", "rmo", "ldma", "rnma", "rdsta", "rustlia", "erdmu", "rma", "rnmma", "ldlia", "drman", "drmo", "drmu", "drsm", "ridmma", "rdmma", "ridsta"], "mode": ["range", "device", "option", "mac", "perm", "direction", "MODE", "ward", "force", "power", "pose", "only", "code", "raid", "none", "zero", "mm", "command", "md", "cmd", "me", "phrase", "use", "mit", "prefix", "move", "mod", "area", "module", "te", "pe", "ode", "test", "de", "scale", "dd", "mop", "position", "ase", "when", "Mode", "time", "mask", "mt", "mate", "format", "m", "stroke", "role"], "r": ["f", "it", "err", "lr", "rm", "ref", "re", "br", "rl", "d", "rs", "nr", "rd", "hr", "fr", "rc", "result", "k", "er", "rh", "rr", "ren", "pr", "or", "g", "ar", "rate", "p", "sr", "rec", "gr", "new", "rel", "rar", "rect", "root", "vr", "j", "rt", "b", "req", "rer", "response", "dr", "mr", "R", "cr", "y", "rb", "reader", "ret", "h", "q", "rg", "rn", "m", "ro", "res"]}}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int decode_codestream(J2kDecoderContext *s)\n\n{\n\n    J2kCodingStyle *codsty = s->codsty;\n\n    J2kQuantStyle  *qntsty = s->qntsty;\n\n    uint8_t *properties = s->properties;\n\n\n\n    for (;;){\n\n        int marker, len, ret = 0;\n\n        const uint8_t *oldbuf;\n\n        if (s->buf_end - s->buf < 2){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing EOC\\n\");\n\n            break;\n\n        }\n\n\n\n        marker = bytestream_get_be16(&s->buf);\n\n        if(s->avctx->debug & FF_DEBUG_STARTCODE)\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"marker 0x%.4X at pos 0x%tx\\n\", marker, s->buf - s->buf_start - 4);\n\n        oldbuf = s->buf;\n\n\n\n        if (marker == J2K_SOD){\n\n            J2kTile *tile = s->tile + s->curtileno;\n\n            if (ret = init_tile(s, s->curtileno))\n\n                return ret;\n\n            if (ret = decode_packets(s, tile))\n\n                return ret;\n\n            continue;\n\n        }\n\n        if (marker == J2K_EOC)\n\n            break;\n\n\n\n        if (s->buf_end - s->buf < 2)\n\n            return AVERROR(EINVAL);\n\n        len = bytestream_get_be16(&s->buf);\n\n        switch(marker){\n\n            case J2K_SIZ:\n\n                ret = get_siz(s); break;\n\n            case J2K_COC:\n\n                ret = get_coc(s, codsty, properties); break;\n\n            case J2K_COD:\n\n                ret = get_cod(s, codsty, properties); break;\n\n            case J2K_QCC:\n\n                ret = get_qcc(s, len, qntsty, properties); break;\n\n            case J2K_QCD:\n\n                ret = get_qcd(s, len, qntsty, properties); break;\n\n            case J2K_SOT:\n\n                if (!(ret = get_sot(s))){\n\n                    codsty = s->tile[s->curtileno].codsty;\n\n                    qntsty = s->tile[s->curtileno].qntsty;\n\n                    properties = s->tile[s->curtileno].properties;\n\n                }\n\n                break;\n\n            case J2K_COM:\n\n                // the comment is ignored\n\n                s->buf += len - 2; break;\n\n            default:\n\n                av_log(s->avctx, AV_LOG_ERROR, \"unsupported marker 0x%.4X at pos 0x%tx\\n\", marker, s->buf - s->buf_start - 4);\n\n                s->buf += len - 2; break;\n\n        }\n\n        if (s->buf - oldbuf != len || ret){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"error during processing marker segment %.4x\\n\", marker);\n\n            return ret ? ret : -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 24244, "substitutes": {"s": ["eps", "comm", "app", "sports", "d", "c", "sam", "er", "comments", "tests", "r", "times", "p", "changes", "aws", "bits", "vs", "S", "xs", "ns", "ies", "y", "less", "http", "h", "orders", "v", "sq", "i", "sb", "args", "os", "rs", "spec", "n", "cs", "ags", "j", "als", "ats", "ts", "ims", "styles", "its", "ers", "parts", "summary", "sys", "ms", "as", "x", "ins", "gets", "ants", "ties", "simple", "ses", "ids", "bis", "sts", "sw", "bs", "a", "is", "b", "ps", "stats", "gs", "ls", "ports", "fs", "w", "ex", "ds", "hs", "details", "g", "set", "js", "ss", "settings", "dates", "qs", "south", "es", "e", "sv", "self", "source", "t", "events"], "codsty": ["cpsty", "odsty", " codety", "codsy", "cdety", "oxstro", "odestyle", " codty", "cmdstyle", " codestyle", "codst", "lexstyle", "codestyle", "oxestyles", "cmdstra", "cmdsty", "codeestyles", "cmdsy", "pedty", "lexsty", "oxety", " codstra", "lexestyle", "cdsy", "codstra", "codestyles", "lexstro", "codety", "odsy", "cdestyle", " codstro", "codstro", "pedstyle", " codstyle", " codestyles", "odstyle", " codst", " codsy", "codesty", "odestyles", "cpst", "cpstra", "cpestyles", "pedsty", "odety", "codesy", "oxestyle", "odty", "cmdestyles", "codstyle", "codty", "oxstyle", "pedstro", "oxsty", "cmdst", "cdsty", "odstro"], "qntsty": [" qndsym", "qncsty", " qndso", "Qntsym", "qnotsy", "qnstyle", "qrentsty", "Qndsty", "qctstyle", "qctstyles", "Qntsty", "qctsy", " qntst", "qnnsty", "qntstyle", " qntstyle", "qntst", "qntstyles", " qrtsty", "qnnsta", "qnnst", " qrtstyles", " qndst", "qndsta", "qntSty", "qnsym", " qndstyle", " qntstyles", "Qndstyle", "qndfo", "qdefsty", "Qntfo", "qndstyle", " qntso", "qrentstyle", " qndsta", " qntsym", "qdefstyle", "qentso", "Qndfo", "qmtstyle", " qntSty", "qrentsym", "qmtSty", "qndst", "qentsty", "qmtsym", "qnotstyles", "qctsty", "qntso", "qncsta", "qentstyle", " qntsy", "qnotsty", "qndsym", "qmtsty", "qndsty", " qrtstyle", "qnotstyle", " qrtsy", "qndso", "qncstyle", "Qntstyle", " qndSty", "qrentSty", "qrtsym", "qntsy", " qntsta", "qrtstyle", "qntfo", "qncst", "qntsym", "qdefso", " qndsty", "qrtstyles", "Qndsym", "qnnstyle", "qrtsty", "qnfo", "qndSty", "qrtsy", "qnsty", "qrtfo", "qntsta"], "properties": ["prop", "values", "bugs", "options", "items", "phones", "fields", "ties", "strings", "members", "tags", "phy", "flags", "params", "comments", "details", "links", "packages", "tis", "times", "pps", "metadata", "headers", "products", "objects", "prints", "classes", "units", "services", "bits", "resources", "workers", "frames", "settings", "perties", "abilities", "dates", "types", "beans", "ps", "images", "poses", "powers", "states", "vals", "terms", "stories", "progress", "styles", "notes", "effects", "fixes", "pro", "features", "parts", "errors", "orders", "property", "artifacts", "reports", "dos", "pointers"], "marker": ["Markiter", "presentER", "arkker", "packer", " markarer", " Marker", "MarkER", "markker", "Marker", "merer", "markiter", "Markker", " markter", "arkter", "markeder", " markER", "masker", "misster", "marketer", "markediner", "maskER", "misser", "mereter", "presenter", "Markner", "markarer", "markter", "presentener", "missER", "merarer", " Markiter", "markner", "markedER", "markiner", "arker", "Markter", "presentker", "Markera", "packter", "Marketer", " markner", "arkera", "packER", " marketer", "maskner", "markER", "merER", "missiner", "packner", "markera", "markedera", "maskiter", "Markarer", "markedter", "arkER", "Markiner", " Markner", " MarkER", "arkener", "markener", "Markener"], "len": ["lvl", "wid", "length", "ll", "syn", "ln", "nl", "mem", "del", "fin", "seq", "lis", "n", "el", "fn", "Len", "vol", "resp", "lon", "inv", "pos", "els", "vec", "l", "size", "nt", "lan", "fun", "loc", "lib", "fil", "lim", "z", "limit", "num", "iter", "val", "sp", "en", "ret", "il", "offset", "un", "ptr", "elt", "ls", "lp", "mid", "kl", "joined"], "oldbuf": ["newbuff", "lowbuffer", "OLDbuff", " oldbuff", "Oldbuffer", "OLDcb", "lowbuf", "Oldbytes", "oldbytes", "oldbuffer", "OLDbuffer", "newbuffer", "lowbytes", "Oldbuff", "olderbuff", "lowbuff", "newcb", "newbuf", "oldbuff", "oldercb", "oldcb", " oldbytes", "Oldbuf", "OLDbuf", "olderbuf", "olderbuffer", " oldbuffer"], "tile": ["Tile", "tree", "device", "sett", "sheet", " Tile", "site", "store", "pose", "entity", "slice", "phone", "unit", "cell", "vp", "kt", "grid", "league", "title", "buffer", "member", "target", "tier", "details", "sel", "toggle", "pixel", "ten", "stone", "tip", "layer", "tab", "mat", "shot", "rect", "node", "sector", "te", "coord", "image", "depth", "tag", "detail", "ele", "ti", "test", "ts", "player", "mobile", "port", "scale", "tie", "key", "window", "theme", "ile", "tif", "tle", "mate", "table", "ptr", "vt", "property", "offset", "t", "texture"]}}
{"project": "FFmpeg", "commit_id": "9745f19ffc9031ce480e43d7cf1053b58100d70f", "target": 0, "func": "static av_cold int ass_decode_init(AVCodecContext *avctx)\n\n{\n\n    avctx->subtitle_header = av_malloc(avctx->extradata_size);\n\n    if (!avctx->extradata)\n\n        return AVERROR(ENOMEM);\n\n    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);\n\n    avctx->subtitle_header_size = avctx->extradata_size;\n\n    return 0;\n\n}\n", "idx": 24269, "substitutes": {"avctx": ["avpool", "afctl", " avctl", "averctx", "actgc", "wavtx", "avercb", "devpool", "navgc", "avercrit", "avcrit", "averctl", "devcontext", "avectl", "autpid", "avpkg", "averpkg", "avcmp", "actcontext", "autctl", "acttx", "wavcontext", "wavtxt", "wavctl", "avercontext", "actcmd", "actkt", "navcontext", "afpid", " avcmd", "afcontext", " avpkg", "afpkg", "avgc", "wavcrit", " avcontext", "avecontext", "avecmp", " avpid", "devctx", "avpid", "avectx", "avkt", "afctx", "avtxt", "avtx", "navctx", "actpool", "wavcmd", "avcmd", " avcrit", "avertxt", "actctx", "navcmp", "avetx", "avcb", "avepkg", "avcontext", "devtx", "autcontext", "autctx", "avctl", "wavctx", " avkt", "avercmd", "avertx", "wavcb", " avtxt", " avtx", "avegc", " avpool", "averkt", "actcmp", "afcb", "wavpkg", "actpkg"]}}
{"project": "qemu", "commit_id": "f2b58c43758efc61e2a49b899f5e58848489d0dc", "target": 1, "func": "int v9fs_device_realize_common(V9fsState *s, Error **errp)\n\n{\n\n    int i, len;\n\n    struct stat stat;\n\n    FsDriverEntry *fse;\n\n    V9fsPath path;\n\n    int rc = 1;\n\n\n\n    /* initialize pdu allocator */\n\n    QLIST_INIT(&s->free_list);\n\n    QLIST_INIT(&s->active_list);\n\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n\n        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);\n\n        s->pdus[i].s = s;\n\n        s->pdus[i].idx = i;\n\n    }\n\n\n\n    v9fs_path_init(&path);\n\n\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n\n\n    if (!fse) {\n\n        /* We don't have a fsdev identified by fsdev_id */\n\n        error_setg(errp, \"9pfs device couldn't find fsdev with the \"\n\n                   \"id = %s\",\n\n                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    if (!s->fsconf.tag) {\n\n        /* we haven't specified a mount_tag */\n\n        error_setg(errp, \"fsdev with id %s needs mount_tag arguments\",\n\n                   s->fsconf.fsdev_id);\n\n        goto out;\n\n    }\n\n\n\n    s->ctx.export_flags = fse->export_flags;\n\n    s->ctx.fs_root = g_strdup(fse->path);\n\n    s->ctx.exops.get_st_gen = NULL;\n\n    len = strlen(s->fsconf.tag);\n\n    if (len > MAX_TAG_LEN - 1) {\n\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        error_setg(errp,\n\n                   \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    rc = 0;\n\nout:\n\n    if (rc) {\n\n        if (s->ops->cleanup && s->ctx.private) {\n\n            s->ops->cleanup(&s->ctx);\n\n        }\n\n        g_free(s->tag);\n\n        g_free(s->ctx.fs_root);\n\n        v9fs_path_free(&path);\n\n    }\n\n    return rc;\n\n}\n", "idx": 24280, "substitutes": {"s": ["o", "eps", "reads", "service", "comm", "d", "c", "sam", "sync", "r", "p", "changes", "aws", "vs", "S", "ns", "save", "ies", "y", "states", "less", "h", "v", "sq", "these", "space", "sb", "args", "obj", "store", "re", "os", "rs", "sl", "spec", "n", "state", "cs", "services", "j", "session", "als", "so", "ats", "ts", "ims", "des", "its", "parts", "m", "sys", "ms", "as", "ins", "gets", "ses", "results", "has", "sts", "sw", "go", "bs", "a", "is", "b", "l", "ps", "stats", "gs", "serv", "errors", "ls", "this", "ssl", "f", "ports", "fs", "w", "bes", "ds", "hs", "params", "details", "g", "set", "js", "ss", "settings", "qs", "south", "es", "e", "sv", "u", "self", "source", "ys", "t", "utils", "conf"], "errp": ["errorpa", "corp", "lrpolicy", "ererap", "errorpe", " erpad", "corpoint", "acerpart", "errpolicy", " errP", "rerp", "ermpad", "errpress", "errpoint", "errorpb", "errpe", "errorap", "errP", "errpart", "rerpa", "errorpart", "errorpad", "errorback", "ermback", "acerpress", "corpe", "ererpe", "ermpart", "ermpolicy", "errback", " erpart", "ermpress", "errpad", "lrp", "errpy", "errorpoint", "errap", "acerpolicy", "nerP", " erback", " errpy", "corap", "erpre", "erp", "errpb", "errorp", " errpb", "lrpress", "ererp", "lrpart", "nerpb", "acerp", "rerP", " erp", "errorpre", "erP", "errorP", "ererpoint", "errorpy", "nerpy", "erpa", "rerpre", "nerp", "errpre", "errpa", "ermp"], "i": ["ui", "c", "ini", "id", "in", "r", "I", "p", " bi", "sim", "ai", "li", "used", "ip", "ij", "y", " mi", "ci", "iu", " I", "si", "MI", "v", "ei", "ji", "ski", "try", " ii", "n", "io", "j", "next", "ind", "ims", "key", "iter", "uri", "m", "qi", "ix", "batch", "x", "multi", "ami", "k", "ri", "phi", "di", "zi", "mi", "ii", "is", "l", " ti", "bi", "xi", "im", "f", "iri", "it", "client", "pi", "me", "gi", "hi", "ti", "e", "u", "index", "cli"], "len": ["wid", "von", "length", "ld", "cmp", "Length", "gen", "err", "ll", "L", "ln", "mult", "nl", "mem", "ul", "fin", "gz", "fl", "seq", "n", "lf", "count", "el", "Len", "fn", "compl", "lon", "pos", "enc", "pl", "li", "vec", "cod", "l", "size", "nt", "lan", "dl", "fun", "loc", "lim", "num", "coll", "val", "en", "il", "lp", "kl", "elt", "ls", "conv"], "stat": ["it", " Stat", "kan", "dir", "STAT", "fw", "conn", "status", "def", "disk", "pr", "fin", "sync", "get", "db", "ctl", "p", "Stat", "fn", "cache", " STAT", "util", "node", "set", "et", "print", "file", "scan", "l", "attr", "info", " fi", "load", " stats", "stats", "fd", "num", "check", "Stats", "gc", "un", "fat", "h", "str"], "fse": ["vSE", "bfene", "ppe", "fwse", "Fte", "cfSE", "cfse", "cfene", "jse", "fwpe", "fsle", "bse", "bSE", " fpse", "Fse", "bte", "firesche", "fsene", "fwese", " fSE", "fsem", "jte", "Fsle", "fspe", "vpe", "fireese", "flowse", "bve", "bfse", "cfese", "fwSE", "vpse", "bfpe", "fpe", "vte", "fpse", "bfese", "flowsem", "fwte", "cfpe", "Fsem", "fwsche", " fsche", "pse", "flowpe", "flowte", "psem", "vse", "fsese", "pte", "jve", "fve", "fsche", "jsle", "fte", " fese", "cfpse", "fese", "bpe", "firese", "fSE", "fsse", "bsle", "Fve", "Fpe", "fene"], "path": ["ath", "f", "context", "ep", "patch", "full", "out", "dir", "ref", "temp", "host", "__", "d", "w", "c", "ring", "ATH", "id", "output", "core", "ex", "dev", "target", "r", "cmd", "ext", "cp", "p", "route", "prefix", "dest", "root", "transform", "policy", "np", "tag", "PATH", "th", "doc", "file", "template", "txt", "wp", "key", "sp", "pod", "self", "pkg", "P", "h", "t", "pattern", "m", "point", "name", "pt", "Path"]}}
{"project": "FFmpeg", "commit_id": "ad5807f8aa883bee5431186dc1f24c5435d722d3", "target": 1, "func": "static int wsd_read_header(AVFormatContext *s)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    int version;\n\n    uint32_t text_offset, data_offset, channel_assign;\n\n    char playback_time[AV_TIMECODE_STR_SIZE];\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avio_skip(pb, 8);\n\n    version = avio_r8(pb);\n\n    av_log(s, AV_LOG_DEBUG, \"version: %i.%i\\n\", version >> 4, version & 0xF);\n\n    avio_skip(pb, 11);\n\n\n\n    if (version < 0x10) {\n\n        text_offset = 0x80;\n\n        data_offset = 0x800;\n\n        avio_skip(pb, 8);\n\n    } else {\n\n        text_offset = avio_rb32(pb);\n\n        data_offset = avio_rb32(pb);\n\n    }\n\n\n\n    avio_skip(pb, 4);\n\n    av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);\n\n    av_dict_set(&s->metadata, \"playback_time\", playback_time, 0);\n\n\n\n    st->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    st->codecpar->codec_id    = s->iformat->raw_codec_id;\n\n    st->codecpar->sample_rate = avio_rb32(pb) / 8;\n\n    avio_skip(pb, 4);\n\n    st->codecpar->channels    = avio_r8(pb) & 0xF;\n\n    st->codecpar->bit_rate    = st->codecpar->channels * st->codecpar->sample_rate * 8LL;\n\n    if (!st->codecpar->channels)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    avio_skip(pb, 3);\n\n    channel_assign         = avio_rb32(pb);\n\n    if (!(channel_assign & 1)) {\n\n        int i;\n\n        for (i = 1; i < 32; i++)\n\n            if (channel_assign & (1 << i))\n\n                st->codecpar->channel_layout |= wsd_to_av_channel_layoyt(s, i);\n\n    }\n\n\n\n    avio_skip(pb, 16);\n\n    if (avio_rb32(pb))\n\n       avpriv_request_sample(s, \"emphasis\");\n\n\n\n    if (avio_seek(pb, text_offset, SEEK_SET) >= 0) {\n\n        get_metadata(s, \"title\",       128);\n\n        get_metadata(s, \"composer\",    128);\n\n        get_metadata(s, \"song_writer\", 128);\n\n        get_metadata(s, \"artist\",      128);\n\n        get_metadata(s, \"album\",       128);\n\n        get_metadata(s, \"genre\",        32);\n\n        get_metadata(s, \"date\",         32);\n\n        get_metadata(s, \"location\",     32);\n\n        get_metadata(s, \"comment\",     512);\n\n        get_metadata(s, \"user\",        512);\n\n    }\n\n\n\n    return avio_seek(pb, data_offset, SEEK_SET);\n\n}\n", "idx": 24283, "substitutes": {"s": ["f", "sys", "sn", "sb", "ins", "os", "fs", "rs", "c", "ses", "ds", "hs", "scl", "g", "n", "p", "sc", "cs", "sts", "services", "aws", "S", "js", "bs", "ss", "a", "ats", "b", "ts", "ns", "ps", "src", "stats", "qs", "es", "its", "gs", "sp", "sv", "sg", "pkg", "h", "ls", "t", "stat", "m", "v", "sq"], "pb": ["vm", "bb", "fb", "pm", "sb", "typ", "peer", "atum", "emb", "prototype", "uf", "mp", "pc", "nb", "vp", "tk", "stab", "bank", "pp", "cpp", "tc", "jpg", "um", "pool", "cp", "p", "pg", "tab", "resp", "cb", "cm", "buf", "gp", "ctx", "span", "PB", "amp", "pl", "np", "td", "erb", "tg", "b", "ts", "dp", "py", "wb", "pa", "wp", "txt", "bj", "BP", "bh", "snap", "px", "bot", "pro", "tp", "bp", "sp", "rb", "fp", "gc", "pkg", "lp", "ib", "jp", "uv", "proc", "conv", "cv", "pt"], "st": ["ost", "sn", "stand", "sb", "rest", "store", "nd", "sta", "sty", "se", "std", "d", "stab", "sat", "ste", "tt", "cont", "irst", "sl", "St", "inst", "n", "p", "sc", "sh", "sts", "ut", "sw", "set", "usr", "ust", "et", "stage", "art", "td", "stan", "th", "ast", "ss", "stop", "put", "ct", "ts", "nt", "start", "sm", "must", "ST", "stable", "interface", "step", "bt", "ft", "sp", "sth", "mt", "sv", "est", "ist", "h", "t", "tmp", "stat", "str", "pt"], "version": ["f", "class", "type", "length", "major", "product", "match", "currently", "server", "latest", "chip", "flash", "conv", "power", "hash", "versions", "feature", "status", "component", "value", "VERSION", "binding", "result", "command", "spec", "ver", "mode", "fish", "ception", "go", "message", "sequence", "vers", "depth", "release", "tag", "section", "python", "size", "ersion", "volume", "scale", "vision", "step", "json", "position", "serial", "current", "time", "package", "channel", "number", "usage", "Version", "about", "format", "index", "v", "final", "VER"], "text_offset": ["text_index", "text___offset", "textipoffset", "text___tile", "text_tile", "text_Offset", "textiptile", " text_size", " text_tile", "textptprefix", " text_index", "textPoffset", " text_skip", "text_size", "textPsize", "textipOffset", "textPskip", "textptOffset", "textPtile", "text___skip", " text_Offset", "textipindex", " text_prefix", "text___size", "text_prefix", "text___Offset", "text_skip", "textpttile", "textptoffset", "text___index"], "data_offset": ["data_size", "data_position", "data___address", " data_shift", " data_Offset", "data_Offset", "video___address", "video_address", "data__off", "data_seek", "data_shift", "data___position", "data___size", "data__Offset", " data_position", "video_offset", "data_off", "data__address", "data___off", "data_address", " data_seek", "video___offset", "data__offset", "video___off", "video___Offset", "video_Offset", " data_size", "video_off", "data___offset", "data___Offset"], "channel_assign": ["channel_assition", "channel_ordect", "channel_ordition", "channel_attIGN", "channel_assigned", "channel_seignment", "channel_passoc", "channel___balect", "channel_balign", "channel_assignment", "channel_assay", "channel_Assignment", "channel_attignment", "channel_ignoc", "channel_seigned", "channel_Assign", "channel_ignign", "channel___balition", "channel_baligned", "channel___baligned", "channel_balition", "channel_affition", "channel_attoc", "channel_attign", "channel_balect", "channel_assoc", "channel_alIGN", "channel_passay", "channel_Assigned", "channel___assign", "channel_attay", "channel_attigned", "channel___assect", "channel_affign", "channel_ordign", "channel_aligned", "channel_alignment", "channel_affect", "channel_passignment", "channel_ignignment", "channel_seIGN", "channel_passign", "channel___assigned", "channel_seign", "channel___assition", "channel_assect", "channel___balign", "channel_affigned", "channel_ignay", "channel_ordigned", "channel_assIGN", "channel_align"], "playback_time": ["playbacks_Time", "playBack_Time", "playBack_time", "playbacks_info", "playBack_times", "playback_times", "playback_string", "playbo_times", "playbo_time", "playback_Time", "playbo_string", "playback_info", "playbacks_time"], "i": ["it", "ic", "x", "length", "ui", " j", "multi", "\u0438", "pi", "c", " ii", "index", "ex", "k", "PI", "gu", "in", "me", "gi", "I", "n", "p", "phi", "di", "zi", "sim", "j", "ai", "mi", "li", "ii", "hi", "is", "ti", "ind", "init", "l", "bi", "ip", "y", "ims", "ci", "iter", "u", "iu", " I", "xi", "si", "t", "q", "m", "v", "cli", "qi", "ix"]}}
{"project": "FFmpeg", "commit_id": "16c6795465fd7663792fe535256c760560714863", "target": 0, "func": "x11grab_read_header(AVFormatContext *s1)\n\n{\n\n    struct x11grab *x11grab = s1->priv_data;\n\n    Display *dpy;\n\n    AVStream *st = NULL;\n\n    enum AVPixelFormat input_pixfmt;\n\n    XImage *image;\n\n    int x_off = 0;\n\n    int y_off = 0;\n\n    int screen;\n\n    int use_shm;\n\n    char *dpyname, *offset;\n\n    int ret = 0;\n\n    Colormap color_map;\n\n    XColor color[256];\n\n    int i;\n\n\n\n    dpyname = av_strdup(s1->filename);\n\n    if (!dpyname)\n\n        goto out;\n\n\n\n    offset = strchr(dpyname, '+');\n\n    if (offset) {\n\n        sscanf(offset, \"%d,%d\", &x_off, &y_off);\n\n        if (strstr(offset, \"nomouse\")) {\n\n            av_log(s1, AV_LOG_WARNING,\n\n                   \"'nomouse' specification in argument is deprecated: \"\n\n                   \"use 'draw_mouse' option with value 0 instead\\n\");\n\n            x11grab->draw_mouse = 0;\n\n        }\n\n        *offset= 0;\n\n    }\n\n\n\n    av_log(s1, AV_LOG_INFO, \"device: %s -> display: %s x: %d y: %d width: %d height: %d\\n\",\n\n           s1->filename, dpyname, x_off, y_off, x11grab->width, x11grab->height);\n\n\n\n    dpy = XOpenDisplay(dpyname);\n\n    av_freep(&dpyname);\n\n    if(!dpy) {\n\n        av_log(s1, AV_LOG_ERROR, \"Could not open X display.\\n\");\n\n        ret = AVERROR(EIO);\n\n        goto out;\n\n    }\n\n\n\n    st = avformat_new_stream(s1, NULL);\n\n    if (!st) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto out;\n\n    }\n\n    avpriv_set_pts_info(st, 64, 1, 1000000); /* 64 bits pts in us */\n\n\n\n    screen = DefaultScreen(dpy);\n\n\n\n    if (x11grab->follow_mouse) {\n\n        int screen_w, screen_h;\n\n        Window w;\n\n\n\n        screen_w = DisplayWidth(dpy, screen);\n\n        screen_h = DisplayHeight(dpy, screen);\n\n        XQueryPointer(dpy, RootWindow(dpy, screen), &w, &w, &x_off, &y_off, &ret, &ret, &ret);\n\n        x_off -= x11grab->width / 2;\n\n        y_off -= x11grab->height / 2;\n\n        x_off = FFMIN(FFMAX(x_off, 0), screen_w - x11grab->width);\n\n        y_off = FFMIN(FFMAX(y_off, 0), screen_h - x11grab->height);\n\n        av_log(s1, AV_LOG_INFO, \"followmouse is enabled, resetting grabbing region to x: %d y: %d\\n\", x_off, y_off);\n\n    }\n\n\n\n    use_shm = XShmQueryExtension(dpy);\n\n    av_log(s1, AV_LOG_INFO, \"shared memory extension%s found\\n\", use_shm ? \"\" : \" not\");\n\n\n\n    if(use_shm) {\n\n        int scr = XDefaultScreen(dpy);\n\n        image = XShmCreateImage(dpy,\n\n                                DefaultVisual(dpy, scr),\n\n                                DefaultDepth(dpy, scr),\n\n                                ZPixmap,\n\n                                NULL,\n\n                                &x11grab->shminfo,\n\n                                x11grab->width, x11grab->height);\n\n        x11grab->shminfo.shmid = shmget(IPC_PRIVATE,\n\n                                        image->bytes_per_line * image->height,\n\n                                        IPC_CREAT|0777);\n\n        if (x11grab->shminfo.shmid == -1) {\n\n            av_log(s1, AV_LOG_ERROR, \"Fatal: Can't get shared memory!\\n\");\n\n            ret = AVERROR(ENOMEM);\n\n            goto out;\n\n        }\n\n        x11grab->shminfo.shmaddr = image->data = shmat(x11grab->shminfo.shmid, 0, 0);\n\n        x11grab->shminfo.readOnly = False;\n\n\n\n        if (!XShmAttach(dpy, &x11grab->shminfo)) {\n\n            av_log(s1, AV_LOG_ERROR, \"Fatal: Failed to attach shared memory!\\n\");\n\n            /* needs some better error subroutine :) */\n\n            ret = AVERROR(EIO);\n\n            goto out;\n\n        }\n\n    } else {\n\n        image = XGetImage(dpy, RootWindow(dpy, screen),\n\n                          x_off,y_off,\n\n                          x11grab->width, x11grab->height,\n\n                          AllPlanes, ZPixmap);\n\n    }\n\n\n\n    switch (image->bits_per_pixel) {\n\n    case 8:\n\n        av_log (s1, AV_LOG_DEBUG, \"8 bit palette\\n\");\n\n        input_pixfmt = AV_PIX_FMT_PAL8;\n\n        color_map = DefaultColormap(dpy, screen);\n\n        for (i = 0; i < 256; ++i)\n\n            color[i].pixel = i;\n\n        XQueryColors(dpy, color_map, color, 256);\n\n        for (i = 0; i < 256; ++i)\n\n            x11grab->palette[i] = (color[i].red   & 0xFF00) << 8 |\n\n                                  (color[i].green & 0xFF00)      |\n\n                                  (color[i].blue  & 0xFF00) >> 8;\n\n        x11grab->palette_changed = 1;\n\n        break;\n\n    case 16:\n\n        if (       image->red_mask   == 0xf800 &&\n\n                   image->green_mask == 0x07e0 &&\n\n                   image->blue_mask  == 0x001f ) {\n\n            av_log (s1, AV_LOG_DEBUG, \"16 bit RGB565\\n\");\n\n            input_pixfmt = AV_PIX_FMT_RGB565;\n\n        } else if (image->red_mask   == 0x7c00 &&\n\n                   image->green_mask == 0x03e0 &&\n\n                   image->blue_mask  == 0x001f ) {\n\n            av_log(s1, AV_LOG_DEBUG, \"16 bit RGB555\\n\");\n\n            input_pixfmt = AV_PIX_FMT_RGB555;\n\n        } else {\n\n            av_log(s1, AV_LOG_ERROR, \"RGB ordering at image depth %i not supported ... aborting\\n\", image->bits_per_pixel);\n\n            av_log(s1, AV_LOG_ERROR, \"color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\\n\", image->red_mask, image->green_mask, image->blue_mask);\n\n            ret = AVERROR_PATCHWELCOME;\n\n            goto out;\n\n        }\n\n        break;\n\n    case 24:\n\n        if (        image->red_mask   == 0xff0000 &&\n\n                    image->green_mask == 0x00ff00 &&\n\n                    image->blue_mask  == 0x0000ff ) {\n\n            input_pixfmt = AV_PIX_FMT_BGR24;\n\n        } else if ( image->red_mask   == 0x0000ff &&\n\n                    image->green_mask == 0x00ff00 &&\n\n                    image->blue_mask  == 0xff0000 ) {\n\n            input_pixfmt = AV_PIX_FMT_RGB24;\n\n        } else {\n\n            av_log(s1, AV_LOG_ERROR,\"rgb ordering at image depth %i not supported ... aborting\\n\", image->bits_per_pixel);\n\n            av_log(s1, AV_LOG_ERROR, \"color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\\n\", image->red_mask, image->green_mask, image->blue_mask);\n\n            ret = AVERROR_PATCHWELCOME;\n\n            goto out;\n\n        }\n\n        break;\n\n    case 32:\n\n        input_pixfmt = AV_PIX_FMT_0RGB32;\n\n        break;\n\n    default:\n\n        av_log(s1, AV_LOG_ERROR, \"image depth %i not supported ... aborting\\n\", image->bits_per_pixel);\n\n        ret = AVERROR_PATCHWELCOME;\n\n        goto out;\n\n    }\n\n\n\n    x11grab->frame_size = x11grab->width * x11grab->height * image->bits_per_pixel/8;\n\n    x11grab->dpy = dpy;\n\n    x11grab->time_base  = av_inv_q(x11grab->framerate);\n\n    x11grab->time_frame = av_gettime() / av_q2d(x11grab->time_base);\n\n    x11grab->x_off = x_off;\n\n    x11grab->y_off = y_off;\n\n    x11grab->image = image;\n\n    x11grab->use_shm = use_shm;\n\n\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->width  = x11grab->width;\n\n    st->codec->height = x11grab->height;\n\n    st->codec->pix_fmt = input_pixfmt;\n\n    st->codec->time_base = x11grab->time_base;\n\n    st->codec->bit_rate = x11grab->frame_size * 1/av_q2d(x11grab->time_base) * 8;\n\n\n\nout:\n\n    av_free(dpyname);\n\n    return ret;\n\n}\n", "idx": 24289, "substitutes": {"x11grab": ["ey11call", "x6gc", "xonedGrab", "x11client", "X11grab", "x86grab", "x11config", "xx14cap", "ey511cap", "ax11rab", "ax11grab", "x11job", "x_grab", "x14crop", "axonedgrab", "xonedrab", "x511grab", "x3config", " x11client", "x1111gc", "x18pop", "x86stat", "x1111progress", "x211cache", "x1080stat", "x1job", "xonyab", "ey511crop", "X11call", "x112crop", "xonyjob", "axonedconfig", "ox18rab", "x211pop", "x18grab", "x1080client", "xx14crop", "ax18gc", "ox11rab", "x11progress", "x11ab", "ey11grab", "x1rab", "x3Grab", "x18gc", "ox11job", "x14progress", "ey11cap", "xx14grab", "X11progress", "x51pop", "x511cap", "x3stat", "xonedgrab", "x118crop", "x1grab", "ey511grab", "xx11grab", "x_config", "x11cache", " x3port", " x3client", "x18cache", " x3stat", "ax11Grab", "x11pop", "xonedconfig", "axonedGrab", "xx11crop", "x6grab", " x3grab", "ox18ab", "x14cap", "x_rab", "x1111call", "x3port", "ox18job", "x11call", "x3client", "x3grab", "x11gc", "ax11config", "X11gc", "x118grab", "ey511call", "x11rab", "ax18grab", "x1080port", "ox11ab", "ax11cache", "x86port", "x1111grab", " x11port", "x18ab", "xx11cap", "x51gc", "x11crop", "x112progress", "ax11pop", "x86client", "xonyrab", "ax11gc", "x1080grab", "x14grab", "x51cache", "x211gc", "x1ab", "x18rab", "x11Grab", "x118cap", "x11port", "x_Grab", "ox18grab", "x511call", "x118call", "xonygrab", "xx14progress", "x6progress", "ox11grab", "x3rab", "ax18pop", "xx11progress", "ey11crop", "x51grab", "ax18cache", "x11stat", "x112grab", "x511crop", "x211grab", "x11cap", "axonedrab", "x18job", " x11stat", "x6call", "x112cap"], "dpy": ["dxpy", "dpm", "dsxy", " dumpy", "adtry", "ymit", "dspm", "dxy", "dlpy", "gumpy", "domit", "dpc", " dpe", " dply", "dnpm", "dxpc", "sdtry", " dpu", "dply", " dPy", "dopy", "npy", "dphy", "sdpy", " dphy", "tdpy", "dipm", "dtry", "dpo", "diply", "dxpm", " dtry", "dompy", "sdmy", "dsply", "adphy", "dumpy", "edpo", "gtry", "dotry", "dpty", "dltry", "dixy", "ypm", "gphy", "sdpe", "edpy", "dpu", " dpty", "tdpty", " dpc", "edply", "domtry", "dompm", "adpy", "mainpu", "dpe", "ntry", "dommy", "dnpc", "dPy", "tdpe", "npo", "dnxy", "mainpy", " dmit", "tdPy", "dspy", "gpy", "adumpy", " dpo", "dipy", " dmy", "sdPy", "ypy", "ytry", "sdpty", "sdpm", "dmy", "edtry", "dxxy", "maintry", " dxy", "dlpu", "dlbase", "dmit", "nply", "dbase", " dbase", "dopm", "dnpy", " dpm", "mainbase"], "st": ["stack", "sn", "ost", "it", "rest", "store", "nd", "sty", "se", "std", "d", "fr", "ste", "tt", "cont", "irst", "sl", "St", "r", "inst", "sc", "sh", "sts", "ut", "sw", "set", "dist", "ust", "stage", "art", "ast", "so", "rt", "stop", "ct", "start", "nt", "dr", "ST", "stable", "sp", "sv", "est", "ist", "t", "tmp", "stat", "end", " ST", "str", "pt"], "input_pixfmt": ["input_pixelsfgt", "input_pixfMT", "input_pixfbmt", "input_pixfbsm", "input_pixfcsm", "input_pixelsfMT", "input_pixelsfmt", "input_pixfsm", "input_pixfcMT", "input_pixfcgt", "input_pixfcmt", "input_pixfbMT", "input_pixfgt", "input_pixfbgt", "input_pixelsfsm"], "image": ["f", "photo", "media", "o", "icon", "xml", "map", "gif", "video", "io", "img", "Image", "view", "input", "frame", "file", "ime", "mage", "png", "document", "figure", "source", "im", "m", "sample", "crop", "picture"], "screen": ["sys", "desktop", "tree", "space", "server", "store", "network", "score", "white", "host", "widget", "creen", "display", "grid", "connect", "buffer", "focus", "secure", "path", "password", "console", "pen", "sc", "remote", "sh", "disc", "root", "set", "go", "isc", "view", "stage", "sec", "clear", "Screen", "process", "chain", "script", "scan", "size", "scale", "page", "query", "window", "seek", "snap", "draw", "sp", "win", "scroll", "scope", "gc", "scene", "ram", "SC", "proc", "crop", "hw"], "use_shm": ["use_thm", "use_khM", "use_Shm", "usexShM", "use_thM", "usexShm", "use_ShM", "use_khc", "usexshM", "use_thmt", "use_khmt", "use_shc", "usexshc", "usexshm", "usexshmt", "usexShc", "use_thc", "use_Shc", "use_khm", "use_shmt", "usexShmt", "use_Shmt", "use_shM"], "dpyname": ["dpydamer", "pdyame", "ddnAME", "dpnename", "tpynamed", "DPynname", "dpyoamer", "dpwnamed", "tpwnename", "dprenamer", "dpnome", "pdnamy", "dpwnename", "ddynAME", "dpylonomial", "tpwname", "dpynamed", "dprenename", "dpgnamer", "dpydAME", "dpyrAME", "pdyename", "DPynamed", "dpylename", "ddname", "ddyname", "DPyname", "dprenam", "dpylamer", "dpynamy", "dpynAME", "dpyoaming", "tpynename", "DPgnamed", "dpname", "cpYNamer", "pdynamer", "vpynename", "dpagname", "dpynaming", "DPynaming", "DPgname", "dpwnAME", "cpynami", "dpyename", "ddnename", "DPgnname", "vpylame", "dpgnname", "vpylename", "dpyome", "dpagnaming", "vpyname", "pdnaming", "cpyname", "dpydename", "dpyraming", "vpylamer", "dpyaname", "dpYName", "ddnamer", "dpnamy", "dpgnaming", "tpynAME", "dpyoamy", "dpymam", "dpydame", "pdynaming", "dpyramed", "pdynamy", "cpynamer", "tpwnAME", "dpyanaming", "ddynename", "dpynome", "dpynename", "dpyomial", "dpynamer", "dpynami", "pdynomial", "dpylam", "dpyrname", "dpgnAME", "vpylam", "tpwnamed", "dpgname", "dpYNami", "cpynam", "cpYNam", "pdyome", "dpynam", "dpyame", "dpnaming", "dpyrename", "dpynomial", "pdyomial", "cpYNami", "pdnamer", "dpYNam", "pdyname", "dpyoame", "DPgnaming", "dpymami", "dpgnename", "tpyname", "dpymame", "dpYNamer", "dpylonome", "dpylonamer", "pdynome", "dpagnamy", "vpynamer", "dpyanname", "dpnAME", "cpYName", "dpagnamer", "dpyloname", "dpylame", "dpylonam", "dpnamer", "pdynename", "dpyrame", "ddynamer", "dpymamer", "dpynname", "dprename", "dpwname", "dprenami", "dpylonename", "dpyanamed", "pdname", "dpnomial", "dpgnamed", "vpynam"], "offset": ["range", "padding", "type", "attribute", "alt", "name", "ret", "o", "reset", "reference", "address", "ref", "map", "output", "error", "zero", "buffer", "command", "row", "alias", "pointer", "prefix", "initial", "set", "order", "origin", "et", "pos", "frame", "tile", "layout", "associated", "line", "data", "location", "size", "info", "shift", "start", "key", "addr", "url", "seek", "position", "optional", "meta", "sp", "style", "scroll", "slot", "off", "iso", "source", "timeout", "rot", "encrypted", "index", "point", "ptr", "Offset", "onet", "crop"], "color_map": [" color2map", " color_maps", "color2maps", "color2set", "color_set", "color2map", " color_set", " color2set", " color2maps", "color_maps"], "color": ["context", "type", "match", "field", "gray", "store", "white", "col", "array", "value", "map", "buffer", "colour", "pixel", "COLOR", "filter", "state", "blue", "mask", "number", "table", "background", "stroke"], "i": ["f", "it", "out", "o", "c", "id", "r", "I", "n", "p", "io", "di", "set", "j", "et", "ii", "print", "b", "l", "info", "z", "e", "si", "t", "h", "m", "v"], "screen_w": ["covermingwh", "cover_n", "screen2n", "covermingr", "cover_wh", "cover_r", "screen_r", "screen2r", "covermingn", "cover_w", " screen_width", "screenmingr", "screen_W", " screen_W", "screen2w", "screenmingw", "screenmingwh", "screen2wh", "screen_wh", "screen_n", "screenmingn", "screen_width", " screen_x", "covermingw", "screen_x"], "screen_h": ["screen2ch", "screen_ch", "screen2c", "screen_i", "screen__h", " screen_c", " screen_i", " screen_height", " screen_ch", "screen2w", "screen_c", "screen_height", "screen__i", "screen__w", "screen2h", "screen__height"], "w": ["f", "x", "W", "o", "iw", "d", "widget", "c", "wd", "path", "g", "r", "n", "p", "s", "sw", " W", "nw", "wa", "a", "b", "l", "y", "wb", "wp", "wt", "z", "window", "e", "rw", "win", "kw", "h", "t", "q", "m", "v", "wx", "hw"]}}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 16; i++)\n\n        if (simple_limit(dst+i*stride, 1, flim))\n\n            filter_common(dst+i*stride, 1, 1);\n\n}\n", "idx": 24291, "substitutes": {"dst": ["datend", " dost", "dsrc", "ddsrc", "dnd", "drc", "due", " dsrc", "mnd", "tst", "ddest", " dend", "ddst", "Due", "dost", "Dst", "ddue", "dend", " drc", "datest", "mst", "trc", "Dost", "dest", "datnd", "tost", "Dsrc", "Dest", " due", "test", " dest", " dnd", "mend", "mest", "Drc", "datst"], "stride": ["slope", " struse", "stringick", "STRider", "intick", "intride", "constide", "stringide", "intuse", " strride", "struse", "strider", "STRope", "constider", "intide", "slride", "stringuse", " strime", "STRance", "strride", " strance", "constride", "STRime", "strick", " strick", "strance", "STRride", "constance", "strope", "strime", " strider", " strope", "slime", "slide", "STRide", "stringride"], "flim": [" Flim", "tlam", "tlimit", " Flimit", "sfmin", " Fdep", "fclip", " flam", "flimit", "sflimit", "fcdep", " Fclip", " flimit", " fmin", "sflam", "sflim", "tmin", "fclimit", "fclim", " fclip", "fcclip", "fmin", " fdep", "fdep", "flam", "tlim"], "i": ["ji", "it", "ic", "x", "batch", "ui", "ki", "multi", " multi", "pi", " ni", " ii", "ini", "ex", "index", "id", "yi", "iy", "gu", "in", "me", "gi", "g", "I", "phi", "di", "oi", "zi", "sim", "j", "go", "ai", "span", " err", "mi", "li", "ii", "iq", "asi", "chain", "hi", "is", "ti", "ind", "info", " ti", " pi", "ip", " mi", "ims", "bi", "ci", "z", "ij", "e", "iu", " I", " m", "xi", "im", "t", "si", "m", "v", "cli", "init", "qi", "ei", "ix"]}}
{"project": "qemu", "commit_id": "a77fd4bb2988c05953fdc9f1524085870ec1c939", "target": 1, "func": "void bdrv_drain(BlockDriverState *bs)\n\n{\n\n    bool busy = true;\n\n\n\n    bdrv_drain_recurse(bs);\n\n\n\n\n\n    while (busy) {\n\n        /* Keep iterating */\n\n         bdrv_flush_io_queue(bs);\n\n         busy = bdrv_requests_pending(bs);\n\n         busy |= aio_poll(bdrv_get_aio_context(bs), busy);\n\n", "idx": 24292, "substitutes": {"bs": ["sys", "ms", "sb", "bas", "uses", "bles", "bps", "lbs", "bc", "fs", "rs", "bes", "BS", "ses", "ubs", "ds", "uts", "ks", "aos", "bos", "bis", "hz", "cs", "cks", "sts", "bits", "vs", "iss", "js", "blocks", "ss", "outs", "ats", "ns", "ts", "ps", "ims", "acs", "aus", "qs", "bh", "es", "its", "gs", "obs", "ls"]}}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "static void main_loop(void)\n\n{\n\n    bool nonblocking;\n\n    int last_io __attribute__ ((unused)) = 0;\n\n#ifdef CONFIG_PROFILER\n\n    int64_t ti;\n\n#endif\n\n    int r;\n\n\n\n    qemu_main_loop_start();\n\n\n\n    for (;;) {\n\n#ifdef CONFIG_IOTHREAD\n\n        nonblocking = !kvm_enabled() && last_io > 0;\n\n#else\n\n        nonblocking = cpu_exec_all();\n\n        if (vm_request_pending()) {\n\n            nonblocking = true;\n\n        }\n\n#endif\n\n#ifdef CONFIG_PROFILER\n\n        ti = profile_getclock();\n\n#endif\n\n        last_io = main_loop_wait(nonblocking);\n\n#ifdef CONFIG_PROFILER\n\n        dev_time += profile_getclock() - ti;\n\n#endif\n\n\n\n        if (qemu_debug_requested()) {\n\n            vm_stop(VMSTOP_DEBUG);\n\n        }\n\n        if (qemu_shutdown_requested()) {\n\n            qemu_kill_report();\n\n            monitor_protocol_event(QEVENT_SHUTDOWN, NULL);\n\n            if (no_shutdown) {\n\n                vm_stop(VMSTOP_SHUTDOWN);\n\n            } else\n\n                break;\n\n        }\n\n        if (qemu_reset_requested()) {\n\n            pause_all_vcpus();\n\n            cpu_synchronize_all_states();\n\n            qemu_system_reset(VMRESET_REPORT);\n\n            resume_all_vcpus();\n\n        }\n\n        if (qemu_powerdown_requested()) {\n\n            monitor_protocol_event(QEVENT_POWERDOWN, NULL);\n\n            qemu_irq_raise(qemu_system_powerdown);\n\n        }\n\n        if ((r = qemu_vmstop_requested())) {\n\n            vm_stop(r);\n\n        }\n\n    }\n\n    bdrv_close_all();\n\n    pause_all_vcpus();\n\n}\n", "idx": 24294, "substitutes": {"nonblocking": ["Nonblock", "notblock", "noneloading", "nolocking", "notblocking", "nonblock", "Nonloading", "southblock", " nonlocking", "nonblocks", "Nonlocking", "southblocking", " nonocking", "nonelocking", "noocking", "noblock", "Nonocking", " nonblock", "noneblocking", "nonlocking", "southlocking", "noblocking", "notocking", "notloading", "nonocking", "southblocks", "Nonblocking", "noneblock", "nonloading", "notblocks", "notlocking", "noblocks"], "last_io": [" last_no", " last_iol", "last_iol", " last_i", "last_i", "lasttimeio", "last___io", " last_boot", "last___ios", " last_ios", "last___iol", "lasttimeno", "last_ios", "last_connection", "last_boot", "lasttimeios", "last_no", "last___connection", "lasttimei", " last_connection"], "ti": ["iat", "isi", "i", "ui", "tm", "TI", "tu", "iw", "tk", "tv", "pi", "yi", "lt", "ri", "fi", "gi", "phi", "io", "aki", "di", "zi", "ai", "te", "tim", "mi", "ii", "ta", "li", "Ti", "uci", "hi", "ita", "tie", "bi", "ati", "txt", "ci", "tw", "tp", "ni", "vi", "si", "t", "iti"], "r": ["run", "it", "i", "out", " intr", "err", "lr", "rm", "re", "br", "ru", "d", "rs", "w", "nr", "rd", "c", "hr", "rc", "result", "ry", "er", "rr", "or", "g", "sr", "n", "p", "ar", "res", "ra", " err", "up", "rt", "b", "l", "rin", "dr", "R", "cr", "mr", "e", "rb", "rw", "ptr", "h", "t", "q", "rg", "m", "v", " R"]}}
{"project": "qemu", "commit_id": "0928a95ffe91862938cee997c9e30602fa7884ab", "target": 0, "func": "static void bootp_reply(const struct bootp_t *bp)\n\n{\n\n    BOOTPClient *bc = NULL;\n\n    struct mbuf *m;\n\n    struct bootp_t *rbp;\n\n    struct sockaddr_in saddr, daddr;\n\n    struct in_addr dns_addr;\n\n    const struct in_addr *preq_addr;\n\n    int dhcp_msg_type, val;\n\n    uint8_t *q;\n\n\n\n    /* extract exact DHCP msg type */\n\n    dhcp_decode(bp, &dhcp_msg_type, &preq_addr);\n\n    dprintf(\"bootp packet op=%d msgtype=%d\", bp->bp_op, dhcp_msg_type);\n\n    if (preq_addr)\n\n        dprintf(\" req_addr=%08x\\n\", ntohl(preq_addr->s_addr));\n\n    else\n\n        dprintf(\"\\n\");\n\n\n\n    if (dhcp_msg_type == 0)\n\n        dhcp_msg_type = DHCPREQUEST; /* Force reply for old BOOTP clients */\n\n\n\n    if (dhcp_msg_type != DHCPDISCOVER &&\n\n        dhcp_msg_type != DHCPREQUEST)\n\n        return;\n\n    /* XXX: this is a hack to get the client mac address */\n\n    memcpy(client_ethaddr, bp->bp_hwaddr, 6);\n\n\n\n    if ((m = m_get()) == NULL)\n\n        return;\n\n    m->m_data += IF_MAXLINKHDR;\n\n    rbp = (struct bootp_t *)m->m_data;\n\n    m->m_data += sizeof(struct udpiphdr);\n\n    memset(rbp, 0, sizeof(struct bootp_t));\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n        if (preq_addr) {\n\n            bc = request_addr(preq_addr, client_ethaddr);\n\n            if (bc) {\n\n                daddr.sin_addr = *preq_addr;\n\n            }\n\n        }\n\n        if (!bc) {\n\n         new_addr:\n\n            bc = get_new_addr(&daddr.sin_addr);\n\n            if (!bc) {\n\n                dprintf(\"no address left\\n\");\n\n                return;\n\n            }\n\n        }\n\n        memcpy(bc->macaddr, client_ethaddr, 6);\n\n    } else if (preq_addr) {\n\n        bc = request_addr(preq_addr, client_ethaddr);\n\n        if (bc) {\n\n            daddr.sin_addr = *preq_addr;\n\n            memcpy(bc->macaddr, client_ethaddr, 6);\n\n        } else {\n\n            daddr.sin_addr.s_addr = 0;\n\n        }\n\n    } else {\n\n        bc = find_addr(&daddr.sin_addr, bp->bp_hwaddr);\n\n        if (!bc) {\n\n            /* if never assigned, behaves as if it was already\n\n               assigned (windows fix because it remembers its address) */\n\n            goto new_addr;\n\n        }\n\n    }\n\n\n\n    saddr.sin_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_ALIAS);\n\n    saddr.sin_port = htons(BOOTP_SERVER);\n\n\n\n    daddr.sin_port = htons(BOOTP_CLIENT);\n\n\n\n    rbp->bp_op = BOOTP_REPLY;\n\n    rbp->bp_xid = bp->bp_xid;\n\n    rbp->bp_htype = 1;\n\n    rbp->bp_hlen = 6;\n\n    memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, 6);\n\n\n\n    rbp->bp_yiaddr = daddr.sin_addr; /* Client IP address */\n\n    rbp->bp_siaddr = saddr.sin_addr; /* Server IP address */\n\n\n\n    q = rbp->bp_vend;\n\n    memcpy(q, rfc1533_cookie, 4);\n\n    q += 4;\n\n\n\n    if (bc) {\n\n        dprintf(\"%s addr=%08x\\n\",\n\n                (dhcp_msg_type == DHCPDISCOVER) ? \"offered\" : \"ack'ed\",\n\n                ntohl(daddr.sin_addr.s_addr));\n\n\n\n        if (dhcp_msg_type == DHCPDISCOVER) {\n\n            *q++ = RFC2132_MSG_TYPE;\n\n            *q++ = 1;\n\n            *q++ = DHCPOFFER;\n\n        } else /* DHCPREQUEST */ {\n\n            *q++ = RFC2132_MSG_TYPE;\n\n            *q++ = 1;\n\n            *q++ = DHCPACK;\n\n        }\n\n\n\n        if (bootp_filename)\n\n            snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), \"%s\",\n\n                     bootp_filename);\n\n\n\n        *q++ = RFC2132_SRV_ID;\n\n        *q++ = 4;\n\n        memcpy(q, &saddr.sin_addr, 4);\n\n        q += 4;\n\n\n\n        *q++ = RFC1533_NETMASK;\n\n        *q++ = 4;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0x00;\n\n\n\n        if (!slirp_restrict) {\n\n            *q++ = RFC1533_GATEWAY;\n\n            *q++ = 4;\n\n            memcpy(q, &saddr.sin_addr, 4);\n\n            q += 4;\n\n\n\n            *q++ = RFC1533_DNS;\n\n            *q++ = 4;\n\n            dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n\n            memcpy(q, &dns_addr, 4);\n\n            q += 4;\n\n        }\n\n\n\n        *q++ = RFC2132_LEASE_TIME;\n\n        *q++ = 4;\n\n        val = htonl(LEASE_TIME);\n\n        memcpy(q, &val, 4);\n\n        q += 4;\n\n\n\n        if (*slirp_hostname) {\n\n            val = strlen(slirp_hostname);\n\n            *q++ = RFC1533_HOSTNAME;\n\n            *q++ = val;\n\n            memcpy(q, slirp_hostname, val);\n\n            q += val;\n\n        }\n\n    } else {\n\n        static const char nak_msg[] = \"requested address not available\";\n\n\n\n        dprintf(\"nak'ed addr=%08x\\n\", ntohl(preq_addr->s_addr));\n\n\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPNAK;\n\n\n\n        *q++ = RFC2132_MESSAGE;\n\n        *q++ = sizeof(nak_msg) - 1;\n\n        memcpy(q, nak_msg, sizeof(nak_msg) - 1);\n\n        q += sizeof(nak_msg) - 1;\n\n    }\n\n    *q++ = RFC1533_END;\n\n\n\n    daddr.sin_addr.s_addr = 0xffffffffu;\n\n\n\n    m->m_len = sizeof(struct bootp_t) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n    udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n}\n", "idx": 24311, "substitutes": {"bp": ["pd", "bb", "batch", "sb", "pb", "br", "bps", "pc", "nb", "vp", "pp", "bf", "phy", "bsp", "bm", "hp", "cp", "p", "cb", "gp", "ctx", "kb", "np", "bs", "bg", "b", "ps", "bi", "bj", "wp", "BP", "bh", "bt", "tp", "sp", "rb", "fp", "lp", "jp", "lb"], "bc": ["bb", "ic", "uc", "BC", "pb", "cf", "ca", "bridge", "ll", "bl", "comm", "pc", "bo", "c", "tc", "arb", "abc", "dc", "bf", "rc", "bm", "abl", "ck", "ec", "sync", "console", "func", "db", "clus", "bec", "soc", "nc", "bitcoin", "sc", "arc", "cb", "cm", "proc", "gov", "sec", "bs", "bg", "eb", "b", "xc", "vc", "unc", "bi", "anc", "ba", "bd", "mc", "butt", "bt", "fc", "circ", "exec", "gc", "cc", "loop", "ml", "lc", "mu", "scribed", "broad"], "m": ["vm", "f", "pm", "ms", "i", "perm", "tm", "o", "rm", "ma", "mb", "mp", "d", "c", "mem", "mm", "bm", "hm", "g", "md", "r", "me", "p", "mail", "M", "mat", "dm", "msg", "mo", "cm", "mod", "j", "module", "mi", "gm", "am", "b", "mr", "sm", "mn", "mc", "managed", "mt", "h", "t", "v", "em", "mu"], "rbp": ["rwp", "umbpa", "rbps", "rbd", "obbp", "vrpm", "erbps", "obbpm", "rbpm", "umbd", "robpa", "rwps", "rbpa", "erbP", " RBpre", " RBv", "umbp", "robd", " RBpm", "rwP", "erbpa", " RBp", "obbv", "robps", "erbd", "robp", "rwpc", "rbP", "rbpre", "obbpre", "rbv", "erbpc", "vrp", "vrpre", "rbpc", "robpc", "umbP", "robP", "erbp", "vrv"], "saddr": [" saddress", "sysha", "sadd", "sha", "sysaddr", "sysadd", "sysaddress", " sadd", "nsha", "nsaddr", "nsaddress", "nsadd", "saddress", " sha"], "daddr": ["daddress", " dadd", "dcdist", " ddist", "madd", "Dptr", "dattr", "Ddist", "maddr", "Dadd", "dnaddr", " daddress", "ddadd", "dnadd", "sdaddr", "mattr", "sdadd", "dnptr", "sdaddress", "dcadd", "durl", " dptr", "dcptr", "dptr", " durl", "dnattr", " dattr", "sdurl", "ddist", "dcaddr", "Daddress", "Durl", "mptr", "ddaddress", "ddaddr", "dadd", "Daddr", "ddurl"], "dns_addr": ["dns_address", "dns_url", "dNS_addr", "dnsgaddr", "dnsgaddress", "dnsgname", "dnsqname", "dnsqaddr", "dNS_url", "dnsqurl", "dnsqaddress", "dns_name", "dNS_name", "dnsgurl", "dNS_address"], "preq_addr": ["preq___cmd", "prek___cmd", "prek_cmd", "prekg_adr", "preqxloc", "prek___conn", "preq_conn", "preqt__attr", "prek_addr", "preqt_ad", "preqxmsg", "prekg_ord", "preq_loc", "preq_msg", "prech_address", "preqt__ad", "prequ_req", "preq_ad", "prequ_add", "preq_address", "preq___addr", "prequ_order", "preq_order", "preqt_addr", "preqt_attr", "prech_addr", "preqt_ord", "preq_cmd", "prek_ref", "prev_loc", "preq_ord", "prequest_address", "prek___addr", "prequ_host", "preqipaddr", "preq_data", "preq_attr", "preq___ord", "preq__ord", "preq__msg", "prekg_ptr", "preq__loc", "preqt__ord", "preqxaddr", "prek___ref", "prequest_addr", "preq__addr", "preqipaddress", "preq___conn", "preq_url", "prequest_data", "preq___ref", "preq_ptr", "prech__addr", "prev_addr", "preqt__addr", "preqipdata", "preq__ref", "prekg_addr", "preq__data", "prech__address", "preq___ad", "prequest_url", "prev_msg", "preq_ref", "prequ_addr", "prequ_address", "prech__ref", "preq__address", "preq__ad", "prech_ref", "prequest_attr", "prek_conn", "preq_adr", "preq_host", "preq_req", "preq___attr", "prequest_msg", "preq__attr", "preq_add"], "dhcp_msg_type": ["dhcp_msg_time", "dhcp_req_style", "dhcp_msg_size", "dhcp_cmd_name", "dhcp_message_id", "dhcp_message_TYPE", "dhcp_msg_t", "dhcp_msg_info", "dhcp_req_no", "dhcp_req_name", "dhcp_cmd_type", "dhcp_msg_style", "dhcp_msg_TYPE", "dhcp_message_type", "dhcp_msg_no", "dhcp_msg_name", "dhcp_cmd_Type", "dhcp_message_num", "dhcp_message_name", "dhcp_msg_types", "dhcp_msg_num", "dhcp_cmd_id", "dhcp_req_t", "dhcp_msg_id", "dhcp_message_size", "dhcp_message_info", "dhcp_message_Type", "dhcp_message_time", "dhcp_msg_Type", "dhcp_req_type", "dhcp_message_types", "dhcp_message_status", "dhcp_cmd_t", "dhcp_msg_status"], "val": ["pol", "typ", "tx", "cal", "al", "len", "value", "valid", "mem", "local", "seq", "rel", "msg", "bal", "ctx", "pos", "test", "Val", "vc", "VAL", "vals", "key", "addr", "eval", "base", "ret", "v", "res"], "q": ["f", "ch", "Q", "o", "dq", "d", "w", "c", "k", "g", "qu", "p", "qq", "j", "iq", "qa", "query", "qs", "ql", "e", "u", "eq", "ue", "h", "t", "v", "sq", "qi"]}}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "static void print_features(FILE *f,\n\n                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                           uint32_t features, const char *prefix)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(feature_name); i++)\n\n        if (feature_name[i] && (features & (1 << i))) {\n\n            if (prefix)\n\n                (*cpu_fprintf)(f, \"%s\", prefix);\n\n            (*cpu_fprintf)(f, \"%s \", feature_name[i]);\n\n        }\n\n}\n", "idx": 24312, "substitutes": {"f": ["fx", "fb", "x", "full", "out", "cf", "o", "fast", "fw", "ff", "uf", "fa", "fs", "d", "tf", "w", "c", "fr", "bf", "fl", "fi", "g", "fm", "r", "n", "p", "lf", "fn", "s", "j", "form", "rf", "file", "xf", "b", "l", "fac", "fd", "fc", "e", "fp", "t", "h", "q", "m", "v", "F"], "cpu_fprintf": ["cpu_vprintln", "cpu_rmt", "cpu_dprint", "cpu_vmt", "cpu_hprint", "cpu_vformat", "cpu_dprintln", "cpu_cformat", "cpu_rprintf", "cpu_rformat", "cpu_hformat", "cpu_cmt", "cpu_dmt", "cpu_fmt", "cpu_dprintf", "cpu_fformat", "cpu_rprintln", "cpu_fprintln", "cpu_cprintf", "cpu_hprintf", "cpu_dformat", "cpu_vprintf", "cpu_fprint", "cpu_vprint", "cpu_cprint", "cpu_hmt", "cpu_rprint"], "features": ["sections", "names", "eatures", " feats", " Features", "fields", "items", "feature", "versions", "forms", "ATURES", "Features", "flags", "details", "tests", "acts", "prints", "classes", "ints", "bits", "faces", "rows", "frames", "words", "ances", "pins", "blocks", "xs", "types", "weights", "feat", "images", " matches", "terms", "fts", "fixes", "properties", "parts", "events", "reports", " rows"], "prefix": ["help", "fx", "padding", "pretty", "pre", "x", "tx", "append", "FIX", "null", "foo", "pad", "wrapper", "master", "buffer", "password", "p", "cache", "fix", "phrase", "border", "restricted", "just", "confirmed", "tag", "print", "chain", "priority", "yes", "quote", "key", "txt", "alpha", "progress", "base", "fixes", "sp", "pres", "fp", "label", "offset", "pkg", "pattern", "format", "name", "ix"], "i": ["it", "ic", "ms", "x", "ui", "multi", "ki", "o", " multi", "pi", " ni", " ii", "ini", "ex", "id", "index", "yi", "ri", "g", "gu", "me", "gi", "in", "I", "n", "p", "phi", "io", "di", "zi", "sim", "j", "ai", "mi", "li", "iq", "ii", "chain", "is", "ti", "ind", "l", " ti", "bi", "y", " mi", "ims", "ip", "ci", "key", "z", "ij", "json", "num", "e", "u", "iu", " I", "xi", "si", "im", "ni", "m", "v", "cli", "init", "qi", "mu", "ix"]}}
{"project": "qemu", "commit_id": "1a9353d258aba69afd8a389bf5fb705caab12ce0", "target": 0, "func": "int cpu_x86_gen_code(uint8_t *gen_code_buf, int max_code_size, \n\n                     int *gen_code_size_ptr, uint8_t *pc_start, \n\n                     int flags)\n\n{\n\n    DisasContext dc1, *dc = &dc1;\n\n    uint8_t *gen_code_end, *pc_ptr;\n\n    long ret;\n\n#ifdef DEBUG_DISAS\n\n    struct disassemble_info disasm_info;\n\n#endif\n\n    dc->code32 = (flags >> GEN_FLAG_CODE32_SHIFT) & 1;\n\n    dc->addseg = (flags >> GEN_FLAG_ADDSEG_SHIFT) & 1;\n\n    dc->f_st = (flags >> GEN_FLAG_ST_SHIFT) & 7;\n\n    dc->cc_op = CC_OP_DYNAMIC;\n\n    gen_code_ptr = gen_code_buf;\n\n    gen_code_end = gen_code_buf + max_code_size - 4096;\n\n    gen_start();\n\n\n\n    dc->is_jmp = 0;\n\n    pc_ptr = pc_start;\n\n    do {\n\n        ret = disas_insn(dc, pc_ptr);\n\n        if (ret == -1) \n\n            error(\"unknown instruction at PC=0x%x B=%02x %02x\", \n\n                  pc_ptr, pc_ptr[0], pc_ptr[1]);\n\n        pc_ptr = (void *)ret;\n\n    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);\n\n    /* we must store the eflags state if it is not already done */\n\n    if (dc->cc_op != CC_OP_DYNAMIC)\n\n        gen_op_set_cc_op(dc->cc_op);\n\n    if (dc->is_jmp != 1) {\n\n        /* we add an additionnal jmp to update the simulated PC */\n\n        gen_op_jmp_im(ret);\n\n    }\n\n    gen_end();\n\n    *gen_code_size_ptr = gen_code_ptr - gen_code_buf;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel) {\n\n        uint8_t *pc;\n\n        int count;\n\n\n\n        INIT_DISASSEMBLE_INFO(disasm_info, logfile, fprintf);\n\n#if 0        \n\n        disasm_info.flavour = bfd_get_flavour (abfd);\n\n        disasm_info.arch = bfd_get_arch (abfd);\n\n        disasm_info.mach = bfd_get_mach (abfd);\n\n#endif\n\n#ifdef WORDS_BIGENDIAN\n\n        disasm_info.endian = BFD_ENDIAN_BIG;\n\n#else\n\n        disasm_info.endian = BFD_ENDIAN_LITTLE;\n\n#endif        \n\n        fprintf(logfile, \"IN:\\n\");\n\n        disasm_info.buffer = pc_start;\n\n        disasm_info.buffer_vma = (unsigned long)pc_start;\n\n        disasm_info.buffer_length = pc_ptr - pc_start;\n\n        pc = pc_start;\n\n        while (pc < pc_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n        \n\n        pc = gen_code_buf;\n\n        disasm_info.buffer = pc;\n\n        disasm_info.buffer_vma = (unsigned long)pc;\n\n        disasm_info.buffer_length = *gen_code_size_ptr;\n\n        fprintf(logfile, \"OUT: [size=%d]\\n\", *gen_code_size_ptr);\n\n        while (pc < gen_code_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 24315, "substitutes": {"gen_code_buf": ["gen_code_begin", "gen_call_buff", "gen_call_bin", "gen_code_buff", "gen_call_buf", "gen_code_iter", "gen_co_size", "gen_call_iter", "gen_code_bin", "gen_code_buffer", "gen_co_begin", "gen_call_size", "gen_Code_buffer", "gen_call_buffer", "gen_Code_size", "gen_co_buf", "gen_code_size", "gen_Code_iter", "gen_Code_buf", "gen_co_buffer"], "max_code_size": ["max_code2size", "max_code_length", "max_code_len", "max_data_size", "max_code_name", "max_code_Size", "max_data_name", "max_code2len", "max_code2name", "max_data_Size", "max_data_len", "max_data_length"], "gen_code_size_ptr": ["gen_code_size_tr", "gen_code_Size_Ptr", "gen_code_size_Ptr", "gen_code_Size_ptr", "gen_code_size_loc", "gen_code_Size_tr", "gen_code_Size_addr", "gen_code_size_addr"], "pc_start": ["PC_begin", "pc2start", "PC_end", "pc_end", "fc_begin", "PC_start", "fc_ptr", "fc_start", "fc_end", "pc_begin", "pc2end", "pc2begin", "pc2ptr", "PC_ptr"], "flags": ["ms", "ports", "limits", "ops", " Flags", "args", "bugs", "options", "fields", "status", "fs", "lag", "planes", "tags", "ds", "stores", "amps", "comments", "details", "Flags", "pages", "cmd", "products", "fps", "cs", "ags", "bits", "faces", "words", "pins", "levels", "xf", "ts", "weights", "locks", "files", "mask", "flag", "FLAG", "kind", "posts", "features", "actions", "properties", "heads", "reports", "utils", "doms"], "dc1": ["c0", "c3", "c6", "disc3", "c2", "disc2", "DC2", "dc2", "DC0", "disc1", "cca1", "c8", " dc2", "cca2", "cca6", "dc8", "c1", "disc8", "dc3", "dc6", "DC1", " dc8", "DC6", "cca0", "dc0", " dc3"], "dc": ["dim", "mac", "cam", "ce", "ca", "adr", "dir", "bc", "d", "dh", "c", "cd", "rc", "tc", "cca", "create", "disk", "mm", "ec", "mk", "currency", "ga", "cat", "cp", "ctl", "rec", "nc", "dt", "disc", "di", "design", "dm", "cm", "ctx", "center", "df", "td", "doc", "die", "iac", "central", "da", "ct", "dp", "desc", "ac", "dr", "dd", "cr", "document", "dat", "wp", "dra", "city", "mc", "bd", "fc", "draw", "kw", "driver", "gc", "DC", "cc", "controller", "lc", "drm"], "gen_code_end": ["gen_codes_end", "gen_code__end", "gen_code__start", "gen_code_offset", "gen_codes_start", "gen_codes_len", "gen_code_END", "gen_pre_END", "gen_pre_start", "gen_codes_offset", "gen_code_ptr", "gen_data_buf", "gen_code__len", "gen_data_start", "gen_data_end", "gen_data_ptr", "gen_code_len", "gen_pre_end", "gen_code__offset", "gen_code_start"], "pc_ptr": ["pc_rel", "gc_ctr", "proc_ptr", "pod_pointers", "pcPend", "pc__ctr", "asc_rep", "asc_rel", "fc_ptr", "pc0buf", "pc_ctr", "pcPlr", "podPptr", "pc_Ptr", "pc__ptr", "pod_addr", "pc_sp", "pcPrel", "pc__tr", "gc__ptr", "asc_ptr", "podPaddr", "gc__tr", "proc_start", "fc_buf", "pc_buf", "pc_tr", " pc_iter", "pod_end", "ascPrep", "pc_addr", "pcPptr", "proc_pointer", "pcPrep", " pc_sp", "proc_addr", "pcPaddr", "gc_pointer", "pc_pointer", "podPpointers", "asc_rect", "pc0ptr", "pc_pointers", "pc_end", "pod_ptr", "ascPptr", "pc_rep", "ascPrel", "pc0start", "fc_Ptr", " pc_addr", "gc_tr", "pc__pointer", "pcPrect", "gc__pointer", "ascPrect", "pc0Ptr", "ascPlr", "pc_rect", "gc__ctr", "pc_lr", "pc_iter", "asc_lr", "gc_ptr", "podPend", "pcPpointers", "fc_start"], "ret": ["inter", "alt", "ter", "out", "red", "err", "reset", "ll", "RET", "ref", "re", "rm", "len", "success", "try", "status", "tf", "gt", "valid", "def", "value", "result", "rev", "cont", "mem", "r", "ext", "det", "reply", "cmd", "deg", "resp", "gov", "rem", "j", "nz", "print", "rt", "back", "desc", "ts", "nt", "fun", "rets", "addr", "txt", " RET", "num", "ft", " Ret", "val", "iter", "mt", "null", "Ret", " alt", "gc", "tr", "t", "elt", "vt", "arg", "tmp", "res"], "disasm_info": ["disasm_fo", "disassembly_fo", "dislamm_id", "disasm__INFO", "disasm_id", "disassembly_status", "disasm_INFO", "disassembly_inf", "dislamm_Info", "disasm_inf", "disassembly_Info", "disarm_Info", "disassembly_info", "disasm_status", "disasm__state", "disasm__info", "dislamm_info", "disasm__status", "disasm__inf", "disarm_inf", "disasm_state", "disasm__Info", "disassembly_state", "disasm_Info", "disarm_info", "disassembly_INFO"], "pc": ["pb", "PC", "bc", "c", "rc", "tc", "asc", "ec", "cp", "sc", "nc", "arc", "cs", "isc", "ctx", "enc", "ac", "oc", "psc", "mc", "fc", "tp", "gc", "lp", "cc", "proc", "pt", "pic"], "count": [" call", "type", "length", "cmp", "ount", "err", "code", "c", "skip", "id", "ctr", "result", "func", "counter", "nc", "resp", "call", "ctx", "total", "Count", "process", "ct", "z", "num", "draw", "current", "flag", "name"]}}
{"project": "qemu", "commit_id": "31478f26ab4ed82d35b763bbf259810d0c8b44e1", "target": 1, "func": "static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,\n\n                                            const char *name,\n\n                                            Error **errp)\n\n{\n\n    QObject *qobj;\n\n    QString *qstr;\n\n\n\n    qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    if (!qobj) {\n\n        return NULL;\n\n    }\n\n\n\n    qstr = qobject_to_qstring(qobj);\n\n    if (!qstr) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,\n\n                   full_name(qiv, name), \"string\");\n\n        return NULL;\n\n    }\n\n\n\n    return qstring_get_str(qstr);\n\n}\n", "idx": 24328, "substitutes": {"qiv": ["quivo", "acquIV", "qutv", " qIv", "dqivo", "queryiv", "sqiver", "qIV", "qivo", "quIv", "dqtv", "qtv", "sqiv", "qiver", " qiver", "querytv", "acquiver", "queryivo", "qIv", "queryiver", "quiver", " qIV", "sqivo", "quiv", "dqiver", "acquiv", "dqiv", "quIV", "sqtv", "acquIv"], "name": ["type", "na", "nm", "search", "ma", "item", "nam", "named", "nan", "normal", "part", "w", "def", "value", "id", "word", "error", "title", "common", "local", "var", "path", "in", "resource", "spec", "ext", "n", "p", "san", "prefix", "new", "lat", "init", "data", "size", "NAME", "key", "base", "ame", "missing", "Name", "label", "no", "format", "str", "names"], "errp": ["scorep", "rrr", "errper", " erpa", "errorpe", " errm", "scorepe", " errP", "krpa", "errpid", "errpe", "arrr", "krpat", "errm", "riskpa", "rrm", "errP", " errr", " errpe", "errr", " errpr", " erpid", "riskpid", "krpid", "arrp", "rrp", " erpat", "errorpr", "arrper", "errorp", "krp", "arrm", "errpat", "errpr", "rrper", " erp", "riskp", "errorP", "scorepr", "riskpat", "scoreP", " errper", "errpa"], "qobj": ["eqobj", "qObj", "dqObj", "sqobj", "qqobject", "qubo", "dqobject", "qujs", "eqobject", " qtxt", "dqjs", "qqobj", "dqopt", "queryobject", "querystr", "quobj", "qtxt", "qobject", " qObj", " qjs", "queryrect", "qutxt", "qjs", "eqstr", "sqjs", "qqtxt", "quObj", " qbo", " qobject", "qqbo", "qbo", "qrect", "eqrect", "quopt", "dqobj", "dqbo", "sqopt", "queryobj", "qqObj", "qqjs", " qrect", "sqObj", "qopt"], "qstr": ["qqst", "qstring", "dqarr", "qsp", "sqobj", "qfr", "qstable", "dqSTR", "qufr", "sqstr", "dqsp", " qfr", "querybr", "qustable", "qarr", "qSTR", "dqbr", " qstring", "querystr", "dqfr", "quobj", "qustring", "quarr", "qqstring", "qusp", " qSTR", "qubr", "sqstring", "querySTR", "qst", "dqstr", "qustr", "sqsp", "qqstr", "qqstable", "dqobj", "qust", " qbr", " qarr", " qst", "queryobj", "qbr", "dqstring", " qstable"]}}
{"project": "qemu", "commit_id": "74b6ce43e3aacbb101018407196fc963e2c39fea", "target": 1, "func": "static void qio_channel_socket_finalize(Object *obj)\n{\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);\n    if (ioc->fd != -1) {\n#ifdef WIN32\n        WSAEventSelect(ioc->fd, NULL, 0);\n#endif\n        closesocket(ioc->fd);\n        ioc->fd = -1;", "idx": 24331, "substitutes": {"obj": ["ock", "cmp", "other", "o", "xy", "ref", "conn", "os", "piece", "tk", "obo", "bo", "ex", "cont", "object", "act", "cmd", "objects", "org", "Object", "ob", "resp", "j", "Obj", "js", "any", "attr", "nt", "bj", "txt", "oj", "bh", "oco", "obs", "pkg", "tmp", "t", "onet"], "ioc": ["giog", " iog", "dioco", "bioci", "iocy", " ioci", "piog", "lioco", "liocated", "diOC", "gioc", "ziocated", "pioco", "piroc", " iroc", "ziroc", "dioc", "iog", "gioco", "liroc", "iroc", "ioci", "pioc", "iocated", "diroc", "biroc", "ioco", "iioc", "iiroc", "giroc", " iocy", "iOC", "zioc", "giocy", "lioc", "bioc", "iiocy", "diocy", " ioco", "dioci", " iocated", "zioco", "iioco", "biOC", " iOC"]}}
{"project": "qemu", "commit_id": "c9add6219514b20223f024584f0464b8842b1ec0", "target": 1, "func": "bool ftrace_init(void)\n\n{\n\n    char mount_point[PATH_MAX];\n\n    char path[PATH_MAX];\n\n    int debugfs_found;\n\n    int trace_fd = -1;\n\n\n\n    debugfs_found = find_mount(mount_point, \"debugfs\");\n\n    if (debugfs_found) {\n\n        snprintf(path, PATH_MAX, \"%s/tracing/tracing_on\", mount_point);\n\n        trace_fd = open(path, O_WRONLY);\n\n        if (trace_fd < 0) {\n\n            if (errno == EACCES) {\n\n                trace_marker_fd = open(\"/dev/null\", O_WRONLY);\n\n                if (trace_marker_fd != -1) {\n\n                    return true;\n\n                }\n\n            }\n\n            perror(\"Could not open ftrace 'tracing_on' file\");\n\n            return false;\n\n        } else {\n\n            if (write(trace_fd, \"1\", 1) < 0) {\n\n                perror(\"Could not write to 'tracing_on' file\");\n\n                close(trace_fd);\n\n                return false;\n\n            }\n\n            close(trace_fd);\n\n        }\n\n        snprintf(path, PATH_MAX, \"%s/tracing/trace_marker\", mount_point);\n\n        trace_marker_fd = open(path, O_WRONLY);\n\n        if (trace_marker_fd < 0) {\n\n            perror(\"Could not open ftrace 'trace_marker' file\");\n\n            return false;\n\n        }\n\n    } else {\n\n        fprintf(stderr, \"debugfs is not mounted\\n\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 24351, "substitutes": {"mount_point": ["mountitypoint", "mountityarea", "mount2point", "mounturepattern", "mount_pattern", "mount_Point", "mount_area", "mounted_point", "mounturepoint", " mount_points", "mount_points", "mounturearea", " mount_pattern", "mountitypattern", "mountitypoints", " mount_area", "mount2base", "mount2points", " mount_prefix", "mount_base", " mount_base", "mount_prefix", "mounturepoints", " mount_Point", "mounted_Point"], "path": ["ath", "here", "context", "type", "length", "patch", "full", "prop", "where", "parent", "dir", "temp", "config", "part", "pi", "binding", "id", "core", "local", "empty", "cmd", "spec", "p", "route", "prefix", "dest", "root", "to", "transform", "order", "call", "module", "form", "message", "PATH", "th", "chain", "file", "doc", "test", "data", "port", "template", "text", "history", "progress", "link", "key", "url", "directory", "pod", "kind", "time", "self", "package", "walk", "pattern", "pkg", "format", "index", "mount", "name", "pt", "Path"], "debugfs_found": ["debugfs2found", "debugfs_finder", "debugfs_Found", "debugfs_find", "debugf_Found", "debugfs2Found", "debugFS_Found", "debugf2find", "debugbs_found", "debugbs_Found", "debugbs_finder", "debugfs_loaded", "debugf_find", "debugFS_loaded", "debugFS_found", "debugf2Found", "debugf2found", "debugfs2find", "debugf_found"]}}
{"project": "FFmpeg", "commit_id": "7cf22c79706d23d40d16cee37eb32d5797adcc2c", "target": 0, "func": "yuv2rgba64_1_c_template(SwsContext *c, const int32_t *buf0,\n\n                       const int32_t *ubuf[2], const int32_t *vbuf[2],\n\n                       const int32_t *abuf0, uint16_t *dest, int dstW,\n\n                       int uvalpha, int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    const int32_t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0];\n\n    int i;\n\n    int A1 = 0xffff<<14, A2= 0xffff<<14;\n\n\n\n    if (uvalpha < 2048) {\n\n        for (i = 0; i < ((dstW + 1) >> 1); i++) {\n\n            int Y1 = (buf0[i * 2]    ) >> 2;\n\n            int Y2 = (buf0[i * 2 + 1]) >> 2;\n\n            int U  = (ubuf0[i] + (-128 << 11)) >> 2;\n\n            int V  = (vbuf0[i] + (-128 << 11)) >> 2;\n\n            int R, G, B;\n\n\n\n            Y1 -= c->yuv2rgb_y_offset;\n\n            Y2 -= c->yuv2rgb_y_offset;\n\n            Y1 *= c->yuv2rgb_y_coeff;\n\n            Y2 *= c->yuv2rgb_y_coeff;\n\n            Y1 += 1 << 13;\n\n            Y2 += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] << 11;\n\n                A2 = abuf0[i * 2 + 1] << 11;\n\n\n\n                A1 += 1 << 13;\n\n                A2 += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);\n\n                dest += 8;\n\n            } else {\n\n                output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                dest += 6;\n\n            }\n\n        }\n\n    } else {\n\n        const int32_t *ubuf1 = ubuf[1], *vbuf1 = vbuf[1];\n\n        int A1 = 0xffff<<14, A2 = 0xffff<<14;\n\n        for (i = 0; i < ((dstW + 1) >> 1); i++) {\n\n            int Y1 = (buf0[i * 2]    ) >> 2;\n\n            int Y2 = (buf0[i * 2 + 1]) >> 2;\n\n            int U  = (ubuf0[i] + ubuf1[i] + (-128 << 12)) >> 3;\n\n            int V  = (vbuf0[i] + vbuf1[i] + (-128 << 12)) >> 3;\n\n            int R, G, B;\n\n\n\n            Y1 -= c->yuv2rgb_y_offset;\n\n            Y2 -= c->yuv2rgb_y_offset;\n\n            Y1 *= c->yuv2rgb_y_coeff;\n\n            Y2 *= c->yuv2rgb_y_coeff;\n\n            Y1 += 1 << 13;\n\n            Y2 += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] << 11;\n\n                A2 = abuf0[i * 2 + 1] << 11;\n\n\n\n                A1 += 1 << 13;\n\n                A2 += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);\n\n                dest += 8;\n\n            } else {\n\n                output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                dest += 6;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24356, "substitutes": {"ubuf0": ["ubbuf0", "abuf1", "ubimg0", "abufSpec", "abuf8", "ubbuf2", "abbuf3", "ubbuff0", "ubufSpec", "ubimg2", "abuf0", "abbufSpec", "abbuf8", "abuf2", "ubbuff3", "abuf3", "ubuff3", "ubbuff1", "ubbuff8", "ubimgSpec", "abbuf0", "ubuffer0", "ubbufSpec", "ubbuf8", "ubuf3", "ubuffer1", "ubuff1", "abbuf1", "ubimg1", "ubuff0", "ubuffer2", "ubuff8", "abbuf2", "ubbuf1", "ubuf2", "ubuf8", "ubufferSpec", "ubbuf3"], "vbuf0": ["gbuf6", "gbuf1", "gbuf047", "vbur3", "vuffer0", "vfont1", "bbuf0", "vbuff1", "bbuf3", "guf047", "bbuf1", "vbuf6", "vbuff0", "vbur0", "vbuf3", "vuffer6", "vuf0", "vuffer1", "vuffer047", "guf6", "buf0", "guf0", "guf1", "buf1", "vuf047", "vbur1", "vbuf047", "gbuf0", "vfont6", "vbuff3", "buf3", "vuf6", "vfont0", "vfont047", "vuf3", "vuf1"], "i": ["ji", "f", "it", "ic", "x", "batch", "ui", "name", "ki", "multi", "\u0438", "o", "point", "ski", "status", "ami", "pi", "c", "id", "k", "ini", "ri", "me", "gi", "I", "n", "p", "phi", "io", "di", "oi", "zi", "sim", "j", "go", "ai", "span", "mi", "li", "ii", "chain", "a", "is", "ti", "ind", "l", "info", "bi", "ij", "ip", "y", "ish", "ci", "z", "uri", "iu", "xi", "h", "t", "im", "si", "index", "v", "cli", "m", "qi", "this", "ei", "ix"], "R": ["TR", "Q", "W", "BR", "HR", "U", "L", "D", "GR", "A", "RE", "ER", "r", "RT", "DR", "RR", "I", "M", "RGB", "RB", "RA", "X", "RM", "RC", "V", "E", "T", "RO", "SR", "N", "RF", "H", "P", "Y", "C", "RG", "NR"], "G": ["Q", "Car", "W", "GT", "PG", "Gs", "LG", "U", "L", "GI", "D", "GR", "GB", "GU", "Gu", "BG", "GC", "g", "GM", "M", "GS", "Graphics", "GD", "GP", "GG", "GA", "Ge", "VG", "V", "GV", "H", "Group", "Y", "C", "RG"], "B": ["Bus", "BC", "W", "Bi", "BR", "Bar", "U", "L", "D", "GB", "BL", "BG", "BM", "LB", "A", "BA", "M", "BB", "J", "S", "V", "AB", "T", "DB", "NB", "BW", "BT", "N", "Bs", "SB", "BO", "P", "BU", "Y", "C", "VB"]}}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_int(v, obj, name, errp);\n\n    }\n\n}\n", "idx": 24364, "substitutes": {"v": ["f", "vm", "it", "i", "x", "o", "ev", "lv", "d", "vp", "w", "tv", "c", "vv", "pr", "g", "r", "ver", "p", "n", "s", "vis", "mint", "vr", "j", "view", "vs", "inv", "av", "V", "b", "l", "vc", "y", "e", "sv", "vi", "h", "t", "vt", "uv", "m", "conv", "q", "cv"], "obj": [" ob", "o", "ref", "nb", "tk", "object", "og", "act", "inst", "cmd", "objects", "org", "Object", "ob", " Obj", "Obj", "ctx", "inv", "np", "js", "oid", "so", "attr", "nt", "info", "bj", "addr", "lib", "oj", "px", "rb", "obs", "ist", "off", "pkg", "self", "tmp", "elt", "ot"], "name": ["type", "ident", "na", "nm", " names", "ma", "named", "normal", "part", "w", "ann", "def", "id", "word", "error", " prefix", "local", "var", "path", "comment", "spec", "ext", "n", "p", "alias", "s", " Name", "prefix", "par", "an", "ne", "init", "data", "NAME", "key", "text", "ame", "missing", "Name", "t", "no", "str", "names"], "errp": ["errorpe", "errps", " errpa", " errm", "cerpa", " errP", "cerd", "errpe", "errm", "rrm", "errP", "cerp", "errorps", " errd", " errpe", "rrP", "rrp", "errd", "rrps", "errorp", "rrpa", "rrpe", "errorm", "errorP", " errps", "rrd", "errpa"]}}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "static void avc_luma_mid_8w_msa(const uint8_t *src, int32_t src_stride,\n\n                                uint8_t *dst, int32_t dst_stride,\n\n                                int32_t height)\n\n{\n\n    uint32_t loop_cnt;\n\n    v16i8 src0, src1, src2, src3, src4;\n\n    v16i8 mask0, mask1, mask2;\n\n    v8i16 hz_out0, hz_out1, hz_out2, hz_out3;\n\n    v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8;\n\n    v8i16 dst0, dst1, dst2, dst3;\n\n    v16u8 out0, out1;\n\n\n\n    LD_SB3(&luma_mask_arr[0], 16, mask0, mask1, mask2);\n\n\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    hz_out0 = AVC_HORZ_FILTER_SH(src0, src0, mask0, mask1, mask2);\n\n    hz_out1 = AVC_HORZ_FILTER_SH(src1, src1, mask0, mask1, mask2);\n\n    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);\n\n    hz_out3 = AVC_HORZ_FILTER_SH(src3, src3, mask0, mask1, mask2);\n\n    hz_out4 = AVC_HORZ_FILTER_SH(src4, src4, mask0, mask1, mask2);\n\n\n\n    for (loop_cnt = (height >> 2); loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src0, src1, src2, src3);\n\n        XORI_B4_128_SB(src0, src1, src2, src3);\n\n        src += (4 * src_stride);\n\n\n\n        hz_out5 = AVC_HORZ_FILTER_SH(src0, src0, mask0, mask1, mask2);\n\n        hz_out6 = AVC_HORZ_FILTER_SH(src1, src1, mask0, mask1, mask2);\n\n        hz_out7 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);\n\n        hz_out8 = AVC_HORZ_FILTER_SH(src3, src3, mask0, mask1, mask2);\n\n        dst0 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out0, hz_out1, hz_out2,\n\n                                               hz_out3, hz_out4, hz_out5);\n\n        dst1 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out1, hz_out2, hz_out3,\n\n                                               hz_out4, hz_out5, hz_out6);\n\n        dst2 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out2, hz_out3, hz_out4,\n\n                                               hz_out5, hz_out6, hz_out7);\n\n        dst3 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5,\n\n                                               hz_out6, hz_out7, hz_out8);\n\n        out0 = PCKEV_XORI128_UB(dst0, dst1);\n\n        out1 = PCKEV_XORI128_UB(dst2, dst3);\n\n        ST8x4_UB(out0, out1, dst, dst_stride);\n\n\n\n        dst += (4 * dst_stride);\n\n        hz_out3 = hz_out7;\n\n        hz_out1 = hz_out5;\n\n        hz_out5 = hz_out4;\n\n        hz_out4 = hz_out8;\n\n        hz_out2 = hz_out6;\n\n        hz_out0 = hz_out5;\n\n    }\n\n}\n", "idx": 24368, "substitutes": {"src": ["sys", "sn", "stack", "cur", "sb", "stream", "ins", "rl", "ix", "syn", "pri", "host", "iv", "std", "ipl", "rs", "sub", "rc", "ctr", "cont", "sl", "rx", "sync", "in", "inst", "sr", "supp", "sc", "s", "ser", "img", "usr", "dest", "dist", "lat", "input", "sec", "th", "raw", "scan", "rt", "loc", "txt", "addr", "url", "seek", "st", "fc", "tp", "hl", "source", "ptr", "tr", "tmp"], "src_stride": ["src_constite", "src_decide", "src_brride", "src_STRice", "src_strim", "src_STRite", "src_stides", "src_stade", "src_constride", "src_STRride", "src_Strate", "src_grine", "src_constide", "src_stide", "src_grides", "src_brides", "src_Stride", "src_strides", "src_decride", "src_slide", "src_strate", "src_STRim", "src_glide", "src_STRade", "src_Strride", "src_gline", "src_bride", "src_grride", "src_grice", "src_brade", "src_decides", "src_Strim", "src_STRine", "src_constides", "src_slride", "src_slate", "src_STRide", "src_strite", "src_strride", "src_strice", "src_glice", "src_glade", "src_gride", "src_decite", "src_STRate", "src_STRides", "src_slim", "src_strine", "src_grade", "src_strade"], "dst": ["tnd", "dest", " dnd", " ddest", "Ddest", "test", "dnd", "Dst", " dest", "Dest", "Dnd", "ddest", "tst", "tdest"], "dst_stride": ["dst_brate", "dst_glade", "dst_glate", "dst_decide", "dst_strate", "dst_glide", "dst_glride", "dst_strade", "dst_bride", "dst_decade", "dst_decride", "dst_decate", "dst_brride", "dst_strride", "dst_brade"], "height": ["here", "padding", "length", "tx", "hash", "flow", "push", "read", "ty", "grow", "buffer", "zh", "command", "loss", "count", "gravity", "ctx", "ht", "show", "depth", "th", "capacity", "chain", "rank", "size", "y", "history", "window", "draw", "kw", "check", "import", "resolution", "scope", "scroll", "frequency", "radius", "Height", "h", "density", "bottom"], "loop_cnt": ["loop_cNT", "loop2Count", "loop_acust", "loop_count", "loop_fccount", "loop2cnt", "loop_cust", "loop_Cust", "loop2cpt", "loop_acpt", "loop_fcpt", "loop2Cnt", "loop_fcst", "loop_uncctr", "loop2cust", "loop_cst", "loop2Cust", "loop_tount", "loop_Cst", "loop_tust", "loop_Cnt", "loop2Cpt", "loop_cpt", "loop_uncpt", "loop_uncNT", "loop_Ccount", "loop_uncnt", "loop_acnt", "loop2cst", "loop_acst", "loop2Ccount", "loop_ccount", "loop_Cpt", "loop_acount", "loop_fcnt", "loop_Count", "loop_CNT", "loop_cctr", "loop_tcount", "loop2Cst", "loop2count", "loop_Cctr", "loop2ccount", "loop_tnt", "loop_account"], "src0": ["source0", "source1", "rc02", " src5", "rc0", " src02", "ser00", "rc5", "st1", "inst0", "ser2", " src00", "src5", "inst5", "st0", "rc00", "st2", "inst02", "source4", "source3", "inst1", "rc3", "ser1", "source2", "rc2", "rc1", "source00", "rc4", "st00", "ser0", "src02", "src00"], "src1": ["source0", "source1", "sys2", "dest2", "rc0", "sr3", "src01", " src01", "srcOne", "src11", "sys0", "sourceOne", "ser2", "rc01", "sys4", "source11", "dest3", "source4", "ser4", "source3", "rc3", "rcOne", "sys3", "ser1", "rc11", "source2", "rc2", "rc1", "sys1", "sr1", "sr0", "dest0", "ser3", " srcOne", "rc4", "source01", "ser0", " src11", "sr4", "dest1"], "src2": ["source0", "source1", "sys2", "dest2", "rc02", "rc0", " src02", "ser02", "src6", "proc6", "sys0", "proc1", "ser2", "dest3", "proc3", "source4", "ser4", "source3", "rc3", "sys6", "sys3", "ser1", "source2", "source02", "rc2", "rc1", "sys1", "dest0", "rc4", "rc6", "proc2", "dest1", "src02"], "src3": ["source0", "source1", "sys2", " src5", "rc0", "sr3", "rc03", "sr003", "rc5", "srd", " src003", "src5", "sourced", "src03", "src003", "source4", "source3", "rc3", " src03", "sys3", "rcd", "sr2", "rc003", "srant", "sys03", "source5", "source2", "rc2", "rc1", "sourceant", "sys1", "sr1", "rcant", "srcd", "rc4", "source03", "sr03", "sr4", "srcant"], "src4": ["source0", "source1", "dest2", " src5", "rc0", "rc5", "src5", "dest3", "src44", "source4", "source3", " src44", "rc44", "rc3", "source5", "dest4", "source2", "rc2", "rc1", "rc4", "dest1", "source44"], "mask0": ["weight2", "flag1", "cmd2", "shape8", "mark2", "askING", "ask1", "maskING", " mask6", "weight1", "mark0", "shape0", "cmd0", "mark1", "miss2", "weight3", "Mask8", "fac2", "mark3", "miss0", "flag2", "ask6", "ask3", "Mask0", "maskator", "mask3", "miss1", "fac1", "markator", "facING", "cmdator", "fac0", "markING", " maskator", "weight0", " mask8", "ask0", "flag0", "askator", "shape50", " mask3", "mask50", "miss3", "mask6", "Mask1", "shape1", "cmd1", "ask2", " mask50", "flag6", "mask8", "Mask50"], "mask1": ["mark2", "markONE", "ask1", "broad3", "mark0", "filter3", "lock0", "miss2", "lock6", "mark1", "broad1", "mark3", "miss0", "ask6", "ask3", "lock4", "map6", "missONE", "ask4", "broadONE", "mask3", "broad2", "map4", "miss1", "map0", "ask0", "maskONE", "filter2", "filter1", "map1", " mask3", "mask4", "miss3", "mask6", "ask2", "lock1", "filter0"], "mask2": ["broad4", "mark2", "miss4", "miss05", "ask05", "ask1", " mask6", "mark0", "filter3", "miss2", "mark1", "check3", "mark6", "broad1", "mark3", "miss0", "ask3", "ask6", "ask4", "mask3", "check4", "miss1", "check1", "broad2", "broad05", "ask0", "filter2", "filter1", "mask05", " mask4", " mask3", "filter4", "mark4", "mask4", "miss3", "mask6", "ask2", "check2"], "hz_out0": ["hz_no0", "hz_in6", "hz_val1", "hz_err2", "hz_int2", "hz_val6", "hz_in1", "hz_no1", "hz_err1", "hz_val0", "hz_int1", "hz_in2", "hz_val2", "hz_err6", "hz_err0", "hz_int4", "hz_in4", "hz_no4", "hz_int0", "hz_in0", "hz_no2"], "hz_out1": ["hz_Out1", "hz_obj1", "hz_Out3", "hz_no3", "hz_obj3", "hz_inB", "hz_obj2", "hz_in1", "hz_no1", "hz_OutOne", "hz_outB", "hz_in2", "hz_objB", "hz_outOne", "hz_noB", "hz_in3", "hz_no2", "hz_inOne"], "hz_out2": ["hz_result5", "hz_OUT2", "hz_result0", "hz_inner3", "hz_int5", "hz_int2", "hz_off4", "hz_OUT0", "hz_OUT8", "hz_result8", "hz_out02", "hz_inner02", "hz_inner4", "hz_OUT5", "hz_int0", "hz_off02", "hz_inner2", "hz_off2", "hz_off3", "hz_result2", "hz_int8"], "hz_out3": ["hz_OUT6", "hz_result7", "hz_OUT4", "hz_key6", "hz_key8", "hz_result3", "hz_OUT7", "hz_result6", "hz_off4", "hz_OUT8", "hz_key3", "hz_result8", "hz_output3", "hz_output4", "hz_off7", "hz_OUT5", "hz_output5", "hz_off5", "hz_key7", "hz_off3", "hz_OUT3", "hz_output7"], "hz_out4": ["hz_err4", "hz_postFourth", "hz_post4", "hz_err2", "hz_off4", "hz_in1", "hz_offFourth", "hz_off1", "hz_in2", "hz_in4", "hz_outFourth", "hz_post2", "hz_off2", "hz_off3", "hz_err3", "hz_inFourth", "hz_post1"], "hz_out5": ["hz_option1", "hz_option7", "hz_output1", "hz_off0", "hz_output0", "hz_off1", "hz_option5", "hz_off7", "hz_output5", "hz_off5", "hz_option0", "hz_output7"], "hz_out6": ["hz_result5", "hz_output2", "hz_result4", "hz_off4", "hz_result6", "hz_off6", "hz_output4", "hz_output5", "hz_off5", "hz_off2", "hz_result2", "hz_output6"], "hz_out7": ["hz_option1", "hz_option7", "hz_output1", "hz_output3", "hz_option3", "hz_off1", "hz_off7", "hz_off3", "hz_output7"], "hz_out8": ["hz_OUT6", "hz_out11", "hz_off8", "hz_OUT7", "hz_OUT8", "hz_off11", "hz_off6", "hz_off7", "hz_OUT11"], "dst0": ["lest5", "dost0", "dost4", "lst4", "dest5", "lst1", "ddest0", "ddest1", "lest1", "lst0", "dest4", "dost5", "dost1", "ddest4", "dst5", "dst4", "dest0", "lst5", "ddest5", "lest4", "dest1", "lest0"], "dst1": [" dstr1", "dist4", "dest2", " dst4", " dstr0", " dstr2", "dstr1", "dist2", "dstr4", "dstr0", "dest4", "dist0", " dstr4", "dst4", "dest0", "dist1", "dest1", "dstr2"], "dst2": ["dest2", "drest2", "idst2", "idist2", "idst256", "idist256", "dest256", "idstTwo", "dist2", "dist256", "drest256", "destTwo", "idistTwo", "drestTwo", "dst256", "distTwo", "dstTwo"], "dst3": ["dnd2", "dest2", "dnd6", "dint3", " dint7", " dint6", "dint7", " dst7", " dint2", "dint2", "dest3", "dnd7", "dst6", "dest6", " dint3", " dst6", "dest7", "dnd3", "dst7", "dint6"], "out0": ["resultk", "ink", " out2", "outk", "result1", "result2", "in2", "out2", "in0", " outk", "in1", "result0"], "out1": ["output2", " out2", "output1", "Out2", "Out4", "Out1", "out3", "output3", "out2", "output4", " out3", " out4", "Out3", "out4"]}}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int pam_encode_close(AVCodecContext *avctx)\n\n{\n\n    av_frame_free(&avctx->coded_frame);\n\n    return 0;\n\n}\n", "idx": 24371, "substitutes": {"avctx": ["wavtxt", "aircmd", "aftx", "Avctx", "wavtx", "Avcontext", "aftxt", "wavctx", "Avcmd", " avcmd", "afctx", " avtxt", "avtxt", "avtx", "aircontext", " avtx", "avsys", "airctx", "avcmd", "afcontext", "airsys", " avsys", " avcontext", "Avsys", "avcontext", "wavcontext"]}}
{"project": "FFmpeg", "commit_id": "6f600ab35424823fb682b5669241edcc66590a8d", "target": 0, "func": "static av_cold int oggvorbis_init_encoder(vorbis_info *vi, AVCodecContext *avccontext)\n\n{\n\n    OggVorbisContext *context = avccontext->priv_data;\n\n    double cfreq;\n\n\n\n    if (avccontext->flags & CODEC_FLAG_QSCALE) {\n\n        /* variable bitrate */\n\n        if (vorbis_encode_setup_vbr(vi, avccontext->channels,\n\n                                    avccontext->sample_rate,\n\n                                    avccontext->global_quality / (float)FF_QP2LAMBDA / 10.0))\n\n            return -1;\n\n    } else {\n\n        int minrate = avccontext->rc_min_rate > 0 ? avccontext->rc_min_rate : -1;\n\n        int maxrate = avccontext->rc_min_rate > 0 ? avccontext->rc_max_rate : -1;\n\n\n\n        /* constant bitrate */\n\n        if (vorbis_encode_setup_managed(vi, avccontext->channels,\n\n                                        avccontext->sample_rate, minrate,\n\n                                        avccontext->bit_rate, maxrate))\n\n            return -1;\n\n\n\n        /* variable bitrate by estimate, disable slow rate management */\n\n        if (minrate == -1 && maxrate == -1)\n\n            if (vorbis_encode_ctl(vi, OV_ECTL_RATEMANAGE2_SET, NULL))\n\n                return -1;\n\n    }\n\n\n\n    /* cutoff frequency */\n\n    if (avccontext->cutoff > 0) {\n\n        cfreq = avccontext->cutoff / 1000.0;\n\n        if (vorbis_encode_ctl(vi, OV_ECTL_LOWPASS_SET, &cfreq))\n\n            return -1;\n\n    }\n\n\n\n    if (context->iblock) {\n\n        vorbis_encode_ctl(vi, OV_ECTL_IBLOCK_SET, &context->iblock);\n\n    }\n\n\n\n    return vorbis_encode_setup_init(vi);\n\n}\n", "idx": 24375, "substitutes": {"vi": ["iri", "i", "ku", "ui", "ki", "edi", "see", "jac", "voice", "iv", "vich", "vert", "vp", "ami", "pi", "eni", "umi", "wire", "activate", "ri", "oci", "pin", "ve", "vis", "mit", "avi", "di", "VI", "vr", "can", "ai", "mi", "ii", "vo", "voc", "av", "vy", "ti", "vc", "vid", "bi", "ive", "ci", "Vi", "vision", "verse", "via", "vim", "qv", "wiki", "xi", "vt", "uv", "vin", "v", "cli", "vre"], "avccontext": ["avccrontext", "avcconte", "avceonystem", "avcconscontext", "avncyntxt", "avccoconcurrent", "avccontex", "avctrontext", "avceonyfigure", "avCContnect", "avncyntex", "avclonclient", "avcconakey", "avccoconconnection", "avccronect", "avcconstruct", "avcellanontext", "avcconytext", "avckoncontext", "avccustomject", "avccoontext", "avclontext", "avacconstant", "avccocontext", "avctontext", "avCContfig", "avcfoconject", "avccaconth", "avccentex", "avccontstant", "avccencontext", "avctaytext", "avccontconnection", "avcconfig", "avcellanonth", "avcconsect", "avcfoconect", "avckoconcurrent", "avccynct", "avccacontxt", "avceonect", "avcusoncontext", "avccustomcert", "avccalasstext", "avckonstant", "avccontcontext", "avccanect", "avCConttext", "avccentext", "avcconsfig", "avccronnect", "avccantext", "avcconconnection", "avcconacontext", "avccronte", "avccyntxt", "avcconatext", "avccondtext", "avckocontext", "avccanonject", "avccanoncurrent", "avccustomtext", "avccoonclient", "avcloonclient", "avcloonstruct", "avcclassnect", "avccanonstant", "avccantontext", "avcellontext", "avncyntext", "avckorestant", "avccantex", "avccanfig", "avccronfig", "avccaconload", "avccynject", "avccncontext", "avcellanontxt", "avcelloconsole", "avccontxt", "avccontsole", "avccaytext", "avccaconstant", "avcconject", "avccalasste", "avccanoncontext", "avctronfig", "avcconclient", "avcconyect", "avctoncontext", "avcusonconnection", "avccontect", "avaccontext", "avckoretext", "avccante", "avccontfig", "avcellonkey", "avccanontxt", "avacconsole", "avckorecontext", "avaccondstant", "avclonstruct", "avccronct", "avctayect", "avcelloconfig", "avcusoconcontext", "avccxonfigure", "avcellonsole", "avccyntex", "avcconsstant", "avccrontxt", "avncontex", "avccronject", "avnconload", "avceonyect", "avcellanonsole", "avcconcert", "avceonstem", "avccrontex", "avccanstant", "avcfontext", "avccatfigure", "avccacontex", "avceonytext", "avcconstext", "avccontnect", "avcellonstant", "avcconload", "avcfocontext", "avccoconfig", "avccoretex", "avccynstant", "avcusontext", "avCConnect", "avckoconect", "avccronstant", "avccantonclient", "avccanonsole", "avcconct", "avCConfig", "avccyntext", "avccoonstruct", "avaccondct", "avcconsole", "avcconttex", "avccontclient", "avcelloconject", "avcconttext", "avacconct", "avccaontex", "avckoncurrent", "avcconstem", "avccaystant", "avctonfig", "avcfoncert", "avccoconject", "avncynload", "avctronstant", "avctonstant", "avceonfigure", "avccantonstruct", "avccanonth", "avcconnect", "avcellanonkey", "avcclasstext", "avccannect", "avccattext", "avcellanoncontext", "avctronect", "avclonsole", "avccondsole", "avccaontext", "avccynsole", "avncontxt", "avcclasste", "avccxonstem", "avcellocontext", "avcusontex", "avcconystant", "avcconkey", "avcusocontext", "avcconyfigure", "avccondstant", "avccoconect", "avccaonnect", "avccoconsole", "avcconsnect", "avckonject", "avccatect", "avCContext", "avcconstant", "avccatstem", "avccynfig", "avckoconject", "avcelloncontext", "avncontext", "avccalasstex", "avccynload", "avckontex", "avccorecontext", "avcfoconcert", "avcconect", "avaccondtext", "avccronsole", "avcconsject", "avcconttxt", "avccronth", "avccaonte", "avcconfigure", "avccenconnection", "avcloonsole", "avcellonth", "avcfonect", "avcconth", "avccxontext", "avcconycontext", "avccoconcontext", "avcconssole", "avccoonsole", "avctaystant", "avckonect", "avccanonkey", "avceontext", "avaccondsole", "avccanonect", "avcellanonstant", "avccocontex", "avcusoconconnection", "avccaycontext", "avcfonject", "avccondct", "avcellonfig", "avccnnect", "avccanject", "avccxonect", "avcusocontex", "avckoretex", "avCConcontext", "avccancert", "avccontstruct", "avccorestant", "avccalassnect", "avcconcontext", "avccanontext", "avccontkey", "avccayect", "avcellonject", "avccacontext", "avcconcurrent", "avccoretext", "avckontext", "avccustomect", "avcconasole", "avccontload", "avccnfig", "avccroncurrent", "avctaycontext", "avCContcontext", "avccantonsole", "avcloontext", "avcellontxt", "avcclasstex", "avctonect", "avccoconcert", "avcconystem", "avccntext", "avcconytex"], "context": ["contact", "kernel", "engine", "parent", "tx", "cf", "reference", "options", "Context", "network", "address", "condition", "man", "host", "component", "config", "language", "c", "profile", "event", "buffer", "local", "command", "translation", "metadata", "module", "ctx", "function", "environment", "instance", "connection", "capacity", "information", "chain", "data", "location", "info", "document", "text", "interface", "history", "mc", "window", "support", "package", "check", "content", "cc", "index"], "cfreq": ["lfrequ", "cfq", " cfrequire", "lfrequest", "czrequire", "fwrequ", " cfqq", "fwq", "czrr", "fcrr", "cfrequest", "lfq", "cloudrequire", "cfrequire", "czreq", " cfrr", "cfrr", "czq", "czqq", "cloudrequ", "lfreq", "fcrequ", "cfrequ", "fcreq", "czrequest", "fcrequest", "cloudqq", " cfrequest", "fwreq", "cloudreq", "cfqq", "czrequ", "fwrequest", " cfrequ"]}}
{"project": "FFmpeg", "commit_id": "439c3d5bcc4a4560eaf5fd43c6e156e3d9bc42f2", "target": 1, "func": "static int encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                        const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    NellyMoserEncodeContext *s = avctx->priv_data;\n\n    int ret;\n\n\n\n    if (s->last_frame)\n\n        return 0;\n\n\n\n    memcpy(s->buf, s->buf + NELLY_SAMPLES, NELLY_BUF_LEN * sizeof(*s->buf));\n\n    if (frame) {\n\n        memcpy(s->buf + NELLY_BUF_LEN, frame->data[0],\n\n               frame->nb_samples * sizeof(*s->buf));\n\n        if (frame->nb_samples < NELLY_SAMPLES) {\n\n            memset(s->buf + NELLY_BUF_LEN + avctx->frame_size, 0,\n\n                   (NELLY_SAMPLES - frame->nb_samples) * sizeof(*s->buf));\n\n            if (frame->nb_samples >= NELLY_BUF_LEN)\n\n                s->last_frame = 1;\n\n        }\n\n        if ((ret = ff_af_queue_add(&s->afq, frame) < 0))\n\n            return ret;\n\n    } else {\n\n        memset(s->buf + NELLY_BUF_LEN, 0, NELLY_SAMPLES * sizeof(*s->buf));\n\n        s->last_frame = 1;\n\n    }\n\n\n\n    if ((ret = ff_alloc_packet(avpkt, NELLY_BLOCK_LEN))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");\n\n        return ret;\n\n    }\n\n    encode_block(s, avpkt->data, avpkt->size);\n\n\n\n    /* Get the next frame pts/duration */\n\n    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,\n\n                       &avpkt->duration);\n\n\n\n    *got_packet_ptr = 1;\n\n    return 0;\n\n}\n", "idx": 24400, "substitutes": {"avctx": ["vrcu", "wavcu", "ivercontext", "avecontext", "auconn", "averctx", "abcontext", "aftx", "ajctx", "auctx", "apcontext", "iverctrl", " avcu", "avercontext", " avctrl", "avercu", "ajjac", "avcu", "avjac", "wavctx", "vrconn", "avconn", "avectx", "vrcontext", "afctx", " avjac", " avconn", "abtx", "apctx", "ajcontext", "avtx", "vrctx", "aucu", " avtx", "abctx", "apctrl", "avecu", "afcontext", "ajcu", "iverctx", "avejac", "avpkg", "wavcontext", " avpkg", "avctrl", "abpkg", "apconn", "wavconn", "iverconn", "averconn", "afpkg", " avcontext", "avcontext", "aucontext"], "avpkt": ["aveopacket", "avwpkt", "ahpet", "avcompoint", "afcft", "avepft", "avpingcht", "avpodacket", "avvkt", "avmett", "averpingqt", "afckt", "avpodft", "avopkt", "avPoint", "avpelt", "averpett", "avpett", "avpacket", "avhelt", "avpackett", "ahpkat", "avcpkat", "avpkat", "avpkg", "avpadcht", "afcelt", "averpkt", "afpelt", "avpaett", "campkg", "avvacket", "avhft", "averpqt", "avwpft", "avphpkt", "avcpet", "avptxt", "avpackkg", "avcpkt", "avpcht", "avjet", "avpqt", "avjft", "avpft", "avpet", "campackacket", "avcett", "avwpacket", "avcpwk", "aveoptxt", "ahphpkat", "avcelt", "avmqt", "avtpkat", "campkt", "avjelt", "averpingcht", "afcet", "avpackacket", "avcompkt", "afpet", "avtpwk", "ahphpwk", "avcompett", "avtpet", "avPgt", "ahphpkt", "avpodkt", "averpingkt", "avmcht", "avvkg", "avphpkat", "avPkt", "avpingett", "avhkt", " avPgt", "avoptxt", "aveopft", "aveptxt", "avtpkt", " avPett", "avckt", "avopft", " avpoint", "avphpwk", "avcompgt", "avpadkt", "avpingqt", "avjkt", "campackkt", "avckg", "avpadqt", "averpcht", "campett", "avcacket", "ahphpet", "avpackkt", "avpgt", " avpett", " avPoint", "campackett", "avpodtxt", "avpingkt", "ahpwk", "avpaoint", "avphpet", " avpgt", "campacket", "afpkt", "avhet", "avepacket", "averpingett", "ahpkt", "avcft", "avpoint", "afpft", " avPkt", "avmkt", "avpwk", "avvett", "avopacket", "avpadett", "aveopkt", "avPett", "avcet", "avpagt", "avwptxt", "campackkg", "avpakt", "avepkt"], "frame": ["f", "block", "fb", "range", "context", "field", "fram", "movie", "cf", "force", "ence", "ce", "zone", "fw", "feature", "Frame", "component", "from", "normal", "flow", "fr", "profile", "word", "event", "video", "request", "error", "object", "sample", "command", "row", "framework", "header", "me", "r", "close", "state", "new", "call", "frames", "rame", "function", "message", "show", "image", "sequence", "next", "face", "process", "file", " Frame", "ime", "xf", "data", "response", "chain", "feat", "info", "iframe", "window", "fe", "version", "e", "draw", "time", "style", "channel", "trace", "scene", "point", "one"], "got_packet_ptr": ["got_packet_obj", "got_packacket_ptr", "got_packkt_Ptr", "got_packkt_ptr", "got_packet_addr", "got_packet2addr", "got_packacket_addr", "got_packacket2obj", "got_packkt_pointer", "got_packkt_addr", "got_packet2obj", "got_packet2ptr", "got_packacket2addr", "got_packet2Ptr", "got_packet_Ptr", "got_packet_pointer", "got_packacket_pointer", "got_packacket2pointer", "got_packet2pointer", "got_packacket_obj", "got_packacket2ptr"], "s": ["comm", "c", "changes", "alls", "ares", "ains", "aws", "bits", "vs", "S", "xs", "ns", "ies", "y", "less", "h", "ows", "sq", "ess", "i", "sb", "os", "rs", "us", "ges", "scl", "sl", "spec", "n", "sc", "cs", "services", "als", "ats", "ts", "ims", "acs", "tes", "its", "ers", "parts", "m", "sys", "ms", "as", "ins", "simple", "gets", "results", "has", "bis", "lines", "sts", "sw", "iss", "bs", "is", "b", "l", "ps", "stats", "gs", "ls", "ssl", "se", "fs", "ex", "ds", "hs", "g", "set", "js", "ss", "uns", "qs", "es", "sv", "self", "utils", "conf"], "ret": ["f", "it", "alt", "lit", "out", "red", "err", "reset", "ll", "RET", "ref", "re", "pas", "len", "status", "try", "rm", "att", "gt", "def", "value", "result", "cont", "ry", "reg", "del", "ext", "mel", "det", "deg", "cert", "compl", "resp", "new", "pret", "rem", "print", "fit", "rt", "back", "nt", "fun", "rets", "virtual", "txt", "ft", " Ret", "val", "flag", "mt", "Ret", "tr", "elt", "t", "final", "str", "res"]}}
{"project": "FFmpeg", "commit_id": "7167bc94cb695a3027aea6aac34a1b040848c7dc", "target": 1, "func": "static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float bias)\n\n{\n\n    IndividualChannelStream *ics = &sce->ics;\n\n    float *in    = sce->coeffs;\n\n    float *out   = sce->ret;\n\n    float *saved = sce->saved;\n\n    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;\n\n    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;\n\n    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;\n\n    float *buf  = ac->buf_mdct;\n\n    float *temp = ac->temp;\n\n    int i;\n\n\n\n    // imdct\n\n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n        if (ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE)\n\n            av_log(ac->avctx, AV_LOG_WARNING,\n\n                   \"Transition from an ONLY_LONG or LONG_STOP to an EIGHT_SHORT sequence detected. \"\n\n                   \"If you heard an audible artifact, please submit the sample to the FFmpeg developers.\\n\");\n\n        for (i = 0; i < 1024; i += 128)\n\n            ff_imdct_half(&ac->mdct_small, buf + i, in + i);\n\n    } else\n\n        ff_imdct_half(&ac->mdct, buf, in);\n\n\n\n    /* window overlapping\n\n     * NOTE: To simplify the overlapping code, all 'meaningless' short to long\n\n     * and long to short transitions are considered to be short to short\n\n     * transitions. This leaves just two cases (long to long and short to short)\n\n     * with a little special sauce for EIGHT_SHORT_SEQUENCE.\n\n     */\n\n    if ((ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE) &&\n\n            (ics->window_sequence[0] == ONLY_LONG_SEQUENCE || ics->window_sequence[0] == LONG_START_SEQUENCE)) {\n\n        ac->dsp.vector_fmul_window(    out,               saved,            buf,         lwindow_prev, bias, 512);\n\n    } else {\n\n        for (i = 0; i < 448; i++)\n\n            out[i] = saved[i] + bias;\n\n\n\n        if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n            ac->dsp.vector_fmul_window(out + 448 + 0*128, saved + 448,      buf + 0*128, swindow_prev, bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      bias, 64);\n\n            memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));\n\n        } else {\n\n            ac->dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, bias, 64);\n\n            for (i = 576; i < 1024; i++)\n\n                out[i] = buf[i-512] + bias;\n\n        }\n\n    }\n\n\n\n    // buffer update\n\n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n        for (i = 0; i < 64; i++)\n\n            saved[i] = temp[64 + i] - bias;\n\n        ac->dsp.vector_fmul_window(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 0, 64);\n\n        ac->dsp.vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 0, 64);\n\n        ac->dsp.vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 0, 64);\n\n        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n\n    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {\n\n        memcpy(                    saved,       buf + 512,        448 * sizeof(float));\n\n        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n\n    } else { // LONG_STOP or ONLY_LONG\n\n        memcpy(                    saved,       buf + 512,        512 * sizeof(float));\n\n    }\n\n}\n", "idx": 24424, "substitutes": {"ac": ["aic", "ic", "mac", "ad", "cam", "jac", "cu", "rac", "acer", "comm", "bc", "AC", "pc", "aci", "c", "tc", "abc", "dc", "pac", "ica", "ec", "act", "ack", "ace", "cache", "cs", "sac", "acl", "ctx", "aco", "ap", "acc", "iac", "ach", "am", "ct", "auc", "oc", "anc", "fac", "acs", "unc", "cas", "mc", "fc", "ak", "gc", "ab", "Ac", "cc", "aq"], "sce": [" sse", "mske", "msced", "desse", "osced", "Sces", "sces", " sced", "sscle", "deske", "ssced", "descle", "nscle", " scle", "ssces", "msce", "nse", "nsse", "ssce", "Sce", "ncle", "osces", " spe", "scle", "osce", "Scle", "spe", "jscle", "sced", "nsce", "jsCE", "sse", "jsce", "npe", "jske", "desCE", "oscle", " sces", "sCE", "nce", "ske", "msse", "nspe", "desce", "Sse", "desces", " ske"], "bias": ["maos", "blias", "bade", "dau", "bac", "lias", "rbac", "lase", "ambaos", "bases", "mase", "lases", "Bias", "Base", "lau", "bau", " bac", "blade", "sbases", "blaid", "bii", "sbase", "dias", "Bii", "ambias", "ambase", "blac", "rbaid", "ambii", "baid", "mias", "dases", "rbias", "baos", "sbau", "rbade", "sbias", "base", " baid", "dase", "Baos", "mii", " bade"], "ics": ["sys", "aic", "ic", "irc", "ms", "icons", "irs", "css", "ives", "ians", "uses", "ists", "atics", "ik", "ins", "ix", "onics", "ick", "nuts", "phones", "fs", "xes", "iques", "icc", " ic", "nic", "iers", "amps", "mic", "iris", "his", "caps", "ices", "tis", "cus", "fps", "ents", "cs", "ints", "ars", "ands", "bs", "ICS", "xs", "cons", "is", "ats", "ts", "ns", "ims", "eric", "acs", "rics", "icals", "stats", "qs", "terms", "mc", "icates", "aps", "its", "IC", "inks", "ads", "icing", "oms", "actions", "ris", "ires", "atts", "checks", "icks", "ips"], "in": ["isin", "it", "inf", "inc", "min", "ins", "ref", "len", "ex", "ini", "id", "mem", "mm", "gin", "pin", "add", "input", "vin", "mi", "into", "oin", "raw", "inner", "rin", "ind", "In", "info", "inn", "din", "nin", "bin", "iter", "val", "en", "IN", "qi", "m", "init"], "out": ["f", "it", "ch", "batch", "o", "ref", "v", "w", "ex", "result", "output", "at", "mem", "buffer", "r", "list", "n", "p", "cache", "io", "new", "set", "to", "pos", "up", "outs", "Out", "b", "data", "nt", "ou", "OUT", "ret", "off", "t", "tmp", "final", "all", "ot", "end", "res"], "saved": ["saving", "Sorted", "maves", "unsave", "unsaves", "assaved", "unsaled", "assaled", "daving", "maved", "jsaved", "assaving", "Saving", "sorted", "daves", " saled", "dave", "unsaving", "Saves", "saves", "jsave", "saled", "morted", " save", "daved", "save", "assave", "mave", " saving", "Saved", "unsaved", "jsaving", " saves", "jsaves", "Save", " sorted"], "swindow": ["twindew", "swandow", "swinkox", "swidthowe", "swidthow", "swinkew", "swinkow", "swidthox", "twandowe", "twindowe", "twandox", "twindow", "swandowe", "swindowe", "swandox", "swandew", "twandow", "twandew", "swindew", "twindox", "swinkowe", "swidthew", "swindox"], "lwindow_prev": ["lwindow_pre", "lwindow_last", "lwindow2next", "lwindow_orig", "lwindow2last", "lwindow_next", "lwindow2prev", "lwindow2pre"], "swindow_prev": ["swindew_tmp", "swindow_orig", "swindew_prev", "swindow_tmp", "swindew_pre", "swindow_pre", "swindew_orig"], "buf": ["block", "uc", "batch", "cam", "queue", "uf", "ff", "box", "len", "bc", "buffer", "mem", "seq", "var", "cmd", "pool", "Buff", "cache", "memory", "img", "msg", "cb", " vec", "vec", "raw", "wb", "txt", "window", "alloc", "lim", "bin", "limit", "iter", "rb", "rw", "cap", "Buffer", "buff", "pkg", "off", "BU", "tmp", "xff", "proc", "conv", "init", "cv"], "temp": ["dim", "tm", "unit", "water", "w", "emp", "pi", "tc", "hum", "mem", "mm", "dev", "buffer", "height", "tem", "cache", "deg", "dest", "rem", "mint", "pos", "tim", "acc", "test", "fac", "num", "strength", "kw", "cap", "current", "tmp", "t", "m", "v", "em", "pt", "Temp"], "i": ["ui", " j", "o", "ini", "id", "spin", "I", "p", "s", "sim", "ai", "li", "info", "ip", "ij", "y", "ci", "iu", "si", "ei", "ji", "ki", "\u0438", " x", "us", " ni", " ii", "remote", "io", "j", "init", "ind", "ims", "iter", "uri", "m", "point", " l", "qi", "ix", "x", "multi", "ami", "ri", "phi", "di", "zi", " v", "mi", "ii", "is", " ti", " pi", " m", "xi", "im", "q", "f", "it", "ic", "pi", " ki", "g", "me", "gi", " e", "iq", "ti", "e", "u", "t", "index", "Xi", "cli"]}}
{"project": "FFmpeg", "commit_id": "70d54392f5015b9c6594fcae558f59f952501e3b", "target": 0, "func": "void ff_dsputil_init_alpha(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n    const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n    if (!high_bit_depth) {\n\n    c->put_pixels_tab[0][0] = put_pixels16_axp_asm;\n\n    c->put_pixels_tab[0][1] = put_pixels16_x2_axp;\n\n    c->put_pixels_tab[0][2] = put_pixels16_y2_axp;\n\n    c->put_pixels_tab[0][3] = put_pixels16_xy2_axp;\n\n\n\n    c->put_no_rnd_pixels_tab[0][0] = put_pixels16_axp_asm;\n\n    c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_axp;\n\n    c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_axp;\n\n    c->put_no_rnd_pixels_tab[0][3] = put_no_rnd_pixels16_xy2_axp;\n\n\n\n    c->avg_pixels_tab[0][0] = avg_pixels16_axp;\n\n    c->avg_pixels_tab[0][1] = avg_pixels16_x2_axp;\n\n    c->avg_pixels_tab[0][2] = avg_pixels16_y2_axp;\n\n    c->avg_pixels_tab[0][3] = avg_pixels16_xy2_axp;\n\n\n\n    c->avg_no_rnd_pixels_tab[0][0] = avg_no_rnd_pixels16_axp;\n\n    c->avg_no_rnd_pixels_tab[0][1] = avg_no_rnd_pixels16_x2_axp;\n\n    c->avg_no_rnd_pixels_tab[0][2] = avg_no_rnd_pixels16_y2_axp;\n\n    c->avg_no_rnd_pixels_tab[0][3] = avg_no_rnd_pixels16_xy2_axp;\n\n\n\n    c->put_pixels_tab[1][0] = put_pixels_axp_asm;\n\n    c->put_pixels_tab[1][1] = put_pixels_x2_axp;\n\n    c->put_pixels_tab[1][2] = put_pixels_y2_axp;\n\n    c->put_pixels_tab[1][3] = put_pixels_xy2_axp;\n\n\n\n    c->put_no_rnd_pixels_tab[1][0] = put_pixels_axp_asm;\n\n    c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels_x2_axp;\n\n    c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels_y2_axp;\n\n    c->put_no_rnd_pixels_tab[1][3] = put_no_rnd_pixels_xy2_axp;\n\n\n\n    c->avg_pixels_tab[1][0] = avg_pixels_axp;\n\n    c->avg_pixels_tab[1][1] = avg_pixels_x2_axp;\n\n    c->avg_pixels_tab[1][2] = avg_pixels_y2_axp;\n\n    c->avg_pixels_tab[1][3] = avg_pixels_xy2_axp;\n\n\n\n    c->avg_no_rnd_pixels_tab[1][0] = avg_no_rnd_pixels_axp;\n\n    c->avg_no_rnd_pixels_tab[1][1] = avg_no_rnd_pixels_x2_axp;\n\n    c->avg_no_rnd_pixels_tab[1][2] = avg_no_rnd_pixels_y2_axp;\n\n    c->avg_no_rnd_pixels_tab[1][3] = avg_no_rnd_pixels_xy2_axp;\n\n\n\n    c->clear_blocks = clear_blocks_axp;\n\n    }\n\n\n\n    /* amask clears all bits that correspond to present features.  */\n\n    if (amask(AMASK_MVI) == 0) {\n\n        c->put_pixels_clamped = put_pixels_clamped_mvi_asm;\n\n        c->add_pixels_clamped = add_pixels_clamped_mvi_asm;\n\n\n\n        if (!high_bit_depth)\n\n            c->get_pixels   = get_pixels_mvi;\n\n        c->diff_pixels      = diff_pixels_mvi;\n\n        c->sad[0]           = pix_abs16x16_mvi_asm;\n\n        c->sad[1]           = pix_abs8x8_mvi;\n\n        c->pix_abs[0][0]    = pix_abs16x16_mvi_asm;\n\n        c->pix_abs[1][0]    = pix_abs8x8_mvi;\n\n        c->pix_abs[0][1]    = pix_abs16x16_x2_mvi;\n\n        c->pix_abs[0][2]    = pix_abs16x16_y2_mvi;\n\n        c->pix_abs[0][3]    = pix_abs16x16_xy2_mvi;\n\n    }\n\n\n\n    put_pixels_clamped_axp_p = c->put_pixels_clamped;\n\n    add_pixels_clamped_axp_p = c->add_pixels_clamped;\n\n\n\n    if (avctx->bits_per_raw_sample <= 8 &&\n\n        (avctx->idct_algo == FF_IDCT_AUTO ||\n\n         avctx->idct_algo == FF_IDCT_SIMPLEALPHA)) {\n\n        c->idct_put = ff_simple_idct_put_axp;\n\n        c->idct_add = ff_simple_idct_add_axp;\n\n        c->idct =     ff_simple_idct_axp;\n\n    }\n\n}\n", "idx": 24426, "substitutes": {"c": ["f", "cl", "ic", "ch", "uc", "cam", "ce", "ca", "cu", "bc", "d", "pc", "config", "w", "pi", "tc", "abc", "rc", "dc", "cont", "ec", "g", "cp", "p", "cache", "sc", "nc", "cs", "cb", "cm", "call", "can", "ctx", "enc", "com", "co", "chain", "comp", "b", "ct", "xc", "ac", "anc", "unc", "l", "cr", "vc", "ci", "mc", "st", "con", "fc", "e", "check", "etc", "gc", "t", "cc", "C", "v", "lc", "m", "conf"], "avctx": ["avco", "averctx", "AVco", "avercontext", " avco", "avtc", "AVctx", "avconn", "vconn", "averco", " avconn", "vcontext", "vtc", "AVcontext", " avtc", "vctx", "averconn", "avertc", " avcontext", "avcontext", "AVconn"]}}
{"project": "FFmpeg", "commit_id": "2bb62455c899cdccbdc2a6ad33f9582008ed9f05", "target": 0, "func": "static char *check_nan_suffix(char *s)\n\n{\n\n    char *start = s;\n\n\n\n    if (*s++ != '(')\n\n        return start;\n\n\n\n    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||\n\n           (*s >= '0' && *s <= '9') ||  *s == '_')\n\n        s++;\n\n\n\n    return *s == ')' ? s + 1 : start;\n\n}\n", "idx": 24433, "substitutes": {"s": ["status", "comm", "d", "c", "r", "times", "pers", "ar", "p", "ares", "sym", "S", "gins", "xs", "ns", "y", "z", "less", "si", "h", "v", "sq", "ess", "i", "sb", "args", "search", "os", "rs", "sl", "n", "cs", "ats", "ts", "ims", "tes", "its", "m", "ix", "sys", "ms", "as", "ins", "gets", "has", "sts", "a", "is", "b", "l", "ps", "stats", "gs", "single", "ls", "f", "ports", "fs", "sol", "w", "ds", "hs", "g", "sets", "an", "ars", "span", "js", "ss", "uns", "qs", "south", "es", "sp", "sv", "t", "res"], "start": ["it", "join", "length", "i", "trans", "rest", "star", "begin", "d", "part", "first", "value", "id", "error", "starting", "g", "started", "list", "p", "state", "new", "j", "span", "art", "next", "stop", "arts", "key", "step", "st", "base", "sp", "Start", "offset", "before", "end", "tmp", "q", "index", "v", "str", "init", "name"]}}
{"project": "FFmpeg", "commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "target": 1, "func": "static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){\n\n    long i;\n\n#if !HAVE_FAST_UNALIGNED\n\n    if((long)src2 & (sizeof(long)-1)){\n\n        for(i=0; i+7<w; i+=8){\n\n            dst[i+0] = src1[i+0]-src2[i+0];\n\n            dst[i+1] = src1[i+1]-src2[i+1];\n\n            dst[i+2] = src1[i+2]-src2[i+2];\n\n            dst[i+3] = src1[i+3]-src2[i+3];\n\n            dst[i+4] = src1[i+4]-src2[i+4];\n\n            dst[i+5] = src1[i+5]-src2[i+5];\n\n            dst[i+6] = src1[i+6]-src2[i+6];\n\n            dst[i+7] = src1[i+7]-src2[i+7];\n\n        }\n\n    }else\n\n#endif\n\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n\n        long a = *(long*)(src1+i);\n\n        long b = *(long*)(src2+i);\n\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n\n    }\n\n    for(; i<w; i++)\n\n        dst[i+0] = src1[i+0]-src2[i+0];\n\n}\n", "idx": 24472, "substitutes": {"dst": ["Dput", "draentry", "delcr", " dentry", "delstart", " dstart", "dsee", "redst", " dpt", "Dist", "Dst", " dist", "dsest", "dstop", "Ddest", "donesl", "dradest", " dbl", " dput", "Dct", " dcr", " dbsp", " dest", "dasee", "dhport", "tddest", "dast", "dhentry", "dpt", "disdest", "dlst", "dsv", "dbsp", " dsee", "dsist", "dstart", "doneld", "dact", "dv", "bdbsp", "dastart", "tdest", "disst", "dsl", "dlstop", " dct", "dST", "drast", "sdST", "dput", "DST", "donedest", "Dset", "tdst", "dbl", "bdbl", "draport", "disport", "dset", "redist", "bdport", "disbsp", "dsset", " dv", "dlsl", "dentry", "drabsp", "sdst", " dport", "dhst", "dport", "drasl", "dsst", "sdset", " ddest", "dabsp", "dsput", "Dbl", "redct", "dsct", "tdpt", "dlld", "dhdest", "redbsp", "donest", "dct", "dsST", "donestop", "donesee", "dsbl", "dacr", "Dpt", "drald", "donebsp", "delst", "dcr", "dld", "dest", "dist", "drabl", "Dest", "sdbl", "Dv", "deldest", "drastop", "bdst", "dadest", "ddest", "daist"], "src1": ["source0", "attr1", "source1", " src001", "attr2", "rc0", "src01", "usc2", " src01", "srcOne", "rcone", "sourceone", "proc1", "inst0", "sourceOne", "rc01", "usrOne", "src3", "rc001", "srcone", "proc3", "usr1", " srcone", "instOne", "usr001", "inst1", "rc3", "rcOne", "usc1", "instone", "src0", "source2", "rc2", "rc1", "uscOne", " srcOne", "usr2", "proc01", "inst2", " src0", "source01", "src001", "attrOne", "proc2", " src3"], "src2": ["sur2", "source1", "cur1", " src4", " src02", "usc2", "src6", "iv42", "ser2", "iv6", "src42", "sync2", "secure02", "rc2", "rcTwo", "ser3", "rc4", "sync1", "cmd1", "srcserver", "cmd2", "priv2", "srclib", "sync42", " src9", "ripp1", "src14", "sync6", "iv2", "rc3", "src0", "source2", " srcserver", "ripp02", "src4", "secure4", "src9", "func1", "sur1", "srcb", " src0", "proc2", "rc6", "rc02", "ripp9", "procb", "stocklib", "source6", "rc9", "rclib", "func4", "stock22", "source4", "usc22", "secure2", "srcTwo", "rc14", "secure1", "sur02", "ripp2", "rc22", "rc1", "usclib", "cur4", "priv1", "src22", " src3", "surserver", "iv1", "stock2", "source0", "proc0", "func2", "rc0", "secure6", "priv14", "rcb", "rcserver", "proc1", "cmd14", "rc42", "src3", "source3", "usc1", "cur2", "ser1", " srcTwo", "stock1", "sourceb", "src02", "serTwo"], "w": ["f", "W", "x", "len", "week", "iw", "wh", "v", "d", "c", "word", "ew", "wait", "wr", "wl", "r", "n", "p", "we", "sw", " W", "nw", "wa", "l", "wb", "y", "wp", "wt", "window", "wi", "z", "rw", "kw", "wal", "win", "h", "m", "wx", "hw"], "i": ["ui", " j", "o", "status", "ini", "id", "er", "um", "in", "I", "p", " bi", "sim", "ai", "li", "info", "ip", "ij", "y", "ci", "iu", " I", "si", "h", "v", "ei", "ji", "ki", "\u0438", "os", "try", " ni", " ii", "at", "gu", "n", "io", "j", "asi", "chain", "ind", "ims", "key", "uri", "iter", "ni", "m", "qi", "ix", "iii", "batch", "x", "multi", "ami", "k", "yi", "ri", "iy", "phi", "di", "oi", "zi", "go", " err", "mi", "ii", "is", "l", " ti", "bi", "ir", "xi", "im", "q", "this", "f", "iri", "it", "ic", "err", "ma", "pi", "ia", "fi", "g", "me", "gi", "list", "hi", "ti", "json", "e", "u", "source", "index", "cli", "init", "name"]}}
{"project": "FFmpeg", "commit_id": "cb85779d459c6486acbbf060b3f169779424583e", "target": 0, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data,\n\n                        int *got_frame,\n\n                        AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    DPXContext *const s = avctx->priv_data;\n\n    AVFrame *picture  = data;\n\n    AVFrame *const p = &s->picture;\n\n    uint8_t *ptr[AV_NUM_DATA_POINTERS];\n\n\n\n    unsigned int offset;\n\n    int magic_num, endian;\n\n    int x, y, i, ret;\n\n    int w, h, bits_per_color, descriptor, elements, packing, total_size;\n\n\n\n    unsigned int rgbBuffer = 0;\n\n    int n_datum = 0;\n\n\n\n    if (avpkt->size <= 1634) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small for DPX header\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    magic_num = AV_RB32(buf);\n\n    buf += 4;\n\n\n\n    /* Check if the files \"magic number\" is \"SDPX\" which means it uses\n\n     * big-endian or XPDS which is for little-endian files */\n\n    if (magic_num == AV_RL32(\"SDPX\")) {\n\n        endian = 0;\n\n    } else if (magic_num == AV_RB32(\"SDPX\")) {\n\n        endian = 1;\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"DPX marker not found\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    offset = read32(&buf, endian);\n\n    if (avpkt->size <= offset) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid data start offset\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    // Need to end in 0x304 offset from start of file\n\n    buf = avpkt->data + 0x304;\n\n    w = read32(&buf, endian);\n\n    h = read32(&buf, endian);\n\n    if ((ret = av_image_check_size(w, h, 0, avctx)) < 0)\n\n        return ret;\n\n\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n\n\n    // Need to end in 0x320 to read the descriptor\n\n    buf += 20;\n\n    descriptor = buf[0];\n\n\n\n    // Need to end in 0x323 to read the bits per color\n\n    buf += 3;\n\n    avctx->bits_per_raw_sample =\n\n    bits_per_color = buf[0];\n\n    buf++;\n\n    packing = *((uint16_t*)buf);\n\n\n\n    buf += 824;\n\n    avctx->sample_aspect_ratio.num = read32(&buf, endian);\n\n    avctx->sample_aspect_ratio.den = read32(&buf, endian);\n\n    if (avctx->sample_aspect_ratio.num > 0 && avctx->sample_aspect_ratio.den > 0)\n\n        av_reduce(&avctx->sample_aspect_ratio.num, &avctx->sample_aspect_ratio.den,\n\n                   avctx->sample_aspect_ratio.num,  avctx->sample_aspect_ratio.den,\n\n                  0x10000);\n\n    else\n\n        avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n\n\n\n    switch (descriptor) {\n\n        case 51: // RGBA\n\n            elements = 4;\n\n            break;\n\n        case 50: // RGB\n\n            elements = 3;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported descriptor %d\\n\", descriptor);\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch (bits_per_color) {\n\n        case 8:\n\n            if (elements == 4) {\n\n                avctx->pix_fmt = AV_PIX_FMT_RGBA;\n\n            } else {\n\n                avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n            }\n\n            total_size = avctx->width * avctx->height * elements;\n\n            break;\n\n        case 10:\n\n            if (!packing) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Packing to 32bit required\\n\");\n\n                return -1;\n\n            }\n\n            avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n\n            total_size = (avctx->width * avctx->height * elements + 2) / 3 * 4;\n\n            break;\n\n        case 12:\n\n            if (!packing) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Packing to 16bit required\\n\");\n\n                return -1;\n\n            }\n\n            if (endian) {\n\n                avctx->pix_fmt = AV_PIX_FMT_GBRP12BE;\n\n            } else {\n\n                avctx->pix_fmt = AV_PIX_FMT_GBRP12LE;\n\n            }\n\n            total_size = 2 * avctx->width * avctx->height * elements;\n\n            break;\n\n        case 16:\n\n            if (endian) {\n\n                avctx->pix_fmt = elements == 4 ? AV_PIX_FMT_RGBA64BE : AV_PIX_FMT_RGB48BE;\n\n            } else {\n\n                avctx->pix_fmt = elements == 4 ? AV_PIX_FMT_RGBA64LE : AV_PIX_FMT_RGB48LE;\n\n            }\n\n            total_size = 2 * avctx->width * avctx->height * elements;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported color depth : %d\\n\", bits_per_color);\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->picture.data[0])\n\n        avctx->release_buffer(avctx, &s->picture);\n\n    if ((ret = ff_get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    // Move pointer to offset from start of file\n\n    buf =  avpkt->data + offset;\n\n\n\n    for (i=0; i<AV_NUM_DATA_POINTERS; i++)\n\n        ptr[i] = p->data[i];\n\n\n\n    if (total_size > avpkt->size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Overread buffer. Invalid header?\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    switch (bits_per_color) {\n\n    case 10:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            uint16_t *dst[3] = {(uint16_t*)ptr[0],\n\n                                (uint16_t*)ptr[1],\n\n                                (uint16_t*)ptr[2]};\n\n            for (y = 0; y < avctx->width; y++) {\n\n                *dst[2]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                *dst[0]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                *dst[1]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                // For 10 bit, ignore alpha\n\n                if (elements == 4)\n\n                    read10in32(&buf, &rgbBuffer,\n\n                               &n_datum, endian);\n\n            }\n\n            for (i = 0; i < 3; i++)\n\n                ptr[i] += p->linesize[i];\n\n        }\n\n        break;\n\n    case 12:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            uint16_t *dst[3] = {(uint16_t*)ptr[0],\n\n                                (uint16_t*)ptr[1],\n\n                                (uint16_t*)ptr[2]};\n\n            for (y = 0; y < avctx->width; y++) {\n\n                *dst[2] = *((uint16_t*)buf);\n\n                *dst[2] = (*dst[2] >> 4) | (*dst[2] << 12);\n\n                dst[2]++;\n\n                buf += 2;\n\n                *dst[0] = *((uint16_t*)buf);\n\n                *dst[0] = (*dst[0] >> 4) | (*dst[0] << 12);\n\n                dst[0]++;\n\n                buf += 2;\n\n                *dst[1] = *((uint16_t*)buf);\n\n                *dst[1] = (*dst[1] >> 4) | (*dst[1] << 12);\n\n                dst[1]++;\n\n                buf += 2;\n\n                // For 12 bit, ignore alpha\n\n                if (elements == 4)\n\n                    buf += 2;\n\n            }\n\n            for (i = 0; i < 3; i++)\n\n                ptr[i] += p->linesize[i];\n\n        }\n\n        break;\n\n    case 16:\n\n        elements *= 2;\n\n    case 8:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            memcpy(ptr[0], buf, elements*avctx->width);\n\n            ptr[0] += p->linesize[0];\n\n            buf += elements*avctx->width;\n\n        }\n\n        break;\n\n    }\n\n\n\n    *picture   = s->picture;\n\n    *got_frame = 1;\n\n\n\n    return buf_size;\n\n}\n", "idx": 24478, "substitutes": {"avctx": ["afctl", "avtmp", "averctx", "awsys", "aftx", "afcp", "verconn", "vrtc", "ajsys", "vrcontext", "avercp", "avetc", "vrctx", "verctx", "abcmp", "averctl", "wavcmp", "avectl", "wavjac", "wavsys", "awctx", "awconn", "avpkg", "averpkg", "avcmp", "aftmp", "awjac", "cvconn", "abtmp", "avertmp", "avecmd", "vrcmp", "navtxt", "aveobj", "cvctx", "vertx", "abcp", "vercontext", " avconn", "navobj", "avsys", "awpkg", "afpkg", " avcontext", "avetxt", "averobj", "avercmp", "avecontext", "ajctx", "avecmp", "awcp", "avtc", "vrconn", "avectx", "afctx", "avtxt", "abtx", "avtx", "abctx", "navctx", " avtc", "awcmd", "avcmd", "afcmp", "avertxt", "avecp", "avetx", "navcp", "aveconn", "cvcontext", "avcontext", "abcontext", " avcmp", "avobj", "avcp", "avctl", "cvtx", "ajjac", "wavctx", "avjac", "avertx", "wavcp", "avconn", "abconn", "abcmd", " avtx", "abpkg", "ajpkg", "wavpkg", "vrtx"], "data": ["padding", "device", "type", "action", "length", "batch", "media", "o", "pic", "ata", "d", "pad", "value", "id", "read", "video", "error", "buffer", "empty", "family", "original", "cache", "record", "pointer", "rel", "bytes", "root", "bits", "area", "to", "input", "policy", "message", "frame", "image", "Data", "next", "raw", "file", "a", "response", "share", "size", "info", "images", "page", "dat", "query", "start", "text", "window", "bin", "current", "package", "reader", "DATA", "table", "t", "format", "m", "sample", "name"], "got_frame": ["got_state", "got2frame", "got___frame", "received_frames", "received_time", "got___time", "got___frames", "received_frame", "got2frames", "got_frames", "got_time", "received_state", "got2time", "got___state", "got2state"], "avpkt": ["avcpett", "avwpkt", " avcpacket", "avepkat", "avppt", "avepct", "avpatkt", " avpdr", "avndr", "avpett", "avpacket", " avcppt", "aveckt", "avcpct", "avwpkg", " avcpet", "avpds", "avcpkat", "avpct", "avPacket", "avpkat", "avpkg", "avmck", "avpaett", "avcpdr", "avpdr", "avecpkt", "avcpet", "avdkt", "avPet", "avpatck", "avcpkt", "avcpck", " avpet", "avcpkg", "avedpt", "avPck", "avmkin", "avdkg", "avpet", "avdct", "iverpatkt", "avwpds", "avcett", "avwpacket", "avedct", "avepett", "avwpck", "iverpatacket", " avcpkt", "avpatkin", "avedkg", "avpatacket", "avpakat", "aveppt", "avcppt", "avckat", "avecct", "avPkt", "avpck", "avbpds", " avcpdr", "avcpds", " avpacket", "iverpck", "avepck", " avppt", "avbpacket", "iverpkt", "avckt", "avwppt", "avPdr", "avcpacket", " avpds", "avwpct", "iverpatck", "avepkg", "iverpkin", "avcct", "avbpkt", "avecett", "avmacket", "avepacket", "avnet", "avedkt", "avbppt", "avnacket", "avPkin", "avecpck", "avmkt", "avpkin", "avpact", "avdpt", "avecpct", "aveckat", "avecpacket", "avnkt", "avPct", "iverpacket", " avcpds", "avpakt", "iverpatkin", "avepkt"], "buf": ["bed", "cur", "pb", "queue", "bl", "ff", "_", "done", "ctr", "cont", "buffer", "mem", "var", "late", "pg", "new", "ctx", "bg", "raw", "orig", "wb", "pkg", "xff", "v", "env", "padding", "pack", "args", "emb", "obj", "br", "temp", "begin", "nb", "bc", "after", "bf", "func", "db", "cp", "msg", "bar", "bag", "next", "desc", "window", "bur", "bin", "bp", "Buffer", "fp", "buff", "packed", "batch", "length", "box", "pad", "pend", "def", "read", "keep", "bytes", "coord", "vec", "bs", "doc", "b", "dr", "text", "alloc", "limit", "rb", "off", "tr", "tmp", "aw", "cv", "block", "prop", "err", "nm", "ref", "uf", "len", "foo", "rc", "result", "zero", "far", "cmd", "important", "img", "cb", "usr", "paste", "np", "eb", "shift", "port", "txt", "aux", "cap", "proc", "conv"], "s": ["sys", "ms", "space", "sb", "csv", "os", "fs", "v", "rs", "c", "ds", "g", "cs", "sts", "S", "js", "ss", "a", "ats", "b", "ts", "ns", "ps", "acs", "qs", "stats", "es", "gs", "e", "sv", "ls", "t", "sq"], "picture": ["photo", "context", "media", "feature", "status", "piece", "profile", "audio", "video", "command", "path", "pen", "family", "camera", "img", "policy", "frame", "image", "settings", "information", "share", "conference", "images", "info", "document", "png", "pa", "query", "pict", "support", "style", "summary", "pkg", "table", "Picture", "format", "pic"], "p": ["f", "pb", "o", "pc", "pp", "c", "r", "cp", "n", "par", "j", "ap", "np", "a", "b", "ps", "pa", "sp", "u", "fp", "pkg", "P", "t", "jp", "m", "pic"], "ptr": ["err", "ref", "address", "br", "Ptr", "pad", "push", "ctr", "rev", "buffer", "pr", "ext", "pointers", "arr", "pointer", "rel", "pos", "vec", "desc", "attr", "dr", "src", "addr", "alloc", "tr", "str", "pt"], "AV_NUM_DATA_POINTERS": ["AV_NUM_DATA_POINTINGS", "AV_NUM_DATA_POINTERER", "AV_NUM_DATA_POINTER", "AV_NUM_DATA_PAINER", "AV_NUM_DATA_POINTERINGS", "AV_NUM_DATA_POADER", "AV_NUM_DATA_PAINTERS", "AV_NUM_DATA_POADers", "AV_NUM_DATA_POINTERers", "AV_NUM_DATA_POINTers", "AV_NUM_DATA_POINER", "AV_NUM_DATA_PAINERS", "AV_NUM_DATA_PAINTINGS", "AV_NUM_DATA_PAINTER", "AV_NUM_DATA_PAININGS", "AV_NUM_DATA_POININGS", "AV_NUM_DATA_PAINers", "AV_NUM_DATA_POADERS", "AV_NUM_DATA_PAINTers", "AV_NUM_DATA_POINTERERS", "AV_NUM_DATA_POINERS", "AV_NUM_DATA_POINers", "AV_NUM_DATA_POADINGS"], "offset": ["f", "padding", "type", "length", "out", "o", "address", "ref", "ff", "len", "pad", "error", "buffer", "row", "header", "offs", "pointer", "extra", "area", "et", "origin", "order", "pos", "expected", "image", "location", "size", "start", "shift", "page", "loc", "addr", "seek", "window", "position", "sp", "package", "slot", "off", "rot", "timeout", "end", "index", "point", "t", "Offset"], "magic_num": [" magic_mod", " magic_no", "magic_ord", "magic10mult", "magic_mult", "magicityNUM", " magic_unit", "magic_unit", " magic_ord", "magic_mod", "magic00mod", "magicityname", "magic_major", " magic_number", "magicitynum", "magic00num", "magic10ord", "magic00unit", "magic_NUM", "magic10number", " magic_major", "magic_no", " magic_mult", "magic_number", "magic10num", " magic_name", "magic_name", "magic00no", "magicitynumber", "magic00major", "magic00number", " magic_NUM"], "endian": ["indort", "endedior", "Endian", " endary", "Endians", "endedieval", "eastian", " endians", "endrian", "windort", "endary", "ENDrian", "endingicator", "endedian", "endingian", "ENDIAN", " enden", "easticator", "indorable", "EndIAN", "ENDen", " ender", "endieval", "endior", "windrian", " endort", "ENDians", "endingIAN", "eastians", " endalian", " endIAN", "endingrian", "endingalian", "ENDer", "endicator", " endior", " endorable", "endingians", "endalian", "indrian", "endedicator", "indian", "Enden", "endians", "endedIAN", "endinger", " endrian", "windian", "windorable", "endedians", "Endior", "endingieval", "eastalian", "ENDian", "eastary", "eastieval", "enden", "endIAN", "endorable", "endingary", "endort", "ender"], "x": ["tx", "o", "xy", "c", "ex", "index", "dx", "rx", "r", "n", "ax", "X", "xs", "a", "l", "xc", "ox", "px", "m", "v", "wx", "ix"], "y": ["my", "ch", "gy", "o", "xy", "dy", "yt", "yn", "c", "ty", "yy", "iy", "axy", "ny", "yl", "j", "hy", "b", "py", "ey", "ys", "Y", "ym", "sy", "m"], "i": ["f", "it", "pi", "c", "id", "g", "in", "I", "di", "j", "mi", "ii", "b", "l", "ind", "info", "ip", "ij", "ir", "ib", "iu", "si", "im", "index", "m", "ix"], "ret": ["f", "it", "alt", "not", "out", "err", "reset", "got", "RET", "ref", "re", "success", "status", "try", "tf", "gt", "def", "value", "result", "mem", "arr", "new", "resp", "rem", "j", "magic", "total", "print", "found", "rt", "back", "nt", "dr", "rets", "txt", "native", "ft", " Ret", "val", "vector", "flag", "Ret", "packed", "tr", "elt", "format", "callback", "res"], "w": ["wid", "W", "fw", "iw", "wh", "d", "widget", "ex", "ew", "wd", "ww", "wr", "g", "r", "n", "whe", "we", "sw", "nw", "wig", "wa", "l", "weights", "work", "wb", "wp", "wt", "wn", "window", "wi", "z", "rw", "win", "kw", "wal", "m", "wx", "aw", "hw"], "h": ["it", "hd", "ch", "length", "o", "ih", "hash", "ph", "host", "he", "wh", "d", "hr", "k", "hang", "hs", "high", "mk", "height", "ah", "n", "kh", "hz", "sh", "hal", "oh", "ht", "hei", "html", "hi", "b", "l", "size", "z", "uh", "bh", "ha", "H", "hh", "hl", "q", "m", "v", "ho", "hw"], "bits_per_color": ["bits_per_channel", "bits_per_component", "bits_PER_image", "bits_PER_pixel", "bits_PER_channel", "bits_PER_color", "bits_per_image", "bits_per_pixel", "bits_PER_component"], "descriptor": ["descripion", "descructor", "descripor", "desccriptator", "descructractor", "Desccriptors", "descripractor", "Descriptor", "descriptator", "descryption", "descryptor", "descriptractor", "decriptors", "descriptors", "Description", "descructator", "descructors", "descruction", "descripors", "decription", "Desccriptator", "Desccriptor", "desccriptractor", "deccriptors", "Descriptors", "desccription", "Descriptator", "deccription", "desccriptors", "decriptor", "desccriptor", "deccriptractor", "descryptors", "deccriptor", "decriptractor", "description", "descryptator", "Desccription"], "elements": ["eelement", "Elem", "mesections", "melem", "eesections", "esections", "Esections", "elem", "melements", "melement", "eelem", "element", "Elements", "Element", "eelements"], "packing": ["saving", "using", "padding", "locking", "ping", "pack", "length", "testing", "processing", "boxing", "power", "adding", "packs", "protection", "loading", "scoring", "ordering", "extra", "sharing", "checking", "rating", "sequence", "shift", "heading", "picking", "tracking", "working", "package", "fp", "forcing", "packed", "aging", "fitting", "pkg", "reading"], "total_size": ["total_count", " total_count", "total_SIZE", " total_SIZE", " total_space", "total_space"]}}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "static void gen_pool16c_insn(DisasContext *ctx, int *is_branch)\n\n{\n\n    int rd = mmreg((ctx->opcode >> 3) & 0x7);\n\n    int rs = mmreg(ctx->opcode & 0x7);\n\n    int opc;\n\n\n\n    switch (((ctx->opcode) >> 4) & 0x3f) {\n\n    case NOT16 + 0:\n\n    case NOT16 + 1:\n\n    case NOT16 + 2:\n\n    case NOT16 + 3:\n\n        gen_logic(ctx, OPC_NOR, rd, rs, 0);\n\n        break;\n\n    case XOR16 + 0:\n\n    case XOR16 + 1:\n\n    case XOR16 + 2:\n\n    case XOR16 + 3:\n\n        gen_logic(ctx, OPC_XOR, rd, rd, rs);\n\n        break;\n\n    case AND16 + 0:\n\n    case AND16 + 1:\n\n    case AND16 + 2:\n\n    case AND16 + 3:\n\n        gen_logic(ctx, OPC_AND, rd, rd, rs);\n\n        break;\n\n    case OR16 + 0:\n\n    case OR16 + 1:\n\n    case OR16 + 2:\n\n    case OR16 + 3:\n\n        gen_logic(ctx, OPC_OR, rd, rd, rs);\n\n        break;\n\n    case LWM16 + 0:\n\n    case LWM16 + 1:\n\n    case LWM16 + 2:\n\n    case LWM16 + 3:\n\n        {\n\n            static const int lwm_convert[] = { 0x11, 0x12, 0x13, 0x14 };\n\n            int offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_ldst_multiple(ctx, LWM32, lwm_convert[(ctx->opcode >> 4) & 0x3],\n\n                              29, offset << 2);\n\n        }\n\n        break;\n\n    case SWM16 + 0:\n\n    case SWM16 + 1:\n\n    case SWM16 + 2:\n\n    case SWM16 + 3:\n\n        {\n\n            static const int swm_convert[] = { 0x11, 0x12, 0x13, 0x14 };\n\n            int offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_ldst_multiple(ctx, SWM32, swm_convert[(ctx->opcode >> 4) & 0x3],\n\n                              29, offset << 2);\n\n        }\n\n        break;\n\n    case JR16 + 0:\n\n    case JR16 + 1:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, reg, 0, 0);\n\n        }\n\n        *is_branch = 1;\n\n        break;\n\n    case JRC16 + 0:\n\n    case JRC16 + 1:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, reg, 0, 0);\n\n            /* Let normal delay slot handling in our caller take us\n\n               to the branch target.  */\n\n        }\n\n        break;\n\n    case JALR16 + 0:\n\n    case JALR16 + 1:\n\n        opc = OPC_JALR;\n\n        goto do_jalr;\n\n    case JALR16S + 0:\n\n    case JALR16S + 1:\n\n        opc = OPC_JALRS;\n\n    do_jalr:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, opc, 2, reg, 31, 0);\n\n        }\n\n        *is_branch = 1;\n\n        break;\n\n    case MFHI16 + 0:\n\n    case MFHI16 + 1:\n\n        gen_HILO(ctx, OPC_MFHI, 0, uMIPS_RS5(ctx->opcode));\n\n        break;\n\n    case MFLO16 + 0:\n\n    case MFLO16 + 1:\n\n        gen_HILO(ctx, OPC_MFLO, 0, uMIPS_RS5(ctx->opcode));\n\n        break;\n\n    case BREAK16:\n\n        generate_exception(ctx, EXCP_BREAK);\n\n        break;\n\n    case SDBBP16:\n\n        /* XXX: not clear which exception should be raised\n\n         *      when in debug mode...\n\n         */\n\n        check_insn(ctx, ISA_MIPS32);\n\n        if (!(ctx->hflags & MIPS_HFLAG_DM)) {\n\n            generate_exception(ctx, EXCP_DBp);\n\n        } else {\n\n            generate_exception(ctx, EXCP_DBp);\n\n        }\n\n        break;\n\n    case JRADDIUSP + 0:\n\n    case JRADDIUSP + 1:\n\n        {\n\n            int imm = ZIMM(ctx->opcode, 0, 5);\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, 31, 0, 0);\n\n            gen_arith_imm(ctx, OPC_ADDIU, 29, 29, imm << 2);\n\n            /* Let normal delay slot handling in our caller take us\n\n               to the branch target.  */\n\n        }\n\n        break;\n\n    default:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n", "idx": 24483, "substitutes": {"ctx": ["handler", "cmp", "kk", "cu", "fw", "std", "tc", "ctr", "dc", "gz", "ctl", "pg", "prefix", "xs", "rt", "ct", "work", "history", "gc", "pkg", "tx", "xy", "conn", "bc", "scl", "unk", "tz", "func", "cp", "pause", "sc", "msg", "ksh", "setup", "mom", "anc", "mc", "timeout", "lex", "jj", "hw", "sys", " cx", "context", "batch", "x", "jac", "kt", "ck", "act", "nc", "cm", "kb", "cfg", "kw", "xp", "kl", "cc", "wx", "cv", "grad", "iat", "typ", "ork", "ka", "cmd", "resp", "nw", "np", "js", "req", "xc", "nt", "wp", "txt", "bh", "aux", "etc", "jp", "proc", "init", "conf"], "is_branch": ["is_BRanch", "is_blranch", "is_relag", "is_brag", "is_BRag", "is_blanch", "is_relanch", "is_relranch", "is_brranch", "is_BRranch", "is_blag"], "opc": [" opC", "opci", "OPc", "pci", "OPcs", "OPC", "opcs", "OPci", " opci", "pcs", "opC", " opcs", "pC", "pc"], "lwm_convert": ["lwm_transver", "lwm_unvert", "lwm_convversion", "lwm_conv", "lwm_converts", "lwm_calver", "lwm_transv", "lwm_transvert", "lwm_unver", "lwm_conver", "lwm_calverts", "lwm_convv", "lwm_transverts", "lwm_changeversion", "lwm_changevert", "lwm_changev", "lwm_conversion", "lwm_transversion", "lwm_convvert", "lwm_unverts", "lwm_calvert"], "swm_convert": ["swm_mapvert", "swm_uncode", "swm_concode", "swm_interver", "swm_createconv", "swm_conconv", "swm_transvert", "swm_intervert", "swm_conver", "swm_transcode", "swm_mapconv", "swm_createver", "swm_unvert", "swm_unver", "swm_changever", "swm_interconv", "swm_mapchange", "swm_transver", "swm_interchange", "swm_changevert", "swm_conchange", "swm_createvert", "swm_mapver", "swm_changecode", "swm_createchange"]}}
{"project": "FFmpeg", "commit_id": "abb5e37f64c48bba8bd0fde2bada0f7544defa24", "target": 1, "func": "int ff_filter_frame(AVFilterLink *link, AVFrame *frame)\n\n{\n\n    int (*filter_frame)(AVFilterLink *, AVFrame *);\n\n    AVFilterPad *dst = link->dstpad;\n\n    AVFrame *out;\n\n\n\n    FF_DPRINTF_START(NULL, filter_frame);\n\n    ff_dlog_link(NULL, link, 1);\n\n\n\n    if (!(filter_frame = dst->filter_frame))\n\n        filter_frame = default_filter_frame;\n\n\n\n    /* copy the frame if needed */\n\n    if (dst->needs_writable && !av_frame_is_writable(frame)) {\n\n        av_log(link->dst, AV_LOG_DEBUG, \"Copying data in avfilter.\\n\");\n\n\n\n        switch (link->type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            out = ff_get_video_buffer(link, link->w, link->h);\n\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            out = ff_get_audio_buffer(link, frame->nb_samples);\n\n            break;\n\n        default: return AVERROR(EINVAL);\n\n        }\n\n        if (!out) {\n\n            av_frame_free(&frame);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        av_frame_copy_props(out, frame);\n\n\n\n        switch (link->type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            av_image_copy(out->data, out->linesize, frame->data, frame->linesize,\n\n                          frame->format, frame->width, frame->height);\n\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            av_samples_copy(out->extended_data, frame->extended_data,\n\n                            0, 0, frame->nb_samples,\n\n                            av_get_channel_layout_nb_channels(frame->channel_layout),\n\n                            frame->format);\n\n            break;\n\n        default: return AVERROR(EINVAL);\n\n        }\n\n\n\n        av_frame_free(&frame);\n\n    } else\n\n        out = frame;\n\n\n\n    return filter_frame(link, out);\n\n}\n", "idx": 24484, "substitutes": {"link": ["range", "field", "ie", "map", "ink", "id", "connect", "path", "in", "open", "call", "pl", "light", "li", "info", "loc", "z", "base", "user", "mt", "head", "parent", "store", "flow", "links", "tool", "lay", "db", "cp", "Link", "thread", "msg", "le", "tag", "chain", "ind", "lib", "key", "handle", "relation", "label", "ml", "lock", "device", "type", "ld", "network", "drive", "ln", "def", "owner", "linked", "library", "filter", "low", "node", "way", "share", "l", "url", "style", "kind", "this", "join", "match", "stream", "ref", "slice", "like", "local", "target", "list", "rel", "set", "slave", "image", "connection", "line", "load", "query", "sp", "check", "self", "source", "loop", "name"], "frame": ["range", "field", "feature", "word", "request", "buffer", "in", "pointer", "new", "call", "face", " Frame", "info", "page", "base", "step", "user", "draw", "head", "scene", "sample", "one", "fram", "cf", "force", "ce", "zone", "code", "Frame", "term", "flow", "fr", "video", "error", "cast", "header", "remote", "state", "function", "next", "chain", "data", "ind", "iframe", "window", "point", "length", "ence", "from", "normal", "part", "cycle", "framework", "filter", "shot", "frames", "show", "rule", "doc", "process", "file", "version", "style", "time", "f", "block", "movie", "ref", "component", "profile", "event", "local", "me", "to", "module", "rame", "message", "up", "image", "sequence", "instance", "line", "response", "start", "feat", "channel", "trace", "source", "t"], "filter_frame": ["filteripchannel", "save_position", "filter___link", "filter_line", " filter_type", " filter_window", "filter___position", " filter_fram", "transform___frames", "transform___window", "transform___format", "filter4link", "filter_filter", "filter___frame", "filter2image", "filter___state", "filter_frames", " filter_link", "filter_format", "filtermyframes", "filter___line", "filter___window", "filter2frame", "transform___frame", "filter_state", "filterphpframe", "filteripframes", " filter_filter", "filtermychannel", "filter_link", "transform_format", "filter_type", "transform_window", "save_line", "filteriptype", " filter_frames", "filter4filter", "filterphpposition", "transform_frames", "filterphpchannel", "filter_fram", "filteripframe", "filter___format", "filtermyframe", "filter_image", "filter_channel", "filter2filter", "filter___channel", "transform_frame", "save_channel", "filter___frames", "filter_window", "filter4image", " filter_image", "filter4frame", "filter_position", "save_frame", " filter_state", "filter2link", "filtermytype", " filter_channel", "filterphpline"], "dst": ["fdest", "fost", " dost", "dsp", "dast", "sddest", " dST", "sst", "sbr", " dsp", "Dbr", "dset", "sost", "dost", "Dst", " dust", "bddest", "ssp", "Dost", "sdst", "sdost", "dest", "bdset", "bdost", "Ddest", "dST", "sdset", "Dest", "dbr", "sdST", "fest", "sdust", "daST", " dest", " dbr", " dset", " ddest", "Dsp", "bdst", "dust", "fst", "dadest", "ddest", "daust"], "out": ["gen", "o", "status", "output", "false", "buffer", "mem", "var", "or", "in", "pool", "p", "new", "extra", "can", "raw", "base", "user", "OUT", "table", "v", "one", "ch", "bool", "obj", "boot", "os", "gt", "at", "error", "cast", "n", "io", "msg", "inv", "Out", "co", "inner", "data", "ou", "net", "allowed", "point", "ot", "batch", "full", "box", "op", "update", "comment", "b", "old", "off", "all", "outer", "no", "tmp", "f", "it", "external", "client", "err", "null", "ref", "vert", "bit", "w", "ex", "result", "zero", "aos", "group", "empty", "ext", "list", "cache", "set", "to", "order", "up", "outs", "image", "line", "port", "aux", "val", "check", "t", "end", "conv", "init", "name", "res"]}}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,\n\n                            const void *data,\n\n                            size_t len) {\n\n    VncState *vs = (VncState *)transport;\n\n    int ret;\n\n\n\n retry:\n\n    ret = send(vs->csock, data, len, 0);\n\n    if (ret < 0) {\n\n        if (errno == EINTR)\n\n            goto retry;\n\n        return -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 24485, "substitutes": {"transport": ["ransmit", "ransporter", "Transaction", "transmit", "exporter", " transform", "Transports", "teleport", "teleporter", "Transmit", "Transform", "transports", "transform", "transporter", "Transporter", "Transport", "teleaction", " transmit", "teleports", " transporter", "ransform", "exaction", "export", "transaction", "exports", "ransport"], "data": ["f", "block", "batch", "action", "rew", "ata", "d", "pad", "def", "buffer", "empty", "p", "rec", "pointer", "rel", "msg", "bytes", "buf", "message", "Data", "raw", "a", "load", "dat", "text", "window", "bin", "partial", "DATA", " DATA", "table", "str"], "len": ["wid", "length", "ld", "cmp", "ll", " length", "ln", " bl", "elta", "nl", "mem", "lic", "fin", "lf", "el", "n", "Len", "resp", "bytes", "enc", "pos", "vec", "l", "size", "nt", "lan", "lib", "fil", "val", "en", "lp", "t", "elt", "end", "mid", "str", " l"], "vs": ["otes", "ms", "Vs", "values", "ins", "fs", "v", "rs", "ds", "var", "ks", "caps", "cs", "sts", "vr", "inv", "ils", "als", "bs", "vers", "js", "ats", "VS", "ts", "ns", "ps", "vl", "vc", "vals", "qs", "stats", "px", "gs", "sv", "obs", "ls", "vt"], "ret": ["ere", "inter", "ld", "x", "alt", "ter", "out", "err", "reset", "ll", "RET", "re", "pub", "status", "en", "code", "att", "gt", "xt", "def", "rev", "cont", "lt", "fin", "ext", "db", "det", "arg", "deg", "arr", "usr", "rem", "j", "rt", "back", "desc", "nt", "dr", "fun", "rets", " RET", "num", "ft", " Ret", "val", "iter", "flag", "mt", "Ret", " alt", "tr", "gc", "t", "elt", "pat", "jp", "off", "vet", "res"]}}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_set_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n    prop->set(obj, value, errp);\n\n}\n", "idx": 24486, "substitutes": {"obj": ["o", "xy", "ref", "os", "op", "iv", "bo", "object", "pr", "og", "act", "objects", "org", "Object", "ob", "rect", "gov", "vr", "Obj", "ctx", "vs", "np", "js", "oid", "b", "attr", "nt", "info", "txt", "bh", "obs", "self", "pkg", "tmp", "t", "elt", "ot", "onet", "pt", "hw"], "v": ["vm", "f", "vu", "o", "ev", "iv", "vp", "w", "tv", "c", "k", "g", "r", "p", "vis", "vr", "j", "view", "vs", "av", "V", "vy", "b", "nv", "l", "vc", "sv", "vim", "vi", "h", "q", "vt", "uv", "m", "conv", "cv"], "opaque": ["OPaque", "oposter", "opsiera", "oploster", "ioposter", "iposter", "opque", "opacity", "popaque", "opiera", "popiera", "oplque", "opsaque", "opsque", "popacity", "popque", "oplois", "OPacity", "OPiera", "ipois", "opsacity", "iopaque", "oplaque", "OPque", "ipque", "opois", "iopois", "ipaque", "iopque"], "name": ["names", "type", "nm", " names", "search", "term", "nam", "named", "part", "w", "def", "word", "error", "path", "comment", "n", "alias", " NAME", " Name", "san", "prefix", "add", " path", "attr", "NAME", "key", "text", "ame", "missing", "Name", "cap", "label", " key", "ni", "t", "no", "str", " prefix"], "errp": ["rrr", " errpa", "arrpc", "yrp", "errpid", "arrr", "arrpre", "ferr", " errr", " errpc", "yrpr", "errorr", "yrr", "ferp", "errr", " errpr", " errpre", "arrp", "rrp", "errpc", "ferpr", "errorp", " errpid", "rrpc", "errpr", "rrpa", "errorpc", "errorpre", "arrpa", "yrpid", "ferpid", "errpre", "errpa"], "prop": ["priv", "opt", "lit", " val", "pb", " pos", "ref", "item", "Pro", "op", "col", "mp", "Prop", "def", "pp", " p", " pro", "pr", "prof", " Prop", "cmd", "cp", "p", " proc", " tmp", " props", " def", " ref", "pred", "proc", "decl", "rep", "pl", "tag", "acc", "desc", "attr", "ps", "fac", "pa", "key", "prot", "pro", "val", "pkg", "ptr", "jp", "property", " prob", "pt"], "value": ["type", "attribute", "length", "field", " Value", "values", "address", "code", "status", "unit", "iv", "widget", "entry", "valid", "result", "now", "Value", "count", "VALUE", "state", "new", "set", "message", "total", "instance", "V", "inner", "data", "test", "size", "port", "des", "key", "text", "num", "val", "current", "number", "ue", "max", "description", "property", "index", "no"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,\n\n                            int mb_x, int mb_y, uint8_t *img_y,\n\n                            uint8_t *img_cb, uint8_t *img_cr,\n\n                            unsigned int linesize, unsigned int uvlinesize)\n\n{\n\n    assert(!FRAME_MBAFF(h));\n\n    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {\n\n        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);\n\n        return;\n\n    }\n\n\n\n#if CONFIG_SMALL\n\n    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);\n\n#else\n\n    if(h->pixel_shift){\n\n        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);\n\n    }else{\n\n        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);\n\n    }\n\n#endif\n\n}\n", "idx": 24488, "substitutes": {"h": ["f", "it", "hd", "ch", "context", "ssh", "x", "ih", "hash", "each", "ph", "host", "comm", "he", "dh", "w", "hr", "c", "hum", "rh", "hs", "zh", "hm", "g", "hp", "ah", "p", "cache", "kh", "s", "hz", "sh", "hal", "j", "oh", "ht", "html", "hi", "l", "history", "bh", "handle", "H", "hh", "hl", "http", "t", "m", "v", "hw"], "sl": ["sn", "ld", "ssh", "lit", "sb", "sa", "Sl", "spot", "rl", "slice", "syn", "ph", "se", "tl", "dh", "sol", "ln", "ell", "sil", "nl", "scl", "hs", "zh", "fl", "sel", "SL", "sch", "s", "sal", "sh", "sole", "spl", "sche", "ht", "sql", "pl", "shell", "isl", "l", "dl", "sid", "sm", "la", "lib", "bh", "coll", "sp", "serv", "hl", "sv", "kel", "il", "ls", "kl", "ml", "jl", "ssl"], "mb_x": ["mb_wx", "mb__x", "mb_axis", "MB_xp", "mb5ip", "mb__y", "mb5ix", "MB_x", "mb_lex", "mb_xy", "img_lex", "MB_ex", "img_X", "img_x", "mb____wx", "mb__ex", "mb_X", "img_ax", "mb_ip", "mb64xy", "mb64X", "mb____xt", "mg_x", "mb____x", "mb_ax", "mb__axis", "mb64x", "mb64ax", "mg_xs", "mb_xs", "MB_xs", "img_xy", "mb5xs", "img_wx", "img_xt", "mb_ix", "mb_ex", "MB_y", "mb_xt", "mb____lex", "mg_ip", "mb__xp", "mb5x", "mb_xp", "mb__xs", "MB_axis", "mg_ix"], "mb_y": ["nom_sy", "mb_out", "nom_ly", "mbXy", "rav_out", "mb___y", "umb_cy", "mb_id", "mb_ym", "rav___hot", "rav_cy", "mb67asy", "nom_y", "mb5out", "MB_x", "MB_ym", "mb67ys", "mb67y", "MB_cy", "mbXym", "mb5yy", "mb_ly", "mb_yy", "img_asy", "mb___hot", "nom_id", "mb5hot", "mb67ay", "rav___cy", "mb_cy", "mb5cy", "umb_yy", "mb_ay", "mb5y", "rav_y", "mb_ys", "rav___y", "mb_hot", "rav___out", "MB_y", "mbXx", "mb_sy", "mb___cy", "rav_hot", "mb___out", "mbXcy", "img_ys", "img_ay", "mb_asy", "umb_y", "umb_hot"], "img_y": ["img___yy", "aug_y", "img_my", "img_cy", "anim_uy", "emb_my", "img_uy", "aug___ya", "img___y", "emb___xy", "good___oy", "good_oy", "img___oy", "img_ey", "emb___my", "emb___ya", "orig_ny", "img______y", "aug___y", "aug___asy", "good___yy", "good_yy", "img______Y", "good___Y", "img___Y", "aug_oy", "good___y", "img______yy", "img_asy", "img_yy", "img_oy", "img___ya", "orig_uy", "anim_cy", "aug_ya", "img___asy", "emb___y", "img_xy", "img_ny", "emb_ya", "orig_ey", "anim_y", "img______oy", "aug___oy", "img_Y", "anim_asy", "emb_y", "good_y", "img___xy", "aug_asy", "emb_xy", "img___my", "good_Y", "img_ya", "orig_y"], "img_cb": ["imgCzb", "img___rb", "img_nw", "img_rb", "img_cf", "imgLctrl", "imgLdb", " img_kw", " img_bb", "imgCvc", "img___kw", "img___cc", "imgLbg", " img_cp", "imgCctrl", "imag_cb", " img_cf", "imag_db", "img_cc", "img___cr", "img_vc", "img_kw", "pkg_cb", "img___bb", "pkg_ctrl", "img___cb", "img_bg", "imag_ctrl", "img_ctrl", "img___cf", "img_bb", "img_db", "imgLcb", "imgCcb", " img_erb", "img_zb", "img_cp", "pkg_vc", "pkg_zb", " img_nw", "img_erb", "imag_bg", " img_rb", " img_cc"], "img_cr": [" img_ctr", "img_cy", " img_err", "img_ctr", " img_cy", "img_try", "img___cc", " img_tc", "img_fr", "img_crit", "img___cp", "img___br", " img_cp", "img_tc", "img___cy", "img_br", "img_cc", "img___cr", "img___cb", " img_crit", " img_try", "img_cp", "img___tc", "img___err", " img_fr", "img___fr", "img_err", "img___ctr", " img_br", " img_cc"], "linesize": ["linesze", "inesze", "insIZE", "insize", "locksize", " linesze", "stepsize", "linksization", " linesiz", "stepsforge", "lockshare", "linessize", "linesization", "pinsize", "lockseline", "linksIZE", "inssize", "inesization", "linsization", "inesIZE", "linesIZE", " linesIZE", "stepszie", "lineseline", "linssize", "worksiz", "linksize", "stepsization", "endsize", "endsforge", "inessize", "linsiz", "linesforge", "insization", "endszie", "linsize", "stepseline", "lineszie", "pinsization", "pinsforge", "linsIZE", "lineshare", " lineszie", "workszie", "pinszie", "workshare", "workseline", "linksze", "linszie", " linesization", "linesiz", "worksIZE", "inesize", "endsization", "worksize", "stepshare"], "uvlinesize": ["uvlinsect", "uvlinsicate", "vvlinesizer", "uvvalsizing", "uvringsize", "nvlinesizing", "uvlineszie", "vvlinesetime", "uvinesource", "uvcodesize", "vvlinize", "uvlinzie", "uupointsicate", "uvlinesocate", "uvvalsize", "nvlevelsizing", "uvlinksize", "vvlinsizer", "vvlinesect", "uvpointsize", "nvlevelsize", "uvinesIZE", "nvlevelsIZE", "nvlinesIZE", "uvstylesIZE", "vvlinesIZE", "uvlinsz", "vvlinource", "uvlinesource", "uupointsz", "uvlinksocate", "uupointsize", "uvpointsicate", "uvlinsizer", "uvcodesify", "vvlinzie", "uvmarksicate", "ujlinesize", "uvframesetime", "uvringsizing", "vvlinsetime", "uvframesect", "nvlinesize", "ujlinesizer", "vvlinesize", "uvmarksizer", "uvlinesify", "uvvalsizer", "uvinesize", "uvlinesizing", "uulinesz", "uvlinsetime", "uvmarksize", "nvlevelsizer", "uvineszie", "uvlinsize", "uvringsizer", "uvstyleszie", "uvlevelsIZE", "uvlinesIZE", "uvlinource", "ujlinesify", "uvlinksizer", "uvlinize", "vvlinIZE", "uvlinesetime", "uvcodesocate", "uvpointsetime", "uvpointsizer", "uvlinIZE", "uvframesize", "uvlevelsizer", "uulinesize", "uvlinksify", "uvlinesicate", "uvlevelsify", "ujlevelsify", "ujlinesocate", "nvlinesizer", "uvpointsect", "ujlevelsocate", "uvlevelsize", "uvlevelsizing", "uvmarksz", "ujlevelsizer", "uvpointsz", "uulinesizer", "uvringsIZE", "uvlinesect", "uupointsizer", "vvlinesource", "vvlinsect", "uvlinesizer", "vvlinsize", "uvcodesizer", "uulinesicate", "ujlevelsize", "vvlineszie", "uvframesizer", "uvstylesize", "uvlevelsocate", "uvvalsIZE", "uvstylesource", "uvlinesz"]}}
{"project": "qemu", "commit_id": "bf18bee547d19fde314e7b6b81f21f68b46c8a92", "target": 0, "func": "void qmp_eject(const char *device, bool has_force, bool force, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int rc;\n\n\n\n    if (!has_force) {\n\n        force = false;\n\n    }\n\n\n\n    rc = do_open_tray(device, force, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    if (rc == EINPROGRESS) {\n\n        error_setg(errp, \"Device '%s' is locked and force was not specified, \"\n\n                   \"wait for tray to open and try again\", device);\n\n        return;\n\n    }\n\n\n\n    qmp_x_blockdev_remove_medium(device, errp);\n\n}\n", "idx": 24501, "substitutes": {"device": ["context", "engine", "product", "Device", "hid", "server", "pipe", "address", "network", "edge", "drive", "pad", "disk", " Device", "index", "error", "dev", "buffer", "command", "target", "path", "resource", "spec", "DEV", "remote", "mode", "di", "slave", "devices", "module", "connection", "project", "any", "android", "location", "de", "port", "DE", "query", "window", "interface", "directory", "handle", "link", "serial", "pod", "driver", "reader", "scope", "end", "controller", "name"], "has_force": ["has___force", "yes_force", " has_forced", "has_Force", "yes___Force", "yes___forced", " has_Force", "yes_Force", "has___forcing", "has_forced", "yes___force", "yes___forcing", "yes_forced", "has_forcing", "has___Force", "has___forced", "yes_forcing"], "force": ["f", " enforce", "needed", "ce", "store", "forced", "edge", "service", " forced", "enable", "flow", "cycle", "core", "secure", "command", "sync", "act", "late", "find", "console", "cmd", "ignore", "close", "remote", "use", " confirm", "dirty", "forcer", "util", "forge", "always", "policy", "write", "form", "forward", "confirmed", "rule", "spread", " Force", "file", "yes", "safe", "fine", "require", "allow", "handle", "Force", "ise", "flag", "check", "forcing", "required", "ly", "ync", "orce"], "errp": ["errper", " errm", "errps", " errpa", "errorpm", "iterper", " errP", "errm", "iterpa", "errP", "errorps", "erm", "bufP", "rrP", "errorcp", "rrp", "bufp", "bufpm", "errcp", "iterp", "iterps", "rrcp", "erp", "rrps", "errpm", "errorp", " errpm", "rrper", "bufps", "rrpa", "errorm", "erP", "errorP", " errps", " errcp", " errper", "errpa"], "local_err": ["global_r", "local____er", "local____eas", "local_eas", "global_er", "global_kr", " local_error", "global_err", "local____err", "global_error", "local_rr", "local___kr", "local_r", "local___error", "local____error", "local___err", " local_rr", "local_error", " local_er", " local_eas", "local_kr", "local___r", "local_er"], "rc": ["ch", "cur", "uc", "cmp", "userc", "err", "ok", " RC", "inc", "code", " ec", "pc", "bc", "rs", "cor", "roc", " cc", "c", "ctr", "tc", "dc", "ry", "ck", " src", "ec", "cmd", "erc", "ack", " proc", "rec", "sc", "nc", "cs", "arc", "cb", "isc", "sec", "RC", "co", "rt", " exc", "auc", "ac", "oc", " cr", "nt", "cr", "con", "fc", "coll", "gc", "cc", "lc", " ac", "res"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int check_prot(int prot, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n    if (access_type == ACCESS_CODE) {\n\n        if (prot & PAGE_EXEC) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else if (rw) {\n\n        if (prot & PAGE_WRITE) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else {\n\n        if (prot & PAGE_READ) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24508, "substitutes": {"prot": ["prop", "protected", "typ", "ort", "pb", "prototype", "inet", "att", "tf", "nav", "def", "alg", "phy", "fl", "gate", "chron", "top", "ocol", "org", "rect", "gov", "pred", "sche", "et", "gp", "ht", "phys", "np", "eth", "php", "port", "virtual", "iot", "Prot", "pro", "tp", "tif", "net", "rot", "ptr", "pkg", "pat", "jp", "vt", "tr", "protect", "vet", "onet", "ssl"], "rw": ["rew", "web", "rl", "fw", "ru", "iw", "nb", "vp", "w", "rd", "rh", "rob", "wd", "wr", "wl", "route", "we", "writ", "sw", "vr", "nw", "write", "wa", "rt", "wb", "nor", "wp", "wn", "tw", "rb", "writer", "wx", "aw", "RW", "ro", "hw"], "access_type": ["access2type", "access___kind", " access_info", "access2info", "access___Type", "access2kind", "access_TYPE", "access_kind", "Access_type", " access_kind", "access_flag", "Access_Type", "access___type", "access___info", "access_info", " access_Type", "access_Type", "access2Type", "Access_TYPE", "Access_flag"], "ret": ["f", "sys", "inter", "ld", "alt", "ter", "out", "lit", "rest", "pas", "ll", "RET", "rm", "re", "reset", "pub", "ref", "mb", "att", "gt", "def", " fut", "rev", "cont", "reg", "mem", "del", "ext", "cmd", "det", "reply", "cert", "dt", "compl", "resp", "rel", "pret", "rem", "nz", "eth", "print", "ert", "bill", "rt", "back", "req", "desc", "nt", "dr", "fun", "rets", "txt", "quad", "ft", "val", "flag", "mt", "net", "Ret", "off", "tr", "t", "elt", "jp", "Return", "res"]}}
{"project": "qemu", "commit_id": "4545d4f4af8b29ba3b38dfb74d6f45342e15a62d", "target": 1, "func": "static int vmdk_write_extent(VmdkExtent *extent, int64_t cluster_offset,\n\n                            int64_t offset_in_cluster, QEMUIOVector *qiov,\n\n                            uint64_t qiov_offset, uint64_t n_bytes,\n\n                            uint64_t offset)\n\n{\n\n    int ret;\n\n    VmdkGrainMarker *data = NULL;\n\n    uLongf buf_len;\n\n    QEMUIOVector local_qiov;\n\n    struct iovec iov;\n\n    int64_t write_offset;\n\n    int64_t write_end_sector;\n\n\n\n    if (extent->compressed) {\n\n        void *compressed_data;\n\n\n\n        if (!extent->has_marker) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n        buf_len = (extent->cluster_sectors << 9) * 2;\n\n        data = g_malloc(buf_len + sizeof(VmdkGrainMarker));\n\n\n\n        compressed_data = g_malloc(n_bytes);\n\n        qemu_iovec_to_buf(qiov, qiov_offset, compressed_data, n_bytes);\n\n        ret = compress(data->data, &buf_len, compressed_data, n_bytes);\n\n        g_free(compressed_data);\n\n\n\n        if (ret != Z_OK || buf_len == 0) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n\n\n        data->lba = offset >> BDRV_SECTOR_BITS;\n\n        data->size = buf_len;\n\n\n\n        n_bytes = buf_len + sizeof(VmdkGrainMarker);\n\n        iov = (struct iovec) {\n\n            .iov_base   = data,\n\n            .iov_len    = n_bytes,\n\n        };\n\n        qemu_iovec_init_external(&local_qiov, &iov, 1);\n\n    } else {\n\n        qemu_iovec_init(&local_qiov, qiov->niov);\n\n        qemu_iovec_concat(&local_qiov, qiov, qiov_offset, n_bytes);\n\n    }\n\n\n\n    write_offset = cluster_offset + offset_in_cluster,\n\n    ret = bdrv_co_pwritev(extent->file, write_offset, n_bytes,\n\n                          &local_qiov, 0);\n\n\n\n    write_end_sector = DIV_ROUND_UP(write_offset + n_bytes, BDRV_SECTOR_SIZE);\n\n\n\n    if (extent->compressed) {\n\n        extent->next_cluster_sector = write_end_sector;\n\n    } else {\n\n        extent->next_cluster_sector = MAX(extent->next_cluster_sector,\n\n                                          write_end_sector);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n    ret = 0;\n\n out:\n\n    g_free(data);\n\n    if (!extent->compressed) {\n\n        qemu_iovec_destroy(&local_qiov);\n\n    }\n\n    return ret;\n\n}\n", "idx": 24540, "substitutes": {"extent": ["extect", "Extant", "xtment", "geent", "extment", "xtect", "xtents", "indents", "contents", "intent", "contend", "indension", "geents", "gement", "indend", "indant", "contension", "intension", "xtent", "contENT", "Extent", "xtant", "ordent", "xtENT", "indent", "ordension", "Extents", "xtension", "intect", "Extect", "expent", "indment", "extant", "extend", "expend", "extENT", "intents", "extents", "expant", "extension", "contant", "ordENT", "content", "expension", "Extension", "geension", "ordant"], "cluster_offset": ["clusterxposition", "clusters_offset", "cluster_info", "clusteripoffset", "clusters_info", "clusters_align", "clusteripinfo", "clusteripalign", "clusters_owner", "cluster_owner", "clusterxoffset", "cluster_position", "cluster_Offset", "clusteripposition", "clusterxOffset", "clusterxowner", "clusters_position", "clusters_Offset", "cluster_align"], "offset_in_cluster": ["offset_in_Clust", "offset_in_glure", "offset_in_colure", "offset_in_glusters", "offset_in_colust", "offset_in_Clusters", "offset_in_glust", "offset_in_Closer", "offset_in_clust", "offset_in_gloser", "offset_in_plure", "offset_in_closer", "offset_in_plust", "offset_in_colusters", "offset_in_clusters", "offset_in_pluster", "offset_in_ploser", "offset_in_plusters", "offset_in_Cluster", "offset_in_gluster", "offset_in_clure", "offset_in_coluster"], "qiov": ["qualibr", "qovi", "qiev", "eqiop", "qvoice", "quibr", "qriver", "questiov", "questiour", " qiev", "iqvoice", " qiop", "quiev", " qiour", "qualconv", "qualiov", "qibr", "queryiev", "questiev", "iqiov", "qqiev", "qualiev", "iqibr", "iqiop", " qovi", "qqovi", " qvoice", "qualovi", "qqiour", "queryibr", "qualiour", "eqiov", "qiop", "eqriver", " qconv", "eqvoice", " qibr", "queryiov", " qriver", "iqiour", "qconv", "qqiov", "quiov", "questibr", "qiour", "quconv", "queryiour", "iqriver", "iqiev"], "qiov_offset": ["qiov2reset", "qiov2error", "qiov2Offset", "qoulder_error", "qoulder_origin", "qiov__error", "qiov_error", "qiol_error", "qiop_offset", "qiol_offset", "qoulder_len", "qiop_Offset", "qoulder_offset", "qiov__addr", "qiol_addr", "qiov_off", "qiop_error", "qiop_reset", "qiov__offset", "qiov2offset", "qiov_addr", "qiov_reset", "qiov_Offset", "qiov_origin", "qiov__off", "qiov_len", "qiol_off"], "n_bytes": [" n_tes", "N_seconds", "n_details", "an_seconds", "N_errors", "n__bits", "_", "n_bits", "nowbytes", "cont", "n__Bytes", "nbytebyte", " n_seconds", "n_seconds", "noxbytes", "noxchanges", "nowtes", "N_bits", "n_windows", "n_parts", "n__tes", "an42seconds", "nbytessections", "an42windows", "n42windows", "gc", "N_bytes", "nbytesbytes", "n_sections", "nbytebytes", "n_Bytes", "N_parts", "noxseconds", "N_blocks", "nowseconds", "n42seconds", "an42changes", "n_changes", "an42bytes", "an_windows", "n__bytes", "an_changes", "nbytesections", "an_bytes", "n_frames", "noxwindows", "n_blocks", "into", "vec", " n_rows", "n42bytes", " n_frames", " n_details", "n_tes", " n_byte", "n42changes", "n_rows", "block", "N_tes", "n_byte", "nowdetails", "cmd", "N_Bytes", "n_errors", " n_sections", "flag", "nbytesbyte"], "offset": ["f", "padding", "attribute", "length", "alt", "o", "ref", "address", "op", "id", "error", "buffer", "top", "amount", "pointer", "prefix", "set", "buf", "origin", "pos", "ta", "image", "oid", "eta", "location", "shift", "start", "size", "info", "addr", "seek", "base", "position", "scroll", "mt", "off", "rot", "ptr", "end", "index", "Offset"], "ret": ["opt", "alt", "lit", "out", "ter", "not", "err", "reset", "ll", "RET", "rm", "re", "ref", "success", "status", "len", "try", "att", "gt", "valid", "def", "result", "rev", "after", "mem", "over", "det", "mel", "arg", "deg", "dt", "resp", "rem", "j", "print", "rt", "back", "nt", "fun", "rets", "prot", "url", " RET", "ft", " Ret", "val", "net", "mt", "flag", "Ret", "tr", "t", "elt", "final", "Return", "utils", "res"], "data": ["address", "ata", "d", "map", "c", "done", "output", "buffer", "mem", "p", "extra", "size", "info", "base", "reader", "writer", " DATA", "table", "h", "tar", "padding", "obj", "only", "value", "error", "ATA", "add", "buf", "next", "init", "dat", "window", "bin", "partial", "format", "length", "batch", "reset", "pad", "normal", "def", "read", "memory", "bytes", "text", "number", "DATA", "off", "no", "str", "this", "block", "ref", "hash", "len", "result", "group", "empty", "cache", "initial", "rel", "to", "module", "message", "image", "Data", "missing", "self", "t", "name"], "buf_len": ["uf_ls", "uf_el", "buf67ln", "buf__lib", "buf0length", "buf2length", "buf_length", " buftln", "queue_ls", "queue_lib", "buf67len", "buf0ls", " buftlit", " buf_lit", "buf_lit", "uf_len", "buf__length", "buf67length", "buftlen", "buf__lon", "buf2size", "queue_length", "uf_ln", " buf_ln", "buff_ls", "buf__el", "buftlit", "buff_len", " buftlen", "uf_min", "uf_lib", " buf_length", "buff_lon", "buf_el", "buftlength", "buf67min", "buf_ln", "buf_lon", "buf__ls", "uf_length", "buf_ls", "buf_min", "buf2ls", "buf_lim", "buftln", "buf0len", "queue_Len", "buf__len", "buf_Len", "queue_lim", "buff_length", "buf0size", "buf_lib", "buf2len", "buf_size", "queue_len", " buftlength", "uf_size"], "local_qiov": ["local_qualiov", "local_iqibi", "local_quiov", "local_qqiev", "local_sqvoice", "local___iqibi", "local_qibr", "local_qualibr", "local_qqivic", "local_qtoyer", "local_qualibi", "local_qualoji", "local_qtovi", "local_clientiev", "local___qvoice", "local_qualovi", "local_qiological", "local_sqibi", "local_ueivic", "local_qualoyer", "local_iqvoice", "local___qibi", "local___iqiov", "local_qiour", "local_qiev", "local___iqibr", "local_quiour", "local_iqibr", "local_ueminecraft", "local_sqiological", "local___qiov", "local_qualvoice", "local_qoji", "local_iqiour", "local_qminecraft", "local_qovi", "local_sqiov", "local_checkoji", "local_clientminecraft", "local_qqiov", "local_qvoice", "local_sqiour", "local___qibr", "local_clientiov", "local_qoyer", "local_qibi", "local_iqiev", "local___iqvoice", "local_qqminecraft", "local_qivic", "local_quiological", "local_checkiov", "local_quiev", "local_clientivic", "local_ueiov", "local_checkoyer", "local_checkovi", "local_sqiev", "local_qtiov", "local_iqiological", "local_iqiov", "local_ueiev", "local_sqibr", "local_qtoji"], "iov": ["iat", "von", "iva", "ux", "iol", " commun", " vocal", "voice", " resp", " unim", "icon", " bio", "iv", "vp", "uj", "tv", "rov", "ech", " rav", "veh", "river", " mus", " enorm", " misc", "communication", "liv", "nov", "nir", " coh", " fav", " pir", "iop", "uart", "org", " multimedia", "gov", "vr", " mob", "isco", " cohort", " calib", " civ", "vo", "iq", "iological", " imp", " mech", " vital", " residual", " tv", "ij", " codec", "kov", "minecraft", "riot", "imp", " mor", "tif", " impulse", " neigh", "ir", "serv", "ivic", "vector", " serv", "eur", "conv", " vib", "iour", " vers"], "write_offset": ["writeingseek", " write_floor", "seek___start", "write_padding", "write67floor", "seek___off", "seek_off", " write_mask", "seek_position", "writeingmask", "write_position", "write___position", "writeableoffset", "writeingoffset", "writeablestart", "seek_start", "write67position", "write_floor", "write_mask", "writeableposition", " write_padding", "write___off", "write___start", "write67padding", "writeingposition", "write67offset", "write_off", " write_seek", "write_start", " write_position", "seek___position", "write___offset", "seek___offset", "seek_offset", "write_seek", "writeableoff"], "write_end_sector": ["write_end2sel", "write_end_sel", "write_end_offset", "write_end2offset", "write_endzoffset", "write_end_sec", "write_start_offset", "write_end2sec", "write_start_sec", "write_endzsector", "write_endzsec", "write_start_sector", "write_endzsel", "write_start_sel", "write_end2sector"], "compressed_data": ["composed2DATA", "compressed_dat", "compressedingmemory", "compressedingData", "compress_str", "compressed1dat", "compressed67hash", "compress_memory", "composed_data", "compacted_data", "composed2table", "compress_Data", "compacted_dat", "compressed_hash", "compress_data", "compressed_buffer", "compressedingdata", "composed2data", "composed_DATA", "compressed2table", "compressed_memory", "compressed67key", "composed_table", "computed_key", "computed67hash", "compressed_Data", "compressed1data", "computed67bytes", "computed_data", "compressed67data", "compressed_bytes", "compressed_table", "compressed2data", "compressed2DATA", "computed67data", "compressed_ata", "compressed_key", "compressed_str", "compacted_ata", "computed_bytes", "compressed1Data", "compressed67bytes", "computed67key", "compacted_buffer", "compressed1buffer", "computed_hash", "compressed1str", "compressed1ata", "compressed_DATA"]}}
{"project": "FFmpeg", "commit_id": "8bc80f8b24cb6f03ad209ce546ae594904c8b353", "target": 1, "func": "static int http_server(void)\n\n{\n\n    int server_fd, ret, rtsp_server_fd, delay, delay1;\n\n    struct pollfd poll_table[HTTP_MAX_CONNECTIONS + 2], *poll_entry;\n\n    HTTPContext *c, *c_next;\n\n\n\n    server_fd = socket_open_listen(&my_http_addr);\n\n    if (server_fd < 0)\n\n        return -1;\n\n\n\n    rtsp_server_fd = socket_open_listen(&my_rtsp_addr);\n\n    if (rtsp_server_fd < 0)\n\n        return -1;\n\n    \n\n    http_log(\"ffserver started.\\n\");\n\n\n\n    start_children(first_feed);\n\n\n\n    first_http_ctx = NULL;\n\n    nb_connections = 0;\n\n    first_http_ctx = NULL;\n\n\n\n    start_multicast();\n\n\n\n    for(;;) {\n\n        poll_entry = poll_table;\n\n        poll_entry->fd = server_fd;\n\n        poll_entry->events = POLLIN;\n\n        poll_entry++;\n\n\n\n        poll_entry->fd = rtsp_server_fd;\n\n        poll_entry->events = POLLIN;\n\n        poll_entry++;\n\n\n\n        /* wait for events on each HTTP handle */\n\n        c = first_http_ctx;\n\n        delay = 1000;\n\n        while (c != NULL) {\n\n            int fd;\n\n            fd = c->fd;\n\n            switch(c->state) {\n\n            case HTTPSTATE_SEND_HEADER:\n\n            case RTSPSTATE_SEND_REPLY:\n\n            case RTSPSTATE_SEND_PACKET:\n\n                c->poll_entry = poll_entry;\n\n                poll_entry->fd = fd;\n\n                poll_entry->events = POLLOUT;\n\n                poll_entry++;\n\n                break;\n\n            case HTTPSTATE_SEND_DATA_HEADER:\n\n            case HTTPSTATE_SEND_DATA:\n\n            case HTTPSTATE_SEND_DATA_TRAILER:\n\n                if (!c->is_packetized) {\n\n                    /* for TCP, we output as much as we can (may need to put a limit) */\n\n                    c->poll_entry = poll_entry;\n\n                    poll_entry->fd = fd;\n\n                    poll_entry->events = POLLOUT;\n\n                    poll_entry++;\n\n                } else {\n\n                    /* not strictly correct, but currently cannot add\n\n                       more than one fd in poll entry */\n\n                    delay = 0;\n\n                }\n\n                break;\n\n            case HTTPSTATE_WAIT_REQUEST:\n\n            case HTTPSTATE_RECEIVE_DATA:\n\n            case HTTPSTATE_WAIT_FEED:\n\n            case RTSPSTATE_WAIT_REQUEST:\n\n                /* need to catch errors */\n\n                c->poll_entry = poll_entry;\n\n                poll_entry->fd = fd;\n\n                poll_entry->events = POLLIN;/* Maybe this will work */\n\n                poll_entry++;\n\n                break;\n\n            case HTTPSTATE_WAIT:\n\n                c->poll_entry = NULL;\n\n                delay1 = compute_send_delay(c);\n\n                if (delay1 < delay)\n\n                    delay = delay1;\n\n                break;\n\n            case HTTPSTATE_WAIT_SHORT:\n\n                c->poll_entry = NULL;\n\n                delay1 = 10; /* one tick wait XXX: 10 ms assumed */\n\n                if (delay1 < delay)\n\n                    delay = delay1;\n\n                break;\n\n            default:\n\n                c->poll_entry = NULL;\n\n                break;\n\n            }\n\n            c = c->next;\n\n        }\n\n\n\n        /* wait for an event on one connection. We poll at least every\n\n           second to handle timeouts */\n\n        do {\n\n            ret = poll(poll_table, poll_entry - poll_table, delay);\n\n        } while (ret == -1);\n\n        \n\n        cur_time = gettime_ms();\n\n\n\n        if (need_to_start_children) {\n\n            need_to_start_children = 0;\n\n            start_children(first_feed);\n\n        }\n\n\n\n        /* now handle the events */\n\n        for(c = first_http_ctx; c != NULL; c = c_next) {\n\n            c_next = c->next;\n\n            if (handle_connection(c) < 0) {\n\n                /* close and free the connection */\n\n                log_connection(c);\n\n                close_connection(c);\n\n            }\n\n        }\n\n\n\n        poll_entry = poll_table;\n\n        /* new HTTP connection request ? */\n\n        if (poll_entry->revents & POLLIN) {\n\n            new_connection(server_fd, 0);\n\n        }\n\n        poll_entry++;\n\n        /* new RTSP connection request ? */\n\n        if (poll_entry->revents & POLLIN) {\n\n            new_connection(rtsp_server_fd, 1);\n\n        }\n\n    }\n\n}\n", "idx": 24542, "substitutes": {"server_fd": ["server__fee", "server_FD", "server_fp", " server2fp", " server2f", "erver_fi", " server2fd", "server64fee", "server2fl", "server_f", "server_dir", "erver_fp", "server64fp", "ser_fl", "server__dir", " server2dir", "serverTimefd", " server2fl", "server__fi", "server_fi", " server2fed", "serverTimefp", "server_fed", "serverEfl", "server__fd", " server_fp", "ser_fp", "server__f", "server2dir", "erver_fd", "server2fed", "server_fn", "server__fp", "server64fi", "serverTimefl", "ser_FD", " server_fed", "serverTimeFD", "ser_fd", "server2fp", " server_dir", "server64fd", "serverEfd", "server2f", " server_fl", "server2fd", "server_fl", "server2fn", " server2fn", " server_f", "server_fee", " server_fn", "erver_fee", "serverEfed", "serverEfn"], "ret": ["alt", "err", "RET", "dy", "re", "ff", "status", "done", "result", "rx", "received", "dt", "rel", "resp", "rt", "dl", "fun", "dr", "rets", "poll", "fe", "iter", "flag", "Ret", "xff", "elt", "res"], "rtsp_server_fd": ["rtsp_client_dir", "rtsp_client_pid", "rtsp_client2fp", "rtsp_server_fee", "rtsp_host_pid", "rtsp_server_fc", "rtsp_host_fd", "rtsp_server_dl", "rtsp_client_addr", "rtsp_server2dl", "rtsp_server___d", "rtsp_client2dl", "rtsp_server_d", "rtsp_client_fee", "rtsp_server___fd", "rtsp_server_pid", "rtsp_server2fp", "rtsp_server_fp", "rtsp_client_fp", "rtsp_host_fee", "rtsp_host_dl", "rtsp_client2fd", "rtsp_server2d", "rtsp_server___fp", "rtsp_client_fd", "rtsp_server___dl", "rtsp_client2d", "rtsp_client_fc", "rtsp_server2fd", "rtsp_client_dl", "rtsp_server_dir", "rtsp_client_d", "rtsp_server_addr"], "delay": ["batch", "ait", "hold", "sleep", "dq", "dy", "disable", "ay", "distance", "d", "def", "skip", "wait", "del", "buffer", "command", "sync", "lambda", "rate", "send", "pause", "dt", "rel", "dist", "sequence", "depth", "layout", "stop", "da", "priority", "dp", "dl", "slow", "dr", "shift", "size", "poll", "step", "time", "driver", "seed", "label", "timeout", "offset", "loop", "duration"], "delay1": ["sleepone", "loop2", "loop1", "delayone", "sleep1", "loopone", "sleep2", "timeout1", "timeout2", "delay2", "timeoutone"], "poll_table": ["pollationlist", "pull_list", "poll_initial", "pull_entry", "pollationtable", "pull_table", "poll_buffer", "pollationinitial", "poll2buffer", " poll_TABLE", "poll_TABLE", " poll_buffer", "poll_list", "pull_initial", "poll2TABLE", "poll2entry", "poll2table", "pollationentry"], "poll_entry": ["poll32input", "poll_object", "questiongmatch", "voteptentry", "polldair", "townEsetting", "ollFsystem", "town_entry", "polljresource", "pollopinstance", "poll64option", "polldinstance", "polllchild", "oll_def", "roll_inter", "waitophandler", "roll32enter", "pollerneeded", "pollfinternal", " poll_search", "pollerry", "poll64ry", "scroll_object", "poll1interface", "pollEsection", "poll64entry", "pollablerow", "patch64Entry", "patch_Entry", "roll_entry", "polljqueue", " poll_array", "pollvmatch", "poll32table", "cache_ry", "pull_entry", "pollopentry", "pollacexit", "polledinterface", "pull_row", "scroll_table", "pollingrow", "poll1table", "wait_handler", "poll_enter", "poll_internal", "questiongargument", "poll64exit", " poll_element", "polllentry", "townEsection", "download_child", "poll_owner", "oll_function", "wait_result", "poll_interface", "voteptry", "pollfentry", "polleddef", "pool___ent", "poll___ent", "pollginput", "poll1entry", "poll_resource", "downloaderqueue", "pollptdef", "download_owner", "vote_exit", "polllowner", "townEentry", "ollgentry", "scroll_input", "question_entry", "download_needed", "waitopentry", "pollableentry", "downloadptowner", "poll_option", "downloaderentry", "pollgattribute", "poll_match", "poll_Entry", "pollopresult", "roll_enter", "poll_ry", "ollgwriter", "vote_def", "pollgitem", "question_attribute", "poll_air", "poll_cell", "town_section", "poll_function", "pollgwriter", "polljneeded", "pollgmatch", "voteptexit", "pollLsystem", "pollventry", "pollableenter", "roll_row", "polledgroup", "pollgobject", "Poll_element", "poll_item", "poll_search", "pollopair", "pollacry", "polllyinstance", "poll32object", "poll___system", " poll_row", " poll_member", "pollptentry", "pollgtable", "pollammukeeper", "cache_entry", "poll_member", "poll32inter", "pollvargument", "wait_air", "downloaderresource", "pollLentry", "question_match", "ollgdef", "question_argument", "pollopowner", "download_queue", "roll32row", "wait_entry", "pool_ent", "poll_exit", "pollEentry", "pollFfunction", "polllyleft", "pollingent", "pollammugroup", "pool_entry", "pollerqueue", "poll_row", "scrollopinput", "pollerEntry", "waitopresult", "vote_entry", "poll_attribute", "polledattribute", "poll_ent", "pollopobject", "wait_owner", "pollophandler", "polllymember", "scroll_entry", "ollFfunction", "poll_element", " poll_interface", "poll_group", "vote_group", "polledwriter", "wait_instance", "poll_def", "downloaderneeded", "oll_system", "poll_needed", "voteedgroup", "pool_system", "cacheerentry", "pollEsetting", "polledkeeper", "pollptry", "town_setting", "oll_entry", "waitopowner", "questiongentry", "poll_queue", "pollgentry", "pollDsetting", "polllyair", "polllyowner", "poll_result", "poll_input", "pollableinter", "pollFsystem", "patch_entry", "pollgargument", "questiongattribute", "downloadptentry", "cache_Entry", "pollFentry", "polleriterator", "poll64def", "poll32entry", "roll32entry", "voteedkeeper", "Poll_option", "pollDentry", "pollptowner", "voteedentry", "polledentry", "waitopair", "scrolloptable", "pollgdef", "poll_argument", "cacheeriterator", "scrollopobject", "pollLfunction", "polledtable", "downloadptchild", "pollDsection", " poll_ent", "Poll_entry", "patch_option", "poll___entry", "polldowner", "pollptexit", "download_entry", "pollopinput", "poll_writer", "vote_ry", "oll_writer", " poll_internal", "patch64option", "pollerresource", "polldentry", "polllyentry", "poll_iterator", "cacheerEntry", "scrollopentry", "poll_handler", " poll_item", "poll_left", "cache_iterator", "poll_inter", "poll_instance", "poll32enter", "cacheerry", " poll_left", "poll_child", "poll_array", "pollvattribute", "pollfelement", "ollgattribute", "ollFentry", "poll32row", "pull_cell", "poll_setting", "pollammuentry", "pollingarray", "roll32inter", "vote_keeper", "oll_attribute", "polljentry", "pollacdef", "pool___system", "pollptchild", "waitopinstance", "pollingentry", "pollgsearch", "poll64Entry", "poll_keeper", "download_resource", "voteptdef", "pollerentry", "poll_section", "patch64entry", "pollacentry", "pool___entry", "poll_system", "polloptable"], "c": ["f", "cl", "ch", "cur", "cmp", "toc", "cf", "ce", "cu", "ca", "comm", "bc", "pc", "tc", "cd", "rc", "dc", "abc", "cont", "ec", "ctrl", "cp", "p", "n", "cache", "cs", "cb", "cm", "call", "ctx", "enc", "com", "co", "b", "ct", "xc", "ac", "vc", "anc", "cr", "lib", "ci", "mc", "con", "fc", "e", "gc", "h", "t", "cc", "C", "v", "lc", "m", "cv", "conf"], "c_next": ["c_response", "cjcurrent", "cjresponse", "cjnext", "cjprev", "h_current", "h_response", "c_current", "c_prev", "h_next", "h_prev"], "fd": ["f", "fx", "pd", "handler", "sd", "fb", "ld", "stream", "dial", "dir", "dy", "uf", "ff", "nd", "dll", "fa", "fee", "fs", "d", "rd", "fr", "cd", "dc", "bf", "ds", "fl", "wait", "wd", "fin", "buffer", "fm", "fi", "func", "db", "lf", "fn", "dig", "ffff", "fps", "dt", "pid", "cb", "dist", "fed", "buf", "df", "td", "gd", "da", "desc", "ind", "dl", "port", "dd", "dr", "dat", "addr", "dra", "fe", "dn", "handle", "fc", "draw", "du", "fp", "FD", "ptr", "elt", "socket"]}}
{"project": "FFmpeg", "commit_id": "f3c0e0bf6f53df0977f3878d4f5cec99dff8de9e", "target": 0, "func": "static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n\n                               const uint8_t *buf, int buf_size,\n\n                               int first_field)\n\n{\n\n    static const uint8_t header_prefix[]    = { 0x00, 0x00, 0x02, 0x80, 0x01 };\n\n    static const uint8_t header_prefix444[] = { 0x00, 0x00, 0x02, 0x80, 0x02 };\n\n    int i, cid, ret;\n\n\n\n    if (buf_size < 0x280)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (memcmp(buf, header_prefix, 5) && memcmp(buf, header_prefix444, 5)) {\n\n        av_log(ctx->avctx, AV_LOG_ERROR, \"error in header\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (buf[5] & 2) { /* interlaced */\n\n        ctx->cur_field = buf[5] & 1;\n\n        frame->interlaced_frame = 1;\n\n        frame->top_field_first  = first_field ^ ctx->cur_field;\n\n        av_log(ctx->avctx, AV_LOG_DEBUG,\n\n               \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);\n\n    }\n\n\n\n    ctx->height = AV_RB16(buf + 0x18);\n\n    ctx->width  = AV_RB16(buf + 0x1a);\n\n\n\n    av_dlog(ctx->avctx, \"width %d, height %d\\n\", ctx->width, ctx->height);\n\n\n\n    ctx->is_444 = 0;\n\n    if (buf[0x4] == 0x2) {\n\n        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV444P10;\n\n        ctx->avctx->bits_per_raw_sample = 10;\n\n        if (ctx->bit_depth != 10) {\n\n            ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n\n            ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n\n            ctx->bit_depth = 10;\n\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n\n        }\n\n        ctx->is_444 = 1;\n\n    } else if (buf[0x21] & 0x40) {\n\n        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n\n        ctx->avctx->bits_per_raw_sample = 10;\n\n        if (ctx->bit_depth != 10) {\n\n            ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n\n            ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n\n            ctx->bit_depth = 10;\n\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10;\n\n        }\n\n    } else {\n\n        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n\n        ctx->avctx->bits_per_raw_sample = 8;\n\n        if (ctx->bit_depth != 8) {\n\n            ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n\n            ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n\n            ctx->bit_depth = 8;\n\n            ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n\n        }\n\n    }\n\n\n\n    cid = AV_RB32(buf + 0x28);\n\n    av_dlog(ctx->avctx, \"compression id %d\\n\", cid);\n\n\n\n    if ((ret = dnxhd_init_vlc(ctx, cid)) < 0)\n\n        return ret;\n\n\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    ctx->mb_width  = ctx->width >> 4;\n\n    ctx->mb_height = buf[0x16d];\n\n\n\n    av_dlog(ctx->avctx,\n\n            \"mb width %d, mb height %d\\n\", ctx->mb_width, ctx->mb_height);\n\n\n\n    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)\n\n        ctx->height <<= 1;\n\n\n\n    if (ctx->mb_height > 68 ||\n\n        (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n\n        av_log(ctx->avctx, AV_LOG_ERROR,\n\n               \"mb height too big: %d\\n\", ctx->mb_height);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    for (i = 0; i < ctx->mb_height; i++) {\n\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));\n\n        av_dlog(ctx->avctx, \"mb scan index %d\\n\", ctx->mb_scan_index[i]);\n\n        if (buf_size < ctx->mb_scan_index[i] + 0x280LL) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"invalid mb scan index\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24555, "substitutes": {"ctx": ["cmp", "kk", "ca", "fw", "std", "c", "that", "tc", "crit", "command", "inst", "pool", "ctl", "new", "and", "raw", "ct", "ns", "ij", "expr", "loc", "history", "px", "exec", "scope", "gc", "pkg", "tm", "tx", "cf", "obj", "Context", "conn", "tz", "mk", "ctrl", "func", "cp", "pause", "qq", "setup", "co", "mom", "iac", "wcs", "anc", "mc", "handle", "timeout", "hw", "sys", " cx", "context", "x", "cam", "jac", "def", "kt", "abc", "jpg", "ck", "act", "nc", "cm", "acl", "cfg", "cas", "addr", "cookie", "alloc", "kw", "xp", "lp", "kl", "tmp", "cc", "wx", "lc", "cv", "iat", "ka", "tk", "cmd", "cn", "resp", "util", "cb", "module", "np", "kick", "req", "xc", "nt", "aux", "check", "etc", "jp", "proc", "conv", "utils", "conf"], "frame": ["f", "block", "context", "x", "fram", "tx", "cf", "ce", "zone", "fw", "feature", "code", "Frame", "se", "component", "config", "fr", "cpu", "event", "buffer", "seq", "command", "row", "cmd", "list", "ace", "state", "set", "module", "function", "rame", "sequence", "image", "next", "face", "process", "file", "chain", "line", "data", "feat", "info", "iframe", "window", "base", "position", "version", "sp", "scene", "format", "point", "lock", "init"], "buf": ["fb", "pack", "batch", "cmp", "length", "pb", "tx", "cam", "emb", "nm", "conv", "ref", "queue", "uf", "bl", "br", "box", "foo", "len", "pad", "ctr", "result", "bf", "buffer", "mem", "seq", "func", "cmd", "db", "burst", "Buff", "cache", "deg", "img", "mat", "msg", "cb", "bytes", "bar", "vec", "np", "bs", "bg", "doc", "bn", "bu", "orig", "b", "data", "desc", "aka", "window", "history", "bh", "bp", "rb", "cap", "Buffer", "buff", "pkg", "tmp", "proc", "v", "cv", "grad"], "buf_size": [" buf2Size", "buf2size", " buf2offset", " buf2size", " buf_Size", " buf_offset", "buf2Size", "buf_ize", "buf2offset", "buffer_ize", "buffer_Size", "buf_loc", "buffer_loc", "buffer_size", "buf_offset", "buf_Size"], "first_field": ["first___Field", "first_key", "first___len", "initial_byte", "first_len", " first_Field", "initial_field", " first___Field", " first___field", "first_byte", "first__key", "first__len", "firstFieldfield", " first___key", "firstFieldlen", "first___field", " first_len", "first_Field", "first___key", "firstFieldField", " first___len", "firstFieldkey", "first_fix", "first__Field", " first_key", "initial_fix", "first__field", "initial_key"], "header_prefix": ["header___master", "header___prefix", "header___pkg", "header67prefix", "frame67origin", "header__field", "header_pkg", " header_master", "header__prefix", "header67field", "header_field", "header_master", "header_origin", "header67base", "header67origin", "header__base", "frame_field", "header_base", "frame67prefix", "frame_prefix", "frame_origin", "header__origin", "frame67base", " header_pkg", "frame_base", "frame67field"], "header_prefix444": ["header_type420", "header_ring444", "header_format483", "header_fix444", "header_ring411", "header_buffer345", "header_ring420", "header___prefix444", "header_fix345", "header___type420", "header_format444", "header_prefix483", "header_fix450", "header___type411", "header_buffer444", "header_prefix450", "header___type444", "header_fix483", "header_type411", "header_buffer450", "header___prefix411", "header_prefix420", "header_buffer483", "header_prefix345", "header___prefix420", "header_format450", "header_type444", "header_prefix411", "header_format345"], "i": ["it", "ki", " j", "pi", " ii", "iy", "fi", "I", " bi", "di", "j", "ai", "mi", "li", "ii", "ti", "l", " ti", "bi", "ij", "y", " mi", "ip", "ci", "si", "m", "v", "ix"], "cid": ["cfID", "cfid", "chanvid", "chanID", "chanId", "cfvid", "cvid", "cfId", "recId", "recid", "cId", "chanid", "recID", "recvid", "cID"], "ret": ["alt", "out", "reset", "ref", "RET", "len", "rc", "result", "mem", "new", "resp", "rel", "rt", "desc", "fun", "txt", "url", "tif", "aux", "val", "flag", "mt", "Ret", "res"]}}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static int get_monitor_def(target_long *pval, const char *name)\n\n{\n\n    const MonitorDef *md;\n\n    void *ptr;\n\n\n\n    for(md = monitor_defs; md->name != NULL; md++) {\n\n        if (compare_cmd(name, md->name)) {\n\n            if (md->get_value) {\n\n                *pval = md->get_value(md, md->offset);\n\n            } else {\n\n                CPUState *env = mon_get_cpu();\n\n                if (!env)\n\n                    return -2;\n\n                ptr = (uint8_t *)env + md->offset;\n\n                switch(md->type) {\n\n                case MD_I32:\n\n                    *pval = *(int32_t *)ptr;\n\n                    break;\n\n                case MD_TLONG:\n\n                    *pval = *(target_long *)ptr;\n\n                    break;\n\n                default:\n\n                    *pval = 0;\n\n                    break;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 24559, "substitutes": {"pval": ["phprel", "pingval", "prel", "tvalue", "phpval", " pcal", "preg", "Pvalue", "pcal", "phpVal", "phpdata", "phpaval", "Ppol", " preg", "pdata", "pingdata", "phppol", "pVAL", "Prel", "mval", " pdata", "mVAL", "ppol", "PVal", "PVAL", " pvalue", " pVAL", " prel", " paval", " pVal", "tval", "pingcal", "paval", "phpreg", "tVal", " ppol", "phpcal", "Preg", "mvalue", "pVal", "pingaval", "pvalue", "mVal", "Pvals", "phpvals", "Pval", "pvals", " pvals"], "name": ["class", "type", "parent", "action", "on", "nm", "ref", "ma", "status", "term", "nam", "named", "code", "normal", "none", "w", "def", "value", "c", "id", "word", "title", "mem", "local", "command", "path", "group", "in", "comment", "cmd", "family", "n", "p", "alias", "state", "prefix", "call", "tag", "file", "old", "data", "info", "NAME", "key", "text", "base", "ame", "version", "mask", "Name", "kind", "unknown", "description", "t", "no", "m", "str", "names"], "md": ["hd", "nd", "d", "att", "mand", "sam", "mem", "del", "og", "mod", "ct", "dl", "sm", "bd", "mn", "dn", "met", "mt", "ud", "der", "pt", "sd", "tm", "ded", "obj", "bf", "mk", "det", "add", "dm", "msg", "ind", " Md", "de", "dat", "mc", " dd", "m", "ms", "ld", "amd", "multi", "mb", "mp", "def", "dj", "cd", "mm", "wd", "mind", "metadata", "cond", "di", "bind", "MD", "df", "td", "mi", "doc", "dr", "dem", "managed", "grad", "od", "pd", "ad", " cmd", "man", "ma", "ann", "ds", "mx", "ng", "cmd", "ord", "esm", "nt", "dd", "mid"], "ptr": ["inter", "pack", "cur", "adr", "address", "ref", "prototype", "then", "pc", "Ptr", "pad", "dh", "map", "ctr", "rob", "dev", "pr", "buffer", "row", "inst", "p", "pointers", "arr", "pointer", "rel", "rect", "proc", "ctx", "pos", "pl", "td", "np", "eth", "prime", "req", "ind", "attr", "ts", "ps", "dr", "loc", "addr", "txt", "alloc", "handle", "butt", "tp", "sp", "iter", "buff", "offset", "tr", "t", "jp", "dep", "index", "str", "ped", "pt"], "env": ["priv", "context", "ef", "eu", "pb", "obj", "ev", "po", "conn", "tk", "qt", "rc", "er", "cv", "dev", "ew", "var", "now", "pen", "ext", "db", "cmd", "ve", "org", "proc", "cb", "buf", "open", "ctx", "vs", "environment", "shell", "np", "nv", "attr", "bean", "loc", "txt", "window", "e", "sp", "en", "pres", "cap", "pkg", "exc", "eng", "vt", "uv", "v", "dep", "init", "ped", "tmp", "conf"]}}
{"project": "qemu", "commit_id": "5f9099d9cee0e9ed377aee705ca9f4db75e8948d", "target": 1, "func": "static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,\n                                 struct target_ucontext_v2 *uc)\n{\n    sigset_t host_set;\n    abi_ulong *regspace;\n    target_to_host_sigset(&host_set, &uc->tuc_sigmask);\n    sigprocmask(SIG_SETMASK, &host_set, NULL);\n    if (restore_sigcontext(env, &uc->tuc_mcontext))\n    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)\n#if 0\n    /* Send SIGTRAP if we're single-stepping */\n    if (ptrace_cancel_bpt(current))\n            send_sig(SIGTRAP, current, 1);\n#endif\n    return 0;", "idx": 24578, "substitutes": {"env": ["vm", "here", "context", "hw", "cur", "ef", "esc", "tm", "server", "obj", "home", "ev", "conn", "code", "viron", "config", "erd", "dev", "mem", "ec", "act", "ah", "sc", "nc", "org", "cb", "gov", "et", "ctx", "vs", "te", "environment", "enc", "eco", "desc", "window", "con", "e", "kw", "en", "net", "ptr", "exc", "eng", "uv", "proc", "v", "enter", "cv", "conf"], "frame_addr": ["frame_ref", " frame_ptr", "trace_addr", "frame___addr", "frame___ref", "trace_address", "frame2addr", "frame___prefix", "frame2address", " frame_address", "trace_ref", "frame__addr", "frame__ptr", "frame_address", "frame___address", "frame_prefix", "frame__address", "frame_ptr", "trace_prefix", "frame2ptr"], "uc": ["urn", "ux", "ui", "userc", "cu", "uf", "ucc", "orc", "bc", "usc", "uch", "tc", "uca", "rc", "nic", "ul", "upt", "ec", "um", "clus", "UC", "sc", "ut", "uci", "uk", "auc", "unc", "uph", "oc", "ocr", "anc", "ou", "uh", "alloc", "ub", "mc", "fc", "uma", "uu", "du", "ud", "u", "uv"], "host_set": ["hmodmap", "host___list", "hostnamesc", "hostmodmap", "host_sc", "addr_mask", "target_set", "target_mask", "h_map", "h_Set", "target_value", "host_list", "host___set", "host_mask", "addr_set", "host___value", "host_map", "hostmodset", "host_sets", "host_value", "hmodset", "host_Set", "h_set", "hmodSet", "hostnameset", "h_sc", "hostnamemap", "hostmodsc", "hostnameSet", "hostmodSet", "addr_map", "hmodsc", "addr_sets", "host___mask", "target_list"], "regspace": ["funcspace", "memspace", "regtab", "memsid", "regSpace", "pgSpace", "funcSpace", "pgsid", "pgspace", "memSpace", "functab", "regsid", "memtab", "funcsid", "pgtab"]}}
{"project": "qemu", "commit_id": "619d11e4631000f20318dec90b87f314272bfa4a", "target": 0, "func": "FWCfgState *pc_memory_init(MemoryRegion *system_memory,\n\n                           const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           ram_addr_t below_4g_mem_size,\n\n                           ram_addr_t above_4g_mem_size,\n\n                           MemoryRegion *rom_memory,\n\n                           MemoryRegion **ram_memory,\n\n                           PcGuestInfo *guest_info)\n\n{\n\n    int linux_boot, i;\n\n    MemoryRegion *ram, *option_rom_mr;\n\n    MemoryRegion *ram_below_4g, *ram_above_4g;\n\n    FWCfgState *fw_cfg;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* Allocate RAM.  We allocate it as a single memory region and use\n\n     * aliases to address portions of it, mostly for backwards compatibility\n\n     * with older qemus that used qemu_ram_alloc().\n\n     */\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_init_ram(ram, NULL, \"pc.ram\",\n\n                           below_4g_mem_size + above_4g_mem_size);\n\n    vmstate_register_ram_global(ram);\n\n    *ram_memory = ram;\n\n    ram_below_4g = g_malloc(sizeof(*ram_below_4g));\n\n    memory_region_init_alias(ram_below_4g, NULL, \"ram-below-4g\", ram,\n\n                             0, below_4g_mem_size);\n\n    memory_region_add_subregion(system_memory, 0, ram_below_4g);\n\n    e820_add_entry(0, below_4g_mem_size, E820_RAM);\n\n    if (above_4g_mem_size > 0) {\n\n        ram_above_4g = g_malloc(sizeof(*ram_above_4g));\n\n        memory_region_init_alias(ram_above_4g, NULL, \"ram-above-4g\", ram,\n\n                                 below_4g_mem_size, above_4g_mem_size);\n\n        memory_region_add_subregion(system_memory, 0x100000000ULL,\n\n                                    ram_above_4g);\n\n        e820_add_entry(0x100000000ULL, above_4g_mem_size, E820_RAM);\n\n    }\n\n\n\n\n\n    /* Initialize PC system firmware */\n\n    pc_system_firmware_init(rom_memory, guest_info->isapc_ram_fw);\n\n\n\n    option_rom_mr = g_malloc(sizeof(*option_rom_mr));\n\n    memory_region_init_ram(option_rom_mr, NULL, \"pc.rom\", PC_ROM_SIZE);\n\n    vmstate_register_ram_global(option_rom_mr);\n\n    memory_region_add_subregion_overlap(rom_memory,\n\n                                        PC_ROM_MIN_VGA,\n\n                                        option_rom_mr,\n\n                                        1);\n\n\n\n    fw_cfg = bochs_bios_init();\n\n    rom_set_fw(fw_cfg);\n\n\n\n    if (linux_boot) {\n\n        load_linux(fw_cfg, kernel_filename, initrd_filename, kernel_cmdline, below_4g_mem_size);\n\n    }\n\n\n\n    for (i = 0; i < nb_option_roms; i++) {\n\n        rom_add_option(option_rom[i].name, option_rom[i].bootindex);\n\n    }\n\n    guest_info->fw_cfg = fw_cfg;\n\n    return fw_cfg;\n\n}\n", "idx": 24588, "substitutes": {"system_memory": ["sys_storage", "sys_memory", "system_activity", "sys_cache", "systemitymemory", " system_database", "system_energy", "systemalactivity", "system_database", "sys_energy", "system_media", "systemitymem", "system_maximum", "sys_activity", "system_storage", "systemalmemory", "systemitymedia", "sys_maximum", "systemitydatabase", "system_mem", " system_media", "systemalmaximum", "system_cache", " system_mem", "systemalstorage"], "kernel_filename": ["kerneloxFilename", "kerneloxheader", "system_header", "kernel_directory", "disk_Filename", "system_Filename", "disk_file", "kernel2file", "kernel_header", "kerneloxfilename", "kernel_Filename", "kernel2directory", "disk_directory", "system_file", "system_filename", "kernel2filename", "disk_filename", "kernel_file", "kernel2Filename", "kerneloxfile"], "kernel_cmdline": ["kernel_programline", "kernel_commandline", "kernel_cmdl", "kernel_cmdlist", "kernel_programlist", "kernel_commandlist", "kernel_commandl", "kernel_cpline", "kernel_programl", "kernel_cplist", "kernel_cpl"], "initrd_filename": ["initringuartflags", "initrduartfilename", "initringuartfolder", "initrdfilefolder", "initrd_flags", "initrduartflags", "initring_folder", "initrdfilelocation", "initring_filename", "initring_location", "initrdfilefilename", "initrduartlocation", "initrd_folder", "initringuartlocation", "initrduartfolder", "initrdfileflags", "initring_flags", "initrd_location", "initringuartfilename"], "below_4g_mem_size": ["below_4g_memsSize", "below_4g_Mem_sum", "below_4g_memory_Size", "below_4g_mem2name", "below_4g_memory_to", "below_4g_mem_name", "below_4g_mem_to", "below_4g_memsto", "below_4g_Mem_size", "below_4g_memory_size", "below_4g_mem_member", "below_4g_mem_SIZE", "below_4g_mem2SIZE", "below_4g_memssize", "below_4g_mem_sum", "below_4g_mem_Size", "below_4g_Mem_SIZE", "below_4g_mem2size"], "above_4g_mem_size": ["above_4g_mem_Size", "above_4g_mem2SIZE", "above_4g_memLsize", "above_4g_mem_name", "above_4g_Mem_SIZE", "above_4g_mem_sum", "above_4g_mem_SIZE", "above_4g_mem2name", "above_4g_mem2size", "above_4g_memLpower", "above_4g_Mem_sum", "above_4g_memLSIZE", "above_4g_mem_power", "above_4g_Mem_name", "above_4g_Mem_size", "above_4g_Mem_power", "above_4g_Mem_Size"], "rom_memory": ["system_queue", "ram_storage", "rom_library", "system_session", "rom_queue", "rom___storage", "ram_mem", "rom_mem", "romplestorage", "rom___session", "ram_library", "romplememory", "rom_storage", "romplesession", "rom_session", "rom___queue", "system_storage", "romplequeue", "rom___memory"], "ram_memory": ["ram__reference", "ram_storage", "ram_reference", "system_address", "rom_media", "ram2address", "ram2memory", "system_media", "ram_address", "ram2storage", "ram___memory", "ram__address", "ram__memory", "system_storage", "ram2media", "ram_media", "ram___address", "ram__media", "rom_address", "rom_reference", "ram___media", "ram___storage"], "guest_info": ["guest_settings", "guer_info", "guess_settings", "guess_Info", "guer_Info", "guest_id", "guer_information", "guess_id", "guest_Info", "guest_information", "guess_info"], "linux_boot": ["Linux_start", "Linux_boot", "linux_Boot", "linux_oot", "linux8linux", "linux8Boot", "Linux_Boot", "linux8boot", "Linux_linux", "Linux_oot", "linux_start", "linux_linux", "linux8start"], "i": ["f", "it", "pi", "c", "k", "fi", "g", "r", "I", "n", "p", "phi", "di", "j", "mi", "ii", "li", "b", "l", "ti", "bi", "y", "ci", "ir", "ib", "si", "t", "m"], "ram": ["tar", "sd", "region", "my", "vm", "dim", "mac", "range", "amd", "mix", "storm", "hw", "tx", "cam", "gray", "rm", "rum", "ma", "ru", "Ram", "mb", "rain", "ray", "program", "sam", "core", "sky", "reg", "mem", "mm", "dev", "ry", "um", "cpu", "row", "lam", "gram", "iam", "tem", "memory", "rom", "ra", "rem", "sim", "area", "go", "raw", "scan", "am", "rank", "lib", "ance", "dem", "alloc", "mc", "AM", "ame", "gra", "ank", "gem", "serv", "win", "ream", "RAM", "usage", "im", "sum", "ro", "res"], "option_rom_mr": ["option_cmexec", "option_rom2vr", "option_rom_vr", "option_mem_kr", "optionalsromexec", "option_rom__kr", "option_rom_rm", "option_chrom_rm", "option_romexec", "option_mem_rs", "option_chrom_mr", "option_rom2mr", "option_rom2rm", "option_rom2hr", "option_rom_rs", "option_rom__rs", "optionalsraexec", "option_rom__mr", "option_rom_kr", "option_memexec", "option_rom__hr", "option_chrom_hr", "option_rom_hr", "option_mem_mr", "option_raexec", "option_chrom_vr", "option_mem_hr"], "ram_below_4g": ["ram_below_44j", "ram_below_fourg", "ram_below_fourv", "ram_below_4G", "ram_below_5l", "ram_below_4j", "ram_below_04g", "ram_below_5j", "ram_below_4v", "ram_below_04gu", "ram_below_2d", "ram_below_2l", "ram_below_44l", "ram_below_2g", "ram_below_8p", "ram_below_5d", "ram_below_04d", "ram_below_44g", "ram_below_8l", "ram_below_fourj", "ram_below_fourG", "ram_below_04j", "ram_below_5g", "ram_below_2p", "ram_below_4gu", "ram_below_2gu", "ram_below_2G", "ram_below_8g", "ram_below_04v", "ram_below_2j", "ram_below_44G", "ram_below_8j", "ram_below_04G", "ram_below_4l", "ram_below_4d", "ram_below_2v", "ram_below_4p"], "ram_above_4g": ["ram_above_49g", "ram_above_5gi", "ram_above_4v", "ram_above_04G", "ram_above_4m", "ram_above_2gi", "ram_above_04g", "ram_above_44l", "ram_above_2m", "ram_above_fourgi", "ram_above_44j", "ram_above_4j", "ram_above_4G", "ram_above_5j", "ram_above_4gi", "ram_above_5v", "ram_above_fourj", "ram_above_44g", "ram_above_2f", "ram_above_14l", "ram_above_49v", "ram_above_5g", "ram_above_14og", "ram_above_4og", "ram_above_fourm", "ram_above_49og", "ram_above_fourg", "ram_above_14g", "ram_above_5m", "ram_above_44G", "ram_above_04j", "ram_above_fourl", "ram_above_5og", "ram_above_14v", "ram_above_5l", "ram_above_4l", "ram_above_2g", "ram_above_49l", "ram_above_04l", "ram_above_2j", "ram_above_2l", "ram_above_44f", "ram_above_4f"], "fw_cfg": ["hw_config", "fw__fg", "fw_conf", "hw_conf", "fw__conf", "fw__config", "fw_config", "fw__cfg", "hw_fg", "hw_cfg", "fw_fg"]}}
{"project": "qemu", "commit_id": "c5ce83334465ee5acb6789a2f22d125273761c9e", "target": 0, "func": "static void press_key(VncState *vs, int keysym)\n\n{\n\n    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);\n\n    qemu_input_event_send_key_delay(0);\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);\n\n    qemu_input_event_send_key_delay(0);\n\n}\n", "idx": 24603, "substitutes": {"vs": ["vm", "ms", "Vs", "sb", "ops", "values", "ues", "ails", "vd", "ins", "lbs", "fs", "rs", "vp", "lists", "ses", "ds", "hs", "ks", "ques", "plays", "pages", "helps", "changes", "s", "lines", "blogs", "fps", "cs", "sts", "vr", "ils", "bs", "js", "pins", "ss", "xs", "wcs", "VS", "ns", "ts", "vc", "ps", "vals", "stats", "its", "sv", "obs", "atts", "ls", "vt", "heads", "v", "views"], "keysym": ["ksys", "keysy", "keysemb", "keyssym", "ksemb", " keysymm", "keysys", "ksymm", "kssym", " keysy", "keysymm", "namesemb", " keysemb", "ksy", " keyssym", "codesys", "namesym", "codessym", "codesy", "namesymm", "namesy", " keysys", "ksym", "codesym"]}}
{"project": "qemu", "commit_id": "8172539d21a03e982aa7f139ddc1607dc1422045", "target": 0, "func": "static void s390_virtio_device_sync(VirtIOS390Device *dev)\n\n{\n\n    VirtIOS390Bus *bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);\n\n    ram_addr_t cur_offs;\n\n    uint8_t num_vq;\n\n    int i;\n\n\n\n    virtio_reset(dev->vdev);\n\n\n\n    /* Sync dev space */\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_TYPE, dev->vdev->device_id);\n\n\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, s390_virtio_device_num_vq(dev));\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_FEATURE_LEN, dev->feat_len);\n\n\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG_LEN, dev->vdev->config_len);\n\n\n\n    num_vq = s390_virtio_device_num_vq(dev);\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, num_vq);\n\n\n\n    /* Sync virtqueues */\n\n    for (i = 0; i < num_vq; i++) {\n\n        ram_addr_t vq = (dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG) +\n\n                        (i * VIRTIO_VQCONFIG_LEN);\n\n        ram_addr_t vring;\n\n\n\n        vring = s390_virtio_next_ring(bus);\n\n        virtio_queue_set_addr(dev->vdev, i, vring);\n\n        virtio_queue_set_vector(dev->vdev, i, i);\n\n        stq_phys(vq + VIRTIO_VQCONFIG_OFFS_ADDRESS, vring);\n\n        stw_phys(vq + VIRTIO_VQCONFIG_OFFS_NUM, virtio_queue_get_num(dev->vdev, i));\n\n    }\n\n\n\n    cur_offs = dev->dev_offs;\n\n    cur_offs += VIRTIO_DEV_OFFS_CONFIG;\n\n    cur_offs += num_vq * VIRTIO_VQCONFIG_LEN;\n\n\n\n    /* Sync feature bitmap */\n\n    if (dev->vdev->get_features) {\n\n        stl_phys(cur_offs, dev->vdev->get_features(dev->vdev));\n\n    }\n\n\n\n    dev->feat_offs = cur_offs + dev->feat_len;\n\n    cur_offs += dev->feat_len * 2;\n\n\n\n    /* Sync config space */\n\n    if (dev->vdev->get_config) {\n\n        dev->vdev->get_config(dev->vdev, dev->vdev->config);\n\n    }\n\n\n\n    cpu_physical_memory_rw(cur_offs, dev->vdev->config, dev->vdev->config_len, 1);\n\n    cur_offs += dev->vdev->config_len;\n\n}\n", "idx": 24606, "substitutes": {"dev": ["range", "patch", "pay", "stick", "app", "d", "mem", "var", "build", "vol", "mod", "raw", "draw", "der", "pkg", "v", "pack", "dis", "obj", "ev", "conn", "gu", "cast", "db", "det", "ver", "spec", "add", "th", "desc", "data", "de", "des", "oy", "prom", "hw", "device", "game", "cam", "roy", "pad", "normal", "def", "comment", "disc", "go", "form", "doc", "test", "dem", "serv", "driver", "grad", "od", "priv", "block", "prop", "ad", "server", "err", "home", "ay", "w", "ow", "watch", "sky", "debug", "md", "cmd", "DEV", "ve", "develop", "util", "av", "die", "scan", "req", "nt", "dd", "Dev", "pro", "val", "end"], "bus": ["block", "Bus", "device", "board", "type", "out", "hand", "gen", "bridge", "boot", "box", " BUS", "os", "host", "bc", "bank", "us", "config", "c", "bolt", "disk", "proxy", "local", "db", "BUS", "vol", "util", "hub", "buf", "bar", "bs", "chain", "way", "b", "usb", "vc", "is", "ac", "nt", "port", "lib", "link", "base", "handle", "con", "serv", "driver", "self", "loop", "lock", "mount"], "cur_offs": [" cur_ops", " cur_ups", "cur___phones", "cur___off", "cur_phones", "cur_outs", "cat_phones", "cat_off", "cur_ups", " cur_posts", "cur___ups", "cur___offs", "cur___opens", "cat_opens", "cur_pos", "cur___outs", "cur_posts", " cur_pos", "cur_opens", " cur_off", "cur_ops", "cat_offs", " cur_outs", "cur_off"], "num_vq": ["num_quq", "num_vinue", "numoothvq", "num_vsple", "num___vq", "num_uq", "num_quQ", "numoothvQ", "num_vinf", "numoothvqs", "num_vig", "num___vQ", "num___vig", "num_uqu", "num_vsig", "num_vinck", "num_vsq", "num_vqu", "num_vmig", "num_vinq", "num_fcu", "num_vf", "num_veue", "num_vqi", "num_fig", "num_fple", "num_fqs", "num_avq", "num_vmq", "num_visQ", "num_svQ", "num_vinQ", "num_viue", "num_qucu", "num_vmQ", "num_vck", "num_vick", "num_vple", "num_veque", "num_visqi", "num_uqs", "num_vmple", "num___vsq", "numoothvcu", "num_veck", "num_svqi", "num_vque", "num_svqu", "num_visf", "num_vQ", "num_vequ", "num_veq", "num___vsig", "numoothquQ", "num___vsQ", "num_visq", "num_veQ", "num_vcu", "num_vue", "num_vinqi", "num___vsple", "num_veqs", "numoothquqs", "num_uQ", "num_fQ", "num_svqs", "num_viq", "num_svq", "num_avQ", "num_vsQ", "num___vple", "num_vinque", "num_avqs", "numoothquq", "num_vqs", "num_fq", "num_vique", "num_avcu", "num_svf", "num_quqs", "numoothqucu"], "i": ["it", "ic", "my", "x", "batch", "ui", "ki", "multi", "\u0438", "o", " multi", "ami", "pi", " ni", " ii", "ini", "index", "id", "ri", "in", "me", "gi", "I", "n", "p", "phi", " bi", "s", "di", "zi", "sim", "j", "ai", " v", "asi", "mi", "li", "ii", "iq", "h", "hi", "is", "ti", "ind", " ti", "bi", " pi", " mi", "ims", "y", "ci", "ij", "ip", "e", " si", "u", "iu", " I", " m", "si", "t", "im", "xi", "m", "v", "qi", "cli", " index", "name", "ei", "ix"], "vring": ["vjing", " vstring", "vmrings", "vstring", "wring", " vlic", "qvring", "svng", "vlic", "mling", "frings", "qvjing", " vri", "svling", "fng", " vjing", "svbinding", "flic", "qvstring", "vling", "mng", "svg", " vling", "vng", "ivling", "mring", "vg", "fring", "ivring", "mbinding", " vrings", "qvling", "svring", " vng", "ivri", "vmng", "vmring", " vbinding", "ivg", " vg", "vrings", "svri", "wling", "wjing", "vbinding", "vri", "vmlic", "wstring"]}}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){\n\n    int i;\n\n    int dc0, dc2;\n\n    pixel4 dc0splat, dc2splat;\n\n    pixel *src = (pixel*)_src;\n\n    stride /= sizeof(pixel);\n\n\n\n    dc0=dc2=0;\n\n    for(i=0;i<4; i++){\n\n        dc0+= src[-1+i*stride];\n\n        dc2+= src[-1+(i+4)*stride];\n\n    }\n\n    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);\n\n    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);\n\n\n\n    for(i=0; i<4; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= dc0splat;\n\n    }\n\n    for(i=4; i<8; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= dc2splat;\n\n    }\n\n}\n", "idx": 24621, "substitutes": {"_src": ["___ser", " _ser", "_ser", "_source", "___source", " _rc", " _source", "_rc", "___rc", "_sys", "___src", " _sys"], "stride": ["strate", " strine", "trision", " strate", "STRider", "sline", "voline", "arrine", "Strider", "striine", "slice", "slode", "Strine", "stringide", "stringision", "stringine", "Strride", "STRice", "volride", " strride", "scheine", "struse", "strider", "volide", "arrice", "brate", "Strimate", "slision", "stringride", "strice", "striuse", "Strope", "striride", "scheide", "stide", "strine", "STRode", " strimate", "brope", "stringice", "strride", "Strice", "striide", "trice", "slider", "brride", "arrride", "strision", "STRuse", "STRride", " strode", "Stride", "STRine", "stine", "STRimate", "stringider", "trider", "strope", "scheride", " strider", "strimate", "tride", "volice", " strope", "bride", "slide", "strode", "arride", "STRide", "scheider", "stuse", "Strate"], "i": ["ui", "o", "ie", "ini", "id", "er", "PI", "in", "r", "I", "p", " bi", "s", "sim", "ai", "li", "info", "ip", "ij", "y", "ci", "iu", "si", "MI", "ei", "ji", "ki", "\u0438", "ik", " ii", "at", "n", "io", "j", "init", "ind", "ims", "key", "mc", "iter", "uri", "m", "point", "qi", "ix", "iii", "my", "batch", "x", "multi", "ami", "ri", "phi", "di", "oi", "zi", "go", "mi", "ii", "print", "is", "l", " ti", "bi", "dr", "xi", "im", "q", "this", "f", "it", "ic", "err", "pi", "ex", "g", "me", "gi", "to", "iq", "hi", "ti", "php", "port", "e", "index", "cli", "name"], "dc0": ["bc50", "disc0", "rc0", "bczero", "disc2", " dc9", "bcator", "DC0", "disc1", " dc1", "dc9", "dc50", " dc50", "bc6", "dc00", "dcator", "disc9", "ccaator", "fc00", "rc00", "cca6", "fcZero", "dc1", "fc0", "bc0", "dcZero", "DC7", " dczero", " dcator", "bc2", "disc50", " dc6", "disc7", "rcZero", "dc6", "ccazero", " dc00", "dc7", "DC1", " dcZero", "cca0", " dc7", "dczero", "bc9"], "dc2": ["disc0", "bcTwo", "disc3", "disc2", "dc5", "cd02", " dc_", "fc3", "cd2", " dc02", "dcTwo", "di_", "bc3", "lc2", "cdTwo", "lc4", " dc4", "di02", "di2", "fc0", "bc0", "fc5", "fc_", "dc4", "dc3", "di4", "bc2", "cd5", "di3", "disc02", "dc_", "lcTwo", "cd0", "disc5", "cd3", "discTwo", "diTwo", " dcTwo", "fc2", "fc02", " dc3", "dc02"], "dc0splat": ["dc0bspit", "dc0scicit", "dc0scat", "dc0explats", "dc2splant", "dc0polant", "dc1splatch", "dc5splititter", "dc2SplAT", "dc0splitats", "dc0splatted", "dc2Splat", "dc0Splant", "dc1split", "dc0splitter", "dc0explat", "dc0SplAT", "dc5splitatted", "dc0split", "dc1plit", "dc0scit", "dc0plit", "dc1plicit", "dc0separitter", "dc0splitatted", "dc0separatted", "dc2split", "dc0splAT", "dc0separat", "dc0Split", "dc1platch", "dc2Split", "dc0splititter", "dc0bspat", "dc0splicit", "dc1splat", "dc0plant", "dc5splatted", "dc1splicit", "dc0splant", "dc0splats", "dc2Splant", "dc0bspicit", "dc0bspatch", "dc5splitter", "dc0plAT", "dc0polat", "dc0scatch", "dc5splats", "dc5splat", "dc2splAT", "dc0Splat", "dc5splitats", "dc0polAT", "dc0plat", "dc0splatch", "dc0explitter", "dc0splitat", "dc0plicit", "dc1plat", "dc0platch", "dc5splitat", "dc0separats", "dc0polit", "dc0explatted"], "dc2splat": ["dc2plat", "dc2platio", "dc2plAT", "dc3Splat", "dc7splate", "dc1SplAT", "dc2Splate", "dc2SplAT", "dc1Splat", "dc2Splat", "dc3splate", "dc2plate", "dc3Splate", "dc2splot", "dc1splAT", "dc3splat", "dc2Splot", "dc2splate", "dc2plot", "dc2splitit", "dc1split", "dc1Splot", "dc7splitatio", "dc3SplAT", "dc1splot", "dc2split", "dc3Split", "dc7splitit", "dc2spAT", "dc3splAT", "dc7splatio", "dc2Split", "dc3split", "dc2splatio", "dc7splat", "dc2spit", "dc1Split", "dc7splitat", "dc1splat", "dc2spot", "dc7split", "dc2splitatio", "dc2Splatio", "dc2splAT", "dc2splitat", "dc2plit", "dc2spate", "dc7splitate", "dc2splitate", "dc2spat"], "src": ["sys", "sn", "cur", "sb", "obj", "rl", "ins", "slice", "syn", "iv", "bc", "rs", "usc", "config", "ur", "rc", "ctr", "cont", "sl", "seq", "sup", "sync", "inst", "r", "spec", "sr", "supp", "sc", "ser", "img", "rect", "dest", "usr", "sw", "vr", "dist", "root", "input", "RC", "bs", "scan", "rt", "inner", "req", "attr", "loc", "txt", "addr", "sur", "url", "st", "fc", "tp", "iter", "hl", "via", "source", "ptr", "pkg", "tmp", "proc", "filename", "str", "cli"]}}
{"project": "FFmpeg", "commit_id": "48aecf5a7dd8e914d44cb4210a09172dbd8d5d86", "target": 1, "func": "static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,\n\n                           const uint8_t *sps_pps, uint32_t sps_pps_size,\n\n                           const uint8_t *in,      uint32_t in_size) {\n\n    uint32_t offset = *poutbuf_size;\n\n    uint8_t nal_header_size = offset ? 3 : 4;\n\n\n\n    *poutbuf_size += sps_pps_size+in_size+nal_header_size;\n\n    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);\n\n    if (sps_pps)\n\n        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);\n\n    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);\n\n    if (!offset)\n\n        AV_WB32(*poutbuf+sps_pps_size, 1);\n\n    else {\n\n        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;\n\n        (*poutbuf+offset)[2] = 1;\n\n    }\n\n}\n", "idx": 24625, "substitutes": {"poutbuf": ["pOutqueue", "pwbuff", "paoutport", "pinbox", "pourbox", "pontbound", "paontbound", "pexport", "poutiter", "poubuffer", "Poutbuffer", "piongbuf", "paouterpkg", "pandbuf", "pongvec", "psoutstream", "paoubuffer", "poutqueue", "pourbound", "poldcb", "paoutiter", "poutbatch", "psoutbuf", "pandport", "Pinproc", "pinnerbin", "pongbatch", "paoutfac", "pongbag", "pouterrc", "toutbuffer", "pinbound", " poutbuffer", "psoutbatch", "poutcat", "tincv", "pinnerbuffer", "pnotbuf", "pongbuf", "tinbuf", "poufunc", "Poutqueue", "pinnerqueue", "pwcv", "poutbc", "pinnerbuf", "pinbuff", "pouterport", " poutbox", "pioutbag", "pouterpkg", "toutcv", "poutbag", "piongcb", "pentstream", "ponbin", "pOutbuff", "pinnerproc", "poutsbin", "poutbin", "pinbuf", "pentbuf", "panditer", "psongstream", "poncache", "poutfac", "paouterport", "paoutbuf", "pioutcb", "paoutbuffer", "poutscat", "psongbatch", "toutbuf", "paoubuf", "pinfunc", "panotbuf", "poutcv", "pioutrc", "paoufunc", "paoutbc", "paoutcache", "poldrc", "poutscache", "pourbuffer", "paoutbound", "pinbin", "Poutbuf", "pdobuf", "pdobc", "poutpkg", "poutport", " pexbox", "poutvec", " pexbuf", "poutbuffer", "pdocat", "pouterbag", "Pinqueue", "poldbuf", "paoutbin", "psoutvec", "pioutbuf", "poutbuff", "Poutproc", "pinnerbatch", "paoubin", "pOutproc", " pexbuffer", "pwbuffer", "pnotfac", "psongvec", "piongbag", " poutbound", "pontbuf", "poutrc", "pontbc", "pongstream", "panotcache", "pinqueue", "pinnerfunc", "tinbuff", "panotbin", "pentvec", " pexbound", "pinproc", "pnotcache", "poutsbc", "paoutpkg", "pontcat", "paontbc", "piongrc", "poutstream", "pentbatch", "paontbuf", "pouterbuf", "pandpkg", "poutproc", "poutcache", "pwbuf", "pOutbuffer", "pOutcv", "pexbuffer", "paouteriter", "paouterbuf", "pinbuffer", "poutcb", "pincv", "Pinbuffer", "poutercb", "paontcat", "paoutfunc", "poutbox", "Pinbuf", "pexbuf", "pexiter", "poutsfac", "pOutbuf", "poldbag", "poutbound", "pnotbin", "paoutcat", "pinnervec", "pexpkg", "toutbuff", "pdobound", "pinnerstream", "pongcb", "tinbuffer", "panotfac", "psongbuf", "poubin", "pexbox", "ponfac", "poutsbound", "ponbuf", "poubuf", "poutfunc", "poutsbuf", "pongrc", "pourbuf", "pouteriter", "pexbound"], "poutbuf_size": ["poutbuf_space", "poutbuffer_name", "poutqueue_SIZE", "poutbuffer_ize", "poutbuf_SIZE", "poutbuffer_length", "poutbuf_len", "poutbuffer_size", "poutqueue_size", "poutqueue_Size", "poutbuf_name", "poutbuffer_len", "poutqueue_sy", "poutbuffer_space", "poutbuf_ize", "poutbuf_sy", "poutbuf_length", "poutbuf_Size", "poutbuffer_Size"], "sps_pps": ["sps__pps", "spe_ppers", "sps_bps", "sps_ps", "sps2pps", "sps___bps", "spsitypp", "sps___pp", "sps__pp", "sPS_ps", "sapes_ppy", "sapes_ps", "spe_pp", "sps_ppy", "spsityps", "spe_ps", "sps__ps", "spsityppers", "sPS_pp", "sps___ps", "sps2pp", "sPS_pps", "speitypps", "sPS_bps", "sps_pp", "speityps", "spe_pps", "sapes_pps", "sps_ppers", "sps__ppers", "sps2bps", "sapes_pp", "speitypp", "sps___pps", "spsitypps", "sps2ps", "speityppers"], "sps_pps_size": ["sps_ps_Size", "sps_ppa_SIZE", "sps_pps_Size", "sps_ps_sum", "sps_ps_size", "sps_pps_space", "sps_ppa_length", "sps_pp_size", "sps_pp_length", "sps_pps_SIZE", "sps_ppa_size", "sps_pps_sum", "sps_ps_scope", "sps_ps_SIZE", "sps_pps_scope", "sps_pps_length", "sps_pp_Size", "sps_ps_space"], "in": ["isin", "it", "ic", "i", "out", "inf", "inc", "ins", "c", "id", "gin", "p", "s", "input", "inv", "vin", "mi", "raw", "doc", "inner", "is", "data", "ind", "In", "ac", "rin", "inn", "din", "nin", "st", "bin", "con", "IN", "h", "t", "all", "m", "str"], "in_size": ["in_name", "in_len", "ini67speed", "in_Size", "ini67SIZE", "ini_SIZE", "out_shape", "in_SIZE", "in_count", " in_Size", "in_speed", "in67length", "in_shape", "out_size", " in_name", "in67SIZE", "in_length", "in67size", "ini67size", "out_count", " in_len", "out_Size", "in67speed", "ini_length", "ini_speed", "ini67length", "ini_size"]}}
{"project": "qemu", "commit_id": "164a101f28a53cd3db60ed874e7c3630e7988ed8", "target": 1, "func": "void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *e,\n\n                            EventNotifierHandler *io_notify,\n\n                            AioFlushEventNotifierHandler *io_flush)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->e == e && !node->deleted) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Are we deleting the fd handler? */\n\n    if (!io_notify) {\n\n        if (node) {\n\n            g_source_remove_poll(&ctx->source, &node->pfd);\n\n\n\n            /* If the lock is held, just mark the node as deleted */\n\n            if (ctx->walking_handlers) {\n\n                node->deleted = 1;\n\n                node->pfd.revents = 0;\n\n            } else {\n\n                /* Otherwise, delete it for real.  We can't just mark it as\n\n                 * deleted because deleted nodes are only cleaned up after\n\n                 * releasing the walking_handlers lock.\n\n                 */\n\n                QLIST_REMOVE(node, node);\n\n                g_free(node);\n\n            }\n\n        }\n\n    } else {\n\n        if (node == NULL) {\n\n            /* Alloc and insert if it's not already there */\n\n            node = g_malloc0(sizeof(AioHandler));\n\n            node->e = e;\n\n            node->pfd.fd = (uintptr_t)event_notifier_get_handle(e);\n\n            node->pfd.events = G_IO_IN;\n\n            QLIST_INSERT_HEAD(&ctx->aio_handlers, node, node);\n\n\n\n            g_source_add_poll(&ctx->source, &node->pfd);\n\n        }\n\n        /* Update handler with latest information */\n\n        node->io_notify = io_notify;\n\n        node->io_flush = io_flush;\n\n    }\n\n\n\n    aio_notify(ctx);\n\n}\n", "idx": 24626, "substitutes": {"ctx": ["sys", "cl", "hw", "context", "fx", "stack", "cmp", "x", "tx", "cf", "obj", "xy", "jac", "Context", "ca", "conn", "bc", "pc", "config", "c", "tc", "kt", "crit", "tz", "params", "ck", "act", "ctrl", "height", "func", "cmd", "ctl", "cp", "p", "sc", "nc", "org", "resp", "cb", "cm", "co", "cfg", "comp", "req", "ct", "xc", "wcs", "anc", "desc", "expr", "nt", "loc", "addr", "window", "px", "fc", "aux", "course", "kw", "xp", "etc", "pkg", "kl", "t", "cc", "jp", "conv", "wx", "cv", "conf"], "e": ["f", "it", "ep", "i", "x", "ea", "eu", "ef", "ing", "o", "ce", "obj", "eps", "ev", "re", "eeee", "entity", "se", "d", "ie", "ent", "c", "ex", "er", "event", "ec", "g", "r", "ed", "n", "el", "ge", "p", "s", "le", "et", "eg", "pe", "te", "enc", "eb", "ne", "E", "a", "ele", "b", "element", "l", "de", "y", "es", "xe", "en", "u", "h", "end", "t", "q", "m", "v", "ee", "ae", "ei"], "io_notify": ["io_annification", "io__notsync", "io_listify", "io_nify", "io_notine", "io_listize", "io_Notist", "io__notify", "io_prifier", "io_Notize", "io_nification", "io_disise", "io_nif", "io_disine", "io_notig", "io_Notif", "io_signize", "io_disify", "io_notif", "io_notsync", "io_disifier", "io_annify", "io_noise", "io_noine", "io_annif", "io_prify", "io_Notify", "io__notifier", "io_nist", "io_signify", "io_signification", "io_notifier", "io_prise", "io_noifier", "io_annsync", "io_annifier", "io_notification", "io_notise", "io_noify", "io_listification", "io_prine", "io_Notification", "io__notification", "io_signig", "io_notize", "io_listig", "io_annist", "io_Notig", "io_notist"], "io_flush": ["i_sync", "ioacsave", "io_save", "io2flush", "iocflat", "ilocflush", "io___write", "i_open", "ioacflush", "iozsend", "ilocflat", "iopresync", "ilocbuild", "i_destroy", "ioacsync", "iojbuild", "iopreflush", "io2send", "io_send", "iojwrite", "iojflush", "ilocwrite", "io_flat", "i_send", "io2open", "io2ush", "io_build", "iopredestroy", "ilo_write", "ioacdestroy", "iopresave", "iojflat", "ilo_flat", "io_sync", "i_flush", "ilo_build", "io_write", "ilo_flush", "iocflush", "iozflush", "iozush", "io___build", "io_ush", "i_save", "i_ush", "io_destroy", "iozopen", "iocbuild", "iocwrite", "io_open", "io___flat", "io___flush"], "node": ["handler", "hd", "field", "see", "nd", "station", "host", "child", "none", "array", "valid", "c", "id", "nut", "create", "mem", "false", "or", "Node", "p", "new", "call", "info", "save", "page", "y", "document", "stable", "link", "step", "gc", "ptr", "table", "max", "note", "parent", "obj", "store", "item", "edge", "entry", "db", "good", "n", "tip", "remote", "add", "msg", "ye", "stage", "function", "total", "inner", "primary", "desc", "data", "key", "window", "eval", "m", "callback", "ready", "tree", "device", "our", "peer", "nn", "box", "normal", "pad", "thus", "k", "now", "linked", "fn", "ne", "process", "addr", "worker", "adj", "tmp", "manager", "no", "sum", "parse", "od", "server", "null", "ref", "se", "component", "bo", "wrapper", "event", "master", "local", "object", "row", "g", "empty", "cmd", "list", "cache", "holder", "connected", "root", "slave", "nw", "module", "nu", "message", "np", "instance", "ode", "nt", "post", "load", "num", "missing", "copy", "check", "self", "seed", "source", "leaf", "t", "index", "name"]}}
{"project": "FFmpeg", "commit_id": "40ad05bab206c932a32171d45581080c914b06ec", "target": 0, "func": "int float_near_ulp(float a, float b, unsigned max_ulp)\n\n{\n\n    union av_intfloat32 x, y;\n\n\n\n    x.f = a;\n\n    y.f = b;\n\n\n\n    if (is_negative(x) != is_negative(y)) {\n\n        // handle -0.0 == +0.0\n\n        return a == b;\n\n    }\n\n\n\n    if (abs(x.i - y.i) <= max_ulp)\n\n        return 1;\n\n\n\n    return 0;\n\n}\n", "idx": 24629, "substitutes": {"a": ["f", "xa", "af", "sa", "ea", "as", "i", "o", "ca", "al", "ma", "sta", "d", "w", "c", "ia", "at", "A", "apa", "aa", "ar", "p", "ao", "va", "ax", "ra", "an", "au", "ta", "am", "da", "ach", "ac", "eas", "l", "ba", "la", "alpha", "aaa", "ab", "t", "oa", "\u00e1", "ae"], "b": ["f", "bb", "fb", "i", "sb", "br", "mb", "nb", "bc", "c", "bf", "B", "g", "db", "n", "beta", "bis", "ob", "cb", "j", "bs", "eb", "l", "bi", "ba", "z", "e", "rb", "bp", "by", "u", "ib", "ab", "t", "be", "v", "m"], "max_ulp": [" max_pdf", "max_imp", " max_imp", "max_pdf", "max_fp", "max_raf", " max_fp", " max_raf"], "x": ["f", "fx", "xa", " cx", "i", " ax", "ux", "tx", "xy", "xd", "xml", "w", "xt", " xx", "ex", "yx", "one", "at", "dx", "mx", "rx", " X", "p", "ax", "lat", "X", "xx", "xs", "xf", "zx", "l", "xc", "ox", "z", "px", "xp", "u", "xi", "lex", "v", "wx", "ix"], "y": ["sys", "my", "i", "gy", "xy", "ay", "fy", "yt", "yi", "ry", "ty", "yy", "uy", "iy", "yer", "ady", "iny", "axy", "ny", "yl", "ye", "ot", "cy", "yo", "vy", "hy", "yr", "py", "ies", "z", "yd", "ey", "ya", "ys", "oy", "ly", "Y", "ym", "v", "sy"]}}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int roq_dpcm_encode_init(AVCodecContext *avctx)\n\n{\n\n    ROQDPCMContext *context = avctx->priv_data;\n\n\n\n    if (avctx->channels > 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be mono or stereo\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_rate != 22050) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be 22050 Hz\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_fmt != AV_SAMPLE_FMT_S16) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be signed 16-bit\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avctx->frame_size = ROQ_FIRST_FRAME_SIZE;\n\n\n\n    context->lastSample[0] = context->lastSample[1] = 0;\n\n\n\n    avctx->coded_frame= avcodec_alloc_frame();\n\n\n\n\n\n    return 0;\n\n}", "idx": 24631, "substitutes": {"avctx": ["afctl", "ajheight", "avtmp", "averctx", "afresp", "aftx", "ajkt", "tencontext", "wavtx", "avesys", "afpy", " avca", "avhandle", " avgc", "averheight", "vansys", "avheight", "averctl", "tenctx", "avpkg", "averpkg", "avcmp", "aftmp", "aveca", "wavcontext", "avca", "avertmp", "vanctx", "afkw", "aveaddr", "ajtx", "wavctl", "afobj", "Avcontext", "avercontext", "avresp", "ajcmd", "wavtc", "avpy", "avsys", "afcontext", "wavkt", " avpkg", "avgc", "afpkg", " avcontext", "ajobj", "averobj", "avercmp", "averresp", "avecontext", "vanhandle", "ajctx", "Avtx", "averkw", "Avctx", "afheight", "avtc", "ajpy", "wavthis", "avectx", "avkt", "afctx", "afthis", "avtx", "avkw", " avtc", "wavcmd", "avcmd", "afcmp", "Avca", "avthis", "avetx", " avtmp", "avertc", "avcontext", "tenresp", "wavgc", " avcmp", "averpy", "avobj", "avctl", "wavctx", "aversys", "avercmd", "avertx", "vanaddr", "wavtmp", " avtx", "avegc", "averkt", "tenkw", "avaddr", "averthis", "averhandle", "wavpkg", "avehandle", "averaddr"], "context": ["iterator", "client", "tx", "where", "Context", "address", "condition", "subject", "status", "component", "distance", "config", "map", "c", "that", "operator", "result", "profile", "buffer", "local", "command", "path", "translation", "resource", "metadata", "collection", "cache", "close", "count", "filter", "module", "ctx", "policy", "environment", "message", "sequence", "connection", "settings", "information", "section", "chain", "capacity", "data", "info", "public", "document", "reason", "text", "history", "json", "version", "position", "support", "package", "scope", "content", "index"]}}
{"project": "qemu", "commit_id": "e957f6a9b92439a222ecd4ff1c8cdc9700710c72", "target": 1, "func": "static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,\n\n                                  sPAPRMachineState *spapr)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);\n\n    int index = ppc_get_vcpu_dt_id(cpu);\n\n    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                       0xffffffff, 0xffffffff};\n\n    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()\n\n        : SPAPR_TIMEBASE_FREQ;\n\n    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n    uint32_t page_sizes_prop[64];\n\n    size_t page_sizes_prop_size;\n\n    uint32_t vcpus_per_socket = smp_threads * smp_cores;\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};\n\n    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));\n\n    sPAPRDRConnector *drc;\n\n    sPAPRDRConnectorClass *drck;\n\n    int drc_index;\n\n    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];\n\n    int i;\n\n\n\n    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, index);\n\n    if (drc) {\n\n        drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n        drc_index = drck->get_index(drc);\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index)));\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"reg\", index)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"device_type\", \"cpu\")));\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"cpu-version\", env->spr[SPR_PVR])));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-block-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-line-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-block-size\",\n\n                           env->icache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-line-size\",\n\n                           env->icache_line_size)));\n\n\n\n    if (pcc->l1_dcache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-size\",\n\n                               pcc->l1_dcache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 dcache size for cpu\");\n\n    }\n\n    if (pcc->l1_icache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-size\",\n\n                               pcc->l1_icache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 icache size for cpu\");\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"timebase-frequency\", tbfreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"clock-frequency\", cpufreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"status\", \"okay\")));\n\n    _FDT((fdt_setprop(fdt, offset, \"64-bit\", NULL, 0)));\n\n\n\n    if (env->spr_cb[SPR_PURR].oea_read) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,purr\", NULL, 0)));\n\n    }\n\n\n\n    if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-segment-sizes\",\n\n                          segs, sizeof(segs))));\n\n    }\n\n\n\n    /* Advertise VMX/VSX (vector extensions) if available\n\n     *   0 / no property == no vector extensions\n\n     *   1               == VMX / Altivec available\n\n     *   2               == VSX available */\n\n    if (env->insns_flags & PPC_ALTIVEC) {\n\n        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cs));\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n", "idx": 24648, "substitutes": {"cs": ["sys", "css", "cu", "fs", "pc", "rs", "c", "rc", "core", "ds", "hs", "ck", "ks", "ec", "cp", "cus", "s", "sc", "cks", "sts", "ctx", "vs", "js", "bs", "wcs", "ts", "CS", "ps", "ns", "acs", "cas", "gc", "cms", "ls", "cc", "ces", "proc", "ix"], "fdt": ["FDwt", "ddt", "dlwt", "FDn", "fdwt", "dll", "dlt", "dfl", "dln", "ddm", "FDw", "ffw", "dlm", "fdl", "ffn", "dlw", "fdp", "dft", "ddl", "FDt", "dfm", "dfp", "fft", "fdm", "ffwt", "fdn", "dlp", "fdw", "ddp"], "offset": ["f", "padding", "length", "o", "address", "slice", "len", "pad", " offsets", "id", "zero", "error", "buffer", "count", "pointer", "set", "to", "pos", "oid", "location", "start", "shift", "size", "seek", "interface", "position", "seed", "off", "ptr", "slot", "fp", "end", "index", "point", "lock", "Offset", " index"], "spapr": [" spipr", "spapsrs", "spapsR", "swaprs", "spaprs", "swapsR", "spippr", "spapers", " spiprs", "spavrs", "spcapr", " spipR", " spapR", "spippro", "spiprs", "spapsr", " spipro", "spcaprs", "spapro", "spavro", "swapsrs", "spapep", "spapsp", "swapsr", " spapro", "spipprs", "spipr", "spipR", "swapR", "spipro", "spcapR", "spapeR", "spcapp", "spavr", "spavR", "spippR", "spapp", "swapr", "spaper", "spapR", "swapsp", " spaprs", "swapp"], "cpu": ["vm", "sys", "mac", "chip", "cu", "boot", "conn", "ka", "pc", "us", "c", "core", "gpu", "nic", "mem", "mx", "clock", "ck", "prof", "cmd", "pool", "cp", "linux", "cache", "cum", "sc", "nc", "cn", "node", "util", "ctx", "nu", "aco", "density", "phys", "frame", "process", "processor", "CPU", "px", "pu", "tp", "gc", "stat", "cc", "proc", "cv", "hw"], "env": ["priv", "context", "ef", "obj", "ev", "conn", "viron", "map", "pillar", "er", "dev", "ec", "ext", "node", "cb", "buf", "ctx", "vs", "pe", "environment", "cfg", "estate", "ework", "attr", "equ", "window", "e", "win", "en", "cap", "pres", "scope", "end", "eng", "proc", "v", "cv", "ei", "conf"], "pcc": ["pCC", " pcs", "Pck", "PCC", " pck", "jpcs", "pck", "Pcs", "jpck", "jpcc", "pcs", "jpCC", "Pcc", " pCC"], "segs": ["begs", "veges", " segments", " seges", "begments", "seges", "beges", "seg", "segments", " seg", "veg", "vegments", "vegs", "beg"], "page_sizes_prop": ["page_sizers_property", "page_sizes_ps", "page_sizes_attr", "page_sizers_ps", "page_sizers_attr", "page_sizes_property", "page_sizers_prop"], "page_sizes_prop_size": ["page_sizes_prop_value", "page_sizes_property_size", "page_sizes_property_value", "page_sizes_prop_type", "page_sizes_prop_len", "page_sizes_property_len", "page_sizes_property_type"], "pft_size_prop": ["pft_name_prop", "pft_name_tmp", "pft_name2tmp", "pft_size2prop", "pft_name_buf", "pft_size2tmp", "pft_name_properties", "pft_name2buf", "pft_name2prop", "pft_size_buf", "pft_size_properties", "pft_size_tmp", "pft_name2properties", "pft_size2properties", "pft_size2buf"], "drc": [" dpc", " dry", "drs", "ddRC", "rdrc", "dcur", "ddrc", "drl", "dsrc", "bdrc", "madsrc", "pdrr", " drs", "DRC", "bdRC", " dror", "dry", "Drl", "madrc", "rdRC", "bdror", "Drr", "Drs", "nrl", "dpc", "dclus", "madRC", "pdRC", " dclus", "ddry", "drr", "Dry", "Dsrc", "dror", " drl", "nRC", "pdrc", "rdrs", "rdpc", "bdcur", "nrc", "nrs", "pdsrc", " dcur", "madrr", "Dclus", "dRC", "Dpc", " dRC", "Drc", "ddclus"], "drck": ["drcheck", "delck", "derkick", "derkk", " drkk", "drmcker", "delack", "drcks", "drmk", "drmkick", " drcks", " drk", "drkk", "derk", "drmack", "drcker", "drkick", "delkk", "drack", "derck", " drcker", "drk", " drack", "vrack", "drmcheck", "drmkk", "vrck", " drkick", "vrcheck", "delcks", "drmck", "vrcker", "drmcks", " drcheck"], "drc_index": ["drc_ind", "drc_number", "drc__index", "dRC_number", "drc__id", "drc__Index", "dRC_Index", "dRC_id", "drc_find", "drec__Index", "drec__index", "drec_Index", "drc_id", "drc__ind", "drec__id", "drc__find", "drc__number", "drec_index", "dRC_index", "drec_id", "drec_find", "drc_Index", "drec__find", "dRC_ind"], "radix_AP_encodings": ["radix_prop_encodedINGS", "radix_prop_encodesING", "radix_prop_ENCODING", "radix_prop_encodings", "radix_prop_encODings", "radix_prop_encodedING", "radix_prop_ENCodING", "radix_prop_ENCODINGS", "radix_prop_encodesINGS", "radix_prop_encodINGS", "radix_prop_encodesers", "radix_prop_encoders", "radix_prop_ENCoders", "radix_prop_encodeders", "radix_prop_encODers", "radix_prop_encodING", "radix_prop_ENCODers", "radix_prop_ENCODings", "radix_prop_encODINGS", "radix_prop_encodedings", "radix_prop_encODING", "radix_prop_ENCodINGS", "radix_prop_encodesings", "radix_prop_ENCodings"], "i": ["f", "it", "x", " j", "o", "c", "id", " ii", "I", "n", "p", "list", "io", "set", "j", "ii", "a", "l", "info", "ip", "y", "key", "e", "si", "t", "m", "point", " index"]}}
{"project": "FFmpeg", "commit_id": "1bfb4587a2e5b25ed15f742149e555efc8f305ae", "target": 1, "func": "static void test_function(const TestStruct test_sample)\n\n{\n\n    int ret, i;\n\n    void **output_data  = NULL;\n\n    AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,\n\n                                            test_sample.nb_samples_pch);\n\n    if (!afifo) {\n\n        ERROR(\"ERROR: av_audio_fifo_alloc returned NULL!\");\n\n    }\n\n    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_write failed!\");\n\n    }\n\n    printf(\"written: %d\\n\", ret);\n\n\n\n    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_write failed!\");\n\n    }\n\n    printf(\"written: %d\\n\", ret);\n\n    printf(\"remaining samples in audio_fifo: %d\\n\\n\", av_audio_fifo_size(afifo));\n\n\n\n    ret = read_samples_from_audio_fifo(afifo, &output_data, test_sample.nb_samples_pch);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_read failed!\");\n\n    }\n\n    printf(\"read: %d\\n\", ret);\n\n    print_audio_bytes(&test_sample, output_data, ret);\n\n    printf(\"remaining samples in audio_fifo: %d\\n\\n\", av_audio_fifo_size(afifo));\n\n\n\n    /* test av_audio_fifo_peek */\n\n    ret = av_audio_fifo_peek(afifo, output_data, afifo->nb_samples);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_peek failed!\");\n\n    }\n\n    printf(\"peek:\\n\");\n\n    print_audio_bytes(&test_sample, output_data, ret);\n\n    printf(\"\\n\");\n\n\n\n    /* test av_audio_fifo_peek_at */\n\n    printf(\"peek_at:\\n\");\n\n    for (i = 0; i < afifo->nb_samples; ++i){\n\n        ret = av_audio_fifo_peek_at(afifo, output_data, 1, i);\n\n        if (ret < 0){\n\n            ERROR(\"ERROR: av_audio_fifo_peek_at failed!\");\n\n        }\n\n        printf(\"%d:\\n\", i);\n\n        print_audio_bytes(&test_sample, output_data, ret);\n\n    }\n\n    printf(\"\\n\");\n\n\n\n    /* test av_audio_fifo_drain */\n\n    ret = av_audio_fifo_drain(afifo, afifo->nb_samples);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_drain failed!\");\n\n    }\n\n    if (afifo->nb_samples){\n\n        ERROR(\"drain failed to flush all samples in audio_fifo!\");\n\n    }\n\n\n\n    /* deallocate */\n\n    for (i = 0; i < afifo->nb_buffers; ++i){\n\n        av_freep(&output_data[i]);\n\n    }\n\n    av_freep(&output_data);\n\n    av_audio_fifo_free(afifo);\n\n}\n", "idx": 24655, "substitutes": {"test_sample": ["testobjspace", "est_profile", "testobjerror", " test_stream", "test_system", "test_data", "test2sample", "testing_data", " test_system", "est2error", "testing_example", "est2space", "test_package", "test_sam", "testablesave", "test_save", "testablespace", "testableexample", "test_space", "test_error", "test_example", " test_space", "testing_Sample", "testing_step", "test___package", "est_space", "est_error", "test2space", "testablesample", "testobjsave", "fake_component", "test_site", "testobjexample", "testing_space", "testing_sample", " test_package", "est2sample", "testtsample", "testobjprofile", "test2error", "test_component", "test_profile", " test_model", "test_step", " test_sam", "test_stream", "test_model", "testing_sam", "test___sample", "fake_sim", " test_site", "test_sim", "testtcomponent", "test___Sample", "est_sample", "testtprofile", "fake_profile", " test_Sample", "test_sequence", " test_save", "test_Sample", "testtsim", "test2profile", " test_sim", " test_sequence", "testobjsample", " test_example", "est2profile", "test___sim", "fake_sample"], "ret": ["alt", "ter", "ll", "status", "att", "cont", "del", "r", "reply", "arr", "dt", "rem", "et", "complete", "ert", "rt", "expr", " RET", " Ret", "mt", "Ret", "gc", "inter", "rest", "obj", "rm", "re", "br", "try", "rs", "gt", "after", "rev", "arm", "RT", "det", "ben", "backed", "add", "j", "total", "desc", "rier", "fun", "iter", "net", "final", "sys", "full", "reset", "RET", "def", "ry", "get", "mel", "rect", "art", "print", "back", "dr", "addr", "tr", "elt", "vet", "str", "it", "out", "red", "err", "ref", "len", "result", "report", "details", "repl", "ext", "cmd", "sr", "deg", "cert", "resp", "usr", "nt", "rets", "txt", "ft", "aux", "val", "t", "jp", "arg", "Return", "res"], "i": ["f", "it", "ic", "inter", "x", "batch", "ui", "multi", "\u0438", "o", "err", "ie", "ami", "us", "pi", "ini", "c", "ex", "id", "ri", "in", "me", "gi", "r", "I", "n", "p", "phi", "io", "di", "j", "ai", "mi", "ii", "li", "print", "chain", "ti", "ind", "l", "b", "info", "ip", "bi", "dr", "y", "ci", "mc", "iter", "e", "u", "iu", "xi", "si", "im", "t", "q", "index", "v", "m", "qi", "ix"], "output_data": [" output_bytes", "outputingdata", "outputlistnext", "outputingvalue", "output_body", "output_no", "outputmmbatch", " output_next", "output_value", "output_bus", "output_batch", " output_size", " output_DATA", "output2list", "output_next", "write_list", " output_buffer", "output_DATA", "outputingbus", "outputinglog", "output3batch", "outputingDATA", "output_bytes", "Output_batch", "output2data", "outputlistdata", "Output_bus", "outputlistbody", "output_log", "output3no", "outputmmno", "output3data", "output_size", "outputmmlog", "write_data", "Output_data", "Output_next", "Output_no", "outputingbuffer", "outputmmdata", " output_mu", "output_mu", " output_value", "write_values", "outputmmbus", "output2values", "output2buffer", "output_values", "output_list", "outputingbody", "outputingnext", "Output_log", "output_buffer", "write_buffer", "Output_body"], "afifo": ["aftifoo", "afifton", "afipoin", "afiloo", "affiffo", "afifon", "afiwole", "afffifo", "afimano", "afifoo", "afimoin", "afifole", "afiloi", "afico", "auxtifos", "affifbo", "afiho", "afiwoo", "afiffno", " afihonet", "auxifoin", "aftifor", "ancifoin", "affiffno", " afifole", "afffifpo", "aftiano", "afiterpo", "ancifon", "afiffoin", "afiftoid", "afIfos", "anciftoin", "afIfno", "afihano", "afio", " afihole", "afihoo", "aftio", "afiwano", "afichon", "afifonet", "aftifano", " af_", "afifno", "afifoin", "afipno", "afior", "afilon", "afihoin", "afiffi", "afiftpo", "affifoi", "aftifoin", "afifto", "afichoi", "afffifoid", "auxifno", "afiovolic", "afIfbo", "afipo", "afIfo", "afffifoi", "afifoid", "aftifos", "afiteroo", "afiftoin", "afiwo", "afiano", "affiffi", "afffifon", "afiwor", "afihi", "afifos", "afIfoin", "afihos", "aftior", "affimos", "ancifto", "af_", "auxifos", "afitero", "anciftoo", "alf_", "affiffoo", "afifbo", " afiholic", "afiftoo", "afifi", " afiho", " afifolic", "afiftano", "afiffio", "aftifno", "afici", "afiteroid", " afihoo", "afiovonet", "affifio", "alffunc", "auxifo", "aficolic", " afifi", "affiffoin", "aficho", "aftifo", "afihole", " affunc", "afimos", "afiffo", "aff_", "afimbo", "afifano", "affiffio", "affiffos", "afiftole", "auxtifno", "afimor", "affifoin", "afihonet", "afifoi", "affifpo", "afiffos", "aficonet", "affifon", "afIfoo", "afichoo", "afiovo", " afifano", "afimo", "afilo", "afffifoo", "affimbo", " afifoo", "afifpo", "afiffon", "afifolic", "affifos", "afifio", "ancifo", "ancifton", "afichio", "afiftbo", "ancifoo", "afichos", "auxtifo", "afiovi", "affifi", "affifoid", "affifno", "afifor", " afifonet", "affunc", "afiftos", "afihno", "affimoin", " afihi", "afffunc", "affifoo", "affimo", "affifo", "afiholic", "afipos", " afihano", "afiffoo", "auxtifoin"]}}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)\n\n{\n\n    ff_wmv2_idct_c(block);\n\n    put_pixels_clamped_c(block, dest, line_size);\n\n}\n", "idx": 24668, "substitutes": {"dest": ["ident", "trans", "rest", "temp", "d", "result", "dc", "master", "dev", "target", "results", "comb", "spec", "slave", "dist", "transform", "decl", "origin", "Dest", "orig", "stop", "way", "desc", "port", "src", "loc", "st", "iter", "self", "source", "tr", "table", "end"], "line_size": ["linelysize", "line_Size", "linelyheight", "block_space", "line_space", "block_size", "lineingstorage", " line_height", " line_storage", "block_Size", "line_height", "linelystorage", "line_storage", "lineingheight", "lineingsize"], "block": ["cl", "type", "pack", "batch", "field", "out", "trans", "ref", "bl", "hash", "Block", "bc", "part", "def", "map", "c", "word", "BL", "buffer", "object", "group", "sync", "row", "r", "pixel", "list", "p", "record", "set", "buf", "frame", "image", "blocks", "raw", "chain", "scan", "line", "b", "ip", "load", "link", "snap", "bin", "copy", "source", "point", "lock"]}}
{"project": "FFmpeg", "commit_id": "5a08ba5381cf8d46034440163e71cd95748beceb", "target": 0, "func": "static void decode_interframe_v4(AVCodecContext *avctx, uint8_t *src, uint32_t size)\n\n{\n\n    Hnm4VideoContext *hnm = avctx->priv_data;\n\n    GetByteContext gb;\n\n    uint32_t writeoffset = 0, count, left, offset;\n\n    uint8_t tag, previous, backline, backward, swap;\n\n\n\n    bytestream2_init(&gb, src, size);\n\n\n\n    while (bytestream2_tell(&gb) < size) {\n\n        count = bytestream2_peek_byte(&gb) & 0x1F;\n\n        if (count == 0) {\n\n            tag = bytestream2_get_byte(&gb) & 0xE0;\n\n            tag = tag >> 5;\n\n            if (tag == 0) {\n\n                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);\n\n                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);\n\n            } else if (tag == 1) {\n\n                writeoffset += bytestream2_get_byte(&gb) * 2;\n\n            } else if (tag == 2) {\n\n                count = bytestream2_get_le16(&gb);\n\n                count *= 2;\n\n                writeoffset += count;\n\n            } else if (tag == 3) {\n\n                count = bytestream2_get_byte(&gb) * 2;\n\n                while (count > 0) {\n\n                    hnm->current[writeoffset++] = bytestream2_peek_byte(&gb);\n\n                    count--;\n\n                }\n\n                bytestream2_skip(&gb, 1);\n\n            } else {\n\n                break;\n\n            }\n\n        } else {\n\n            previous = bytestream2_peek_byte(&gb) & 0x20;\n\n            backline = bytestream2_peek_byte(&gb) & 0x40;\n\n            backward = bytestream2_peek_byte(&gb) & 0x80;\n\n            bytestream2_skip(&gb, 1);\n\n            swap   = bytestream2_peek_byte(&gb) & 0x01;\n\n            offset = bytestream2_get_le16(&gb);\n\n            offset = (offset >> 1) & 0x7FFF;\n\n            offset = writeoffset + (offset * 2) - 0x8000;\n\n\n\n            left = count;\n\n\n\n            if (!backward && offset + count >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Attempting to read out of bounds\");\n\n                break;\n\n            } else if (backward && offset >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Attempting to read out of bounds\");\n\n                break;\n\n            } else if (writeoffset + count >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"Attempting to write out of bounds\");\n\n                break;\n\n            }\n\n\n\n            if (previous) {\n\n                while (left > 0) {\n\n                    if (backline) {\n\n                        hnm->current[writeoffset++] = hnm->previous[offset - (2 * hnm->width) + 1];\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                        offset++;\n\n                    } else {\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                    }\n\n                    if (backward)\n\n                        offset -= 4;\n\n                    left--;\n\n                }\n\n            } else {\n\n                while (left > 0) {\n\n                    if (backline) {\n\n                        hnm->current[writeoffset++] = hnm->current[offset - (2 * hnm->width) + 1];\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                        offset++;\n\n                    } else {\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                    }\n\n                    if (backward)\n\n                        offset -= 4;\n\n                    left--;\n\n                }\n\n            }\n\n\n\n            if (swap) {\n\n                left         = count;\n\n                writeoffset -= count * 2;\n\n                while (left > 0) {\n\n                    swap = hnm->current[writeoffset];\n\n                    hnm->current[writeoffset] = hnm->current[writeoffset + 1];\n\n                    hnm->current[writeoffset + 1] = swap;\n\n                    left--;\n\n                    writeoffset += 2;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24677, "substitutes": {"avctx": ["avecontext", " avctl", " avcmp", "avecmp", "avctl", "awcontext", "awtx", "AVctx", "avectx", "awctl", "AVctl", "avtx", " avtx", "AVcontext", "avectl", "awctx", "AVtx", "avcmp", " avcontext", "avcontext", "AVcmp"], "src": ["sys", "sn", "bb", "cur", "sb", "stream", "iv", "rs", "impl", "rc", "gin", "sel", "in", "inst", "sr", "sc", "img", "ser", "sh", "dest", "usr", "cb", "ctx", "input", "origin", "bg", "raw", "loc", "seek", "bin", "copy", "seed", "source", "ptr", "tmp", "filename", "sq"], "size": ["sn", "type", "length", "len", "fee", "storage", "body", "buffer", "height", "empty", "send", "n", "ize", "small", "bytes", "set", "message", "total", "shape", "capacity", "year", "data", "start", "scale", "SIZE", "z", "Size", "number", "max", "sum", "name"], "hnm": ["pnd", "hnam", "uhm", "hodmi", "mnmc", "wnmc", "hnpm", "bnam", "hranmm", "hranM", "pnam", "wnM", "havenum", "hdpm", "mnm", "mnM", "dnM", "atzm", "dnmc", "bnmi", "uhmi", "uham", "hnum", "hodm", "atzmi", "uhum", "hnman", "wnman", "dnm", "dnmm", "hnd", "dnpm", "wnm", "hodum", "pnmi", "bnm", "hdm", "atzam", "dnman", "hnmc", "hnmi", "havenam", "havenm", "hranm", "hdmm", "hnM", "hnmm", "hdM", "havenmi", "bnd", "atzd", "pnm", "hranpm", "mnman", "hodam"], "gb": [" img", "vm", "bb", "orm", "sb", "pb", "large", "Gb", " rg", "bridge", "entity", "mb", " eg", " g", "nb", "gt", "gom", "storage", "gif", "bf", "GB", "gz", "jpg", "BG", " pg", " GB", "g", "gin", "yg", "db", "gu", "git", "ga", " rgb", "deg", "pg", "img", "cb", "bytes", "buf", "gg", "BB", "gov", "gp", "eg", "hub", "kb", "vg", "ctx", "bg", " rc", "gd", "eb", "cfg", "gm", "tg", "b", "attr", " db", "lib", "BT", "gs", "rb", "gc", "ib", "buff", "rg"], "count": ["child", "cell", "c", "ctr", "cont", "common", "call", "complete", "ct", "info", "more", "carry", "max", "contact", "force", "search", "only", "code", "try", "first", "skip", "error", "cast", "n", "amount", "add", "level", "total", "next", "chain", "init", "ind", "current", "scroll", "card", "type", "length", "col", "part", "cycle", "core", "read", "act", "comment", "cond", "limit", "number", "all", "cc", "sum", "ount", "match", "hash", "len", "component", "result", "debug", "find", "cmd", "cache", "counter", "Count", "found", "cart", "start", "nt", "num", "val", "flag", "check", "loop", "index", "name", "conf"], "offset": ["range", "iterator", "padding", "option", "type", "attribute", "length", "alt", "angle", "byte", "address", "item", "flag", "code", "term", "pad", "lag", "part", "skip", "after", "atomic", "article", "error", "unk", "tz", "translation", "amount", "pointer", "initial", "prefix", "set", "extra", "sort", "origin", "pos", "next", "location", "data", "start", "shift", "port", "attr", "seek", "base", "position", "limit", "mask", "time", "scroll", "half", "slot", "off", "timeout", "tail", "end", "source", "index", "point", "lock", "Offset", "init"], "tag": ["field", "feature", "status", "id", "word", "tags", "use", "prefix", "magic", "pos", "pair", "bug", "token", "attr", "lead", "color", "step", "user", "head", "role", "parent", "code", "term", "Tag", "error", "at", "cat", "state", "next", "ag", "key", "meta", "slot", "format", "card", "class", "type", "length", "product", "part", "comment", "TAG", "month", "back", "test", "version", "style", "time", "tmp", "stat", "option", "attribute", "match", "hash", "bit", "date", "debug", "category", "event", "phrase", "element", "start", "port", "flag", "tail", "t", "index", "name"], "previous": ["percedes", "Preprev", "precient", "prevvious", "pinflower", "perviously", "preward", "previously", "Precedes", "Precient", "pervious", "pincedes", " preprev", "Preflower", "prevprev", "Previous", " precient", "Preward", " preward", "preprev", "pinviously", "prevcient", "perflower", "Previously", "pinvious", "prevward", "precedes", "preflower"], "backline": ["Backlink", "sideboard", " backlines", " backlay", "blackline", "blacklay", " backboard", "foreboard", "backlay", "forelink", "backlink", "sidelay", "forelines", "blackboard", "Backboard", "sideline", "backlines", "Backline", "backboard", "Backlines", "blacklink", " backlink", "foreline", "sidelink"], "backward": ["backedward", "prewards", " backbone", " backvious", "backbone", "preward", "preway", "gateforward", "gateverse", "preforward", "backwards", "gateward", "gateway", "backedwards", "backvious", " backwards", " backforward", "backverse", " backverse", "backforward", "preverse", "prebone", "backway", " backway", "backedvious", "backedbone"], "swap": ["snag", " swag", "snrap", "slag", "slip", "warp", "swarp", "swip", "snarp", "wap", " swip", "wrap", "Swap", "wip", "slop", "slap", "Swip", "snop", " swop", "Swrap", "swop", "swag", "snap", "swrap", "Swarp", "snip"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_frame(int sig, struct emulated_sigaction *ka,\n\n\t\t\ttarget_sigset_t *set, CPUX86State *env)\n\n{\n\n\tstruct sigframe *frame;\n\n\tint err = 0;\n\n\n\n\tframe = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\n\t\tgoto give_sigsegv;\n\n#endif\n\n\terr |= __put_user((/*current->exec_domain\n\n\t\t           && current->exec_domain->signal_invmap\n\n\t\t           && sig < 32\n\n\t\t           ? current->exec_domain->signal_invmap[sig]\n\n\t\t           : */ sig),\n\n\t\t          &frame->sig);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tsetup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tif (TARGET_NSIG_WORDS > 1) {\n\n\t\terr |= __copy_to_user(frame->extramask, &set->sig[1],\n\n\t\t\t\t      sizeof(frame->extramask));\n\n\t}\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is popl %eax ; movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb858, (short *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode+2));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+6));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n", "idx": 24720, "substitutes": {"sig": ["sigs", "xsIG", "rsIG", "sigma", " sigen", "Sigs", "xsigs", " sigma", "psig", "nsIG", "rsign", "digma", "ssIG", "dsigs", "dig", "Sigma", " sigs", "sigen", "rsigs", "ssig", "ssigs", "nsigs", "SIG", "ssigen", "psIG", "nsigma", "Sigen", "psigma", "nsig", "dsigen", "rsig", "xsign", "dsigma", "ssigma", "psigs", "dsig", "dIG", "digs", "Sig", "sIG", "xsig", "sign"], "ka": ["KA", "ena", "sa", "ku", "ki", "kan", "ama", "ja", "ik", "ma", "ski", "km", "ko", "ke", "tk", "kt", "k", "ken", "ica", "iak", "ck", "ks", "ema", "ket", "sc", "Ka", "kat", "va", "kr", "kas", "cki", "ctx", "ana", "ta", "sk", "ak", "eta", "arma", "aka", "ker", "pa", "java", "ha", "kw", "gha", "kl"], "set": ["range", "ch", "pack", "pre", "join", "site", "reset", "see", "store", "se", "tk", "config", "def", "map", "sub", "push", "target", "get", "spec", "ver", "sc", "use", "sets", "new", "add", "sh", "util", "sche", "et", "pair", "clear", "setting", "Set", "setup", "settings", "section", "test", "mark", "start", "size", "base", "st", "step", "sp", "net", "check", "offset", "end", "t", "dict", "format", "SET", "init", "parse"], "env": ["dh", "vp", "er", "dev", "mem", "ten", "dt", "open", "et", "ctx", "vs", "origin", "environment", "attr", "info", "der", "ptr", "pkg", "v", "enter", "ei", "here", "obj", "ev", "conn", "code", "erd", "entry", "ec", "sc", "buf", "gear", "enc", "deck", "next", "setup", "desc", "window", "net", "en", "eq", "vt", "Environment", "hw", "context", "engine", "esc", "den", "ef", "screen", "ah", "sw", "nv", "addr", "worker", "outer", "cv", "priv", "stack", "ov", "eu", "server", "err", "viron", "ew", "ve", "org", "cb", "esm", "up", "np", "menu", "query", "e", "self", "end", "eng", "uv", "proc", "init"], "frame": ["range", "queue", "feature", "ie", "none", "word", "request", "buffer", "new", "sche", "call", "ctx", "environment", "face", "size", "page", "base", "step", "draw", "scope", "ptr", "scene", "role", "fram", "cf", "force", "ce", "zone", "code", "Frame", "value", "flow", "fr", "error", "header", "send", "ace", "close", "state", "function", "session", "next", "data", "iframe", "window", "offset", "point", "lock", "fb", "context", "type", "ence", "reset", "def", "tick", "ine", "shot", "policy", "frames", "rule", "process", "doc", "file", "version", "style", "f", "block", "movie", "err", "ref", "ma", "component", "profile", "zero", "event", "object", "fi", "row", "me", "ze", "module", "rame", "message", "sequence", "image", "connection", "line", "response", "feat", "channel", "trace", "fake", "init"]}}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void write_target_close(BlockDriverState *bs) {\n\n    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);\n\n    bdrv_delete(s->qcow);\n\n    free(s->qcow_filename);\n\n}\n", "idx": 24730, "substitutes": {"bs": ["bb", "ms", "sb", "bas", "lbs", "bps", "fs", "bc", "bes", "BS", "ses", "ubs", "ds", "hs", "aos", "bos", "bec", "bis", "cks", "bits", "iss", "vs", "bing", "js", "blocks", "ss", "outs", "b", "ats", "ns", "ts", "acs", "vals", "its", "gs", "bp", "obs"], "s": ["sys", "i", "sa", "sb", " ss", "ins", "se", "comm", "os", "fs", "sol", "rs", "c", "ses", "ds", "hs", "spec", "n", "p", "cs", "sts", "ares", "aws", "j", "iss", "S", "als", "js", "ss", "a", "b", "ats", "ts", "ns", "ps", "ies", "stats", "qs", "es", "its", "gs", "less", "sv", "ls", "q", "sq"]}}
{"project": "FFmpeg", "commit_id": "93c39db5f1544d1220488cfeb93bfe812a52f374", "target": 1, "func": "static int aiff_read_packet(AVFormatContext *s,\n                            AVPacket *pkt)\n{\n    AVStream *st = s->streams[0];\n    AIFFInputContext *aiff = s->priv_data;\n    int64_t max_size;\n    int res, size;\n    /* calculate size of remaining data */\n    max_size = aiff->data_end - avio_tell(s->pb);\n    if (max_size <= 0)\n        return AVERROR_EOF;\n    /* Now for that packet */\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n    case AV_CODEC_ID_GSM:\n    case AV_CODEC_ID_QDM2:\n    case AV_CODEC_ID_QCELP:\n        size = st->codecpar->block_align;\n        break;\n    default:\n        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;\n    size = FFMIN(max_size, size);\n    res = av_get_packet(s->pb, pkt, size);\n    if (res < 0)\n        return res;\n    if (size >= st->codecpar->block_align)\n        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;\n    /* Only one stream in an AIFF file */\n    pkt->stream_index = 0;\n    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;\n    return 0;", "idx": 24732, "substitutes": {"s": ["sys", "ms", "as", "ops", "ins", "os", "comm", "fs", "v", "rs", "c", "ses", "ds", "hs", "g", "n", "p", "bis", "cs", "sts", "set", "aws", "vs", "S", "js", "bs", "ss", "xs", "a", "is", "ats", "b", "ns", "ts", "ps", "stats", "qs", "es", "its", "gs", "sp", "sv", "http", "h", "t", "ls", "events", "sq", "conf"], "pkt": ["wpacket", "wpvc", "Pdu", "ppkt", "ppqt", "tdu", "wpkg", "ppnt", "tkt", "parkt", "pcqt", "Pvc", "proacket", "wpwk", " pwk", " pct", "pront", " packet", "payacket", "packet", " pdu", "wpct", "pcnt", " pkg", "tnt", "paykt", " pvc", "Packet", "pct", "parkg", "pargt", "produ", "pcacket", "prokt", "Pwk", " pnt", " pgt", "pckt", "pvc", "paydu", "Pct", " pqt", "pqt", "Pkt", "pnt", "ppacket", "wpgt", "tacket", "pdu", "pwk", "pgt", "paracket", "pkg", "paynt", "Pnt", "wpkt"], "st": ["stack", "sn", "ost", "sa", "sb", "rest", "obj", "nd", "sta", "se", "std", "rs", "storage", "ste", "tt", "cont", "irst", "sl", "St", "inst", "sc", "sh", "sts", "usr", "sw", "set", "ut", "ust", "et", "stage", "ast", "td", "th", "ss", "stop", "ct", "ts", "start", "must", "sm", "desc", "ST", "stable", "z", "step", "ft", "sp", "mt", "sv", "est", "ist", "etc", "t", "stat", "be", "str", "pt"], "aiff": ["yaolf", "vaiff", " aesh", "aIFF", "awiper", "vaolf", " aich", "yaiff", "awif", "aolf", "eaif", "yaif", "maial", "caiff", "caial", " aif", "maif", "maiff", "aesh", " aiper", "eaiper", " aolf", "caif", " aIFF", "aiper", " aial", "aial", "awiff", "eaesh", "caIFF", "eaiff", "aif", "vaich", "maIFF", "awesh", "aich", "vaif", "yaich"], "max_size": ["maxmaxalign", "MAX_Size", "max_results", "max_Size", "top67size", " max_align", " max_Size", "max_length", "maxlenSize", "maxlenalign", "max_diff", "max67SIZE", "top67diff", "maxmaxsize", "maxmaxlen", "max67value", "max_align", "max67Size", "max_len", "top_Size", "top67Size", "max_data", "top_size", "top67length", "top_diff", "max_SIZE", "max_value", "maxmaxSize", "MAX_size", " max_results", "max67size", "MAX_data", "max67length", "maxlenlen", "max67diff", "MAX_SIZE", " max_value", " max_len", "top_length", "maxlensize", " max_SIZE", "max67results"], "res": [" resolved", "ms", "i", "x", "out", "rest", "err", "reset", "re", " resp", "success", "os", "none", "rs", " ret", "ex", "rc", "result", "rev", "zero", "results", "act", "RES", "empty", "resource", "pers", "cond", "count", " RES", " Res", "resp", "cs", "rel", "bytes", "rem", " rs", "resh", "resources", "bits", "j", "pos", "rows", "rep", "js", "bs", "ne", "cons", "rez", "yes", "ts", "ps", "req", "expr", "rss", "vals", "des", "con", "val", "Res", "resolution", "ret", "pres", "max", "sum", "ress"], "size": ["range", "sn", "type", "ms", "length", "dim", "space", "full", "news", "args", "x", "min", "power", "zone", "score", "len", "fee", "storage", "body", "result", "zero", "grow", "mem", "password", "height", "ose", "empty", "loss", "send", "count", "ize", "small", "cs", "bytes", "set", "too", "area", "equal", "message", "shape", "capacity", "speed", "data", "notice", "scale", "weight", "shift", "SIZE", "window", "z", "south", "num", "sp", "time", "Size", "number", "resolution", "timeout", "scope", "max", "sum", "name"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fnmsub (uint64_t arg1, uint64_t arg2, uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                 float64_is_signaling_nan(farg2.d) ||\n\n                 float64_is_signaling_nan(farg3.d))) {\n\n        /* sNaN operation */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);\n\n    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n#if USE_PRECISE_EMULATION\n\n#ifdef FLOAT128\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n#else\n\n        /* This is OK on x86 hosts */\n\n        farg1.d = (farg1.d * farg2.d) - farg3.d;\n\n#endif\n\n#else\n\n        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);\n\n        farg1.d = float64_sub(farg1.d, farg3.d, &env->fp_status);\n\n#endif\n\n        if (likely(!float64_is_nan(farg1.d)))\n\n            farg1.d = float64_chs(farg1.d);\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 24742, "substitutes": {"arg1": ["prop1", "arg0", " arg01", "args2", " arg0", "prop01", "Arged", "param3", "Arg1", "Arg2", "param0", "Arg01", "param01", "prop0", "args01", "args1", "param1", "arged", " arged", "prop3", "argsed", "arg01"], "arg2": ["arg0", " arg5", "ig02", "argument3", " arg0", "agg02", "ig1", "param2", "param3", "arg02", "argument5", "ig0", "argument2", " arg02", "agg1", "param5", "ig2", "agg0", "arg5", "agg2"], "arg3": ["Arg5", " arg5", "param7", "targetthree", "target3", "param2", " arg7", "param3", "arg23", "doc3", "Arg2", "doc2", "arg7", " argthree", "Arg3", "doc23", "docthree", "param5", "Arg7", "argthree", "target23", "arg5", " arg23", "target2"], "farg1": [" fparamn", "fblock1", "fargs0", "formargone", "fument61", "fcall1", "fagg9", "farm1", " fcall001", "farg001", "farge50", " farg9", " fagg1", "fargs2", "formblock37", "fument50", " farg41", " fagg01", "ftarg001", "fagg8", "fArg1", "fflag001", "farg37", "farp12", "farge001", "fmtag61", "farg50", "fument1", " fparam5", "fargs41", " fargs2", "farm3", "ftagn", "formblock1", " farg5", " fcallone", "fargn", "fvar50", "fArg3", "farg12", "farp1", "ftarg1", "fprocessone", " fargs0", "formarg71", "farm12", "fparam1", "fmarg1", "formarg3", "fvar1", "farg71", "fargs1", "fmargn", "farg41", "ftag71", " fargone", "fmarg71", "fcall8", "farg61", "fargument71", "formarm8", "fparamn", "fvar9", "fagg1", "fblock37", "fdoc1", "fprocess37", "fagg01", "fargument1", "farp8", "farg8", "fdoc61", "fig1", "fvar001", "ftag1", "farg5", "farp5", " fargOne", "ftarg8", "fagg12", "fparam5", "fmtagn", "ftag61", "fblock71", "fprocess71", "fargument5", "fargument61", "fprocess1", " fagg001", "fcall001", "formarm3", " fargn", "farp3", "fargone", "farg9", "formblock71", "fargumentone", " fparamOne", "fargument37", " farg0", " farg001", "formarm1", "fflag8", "fagg3", "fument001", "farg01", "fig001", "fvar8", "fdoc71", "farpn", "fmtag71", "fcall3", " fagg9", "formarg1", "fvar01", "ftcall1", "ftcall8", "farp2", "figone", "formarg12", "farge61", "fargumentn", "farpOne", " fcall3", "formarm12", "fig3", "fArgone", " fparam1", " fcall1", " fargs41", "fargOne", "farp0", "fargument01", "fargumentOne", " farg01", "fdocn", "fargument001", "farp41", "ftcall001", "fmtag1", "formarg37", "fArg001", "fmarg61", "formarg8", "fparamOne", "farm8", "farg0", "formblockone", "fflag1", " fargs1", "fvar61", "fcallone", "farge1", "fagg001", "fblockone", "fargument9"], "farg2": ["fArg42", "fflagtwo", "cfarg5", "ftag3", "fark2", "farg14", "fagg8", "floatarg8", "fargtwo", "fapped", "figed", "fargumenttwo", "fagg42", "foang5", "fark3", "fok3", "cfparam2", "fdev8", "fArg3", "floatarg2", "fargument2", "foktwo", "cfarged", "alftag21", "cfarg2", "ftag21", "cfig14", "cfiged", "fargument4", "foarg15", "fig14", "fflag14", "fapp14", "foang15", "cfigtwo", "alftag2", "fargless", "fvalid21", "fArg8", "floatdev2", "fagg5", "cfargtwo", "fparamed", "farg21", "cfparamed", "farg8", "ftag2", "farg5", "fapp2", "fparam15", "floatarg3", "fpack2", "fangtwo", "fig2", "fokless", "fdev3", "figtwo", "fpacktwo", "fparamtwo", "fparam5", "fvalid2", "foang2", "fok21", "fang2", "cfarg4", "fparam2", "farg15", "fark4", "fagg4", "fpack15", "ftagless", "fagg3", "fdev2", "fark5", "fvalid3", "cfagg4", "alfarg2", "foked", "fArg2", "fok4", "foangtwo", "alfarg3", "fflag2", "cfparamtwo", "fang5", "cfarg3", "cfparam4", "farg4", "floatdev42", "farg42", "floatdev3", "cfarg14", "fargumented", "cfig2", "alftagless", "fapptwo", "foargtwo", "cfagg5", "fparam4", "fagg2", "floatdev8", "cfagg2", "fvalidless", "floatarg42", "fdev42", "fpack5", "fang15", "cfagg3", "alfargless", "fok2", "alfarg21", "farged", "foarg5", "foarg2", "alftag3", "fflaged"], "farg3": [" fok4", "fcargumentck", "ftarget512", "fdim3", "facargthree", "farc03", " fok21", "fcargthree", "fargck", "targs3", "fargs2", "ftag3", "warg3", "flag03", "cfagg53", "fdoc2", "fcarg3", "fmemthree", " farg21", "fok83", "targsThree", "fok3", "ftarget11", "facaj43", "cfagg03", "fdocThree", "fArg3", "farg43", "fcallthree", "wtarget11", "fagg03", "facarg43", "farcThree", "wtarget3", "fcargument3", "cfargThree", "fargsThree", " farg83", "fcall8", " farg4", "figThree", "targThree", "ftag11", "ftarget3", "fdim4", "flag512", "cfaggThree", "fargs3", "facaj8", "farg21", " fok83", "farg8", "fargumentck", "warg03", "targ2", "fdim83", "floc21", "facaj3", "farg53", "fdoc3", "fajthree", "wtarget512", "farc53", "fcall43", "fok21", "farg512", "fmem3", "ftarget03", "farc3", "fagg3", "fargThree", "fagg53", "floc83", "floc3", "fcall3", "wtarget03", "fargument3", "targ3", "faggThree", "fmemck", "fumentthree", "fArg2", "fok4", "fcargck", "fig03", "fargument8", "cfarg3", "farg4", "warg512", "fArgThree", "fig3", "floc4", "targs2", " fok3", "cfarg03", "farg03", "facarg8", "fdim21", "fument3", "facajthree", "fargumentthree", "ftag512", "ftag03", "fig53", "farg11", "cfarg53", "faj3", "fcargumentthree", "faj8", "cfagg3", "warg11", "facarg3", "flag11", "fumentck", "faj43", "farg83", "fargthree", "flag3", "fargument43"], "ft0_128": ["ft0_256", "ft0_65", "ft0_32", "ft067128", "ft0_48", "ft0pt48", "_", "ft067188", "ft60_30", "ft0pt20", "ft067208", "ft2_256", "ft0_30", "ft0_20", "exec", "ft067256", "ft50pt256", "ft0_188", "ft0__3", "ft50pt128", "ft0pt208", "ft50_20", "ft0pt188", "ft1_208", "FL", "func", "ft1_256", "ft0_208", "ft2_32", "ft0_132", "ft2_65", "ft0__128", "ft50_128", "ft1_512", "ft0__132", "def", "ft0__48", "ft50_256", "ft0pt128", "ft1_188", "ft60_128", "ft0_3", "ft50pt20", "ft50pt48", "ft0pt256", "ft2_128", "ft00_48", "ft00_3", "NUM", "ft60_756", "ft0_512", "ft00_128", "ft00_132", "ft0_756", "ft50_48"], "ft1_128": ["ft0_256", "ft0_32", "ft1_138", "ft0_16", "ft167height", "ft167128", "ft1_63", "ft1116", "ft1_16", "ftOne_138", "ftONE_8", "ft1_height", "ft1_256", "ft110", "ftOne_63", "ft0_0", "ftOne_128", "ft1_192", "ftONE_128", "ft1_0", "ft1_32", "ft0_1024", "ft11256", "ft1_8", "ftOne_192", "ftONE_height", "ft1_hex", "ft11128", "ft167hex", "ft1_1024", "ft1678", "ftONE_hex"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void dec_modu(DisasContext *dc)\n\n{\n\n    int l1;\n\n\n\n    LOG_DIS(\"modu r%d, r%d, %d\\n\", dc->r2, dc->r0, dc->r1);\n\n\n\n    if (!(dc->features & LM32_FEATURE_DIVIDE)) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"hardware divider is not available\\n\");\n\n        t_gen_illegal_insn(dc);\n\n        return;\n\n    }\n\n\n\n    l1 = gen_new_label();\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);\n\n    tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);\n\n    gen_set_label(l1);\n\n    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);\n\n}\n", "idx": 24744, "substitutes": {"dc": ["ic", "mac", "dim", "tm", "cf", "dir", "ca", "conn", "fee", "pc", "bc", "d", "def", "c", "tc", "cd", "rc", "cca", "disk", "ds", "ec", "currency", "cat", "db", "cmd", "ctl", "spec", "rec", "sc", "dt", "nc", "disc", "di", "dm", "cs", "cm", "design", "arc", "coord", "df", "td", "doc", "central", "iac", "da", "wcs", "desc", "dp", "vc", "oc", "dr", "dd", "ac", "dat", "dl", "de", "ci", "cr", "mc", "wp", "fc", "draw", "exec", "du", "driver", "kw", "gc", "DC", "cc", "lc"], "l1": ["L2", "lc8", " L1", "lax", "ln", "Lax", "lOne", "m0", " ln", "lc2", "l8", " l01", "levelOne", "lc3", "L1", " l2", "lp2", "level1", "lpOne", " l3", "l0", "lc1", "lp01", "lp8", " lOne", "m2", "l2", " L2", " l8", " lax", "mOne", "lp1", "level2", "lpn", "lcax", "l01", " L0", "lc01", " l0", " LOne", "leveln", "L3", "l3", "m1"]}}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;\n\n\n\n    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);\n\n}\n", "idx": 24748, "substitutes": {"opaque": ["OPaque", "Opface", "OPatile", " opatile", "opatile", "opque", "opface", " opque", " opface", "Opaque", "OPface", "OPque", "Opatile", "Opque"], "addr": ["block", "oad", "i", "ad", "tx", "err", "obj", "adr", "address", "store", "ay", "hash", "dh", "pad", "rs", "map", "id", "at", "mem", "gate", "target", "now", "act", "r", "cmd", "ack", "alias", "res", "add", "ord", "prefix", "msg", "bind", "coord", "pos", " address", "align", "eth", "a", "attr", "work", "ip", "dr", "loc", "src", "alloc", "Address", "handle", "mt", "off", "ptr", "offset", "t", "index", "name", "hw"], "value": ["padding", "tree", "type", "field", " val", "values", " Value", "byte", "address", "code", "term", "unit", "fee", "vp", "buffer", "comment", "Value", "memory", "VALUE", "state", "function", "message", "total", "sequence", "data", "test", "weight", "key", "serial", "val", "vector", "time", "number", "current", "ue", " weight", "property", "v"]}}
{"project": "qemu", "commit_id": "63729c36924348e494d69adbbdec6fdda339b76b", "target": 0, "func": "static void v9fs_create_post_lstat(V9fsState *s, V9fsCreateState *vs, int err)\n\n{\n\n\n\n    if (err == 0 || errno != ENOENT) {\n\n        err = -errno;\n\n        goto out;\n\n    }\n\n\n\n    if (vs->perm & P9_STAT_MODE_DIR) {\n\n        err = v9fs_do_mkdir(s, vs);\n\n        v9fs_create_post_mkdir(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_SYMLINK) {\n\n        err = v9fs_do_symlink(s, vs);\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_LINK) {\n\n        int32_t nfid = atoi(vs->extension.data);\n\n        V9fsFidState *nfidp = lookup_fid(s, nfid);\n\n        if (nfidp == NULL) {\n\n            err = -errno;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n        err = v9fs_do_link(s, &nfidp->path, &vs->fullname);\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_DEVICE) {\n\n        char ctype;\n\n        uint32_t major, minor;\n\n        mode_t nmode = 0;\n\n\n\n        if (sscanf(vs->extension.data, \"%c %u %u\", &ctype, &major,\n\n                                        &minor) != 3) {\n\n            err = -errno;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n\n\n        switch (ctype) {\n\n        case 'c':\n\n            nmode = S_IFCHR;\n\n            break;\n\n        case 'b':\n\n            nmode = S_IFBLK;\n\n            break;\n\n        default:\n\n            err = -EIO;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n\n\n        nmode |= vs->perm & 0777;\n\n        err = v9fs_do_mknod(s, vs, nmode, makedev(major, minor));\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_NAMED_PIPE) {\n\n        err = v9fs_do_mknod(s, vs, S_IFIFO | (vs->perm & 0777), 0);\n\n        v9fs_post_create(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_SOCKET) {\n\n        err = v9fs_do_mksock(s, &vs->fullname);\n\n        v9fs_create_post_mksock(s, vs, err);\n\n    } else {\n\n        vs->fidp->fd = v9fs_do_open2(s, vs);\n\n        v9fs_create_post_open2(s, vs, err);\n\n    }\n\n\n\n    return;\n\n\n\nout:\n\n    v9fs_post_create(s, vs, err);\n\n}\n", "idx": 24754, "substitutes": {"s": ["sys", "sn", "ms", "as", "irs", "sb", "ins", "ashes", "os", "ties", "fs", "v", "rs", "us", "bes", "ges", "ses", "ds", "hs", "sl", "g", "r", "p", "bis", "cs", "sts", "ains", "sw", "aws", "S", "als", "js", "bs", "ss", "xs", "is", "ats", "ns", "ts", "ps", "ims", "ies", "uns", "stats", "qs", "z", "es", "its", "gs", "sv", "ys", "h", "ls", "sq", "ssl"], "vs": ["rys", "otes", "ops", "versions", "vp", "lists", "_", "vv", "ices", "changes", "bits", "call", "xs", "ns", "ies", "posts", "ows", "heads", "v", "views", "rs", "func", "vis", "ves", "cs", "vr", "inv", "fits", "wcs", "ts", "vc", "ims", "irms", "its", "obs", "vt", "lv", "iffs", "ms", "ins", "gets", "def", "ks", "caps", "blogs", "sts", "ils", "bs", "ics", "vy", "ps", "stats", "gs", "ls", "Vs", "ports", "values", "of", "fs", "w", "ds", "hs", "uds", "js", "vers", "V", "ss", "docs", "VS", "nt", "vals", "terms", "qs", "es", "sv", "ys"], "err": ["ier", "cmp", "ll", "norm", "c", "erm", "er", "gz", "or", "r", "arr", "dt", "asm", "eg", "raw", "attr", "y", "progress", "der", "ptr", "h", "here", "ch", "obj", "rm", "br", "conn", "code", "try", "rs", "fr", "Error", "error", "rr", "pr", "good", "ver", "hz", "msg", "buf", "inv", "eas", "rank", "notice", "iter", "aaa", "Er", "exc", "warn", "sys", "aer", "nr", "ell", "eor", "res", "gr", "kr", "rar", "coord", "cfg", "test", "dr", "cr", "rb", "elt", "str", "out", "ner", "lr", "fee", "erer", "rc", "result", "later", "g", "orum", "resp", "usr", "cb", "order", "die", "rez", "req", "mr", "txt", "e", "trace", "conf"], "nfidp": ["nfridv", "nfdIdper", "nfitps", "nfsIdP", "nfridp", "nfiqP", "nfIdwp", "nfsIdpb", "nfxidwp", "nfidwp", "nfxidp", "nfaidphp", "nfaidp", "nfidper", "nfdidper", "nfidphp", "nfiqp", "nfaidps", "nfitper", "nfaidpb", "nfxoidwp", "nfxoidv", "nfdidpa", "nfxidv", "nfsIdp", "nfoidp", "nfdIdpa", "nfidpb", "nfsidP", "nfdIdps", "nfidps", "nfdidp", "nfaidper", "nfIdpb", "nfxoidP", "nfIdpa", "nfIdP", "nfoidv", "nfidpa", "nfidv", "nfIdp", "nfridwp", "nfsidpb", "nfsidphp", "nfiqpb", "nfxoidp", "nfIdv", "nfxidP", "nfaidP", "nfoidP", "nfitpa", "nfitp", "nfsIdphp", "nfiqphp", "nfidP", "nfaidpa", "nfIdper", "nfridP", "nfdidps", "nfoidwp", "nfIdphp", "nfdIdp", "nfIdps", "nfsidp"], "ctype": ["cttype", "ctypes", "cartType", "codype", "CType", "carttype", "contype", "ctType", "ntyp", "ctyp", "CTyp", "ccype", "contyp", "ntotype", "cartype", "ccType", "CTypes", "cctype", "cartyp", "CTtype", "codtype", "codyp", "contypes", "nttype", "ccypes", "ctotype", "ntype", "ccyp", "contotype", "codotype", "contType", "conttype"], "major": ["basic", "patch", "male", " majors", "ajor", "feature", "none", "normal", "valid", "ctr", "recent", " Major", "master", "dx", "oral", "or", "Major", "ior", "nir", "good", "ver", "ser", "gr", "ax", "mot", "mint", " maj", "total", "next", "older", "priority", "primary", "present", "arser", "feat", "ora", "native", "serial", "significant", "rod", "sharp", "ptr", "max", "mid"], "minor": ["Minore", "donOR", "minored", "MINory", "manorable", "MINion", "minimal", "demorable", "manor", "ignOR", " minori", "ignor", "manori", "minion", " minorable", "demor", "monor", "Minory", "ignion", "minOR", "demimal", "manimal", "MINored", "donor", "MINOR", "monory", "donory", "demori", "minorable", " minimal", "minori", "Minor", "MINore", "Minored", "monore", "minore", "monored", "ignory", "donion", "minory", "MINor"]}}
{"project": "qemu", "commit_id": "6049f4f831c6f409031dfa09282b38d0cbaecad8", "target": 0, "func": "void pal_init (CPUState *env)\n\n{\n\n}\n", "idx": 24756, "substitutes": {"env": ["context", "ef", "obj", "ev", "code", "viron", "map", "screen", "dev", "ec", "me", "db", "cb", "buf", "ctx", "vs", "pe", "environment", "test", "e", "EN", "en", "end", "tmp", "proc", "v", "cv", "conf"]}}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n\n                             uint32_t token, uint32_t nargs, target_ulong args,\n\n                             uint32_t nret, target_ulong rets)\n\n{\n\n    if ((token >= TOKEN_BASE)\n\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n\n\n\n        if (call->fn) {\n\n            call->fn(spapr, token, nargs, args, nret, rets);\n\n            return H_SUCCESS;\n\n        }\n\n    }\n\n\n\n    /* HACK: Some Linux early debug code uses RTAS display-character,\n\n     * but assumes the token value is 0xa (which it is on some real\n\n     * machines) without looking it up in the device tree.  This\n\n     * special case makes this work */\n\n    if (token == 0xa) {\n\n        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);\n\n        return H_SUCCESS;\n\n    }\n\n\n\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n\n    rtas_st(rets, 0, -3);\n\n    return H_PARAMETER;\n\n}\n", "idx": 24759, "substitutes": {"spapr": [" spipr", "spapsrar", "spapsrs", "spaptr", " spapior", "spiper", " spiprar", " spiper", "spaprs", " spaper", "ispapsrs", "ispapr", "ispaprs", "spapprar", "spandrs", "spaptior", "spaptrs", " spipR", " spandr", " spapR", "spapslr", "spandior", "sparpr", "sparprar", "spandr", "speper", "ispapsrar", "spapsr", "spapper", " spaplr", " spaprar", "spapior", "spaplr", "ispaper", "spappr", "ispapser", "sparper", "spaptrar", " spandior", "spaprar", "sparprs", "spaptlr", "spiprar", "spapsior", "spapser", "spipr", "spipR", "spappR", "ispapsr", "spepR", "ispaprar", " spandrs", "spapter", "speprar", " spandlr", "spaper", "spapR", "spandlr", " spaprs", "spepr"], "token": ["field", "none", "word", "buffer", "frame", "complete", "wt", "serial", "atom", "era", "table", "ask", "note", "padding", "prototype", "value", "error", "tn", "KEN", "header", "TO", "function", "forward", "tag", "year", "notice", "key", "offset", "before", "trigger", "TN", "final", "tree", "type", "Token", "reset", "normal", "ln", "kt", "tick", "oken", "now", "node", "termin", "input", "rule", "template", "time", "number", "all", "WT", "no", "block", "attribute", "typ", "ok", "kn", "len", "topic", "tk", "date", "event", "local", "password", "message", "position", "channel", "seed", "t", "index"], "nargs": ["nrows", "ngs", "Nargs", "cnargs", "Nparams", "Narg", "numargs", "cnrows", " nrows", "numarg", "normabis", "targs", "tgs", "normparams", "targ", " ngs", "narg", "nabis", "normargs", " nparams", "cngs", "numgs", " nabis", "normarg", "Ngs", "cnparams", "numparams", " narg", "nparams", "cnabis", "trows", "cnarg"], "args": ["ras", "sys", "values", "eps", "ins", "gets", "ants", "fs", "ems", "issues", "ds", "amps", "params", "ais", "acts", "assets", "keys", "arr", "ans", "ags", "arms", "aws", "Args", "ens", "ars", "frames", "ands", "js", "doc", "uments", "xs", "ns", "ts", "ps", "ims", "vals", "stats", "qs", "terms", "files", "gs", "aux", "win", "actions", "posts", "atts", "parts", "orders", "ams", "arg"], "nret": ["nrt", "tRet", " nRet", "Nalt", "Nrepl", "trets", "Nret", " nreturn", "Nreturn", "nRet", "nrets", "Nrets", "nalt", " nrets", "tnrepl", "NRet", "tnRet", " nrt", "talt", "tret", "nrepl", "tnrets", "tnret", "Nrt", " nalt", "trt", "treturn", "nreturn", " nrepl"], "rets": ["secret", "ras", "protected", "values", "RET", "ins", "ants", "ties", "fs", "rs", "gt", "def", "lists", "pillar", "uts", "results", "details", "tests", "uds", "keys", "ents", "sts", "ints", "ens", "rows", " secrets", "fits", "als", "outs", "uments", "rt", "ts", "ns", "nt", "runs", "vals", "states", "des", "cas", "qs", "its", "gs", "aux", "ret", "errors", "ls", "vt", "events", "tracks", "res"], "call": ["f", "block", "run", "pre", "Call", "cal", "dial", "ll", "ref", "make", "cell", "def", "c", "ell", "create", "local", "find", "row", "roll", "build", "list", "n", "send", "close", "rec", "use", "add", "node", "util", "set", "function", "fail", "cod", "co", "back", "l", "ac", "execute", "load", "eval", "play", "con", "draw", "exec", "circ", "check", "label", "all", "t"]}}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static void apply_tns_filter(float *out, float *in, int order, int direction,\n\n                             float *tns_coefs, int ltp_used, int w, int filt,\n\n                             int start_i, int len)\n\n{\n\n    int i, j, inc, start = start_i;\n\n    float tmp[TNS_MAX_ORDER+1];\n\n    if (direction) {\n\n        inc = -1;\n\n        start = (start + len) - 1;\n\n    } else {\n\n        inc = 1;\n\n    }\n\n    if (!ltp_used) {    /* AR filter */\n\n        for (i = 0; i < len; i++, start += inc)\n\n            out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tns_coefs[j]*in[start - j*inc];\n\n    } else {            /* MA filter */\n\n        for (i = 0; i < len; i++, start += inc) {\n\n            tmp[0] = out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tmp[j]*tns_coefs[j];\n\n            for (j = order; j > 0; j--)\n\n                tmp[j] = tmp[j - 1];\n\n        }\n\n    }\n\n}\n", "idx": 24761, "substitutes": {"out": ["f", "opt", "batch", "other", "full", "client", "o", "obj", "null", "store", "clean", "conv", "update", "att", "v", "map", "c", "ex", "result", "output", "at", "sync", "cast", "cmd", "pool", "list", "n", "p", "cache", "cn", "new", "to", "up", "outs", "Out", "print", "co", "b", "nt", "dot", "ou", "copy", "OUT", "net", "global", "ret", "check", "table", "t", "all", "sum", "ot", "one"], "in": ["f", "isin", "it", "ic", "pre", "inf", "o", "ins", "c", "ini", "mm", "gin", "n", "p", "rec", "s", "add", "input", "vin", "form", "image", "raw", "doc", "file", "inner", "is", "b", "ind", "l", "In", "ac", "rin", "data", "inn", "din", "nin", "con", "bin", "iter", "val", "serv", "IN", "t", "sum", "m", "v", "thin", "init"], "order": ["block", "dim", "length", "den", "ordered", "angle", "field", "dir", "err", "store", "address", "condition", "unit", "index", "asc", "er", "error", "ice", "or", "row", "orient", "incre", "r", "n", "count", "mode", "record", "ord", "rar", "sort", "level", "pos", "frame", "Order", "depth", "sequence", "chain", "priority", "rank", "ind", "size", "start", "page", "scale", "shift", "inn", "weight", "base", "position", "num", "ase", "iter", "en", "seed", "offset", "max", "end", "orders", "q", "m", "v"], "direction": ["range", "type", "length", "angle", "trans", "negative", "dir", "directed", "d", "distance", "normal", "language", "flow", "irection", "direct", "command", "orient", "positive", "mode", "filter", "di", "transform", "forward", "degree", "speed", "weight", "directory", "wind", "version", "relation", "vector", "driver", "kind", "number", "duration", "reverse", "DIR", "sign"], "tns_coefs": ["tns_coeffrs", "tns_coefficientsS", "tns_coffls", "tns_coffs", "tns_coefficientsls", "tns_coeferences", "tns_coefls", "tns_coefficientsps", "tns_coefferences", "tns_coEFFs", "tns_coefS", "tns_coEFFS", "tns_coefficientserences", "tns_cofferences", "tns_coefficientsrs", "tns_coEFFerences", "tns_coefrs", "tns_coEFFls", "tns_coeffs", "tns_coefficientss", "tns_coffrs", "tns_coeffls", "tns_coefps", "tns_coeffps", "tns_coffS", "tns_coeffS", "tns_coffps"], "ltp_used": ["ltpnotuse", "ltp_Used", "ltpnotavailable", "ltpnotusing", "ltP_Used", "ltp2used", "ltP_used", "ltP_using", "ltp_use", "ltp2use", "ltP_use", "ltp_using", "ltp_available", "ltpnotused", "ltp2Used", "ltP_available"], "w": ["W", "gen", "fw", "d", "wh", "v", "ow", "worth", "ew", "wd", "wl", "r", "deg", "sw", "nw", "wa", "weights", "weight", "wt", "window", "wind", "draw", "e", "kw", "t", "aw"], "filt": ["filtration", "tfiltration", "ffrend", "ffisher", "tfrend", "ffiltration", "frend", "ffilt", "afrend", "tfisher", "afisher", "afiltration", "tfilt", "fisher", "afilt"], "start_i": ["startptis", "start_in", "start_l", "index_i", "index_j", "indexptis", "indexptl", "index_is", "indexpti", "start_p", "indexptj", " start_p", "start_j", " start_in", "start_is", "startpti", "index_l", "startptl", "startptj"], "len": ["dim", "length", "den", "cmp", "latest", "ll", "ln", "ell", "nl", "mem", "fl", "fin", "sl", "seq", "ail", "del", "wl", "list", "n", "lf", "count", "el", "Len", "fn", "vol", "lon", "pos", "els", "align", "l", "ind", "size", "nt", "lan", "loc", "vel", "lib", "lim", "num", "limit", "iter", "win", "en", "val", "un", "il", "lp", "h", "ls", "end", "m", "q", "elt"], "i": ["ji", "it", "iat", "ic", "iii", "x", "ui", "multi", "ki", "\u0438", "ik", "item", "status", "ie", "init", "pi", "ini", "id", "c", "ia", "at", "ri", "m", "um", "g", "me", "gi", "I", "n", "p", "phi", "list", "io", "di", "oi", "ori", "zi", "sim", "ai", "mi", "li", "ii", "is", "ti", "l", "ind", "start", "info", "ip", "ij", "y", "ims", "bi", "ci", "iter", "ir", "u", "iu", "xi", "si", "t", "im", "index", "v", "qi", "this", "ei", "ix"], "j": ["other", "o", "ja", "jump", "nd", "att", "uj", "c", "er", "r", "p", "dt", "s", "li", "ij", "y", "z", "mn", "v", "pt", "ji", "note", "je", "obj", "xy", "ev", "br", "try", "fr", "pr", "n", "ver", "el", "io", "msg", "jit", "jc", "ind", "key", "m", "jj", "ix", "job", "jac", "ju", "dj", "k", "ge", "jo", "di", "kj", "J", "ii", "bs", "jack", "b", "l", "dr", "adj", "tr", "q", "str", "f", "it", "err", "bo", "ng", "g", "js", "jas", "bj", "json", "oj", "e", "by", "jp", "t", "jl", "aj", "ijk"], "inc": ["isin", "inter", "inf", "err", "ins", "gain", "occ", "ipl", "ln", "pp", "c", "alpha", "asc", "grow", "margin", "incre", "ext", "cond", "rec", "add", "vol", "asm", "prefix", "lin", "amin", "inv", "decl", "enc", "amp", "up", "align", "acc", "inner", "ind", "include", "start", "fac", "inn", "INC", "step", "con", "imp", "fc", "iter", "frac", "circ", "adj", "exc", "cc", "sum", "index", "diff", "alph", "init", "sign", "Inc"], "tmp": [" img", " dst", "pre", "cur", "cmp", "perm", "obj", "xy", "uf", "temp", "mb", "mp", "nb", "tf", "tk", " ret", "pp", "result", " amp", "mm", "params", "mk", "cmd", "list", "cp", "cache", " rgb", "img", "new", "qq", "resp", "msg", "cb", "tab", "mint", "buf", "ctx", " np", "np", "up", "td", "xs", "prime", "comp", "ind", "test", "attr", "nt", "MP", "txt", "gb", "sp", "frac", "copy", "tp", "etc", "buff", "pkg", "table", "zip", "t", " mp", "emp", "jj", "sq"]}}
{"project": "FFmpeg", "commit_id": "69c1fe7c9c9bc85eebfc02c6a19caf7e88cd74ff", "target": 0, "func": "static int mkv_write_ass_blocks(AVFormatContext *s, AVIOContext *pb,\n\n                                AVPacket *pkt)\n\n{\n\n    MatroskaMuxContext *mkv = s->priv_data;\n\n    int i, layer = 0, max_duration = 0, size, line_size, data_size = pkt->size;\n\n    uint8_t *start, *end, *data = pkt->data;\n\n    ebml_master blockgroup;\n\n    char buffer[2048];\n\n\n\n    while (data_size) {\n\n        int duration = ass_get_duration(data);\n\n        max_duration = FFMAX(duration, max_duration);\n\n        end          = memchr(data, '\\n', data_size);\n\n        size         = line_size = end ? end - data + 1 : data_size;\n\n        size        -= end ? (end[-1] == '\\r') + 1 : 0;\n\n        start        = data;\n\n        for (i = 0; i < 3; i++, start++)\n\n            if (!(start = memchr(start, ',', size - (start - data))))\n\n                return max_duration;\n\n        size -= start - data;\n\n        sscanf(data, \"Dialogue: %d,\", &layer);\n\n        i = snprintf(buffer, sizeof(buffer), \"%\" PRId64 \",%d,\",\n\n                     s->streams[pkt->stream_index]->nb_frames, layer);\n\n        size = FFMIN(i + size, sizeof(buffer));\n\n        memcpy(buffer + i, start, size - i);\n\n\n\n        av_log(s, AV_LOG_DEBUG,\n\n               \"Writing block at offset %\" PRIu64 \", size %d, \"\n\n               \"pts %\" PRId64 \", duration %d\\n\",\n\n               avio_tell(pb), size, pkt->pts, duration);\n\n        blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,\n\n                                       mkv_blockgroup_size(size));\n\n        put_ebml_id(pb, MATROSKA_ID_BLOCK);\n\n        put_ebml_num(pb, size + 4, 0);\n\n        // this assumes stream_index is less than 126\n\n        avio_w8(pb, 0x80 | (pkt->stream_index + 1));\n\n        avio_wb16(pb, pkt->pts - mkv->cluster_pts);\n\n        avio_w8(pb, 0);\n\n        avio_write(pb, buffer, size);\n\n        put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);\n\n        end_ebml_master(pb, blockgroup);\n\n\n\n        data      += line_size;\n\n        data_size -= line_size;\n\n    }\n\n\n\n    return max_duration;\n\n}\n", "idx": 24768, "substitutes": {"s": ["sys", "ms", "client", "os", "fs", "rs", "c", "ses", "ds", "hs", "conf", "spec", "n", "p", "sc", "cs", "sts", "aws", "ctx", "S", "js", "ss", "a", "ats", "b", "ts", "ns", "ps", "stats", "es", "gs", "sp", "sv", "sg", "self", "h", "ls", "t", "m", "v", "sq", "ssl"], "pb": ["patch", "pub", "vp", "pp", "_", "tc", "p", "pg", "ctx", "pl", "tg", "wb", "pa", "px", "snap", "mt", "pkg", "v", "pt", "sb", "emb", "obj", "pc", "cp", "n", "sc", "buf", "dp", "bot", "bp", "fp", "buff", "sys", "bb", "apy", "mp", "stab", "PB", "phys", "amp", "td", "bs", "into", "b", "ps", "tp", "rb", "lp", "tmp", "typ", "uf", "tk", "cmd", "resp", "cb", "np", "eb", "wp", "sp", "ab", "jp", "proc", "lb"], "pkt": ["Pvt", "Pdu", "ppkt", "ptx", "tpacket", "ppnt", "pracket", "cpdu", " pq", "tpk", "Pq", "ppvt", "proacket", "prq", " pwk", " pct", "pctx", "Ptx", "prdu", " packet", "cpacket", "packet", " pdu", "prowk", "prok", "mkt", " ptx", "pk", "pcnt", "cpct", "mdu", "ppct", "Packet", "pct", " pvt", "tpkt", "pcacket", "macket", "pq", "prokt", "prkt", " pnt", "Pwk", "mnt", "pckt", "tpwk", "Pct", "Pkt", "pnt", "pdu", "pwk", "cpkt", "pvt", "Pk", "Pnt", "mtx", "proct"], "mkv": ["mtvr", " mkV", "mutc", "kvc", "mkvp", " mkvp", "tkvc", "tkV", " mkvc", "mtvs", " mkc", "tkvp", "mtc", "mutv", "kvp", "mkV", "mtv", "mkc", "mkvc", " mkvs", "mkvs", "mutvr", "tkv", "kv", "mutvs", "kV", "mkvr", " mkvr"], "i": ["f", "it", "ic", "x", "ui", "multi", "d", "pi", "ini", "id", "index", "b", "c", "ri", "g", "in", "height", "gi", "I", "n", "p", "phi", "io", "memory", "di", "zi", "sim", "j", "ai", "mi", "ii", "li", "hi", "a", "is", "ti", "l", "ind", "info", "ip", "y", "ij", "ims", "bi", "ci", "position", "iter", "e", "uri", "u", "iu", "ni", "xi", "si", "t", "im", "all", "m", "v", "h", "cli", "init", "qi", "ix"], "size": ["ui", "address", "status", "unit", "storage", "id", " Size", "grow", "count", "write", "scale", "dimension", "max", "si", "sn", "padding", "dim", "space", "zone", "height", "ose", "send", "ize", "function", "total", "shape", "notice", "window", "scroll", "timeout", "offset", "type", "length", "network", "body", "read", "bytes", "area", "capacity", "l", "time", "number", "resolution", "sized", "sum", "stream", "large", "power", "len", "fee", "loss", "empty", "small", "set", "too", "span", "message", "general", "align", "speed", "shift", "SIZE", "south", "position", "num", "Size", "index", "duration", "name"], "line_size": [" line_length", "line2SIZE", "line2size", "line_space", " line_SIZE", "line_length", "Line_size", " line_space", "line2space", "Line_width", "line_width", "Line_length", "line_SIZE", "line2length"], "start": ["range", "address", "id", "in", "r", "p", "new", "origin", "pos", "alpha", "base", "step", "head", "max", "v", "space", "try", "begin", "entry", "first", "state", "add", "next", "key", "window", "offset", "before", "point", "type", "length", "trans", "reset", "from", "pad", "part", "starting", "get", "started", "art", "a", "l", "seek", "st", "time", "Start", "tmp", "it", "len", "middle", "g", "top", "root", "set", "to", "span", "stop", "shift", "delay", "wind", "position", "sp", "e", "source", "t", "mid", "index", "init", "name"], "end": ["range", "until", "length", "END", "ad", "out", "ment", "alt", "full", "except", "obj", "append", "nd", "ff", "len", "edge", "rend", "begin", "entity", "ent", "w", "entry", "pend", "done", "id", "event", "escape", "dev", "End", "send", "p", "close", "add", "ord", "set", "buf", "open", "ended", "hend", "complete", "endif", "last", "closed", "stop", "ending", "line", "east", "port", "old", "url", "wind", "st", "e", "en", " End", "est", "ue", "offset", "max", "h", "final", "eng", "all", "mid"], "data": ["ata", "d", "map", "done", "id", "dev", "r", "p", "pos", "raw", "base", "step", "table", "one", "padding", "parent", "value", "first", "video", "error", "n", "buf", "next", "shape", "dat", "window", "bin", "iter", "partial", "win", "offset", "multiple", "device", "type", "length", "batch", "trans", "reset", "pad", "def", "body", "read", "di", "bytes", "area", "input", "a", "text", "allow", "aud", "time", "DATA", "all", "no", "str", "f", "block", "stream", "len", "result", "date", "group", "row", "empty", "ed", "burst", "cache", "record", "feed", "to", "message", "image", "align", "Data", "last", "shift", "load", "e", "source", "t", "name"], "blockgroup": ["groupgroup", " blockmap", " blockgroups", " blocknumber", "groupGroup", "groupname", "bookvolume", "groupnumber", "blockname", "blockgroups", " blockvolume", " blockname", "Blocknumber", "bookgroup", "blockGroup", "groupgroups", "groupmap", "blocknumber", "BlockGroup", "blockvolume", " blockGroup", "bookmap", "blockmap", "bookgroups", "Blockgroup", "Blockname", "groupvolume"], "buffer": ["block", "stack", "device", "length", "batch", "out", "stream", "server", "byte", "bridge", "address", "queue", "only", "uf", "pad", "array", "integer", "result", "read", "word", "command", "row", "header", "comment", "send", "cache", "count", "memory", "pointer", "buf", "pair", "binary", "message", "sequence", "frame", "line", "b", "document", "window", "text", "base", "interface", "position", "iter", "Buffer", "buff", "ptr", "table", "source", "variable", "v"]}}
{"project": "qemu", "commit_id": "665414ad06aa1bc92e615db9641e58fb13d07de1", "target": 1, "func": "static int ram_block_enable_notify(const char *block_name, void *host_addr,\n\n                                   ram_addr_t offset, ram_addr_t length,\n\n                                   void *opaque)\n\n{\n\n    MigrationIncomingState *mis = opaque;\n\n    struct uffdio_register reg_struct;\n\n\n\n    reg_struct.range.start = (uintptr_t)host_addr;\n\n    reg_struct.range.len = length;\n\n    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;\n\n\n\n    /* Now tell our userfault_fd that it's responsible for this area */\n\n    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {\n\n        error_report(\"%s userfault register: %s\", __func__, strerror(errno));\n\n\n\n\n\n\n\n\n\n    return 0;\n", "idx": 24771, "substitutes": {"block_name": ["blocknamename", "blocknametype", "blocknamepath", "block_type", "lock_type", "lock_name", "block_names", "block_path", "blocknamenames", "lock_path", "lock_names"], "host_addr": ["Host_ref", "Host_addr", "host_address", "Host_ptr", "host_ptr", "host_ref", " host_address", " host_ref"], "offset": ["type", "address", "ref", "os", "op", "bound", "error", "count", "prefix", "set", "order", "origin", "coord", "pos", "shift", "size", "start", "port", "loc", "addr", "alloc", "base", "style", "off", "head", "before", "index"], "length": ["range", "idth", "padding", "block", "type", "ength", "Length", "address", "len", "pad", "value", "buffer", "height", "family", "count", "amount", "phi", "message", "total", "sequence", "depth", "shape", "capacity", "last", "ENGTH", "location", "size", "data", "load", "SIZE", "position", "limit", "number", " lengths", "end", "loop", "duration", "enth"], "opaque": ["OPaque", "oplasus", "opiphany", "oplaques", "oplosit", "OPaques", "OPosit", "ropaques", "OPois", "ropaque", "opque", "OPasus", "opliphany", "oplque", " Opiphany", "opasus", "oplois", " Opaque", " Opasus", "oposit", "oplaque", "OPque", "roposit", "opois", " Opque", "ropois", "OPiphany", "opaques"], "mis": ["ms", "mos", "sis", " us", "sic", "ma", "Mis", "asis", "fs", "us", "oses", "miss", "mm", "mx", "bm", "aos", "bos", "mas", "tis", "mes", "MS", "mit", "mits", "asm", "ias", "cm", "iss", "mi", "emis", "is", "wcs", "ims", "mr", " mes", "mn", "wi", "mt", "jp", " sus", "m"], "reg_struct": [" reg_ptr", " reg2struct", "reg__STRUCT", "register_str", "reg2obj", "regetydata", "register_data", "regetymethod", "Reg_struct", "cell_details", "reg_STRUCT", "Reg_STRUCT", " reg_obj", "cell_data", "register_destruct", "reg2fun", "reg2str", "reg_fun", " reg2str", "Reg__desc", "register_struct", "reg2struct", "reg_desc", "reg_details", " reg_fun", "Reg__struct", "cell_method", "reg_method", "reg_destruct", " reg2fun", "Reg_desc", "reg__desc", "reg_data", "cell_struct", "regetystruct", "regetystr", " reg2obj", "reg_ptr", "Reg__STRUCT", "regetydestruct", "reg__struct", "reg_str", "regetydetails", "reg_obj", " reg_desc", " reg_str"]}}
{"project": "FFmpeg", "commit_id": "6df2c94130b026930d1f7148699925dcaa08759c", "target": 0, "func": "static void draw_bar_yuv(AVFrame *out, const float *h, const float *rcp_h,\n\n                         const ColorFloat *c, int bar_h)\n\n{\n\n    int x, y, yh, w = out->width;\n\n    float mul, ht, rcp_bar_h = 1.0f / bar_h;\n\n    uint8_t *vy = out->data[0], *vu = out->data[1], *vv = out->data[2];\n\n    uint8_t *lpy, *lpu, *lpv;\n\n    int lsy = out->linesize[0], lsu = out->linesize[1], lsv = out->linesize[2];\n\n    int fmt = out->format;\n\n\n\n    for (y = 0; y < bar_h; y += 2) {\n\n        yh = (fmt == AV_PIX_FMT_YUV420P) ? y / 2 : y;\n\n        ht = (bar_h - y) * rcp_bar_h;\n\n        lpy = vy + y * lsy;\n\n        lpu = vu + yh * lsu;\n\n        lpv = vv + yh * lsv;\n\n        for (x = 0; x < w; x += 2) {\n\n            if (h[x] <= ht) {\n\n                *lpy++ = 16;\n\n                *lpu++ = 128;\n\n                *lpv++ = 128;\n\n            } else {\n\n                mul = (h[x] - ht) * rcp_h[x];\n\n                *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                *lpu++ = mul * c[x].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                *lpv++ = mul * c[x].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n            }\n\n            /* u and v are skipped on yuv422p and yuv420p */\n\n            if (fmt == AV_PIX_FMT_YUV444P) {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                    *lpu++ = 128;\n\n                    *lpv++ = 128;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                    *lpu++ = mul * c[x+1].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                    *lpv++ = mul * c[x+1].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n                }\n\n            } else {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                }\n\n            }\n\n        }\n\n\n\n        ht = (bar_h - (y+1)) * rcp_bar_h;\n\n        lpy = vy + (y+1) * lsy;\n\n        lpu = vu + (y+1) * lsu;\n\n        lpv = vv + (y+1) * lsv;\n\n        for (x = 0; x < w; x += 2) {\n\n            /* u and v are skipped on yuv420p */\n\n            if (fmt != AV_PIX_FMT_YUV420P) {\n\n                if (h[x] <= ht) {\n\n                    *lpy++ = 16;\n\n                    *lpu++ = 128;\n\n                    *lpv++ = 128;\n\n                } else {\n\n                    mul = (h[x] - ht) * rcp_h[x];\n\n                    *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                    *lpu++ = mul * c[x].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                    *lpv++ = mul * c[x].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n                }\n\n            } else {\n\n                if (h[x] <= ht) {\n\n                    *lpy++ = 16;\n\n                } else {\n\n                    mul = (h[x] - ht) * rcp_h[x];\n\n                    *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                }\n\n            }\n\n            /* u and v are skipped on yuv422p and yuv420p */\n\n            if (out->format == AV_PIX_FMT_YUV444P) {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                    *lpu++ = 128;\n\n                    *lpv++ = 128;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                    *lpu++ = mul * c[x+1].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                    *lpv++ = mul * c[x+1].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n                }\n\n            } else {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24787, "substitutes": {"out": ["f", "it", "ch", "batch", "full", "client", "o", "obj", "null", "conv", "err", "reset", "point", "conn", "success", "normal", "w", "one", "ex", "result", "output", "screen", "at", "error", "report", "g", "in", "over", "cmd", "list", "n", "p", "res", "io", "new", "set", "to", "call", "inv", "frame", "up", "Out", "raw", "outs", "file", "scan", "b", "data", "info", "dot", "base", "con", "version", "aux", "net", "OUT", "check", "t", "all", "end", "no", "v", "sum", "conf"], "h": ["f", "hd", "ch", "ih", "hash", "ph", "host", "he", "dh", "w", "hr", "pp", "hs", "hm", "hp", "ah", "r", "p", "kh", "hz", "sh", "oh", "th", "html", "hi", "b", "history", "bh", "ha", "H", "hh", "http", "hl", "t", "q", "m", "v", "hw"], "rcp_h": ["rcpPh", "rcp__h", "rccp_k", "rccp_hm", "rcp__H", "rcP_h", "rcP_H", "rcpPp", "rcpPhm", "rcp_p", "rcp__f", "rcp__ho", "rccp_h", "rcP_ho", "rcp_k", "rcp_hm", "rccp_p", "rcp_f", "rcpPk", "rcp_ho", "rcp_H", "rcP_f"], "c": ["f", "ch", "cf", "cam", "ce", "ca", "conv", "cu", "cal", "col", "pc", "bc", "tc", "dc", "ec", "g", "cp", "p", "n", "cache", "sc", "nc", "cn", "cs", "cb", "cm", "ctx", "co", "chain", "b", "ct", "xc", "vc", "ac", "wcs", "lib", "mc", "C", "fc", "con", "e", "u", "etc", "t", "cc", "m", "v", "lc", "cv", "conf"], "bar_h": ["bar_th", "barpreih", "bar_hs", "bar_hi", "barprebh", "row_hs", "row_ph", "comb_h", "scale_h", "barNamehs", "bar2h", "bar_p", "row_y", "row_h", "comb___h", "bar_height", "comb_th", "ca_hi", "bar_ph", "comb___th", "barLengthhs", "bar___h", "comb_ih", "comb___ih", "barNameph", "bar2height", "barpreth", "ca_h", "bar___bh", "bar2v", "bar___th", "bar___ih", "comb___bh", "scale_height", "barLengthy", "ca_f", "barLengthph", "bar_ih", "barNameh", "bar_f", "barpreh", "comb_bh", "scale_v", "bar_bh", "bar_v", "bar_y", "ca_p", "barLengthh", "barNamey"], "x": ["o", "status", "att", "yx", "id", "r", "p", "inx", "ctx", "exclusive", "ox", "z", "step", "px", "ey", "xxx", "fx", "i", "major", "tex", "tx", "xy", "search", "at", "xxxx", "n", "el", "add", "lat", "j", "X", "te", "xf", "key", "window", "scroll", "lex", "m", "ix", "xa", " cx", "batch", "ux", "full", "on", " xx", "k", "ry", "dx", "sw", "column", "xx", "l", "plus", "xp", "xi", "q", "wx", "w", " i", "xt", "ex", "xes", "mx", "rx", "row", "ext", "ax", "xc", "post", "e", "by", "check", "index", "name"], "y": ["my", "ch", "i", "gy", "xy", "dy", "hot", "ay", "fy", "try", "yt", "yn", "v", "yx", "yi", "ty", "ry", "yy", "sky", "uy", "iy", "yer", "height", "ady", "yu", "ley", "axy", "wy", "ny", "yl", "yp", "ye", "j", "ot", "cy", "kit", "yo", "hy", "b", "aily", "py", "yr", "ies", "z", "yd", "ey", "ya", "ys", "oy", "t", "sy", "ym", "Y", "ky", "asy", "m", "ly", "hey"], "yh": [" yht", "yth", "yoh", "yeoh", "yeh", "vyH", "yhe", "nyhi", "cyz", "nyhash", "eyoh", "eyh", "ieshe", "yyH", "vyhash", "uyz", " yhd", "Yh", "yyth", "vyhi", "cyth", "yyhe", "yysh", "Yhi", "uysh", "yhash", "yehe", "cysh", " yoh", "yyh", "eyhe", "iesh", "yyht", "uyth", "eyhd", "Yhash", "yhi", "nyh", "yz", " yhe", " yH", "iesht", "yehd", "yhd", "iesH", "yH", "yyz", "YH", "uyh", "cyh", "nyH", "yht", "vyh", "ysh"], "mul": ["manular", "mutil", "paramesh", " mmula", "paramaj", "gmcul", " mmUL", "mutul", "remol", "MUL", "mol", "ful", "fuf", "mutular", "remular", "Mul", " mcul", "mil", "muf", "lull", "muli", "remul", "mula", "cmUL", " moul", " mula", "Mull", "rcul", " maj", "Mula", "manula", "mutult", "rul", "remuler", "loul", "cmuli", "moul", "manoul", " mesh", " muler", " mult", "manuf", "mUL", "fcul", "mult", " mmuli", " mol", "Mult", "manull", "paramul", "lul", "mesh", "manul", " muf", "maj", " mmul", " mil", "fular", "dular", "dol", " mull", "manaj", "paramula", "rult", "cmull", "rUL", "Mcul", "manesh", "Muli", "mcul", "pmul", "fUL", "gmul", "Mil", "mular", "gmular", "pmular", " mUL", "Muf", "cmul", " mular", "muler", "gmuf", "mull", "pmil", "dul", " muli", "mancul", "pmult", "fil", "duler", "lula"], "ht": ["hd", "ch", "hop", "tm", "gy", "him", "xy", "hua", "dq", "ih", "iw", "dh", "att", "yt", "gt", "qt", "hr", "he", "hn", "phy", "tt", "rh", "zh", "yy", "hs", "wd", "hm", "height", "phi", "htm", "hz", "dt", "wy", "lat", "hei", "th", "html", "rt", "wt", "uh", "txt", "bh", "HT", "bt", "ha", "tp", "tif", "hh", "tml", "hl", "mt", "vt", "uly", "pt", "hw"], "vy": ["vm", "von", "fy", "ju", "zy", "yt", "vp", "yi", "yy", "ishy", "uy", "iy", "yu", "ley", "axy", "wy", "ny", "zu", "vr", "yo", "cy", "hy", "py", "vc", "isy", "ou", "ey", "sv", "yll", "qv", "vi", "ky", "ly", "vt", "oy", "vin", "v", "vet"], "vu": ["von", "ui", "fu", "ux", "ku", "asu", "cu", "tu", "ru", "ju", "vp", "uj", "us", "uy", "yu", "zu", "nu", "lu", "vo", "bu", "wu", "vc", "pu", "uu", "du", "u", "uo", "qv", "iu", "vi", "ue", "uv", "vin", "su"], "vv": ["vm", "von", "ov", "ku", "asu", "cu", "vd", "ev", "ju", "iv", "vp", "tv", "uj", "cv", "ul", "var", "yu", "nov", "ctl", "va", "avi", "buf", "vr", "vg", "vs", "uum", "av", "nv", "vc", "uu", "sv", "qv", "vi", "vt", "uv", "v", "lv"], "lpy": ["liaxy", "lpo", "dlpsy", "lpa", "llpy", "lipsy", "dlpse", "llxy", "llphp", "lbpa", "dlphp", " lpo", "lepsy", "dlpx", "lepy", "lpx", "llaxy", "lipi", "liphp", "lpxy", "lite", "lpte", " lpsy", "dlpy", "lpi", "dlpu", "llte", " lpx", "lipy", "dlpi", "lbpx", "llpsy", "llpa", "llpo", "lpse", "lixy", "lepu", " lpa", "lepx", "lte", "lipo", "lxy", "lbpy", "lphp", "dlpo", "lpaxy", " lpse", "laxy", "lipse", "llpx", " lpi", "lbpo", "lpsy", "lppy"], "lpu": ["lty", "nsu", "lpo", "mlpu", "lpid", "llpu", "lpie", "lspid", "npie", "limp", "pty", "elpu", "lsu", "nlpu", " lpo", "lisu", " lsu", "mpu", "lmp", "Lty", "lnu", "elnu", "Lpu", "Lcpu", "llcpu", "llpid", "lipie", "nlpie", "pcpu", "Lpy", "lcpu", "lipy", "Lsu", "llmp", "ppy", "mlpy", "Lpo", "mlpo", "llpo", "licpu", "npu", "lipu", "lspu", "mlsu", "lscpu", "llnu", "elpid", "lipo", "mnu", "mpo", "nlsu", "lity", "mmp", "linu", "elcpu", "lsnu", "ppu"], "lpv": ["lsve", "gpV", "lbvi", "lpvin", "linv", "ppv", "lsu", "lpr", "lsv", "LPve", "lpvt", "gpu", "ppV", "ctlvi", "lpvr", "lpvi", "linva", "gpv", "lpV", "ppvin", "lsvin", "lipve", "bpve", "lbf", "lpve", "lf", "lipvt", "lipvr", "lipvi", "ctlvr", "lbv", "lbr", "lpva", "bpv", "lpf", "lsV", "lsvt", "bpf", "lipr", "bpz", "linf", "mlf", "lipv", "lbvt", "LPz", "gpvin", "lbvr", "linve", "mlve", "lsr", "lpz", "lve", "ctlve", "mlv", "lva", "lbve", "LPf", "LPv", "ctlv", "lbz", "mlva", "lv", "ppu"]}}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "func": "static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)\n\n{\n\n    const char *file_out = qemu_opt_get(opts, \"path\");\n\n    HANDLE fd_out;\n\n\n\n    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,\n\n                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\n    if (fd_out == INVALID_HANDLE_VALUE) {\n\n        return -EIO;\n\n    }\n\n\n\n    return qemu_chr_open_win_file(fd_out, _chr);\n\n}\n", "idx": 24794, "substitutes": {"opts": ["oppt", "uppt", "iopts", "upgs", "iopths", "coptx", "ops", "optx", "optrs", "coprs", "ioptx", "oprs", "OPs", "opgs", "ups", "OPgs", "optths", "copts", "OPts", "opttx", "opths", "upts", "OPpt", "optpt", "ioprs", "copths", "optgs", "optts"], "_chr": ["_otlr", " _Chrs", "_otar", "_Char", " _Chp", " _Chl", "_otr", " _chl", "_char", " _Chr", "_Chp", " _char", "_chl", "_echrs", "_CHlr", " _Char", "_echt", " _chrs", "_CHr", "_Chl", "_Chrs", " _chp", "_CHar", "_chlr", "_chp", " _Chlr", "_chrs", " _Cht", "_Cht", " _chlr", "_otp", "_CHp", "_echr", "_echl", "_cht", "_Chr", " _cht", "_Chlr"], "file_out": [" file_Out", " file_output", "file_handle", "file_output", "file_in", "file__out", "File_out", "file__Out", "File_handle", "file__output", "file_name", "File_in", "file_Out", "file__in", " file_in", "File_name"], "fd_out": ["fd2Out", "fd_OUT", "fd___OUT", "file_OUT", "FD_new", "FD_check", "fd_list", "file2con", "fd_in", "fd_con", "file_group", "FD_out", "file2out", "file_Out", "fd___in", "fd_key", "fd___out", "fd2key", "FD_in", "file_in", "fd2out", "fd_check", "fd___group", "file2key", "fd2con", "FD_list", "file_key", "fd_group", "fd_Out", "fd_new", "file2Out", "file_con"]}}
{"project": "FFmpeg", "commit_id": "a38758a97efe9c2de48b5429fd2fdebd55ba6a64", "target": 1, "func": "int ff_h264_fill_default_ref_list(H264Context *h, H264SliceContext *sl)\n\n{\n\n    int i, len;\n\n\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {\n\n        H264Picture *sorted[32];\n\n        int cur_poc, list;\n\n        int lens[2];\n\n\n\n        if (FIELD_PICTURE(h))\n\n            cur_poc = h->cur_pic_ptr->field_poc[h->picture_structure == PICT_BOTTOM_FIELD];\n\n        else\n\n            cur_poc = h->cur_pic_ptr->poc;\n\n\n\n        for (list = 0; list < 2; list++) {\n\n            len  = add_sorted(sorted,       h->short_ref, h->short_ref_count, cur_poc, 1 ^ list);\n\n            len += add_sorted(sorted + len, h->short_ref, h->short_ref_count, cur_poc, 0 ^ list);\n\n            av_assert0(len <= 32);\n\n\n\n            len  = build_def_list(h->default_ref_list[list], FF_ARRAY_ELEMS(h->default_ref_list[0]),\n\n                                  sorted, len, 0, h->picture_structure);\n\n            len += build_def_list(h->default_ref_list[list] + len,\n\n                                  FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,\n\n                                  h->long_ref, 16, 1, h->picture_structure);\n\n            av_assert0(len <= 32);\n\n\n\n            if (len < sl->ref_count[list])\n\n                memset(&h->default_ref_list[list][len], 0, sizeof(H264Ref) * (sl->ref_count[list] - len));\n\n            lens[list] = len;\n\n        }\n\n\n\n        if (lens[0] == lens[1] && lens[1] > 1) {\n\n            for (i = 0; i < lens[0] &&\n\n                        h->default_ref_list[0][i].parent->f.buf[0]->buffer ==\n\n                        h->default_ref_list[1][i].parent->f.buf[0]->buffer; i++);\n\n            if (i == lens[0]) {\n\n                FFSWAP(H264Ref, h->default_ref_list[1][0], h->default_ref_list[1][1]);\n\n            }\n\n        }\n\n    } else {\n\n        len  = build_def_list(h->default_ref_list[0], FF_ARRAY_ELEMS(h->default_ref_list[0]),\n\n                              h->short_ref, h->short_ref_count, 0, h->picture_structure);\n\n        len += build_def_list(h->default_ref_list[0] + len,\n\n                              FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,\n\n                              h-> long_ref, 16, 1, h->picture_structure);\n\n        av_assert0(len <= 32);\n\n\n\n        if (len < sl->ref_count[0])\n\n            memset(&h->default_ref_list[0][len], 0, sizeof(H264Ref) * (sl->ref_count[0] - len));\n\n    }\n\n#ifdef TRACE\n\n    for (i = 0; i < sl->ref_count[0]; i++) {\n\n        tprintf(h->avctx, \"List0: %s fn:%d 0x%p\\n\",\n\n                (h->default_ref_list[0][i].parent->long_ref ? \"LT\" : \"ST\"),\n\n                h->default_ref_list[0][i].pic_id,\n\n                h->default_ref_list[0][i].parent->f.data[0]);\n\n    }\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {\n\n        for (i = 0; i < sl->ref_count[1]; i++) {\n\n            tprintf(h->avctx, \"List1: %s fn:%d 0x%p\\n\",\n\n                    (h->default_ref_list[1][i].parent->long_ref ? \"LT\" : \"ST\"),\n\n                    h->default_ref_list[1][i].pic_id,\n\n                    h->default_ref_list[1][i].parent->f.data[0]);\n\n        }\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 24818, "substitutes": {"h": ["f", "here", "hd", "ch", "cur", "ih", "hash", "ph", "comm", "host", "he", "dh", "w", "c", "eh", "pp", "rh", "hs", "zh", "dev", "hm", "g", "hp", "ah", "header", "r", "p", "cache", "kh", "el", "s", "hz", "sh", "hal", "sw", "oh", "ctx", "ht", "th", "HH", "html", "hi", "gh", "l", "y", "history", "uh", "bh", "handle", "window", "z", "ha", "H", "hh", "hl", "http", "m", "v", "ho", "hw"], "sl": ["sn", "cl", "ssh", "sb", "Sl", "spot", "rl", "bl", "slice", "syn", "tl", "se", "ln", "c", "nl", "scl", "fl", "zh", "sel", "SL", "sc", "s", "shr", "sh", "spl", "sw", "ht", "pl", "bs", "isl", "pse", "so", "l", "dl", "bh", "sp", "serv", "hl", "sv", "sf", "kl", "ls", "ml", "jl", "gro", "ssl"], "i": ["f", "it", "ic", "x", "batch", "ui", "client", "multi", "ki", "status", "try", "us", "pi", "c", " ii", "id", "ini", "at", "in", "r", "gi", "I", "p", "phi", "di", "oi", "zi", "sim", "j", "ai", "mi", "li", "ii", "hi", "is", "ti", "l", "ind", "info", "ip", "bi", "y", "ci", "iter", "iu", "xi", "si", "im", "q", "index", "v", "init", "qi", "this", "ei", "ix"], "len": ["cmp", "alt", "gen", "ll", "bl", "norm", "lt", "gz", "mem", "lis", "count", "vol", "pos", "pl", "li", "size", "dl", "lan", "loc", "lim", "coll", "gl", "il", "lvl", "syn", "rev", "spec", "n", "el", "msg", "fun", "lib", "relation", "iter", "en", "label", "ml", "cl", "von", "length", "ld", "den", "full", "L", "ln", "def", "ell", "fl", "ul", "seq", "lf", "Len", "compl", "low", "lig", "vec", "l", "lang", "limit", "pres", "rot", "lp", "kl", "ls", "elt", "str", "lc", "wid", "lit", "err", "ref", "fin", "rel", "lon", "html", "comp", "sp", "val", "hl", "ler"], "sorted": ["Sort", "sorting", "Sorted", "Sorting", "rsort", "Sordered", "isort", "sordered", "rsorter", "rsorted", "Sorter", "sorter", "isorter", "insorted", "insorting", "sort", "insorter", " sort", "isorting", "insort", "isorted", "saved", " sorting", " sorter", " sordered", "insaved", "Saved", "rsorting", "isordered", "isaved"], "cur_poc": ["cur_voco", "cur_pvoc", "cur_pioco", "cur_vocol", "cur_phpvoc", "cur_perOC", "cur_Pop", "cur_opoc", "cur_pioc", "cur_picoca", "cur_vOC", "cur_prix", "cur_piivot", "cur_pix", "cur_opOC", "cur_pocol", "cur_voca", "cur_permoc", "cur_piocol", "cur_peroc", "cur_pocation", "cur_phpocation", "cur_posc", "cur_picoco", "cur_Poc", "cur_prop", "cur_POC", "cur_piOC", "cur_pOC", "cur_vvoc", "cur_piix", "cur_vivot", "cur_piop", "cur_poco", "cur_vocation", "cur_phpOC", "cur_voc", "cur_loca", "cur_prOC", "cur_losc", "cur_ploc", "cur_proc", "cur_permop", "cur_ploco", "cur_plocol", "cur_poca", "cur_phpoc", "cur_vix", "cur_pop", "cur_plivot", "cur_loc", "cur_loco", "cur_perocation", "cur_picosc", "cur_opop", "cur_Poca", "cur_vop", "cur_vosc", "cur_permOC", "cur_opoca", "cur_picoc", "cur_pivot", "cur_pervoc", "cur_permoca"], "list": ["range", "alt", "status", "lists", "id", "lt", "count", "li", "and", "any", "token", "size", "dl", "link", "user", "listed", "table", "lvl", "note", "parent", "item", "code", "spec", "add", "msg", "lat", "level", "total", "tag", "chain", "ind", "LI", "ist", "label", "card", "tree", "type", "batch", "length", "L", "from", "part", "ul", "member", "high", "act", "form", "art", "show", "file", "old", "l", "test", "LIST", "st", "number", "single", "ls", "all", "no", "lc", "block", "alist", "out", "null", "List", "local", "row", "top", "collection", "layer", "record", "set", "plot", "order", "sequence", "feat", "num", "loop", "index", "name"], "lens": ["ilens", "ylents", " languages", "Lizes", "olens", "flenses", "glents", "olears", "flens", "llanguages", "lems", "ilaps", "plen", "Lears", "lents", "olents", " lems", "flems", "plizes", "leens", "llaps", "ylens", " lows", "llents", "Lows", "ilenses", "leents", "Len", "lenses", "plents", "glens", "lows", "Laps", "olensions", "leen", "Lenses", "lensions", "languages", "Lents", "Lens", "lizes", " lenses", "llens", "plens", "glems", " laps", "Languages", " lents", " lizes", "laps", "ylears", "ylensions", "leows", "flents", "glenses", "Lensions", "ilents", "lears"]}}
{"project": "qemu", "commit_id": "a3f409cb4a35d9aa6a4d24a7a1e05423e189cb7a", "target": 1, "func": "static void vtd_init(IntelIOMMUState *s)\n\n{\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n\n\n\n    memset(s->csr, 0, DMAR_REG_SIZE);\n\n    memset(s->wmask, 0, DMAR_REG_SIZE);\n\n    memset(s->w1cmask, 0, DMAR_REG_SIZE);\n\n    memset(s->womask, 0, DMAR_REG_SIZE);\n\n\n\n    s->iommu_ops.translate = vtd_iommu_translate;\n\n    s->iommu_ops.notify_started = vtd_iommu_notify_started;\n\n    s->root = 0;\n\n    s->root_extended = false;\n\n    s->dmar_enabled = false;\n\n    s->iq_head = 0;\n\n    s->iq_tail = 0;\n\n    s->iq = 0;\n\n    s->iq_size = 0;\n\n    s->qi_enabled = false;\n\n    s->iq_last_desc_type = VTD_INV_DESC_NONE;\n\n    s->next_frcd_reg = 0;\n\n    s->cap = VTD_CAP_FRO | VTD_CAP_NFR | VTD_CAP_ND | VTD_CAP_MGAW |\n\n             VTD_CAP_SAGAW | VTD_CAP_MAMV | VTD_CAP_PSI | VTD_CAP_SLLPS;\n\n    s->ecap = VTD_ECAP_QI | VTD_ECAP_IRO;\n\n\n\n    if (x86_iommu->intr_supported) {\n\n        s->ecap |= VTD_ECAP_IR | VTD_ECAP_EIM;\n\n    }\n\n\n\n    vtd_reset_context_cache(s);\n\n    vtd_reset_iotlb(s);\n\n\n\n    /* Define registers with default values and bit semantics */\n\n    vtd_define_long(s, DMAR_VER_REG, 0x10UL, 0, 0);\n\n    vtd_define_quad(s, DMAR_CAP_REG, s->cap, 0, 0);\n\n    vtd_define_quad(s, DMAR_ECAP_REG, s->ecap, 0, 0);\n\n    vtd_define_long(s, DMAR_GCMD_REG, 0, 0xff800000UL, 0);\n\n    vtd_define_long_wo(s, DMAR_GCMD_REG, 0xff800000UL);\n\n    vtd_define_long(s, DMAR_GSTS_REG, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_RTADDR_REG, 0, 0xfffffffffffff000ULL, 0);\n\n    vtd_define_quad(s, DMAR_CCMD_REG, 0, 0xe0000003ffffffffULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_CCMD_REG, 0x3ffff0000ULL);\n\n\n\n    /* Advanced Fault Logging not supported */\n\n    vtd_define_long(s, DMAR_FSTS_REG, 0, 0, 0x11UL);\n\n    vtd_define_long(s, DMAR_FECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_FEDATA_REG, 0, 0x0000ffffUL, 0);\n\n    vtd_define_long(s, DMAR_FEADDR_REG, 0, 0xfffffffcUL, 0);\n\n\n\n    /* Treated as RsvdZ when EIM in ECAP_REG is not supported\n\n     * vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0xffffffffUL, 0);\n\n     */\n\n    vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0, 0);\n\n\n\n    /* Treated as RO for implementations that PLMR and PHMR fields reported\n\n     * as Clear in the CAP_REG.\n\n     * vtd_define_long(s, DMAR_PMEN_REG, 0, 0x80000000UL, 0);\n\n     */\n\n    vtd_define_long(s, DMAR_PMEN_REG, 0, 0, 0);\n\n\n\n    vtd_define_quad(s, DMAR_IQH_REG, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_IQT_REG, 0, 0x7fff0ULL, 0);\n\n    vtd_define_quad(s, DMAR_IQA_REG, 0, 0xfffffffffffff007ULL, 0);\n\n    vtd_define_long(s, DMAR_ICS_REG, 0, 0, 0x1UL);\n\n    vtd_define_long(s, DMAR_IECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_IEDATA_REG, 0, 0xffffffffUL, 0);\n\n    vtd_define_long(s, DMAR_IEADDR_REG, 0, 0xfffffffcUL, 0);\n\n    /* Treadted as RsvdZ when EIM in ECAP_REG is not supported */\n\n    vtd_define_long(s, DMAR_IEUADDR_REG, 0, 0, 0);\n\n\n\n    /* IOTLB registers */\n\n    vtd_define_quad(s, DMAR_IOTLB_REG, 0, 0Xb003ffff00000000ULL, 0);\n\n    vtd_define_quad(s, DMAR_IVA_REG, 0, 0xfffffffffffff07fULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_IVA_REG, 0xfffffffffffff07fULL);\n\n\n\n    /* Fault Recording Registers, 128-bit */\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_0, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_2, 0, 0, 0x8000000000000000ULL);\n\n\n\n    /*\n\n     * Interrupt remapping registers.\n\n     */\n\n    vtd_define_quad(s, DMAR_IRTA_REG, 0, 0xfffffffffffff80fULL, 0);\n\n}\n", "idx": 24824, "substitutes": {"s": ["eps", "reads", "comm", "sports", "c", "sam", "tags", "comments", "sync", "tests", "r", "pers", "mods", "p", "changes", "aws", "bits", "vs", "S", "ns", "ies", "y", "states", "less", "actions", "h", "v", "sq", "sd", "i", "space", "sb", "args", "os", "rs", "us", "sl", "spec", "n", "cs", "services", "als", "ats", "ts", "ims", "styles", "its", "ers", "parts", "sys", "ms", "as", "ins", "gets", "simple", "ties", "ses", "results", "ids", "bis", "sts", "sw", "sql", "bs", "is", "l", "ps", "locks", "stats", "ads", "gs", "ls", "ports", "se", "fs", "ds", "hs", "details", "sets", "set", "an", "js", "ss", "settings", "qs", "terms", "south", "es", "e", "sv", "self", "t", "utils"], "x86_iommu": ["x86_iomingu", "x86_iomtu", "x86_iummue", "x86_gomun", "x86_Iommcu", "x86_iommtu", "x86_iomcu", "x86_iophercu", "x86_gomcu", "x86_Iommue", "x86_iommun", "x86_iormcu", "x86_gommu", "x86_iomun", "x86_iomue", "x86_iopheru", "x86_gommcu", "x86_Iommtu", "x86_iummtu", "x86_iomingun", "x86_iummcu", "x86_iommcu", "x86_iomingcu", "x86_iormue", "x86_Iomu", "x86_iummu", "x86_Iomcu", "x86_iormtu", "x86_Iomue", "x86_gomu", "x86_Iomtu", "x86_iomu", "x86_iommue", "x86_iopherun", "x86_Iommu", "x86_gommun", "x86_iormu"]}}
{"project": "FFmpeg", "commit_id": "ce19aec15b4291dc48e791d89a1f940babc22cdc", "target": 0, "func": "const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)\n\n{\n\n    av_assert2(p < end);\n\n\n\n    end-=2;\n\n    p++;\n\n    for(;p<end; p+=2){\n\n        if(!*p){\n\n            if     (!p[-1] && p[1]) return p - 1;\n\n            else if(!p[ 1] && p[2]) return p;\n\n        }\n\n    }\n\n    return end+2;\n\n}\n", "idx": 24829, "substitutes": {"av_restrict": ["av_restriction", "av_destrict", "av_Restrict", "av_destriction", "av_stateind", "av_district", "av_distind", "av_Restricted", "av_statericted", "av_Restriction", "av_restricted", "av_stateriction", "av_distriction", "av_destind", "av_destricted", "av_staterict", "av_districted", "av_restind"], "p": ["pb", "app", "d", "vp", "pp", "c", "r", "pers", "pg", "pid", "par", "pos", "pe", "pair", "pl", "rep", "info", "ip", "page", "y", "pa", "z", "progress", "pkg", "ptr", "h", "v", "pt", "i", "pc", "after", "at", "pr", "cp", "n", "j", "dp", "bp", "fp", "m", "point", "ping", "perm", "op", "pad", "part", "pn", "ap", "b", "l", "ps", "tp", "lp", "P", "q", "parse", "f", "pm", "pre", "out", "err", "power", "pi", "g", "empty", "span", "np", "up", "php", "port", "post", "wp", "pro", "sp", "e", "u", "pat", "jp", "end", "t"]}}
{"project": "qemu", "commit_id": "736d120af4bf5f3e13b2f90c464b3a24847f78f0", "target": 0, "func": "void helper_ctc1(CPUMIPSState *env, target_ulong arg1, uint32_t reg)\n\n{\n\n    switch(reg) {\n\n    case 25:\n\n        if (arg1 & 0xffffff00)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0x017fffff) | ((arg1 & 0xfe) << 24) |\n\n                     ((arg1 & 0x1) << 23);\n\n        break;\n\n    case 26:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfffc0f83) | (arg1 & 0x0003f07c);\n\n        break;\n\n    case 28:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfefff07c) | (arg1 & 0x00000f83) |\n\n                     ((arg1 & 0x4) << 22);\n\n        break;\n\n    case 31:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = arg1;\n\n        break;\n\n    default:\n\n        return;\n\n    }\n\n    /* set rounding mode */\n\n    restore_rounding_mode(env);\n\n    /* set flush-to-zero mode */\n\n    restore_flush_mode(env);\n\n    set_float_exception_flags(0, &env->active_fpu.fp_status);\n\n    if ((GET_FP_ENABLE(env->active_fpu.fcr31) | 0x20) & GET_FP_CAUSE(env->active_fpu.fcr31))\n\n        do_raise_exception(env, EXCP_FPE, GETPC());\n\n}\n", "idx": 24847, "substitutes": {"env": ["app", "vp", "disk", "er", "dev", "vv", "gate", "mem", "timer", "pg", "forge", "extra", "et", "ctx", "vs", "eg", "environment", "estate", "runner", "equ", "era", "h", "v", "ee", "enter", "ei", "vm", "here", "obj", "ev", "conn", "erd", "entry", "config", "eh", "operator", "ec", "db", "cp", "msg", "gear", "buf", "te", "inv", "stage", "desc", "window", "em", "global", "en", "net", "vt", "Environment", "hw", "context", "engine", "esc", "ef", "den", "network", "ah", "sw", "shell", "door", "doc", "nv", "test", "addr", "worker", "manager", "cv", "stack", "ov", "client", "server", "ner", "viron", "tk", "ew", "ext", "cmd", "oe", "org", "cb", "loader", "order", " environment", "req", "query", "txt", "e", "hl", "end", "eng", "uv", "init"], "arg1": ["link2", "argone", "arg0", " arg01", " argument2", "args2", " arg0", "arg001", "alt512", "arg8", "Arg1", "arr191", " arg8", "match001", " arg11", " argument1", " arg2", "locone", "argument2", "argumentOne", "app01", "agg1", "Arg11", "args0", "prop2", "loc001", "prop1", "msgized", "addr512", "alt0", "link01", " argument0", " arg3", "sum191", "attized", "argument8", "test1", "matched", "msg191", "alt1", "app1", "argument1", "app512", "app0", "val8", "matchone", "val1", "Arg0", "testOne", "app2", "sumized", "event1", "arg3", "app11", "app51", "agg01", "msg1", "argument3", "addr001", "arg191", "prop01", "block1", "val2", "sum101", "arg512", "arg51", "eventone", "block2", "msg101", "link1", "block001", "argumentized", "arrized", "attOne", "addr0", "argument11", "evented", "loced", "prop3", "test2", "event001", "arg2", "arr101", "link001", "alt11", " argument11", "match1", "block01", "argument01", "argOne", "argument51", "arr1", "agg51", "argument512", "att1", "Arg2", "sum1", "argument0", "addr1", "arg101", "argized", "argument001", "testized", "args1", "arg11", "arged", "val3", "alt001", "loc1", "att2", "args3", "agg2", "arg01"], "reg": ["region", "match", "typ", "red", "registered", "rm", "Reg", "re", "ref", "br", "lag", "rc", "abc", "ia", "index", "or", "row", "g", "r", "round", "cmd", "rec", "REG", "asm", "rem", "isc", "eg", "sec", "tag", "leg", "script", "key", "addr", "ret", "gc", "pattern", "eng", "arg", "res"]}}
{"project": "qemu", "commit_id": "94ad5b00a31113ed36b9d03a8db16de5535e90c4", "target": 0, "func": "static void cpu_set_irq(void *opaque, int irq, int level)\n\n{\n\n    CPUState *env = opaque;\n\n\n\n    if (level) {\n\n        CPUIRQ_DPRINTF(\"Raise CPU IRQ %d\\n\", irq);\n\n        env->halted = 0;\n\n        env->pil_in |= 1 << irq;\n\n        cpu_check_irqs(env);\n\n    } else {\n\n        CPUIRQ_DPRINTF(\"Lower CPU IRQ %d\\n\", irq);\n\n        env->pil_in &= ~(1 << irq);\n\n        cpu_check_irqs(env);\n\n    }\n\n}\n", "idx": 24853, "substitutes": {"opaque": ["OPaque", "Opaques", "OPane", "oplca", "iopaques", " opca", "OPca", "opue", "Opue", " opaques", "Opaque", " opue", "iopue", " opient", "opca", "iopient", "Opient", "oplane", " opane", "iopaque", "oplaque", "opient", "opane", "opaques"], "irq": ["irtqi", "iriquest", "ireq", "ireqa", "pirp", "irtq", "renqq", "iraconf", " irqq", "irique", "reng", "rirgate", "interp", "irtql", "irqu", "irquest", "irque", " irp", "pirqu", "iriq", "ireql", "irp", "pirquest", " irquest", " irquer", "iriware", "iriconf", "irqi", " virql", "ireqi", "irfy", " virqi", "irtqa", "pirq", "interq", "irqq", "irg", "rirq", "irify", " virq", "pirquer", "irware", "iraq", "rirqu", "renq", " irgate", "interquest", "irquer", "rirware", "rirquest", "irql", " virqa", "pirfy", "irconf", "rirconf", "interquer", "iraware", "iraque", "irgate", "rirfy", " irg", "iriqu", "irqa", "rirque", "rengate", "rirqq", "rirg"], "level": ["lvl", "type", "where", "Level", "condition", "status", "code", "bit", "visible", "local", "high", "member", "group", "count", "layer", "mode", "VEL", "low", "le", "goal", "show", "depth", "print", "levels", "priority", "scale", "vel", "impact", "quiet", "limit", "style", "flag", "allowed", "scope", "required", "loop", "index", "legal", "role"], "env": [" horizon", "dh", " envelope", "disk", "er", "dev", "vs", "environment", " ov", "estate", " te", " buffer", "scope", "der", "v", "ee", "enter", "vm", "obj", "ev", "conn", "code", "erd", "config", "entry", "eh", "ec", "db", "gear", "bar", "goal", "actor", "desc", "window", " envoy", "global", "en", "vt", "Environment", "context", "engine", "esc", "ef", "den", " ent", "screen", "console", "ah", "policy", " vex", "door", "shell", "doc", "worker", "outer", "manager", "ov", "server", "viron", "ds", " en", " dh", "ext", "cmd", "ve", "oe", " environment", " ne", "menu", "die", " context", "e", "end", "uv"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int get_stream_blocksize(BlockDriverState *bdrv)\n\n{\n\n    uint8_t cmd[6];\n\n    uint8_t buf[12];\n\n    uint8_t sensebuf[8];\n\n    sg_io_hdr_t io_header;\n\n    int ret;\n\n\n\n    memset(cmd, 0, sizeof(cmd));\n\n    memset(buf, 0, sizeof(buf));\n\n    cmd[0] = MODE_SENSE;\n\n    cmd[4] = sizeof(buf);\n\n\n\n    memset(&io_header, 0, sizeof(io_header));\n\n    io_header.interface_id = 'S';\n\n    io_header.dxfer_direction = SG_DXFER_FROM_DEV;\n\n    io_header.dxfer_len = sizeof(buf);\n\n    io_header.dxferp = buf;\n\n    io_header.cmdp = cmd;\n\n    io_header.cmd_len = sizeof(cmd);\n\n    io_header.mx_sb_len = sizeof(sensebuf);\n\n    io_header.sbp = sensebuf;\n\n    io_header.timeout = 6000; /* XXX */\n\n\n\n    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);\n\n    if (ret < 0 || io_header.driver_status || io_header.host_status) {\n\n        return -1;\n\n    }\n\n    return (buf[9] << 16) | (buf[10] << 8) | buf[11];\n\n}\n", "idx": 24855, "substitutes": {"bdrv": ["bvrf", "bldvc", "vdrvr", "vdrver", "bserv", "bvrvc", "bdrver", "bdrvc", "vsrvr", "bserver", "bsrvc", "vsrver", "vdrv", "bvrvr", " bdrvc", "bdrf", " bldf", "bsrf", "bservr", " bldv", "vsrf", "bldv", "vsrv", "bldvr", " bldvc", "bdrvr", "bvrv", " bldvr", "bsrv", "bserf", "vdrf", "bldf", "bldver", " bdrf", "bsrvr", "bsrver", " bdrvr"], "cmd": ["help", "cl", "opt", "cur", "quit", "cmp", "job", "batch", "tx", "force", "gen", "obj", "dq", "uf", "pay", "conn", "code", "comm", "config", "def", "map", "crypt", "cd", "ctr", "cont", "phy", "mem", "command", "seq", "path", "mk", "md", "ext", "det", "cp", "cond", "mode", "img", "msg", "cb", "call", "ctx", "cod", "raw", "cfg", "comp", "req", "desc", "ind", "ct", "nt", "fun", "addr", "txt", "Cmd", "window", "handle", "exec", "buff", "pkg", "off", "content", "control", "cli", "pt"], "buf": ["obj", "block", "context", "cur", "batch", "tx", "pb", "err", "pipe", "dq", "ref", "queue", "uf", "ff", "br", "nm", "nb", "vp", "def", "map", "buffer", "wait", "mem", "seq", "path", "db", "pool", "cp", "Buff", "p", "cache", "arr", "img", "resp", "msg", "cb", "bytes", "ctx", "pos", "vec", "bag", "bg", "np", "doc", "orig", "desc", "data", "nt", "wb", "ba", "txt", "window", "bin", "rb", "cap", "Buffer", "buff", "pkg", "q", "eng", "tmp", "proc", "v", "cv", "pt"], "sensebuf": ["sexbuff", "iebuffer", "enseblock", "ensebuff", " sensedata", " senseblock", "sensebuffer", " sensewindow", "tiebuf", "ensefb", "tiebuffer", "sexwindow", "tiewindow", "rangefb", " sensebuffer", "iebuf", "sexcb", "sensedata", "ensedata", "tiebuff", "rangecb", "sensebuff", "sensewindow", "ensebuffer", "rangebuf", "sexbuffer", "senseblock", "sexfb", "sensefb", "sensecb", "rangebuff", "sexbuf", " sensebuff", "ieblock", "ensecb", "iedata", "ensebuf"], "io_header": ["io___list", "ao_handler", "auto_master", "ioptinfo", "ioptdetail", "iopthead", "io___data", "io_headers", "io_source", "io2info", "ioerloader", "io__writer", "io_master", "io_Header", " io_wrapper", "cli_header", " io2dr", "io2wrapper", "iooheader", " io_info", "ao\u05bcheader", "io\u05bchandler", "io_state", "error_head", "io__tree", " io_status", "ioOdevice", "ioerheader", "ioptwrapper", "io_writer", " io_list", "ioptholder", "lo_header", " io_layer", "io2holder", "io\u05bcdetail", " io_headers", "ioachead", "io___detail", " io_source", "ioptheader", "lo_device", " io_tree", "io_layer", "io2header", "autoerloader", "io2drm", "ao_header", " io_drm", " io2holder", "io_head", "auto_loader", "ioermodel", "io_body", " io_state", "clioheader", "clioinfo", "cli_holder", " io_writer", "io_wrapper", " io_head", "io_status", "clioholder", "ioaclayer", "io_drm", "error_state", "auto_header", "autoermaster", "io_dr", "ioptplayer", " io_master", "io___handler", "iojbody", "iojheader", "io_player", "ioerhead", " io_metadata", "io_tree", "io___state", "io_detail", " io_model", "io_holder", " io_term", " io2drm", "ao_detail", "ioermaster", "io___header", "ioermetadata", "ioacstate", "erroracplayer", " io_body", "io_term", "cli_info", "iooinfo", "ioodetail", "error_header", "erroracstate", "iooholder", "cliodetail", "ioacheader", "io\u05bcdata", "erroracheader", "io_list", " io2Header", "ao_data", " io2info", " io_holder", "ioptdrm", "ioptHeader", "lo_headers", "io_loader", "io__header", "ioptmetadata", "io__state", " io_dr", "lo_layer", "autoermodel", "ioacplayer", " io_Header", " io2header", "ioacterm", "io__headers", "ao\u05bcdata", "ioptsource", "auto_model", " io2wrapper", "io__flag", "io___tree", "io_handler", "io2Header", "io_device", "io2dr", "io_info", "ioacholder", " io_flag", "ioptmaster", "cli_detail", "ao\u05bcdetail", "io__list", "io_metadata", "ao\u05bchandler", "ioOlayer", "autoerheader", "ioOheader", "error_player", " io_player", "io_data", "io_model", "errorachead", "io\u05bcheader", "io_flag", "ioOheaders"], "ret": ["inter", "alt", "ount", "out", "ter", "lit", "err", "reset", "ll", "RET", "re", "len", "gt", "xt", " fut", "result", "cont", "lt", "ext", "det", "reply", "deg", "arr", "resp", "rect", "usr", "rem", "ne", "rt", "back", "desc", "nt", "rets", " RET", "ft", " Ret", "val", "flag", "mt", "aux", "Ret", " alt", "tr", "gc", "elt", "t", "Return", "res"]}}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,\n\n                                  int64_t size)\n\n{\n\n    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (ret > 0) {\n\n        int metadata_ol_bitnr = ffs(ret) - 1;\n\n        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);\n\n\n\n        qcow2_signal_corruption(bs, true, offset, size, \"Preventing invalid \"\n\n                                \"write on metadata (overlaps with %s)\",\n\n                                metadata_ol_names[metadata_ol_bitnr]);\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24880, "substitutes": {"bs": ["ubis", "bb", "ms", "sb", "bas", "bl", "lbs", "bles", "bps", "fs", "bc", "bes", "BS", "ses", "bf", "ubs", "ds", "hs", "bm", "ks", "bos", "bis", "cs", "cks", "sts", "bits", "iss", "vs", "js", "ss", "b", "ts", "bi", "ba", "qs", "bd", "bh", "bt", "its", "gs", "bp", "obs", "ls"], "ign": ["urn", " assign", "ignment", "aff", "box", "col", "sam", "abc", "cont", "reg", "mem", "auth", "act", "cmd", "iam", "ignore", "cond", "ize", "add", "set", "bind", "ont", "coord", "bag", "align", "bn", "IGN", "igned", "ind", "anc", "loc", "iban", "gn", "check", "rn", "lock", "aj", "sign", "anch"], "offset": ["block", "type", "attribute", "out", "upload", "o", "address", "ref", "op", "part", " offsets", "error", "owner", "absolute", "metadata", "offs", "ocation", "amount", "alias", "prefix", "pointer", "util", "root", "set", "area", "et", "origin", "order", "pos", "tile", "align", "file", "location", "start", "loc", "addr", "seek", "base", "position", "offer", "mt", "off", "trace", "index", "point", "Offset", "crop"], "size": ["sn", "type", "dim", "length", "space", "news", "large", "address", "len", "term", "fee", "unit", "iz", "storage", "body", "sha", "mem", "gz", "height", "empty", "spec", "count", "amount", "ize", "s", "small", "mode", "bytes", "sym", "message", "sec", "total", "shape", "capacity", "since", "year", "scale", "SIZE", "time", "Size", "description", "sum", "sq", "name"]}}
{"project": "FFmpeg", "commit_id": "42361bdf51c4495ca71a532efbb7769475c1822c", "target": 0, "func": "int ff_MPV_frame_start(MpegEncContext *s, AVCodecContext *avctx)\n\n{\n\n    int i, ret;\n\n    Picture *pic;\n\n    s->mb_skipped = 0;\n\n\n\n    if (!ff_thread_can_start_frame(avctx)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Attempt to start a frame outside SETUP state\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* mark & release old frames */\n\n    if (s->pict_type != AV_PICTURE_TYPE_B && s->last_picture_ptr &&\n\n        s->last_picture_ptr != s->next_picture_ptr &&\n\n        s->last_picture_ptr->f.buf[0]) {\n\n        ff_mpeg_unref_picture(s, s->last_picture_ptr);\n\n    }\n\n\n\n    /* release forgotten pictures */\n\n    /* if (mpeg124/h263) */\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n\n        if (&s->picture[i] != s->last_picture_ptr &&\n\n            &s->picture[i] != s->next_picture_ptr &&\n\n            s->picture[i].reference && !s->picture[i].needs_realloc) {\n\n            if (!(avctx->active_thread_type & FF_THREAD_FRAME))\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"releasing zombie picture\\n\");\n\n            ff_mpeg_unref_picture(s, &s->picture[i]);\n\n        }\n\n    }\n\n\n\n    ff_mpeg_unref_picture(s, &s->current_picture);\n\n\n\n    release_unused_pictures(s);\n\n\n\n    if (s->current_picture_ptr &&\n\n        s->current_picture_ptr->f.buf[0] == NULL) {\n\n        // we already have a unused image\n\n        // (maybe it was set before reading the header)\n\n        pic = s->current_picture_ptr;\n\n    } else {\n\n        i   = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        pic = &s->picture[i];\n\n    }\n\n\n\n    pic->reference = 0;\n\n    if (!s->droppable) {\n\n        if (s->pict_type != AV_PICTURE_TYPE_B)\n\n            pic->reference = 3;\n\n    }\n\n\n\n    pic->f.coded_picture_number = s->coded_picture_number++;\n\n\n\n    if (ff_alloc_picture(s, pic, 0) < 0)\n\n        return -1;\n\n\n\n    s->current_picture_ptr = pic;\n\n    // FIXME use only the vars from current_pic\n\n    s->current_picture_ptr->f.top_field_first = s->top_field_first;\n\n    if (s->codec_id == AV_CODEC_ID_MPEG1VIDEO ||\n\n        s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        if (s->picture_structure != PICT_FRAME)\n\n            s->current_picture_ptr->f.top_field_first =\n\n                (s->picture_structure == PICT_TOP_FIELD) == s->first_field;\n\n    }\n\n    s->current_picture_ptr->f.interlaced_frame = !s->progressive_frame &&\n\n                                                 !s->progressive_sequence;\n\n    s->current_picture_ptr->field_picture      =  s->picture_structure != PICT_FRAME;\n\n\n\n    s->current_picture_ptr->f.pict_type = s->pict_type;\n\n    // if (s->flags && CODEC_FLAG_QSCALE)\n\n    //     s->current_picture_ptr->quality = s->new_picture_ptr->quality;\n\n    s->current_picture_ptr->f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n\n\n    if ((ret = ff_mpeg_ref_picture(s, &s->current_picture,\n\n                                   s->current_picture_ptr)) < 0)\n\n        return ret;\n\n\n\n    if (s->pict_type != AV_PICTURE_TYPE_B) {\n\n        s->last_picture_ptr = s->next_picture_ptr;\n\n        if (!s->droppable)\n\n            s->next_picture_ptr = s->current_picture_ptr;\n\n    }\n\n    av_dlog(s->avctx, \"L%p N%p C%p L%p N%p C%p type:%d drop:%d\\n\",\n\n            s->last_picture_ptr, s->next_picture_ptr,s->current_picture_ptr,\n\n            s->last_picture_ptr    ? s->last_picture_ptr->f.data[0]    : NULL,\n\n            s->next_picture_ptr    ? s->next_picture_ptr->f.data[0]    : NULL,\n\n            s->current_picture_ptr ? s->current_picture_ptr->f.data[0] : NULL,\n\n            s->pict_type, s->droppable);\n\n\n\n    if ((s->last_picture_ptr == NULL ||\n\n         s->last_picture_ptr->f.buf[0] == NULL) &&\n\n        (s->pict_type != AV_PICTURE_TYPE_I ||\n\n         s->picture_structure != PICT_FRAME)) {\n\n        int h_chroma_shift, v_chroma_shift;\n\n        av_pix_fmt_get_chroma_sub_sample(s->avctx->pix_fmt,\n\n                                         &h_chroma_shift, &v_chroma_shift);\n\n        if (s->pict_type == AV_PICTURE_TYPE_B && s->next_picture_ptr && s->next_picture_ptr->f.buf[0])\n\n            av_log(avctx, AV_LOG_DEBUG,\n\n                   \"allocating dummy last picture for B frame\\n\");\n\n        else if (s->pict_type != AV_PICTURE_TYPE_I)\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"warning: first frame is no keyframe\\n\");\n\n        else if (s->picture_structure != PICT_FRAME)\n\n            av_log(avctx, AV_LOG_DEBUG,\n\n                   \"allocate dummy last picture for field based first keyframe\\n\");\n\n\n\n        /* Allocate a dummy frame */\n\n        i = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        s->last_picture_ptr = &s->picture[i];\n\n\n\n        s->last_picture_ptr->reference   = 3;\n\n        s->last_picture_ptr->f.key_frame = 0;\n\n        s->last_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        if (ff_alloc_picture(s, s->last_picture_ptr, 0) < 0) {\n\n            s->last_picture_ptr = NULL;\n\n            return -1;\n\n        }\n\n\n\n        memset(s->last_picture_ptr->f.data[0], 0x80,\n\n               avctx->height * s->last_picture_ptr->f.linesize[0]);\n\n        memset(s->last_picture_ptr->f.data[1], 0x80,\n\n               (avctx->height >> v_chroma_shift) *\n\n               s->last_picture_ptr->f.linesize[1]);\n\n        memset(s->last_picture_ptr->f.data[2], 0x80,\n\n               (avctx->height >> v_chroma_shift) *\n\n               s->last_picture_ptr->f.linesize[2]);\n\n\n\n        if(s->codec_id == AV_CODEC_ID_FLV1 || s->codec_id == AV_CODEC_ID_H263){\n\n            for(i=0; i<avctx->height; i++)\n\n            memset(s->last_picture_ptr->f.data[0] + s->last_picture_ptr->f.linesize[0]*i, 16, avctx->width);\n\n        }\n\n\n\n        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 0);\n\n        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 1);\n\n    }\n\n    if ((s->next_picture_ptr == NULL ||\n\n         s->next_picture_ptr->f.buf[0] == NULL) &&\n\n        s->pict_type == AV_PICTURE_TYPE_B) {\n\n        /* Allocate a dummy frame */\n\n        i = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        s->next_picture_ptr = &s->picture[i];\n\n\n\n        s->next_picture_ptr->reference   = 3;\n\n        s->next_picture_ptr->f.key_frame = 0;\n\n        s->next_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        if (ff_alloc_picture(s, s->next_picture_ptr, 0) < 0) {\n\n            s->next_picture_ptr = NULL;\n\n            return -1;\n\n        }\n\n        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 0);\n\n        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 1);\n\n    }\n\n\n\n#if 0 // BUFREF-FIXME\n\n    memset(s->last_picture.f.data, 0, sizeof(s->last_picture.f.data));\n\n    memset(s->next_picture.f.data, 0, sizeof(s->next_picture.f.data));\n\n#endif\n\n    if (s->last_picture_ptr) {\n\n        ff_mpeg_unref_picture(s, &s->last_picture);\n\n        if (s->last_picture_ptr->f.buf[0] &&\n\n            (ret = ff_mpeg_ref_picture(s, &s->last_picture,\n\n                                       s->last_picture_ptr)) < 0)\n\n            return ret;\n\n    }\n\n    if (s->next_picture_ptr) {\n\n        ff_mpeg_unref_picture(s, &s->next_picture);\n\n        if (s->next_picture_ptr->f.buf[0] &&\n\n            (ret = ff_mpeg_ref_picture(s, &s->next_picture,\n\n                                       s->next_picture_ptr)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    av_assert0(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr &&\n\n                                                 s->last_picture_ptr->f.buf[0]));\n\n\n\n    if (s->picture_structure!= PICT_FRAME) {\n\n        int i;\n\n        for (i = 0; i < 4; i++) {\n\n            if (s->picture_structure == PICT_BOTTOM_FIELD) {\n\n                s->current_picture.f.data[i] +=\n\n                    s->current_picture.f.linesize[i];\n\n            }\n\n            s->current_picture.f.linesize[i] *= 2;\n\n            s->last_picture.f.linesize[i]    *= 2;\n\n            s->next_picture.f.linesize[i]    *= 2;\n\n        }\n\n    }\n\n\n\n    s->err_recognition = avctx->err_recognition;\n\n\n\n    /* set dequantizer, we can't do it during init as\n\n     * it might change for mpeg4 and we can't do it in the header\n\n     * decode as init is not called for mpeg4 there yet */\n\n    if (s->mpeg_quant || s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg2_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg2_inter;\n\n    } else if (s->out_format == FMT_H263 || s->out_format == FMT_H261) {\n\n        s->dct_unquantize_intra = s->dct_unquantize_h263_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_h263_inter;\n\n    } else {\n\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg1_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg1_inter;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24881, "substitutes": {"s": ["eps", "comm", "sports", "c", "sam", "comments", "tests", "times", "p", "changes", "aws", "bits", "vs", "S", "ns", "ies", "y", "states", "z", "less", "h", "v", "sq", "views", "series", "sb", "args", "os", "rs", "us", "scl", "spec", "n", "state", "cs", "ags", "j", "als", "ats", "ts", "ims", "styles", "its", "parts", "m", "sys", "ms", "as", "ins", "ses", "scripts", "has", "bis", "sts", "sw", "asts", "bs", "a", "is", "b", "ps", "stats", "gs", "q", "ls", "f", "ports", "news", "se", "fs", "w", "bes", "aunts", "ds", "hs", "details", "g", "set", "an", "js", "ss", "settings", "https", "qs", "es", "sp", "sv", "sg", "self", "t", "events"], "avctx": ["avewcs", "ajcb", "wavcaps", "avecontext", "avco", "averctx", "aveco", "averwcs", "devcaps", "averjac", "ajtx", "ajctx", "avobj", "wavtx", "avctl", "aveobj", "devctx", "avercontext", "ovctl", " avco", "avercb", "ajco", "ovctx", "devjac", "wavctx", "avjac", "avecss", "ovobj", "averobj", "avconn", "avectx", "avercaps", "avwcs", " avjac", "averco", " avconn", "ajcontext", "avtx", " avtx", "averctl", "devcontext", "avectl", "ovcss", "wavjac", "avecb", "avejac", "ajwcs", "avpkg", " avpkg", " avwcs", "avercss", "averconn", "avcss", "ajpkg", "wavpkg", "avcb", "aveconn", " avcontext", "avcontext", "wavcontext", "avcaps"], "i": ["ui", " j", "o", "d", "c", "ini", "id", "in", "r", "I", "p", " bi", "ori", "sim", "ai", "li", "info", "ip", "ish", "y", "ij", "ci", "iu", "si", "v", "ei", "ji", "ki", "\u0438", " ni", " ii", "n", "io", "j", "chain", "ind", "cgi", "uri", "m", "jj", "point", "qi", "ix", "batch", "x", "multi", "ami", "k", "ri", "phi", "di", "oi", "zi", "go", "mi", "ii", "a", "is", "l", "bi", "xi", "im", "f", "it", "ic", "err", "pi", "ex", "fi", "g", "me", "gi", "list", "to", "span", "ti", "json", "e", "by", "u", "index", "cli", "init"], "ret": ["alt", "bool", "out", "ll", "RET", "re", "status", "gt", "result", "ri", "r", "reply", "rel", "set", "rem", "et", "print", "rt", "nt", "txt", "val", "mt", "Ret", "il", "jp", "res"], "pic": ["f", "ping", "ic", "photo", "peg", "Pic", "capt", "Pict", "pb", "cam", "feature", " Pic", "mp", "pc", "piece", "pi", "pp", "pr", "jpg", "pen", "g", "spec", "pin", "p", "camera", "sc", "img", "pick", "ig", "policy", "magic", "phys", "pl", "phot", "image", "ics", "kit", "doc", "iac", "script", "py", "ac", "spr", "feat", "ps", "png", "pa", "pict", "sp", "pres", "fp", "gc", " picture", "lp", "ptr", "jp", "Picture", "proc", "picture"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void co_write_request(void *opaque)\n\n{\n\n    BDRVSheepdogState *s = opaque;\n\n\n\n    qemu_coroutine_enter(s->co_send, NULL);\n\n}\n", "idx": 24895, "substitutes": {"opaque": ["OPaque", "oplaques", "oplosit", "OPaques", "opute", "paque", "pulus", "ogaque", "opque", "OPute", "popaque", "poposit", "oplque", "opulus", "oplulus", "popque", "ogaques", "ogque", "oposit", "pute", "oplaque", "oplute", "ogosit", "OPulus", "paques", "opaques", "popaques"], "s": ["o", "sis", "os", "se", "fs", "rs", "c", "ds", "hs", "r", "n", "p", "state", "sts", "set", "S", "bs", "ss", "a", "is", "ats", "b", "ts", "ns", "ps", "acs", "z", "es", "gs", "e", "less", "sv", "q", "ls", "t", "m", "sq", "Ws", "ess"]}}
{"project": "FFmpeg", "commit_id": "41abc9da50ba7a7b68bbbf6622475ce7a3c72e3f", "target": 1, "func": "static int decode_frame_ilbm(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    IffContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;\n\n    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;\n\n    const uint8_t *buf_end = buf+buf_size;\n\n    int y, plane, res;\n\n\n\n    if ((res = extract_header(avctx, avpkt)) < 0)\n\n        return res;\n\n\n\n    if (s->init) {\n\n        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n            return res;\n\n        }\n\n    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return res;\n\n    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {\n\n        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)\n\n            return res;\n\n    }\n\n    s->init = 1;\n\n\n\n    if (avctx->codec_tag == MKTAG('A','C','B','M')) {\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n\n            for (plane = 0; plane < s->bpp; plane++) {\n\n                for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n\n                    uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n\n            for(y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n                memset(s->ham_buf, 0, s->planesize * 8);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    const uint8_t * start = buf + (plane * avctx->height + y) * s->planesize;\n\n                    if (start >= buf_end)\n\n                        break;\n\n                    decodeplane8(s->ham_buf, start, FFMIN(s->planesize, buf_end - start), plane);\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('D','E','E','P')) {\n\n        int raw_width = avctx->width * (av_get_bits_per_pixel(&av_pix_fmt_descriptors[avctx->pix_fmt]) >> 3);\n\n        int x;\n\n        for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n\n            uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n            memcpy(row, buf, FFMIN(raw_width, buf_end - buf));\n\n            buf += raw_width;\n\n            if (avctx->pix_fmt == PIX_FMT_BGR32) {\n\n                for(x = 0; x < avctx->width; x++)\n\n                    row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4);\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('I','L','B','M')) { // interleaved\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(row, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(s->ham_buf, 0, s->planesize * 8);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane8(s->ham_buf, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else { // PIX_FMT_BGR32\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(row, 0, avctx->width << 2);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n                memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));\n\n                buf += avctx->width + (avctx->width % 2); // padding if odd\n\n            }\n\n        } else if (s->ham) { // IFF-PBM: HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));\n\n                buf += avctx->width + (avctx->width & 1); // padding if odd\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else {\n\n            av_log_ask_for_sample(avctx, \"unsupported bpp\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n    return buf_size;\n\n}\n", "idx": 24896, "substitutes": {"avctx": ["afctl", "avtmp", " avctl", "averctx", "aftx", "ajkt", "svtx", "wavtx", "wavcm", "avhandle", " avgc", "ajcfg", "ajcontext", "verctx", "abhandle", "averctl", "avectl", "wavjac", "avcfg", "avpkg", "averpkg", "ajgc", "avcmp", "aftmp", "wavcontext", "avercf", "avertmp", "avecmd", "avcf", "ajtx", "wavcf", "wavctl", "afkl", "avercontext", "vertx", " avhandle", "verctl", " avcmd", "AVctl", " avjac", " avconn", "abkt", "avekt", " avpkg", "averconn", "avgc", "afpkg", " avcontext", "averwindow", "avercmp", "avecontext", "svcontext", "ajctx", "avecmp", "svwindow", "AVctx", "avecm", "avkt", "avectx", "afctx", "abtx", "avtx", "AVkt", "abctx", "ajkl", "svcmd", " avcfg", "avcmd", "avwindow", "avecfg", "avetx", "aveconn", "avepkg", "avcontext", "afgc", "svctx", "abcontext", "avkl", "averjac", " avcmp", "avctl", "avercfg", "ajjac", "ajcm", "ajctl", " avkt", "avjac", "wavctx", "avertx", "avconn", "averkl", "avergc", "abcmd", "wavtmp", " avwindow", " avtx", "avegc", "AVcontext", "AVtx", "avejac", "abpkg", "ajpkg", "wavhandle", "avehandle", "wavpkg", "vergc", "ajcf", "avcm"], "data": ["rew", "ata", "d", "map", "done", "id", "buffer", "r", "p", "extra", "bits", "frame", "raw", "size", "history", "base", "head", "table", "padding", "action", "code", "value", "error", "header", "mode", "next", "chain", "da", "dat", "window", "bin", "offset", "m", "device", "batch", "length", "pad", "part", "def", "body", "read", "bytes", "area", "dr", "text", "version", "DATA", "no", "mu", "f", "block", "ad", "stream", "options", "len", "debug", "zero", "flags", "group", "empty", "list", "cache", "rel", "message", "sequence", "Data", "query", "t", "content", "end", "name"], "data_size": [" data_length", "data_length", " data_mode", "data_Size", "data_mode", " data_Size"], "avpkt": ["aveopacket", "avwpkt", "awpht", "avpartacket", " avcpacket", "avppt", "averpidct", "avpodacket", "awcpacket", "iverpet", "avopkt", "wavpct", "avpartkt", "iverpwd", "avpacket", "avtpdu", "avPht", "avcpct", "avwpkg", "awwpkt", "avpidpt", "avepdt", "avcpkat", "avpct", "avPacket", "avpkg", "averpkg", "avpkat", "avpkgwd", "averpkt", "avpaacket", "avpdt", "avopdt", " avcpct", "awpwk", " avpct", "avpcet", "avpwd", "awwpacket", "avcpkt", "avpidct", "avpkght", "averpartkg", "iverpkgacket", "avpet", "wavopdu", "wavpacket", "avpaddt", "avpodkat", "avwpacket", "averpacket", "avopkg", "wavopacket", "avwpwk", " avcpkt", "avpidwt", "awpct", "averpartgt", "avtpacket", "avcwd", "avpadkg", "avpodkt", "avPkt", "avpartgt", "awcpht", "avpartkg", "averpartacket", "averpct", " avpkat", "awwpwk", "avpkgacket", "avPpt", "avtpkt", "avpodct", "avcpdu", " avpacket", "avpidkt", "avpwt", "awcpct", "avpadacket", "averpidkt", "avckt", "iverpkt", "avpht", "averppt", "avpkgkt", "avpidwk", "avpadkt", "avpkget", "averpidwt", "avpadt", "avpidacket", "avwppt", "wavopkt", "avopkat", "avcpacket", "awpkt", "avopdu", " avcpkat", "avwpgt", "iverpkgkt", "avcacket", "avpakg", "avpgt", "averpgt", "avwpct", "avopct", "avepkg", "avcpht", "awpacket", "avwpwt", "awcpkt", "wavpdu", "aveopkg", "aveopdt", "avpckt", "wavpkt", "avpawk", "avepacket", "iverpkget", "avpcacket", "avtpct", "avpwk", "averpwt", "avopacket", "aveopkt", "avPct", "avpcwd", "iverpacket", "avpkgct", "avcet", "avpagt", "averpartkt", "iverpkgwd", "averpidpt", "avPwt", "avpakt", "avpdu", "wavopct", "avepkt"], "s": ["sys", "ms", "i", "sb", "ports", "ops", "args", "obj", "ins", "gets", "os", "comm", "ants", "fs", "sports", "v", "rs", "c", "sam", "ses", "ds", "hs", "sl", "results", "details", "comments", "g", "times", "p", "changes", "bis", "cs", "sts", "ares", "sw", "aws", "vs", "S", "als", "js", "bs", "ss", "settings", "a", "is", "ats", "b", "ts", "ns", "ps", "ims", "sm", "tes", "stats", "qs", "es", "its", "gs", "less", "sv", "parts", "h", "t", "ls", "events", "sq", "m", "ess", "conf"], "buf": ["block", "bed", "batch", "length", "cam", "xy", "ref", "queue", "uf", "br", "len", "bl", "mb", "box", "map", "planes", "bf", "buffer", "mem", "true", "seq", "cmd", "pool", "img", "msg", "cb", "bytes", "bar", "pos", "vec", "b", "loc", "addr", "txt", "window", "alloc", "lim", "limit", "rb", "cap", "Buffer", "buff", "ptr", "tr", "xff", "tmp", "offset", "h", "max", "cv"], "buf_end": ["buf_last", "buff_size", "bin_ended", "buf_len", "bin_end", "buf_ended", "buf_size", "buff_end", "buff_len", "buff_start", "bin_last", "buf_start"], "y": ["my", "ch", "i", "gy", "xy", "dy", "hot", "ay", "fy", "col", "sat", "yi", "icy", "ty", "yy", "sky", "uy", "iy", "yer", "ady", "height", "axy", "n", "p", "ny", "ery", "yl", "ye", "j", "cy", "vy", "yr", "b", "py", "ind", "tiny", "ip", "l", "z", "bot", "e", "ey", "ya", "ys", "oy", "t", "h", "Y", "ym", "ot", "sy", "asy", "m", "hey"], "plane": [" planes", "board", "dim", "place", "pan", "cone", "pipe", "animate", "pose", "zone", "slice", "lane", "component", "normal", "planes", "flow", "wise", "profile", "gate", "fl", "late", "pen", "pei", "panel", "ve", "obe", "mode", "axis", "que", "clip", "plot", "pe", "cube", "cut", "depth", "frame", "layout", "face", "plan", "priority", "way", "line", "straight", "ane", "ker", "pa", "port", "bird", "heading", "flat", "mask", "flag", "half", "plate", "mate", "loop", "stroke"], "res": ["ras", "ms", "out", "red", "rest", "err", "reset", "pas", "ref", "re", "hash", "success", "status", "fs", "sol", "rs", "ber", "def", "fr", "result", "rev", "reg", "mem", "pr", "results", "details", "RES", "r", "gr", "resp", "msg", "rel", "proc", "rek", "rem", "resh", " Res", "rep", "js", "raw", "req", "rez", "ps", "dr", "expr", "rss", "des", "vals", "alloc", "progress", "val", "Res", "ret", "resolution", "der", "pres", "ress", "init"], "row": ["block", "field", "edge", "col", "cell", "ow", "entry", "rc", "ry", "sel", "roll", "ver", "record", "rect", "node", "rows", "pos", "raw", "line", "port", "key", "px", "num", "val", "du", "tr", "ro"]}}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "udp_listen(Slirp *slirp, u_int32_t haddr, u_int hport, u_int32_t laddr,\n\n           u_int lport, int flags)\n\n{\n\n\tstruct sockaddr_in addr;\n\n\tstruct socket *so;\n\n\tsocklen_t addrlen = sizeof(struct sockaddr_in), opt = 1;\n\n\n\n\tso = socreate(slirp);\n\n\tif (!so) {\n\n\t    return NULL;\n\n\t}\n\n\tso->s = socket(AF_INET,SOCK_DGRAM,0);\n\n\tso->so_expire = curtime + SO_EXPIRE;\n\n\tinsque(so, &slirp->udb);\n\n\n\n\taddr.sin_family = AF_INET;\n\n\taddr.sin_addr.s_addr = haddr;\n\n\taddr.sin_port = hport;\n\n\n\n\tif (bind(so->s,(struct sockaddr *)&addr, addrlen) < 0) {\n\n\t\tudp_detach(so);\n\n\t\treturn NULL;\n\n\t}\n\n\tsetsockopt(so->s,SOL_SOCKET,SO_REUSEADDR,(char *)&opt,sizeof(int));\n\n\n\n\tgetsockname(so->s,(struct sockaddr *)&addr,&addrlen);\n\n\tso->so_fport = addr.sin_port;\n\n\tif (addr.sin_addr.s_addr == 0 ||\n\n\t    addr.sin_addr.s_addr == loopback_addr.s_addr) {\n\n\t   so->so_faddr = slirp->vhost_addr;\n\n\t} else {\n\n\t   so->so_faddr = addr.sin_addr;\n\n\t}\n\n\tso->so_lport = lport;\n\n\tso->so_laddr.s_addr = laddr;\n\n\tif (flags != SS_FACCEPTONCE)\n\n\t   so->so_expire = 0;\n\n\n\n\tso->so_state &= SS_PERSISTENT_MASK;\n\n\tso->so_state |= SS_ISFCONNECTED | flags;\n\n\n\n\treturn so;\n\n}\n", "idx": 24897, "substitutes": {"addr": [" wr", "alt", "address", "host", "att", "dh", "map", "id", " ip", "er", "mem", " amp", "var", "r", "ar", "arr", "et", "pos", "rt", "attr", "ip", "expr", "loc", " ptr", " kb", "mt", "ptr", "pkg", "ress", " req", "oad", "tx", "args", "adr", "br", "rs", "adv", "gt", "at", "rr", "ace", "add", "msg", "sort", "inv", " address", "tag", " sr", "data", " sa", "ag", "ash", "ha", "offset", " url", " addresses", "ix", " add", "arp", "nl", "act", "coord", " err", "art", "a", "dr", "url", "Address", "tmp", "oa", "elt", "ad", "news", "err", "ref", "aff", "hash", " ha", " dh", "md", " conn", "cmd", "ack", "ord", "usr", " a", "order", "nz", "np", "align", "ac", "dd", " r", "sp", "arg", "name"], "so": ["inho", "o", "po", "ko", " o", "sam", "rh", "stro", "or", "sync", "stone", "soc", "s", "ism", " su", "mo", "sim", "sie", "oh", "isco", "size", "info", "sm", "ico", "si", "sy", "sn", "sa", "obj", "store", "ski", "os", "syn", "sty", " s", "sl", "sc", "cs", "te", "th", "co", "py", " sa", "So", "fo", "ho", "SO", " So", "lo", "box", "dll", "ry", " soc", "sel", "esh", "ao", "sw", "go", "mi", "bs", "ne", "must", "st", "osi", "sf", "iso", "no", "sum", "ro", "ssl", "opt", "dylib", "se", "ow", "bo", "sky", "proxy", "cho", "resource", "sh", "set", "oso", "js", "osp", "since", "ss", "yes", "sing", "pro", "problem", "sp", "su"]}}
{"project": "qemu", "commit_id": "b4548fcc0314f5e118ed45b5774e9cd99f9a97d3", "target": 1, "func": "static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    IRQMP      *irqmp = opaque;\n\n    IRQMPState *state;\n\n\n\n    assert(irqmp != NULL);\n\n    state = irqmp->state;\n\n    assert(state != NULL);\n\n\n\n    addr &= 0xff;\n\n\n\n    /* global registers */\n\n    switch (addr) {\n\n    case LEVEL_OFFSET:\n\n        return state->level;\n\n\n\n    case PENDING_OFFSET:\n\n        return state->pending;\n\n\n\n    case FORCE0_OFFSET:\n\n        /* This register is an \"alias\" for the force register of CPU 0 */\n\n        return state->force[0];\n\n\n\n    case CLEAR_OFFSET:\n\n    case MP_STATUS_OFFSET:\n\n        /* Always read as 0 */\n\n        return 0;\n\n\n\n    case BROADCAST_OFFSET:\n\n        return state->broadcast;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* mask registers */\n\n    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {\n\n        int cpu = (addr - MASK_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->mask[cpu];\n\n    }\n\n\n\n    /* force registers */\n\n    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {\n\n        int cpu = (addr - FORCE_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->force[cpu];\n\n    }\n\n\n\n    /* extended (not supported) */\n\n    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {\n\n        int cpu = (addr - EXTENDED_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->extended[cpu];\n\n    }\n\n\n\n    trace_grlib_irqmp_unknown_register(\"read\", addr);\n\n    return 0;\n\n}\n", "idx": 24899, "substitutes": {"opaque": ["operaque", "operalloc", "paco", "palloc", "iopaques", "operacity", "paque", "opque", "opacity", " opaques", "opaques", "pacity", "iopacity", "operane", "iopalloc", "pane", "iopaque", " opaco", "iopane", "opane", " opque", "opalloc", "opaco", "iopque", "pque", "paques", "iopaco"], "addr": ["hd", "cmp", "alt", "hop", "address", "host", "dh", "att", "map", "id", "mem", "gate", "gz", "ar", "arr", "ser", "pos", "any", "rt", "attr", "ip", "expr", "src", "loc", "mt", "ptr", "pkg", "oad", "tx", "obj", "adr", "conn", "code", "gt", "at", "rr", "db", "ace", "add", "msg", "inv", "au", " address", "tag", "eth", "data", "ag", "ash", "handle", "ha", "iter", "offset", "ix", "hw", "sys", "arp", "pad", "kt", "sha", "act", "now", "alias", "coord", "phys", "amp", "art", "dr", "alloc", "url", "Address", "adj", "off", "elt", "oa", "grad", "mac", "ad", "err", "ref", "aff", "hash", "md", "cmd", "ack", "deg", "ord", "cb", "set", "usr", "order", "aro", "align", "shift", "port", "aux", "hl", "t", "index", "name"], "irqmp": ["irqtms", "irqutmp", "mirqtms", "irqtmp", "irqqmy", "irqqcmp", "irqqMP", "ireqmp", "ireqMP", "irquMP", "irqcmp", "irqtmt", "ierqlmy", "irqlmp", "irqqms", "ierqmy", "irqumt", "mirqtmp", "irqlmt", "irdqtmp", "irdqmp", "irqms", "irqumy", "ierqlmp", "irqmt", "irsqms", "ireqqmp", "mirqmt", "mirqtmt", "mirqms", "irsqmp", "ireqqMP", "ierqlmt", "irqMP", "irqmy", "irqqmp", "ierqmt", "ierqlcmp", "irqlmy", "irqucmp", "ierqmp", "irqqmt", "ireqtmp", "irdqMP", "mirqmp", "ierqcmp", "irqump", "ireqqtmp", "irqlcmp", "irsqmt", "irqqtmp"], "state": ["see", "status", "unit", "cell", "map", "agent", "output", "mem", "buffer", "count", "new", "monitor", "runner", "size", "info", "states", "progress", "base", "draw", "scope", "dict", "parent", "space", "action", "zone", "store", "item", "conn", "code", "config", "value", "error", "spec", "n", "close", "tag", "next", "data", "handle", "point", "type", "job", "length", "comment", "memory", "oo", "area", "STATE", "State", "rule", "ne", "print", "is", "l", "test", "public", "stats", "text", "style", "stat", "all", "no", "manager", "block", "it", "out", "client", "null", "al", "hash", "component", "event", "local", "params", "row", "resource", "list", "cache", "oe", "order", "message", "instance", "image", "start", "port", "post", "trust", "self", "t", "init", "name"]}}
{"project": "qemu", "commit_id": "ea8d82a1ed72634f089ed1bccccd9c84cc1ab855", "target": 1, "func": "void qemu_sglist_destroy(QEMUSGList *qsg)\n\n{\n\n    g_free(qsg->sg);\n\n\n}", "idx": 24902, "substitutes": {"qsg": ["Qsg", " qgs", "qgs", "qug", "Qg", "Qgs", " qg", "qugs", "zgs", " qerg", "qg", "zsg", "querg", "qusg", "qerg", "zsb", "qusb", "zerg", "qsb", " qsb", "Qsb"]}}
{"project": "qemu", "commit_id": "27915efb974999dd256a6c432a17432d9d84e606", "target": 1, "func": "static int virtio_9p_device_init(VirtIODevice *vdev)\n\n{\n\n    V9fsState *s = VIRTIO_9P(vdev);\n\n    int i, len;\n\n    struct stat stat;\n\n    FsDriverEntry *fse;\n\n    V9fsPath path;\n\n\n\n    virtio_init(VIRTIO_DEVICE(s), \"virtio-9p\", VIRTIO_ID_9P,\n\n                sizeof(struct virtio_9p_config) + MAX_TAG_LEN);\n\n\n\n    /* initialize pdu allocator */\n\n    QLIST_INIT(&s->free_list);\n\n    QLIST_INIT(&s->active_list);\n\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n\n        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);\n\n    }\n\n\n\n    s->vq = virtio_add_queue(vdev, MAX_REQ, handle_9p_output);\n\n\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n\n\n    if (!fse) {\n\n        /* We don't have a fsdev identified by fsdev_id */\n\n        fprintf(stderr, \"Virtio-9p device couldn't find fsdev with the \"\n\n                \"id = %s\\n\",\n\n                s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    if (!s->fsconf.tag) {\n\n        /* we haven't specified a mount_tag */\n\n        fprintf(stderr, \"fsdev with id %s needs mount_tag arguments\\n\",\n\n                s->fsconf.fsdev_id);\n\n        goto out;\n\n    }\n\n\n\n    s->ctx.export_flags = fse->export_flags;\n\n    s->ctx.fs_root = g_strdup(fse->path);\n\n    s->ctx.exops.get_st_gen = NULL;\n\n    len = strlen(s->fsconf.tag);\n\n    if (len > MAX_TAG_LEN - 1) {\n\n        fprintf(stderr, \"mount tag '%s' (%d bytes) is longer than \"\n\n                \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n    s->config_size = sizeof(struct virtio_9p_config) + len;\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        fprintf(stderr, \"Virtio-9p Failed to initialize fs-driver with id:%s\"\n\n                \" and export path:%s\\n\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n    if (v9fs_init_worker_threads() < 0) {\n\n        fprintf(stderr, \"worker thread initialization failed\\n\");\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    v9fs_path_init(&path);\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        fprintf(stderr,\n\n                \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        fprintf(stderr, \"share path %s does not exist\\n\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        fprintf(stderr, \"share path %s is not a directory\\n\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    return 0;\n\nout:\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n    virtio_cleanup(vdev);\n\n    v9fs_path_free(&path);\n\n\n\n    return -1;\n\n\n\n}\n", "idx": 24921, "substitutes": {"vdev": [" vconn", "tdev", "tserv", " vserv", "vgo", "vmserver", "vdevice", " vgo", "hhost", "hev", " vev", "vserver", "Vconn", "tdevice", "gdev", "Vdevice", " vhost", "vconn", " vserver", "ghost", "wconn", "wgo", "Vdev", "wdevice", "vmserv", "vev", "wdev", "gdevice", "vmdev", "hdev", "vhost", "vserv", " vdevice", "tserver", "Vgo", "gev", "vmdevice", "hdevice"], "s": ["sis", "comm", "c", "sam", "sync", "tests", "pers", "mods", "p", "changes", "aws", "vs", "S", "ns", "ies", "y", "states", "less", "h", "v", "sq", "these", "space", "sb", "args", "obj", "store", "search", "os", "rs", "sl", "spec", "n", "cs", "services", "j", "als", "so", "ats", "ts", "ims", "des", "its", "m", "my", "ms", "as", "ins", "simple", "gets", "ses", "results", "bis", "sts", "sw", "bs", "is", "b", "ps", "locks", "stats", "gs", "serv", "ls", "ports", "fs", "sol", "w", "ds", "hs", "params", "details", "set", "js", "ss", "settings", "qs", "south", "es", "sv", "self", "source", "t", "conf"], "i": ["ji", "it", "x", "batch", "ui", " j", "multi", " di", " multi", "ami", "pi", " ni", " ii", "ini", "index", "ri", "in", "me", "gi", "I", "n", "p", "phi", " bi", "di", "zi", "sim", "j", " e", " v", "ai", " li", "mi", "li", "ii", "hi", "ti", "ind", " ti", " pi", "bi", " mi", "y", "ip", "ci", "mc", "cgi", " si", " I", " m", "si", " wi", "im", "xi", "m", "q", "MI", "cli", "qi", "ix"], "len": ["von", "length", "ld", "cmp", "gen", "err", "nn", "min", "ll", "L", "ln", " length", "offset", "nl", "mem", "ren", "fin", "fl", "gz", "seq", "lt", " Len", "n", "el", "lf", "fn", "Len", "compl", "bytes", "lon", "pos", "enc", "pl", "li", "vec", " le", "init", "l", "data", "size", "nt", "lan", "fun", "dl", "loc", "LI", "fil", "mn", "lim", "addr", "coll", "str", "val", "en", "il", "ni", "lp", "kl", "ls", "elt", "end", "conv", "t", "lc", "format", "all"], "stat": ["sys", "it", " Stat", "dir", "STAT", "fw", "conn", "status", "std", "d", "config", "disk", "fin", "find", "get", "sync", "r", "ctl", "p", "Stat", "cache", "state", "util", "file", "scan", "l", "attr", "info", "desc", "rss", "stats", "fd", "num", "net", "Stats", "gc", "fat", "h", "init", "name"], "fse": ["cfse", "hpe", "ffpse", "bfpse", "mse", "afpe", "fbe", "rfse", "ftsex", "Fene", "wpe", "fSE", "npse", "fene", "cfSE", " fce", "ftpse", "rsex", "rse", "fcSE", "fcpe", "nte", "fcse", "nse", "ffse", "hte", "dpse", "gse", "rfpse", " fene", "ftse", "hSE", "ffpe", "Fce", "Fse", "rfpe", "fsex", "gte", " fSE", "dpe", "mpse", "dse", "bfse", "afSE", " fpe", "npe", "rfsche", "fcte", "afse", "fsche", "vbe", "ffsche", "wSE", "wse", " fbe", "fce", "bfsche", "dte", "gpe", "hse", "mpe", "gSE", "vene", "mte", "bfpe", "fpe", "fpse", "cfsex", "vse", "ftSE", "rpse", "fte", "cfpse", "Fbe", "rSE", "vce"], "path": ["ath", "context", "parent", "prop", "full", "stream", "o", "dir", "home", "ref", "po", "os", "host", "from", "config", "w", "id", "target", "ext", "cmd", "p", "route", "pid", "prefix", "proc", "root", "dest", "next", "PATH", "doc", "depth", "file", "loc", "template", "key", "history", "handle", "pkg", "pattern", "tmp", "m", "mount", "name", "pt", "Path"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int v9fs_request(V9fsProxy *proxy, int type,\n\n                        void *response, const char *fmt, ...)\n\n{\n\n    dev_t rdev;\n\n    va_list ap;\n\n    int size = 0;\n\n    int retval = 0;\n\n    uint64_t offset;\n\n    ProxyHeader header = { 0, 0};\n\n    struct timespec spec[2];\n\n    int flags, mode, uid, gid;\n\n    V9fsString *name, *value;\n\n    V9fsString *path, *oldpath;\n\n    struct iovec *iovec = NULL, *reply = NULL;\n\n\n\n    qemu_mutex_lock(&proxy->mutex);\n\n\n\n    if (proxy->sockfd == -1) {\n\n        retval = -EIO;\n\n        goto err_out;\n\n    }\n\n    iovec = &proxy->out_iovec;\n\n    reply = &proxy->in_iovec;\n\n    va_start(ap, fmt);\n\n    switch (type) {\n\n    case T_OPEN:\n\n        path = va_arg(ap, V9fsString *);\n\n        flags = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, flags);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_OPEN;\n\n        }\n\n        break;\n\n    case T_CREATE:\n\n        path = va_arg(ap, V9fsString *);\n\n        flags = va_arg(ap, int);\n\n        mode = va_arg(ap, int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sdddd\", path,\n\n                                    flags, mode, uid, gid);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CREATE;\n\n        }\n\n        break;\n\n    case T_MKNOD:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        rdev = va_arg(ap, long int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddsdq\",\n\n                                    uid, gid, path, mode, rdev);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_MKNOD;\n\n        }\n\n        break;\n\n    case T_MKDIR:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddsd\",\n\n                                    uid, gid, path, mode);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_MKDIR;\n\n        }\n\n        break;\n\n    case T_SYMLINK:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddss\",\n\n                                    uid, gid, oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_SYMLINK;\n\n        }\n\n        break;\n\n    case T_LINK:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\",\n\n                                    oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LINK;\n\n        }\n\n        break;\n\n    case T_LSTAT:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LSTAT;\n\n        }\n\n        break;\n\n    case T_READLINK:\n\n        path = va_arg(ap, V9fsString *);\n\n        size = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, size);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_READLINK;\n\n        }\n\n        break;\n\n    case T_STATFS:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_STATFS;\n\n        }\n\n        break;\n\n    case T_CHMOD:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, mode);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CHMOD;\n\n        }\n\n        break;\n\n    case T_CHOWN:\n\n        path = va_arg(ap, V9fsString *);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sdd\", path, uid, gid);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CHOWN;\n\n        }\n\n        break;\n\n    case T_TRUNCATE:\n\n        path = va_arg(ap, V9fsString *);\n\n        offset = va_arg(ap, uint64_t);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sq\", path, offset);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_TRUNCATE;\n\n        }\n\n        break;\n\n    case T_UTIME:\n\n        path = va_arg(ap, V9fsString *);\n\n        spec[0].tv_sec = va_arg(ap, long);\n\n        spec[0].tv_nsec = va_arg(ap, long);\n\n        spec[1].tv_sec = va_arg(ap, long);\n\n        spec[1].tv_nsec = va_arg(ap, long);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sqqqq\", path,\n\n                                    spec[0].tv_sec, spec[1].tv_nsec,\n\n                                    spec[1].tv_sec, spec[1].tv_nsec);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_UTIME;\n\n        }\n\n        break;\n\n    case T_RENAME:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\", oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_RENAME;\n\n        }\n\n        break;\n\n    case T_REMOVE:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_REMOVE;\n\n        }\n\n        break;\n\n    case T_LGETXATTR:\n\n        size = va_arg(ap, int);\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ,\n\n                                    \"dss\", size, path, name);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LGETXATTR;\n\n        }\n\n        break;\n\n    case T_LLISTXATTR:\n\n        size = va_arg(ap, int);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ds\", size, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LLISTXATTR;\n\n        }\n\n        break;\n\n    case T_LSETXATTR:\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        value = va_arg(ap, V9fsString *);\n\n        size = va_arg(ap, int);\n\n        flags = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sssdd\",\n\n                                    path, name, value, size, flags);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LSETXATTR;\n\n        }\n\n        break;\n\n    case T_LREMOVEXATTR:\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\", path, name);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LREMOVEXATTR;\n\n        }\n\n        break;\n\n    case T_GETVERSION:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_GETVERSION;\n\n        }\n\n        break;\n\n    default:\n\n        error_report(\"Invalid type %d\", type);\n\n        retval = -EINVAL;\n\n        break;\n\n    }\n\n    va_end(ap);\n\n\n\n    if (retval < 0) {\n\n        goto err_out;\n\n    }\n\n\n\n    /* marshal the header details */\n\n    proxy_marshal(iovec, 0, \"dd\", header.type, header.size);\n\n    header.size += PROXY_HDR_SZ;\n\n\n\n    retval = qemu_write_full(proxy->sockfd, iovec->iov_base, header.size);\n\n    if (retval != header.size) {\n\n        goto close_error;\n\n    }\n\n\n\n    switch (type) {\n\n    case T_OPEN:\n\n    case T_CREATE:\n\n        /*\n\n         * A file descriptor is returned as response for\n\n         * T_OPEN,T_CREATE on success\n\n         */\n\n        if (v9fs_receivefd(proxy->sockfd, &retval) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_MKNOD:\n\n    case T_MKDIR:\n\n    case T_SYMLINK:\n\n    case T_LINK:\n\n    case T_CHMOD:\n\n    case T_CHOWN:\n\n    case T_RENAME:\n\n    case T_TRUNCATE:\n\n    case T_UTIME:\n\n    case T_REMOVE:\n\n    case T_LSETXATTR:\n\n    case T_LREMOVEXATTR:\n\n        if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_LSTAT:\n\n    case T_READLINK:\n\n    case T_STATFS:\n\n    case T_GETVERSION:\n\n        if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_LGETXATTR:\n\n    case T_LLISTXATTR:\n\n        if (!size) {\n\n            if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n\n                goto close_error;\n\n            }\n\n        } else {\n\n            if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n\n                goto close_error;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\nerr_out:\n\n    qemu_mutex_unlock(&proxy->mutex);\n\n    return retval;\n\n\n\nclose_error:\n\n    close(proxy->sockfd);\n\n    proxy->sockfd = -1;\n\n    qemu_mutex_unlock(&proxy->mutex);\n\n    return -EIO;\n\n}\n", "idx": 24933, "substitutes": {"proxy": ["ping", "handler", "device", "engine", "ock", "x", "client", "server", "force", "xy", "reference", "address", "po", "service", "pc", "echo", "profile", "core", "phy", "master", "target", "reverse", "sync", "linux", "p", "cache", "alias", "remote", "apache", "node", "slave", "roxy", "gp", "view", "pe", "module", "mi", "show", "controller", "friend", "project", "pse", "prime", "port", "native", "link", "handle", "version", "super", "http", "shadow", "source", "timeout", "manager", "index", "Proxy", "socket", "ion"], "type": ["range", "class", "ping", "pre", "action", "length", "typ", "al", "code", "op", "status", "like", "id", "change", "error", "event", "ty", "title", "ype", " Type", "family", "what", "count", "state", "rel", "set", "call", "policy", "function", "pe", "message", "ity", " typ", "test", "types", "size", "start", "issue", "color", "Type", "link", "relation", "TYPE", "tp", "style", "kind", "time", "scope", "trace", "t", "format", "index", "lock", "role"], "response": ["block", "action", "x", "o", "ref", "ata", "success", "status", "result", "output", "buffer", "header", "resp", "message", "image", "next", "data", "page", "Response", "json", "version", "timeout", "v", "answer", "res"], "fmt": ["ffformat", "ifMT", "fMT", "iffm", "tfms", "frfm", "tfformat", "ffMT", "tfmt", "fformat", "frMT", "tfMT", "fms", "ifformat", "frformat", "ffms", "frmt", "ifmt", "ffm", " fms", " fMT", "ffmt", " ffm", " fformat"], "rdev": ["ldev", "xdef", "xdev", "rwev", "redov", "indev", "indiv", "rdov", "rwdev", "lddev", "xdov", "reddev", "xdiv", "ldep", "rwef", "redev", "redef", "rdiv", "rdef", "redep", "rediv", "indef", "rddev", "indov", "rdep", "rwep", "ldef"], "ap": ["apper", "app", " AP", "att", "vp", "array", "map", "pp", "sam", "asc", " ip", "um", "apa", " heap", "ar", "p", "ip", "pa", " ptr", "snap", "aps", " mp", " app", "ait", " tap", " map", "at", "aph", "el", "apache", "au", " address", "ach", "AP", " sa", " sap", "ag", "hap", " cap", "ash", "bp", "gap", "tap", " ac", "af", "as", "arp", "ape", "op", "mp", " p", " soap", "ipp", "act", "acl", " api", " sp", "amp", "ast", " rep", " cp", "a", " op", "im", "ic", "ep", "pre", "al", "api", "ma", "fa", "apt", "ext", "ed", "cache", "ax", "np", "av", "html", "ac", "wp", "sp", "cap", "ab", "aj"], "offset": ["length", "ref", "address", "ata", "len", "op", "fee", "error", "oot", "count", "set", "extra", "origin", "pos", "data", "attr", "start", "shift", "info", "load", "addr", "seek", "alloc", "base", "flag", "rot", "off", "Offset"], "spec": ["f", "pack", "space", "match", " specification", "len", "ie", "entry", "def", "map", "ice", "ica", "row", "list", "ify", "cs", "form", "spe", "desc", "Spec", "info", "ip", "ification", "cap", "ptr", "str"], "flags": ["alf", "ports", "ops", "bugs", "args", "options", "fields", "status", "ants", "def", "id", "members", "tags", "mates", "orts", "amps", "comments", "packages", "Flags", "details", "links", "friendly", "cmd", "times", "acts", "grades", "missions", "points", "keys", "s", "lines", "ags", "acl", "ints", "bits", "faces", "policy", "params", "settings", "levels", "types", "ns", "weight", "ims", "ts", "weights", "vals", "locks", "stats", "files", "fd", "mask", "flag", "actions", "posts", "FLAG", "features", "kind", "properties", "atts", "heads", "names", "doms"], "mode": ["device", "mac", "ms", "cmp", "perm", "direction", "MODE", "tm", "command", "dir", "nom", "code", "status", "normal", "language", "id", "role", "mem", "dev", "mm", "mk", "owner", "md", "cmd", "me", "metadata", "member", "mit", "mod", "module", "pe", "settings", "size", "version", "pro", "ase", "mask", "Mode", "kind", "mt", "time", "source", "room", "flag", "driver", "format", "mid", "lock", "m"], "uid": ["uc", "ui", "eu", "cu", " UID", "ug", "us", "id", "cpu", "rid", "um", "owner", "aid", "mk", "ua", "UID", "mail", "pid", "fork", "util", "usr", "mo", "upid", "nu", "oid", "unique", "vid", "sid", "lan", "username", "mn", "fd", "user", "pu", "stud", "uu", "mask", "ud", "u", "du", "su", "uv", "mid", "mu"], "gid": ["sgmid", "geids", "goid", "gId", "gip", "pgid", "groupno", "geid", "gno", "groupend", "ggoid", " goid", "gz", "gcid", "gpid", "pgno", " gmid", "sgip", "guend", "guID", " gno", "gcno", "ggid", " gId", " gpid", "ggids", " gID", "gez", "groupid", "sgId", "ggz", "groupID", " gend", "guid", "gcID", " gz", " gip", "vgip", "vgmid", "vgId", "pgID", "gmid", "gcpid", "pgpid", "gID", "vgid", "gend", "gids", "guno", "sgid", "geoid", " gids"], "name": ["action", "field", "normal", "id", "member", "comment", "metadata", "alias", "mod", "order", "data", "size", "NAME", "key", "ame", "version", "meta", "val", "time", "Name", "label", "format", "names"], "value": ["context", "attribute", "action", "field", "values", "address", "status", "unit", "output", "password", "comment", "Value", "VALUE", "prefix", "binary", "message", "data", "weight", "key", "text", "version", "val", "description", "content", "format", "property", "v"], "path": ["ath", "tree", "prop", "action", "parent", "full", "out", "join", "dir", "point", "ref", "address", "host", "entry", "map", "binding", "id", "mem", "target", "cmd", "p", "alias", "route", "filter", "prefix", "pointer", "pid", "root", "transform", "policy", "form", "PATH", "raw", "chain", "file", "inner", "location", "reason", "template", "physical", "url", "key", "text", "txt", "near", "partial", "package", "trace", "source", "pattern", "pkg", "pat", "stat", "format", "filename", "method", "pt", "Path"], "oldpath": ["fullPath", "fullvalue", "oldpattern", "newvalue", "rawpath", "newPath", "newpath", "newpattern", "rawpattern", "rawvalue", "oldPath", "fullpattern", "oldvalue", "fullpath", "rawPath"], "iovec": ["iuecin", " iovecos", "ilovecos", "liovecr", "iucec", "iovc", "iokect", "iovecp", " iovcam", " iorepc", "iovepc", "istrucs", "iorecs", "Iovec", "iovecan", "Iokect", "Iokecs", "ioveec", "liovec", "iovcon", "ioecin", " iorecp", "iorecr", "iovcs", "iovecin", " iorecos", "ioverecs", "iorecp", "iocycon", "iorect", "iorepc", "iimecan", "iokeec", " iovecp", " iovc", "Iokec", "iancecam", " iovcan", "iimec", "iucecs", "ilovecor", " iovcon", "iokecs", "iorec", " ionsecin", "ilovecs", "iovecs", "iokec", "iuefc", "liovecs", " iorecs", "iovefc", "ionsec", "iucecr", " iovecam", " iorecor", "ioreec", "liucecs", "iorecos", "iuec", " iovecan", "iancecan", "iovct", "iovecon", " iovepc", " iovefc", "Iokeec", " ionsec", "istrucp", "iorecor", "ilovec", "iodecs", " ionsecon", "Iovect", "istrupc", "iovcam", " iovecs", "iovecam", "iancecon", "ioecr", "liucecin", "iodec", "iucecin", "iovecr", "Ioveec", "iovecor", "ionsecon", "ioverecor", "iocyc", "iocyfc", " iovecin", "ionsefc", " iovecon", "iorecin", "iuecon", "ionsecin", "iovecos", "iovect", "iimecam", " iovecor", "iovcan", "liucec", "iancec", "iocycin", "liucecr", "iimecon", "iodecp", "ioverecos", "istruc", "iodepc", "ioverec", " ionsefc", "ioec", "liovecin", " iorec", "ioecs", "Iovecs"], "reply": ["match", "out", "force", "err", "rm", "queue", "ror", "address", "status", "echo", "result", "body", "error", "buffer", "rr", "rob", "request", "report", "sync", "repl", "fire", "metadata", "pin", "route", "state", "resp", "message", "Reply", "frame", "mi", "info", "ply", "relation", "ret", "ptr", "callback", "answer", "ro"]}}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n\n\n    r->req.status = status;\n\n    scsi_disk_set_sense(s, sense_code);\n\n}\n", "idx": 24968, "substitutes": {"r": ["it", "i", "x", "o", "br", "re", "d", "rs", "w", "rd", "ur", "rc", "er", "rh", "rr", "or", "repl", "g", "rx", "sr", "ar", "p", "rec", "gr", "rar", "ra", "vr", "rt", "req", "dr", "mr", "R", "cr", "e", "rb", "rw", "q", "rn", "rg", "v", "m", "res"], "status": ["note", "type", "Status", "active", "uses", "power", "search", "score", "success", "code", "sol", "valid", "index", "result", "error", "dev", "good", "spec", "close", "mode", "state", "compl", "msg", "set", "atus", "policy", "confirmed", "sequence", "sense", "speed", "size", "notice", "info", "stats", "progress", "version", "strength", "current", "check", "kind", "health", "iso", "source", "description", "stat", "content", "diff", "si", "str", "name", "summary"], "sense_code": ["sense__codes", "sense_codes", " sense_codes", "sense__cod", " sense_cod", "sense_message", "senseablecode", "Sense_codes", "Sense_message", "sense_Code", "sense__message", "senseablemessage", "senseableCode", "sense__code", "Sense_code", "senseablecodes", "Sense_Code", " sense_message", "sense_cod"], "s": ["sys", "sb", "se", "fs", "sol", "rs", "c", "sam", "ds", "sl", "n", "p", "sts", "set", "iss", "S", "js", "ss", "is", "b", "l", "ns", "ts", "ps", "z", "south", "es", "sp", "gs", "sv", "e", "sg", "self", "ls", "t", "m", "v", "str", "sq"]}}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static inline void sdhci_blkgap_write(SDHCIState *s, uint8_t value)\n\n{\n\n    if ((value & SDHC_STOP_AT_GAP_REQ) && (s->blkgap & SDHC_STOP_AT_GAP_REQ)) {\n\n        return;\n\n    }\n\n    s->blkgap = value & SDHC_STOP_AT_GAP_REQ;\n\n\n\n    if ((value & SDHC_CONTINUE_REQ) && s->stopped_state &&\n\n            (s->blkgap & SDHC_STOP_AT_GAP_REQ) == 0) {\n\n        if (s->stopped_state == sdhc_gap_read) {\n\n            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_READ;\n\n            SDHCI_GET_CLASS(s)->read_block_from_card(s);\n\n        } else {\n\n            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_WRITE;\n\n            SDHCI_GET_CLASS(s)->write_block_to_card(s);\n\n        }\n\n        s->stopped_state = sdhc_not_stopped;\n\n    } else if (!s->stopped_state && (value & SDHC_STOP_AT_GAP_REQ)) {\n\n        if (s->prnsts & SDHC_DOING_READ) {\n\n            s->stopped_state = sdhc_gap_read;\n\n        } else if (s->prnsts & SDHC_DOING_WRITE) {\n\n            s->stopped_state = sdhc_gap_write;\n\n        }\n\n    }\n\n}\n", "idx": 25005, "substitutes": {"s": ["ops", "eps", "reads", "comm", "d", "sports", "comments", "sync", "tests", "mods", "p", "changes", "ares", "ains", "aws", "bits", "vs", "S", "xs", "ns", "ies", "z", "less", "actions", "h", "checks", "orders", "sq", "sb", "os", "rs", "us", "sl", "n", "cs", "services", "als", "ats", "ts", "ims", "acs", "its", "parts", "m", "sys", "ms", "as", "ins", "ries", "gets", "ants", "ties", "ses", "bis", "sts", "sw", "bs", "is", "ps", "locks", "stats", "st", "gs", "ls", "ssl", "f", "ears", "ports", "fs", "w", "ex", "bes", "ds", "hs", "details", "set", "an", "ches", "js", "ss", "uns", "qs", "terms", "es", "sv", "t", "events", "conf"], "value": ["block", "option", "type", "attribute", "length", "expression", "field", "currently", "values", "byte", "see", "hash", "code", "unit", "update", "widget", "valid", "index", "word", "request", "buffer", "now", "get", "Value", "VALUE", "we", "input", "message", "total", "sequence", "image", "rule", "process", "python", "example", "data", "VAL", "document", "key", "json", "version", "position", "val", "current", "number", "ue", "description", "variable", "property", "hello", "v", "format"]}}
{"project": "qemu", "commit_id": "568c73a4783cd981e9aa6de4f15dcda7829643ad", "target": 0, "func": "static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,\n\n                              Error **errp)\n\n{\n\n    int val;\n\n\n\n    backend->vc = g_new0(ChardevVC, 1);\n\n\n\n    val = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_width = true;\n\n        backend->vc->width = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_height = true;\n\n        backend->vc->height = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"cols\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_cols = true;\n\n        backend->vc->cols = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"rows\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_rows = true;\n\n        backend->vc->rows = val;\n\n    }\n\n}\n", "idx": 25024, "substitutes": {"opts": ["payTs", "payrets", "opTs", "optargs", "ops", " options", "options", " copts", "opercs", "protions", " copcs", " opargs", "OPargs", "oprets", "payts", "opss", "opte", "opTS", "opscs", "optfs", "operters", "operts", " opfs", "opsts", "oports", " ops", "operorts", "OPTS", "optTs", "OPs", "optrets", "prote", "optters", " copte", "opsTS", "opters", "optTS", "OPts", " opTs", "procs", "opcs", "optcs", "payfs", "optorts", "opsargs", "opsters", "prots", "opfs", " opcs", "opsorts", "opargs", " coptions", "optts", " opte", " oprets"], "backend": ["bookbegin", "bootad", "blacktenance", "BACKended", "frontended", "frontend", "BACKener", "backload", "bootende", "Backende", "backended", "BACKface", "bookrend", "Backbegin", "blackend", "backener", "backface", " backenter", "Backended", "retender", "Backad", "backpad", "bootender", "backende", "Backend", "frontin", "frontender", "BACKad", " backin", " backbegin", "frontenter", "backtenance", "BACKload", "BACKenter", "frontrend", " backad", "Backender", " backface", " backended", "backenter", "booktenance", "bootend", "bookender", " backende", " backload", "backad", "bookenter", "Backload", " backender", "backender", "backbegin", "retend", "BACKpad", "bookended", "bookend", "BACKender", "fronttenance", "retin", "retended", "frontener", "Backface", "backin", "blackender", "frontpad", "BACKrend", "blackended", "BACKend", " backpad", " backener", "backrend", "BACKbegin"], "errp": ["rrr", " errr", "rrp", " errpp", "erpp", "rrpp", "err", "erp", "errr", "errpp"], "val": [" el", "alt", "unit", "valid", "crit", "dev", "mem", "var", " interval", "arr", "vol", "mod", "ctx", " aval", "lev", "pl", "li", "grain", "il", "v", "pt", "fol", "pol", "bool", "cal", "tx", "obj", "value", "pr", "sl", "func", "ver", "el", "let", "msg", "fail", "als", " value", "Val", "lib", "eval", "slot", "lex", "vt", "x", " var", "update", "def", "sel", " eval", "gold", " inval", "compl", "pret", " v", "vec", "test", "gb", "serv", "elt", "stat", "vet", "grad", "it", "prop", "lit", "al", "aval", "ref", "len", "tl", " valid", "bo", "cho", "repl", "pal", "cert", "resp", "util", "V", "req", "AL", "VAL", "vals", "txt", "ival", "ret", "proc", "conf"]}}
{"project": "FFmpeg", "commit_id": "39e0accb7a934bfe3d42324b016dd8790790746d", "target": 1, "func": "static unsigned int find_best(struct vf_instance *vf){\n\n  int is_format_okay = vf->next->query_format(vf->next, IMGFMT_YV12);\n\n  if ((is_format_okay & VFCAP_CSP_SUPPORTED_BY_HW) || (is_format_okay & VFCAP_CSP_SUPPORTED))\n\n    return IMGFMT_YV12;\n\n  else\n\n    return 0;\n\n}\n", "idx": 25066, "substitutes": {"vf": ["vfc", "avfc", "Vf", "evcf", "avbf", "avcf", "ff", " vcf", "avrf", "vxf", "fcf", "vfi", "Vcf", " vfc", "ffi", "evfi", " vbf", "VF", "vF", "vbf", "wcf", " vxf", " vrf", "vrf", "Vrf", "avf", "vcf", " vfi", " vF", "wfc", "fxf", "evf", "evxf", "wbf", "avF", "wf"]}}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void helper_idivl_EAX_T0(void)\n\n{\n\n    int den, q, r;\n\n    int64_t num;\n\n    \n\n    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n    den = T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n#ifdef BUGGY_GCC_DIV64\n\n    r = idiv32(&q, num, den);\n\n#else\n\n    q = (num / den);\n\n    r = (num % den);\n\n#endif\n\n    EAX = (uint32_t)q;\n\n    EDX = (uint32_t)r;\n\n}\n", "idx": 25075, "substitutes": {"den": ["range", "dim", "ov", "na", "perm", "ki", "gen", "nn", " Den", "DEN", "nom", "len", "norm", "d", "none", "vert", "normal", "def", " DEN", "dev", "han", "mon", "pen", "nov", "fen", "n", "non", "dan", "ten", "deg", "dt", "ord", "mat", "di", "ran", "nu", "pos", "ne", "co", "bill", "da", "ind", "don", "size", "dat", "nor", "des", "z", "window", "dn", "mn", "Den", "dem", "con", "bin", "du", "en", "number", "zen", "un", "der", "t", "sum", "ven", "ho"], "q": ["f", "ch", "Q", "quit", "x", "i", "quant", "dq", "question", "qt", "w", "c", "k", "requ", "g", "qu", "n", "p", " Q", "qq", "j", "iq", "qa", "qual", "req", "l", "b", "query", "y", "qs", "z", "ql", "u", "eq", "ue", "h", "t", "m", "v", "sq", "qi", "aq"], "r": ["f", "i", "rm", "rl", "re", "d", "rs", "nr", "rd", "ur", "c", "rc", "er", "rr", "or", "rat", "rx", "g", "sr", "rate", "ar", "n", "p", "rar", "vr", "rf", "rt", "b", "l", "dr", "mr", "R", "cr", "e", "rb", "u", "h", "t", "rn", "rg", "v", "m", "ro"], "num": ["block", "NUM", "dim", "na", "typ", "quant", "out", "cal", "nm", "nom", "nam", "mult", "valid", "id", "index", " msg", "um", "mon", "Num", "g", "n", "ver", "cum", "new", "msg", "rem", " numer", "nu", "coord", "uni", " np", "ta", "np", "total", "bn", "data", "nt", "mn", "con", "net", " tid", "number", "en", "un", "tr", "t", "no", "m", " nu", "final", "sum", "name"]}}
{"project": "FFmpeg", "commit_id": "5d5118f81bd51b9c33500616b3c637123e8e4691", "target": 1, "func": "static inline void idct_col(int16_t *blk, const uint8_t *quant)\n\n{\n\n    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;\n\n    int t10, t11, t12, t13;\n\n    int s0, s1, s2, s3, s4, s5, s6, s7;\n\n\n\n    s0 = (int) blk[0 * 8] * quant[0 * 8];\n\n    s1 = (int) blk[1 * 8] * quant[1 * 8];\n\n    s2 = (int) blk[2 * 8] * quant[2 * 8];\n\n    s3 = (int) blk[3 * 8] * quant[3 * 8];\n\n    s4 = (int) blk[4 * 8] * quant[4 * 8];\n\n    s5 = (int) blk[5 * 8] * quant[5 * 8];\n\n    s6 = (int) blk[6 * 8] * quant[6 * 8];\n\n    s7 = (int) blk[7 * 8] * quant[7 * 8];\n\n\n\n    t0  =  (s3 * 19266 + s5 * 12873) >> 15;\n\n    t1  =  (s5 * 19266 - s3 * 12873) >> 15;\n\n    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;\n\n    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;\n\n    t4  = t0 * 2 + t2;\n\n    t5  = t1 * 2 + t3;\n\n    t6  = t2 - t3;\n\n    t7  = t3 * 2 + t6;\n\n    t8  = (t6 * 11585) >> 14;\n\n    t9  = (t7 * 11585) >> 14;\n\n    tA  = (s2 * 8867 - s6 * 21407) >> 14;\n\n    tB  = (s6 * 8867 + s2 * 21407) >> 14;\n\n    tC  = (s0 >> 1) - (s4 >> 1);\n\n    tD  = (s4 >> 1) * 2 + tC;\n\n    tE  = tC - (tA >> 1);\n\n    tF  = tD - (tB >> 1);\n\n    t10 = tF - t5;\n\n    t11 = tE - t8;\n\n    t12 = tE + (tA >> 1) * 2 - t9;\n\n    t13 = tF + (tB >> 1) * 2 - t4;\n\n\n\n    blk[0 * 8] = t13 + t4 * 2;\n\n    blk[1 * 8] = t12 + t9 * 2;\n\n    blk[2 * 8] = t11 + t8 * 2;\n\n    blk[3 * 8] = t10 + t5 * 2;\n\n    blk[4 * 8] = t10;\n\n    blk[5 * 8] = t11;\n\n    blk[6 * 8] = t12;\n\n    blk[7 * 8] = t13;\n\n}\n", "idx": 25081, "substitutes": {"blk": ["lbck", "bellkar", " blkk", "abelck", "blkb", "abelork", "milck", "bleork", "bledk", " blkan", " bldk", "BLks", "berkb", "stkb", "lbk", "abelikk", "blkw", " blsk", "blekk", "bellk", " blork", "blkan", "BLq", "Blq", "Blk", "berkw", "blkt", "milk", " blikk", "stk", "bk", "blekar", " blkar", "belldk", "bsk", " blkw", "blsk", "bellck", "blks", "bldk", " blkt", "blek", " blck", "bellkid", "lbker", "abelk", "milkt", "bellkt", "blck", "blekid", "abelsk", "bleck", "blikk", "bdk", "blkid", "BLck", "lbkid", "BLk", "blkar", "lbork", "abelker", "blq", "berk", "blekt", "lbkk", "stck", "bck", "Blks", "abeldk", "Blck", "berck", " blks", "bellikk", "abelkan", " blker", "blker", "milork", " blkb", "lbdk", "stkw", " blq", "blkk", "bellkk", "bellkan", "blork"], "quant": ["fx", "sys", "available", "ch", "cur", "patch", "cmp", "client", "percent", "quart", "forced", "liquid", " pint", "mult", "qt", "mill", "valid", "config", "integer", " quantity", "atomic", " Quant", "requ", "tick", "qu", "good", "pal", "rec", "gr", "qq", "vol", "util", "mot", "par", "nice", "quick", "qual", "raw", "private", "req", " qu", "quote", "complex", " quot", " q", "quad", "imp", "frac", "draw", "serial", "check", "Quant", "pkg", "q", "stock", "specific"], "t0": ["T5", "ot00", "let06", "tc1", "ts0", "t00", " t00", "p0", "T1", "t06", "T2", "T0", "let00", "ts6", "tc2", "v1", "ts2", "p3", "v0", "let0", "ot0", "tc0", "v5", " t06", "p1", "T3", "tc6", "v2", "ts1", "p2", "ot06"], "t1": ["ot3", "tt2", "tt6", "Tone", "T1", "elt6", "elt2", "TA", "T6", "ta3", "tone", "T2", "ttA", "ta2", "taone", "ta1", "at4", "tt1", "ot2", "at6", " tone", "elt1", "ot1", "ot4", "eltA", "T3", "ot6", "at1", "at2"], "t2": ["v4", "l6", "T02", "int2", "tt2", "tt6", "p0", "e6", "inttwo", "T1", "int3", "tt02", "e2", " t02", "T6", "t02", "l4", "tstwo", "T2", "ts4", "l0", "e0", "tt1", "p4", "l2", "v1", "v0", "int4", "e4", "Ttwo", "ts3", "T3", "ttwo", "v2", "ts2", "T4", "p2", "p1"], "t3": ["ts5", "T5", "te03", "ttThree", "ts0", "ot8", "tt3", "ot3", "ttthree", "tt03", "TThree", "T1", "pt1", "tThree", "T6", "t03", "Tthree", "T2", "pt6", "T0", "te3", "ot2", "tthree", "T03", "ts2", "ot1", "T8", "tethree", "ts3", "T3", "pt2", "teThree", "ts1", "pt3"], "t4": [" t04", "t428", " t428", "intFour", " tFour", "otFour", "int428", "at4", "ot2", "tFour", "tu4", "int4", "ot04", "ot4", "at04", "tuFour", "atFour", "tu428", "t04", "at2"], "t5": ["tree05", "tt4", "at12", "tree12", "te1", "tt6", "t15", "tree6", "tree1", "tt5", "te15", "t05", "tree5", "tt15", "tt1", "tree4", "at6", "tt05", "te4", "te5", "at5", "tree15", "at05", "tt12"], "t6": [" t60", "p12", "p6", "ot3", "tt6", "ot12", "T6", "ot9", " tSc", "t76", "ta2", "let60", " t76", "ta6", "ot2", "p4", "ts6", "tt60", "letSc", "tSc", "ta9", "p3", "ts8", "ot4", "T8", "ta7", "ot7", "ts7", "ts3", "tt76", "t60", "ttSc", "T3", "s8", "let76", "T7", "ot6", "let6"], "t7": ["rseven", "unt7", "t17", "r6", "taseven", "tt705", "unt17", "tt625", " tseven", "otseven", "t625", "tseven", "te77", "tt7", "int705", "r7", "t77", "int79", "unt79", "te625", "t705", "ta77", "int17", "ta625", "ttseven", "int7", "ot1", "t79", "unt705", "te7", "r1", "ta7", "tt17", "tt79", "ot7", "teseven", "tt77", "ot6"], "t8": ["unt7", "te8", "type8", "TE", "ot8", "ot11", "unt11", "typeE", "type6", "type08", "T6", "at08", "at6", "T08", "ot08", "T8", "te7", "at8", "atE", "t08", "ot7", "unt8", "te08", "unt08", "te11"], "t9": ["dt8", "TNine", "let9", "let15", "tt8", "tN", "dt9", "t15", "dtNine", "tNine", "T9", "T15", "tt15", " tNine", "letNine", "T8", "dtN", "tt9", "let8", "TN", " tN", "ttNine"], "tA": ["te8", " tAn", "wtAn", "tS", "wtC", "tempB", " tS", "otG", "otAn", "tempA", "teS", "otC", " tG", "teB", "teA", "tG", "wtA", "wtG", "otA", "tempS", "tAn", "temp8"], "tB": ["otIB", "tBR", "treeB", " t42", "otG", "treeG", " tIB", "ot42", "tt42", "ttIB", "ttBar", "otBB", "tBB", "otB", " tBar", "tIB", "treeBB", "t42", "tBar", " tG", "ttB", "otBar", "tG", "treeBR", " tBB", "otBR", " tBR"], "tC": ["c3", "TR", " tDC", "trR", "taA", "taG", "tDC", "tsD", "testD", "ta4", "otG", "tsDC", "trD", "testR", "tCA", "tsR", "taC", "TCA", "tr3", "TD", "trC", "testDC", "TC", "trE", " tR", "otC", "cE", " tG", "ot4", "tsC", "tG", "trCA", "otA", " tCA", "cC", "testC", "cA", "tR", "trA"], "tD": [" tDD", "ttI", "ttDD", "tDB", " t21", "wtR", " tDB", "wtF", "tt21", "tree21", "tmD", "tmF", "wtD", "tmR", "tI", " tR", "tDD", "treeDD", "wtDB", "treeD", " tI", "t21", "treeI", "tR", "ttD", "tmDB"], "tE": ["te8", "wt8", "teO", "te6", "wtO", "treeG", "tree6", "treeF", "teF", "tO", "treeE", "teE", " tG", "teA", "teG", "tG", " tO", "wtE", "wtA"], "tF": ["teF", "tJ", "teG", "tG", "teJ", "itZ", "ptF", "teZ", "itJ", "itF", "ptJ", "tZ", "itG", "ptG", "ptZ"], "t10": [" t60", "let60", "let09", "t60", "i60", "t09", "i10", "i8", "let8", "let10", " t09", "i09"], "t11": ["ts31", "ts21", "tt21", "ts11", " t16", "tt11", " t21", "t21", "tt16", "tt31", "t31", "ts16", "t16", " t31"], "t12": ["t14", "tc11", "tt11", "tc16", "tc14", " t14", "tt14", "tt12", "tt16", "tc12", " t16", "t16"], "t13": ["at16", "ot17", "at17", "t57", "t17", "at57", "tu13", "at13", "ot13", "tu57", "tu17", "ot57", "ot16", "tu16", "t16"], "s0": ["g3", "ts5", "sl3", "ts0", "sl5", "g0", "S4", "ts4", "sl0", "i0", " s00", "g5", "g00", "i4", "S0", "i5", "i2", "s00", "S2", "ts3", "sl00", "ts2", "S3"], "s1": ["spec1", "spec81", "sp1", "set4", "set3", "s9", "v9", "specB", " s9", "sp3", "v3", " sB", "sB", "set1", "sp4", "spec4", "ts4", "ts6", "sp6", " s81", "sp5", "sp9", "set6", "v1", "js4", "v5", "ts3", "jsB", "js1", "ts1", "js81", "s81"], "s2": ["v4", "set4", "us5", "set3", "b4", "us1", "S1", "set5", "S4", "h6", "h1", "h5", "us6", "S6", "h2", "v1", "v6", "b5", "us2", "set2", "v5", "b2", "S2", "v2", "S5", "b3"], "s3": ["v4", "jsiii", "SThree", "js5", "set4", "set3", "sv3", "svThree", "sv4", "v3", "Siii", "S1", "set5", "S4", "S03", "siii", "tiii", "js3", "sThree", " sThree", "S6", " s03", "s03", "set6", "v1", "v6", "v5", "js1", "v2", "S5", "S3", "sv03"], "s4": ["v4", "s9", "sv4", "space04", " s9", "sv04", "sFour", "svFour", "space6", "serv4", "S1", " sFour", "S4", "serv8", "space12", "s04", "ts4", "ts6", "spaceFour", "is6", "S6", "serv6", "is12", "ts2", "serv12", "v1", "v6", " s04", "space9", "space4", "is8", "sv9", "S2", "space8", "s8", "v2", "ts1", "s12", "is4"], "s5": ["p6", " s8", "sp1", "set4", "sp7", "s9", " s9", "sp3", "sp4", "spec5", "m6", "S1", "set5", "spec4", "m5", "p5", "m4", "spec9", "is9", "sp6", "is5", "sp5", "p4", "set6", "p7", "m7", "is8", "S7", "spec8", "spec6", "s8", "S5", "S3", "set9", "is4"], "s6": ["S8", " s8", "p6", "sv8", "solE", "s9", "sv6", " s9", "sol9", "p2", "g8", "setE", "set8", "sol8", "p4", "g5", "S6", "set6", "g2", "sol6", "g6", "S7", "S9", "sE", "sv9", "sv7", "s8", "set9", "p1"], "s7": [" s8", "sv8", "js13", " s13", "s9", "sv6", " s9", "svseven", "sv13", " sseven", "m6", "sseven", "s13", "js8", "m5", "h6", "h1", "h5", "S13", "S6", "m7", "js7", "m3", "jsseven", "h7", "S7", "S9", "sv9", "sv7", "s8", "m1"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int fourxm_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 12)\n\n        return 0;\n\n\n\n    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||\n\n        (AV_RL32(&p->buf[8]) != _4XMV_TAG))\n\n        return 0;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n", "idx": 25091, "substitutes": {"p": ["f", "pm", "pre", "ad", "pb", "o", "op", "pc", "d", "mp", "att", "w", "part", "app", "c", "pp", "r", "cp", "n", "proc", "par", "j", "ctx", "ap", "art", "up", "rep", "np", "a", "b", "ps", "post", "pa", "wp", "z", "progress", "pro", "tp", "bp", "pod", "sp", "fp", "self", "pkg", "P", "h", "t", "q", "pat", "m", "v", "jp", "pt"]}}
{"project": "FFmpeg", "commit_id": "2c9be3882a03823413945bd9e2d9af33e6e322d5", "target": 0, "func": "static void jpeg_table_header(AVCodecContext *avctx, PutBitContext *p,\n\n                              ScanTable *intra_scantable,\n\n                              uint16_t luma_intra_matrix[64],\n\n                              uint16_t chroma_intra_matrix[64],\n\n                              int hsample[3])\n\n{\n\n    int i, j, size;\n\n    uint8_t *ptr;\n\n    MpegEncContext *s = avctx->priv_data;\n\n\n\n    if (avctx->codec_id != AV_CODEC_ID_LJPEG) {\n\n        int matrix_count = 1 + !!memcmp(luma_intra_matrix,\n\n                                        chroma_intra_matrix,\n\n                                        sizeof(luma_intra_matrix[0]) * 64);\n\n    if (s->force_duplicated_matrix)\n\n        matrix_count = 2;\n\n    /* quant matrixes */\n\n    put_marker(p, DQT);\n\n    put_bits(p, 16, 2 + matrix_count * (1 + 64));\n\n    put_bits(p, 4, 0); /* 8 bit precision */\n\n    put_bits(p, 4, 0); /* table 0 */\n\n    for(i=0;i<64;i++) {\n\n        j = intra_scantable->permutated[i];\n\n        put_bits(p, 8, luma_intra_matrix[j]);\n\n    }\n\n\n\n        if (matrix_count > 1) {\n\n            put_bits(p, 4, 0); /* 8 bit precision */\n\n            put_bits(p, 4, 1); /* table 1 */\n\n            for(i=0;i<64;i++) {\n\n                j = intra_scantable->permutated[i];\n\n                put_bits(p, 8, chroma_intra_matrix[j]);\n\n            }\n\n        }\n\n    }\n\n\n\n    if(avctx->active_thread_type & FF_THREAD_SLICE){\n\n        put_marker(p, DRI);\n\n        put_bits(p, 16, 4);\n\n        put_bits(p, 16, (avctx->width-1)/(8*hsample[0]) + 1);\n\n    }\n\n\n\n    /* huffman table */\n\n    put_marker(p, DHT);\n\n    flush_put_bits(p);\n\n    ptr = put_bits_ptr(p);\n\n    put_bits(p, 16, 0); /* patched later */\n\n    size = 2;\n\n\n\n    // Only MJPEG can have a variable Huffman variable. All other\n\n    // formats use the default Huffman table.\n\n    if (s->out_format == FMT_MJPEG && s->huffman == HUFFMAN_TABLE_OPTIMAL) {\n\n        size += put_huffman_table(p, 0, 0, s->mjpeg_ctx->bits_dc_luminance,\n\n                                  s->mjpeg_ctx->val_dc_luminance);\n\n        size += put_huffman_table(p, 0, 1, s->mjpeg_ctx->bits_dc_chrominance,\n\n                                  s->mjpeg_ctx->val_dc_chrominance);\n\n\n\n        size += put_huffman_table(p, 1, 0, s->mjpeg_ctx->bits_ac_luminance,\n\n                                  s->mjpeg_ctx->val_ac_luminance);\n\n        size += put_huffman_table(p, 1, 1, s->mjpeg_ctx->bits_ac_chrominance,\n\n                                  s->mjpeg_ctx->val_ac_chrominance);\n\n    } else {\n\n        size += put_huffman_table(p, 0, 0, avpriv_mjpeg_bits_dc_luminance,\n\n                                  avpriv_mjpeg_val_dc);\n\n        size += put_huffman_table(p, 0, 1, avpriv_mjpeg_bits_dc_chrominance,\n\n                                  avpriv_mjpeg_val_dc);\n\n\n\n        size += put_huffman_table(p, 1, 0, avpriv_mjpeg_bits_ac_luminance,\n\n                                  avpriv_mjpeg_val_ac_luminance);\n\n        size += put_huffman_table(p, 1, 1, avpriv_mjpeg_bits_ac_chrominance,\n\n                                  avpriv_mjpeg_val_ac_chrominance);\n\n    }\n\n    AV_WB16(ptr, size);\n\n}\n", "idx": 25095, "substitutes": {"avctx": ["avconst", "avecontext", "Avconn", " avctl", "averconst", "averctx", "abcontext", "avconf", " avconf", "avcp", "Avctx", "avctl", "Avcontext", "AVpkg", "avercontext", "awcontext", "iamctx", "iamcontext", " avcp", "avecam", "awtx", "abctl", "AVctx", "avertx", "aveconf", "AVcp", "avconn", "Avpkg", "awctl", "avercp", "avectx", "navcontext", " avconn", "abtx", "avtx", "navconf", " avtx", "abctx", "avcam", "averctl", "navcam", "AVcontext", "navctx", "awctx", "iamconst", "AVtx", "avpkg", " avpkg", " avcam", " avconst", "iamctl", " avcontext", "avcontext", "AVconn"], "p": ["f", "ping", "pre", "patch", "pb", "o", "point", "br", "op", "pc", "app", "pad", "vp", "w", "part", "d", "pp", "c", "pi", "at", "er", "g", "r", "cp", "n", "cache", "pg", "pid", "new", "ctx", "ap", "np", "up", "per", "b", "dp", "php", "ps", "ip", "post", "y", "pa", "wp", "port", "tp", "bp", "sp", "fp", "pkg", "P", "lp", "jp", "t", "q", "m", "v", "h", "pt"], "intra_scantable": ["intra_Scentator", "intra_scentabe", "intra_escenttable", "intra_scancable", "intra_scentator", "intra_Scantable", "intra_escentator", "intra_escentable", "intra_Scentable", "intra_scentable", "intra_scandator", "intra_escantabe", "intra_scannator", "intra_spectantable", "intra_scancated", "intra_scannable", "intra_scannant", "intra_scanttable", "intra_scannables", "intra_scantstable", "intra_spectanttable", "intra_scandtable", "intra_scantsabe", "intra_scandable", "intra_scentant", "intra_scatchable", "intra_spectatchables", "intra_scannabe", "intra_scantator", "intra_scanctable", "intra_spectantant", "intra_Scenttable", "intra_scantant", "intra_scantsable", "intra_scantsator", "intra_spectatchable", "intra_spectatchtable", "intra_scentables", "intra_scancator", "intra_scentated", "intra_Scantator", "intra_scantated", "intra_scantables", "intra_spectatchant", "intra_Scentated", "intra_scenttable", "intra_escantable", "intra_spectantables", "intra_scatchant", "intra_scanntable", "intra_scatchables", "intra_scandated", "intra_escentabe", "intra_Scanttable", "intra_Scantated", "intra_scatchtable", "intra_escanttable", "intra_escantator", "intra_scantabe"], "luma_intra_matrix": ["luma_intra_contrices", "luma_intra_patrices", "luma_intra_matchric", "luma_intra_matrices", "luma_intra_catx", "luma_intra_matchrices", "luma_intra_contrix", "luma_intra_matchtx", "luma_intra_contrie", "luma_intra_manrix", "luma_intra_manric", "luma_intra_contrics", "luma_intra_matx", "luma_intra_atrie", "luma_intra_atrix", "luma_intra_mattx", "luma_intra_atrices", "luma_intra_scheric", "luma_intra_manrices", "luma_intra_schex", "luma_intra_catrix", "luma_intra_matric", "luma_intra_patrics", "luma_intra_patric", "luma_intra_matrie", "luma_intra_cattx", "luma_intra_catric", "luma_intra_atrics", "luma_intra_catrices", "luma_intra_scherices", "luma_intra_atric", "luma_intra_matrics", "luma_intra_patx", "luma_intra_patrix", "luma_intra_patrie", "luma_intra_attx", "luma_intra_matchrix", "luma_intra_scherix"], "chroma_intra_matrix": ["chroma_intra_catrie", "chroma_intra_atthod", "chroma_intra_mitrices", "chroma_intra5matrix", "chroma_intra_matrie", "chroma_intra_manrix", "chroma_intra_trix", "chroma_intra_tvec", "chroma_intra_mitrix", "chroma_intra5methodrix", "chroma_intra_methodhod", "chroma_intra5methodhod", "chroma_intra_catrix", "chroma_intra_mithod", "chroma_intra_catric", "chroma_intra_tric", "chroma_intra_matric", "chroma_intra_matice", "chroma_intra_attrix", "chroma_intra_methodice", "chroma_intra_tagrie", "chroma_intra_mathod", "chroma_intra_attice", "chroma_intra5matice", "chroma_intra5methodice", "chroma_intra_manvec", "chroma_intra_tagrices", "chroma_intra_matvec", "chroma_intra_catvec", "chroma_intra_catrices", "chroma_intra_methodrix", "chroma_intra_manrices", "chroma_intra5mathod", "chroma_intra_mitice", "chroma_intra_tagrix", "chroma_intra_trices", "chroma_intra_mitrie", "chroma_intra_manric", "chroma_intra_matrices"], "hsample": ["hessample", "hsamples", "hessamples", "hzamples", "hspeed", "hhammy", "hzample", "pssample", "hhsample", "xsammy", "xspeed", "hzammy", "psamples", "psample", "hsammy", "hssample", "xssample", "xsamples", "hzsample", "pspeed", "hhamples", "xsample", "hhample", "hesssample", "hesspeed"], "i": ["ui", "ie", "c", "ini", "id", "er", "in", "r", "I", "ai", "li", "info", "ip", "ij", "y", "ci", "iu", "si", "v", "ei", "series", "ji", "parent", "ki", "\u0438", "try", "us", " ii", "n", "remote", "io", "ind", "uri", "m", "point", "qi", "ix", "my", "x", "multi", "ami", "ri", "iy", "phi", "di", "zi", "mi", "ii", "print", "is", "l", "bi", "dr", " index", "xi", "this", "it", "ic", "mac", "pi", "ex", "g", "me", "gi", "ity", "hi", "ti", "e", "index", "cli", "init"], "j": ["ji", "note", "block", "it", "je", "job", "obj", "jac", "ja", "err", "jump", "br", "try", "v", "uj", "bo", "dj", "fr", "k", "ia", "er", "g", "r", "gi", "di", "kj", "jit", "J", "pos", "nu", "li", "js", "jc", "b", "l", "ind", "bi", "ij", "y", "kid", "z", "oj", "json", "str", "ni", "jp", "q", "index", "jj", "jl", "aj", "ijk"], "size": ["sn", "dim", "length", "args", "len", "w", "pi", "c", "height", "g", "n", "send", "count", "ize", "small", "sh", "set", "pos", "mi", "li", "shape", "l", "shift", "scale", "notice", "SIZE", "ci", "z", "sp", "Size", "offset", "si", "max", "sum", "v", "m"], "ptr": ["err", "ref", "address", "br", "pc", "Ptr", "pad", "pi", "push", "ctr", "pr", "row", "pointers", "pointer", "rel", "ctx", "pos", "rep", "np", "eth", "prime", "ind", "ts", "ps", "dr", "loc", "addr", "alloc", "sp", "tp", "iter", "fp", "offset", "tr", "index", "pt"], "s": ["sys", "sn", "sb", "os", "fs", "v", "rs", "w", "c", "_", "ses", "cont", "ds", "scl", "hs", "spec", "n", "sets", "cs", "sts", "set", "sw", "S", "js", "ss", "a", "is", "ats", "ts", "ns", "ps", "stats", "es", "gs", "sp", "sv", "sg", "t", "ssl"]}}
{"project": "qemu", "commit_id": "8dfe8e7f4facef400ef1c220f29196ae5cfc526c", "target": 0, "func": "static void ppc_spapr_init(MachineState *machine)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\n\n    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    PowerPCCPU *cpu;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *rma_region;\n\n    void *rma = NULL;\n\n    hwaddr rma_alloc_size;\n\n    hwaddr node0_size = spapr_node0_size();\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    /* Allocate RMA if necessary */\n\n    rma_alloc_size = kvmppc_alloc_rma(&rma);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        error_report(\"Unable to create RMA\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < node0_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = node0_size;\n\n\n\n        /* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         */\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size > node0_size) {\n\n        error_report(\"Numa node 0 has to span the RMA (%#08\"HWADDR_PRIx\")\",\n\n                     spapr->rma_size);\n\n        exit(1);\n\n    }\n\n\n\n    /* Setup a load limit for the ramdisk leaving room for SLOF and FDT */\n\n    load_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;\n\n\n\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. */\n\n    spapr->htab_shift = 18; /* Minimum architected size */\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= machine->maxram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n    spapr_alloc_htab(spapr);\n\n\n\n    /* Set up Interrupt Controller before we create the VCPUs */\n\n    spapr->icp = xics_system_init(machine,\n\n                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),\n\n                                               smp_threads),\n\n                                  XICS_IRQS, &error_fatal);\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_validate_node_memory(machine, &error_fatal);\n\n    }\n\n\n\n    /* init CPUs */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            error_report(\"Unable to find PowerPC CPU definition\");\n\n            exit(1);\n\n        }\n\n        spapr_cpu_init(spapr, cpu, &error_fatal);\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        /* Enable H_LOGICAL_CI_* so SLOF can talk to in-kernel devices */\n\n        kvmppc_enable_logical_ci_hcalls();\n\n        kvmppc_enable_set_mode_hcall();\n\n    }\n\n\n\n    /* allocate RAM */\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_spapr.ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    if (rma_alloc_size && rma) {\n\n        rma_region = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram_ptr(rma_region, NULL, \"ppc_spapr.rma\",\n\n                                   rma_alloc_size, rma);\n\n        vmstate_register_ram_global(rma_region);\n\n        memory_region_add_subregion(sysmem, 0, rma_region);\n\n    }\n\n\n\n    /* initialize hotplug memory address space */\n\n    if (machine->ram_size < machine->maxram_size) {\n\n        ram_addr_t hotplug_mem_size = machine->maxram_size - machine->ram_size;\n\n\n\n        if (machine->ram_slots > SPAPR_MAX_RAM_SLOTS) {\n\n            error_report(\"Specified number of memory slots %\"\n\n                         PRIu64\" exceeds max supported %d\",\n\n                         machine->ram_slots, SPAPR_MAX_RAM_SLOTS);\n\n            exit(1);\n\n        }\n\n\n\n        spapr->hotplug_memory.base = ROUND_UP(machine->ram_size,\n\n                                              SPAPR_HOTPLUG_MEM_ALIGN);\n\n        memory_region_init(&spapr->hotplug_memory.mr, OBJECT(spapr),\n\n                           \"hotplug-memory\", hotplug_mem_size);\n\n        memory_region_add_subregion(sysmem, spapr->hotplug_memory.base,\n\n                                    &spapr->hotplug_memory.mr);\n\n    }\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_create_lmb_dr_connectors(spapr);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR rtas '%s'\", \"spapr-rtas.bin\");\n\n        exit(1);\n\n    }\n\n    spapr->rtas_size = get_image_size(filename);\n\n    spapr->rtas_blob = g_malloc(spapr->rtas_size);\n\n    if (load_image_size(filename, spapr->rtas_blob, spapr->rtas_size) < 0) {\n\n        error_report(\"Could not load LPAR rtas '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        error_report(\"RTAS too big ! 0x%zx bytes (max is 0x%x)\",\n\n                     (size_t)spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* Set up EPOW events infrastructure */\n\n    spapr_events_init(spapr);\n\n\n\n    /* Set up the RTC RTAS interfaces */\n\n    spapr_rtc_create(spapr);\n\n\n\n    /* Set up VIO bus */\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    /* We always have at least the nvram device on VIO */\n\n    spapr_create_nvram(spapr);\n\n\n\n    /* Set up PCI */\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    /* Graphics */\n\n    if (spapr_vga_init(phb->bus, &error_fatal)) {\n\n        spapr->has_graphics = true;\n\n        machine->usb |= defaults_enabled() && !machine->usb_disabled;\n\n    }\n\n\n\n    if (machine->usb) {\n\n        if (smc->use_ohci_by_default) {\n\n            pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        } else {\n\n            pci_create_simple(phb->bus, -1, \"nec-usb-xhci\");\n\n        }\n\n\n\n        if (spapr->has_graphics) {\n\n            USBBus *usb_bus = usb_bus_find(-1);\n\n\n\n            usb_create_simple(usb_bus, \"usb-kbd\");\n\n            usb_create_simple(usb_bus, \"usb-mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        error_report(\n\n            \"pSeries SLOF firmware requires >= %ldM guest RMA (Real Mode Area memory)\",\n\n            MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, PPC_ELF_MACHINE, 0);\n\n        if (kernel_size == ELF_LOAD_WRONG_ENDIAN) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, PPC_ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            error_report(\"error loading %s: %s\",\n\n                         kernel_filename, load_elf_strerror(kernel_size));\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                error_report(\"could not load initial ram disk '%s'\",\n\n                             initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR firmware '%s'\", bios_name);\n\n        exit(1);\n\n    }\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size <= 0) {\n\n        error_report(\"Could not load LPAR firmware '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* FIXME: Should register things through the MachineState's qdev\n\n     * interface, this is a legacy from the sPAPREnvironment structure\n\n     * which predated MachineState but had a similar function */\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            kernel_cmdline,\n\n                                            spapr->check_exception_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n\n\n    /* used by RTAS */\n\n    QTAILQ_INIT(&spapr->ccs_list);\n\n    qemu_register_reset(spapr_ccs_reset_hook, spapr);\n\n\n\n    qemu_register_boot_set(spapr_boot_set, spapr);\n\n}\n", "idx": 25103, "substitutes": {"machine": ["vm", "handler", "device", "engine", "direction", "server", "zone", "power", "host", "cell", "normal", "hard", "common", "local", "object", "money", "linux", "alias", "mode", "state", "series", "dm", "monitor", "node", "computer", "sim", "module", "magic", "message", "Machine", "shell", "instance", "connection", "process", "sm", "virtual", "template", "link", "mc", "smart", "managed", "check", "domain", "iso", "unknown", "model", "achine", "manager", "m", "program", "hello"], "spapr": ["snaptadr", "repappr", "skaprt", "spapyler", "spaptrel", "spippr", "spapadr", "spapperred", "slaptnr", "respapro", "sparprt", "respapr", "sprapred", "resparpr", "speaptstr", "spmaprt", "resparpro", "spapperrar", "spanddr", "ppamprer", "ppapr", "spmapro", "spaprar", "speaptrar", "sparprs", "spiprar", "speaprar", "spapsro", "repaprb", "repapprt", "spaspro", "speapstr", "spaptro", "spapler", "speaptro", "spaptler", "speapro", "slapnr", "speaptres", "papdr", "spcapro", "spipprar", "ppaprar", "spaphr", "spaptr", "spaprb", "spaspler", "spapsdr", "skaptrt", "spaptR", "spampr", "speapler", "spapperrr", "papr", "spcapr", "spaperer", "spmaprb", "spapprb", "snapred", "spandr", "spapsrt", "spapprs", "sprapr", "spapsr", "repapprb", "spraprt", "repapred", "speapr", "spaspred", "papsr", "speaprr", "spapres", "sphaprel", "spapro", "snaptlr", "skaptr", "speaptr", "spasprar", "spamprer", "spaptlr", "spaprt", "skaptrer", "spipr", "spipR", "spapyr", "slaptrel", "spaperr", "spapred", "ppampR", "snaptred", "ppamprar", "snapr", "skaprer", "spapR", "spaphrar", "spaspr", "spandro", "spmaprs", "spraperr", "papR", "spapsR", "snaplr", "spippred", "repaptrar", "spapperstr", "repaptred", "slaprel", "papsro", "spapperlr", "spaptnr", "spaptred", "respaprar", "spmapr", "speaptler", "sparpR", "speaptrr", "spapperr", "snaptr", "repaprt", "spaptrt", "repapr", "repapterr", "spaptres", "spraplr", "spaplr", "spaspres", "sparprb", "spappr", "spaptadr", "spaphrr", "slapr", "spapyro", "papsR", "repapprs", "spampR", "skaperr", "repaperr", "spcapR", "spapsrer", "spapeR", "spmapR", "spapserr", "spaper", "spaptrer", "sphaprer", "spiprer", "spaprs", "spapprt", "slaptr", "slaprer", "spapperadr", "spaptstr", "spaprel", "respapR", "spapstr", "spcaprar", "spasperr", "skapterr", "ppapR", "spaprr", "sparpr", "sphapnr", "sparprar", "sphapr", "snapadr", "spamprar", "papsdr", "ppaprer", "spaphstr", "repaptr", "papro", "resparpR", "sprapadr", "ppampr", "spaptrar", "spmapdr", "spapterr", "spapyres", "resparprar", "spaperar", "speapres", "spipperr", "spaptrr", "skapr", "repaprar", "spapnr", "spandR", "spapsrel", "spapsnr", "spapdr", "spraprer", "sparpro", "slaptrer", "spaprer", "repaprs"], "smc": ["simc", "symu", "simf", "symf", "symc", " smf", "smt", "simt", " smu", " smt", "symt", "smf", "simu", "smu"], "kernel_filename": ["module_username", "kernelphpfilename", "proc_directory", "kernelphpwriting", "kernelphpusername", "proc_filename", "proc_location", "proc_username", "kernelpywriting", "module_filename", "kernel_location", "module_writing", "kernel_directory", "kernel_exe", "kernelpyfilename", "kernelphpexe", "kernelpyusername", "kernel_username", "module_exe", "kernelpyexe", "kernel_writing"], "kernel_cmdline": ["kernel_mdline", "kernel_cplines", "kernel_programlines", "kernel_mdlines", "kernel_commandline", "kernel_programline", "kernel_extlines", "kernel_extline", "kernel_mdLine", "kernel_commandlines", "kernel_cmdLine", "kernel_cmdlines", "kernel_commandLine", "kernel_programLine", "kernel_cpline", "kernel_extLine", "kernel_cpLine"], "initrd_filename": ["initrd__Filename", "initrd__filename", "initrb_file", "initrb_Filename", "initrd_Filename", "initrd_txt", "initrs_Filename", "initrs_file", "initrd_file", "initrs_directory", "initrd__txt", "initrd_directory", "initrs_filename", "initrb_txt", "initrd__file", "initrb_filename"], "cpu": ["vm", "kernel", "chip", "cu", "network", "pc", "core", "gpu", "mem", "clock", "pool", "pixel", "cp", "linux", "cache", "memory", "util", "computer", "ctx", "phys", "process", "processor", "CPU", "pu", "java", "gc", "proc", "socket"], "phb": ["shbs", "phbs", "shb", " phbs", "sha", "Phs", "Phb", "Phbs", "Pha", "phs", " pha", " phs", "pha", "shs"], "i": ["it", "x", "ki", " j", "pi", " ii", "ia", "fi", "I", "p", " bi", "io", "di", "j", " v", "ii", "li", "l", "ip", "y", "ci", " init", " I", "si", "t", "m", "v", " l"], "sysmem": ["ysmem", "ysmemory", " sysmemory", "systemram", "sysmc", " sysram", "systemmc", " sysmc", "ysmc", "sysmemory", "systemmem", "systemmemory", "sysram", "ysram"], "ram": ["range", "vm", "region", "red", "cam", "rum", "ma", "ru", "mb", "sam", "rad", "mem", "mm", "dev", "row", "gram", "tem", "mode", "memory", "rom", "ra", "rem", "am", "gra", "AM", "RAM", "ro", "res"], "rma_region": ["rma2range", "rna_reg", "rna_region", "rma2reg", "rma_range", "rma2region", "rna_range", "rma_reg"], "rma": ["Rna", "rva", "rtpa", "rrva", "mma", "rrota", "Rma", "rtva", "rtma", " rna", " rsa", "rhea", "Rsa", " rva", " rpa", "Rhea", "rtota", "rota", "msa", "rsa", "rrpa", "mna", "mhea", "rna", "rpa", " rota", " rhea", "rrma"], "rma_alloc_size": ["rma_buf_size", "rma_buf_len", "rma_alloctspace", "rma_mem_space", "rma_alloc_name", "rma_alloc2name", "rma_all_size", "rma_all_scale", "rma_alloc_len", "rma_alloc2sum", "rma_mem_size", "rma_allocxsize", "rma_buf_member", "rma_alloc_sum", "rma_alloctsize", "rma_alloc_SIZE", "rma_alloc_loc", "rma_allocxSIZE", "rma_allocxname", "rma_allocxloc", "rma_alloctloc", "rma_memxlen", "rma_alloctSIZE", "rma_alloc_member", "rma_alloc_scale", "rma_alloc_space", "rma_alloc2mode", "rma_alloc2size", "rma_allocxspace", "rma_all_space", "rma_allocxlen", "rma_mem_len", "rma_oc_size", "rma_all_SIZE", "rma_oc_sum", "rma_alloc_Size", "rma_alloc2len", "rma_all_mode", "rma_all_Size", "rma_all_loc", "rma_alloc2Size", "rma_oc_space", "rma_memxspace", "rma_alloc2space", "rma_mem_name", "rma_memxname", "rma_memxsize", "rma_alloc_mode"], "load_limit": ["loader_delay", "load_length", "load_lim", "load_limits", "loader_policy", "loader_limits", "load_delay", "loader_length", "load_policy", "loader_lim", "loader_limit"], "fw_size": ["fw_name", "fw_SIZE", "fw_len", "hw_SIZE", "hw_name", "hw_size", "hw_len"], "filename": ["length", "fs", "Filename", "wire", "buffer", "params", "family", "metadata", "fn", "prefix", "module", "write", "message", "connection", "location", "ename", "processor", "username", "seek", "files", "directory", "json", "uri", "fp", "writer", "description", "socket"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void n8x0_nand_setup(struct n800_s *s)\n\n{\n\n    char *otp_region;\n\n    DriveInfo *dinfo;\n\n\n\n    s->nand = qdev_create(NULL, \"onenand\");\n\n    qdev_prop_set_uint16(s->nand, \"manufacturer_id\", NAND_MFR_SAMSUNG);\n\n    /* Either 0x40 or 0x48 are OK for the device ID */\n\n    qdev_prop_set_uint16(s->nand, \"device_id\", 0x48);\n\n    qdev_prop_set_uint16(s->nand, \"version_id\", 0);\n\n    qdev_prop_set_int32(s->nand, \"shift\", 1);\n\n    dinfo = drive_get(IF_MTD, 0, 0);\n\n    if (dinfo) {\n\n        qdev_prop_set_drive_nofail(s->nand, \"drive\",\n\n                                   blk_bs(blk_by_legacy_dinfo(dinfo)));\n\n    }\n\n    qdev_init_nofail(s->nand);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0,\n\n                       qdev_get_gpio_in(s->mpu->gpio, N8X0_ONENAND_GPIO));\n\n    omap_gpmc_attach(s->mpu->gpmc, N8X0_ONENAND_CS,\n\n                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));\n\n    otp_region = onenand_raw_otp(s->nand);\n\n\n\n    memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_mac));\n\n    memcpy(otp_region + 0x800, n8x0_cal_bt_id, sizeof(n8x0_cal_bt_id));\n\n    /* XXX: in theory should also update the OOB for both pages */\n\n}\n", "idx": 25113, "substitutes": {"s": ["ms", "i", "as", "sa", "sb", "ports", "args", "store", "ins", "se", "os", "comm", "fs", "ants", "ties", "rs", "sports", "w", "c", "ses", "ds", "hs", "sl", "params", "sync", "details", "tests", "spec", "n", "p", "changes", "cs", "sts", "asm", "services", "aws", "esm", "set", "vs", "S", "sql", "als", "js", "ss", "is", "ats", "l", "ns", "ts", "ps", "ims", "sm", "y", "ies", "states", "stats", "qs", "south", "es", "its", "gs", "sv", "parts", "h", "ls", "q", "sq", "conf"], "otp_region": ["otp_rect", "otp___origin", "otbp_reg", "ottp_storage", "otpa_region", "otbp_REG", "otP_Region", "otp_origin", "otP_region", "otp_Region", "otpachearea", "otp__origin", "otp__global", "otpa__region", "otp_union", "otpa__union", "otpa__origin", "otp_area", "ottp_field", "otp__union", "otpa_union", "otbp_rect", "otp_field", "otp___region", "ottp_area", "otpachefield", "otp__reg", "otpacheorigin", "otp_reg", "ottp_region", "otp_global", "otbp_region", "otpa_origin", "otpacheunion", "otp__region", "otp___union", "otP_reg", "otP_global", "otpacheregion", "otp__Region", "otpachestorage", "otp_storage", "otp_REG"], "dinfo": [" dfo", "mdinfo", " dinf", "ddfo", "dsInfo", "Dube", "ldinf", "Dno", " dInfo", "Ddetails", "dsfo", "mdfo", "ddInfo", "dinf", " dno", "Dinf", "DInfo", "ddinfo", "dInfo", "dube", "mdno", "lddetails", "ddetails", "ldinfo", "Dinfo", "dsinf", " ddetails", " dube", "ddube", "dfo", "Dfo", "dsinfo", "dno", "mdinf"]}}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void cpu_dump_state (CPUState *env, FILE *f, \n\n                     int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                     int flags)\n\n{\n\n    uint32_t c0_status;\n\n    int i;\n\n    \n\n    cpu_fprintf(f, \"pc=0x\" TARGET_FMT_lx \" HI=0x\" TARGET_FMT_lx \" LO=0x\" TARGET_FMT_lx \" ds %04x \" TARGET_FMT_lx \" %d\\n\",\n\n                env->PC, env->HI, env->LO, env->hflags, env->btarget, env->bcond);\n\n    for (i = 0; i < 32; i++) {\n\n        if ((i & 3) == 0)\n\n            cpu_fprintf(f, \"GPR%02d:\", i);\n\n        cpu_fprintf(f, \" %s \" TARGET_FMT_lx, regnames[i], env->gpr[i]);\n\n        if ((i & 3) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n    }\n\n\n\n    c0_status = env->CP0_Status;\n\n\n\n    cpu_fprintf(f, \"CP0 Status  0x%08x Cause   0x%08x EPC    0x\" TARGET_FMT_lx \"\\n\",\n\n                c0_status, env->CP0_Cause, env->CP0_EPC);\n\n    cpu_fprintf(f, \"    Config0 0x%08x Config1 0x%08x LLAddr 0x\" TARGET_FMT_lx \"\\n\",\n\n                env->CP0_Config0, env->CP0_Config1, env->CP0_LLAddr);\n\n    if (c0_status & (1 << CP0St_CU1))\n\n        fpu_dump_state(env, f, cpu_fprintf, flags);\n\n#if defined(TARGET_MIPS64) && defined(MIPS_DEBUG_SIGN_EXTENSIONS)\n\n    cpu_mips_check_sign_extensions(env, f, cpu_fprintf, flags);\n\n#endif\n\n}\n", "idx": 25119, "substitutes": {"env": ["cur", "ter", "ie", "vp", "pp", "er", "dev", "ten", "forge", "extra", "et", "ctx", "vs", "environment", "info", "era", "v", "ee", "enter", "ei", "cf", "site", "ce", "obj", "store", "ev", "erd", "config", "entry", "eh", "ec", "db", "msg", "buf", "gear", "te", "inv", "enc", "next", "desc", "window", "en", "vt", "ped", "context", "engine", "ef", "esc", "den", "def", "ah", "shell", "doc", "nv", "worker", "rb", "outer", "manager", "cv", "server", "ner", "err", "w", "rc", "result", "event", "ew", "ext", "cmd", "ve", "quer", "org", "set", " environment", "project", "erb", "req", "txt", "e", "hl", "end", "eng", "conf"], "f": ["fx", "fb", "it", "x", "ef", "full", "out", "alf", "cf", "o", "uf", "fw", "ff", "fa", "fs", "d", "tf", "w", "c", "fr", "bf", "fl", "fi", "g", "fm", "r", "func", "lf", "p", "fn", "form", "rf", "fg", "file", "xf", "b", "l", "fac", "fe", "fd", "fc", "ft", "e", "fo", "sf", "fp", "t", "h", "m", "v", "F"], "cpu_fprintf": ["cpu_rmt", "cpu_dprintln", "cpu_rformat", "cpu_frprintf", "cpu_lprintf", "cpu_pprint", "cpu_mprintf", "cpu_mprintln", "cpu_fformat", "cpu_frprint", "cpu_fprintln", "cpu_cprintf", "cpu_vprint", "cpu_fsprint", "cpu_rprint", "cpu_rwrite", "cpu_vmt", "cpu_rprintf", "cpu_tprint", "cpu_fspr", "cpu_tformat", "cpu_rprintln", "cpu_pprintf", "cpu_rrep", "cpu_cprint", "cpu_drep", "cpu_mmt", "cpu_fsprintln", "cpu_fwrite", "cpu_vformat", "cpu_cformat", "cpu_pprintln", "cpu_cmt", "cpu_rflush", "cpu_prep", "cpu_fmt", "cpu_cprintln", "cpu_dformat", "cpu_vprintln", "cpu_dwrite", "cpu_dprint", "cpu_mformat", "cpu_fpr", "cpu_fsprintf", "cpu_vwrite", "cpu_frprintln", "cpu_fflush", "cpu_dmt", "cpu_cpr", "cpu_tmt", "cpu_dprintf", "cpu_frep", "cpu_tprintf", "cpu_frflush", "cpu_vprintf", "cpu_lmt", "cpu_dflush", "cpu_dpr", "cpu_fprint", "cpu_lprint", "cpu_lprintln"], "flags": [" fmt", "ms", "alf", " Flags", " options", "args", "cf", "options", "fields", "ff", " fields", "fee", "fs", " args", "lag", "rs", "members", "tags", "ds", "comments", "Flags", "func", "pages", "cmd", "cond", "fps", "s", "ents", "ags", "bits", "faces", "pins", "ts", "weights", "ps", "ensions", "locks", "vals", "files", "fd", "gs", "flag", "gnu", "posts", "fp", "features", "ptr", "atts", " fs", "heads"], "c0_status": ["c1_active", "c0__Status", "c0_active", "c0__flag", "c0_stat", "c0__name", "c0_sync", "c2__stat", "c2__Status", "c2_Status", "c1_name", "c0_flag", "c1_status", "c2_status", "c1_sync", "c0__status", "c1_flag", "c1_Status", "c1_stat", "c2__status", "c0__active", "c1__Status", "c1__status", "c1__flag", "c1__sync", "c2_stat", "c0__stat", "c0_name", "c0_Status", "c0__sync"], "i": ["ji", "it", "ic", "my", "mac", "x", "batch", "ui", "multi", "\u0438", "o", "point", "status", "us", "ami", "pi", "c", "id", "ini", "index", "ex", "ri", "fi", "in", "me", "gi", "I", "n", "p", "phi", "oi", "di", "zi", "sim", "j", "ai", "mi", "li", "ii", "iq", "chain", "is", "ti", "l", "ind", "size", "info", "ip", "bi", "y", "ij", "abi", "key", "ci", "z", "by", "iu", "xi", "si", "im", "t", "m", "v", "cli", "qi", "ei", "ix"]}}
{"project": "FFmpeg", "commit_id": "fb1473080223a634b8ac2cca48a632d037a0a69d", "target": 1, "func": "static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n\n        int *need_next_header, int *new_frame_start)\n\n{\n\n    GetBitContext bits;\n\n    AACADTSHeaderInfo hdr;\n\n    int size;\n\n    union {\n\n        uint64_t u64;\n\n        uint8_t  u8[8];\n\n    } tmp;\n\n\n\n    tmp.u64 = av_be2ne64(state);\n\n    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);\n\n\n\n    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)\n\n        return 0;\n\n    *need_next_header = 0;\n\n    *new_frame_start  = 1;\n\n    hdr_info->sample_rate = hdr.sample_rate;\n\n    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];\n\n    hdr_info->samples     = hdr.samples;\n\n    hdr_info->bit_rate    = hdr.bit_rate;\n\n    return size;\n\n}\n", "idx": 25130, "substitutes": {"state": ["block", "length", "out", "store", "hash", "code", "config", "map", "value", "output", "reg", "buffer", "mem", "resource", "cache", "count", "memory", "pointer", "msg", "buf", "STATE", "input", "State", "next", "data", "test", "start", "info", "states", "base", "st", "seed", "sample", "lock", "init", "conf"], "hdr_info": ["hdr_inf", "hvr_Info", "hheader_INFO", "hdr__conf", "her_information", "holder_inf", "hdr2fo", "hdr__fo", "hdr2info", "hdr_information", "holder_info", "hheader_information", "hdr2Info", "holder_conf", "hdrletinfo", "hheader_info", "hvr_info", "hvr_fo", "hdr2information", "hdr__inf", "hdr_Info", "hheader_Info", "hvr_information", "holder_fo", "hdr_fo", "hdr_INFO", "hdr__info", "hdr_help", "her_help", "hheader_inf", "hdr_conf", "hdrletinformation", "hdrlethelp", "her_info"], "need_next_header": ["need_nextfulheaders", "need_nextmlvolume", "need_nextalvolume", "need_nextfullayer", "need_next_headers", "need_first_header", "need_nextfuldrop", "need_nextmlindex", "need_nextmlheader", "need_first_layer", "need_next_volume", "need_first_headers", "need_nextmlheaders", "need_next_drop", "need_first_drop", "need_next_layer", "need_nextfulheader", "need_nextalindex", "need_nextalheader", "need_nextalheaders", "need_next_index"], "new_frame_start": ["new_frame_from", "new_frames_start", "new_window_size", "new_frames_offset", "new_frame_offset", "new_frames_from", "new_window_offset", "new_frames_end", "new_window_start", "new_frame_size", "new_window_end", "new_frame_end"], "bits": ["codes", "ms", "ops", "bugs", "boot", "bps", "fs", "bit", "issues", "qt", "cats", "bf", "maps", "flags", "uts", "rots", " buffers", " bases", "keys", "bis", "nets", "cs", "bytes", "ints", "buf", "ctx", "vs", "als", "bs", "pins", "js", "outs", "tops", "xs", "b", "ns", "ts", "ps", "vals", "locks", "stats", "bh", "base", "bt", "its", "gs", "gb", "parts", "checks", "orts"], "hdr": [" hDR", "herder", "hint", "hDr", " hmt", "herbr", " hvr", "hder", "hvr", " phder", "histr", "hstr", "ohint", "rhder", "chder", " hbr", " hder", "ohmt", "hld", "Hls", "hidr", "hild", "hiDR", "rhbr", " phDr", "chbr", "ohdr", "hmt", "rhdr", "hils", "chdr", "ohld", "himt", "HDr", "ohDR", "Hstr", " phdr", "Hdr", "hDR", "herdr", "Hint", " hDr", " hstr", "HDR", "herpr", "rhDR", "chpr", "hbr", "hls", "ohvr", "Hbr", "hivr", " hld", "Hder", " phDR", " hpr", " hint", "Hld", "hpr", " hls"], "size": ["sn", "type", "length", "space", "len", "code", "fee", "from", "c", "body", "zero", "now", "loss", "empty", "g", "spec", "send", "n", "count", "ze", "ize", "s", "small", "new", "sent", "msg", "set", "to", "message", "up", "shape", "start", "scale", "notice", "shift", "SIZE", "z", "sp", "Size", "offset", "max", "sum", "index", "v", "final", "name"], "u8": ["i9", "u15", "ui32", "u16", "iu16", "i48", "u9", "i16", "uni16", "uni8", "i15", "i32", "uni15", "ui8", "uni9", "iu8", "U8", "ui64", "i8", "ui48", "u32", "u48", "u64", "U48", "U32", "iu15", "i64", "U64", "iu9"], "tmp": ["cmp", "perm", "out", "appy", "obj", "xy", "uf", "temp", "mp", "nb", "tf", "buffer", "params", "mk", "empty", "cache", "img", "new", "resp", "msg", "cb", "bytes", "buf", "mint", "proc", "ctx", "pos", "np", "up", "test", "nt", "src", "txt", "bt", "sp", "gs", "aux", "etc", "buff", "pkg", "zip", "vt", "t", "uv", "v", "m", "cv"]}}
{"project": "qemu", "commit_id": "eb513f82f04fab442cdef9db698dafc852275f7f", "target": 1, "func": "uint64_t helper_ld_asi(CPUSPARCState *env, target_ulong addr, int asi, int size,\n\n                       int sign)\n\n{\n\n    uint64_t ret = 0;\n\n#if defined(DEBUG_ASI)\n\n    target_ulong last_addr = addr;\n\n#endif\n\n\n\n    if (asi < 0x80) {\n\n        helper_raise_exception(env, TT_PRIV_ACT);\n\n    }\n\n\n\n    helper_check_align(env, addr, size - 1);\n\n    addr = asi_address_mask(env, asi, addr);\n\n\n\n    switch (asi) {\n\n    case 0x82: /* Primary no-fault */\n\n    case 0x8a: /* Primary no-fault LE */\n\n        if (page_check_range(addr, size, PAGE_READ) == -1) {\n\n#ifdef DEBUG_ASI\n\n            dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n            return 0;\n\n        }\n\n        /* Fall through */\n\n    case 0x80: /* Primary */\n\n    case 0x88: /* Primary LE */\n\n        {\n\n            switch (size) {\n\n            case 1:\n\n                ret = ldub_raw(addr);\n\n                break;\n\n            case 2:\n\n                ret = lduw_raw(addr);\n\n                break;\n\n            case 4:\n\n                ret = ldl_raw(addr);\n\n                break;\n\n            default:\n\n            case 8:\n\n                ret = ldq_raw(addr);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case 0x83: /* Secondary no-fault */\n\n    case 0x8b: /* Secondary no-fault LE */\n\n        if (page_check_range(addr, size, PAGE_READ) == -1) {\n\n#ifdef DEBUG_ASI\n\n            dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n            return 0;\n\n        }\n\n        /* Fall through */\n\n    case 0x81: /* Secondary */\n\n    case 0x89: /* Secondary LE */\n\n        /* XXX */\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Convert from little endian */\n\n    switch (asi) {\n\n    case 0x88: /* Primary LE */\n\n    case 0x89: /* Secondary LE */\n\n    case 0x8a: /* Primary no-fault LE */\n\n    case 0x8b: /* Secondary no-fault LE */\n\n        switch (size) {\n\n        case 2:\n\n            ret = bswap16(ret);\n\n            break;\n\n        case 4:\n\n            ret = bswap32(ret);\n\n            break;\n\n        case 8:\n\n            ret = bswap64(ret);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Convert to signed number */\n\n    if (sign) {\n\n        switch (size) {\n\n        case 1:\n\n            ret = (int8_t) ret;\n\n            break;\n\n        case 2:\n\n            ret = (int16_t) ret;\n\n            break;\n\n        case 4:\n\n            ret = (int32_t) ret;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n#ifdef DEBUG_ASI\n\n    dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n    return ret;\n\n}\n", "idx": 25134, "substitutes": {"env": ["context", "hw", "cur", "esc", "sb", "server", "err", "obj", "store", "ev", "conn", "viron", "vp", "erd", "entry", "er", "dev", "vv", "ew", "buffer", "sc", "pg", "org", "forge", "set", "cb", "sw", "gov", "ctx", "vs", "te", "environment", "inv", "project", "doc", "setup", "cfg", "init", "nv", "attr", "window", "e", "sp", "en", "sv", "ptr", "h", "end", "eng", "vt", "v", "enter", "cv", "conf"], "addr": ["alt", "address", "map", "id", "mem", "gate", "var", "r", "ar", "p", "arr", "asm", "et", "ctx", "pos", "rt", "attr", "ip", "loc", "src", "link", "mt", "ptr", "pkg", "max", "ait", "tx", "site", "obj", "adr", "store", "rs", "gt", "rev", "at", "arm", "ace", "state", "add", "lat", " address", "ag", "handle", "iter", "offset", "hw", "ix", "x", "arp", "pad", "nl", "wd", "act", "now", "alias", "coord", "art", "oc", "dr", "alloc", "url", "mask", "off", "elt", "oa", "str", "iat", "mac", "ad", "err", "ref", "hash", "len", "rc", "reg", "cmd", "ack", "deg", "ord", "usr", "cb", "to", "order", "np", "align", "start", "ret", "end", "index", "init", "name", "res"], "asi": ["iat", "asia", "i", "as", "sa", "ku", "ui", "adr", "pai", "sta", "ski", "asis", "asa", "aci", "ami", "qt", "pi", "eni", "ini", "ais", "agi", "aki", "esi", "axis", "asm", "ois", "di", "ori", "zi", "afi", "arity", "ai", "au", "mi", "ity", "ta", "aii", "oat", "assi", "is", "ti", "AI", "arma", "bi", "ati", "anti", "aka", "notice", "opa", "adi", "osi", "ni", "xi", "isa", "si", "obi", "ani"], "size": ["see", "address", "unit", "count", "s", "extra", "sym", "magic", "pos", "weight", "scale", "z", "ci", "gn", "scope", "si", "max", "sn", "dim", "space", "zone", "code", "ose", "spec", "n", "send", "ize", "mode", "state", "function", "shape", "notice", "en", "offset", "format", "type", "length", "iz", "sha", "member", "sw", "test", "time", "style", "number", "sum", "news", "len", "se", "fee", "empty", "g", "small", "sh", "set", "since", "yes", "shift", "SIZE", "city", "izes", "num", "sp", "Size", "name"], "sign": ["type", "pack", "sa", "rest", "re", "se", "code", "value", "reg", "secure", "act", "get", "wrap", "round", "Sign", "close", "ify", "sc", "ize", "trade", "small", "sh", "set", "mod", "ig", " sig", "align", "shape", "prime", "scale", "trust", "ign", "sp", "style", "pres", "big", "sum", "lock", "name"]}}
{"project": "FFmpeg", "commit_id": "3228ac730c11eca49d5680d5550128e397061c85", "target": 1, "func": "static av_cold int vc2_encode_init(AVCodecContext *avctx)\n\n{\n\n    Plane *p;\n\n    SubBand *b;\n\n    int i, j, level, o, shift, ret;\n\n    const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    const int depth = fmt->comp[0].depth;\n\n    VC2EncContext *s = avctx->priv_data;\n\n\n\n    s->picture_number = 0;\n\n\n\n    /* Total allowed quantization range */\n\n    s->q_ceil    = DIRAC_MAX_QUANT_INDEX;\n\n\n\n    s->ver.major = 2;\n\n    s->ver.minor = 0;\n\n    s->profile   = 3;\n\n    s->level     = 3;\n\n\n\n    s->base_vf   = -1;\n\n    s->strict_compliance = 1;\n\n\n\n    s->q_avg = 0;\n\n    s->slice_max_bytes = 0;\n\n    s->slice_min_bytes = 0;\n\n\n\n    /* Mark unknown as progressive */\n\n    s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) ||\n\n                      (avctx->field_order == AV_FIELD_PROGRESSIVE));\n\n\n\n    for (i = 0; i < base_video_fmts_len; i++) {\n\n        const VC2BaseVideoFormat *fmt = &base_video_fmts[i];\n\n        if (avctx->pix_fmt != fmt->pix_fmt)\n\n            continue;\n\n        if (avctx->time_base.num != fmt->time_base.num)\n\n            continue;\n\n        if (avctx->time_base.den != fmt->time_base.den)\n\n            continue;\n\n        if (avctx->width != fmt->width)\n\n            continue;\n\n        if (avctx->height != fmt->height)\n\n            continue;\n\n        if (s->interlaced != fmt->interlaced)\n\n            continue;\n\n        s->base_vf = i;\n\n        s->level   = base_video_fmts[i].level;\n\n        break;\n\n    }\n\n\n\n    if (s->interlaced)\n\n        av_log(avctx, AV_LOG_WARNING, \"Interlacing enabled!\\n\");\n\n\n\n    if ((s->slice_width  & (s->slice_width  - 1)) ||\n\n        (s->slice_height & (s->slice_height - 1))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is not a power of two!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if ((s->slice_width > avctx->width) ||\n\n        (s->slice_height > avctx->height)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is bigger than the image!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (s->base_vf <= 0) {\n\n        if (avctx->strict_std_compliance < FF_COMPLIANCE_STRICT) {\n\n            s->strict_compliance = s->base_vf = 0;\n\n            av_log(avctx, AV_LOG_WARNING, \"Format does not strictly comply with VC2 specs\\n\");\n\n        } else {\n\n            av_log(avctx, AV_LOG_WARNING, \"Given format does not strictly comply with \"\n\n                   \"the specifications, decrease strictness to use it.\\n\");\n\n            return AVERROR_UNKNOWN;\n\n        }\n\n    } else {\n\n        av_log(avctx, AV_LOG_INFO, \"Selected base video format = %i (%s)\\n\",\n\n               s->base_vf, base_video_fmts[s->base_vf].name);\n\n    }\n\n\n\n    /* Chroma subsampling */\n\n    ret = av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift);\n\n    if (ret)\n\n        return ret;\n\n\n\n    /* Bit depth and color range index */\n\n    if (depth == 8 && avctx->color_range == AVCOL_RANGE_JPEG) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 1;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 8 && (avctx->color_range == AVCOL_RANGE_MPEG ||\n\n               avctx->color_range == AVCOL_RANGE_UNSPECIFIED)) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 2;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 10) {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 3;\n\n        s->diff_offset = 512;\n\n    } else {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 4;\n\n        s->diff_offset = 2048;\n\n    }\n\n\n\n    /* Planes initialization */\n\n    for (i = 0; i < 3; i++) {\n\n        int w, h;\n\n        p = &s->plane[i];\n\n        p->width      = avctx->width  >> (i ? s->chroma_x_shift : 0);\n\n        p->height     = avctx->height >> (i ? s->chroma_y_shift : 0);\n\n        if (s->interlaced)\n\n            p->height >>= 1;\n\n        p->dwt_width  = w = FFALIGN(p->width,  (1 << s->wavelet_depth));\n\n        p->dwt_height = h = FFALIGN(p->height, (1 << s->wavelet_depth));\n\n        p->coef_stride = FFALIGN(p->dwt_width, 32);\n\n        p->coef_buf = av_malloc(p->coef_stride*p->dwt_height*sizeof(dwtcoef));\n\n        if (!p->coef_buf)\n\n            goto alloc_fail;\n\n        for (level = s->wavelet_depth-1; level >= 0; level--) {\n\n            w = w >> 1;\n\n            h = h >> 1;\n\n            for (o = 0; o < 4; o++) {\n\n                b = &p->band[level][o];\n\n                b->width  = w;\n\n                b->height = h;\n\n                b->stride = p->coef_stride;\n\n                shift = (o > 1)*b->height*b->stride + (o & 1)*b->width;\n\n                b->buf = p->coef_buf + shift;\n\n            }\n\n        }\n\n\n\n        /* DWT init */\n\n        if (ff_vc2enc_init_transforms(&s->transform_args[i].t,\n\n                                      s->plane[i].coef_stride,\n\n                                      s->plane[i].dwt_height))\n\n            goto alloc_fail;\n\n    }\n\n\n\n    /* Slices */\n\n    s->num_x = s->plane[0].dwt_width/s->slice_width;\n\n    s->num_y = s->plane[0].dwt_height/s->slice_height;\n\n\n\n    s->slice_args = av_calloc(s->num_x*s->num_y, sizeof(SliceArgs));\n\n    if (!s->slice_args)\n\n        goto alloc_fail;\n\n\n\n    /* Lookup tables */\n\n    s->coef_lut_len = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_len));\n\n    if (!s->coef_lut_len)\n\n        goto alloc_fail;\n\n\n\n    s->coef_lut_val = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_val));\n\n    if (!s->coef_lut_val)\n\n        goto alloc_fail;\n\n\n\n    for (i = 0; i < s->q_ceil; i++) {\n\n        uint8_t  *len_lut = &s->coef_lut_len[i*COEF_LUT_TAB];\n\n        uint32_t *val_lut = &s->coef_lut_val[i*COEF_LUT_TAB];\n\n        for (j = 0; j < COEF_LUT_TAB; j++) {\n\n            get_vc2_ue_uint(QUANT(j, ff_dirac_qscale_tab[i]),\n\n                            &len_lut[j], &val_lut[j]);\n\n            if (len_lut[j] != 1) {\n\n                len_lut[j] += 1;\n\n                val_lut[j] <<= 1;\n\n            } else {\n\n                val_lut[j] = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nalloc_fail:\n\n    vc2_encode_end(avctx);\n\n    av_log(avctx, AV_LOG_ERROR, \"Unable to allocate memory!\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 25135, "substitutes": {"avctx": ["avtmp", "averctx", "aftx", "varcmd", "wavtx", "ajreq", "avesys", "avecc", "afpy", "evconn", "avetmp", "vrcontext", "ajcontext", "vrctx", "wavjac", "ajcu", "avcfg", "avpkg", "ajconn", "wavconn", "cvconn", "afcfg", "wavcontext", "avertmp", "avecmd", "ajtmp", "Avcontext", "avercontext", "varconn", "varconf", "cvctx", "avcu", "varmk", " avjac", "afcc", " avconn", " avsettings", "avpy", "evcontext", "avsys", "avecu", "afcontext", "afconfig", "averconn", " avcontext", "varpy", "avecontext", "evsettings", "afconf", "ajctx", "Avtx", "avconf", "Avctx", "averdef", " avnp", "avsettings", "evctx", "vrconn", "avectx", "avercc", "afctx", "avtx", "avreq", "ajdef", " avcfg", "varctx", "wavcmd", "avcmd", "avecfg", "avereq", "avetx", "avnp", "afconn", "vrcmd", "aveconn", "cvcontext", "avepy", "avepkg", "avcontext", "varsys", "Avnp", "ajsettings", "averjac", "avermk", "avdef", "cvtx", "avercu", "avcc", "ajjac", "aveconfig", "wavctx", "avjac", "aversys", "avercmd", "avertx", "aveconf", "avconn", "avedef", "wavtmp", " avtx", "avmk", "avernp", "vrpkg", "avejac", "avemk", "averconfig", "avconfig", "wavpkg", "wavreq", "vrtx"], "p": ["ph", "pc", "pi", "pp", "c", "pr", "cp", "n", "pn", "ap", "pe", "pl", "a", "l", "ip", "pa", "sp", "P", "t", "jp", "m", "v", "pt"], "b": ["f", "sb", "bc", "d", "c", "sub", "bm", "B", "g", "r", "n", "bs", "a", "l", "bi", "y", "z", "base", "e", "bp", "t", "m", "v"], "i": ["f", "ji", "it", "ic", "x", "batch", "ui", "multi", "\u0438", "ki", "ami", "pi", "c", " ii", "index", "id", "ini", "ri", "g", "gu", "r", "gi", "me", "I", "n", "in", " bi", "remote", "di", "oi", "zi", "go", "ai", "asi", "mi", "li", "ii", "instance", "hi", "a", "is", "ti", "ind", "info", "bi", "ip", "y", "ij", "key", "ims", "ci", "ish", "cgi", "uri", "u", "iu", "xi", "si", "t", "im", "m", "v", "cli", "init", "qi", "ei", "ix"], "j": ["ji", "ja", "jump", "v", "uj", "dj", "k", "g", "n", "kj", "J", "pos", "js", "jc", "ind", "l", "ij", "bj", "z", "oj", "jp", "q", "m", "jj", "aj"], "level": ["lvl", "note", "type", "dim", "length", "where", "Level", "score", "len", "status", "pri", "display", "profile", "debug", "title", "fl", "local", "high", "report", "group", "member", "prof", "family", "count", "mode", "state", "rel", "low", "le", "community", "stage", "pos", "pe", "goal", "depth", "tag", "quality", "levels", "priority", "l", "ind", "size", "weight", "scale", "loc", "vel", "key", "color", "stable", "version", "limit", "coll", "num", "val", "time", "half", "strength", "scope", "trace", "offset", "loop", "index", "lc", "summary", "detail"], "o": ["f", "lo", "out", "ok", "os", "op", "bo", "n", "mode", "ao", "oo", "ob", "go", "O", "ta", "l", "om", "ou", "e", "fo", "u", "off", "offset", "iso", "oa", "m", "ot"], "shift": ["dim", "dq", "sq", "Shift", "aw", "push", "rc", "sup", "sch", "sc", "shr", "sh", "set", "pos", "depth", "align", "shape", "share", "start", "scale", "src", "seek", "seed", "pkg", "offset", "conv", "hift", "ix"], "ret": ["mac", "dim", "na", "alt", "out", "reset", "ll", "status", "bit", "rc", "result", "mem", "fi", "deg", "new", "rel", "set", "mi", "ii", "quality", "reflect", "dr", "val", "gl", "Ret", "jp", "conv", "res"], "fmt": ["Fformat", "fingformat", "finglux", "hirm", "fullirm", "pmt", "virm", "fullformat", " ffeat", "fMT", "flt", "floattm", "fingmt", "ftx", "vMT", "formm", "ftm", "vtx", "htx", "fullmat", "Flt", "ptm", "formt", "pfeat", "fingtm", "pts", " fmm", " flt", "ffeat", "hMT", " fatt", "vlt", "afftm", "fformat", "fatt", "Fmm", "hmt", " firm", "vatt", "htm", "foratt", "facet", "affmt", "fmat", " fts", "vmm", "floatformat", "floatmt", "firm", " flux", "floatacet", "fullmt", "affts", " fmat", "afffeat", "forformat", "vmat", " fMT", "fts", "vformat", "Ftm", "Flux", "vacet", "Fmt", "fmm", "hmm", " ftx", "flux", " facet", "vmt", " ftm", "vtm", " fformat"], "s": ["ops", "eps", "status", "comm", "d", "sports", "c", "er", "comments", "tests", "r", "pers", "mods", "changes", "aws", "bits", "vs", "S", "ns", "ies", "less", "actions", "v", "sq", "uploads", "args", "obj", "os", "rs", "spec", "n", "cs", "services", "als", "ats", "ts", "ims", "styles", "its", "ers", "parts", "m", "sys", "ms", "ins", "ants", "ses", "bis", "sts", "bs", "a", "is", "ps", "locks", "stats", "gs", "ls", "ports", "fs", "ds", "hs", "details", "g", "sets", "set", "js", "ss", "settings", "qs", "terms", "es", "e", "sv", "t", "res"]}}
{"project": "FFmpeg", "commit_id": "b86651a208ee67666a7305b002bc9f14b21dae7f", "target": 1, "func": "static av_cold int rv40_decode_init(AVCodecContext *avctx)\n\n{\n\n    RV34DecContext *r = avctx->priv_data;\n\n\n\n    r->rv30 = 0;\n\n    ff_rv34_decode_init(avctx);\n\n    if(!aic_top_vlc.bits)\n\n        rv40_init_tables();\n\n    r->parse_slice_header = rv40_parse_slice_header;\n\n    r->decode_intra_types = rv40_decode_intra_types;\n\n    r->decode_mb_info     = rv40_decode_mb_info;\n\n    r->loop_filter        = rv40_loop_filter;\n\n    r->luma_dc_quant_i = rv40_luma_dc_quant[0];\n\n    r->luma_dc_quant_p = rv40_luma_dc_quant[1];\n\n    return 0;\n\n}\n", "idx": 25149, "substitutes": {"avctx": ["avecontext", "Avconn", "afconf", " avcmp", "Avtx", "avconf", " avconf", "Avctx", "Avcontext", "awcontext", "avecc", "avcc", "aveconf", "avconn", "avectx", " avcc", "afctx", "afcc", " avconn", "awcmp", "avtx", "vcontext", "vcmp", "vpkg", " avtx", "vctx", "awctx", "awpkg", "afcontext", "avpkg", " avpkg", "avcmp", "avetx", "aveconn", " avcontext", "avcontext"], "r": ["it", "err", "obj", "lr", "ref", "re", "br", "d", "rs", "nr", "rd", "ur", "fr", "rc", "result", "er", "rr", "pr", "ren", "or", "ar", "rate", "p", "rec", "gr", "rel", "rar", "rect", "kr", "vr", "j", "rt", "rer", "attr", "dr", "mr", "R", "cr", "rb", "rw", "ir", "tr", "h", "q", "m", "v", "ro", "res"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_dbatu_h (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 25163, "substitutes": {"opaque": ["Opane", "Opaques", "ipac", "paque", "appac", "appaque", "opque", "opacity", "popaque", " opaques", "Opaque", "paques", "opaques", "popac", "popque", "popacity", "opac", "pane", " opane", "opane", "ipque", "ipaque", " opque", "ipacity", "pque", "appque", "appacity", "Opque"], "sprn": [" sprnr", "srnn", "prnt", "Sprnn", "solnw", "Sprn", "sprN", "sprnt", "prnn", "Sprnr", " sprnw", "solnr", "Sprnt", "solnn", "srN", "sprnw", "prN", "srnt", "prn", "sprnn", "SprN", "Sprnw", "srn", " sprnn", "soln", "sprnr"], "ctx": ["fx", "iat", " cx", "context", "cur", "batch", "tx", "cf", "obj", "jac", "ca", "gas", "conn", "bc", " temporarily", "tk", "c", "ctr", "ctrl", "cp", "sc", "nc", "cb", "voc", "qa", "co", "ct", "xc", " context", "anc", "urg", "ind", "ac", "pa", " gorilla", "ij", "alloc", "unc", "mc", "scope", "gc", "pkg", "ptr", "jp", "cc", "tmp", "proc", "cv"]}}
{"project": "qemu", "commit_id": "9eca6cc64392b4ad8bd8723e840f491fa36524ad", "target": 0, "func": "sprintf_len(char *string, const char *format, ...)\n\n#else\n\nsprintf_len(va_alist) va_dcl\n\n#endif\n\n{\n\n\tva_list args;\n\n#ifdef __STDC__\n\n\tva_start(args, format);\n\n#else\n\n\tchar *string;\n\n\tchar *format;\n\n\tva_start(args);\n\n\tstring = va_arg(args, char *);\n\n\tformat = va_arg(args, char *);\n\n#endif\n\n\tvsprintf(string, format, args);\n\n\treturn strlen(string);\n\n}\n", "idx": 25167, "substitutes": {"format": ["f", "pretty", "type", " fmt", "join", "args", "force", "len", "atter", "term", "unit", "att", "value", "at", " Format", "command", "act", "cat", "spec", "list", "fn", " formatted", "mat", "prefix", "Format", "function", "form", "tag", "layout", "print", "file", "ats", "feat", "flat", "template", "text", "color", "style", "mt", "self", "pattern", "edit", "arg", "str"]}}
{"project": "FFmpeg", "commit_id": "5a412a5c3cc216ae1d15e6b884bda7214b73a5b0", "target": 1, "func": "static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,\n\n                                   uint8_t **data, int *size)\n\n{\n\n    static const int extradata_nal_types_hevc[] = {\n\n        HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,\n\n    };\n\n    static const int extradata_nal_types_h264[] = {\n\n        H264_NAL_SPS, H264_NAL_PPS,\n\n    };\n\n\n\n    ExtractExtradataContext *s = ctx->priv_data;\n\n\n\n    H2645Packet h2645_pkt = { 0 };\n\n    int extradata_size = 0;\n\n    const int *extradata_nal_types;\n\n    int nb_extradata_nal_types;\n\n    int i, has_sps = 0, has_vps = 0, ret = 0;\n\n\n\n    if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n\n        extradata_nal_types    = extradata_nal_types_hevc;\n\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);\n\n    } else {\n\n        extradata_nal_types    = extradata_nal_types_h264;\n\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);\n\n    }\n\n\n\n    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,\n\n                                ctx, 0, 0, ctx->par_in->codec_id, 1);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < h2645_pkt.nb_nals; i++) {\n\n        H2645NAL *nal = &h2645_pkt.nals[i];\n\n        if (val_in_array(extradata_nal_types, nb_extradata_nal_types, nal->type)) {\n\n            extradata_size += nal->raw_size + 3;\n\n            if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n\n                if (nal->type == HEVC_NAL_SPS) has_sps = 1;\n\n                if (nal->type == HEVC_NAL_VPS) has_vps = 1;\n\n            } else {\n\n                if (nal->type == H264_NAL_SPS) has_sps = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (extradata_size &&\n\n        ((ctx->par_in->codec_id == AV_CODEC_ID_HEVC && has_sps && has_vps) ||\n\n         (ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {\n\n        AVBufferRef *filtered_buf;\n\n        uint8_t *extradata, *filtered_data;\n\n\n\n        if (s->remove) {\n\n            filtered_buf = av_buffer_alloc(pkt->size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!filtered_buf) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            filtered_data = filtered_buf->data;\n\n        }\n\n\n\n        extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!extradata) {\n\n            av_buffer_unref(&filtered_buf);\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n\n\n        *data = extradata;\n\n        *size = extradata_size;\n\n\n\n        for (i = 0; i < h2645_pkt.nb_nals; i++) {\n\n            H2645NAL *nal = &h2645_pkt.nals[i];\n\n            if (val_in_array(extradata_nal_types, nb_extradata_nal_types,\n\n                             nal->type)) {\n\n                AV_WB24(extradata, 1); // startcode\n\n                memcpy(extradata + 3, nal->raw_data, nal->raw_size);\n\n                extradata += 3 + nal->raw_size;\n\n            } else if (s->remove) {\n\n                AV_WB24(filtered_data, 1); // startcode\n\n                memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);\n\n                filtered_data += 3 + nal->raw_size;\n\n            }\n\n        }\n\n\n\n        if (s->remove) {\n\n            av_buffer_unref(&pkt->buf);\n\n            pkt->buf  = filtered_buf;\n\n            pkt->data = filtered_buf->data;\n\n            pkt->size = filtered_data - filtered_buf->data;\n\n        }\n\n    }\n\n\n\nfail:\n\n    ff_h2645_packet_uninit(&h2645_pkt);\n\n    return ret;\n\n}\n", "idx": 25179, "substitutes": {"ctx": ["cmp", "ca", "c", "that", "tc", "mem", "gz", "pool", "p", "ct", "work", "ij", "history", "fc", "gc", "pkg", "tx", "cf", "obj", "Context", "conn", "bc", "config", "at", "scl", "func", "cp", "sc", "buf", "setup", "co", "anc", "mc", "handle", "hw", " cx", "context", "x", "jac", "kt", "k", "abc", "ck", "act", "nc", "cm", "cfg", "a", "cas", "addr", "kw", "kind", "xp", "tmp", "cc", "wx", "lc", "cv", "this", "iat", "null", "g", "cmd", "cn", "cb", "np", "req", "xc", "ac", "unc", "txt", "self", "jp", "t", "conv", "conf"], "pkt": ["Pet", "ptx", "ppkt", "pet", "apacket", " pwk", " pct", "Ptx", "apkt", "dacket", "ppet", " packet", "cpacket", "cpet", "packet", "det", " ptx", "Packet", "pct", "apct", "Pwk", " pet", "dkg", "cptx", "Pct", "Pkt", "ppkg", "ppacket", "apwk", "pwk", "cpkt", "pkg", "dkt", " pkg"], "data": ["type", "batch", "length", "out", "ata", "box", "d", "w", "def", "value", "id", "body", "read", "buffer", "n", "p", "cache", "bytes", "buf", "input", "image", "Data", "raw", "next", "file", "a", "da", "dat", "addr", "text", "window", "bin", "DATA", "t", "content", "format", "name", "mu"], "size": ["sn", "type", "length", "space", "address", "len", "code", "fee", "c", "id", "read", "mem", "empty", "g", "send", "n", "count", "ize", "use", "sent", "mode", "bytes", "set", "area", "magic", "pos", "total", "shape", "start", "scale", "SIZE", "z", "num", "sp", "time", "Size", "offset", "max", "end", "sum", "name"], "extradata_nal_types_hevc": ["extradata_nal_types_herck", "extradata_nal_types_hervc", "extradata_nal_types_hervin", "extradata_nal_types_hux", "extradata_nal_types_herVC", "extradata_nal_types_hyux", "extradata_nal_types_hyvc", "extradata_nal_types_wevc", "extradata_nal_types_hdck", "extradata_nal_types_hevp", "extradata_nal_types_hdvc", "extradata_nal_types_hvp", "extradata_nal_types_hyxc", "extradata_nal_types_hdVC", "extradata_nal_types_hVC", "extradata_nal_types_hck", "extradata_nal_types_heck", "extradata_nal_types_hvc", "extradata_nal_types_hxc", "extradata_nal_types_chec", "extradata_nal_types_chevp", "extradata_nal_types_hvin", "extradata_nal_types_hdvin", "extradata_nal_types_wec", "extradata_nal_types_hexc", "extradata_nal_types_hevin", "extradata_nal_types_hyvp", "extradata_nal_types_hec", "extradata_nal_types_chexc", "extradata_nal_types_heVC", "extradata_nal_types_heux", "extradata_nal_types_chevc", "extradata_nal_types_wevp", "extradata_nal_types_weVC", "extradata_nal_types_hc", "extradata_nal_types_cheVC", "extradata_nal_types_cheux"], "extradata_nal_types_h264": ["extradata_nal_types_hvm", "extradata_nal_types_h323", "extradata_nal_types_oh264", "extradata_nal_types_vtml", "extradata_nal_types_h64", "extradata_nal_types_H323", "extradata_nal_types_w64", "extradata_nal_types_eh323", "extradata_nal_types_eh264", "extradata_nal_types_ehvp", "extradata_nal_types_H264", "extradata_nal_types_ohvm", "extradata_nal_types_H265", "extradata_nal_types_wvp", "extradata_nal_types_h265", "extradata_nal_types_hvp", "extradata_nal_types_phtml", "extradata_nal_types_w263", "extradata_nal_types_h263", "extradata_nal_types_v64", "extradata_nal_types_html", "extradata_nal_types_w265", "extradata_nal_types_eh263", "extradata_nal_types_ph64", "extradata_nal_types_w264", "extradata_nal_types_oh64", "extradata_nal_types_vvm", "extradata_nal_types_v264", "extradata_nal_types_ohtml", "extradata_nal_types_w323", "extradata_nal_types_phvm", "extradata_nal_types_H64", "extradata_nal_types_ph264"], "s": ["sys", "sn", "x", "sa", "sb", "d", "w", "c", "ds", "g", "n", "p", "sc", "sw", "S", "ss", "a", "ns", "ps", "z", "sp", "gs", "e", "sv", "sg", "t", "v", "sq"], "extradata_nal_types": ["extradata_nalid_names", "extradata_nals_names", "extradata_nals_types", "extradata_nal_modules", "extradata_nalitynames", "extradata_nal_type", "extradata_nals_modules", "extradata_nals_type", "extradata_nals_Types", "extradata_nalitymodules", "extradata_nalid_type", "extradata_nalitytypes", "extradata_nals_keys", "extradata_nal_keys", "extradata_nals_packages", "extradata_nalitypackages", "extradata_nal_packages", "extradata_nal_names", "extradata_nal_Types", "extradata_nalid_types"], "nb_extradata_nal_types": ["nb_extradata_nal2Types", "nb_extradata_nalxtype", "nb_extradata_nalximages", "nb_extradata_nals_pes", "nb_extradata_nal_names", "nb_extradata_nalxtypes", "nb_extradata_nal2type", "nb_extradata_nal_Types", "nb_extradata_nals_type", "nb_extradata_nals_ypes", "nb_extradata_nal_pes", "nb_extradata_nals_names", "nb_extradata_nals_types", "nb_extradata_nal_type", "nb_extradata_nal2pes", "nb_extradata_nal_images", "nb_extradata_nal2types", "nb_extradata_nal_ypes", "nb_extradata_nals_images", "nb_extradata_nals_Types"], "i": ["ji", "it", "ic", "x", "batch", "ui", " j", "multi", " di", "\u0438", "o", "us", "ami", "pi", "c", " ii", " ni", "ini", "index", "ri", "fi", "g", "gu", "me", "gi", "in", "I", "p", " bi", "di", "zi", "sim", "j", "ai", "asi", "mi", "li", "ii", "hi", "ti", "ind", "info", "bi", " ti", "ip", " mi", "y", "ims", "ci", "ij", "e", "iu", "xi", "si", "im", "m", "cli", " index", "qi", "ei", "ix"], "nal": [" hasnalog", " hasnald", " nial", "nale", "nial", "annale", " nAL", "aneal", " neal", " nalog", "nnAL", "nnale", "snald", "nnial", "annAL", "snalog", "anAL", " nals", "nAL", "annal", "Neal", " hasnal", " nald", " nale", "nals", "Nals", "annial", "anal", "nald", "nnal", "nalog", " hasnals", "Nal", "snals", "NAL", "anals", "snal", "neal"]}}
{"project": "FFmpeg", "commit_id": "0409d333115e623b5ccdbb364d64ca2a52fd8467", "target": 1, "func": "static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,\n\n                                       int16_t *src2,\n\n                                       int height, int denom, int wx0, int wx1,\n\n                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width)\n\n{\n\n    int x, y;\n\n    pixel *src = (pixel *)_src;\n\n    ptrdiff_t srcstride  = _srcstride / sizeof(pixel);\n\n    pixel *dst          = (pixel *)_dst;\n\n    ptrdiff_t dststride = _dststride / sizeof(pixel);\n\n    const int8_t *filter = ff_hevc_epel_filters[mx - 1];\n\n    int shift = 14 + 1 - BIT_DEPTH;\n\n    int log2Wd = denom + shift - 1;\n\n\n\n    ox0     = ox0 * (1 << (BIT_DEPTH - 8));\n\n    ox1     = ox1 * (1 << (BIT_DEPTH - 8));\n\n    for (y = 0; y < height; y++) {\n\n        for (x = 0; x < width; x++)\n\n            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +\n\n                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));\n\n        src  += srcstride;\n\n        dst  += dststride;\n\n        src2 += MAX_PB_SIZE;\n\n    }\n\n}\n", "idx": 25181, "substitutes": {"_dst": ["_dsts", " _dasts", " _ssrc", " _drd", " _srd", " _sst", "_dsrc", "_dssrc", "_sdest", "_ststs", "_dasts", "_dapt", "_ddest", " _dapt", "_ssrc", "_dlsrc", " _dpt", " _sdest", "_dpt", "_drd", " _dsts", "_dldest", "_dadest", " _dsrc", " _dadest", "_stpt", "_stdest", "_dlst", "_dast", "_dsst", "_dsrd", "_sst", " _dast", " _ddest", "_dsdest", "_dlrd", "_srd", "_stst"], "_dststride": ["_dthstride", "_dststringider", "_dthstringide", "_dstzide", "_dstrider", "_dststringide", "_dstSTRide", "_dststringride", "_dstSTRride", "_dststringage", "_dstsage", "_ddstrage", "_dthstrride", "_dststrride", "_dstrride", "_ddstringide", "_ddstrider", "_dststrend", "_dstzride", "_dststrage", "_dstrage", "_dstride", "_dstside", "_dstzend", "_dstzope", "_dstsride", "_dstsider", "_dthstringope", "_ddstrride", "_dthstringride", "_dthstrend", "_dthstrope", "_ddstringride", "_dststrider", "_dthstringend", "_ddstringider", "_dststringend", "_dstSTRend", "_dstSTRope", "_dststringope", "_ddstringage", "_dststrope", "_ddstride"], "_src": ["tsource", "tsrc", "tsn", "devsrc", "_source", "_sn", " _rc", " _source", "devsn", "trc", "devsource", "_rc", "tinst", "devrc", " _inst", " _sn", "_inst"], "_srcstride": ["_srcSTRide", "_srcctrice", "_srcdride", "_srcstide", "_srctrider", "_rcstride", "_srcconstide", "_srcSTRride", "_srcSTRension", "_rcstrice", "_rcstrride", "_stattride", "_statstride", "_srcstice", "_srctrride", "_srctride", "_srcstend", "_rcstice", "_statstrride", "_rcstrend", "_srcstrend", "_srcctrride", "_statstrider", "_srcdrend", "_stattrride", "_stattrension", "_statstrension", "_rcstide", "_srcctride", "_srcconstension", "_srcconstider", "_srcstrice", "_srcconstride", "_srcctrend", "_srcSTRider", "_rcstend", "_stattrider", "_srcdrice", "_srcstrider", "_srcstrension", "_srcstrride", "_srctrension", "_srcdrride"], "src2": ["source0", "source1", " src1", "rc0", " src4", "src1", "ser2", "src3", "source4", "source3", "ser4", "rc3", "sr2", "ser1", "src0", "source2", "rc2", "rc1", "sr1", "rc4", "src4", " src0", " src3", "sr4"], "height": ["padding", "length", "ih", "power", "wh", "w", "ow", "hang", "ty", "hs", "high", "row", "top", "count", "inches", "hz", "rows", " Height", "ht", "hei", "depth", "th", "html", "capacity", "rank", "size", "scale", "volume", "ish", "window", "history", "num", "H", "resolution", "h", "Height", "max", "radius", "density", "oom", "bottom"], "denom": ["denometry", "sunorm", "enom", "Denorm", "Denomin", "dnomin", "enoms", "Denom", "Denoms", "sunom", "denomin", "sunoms", " denum", "enorm", "denoms", "sunometry", "Denometry", "Denum", " denoms", "dnum", "denorm", "dnoms", "denum", "enometry", "dnom", " denomin"], "wx0": ["rxeros", "tx1", "fxeros", "wx00", "fx3", "fx1", "tx0", "tx00", "rx00", "fx2", "wy3", "txeros", "rx0", "fx0", "wy2", "wxeros", "wy1", "rx3", "wx2", "fx00", "wy0", "wx3", "rx2", "rx1"], "wx1": ["fx01", "fx1", "wx9", "dx1", "exp7", "xp0", "rx01", "xp9", "x9", "exp1", "fx2", "rx0", "x0", "xp7", "fx0", "wx01", "x7", "exp9", "wx2", "exp0", "wx7", "dx01", "x1", "dx2", "rx2", "dx0", "xp1", "rx1"], "ox0": ["ax0", "ax00", "xonZero", "ox00", "owzero", "ux00", "ollzero", "hop0", "xon1", "rox0", "oxzero", "ax1", "ix1", " ox00", "oxZero", "oll1", "xon0", "hop1", "hop00", "xon00", "hopZero", "oxx", "oll0", "rox1", "ix00", " oxZero", "ow1", "ow0", "ix0", "ollx", "roxzero", "axZero", "ux0", "roxx", "ixZero", "owx"], "ox1": ["ax0", "box0", "OX0", "Ox0", "Ox3", "box01", "OxOne", "OX1", "ox01", "oxy3", "ox3", "ock2", "oxOne", "oxyOne", " ox01", "ow4", "oxy0", "ock1", "owOne", "oxy1", "ax1", "OX4", "ox2", "ow2", "boxOne", "ow3", "ax01", "OX2", "ox4", "box3", "Ox1", " oxOne", "ock4", " ox3", "ow1", "ow0", "box1", "ock0", "axOne"], "mx": ["vm", "fx", "sys", "pm", "ms", "tm", "ux", "tx", "xy", "ix", "tf", "wm", "ex", "yx", "mm", "bm", "dx", "rx", "cp", "hz", "ax", "cm", "xx", "mi", "nz", "xs", "zx", "ti", "xc", "ip", "mr", "ox", "mn", "px", "tp", "xe", "ey", "xp", "xi", "ml", "m", "wx", "MX"], "my": ["mys", "ms", "pm", "xy", "ma", "mb", "ty", "yy", "mm", "bm", "mk", "mon", "MY", "axy", "wy", "ny", "ery", "sym", "mi", "cy", "yo", "vy", "py", "wi", "mt", "ys", "ky", "oy", "ym"], "x": ["fx", "xa", "ch", "i", "ux", "tx", "on", "o", "cross", "xy", " w", "ick", "ph", "col", "att", "w", " i", "xt", "ex", "yx", "index", "k", "_", "ect", "at", "ry", "ty", "dx", "act", "rx", "g", "path", "r", "row", "n", "p", "el", "ace", "inx", "ax", "column", "lat", "j", "X", "xx", "xxx", "image", "xf", "l", "xc", "ct", "php", "ox", "key", "z", "px", "e", "ey", "by", "time", "xp", "xi", "h", "im", "q", "m", "v", "ix"], "y": ["sys", "ch", "i", "gy", "o", "xy", "dy", "ay", "col", "yt", "v", "w", "c", "index", "sky", "ry", "ty", "yy", "at", "uy", "iy", "ady", "axy", "p", "wy", "ny", "ym", "ye", "j", "lat", "ht", "ot", "cy", "vy", "any", "b", "l", "py", "yr", "ies", "key", "z", "ey", "by", "ya", "h", "t", "sy", "m", "Y"], "src": ["sys", "sn", "sb", "out", "stream", "rl", "ins", "syn", "rs", "usc", "sub", "rc", "ctr", "screen", "ul", "sl", "sup", "sel", "sync", "in", "inst", "r", "resource", "sr", "supp", "pixel", "fn", "spec", "sc", "s", "img", "ser", "dest", "sort", "input", "scan", "desc", "loc", "txt", "st", "bin", "fc", "sing", "obs", "source", "tr", "tmp", "proc", "filename", "sq"], "dst": ["dlsp", "Dput", "adset", "dsp", "lst", "lport", "dlst", " dsp", "dset", "dsc", "dsist", "dsbl", "Dist", "dlport", "Dst", " dist", "sdport", "sdst", "adest", "dest", "dport", "dist", "adst", "dlsc", "dsst", "lsp", " dbl", "Dest", "sdsc", " dput", " dest", "dput", "lsc", " dset", "adsp", "dsput", "sdsp", "Dsp", "Dbl", "Dset", "dbl"], "filter": ["block", "attribute", "pack", "batch", "field", "match", "stream", "Filter", "feature", "ff", "term", "config", "map", "word", "fl", "pixel", "transform", "form", "image", "scale", "fil", "alpha", "bin", "channel", "source", "format", "proc", "conv"]}}
{"project": "qemu", "commit_id": "9d8256ebc0ef88fb1f35d0405893962d20cc10ad", "target": 1, "func": "void sdl2_gl_scanout(DisplayChangeListener *dcl,\n\n                     uint32_t backing_id, bool backing_y_0_top,\n\n\n                     uint32_t x, uint32_t y,\n\n                     uint32_t w, uint32_t h)\n\n{\n\n    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);\n\n\n\n    assert(scon->opengl);\n\n    scon->x = x;\n\n    scon->y = y;\n\n    scon->w = w;\n\n    scon->h = h;\n\n    scon->tex_id = backing_id;\n\n    scon->y0_top = backing_y_0_top;\n\n\n\n    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);\n\n\n\n    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {\n\n        sdl2_set_scanout_mode(scon, false);\n\n        return;\n\n    }\n\n\n\n    sdl2_set_scanout_mode(scon, true);\n\n    if (!scon->fbo_id) {\n\n        glGenFramebuffers(1, &scon->fbo_id);\n\n    }\n\n\n\n    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);\n\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\n                              GL_TEXTURE_2D, scon->tex_id, 0);\n\n}", "idx": 25182, "substitutes": {"dcl": ["dspl", " dfl", " dpl", "dnCL", "cdcl", "edCl", "dpl", "cdfl", "dfl", "cdlc", "dCL", "sdCL", " dlc", "dscl", "dsCL", " dsl", "dncl", "edfl", "dlc", " dCL", "dcr", "dnpl", "dsl", "sdsl", "dscr", "cdCl", " dcr", " dCl", "edcl", "sdcr", "sdpl", "dnsl", "edlc", "dCl", "sdcl"], "backing_id": ["backingOId", "backingOpid", "backing___on", "backding_key", "backowing_id", "backing___name", "backowing_Id", "backing_on", "backing__name", "backing___key", "backing__on", "backding_on", "backing___pid", "backing_key", "backing__key", "backing__id", "backing___Id", "backing_name", "backingOid", "backding_name", "backing_Id", "backing___id", "backing_pid", "backding_id", "backowing_pid"], "backing_y_0_top": ["backing_y_0_origin", "backing_y_0_to", "backing_y_0sbottom", "backing_y_0xorigin", "backing_y_0_bottom", "backing_y_zeroxpos", "backing_y_zero_top", "backing_y_0__part", "backing_y_zeroxtop", "backing_y_zeroxbottom", "backing_y_no_bottom", "backing_y_0__to", "backing_y_no_part", "backing_y_0_part", "backing_y_0sorigin", "backing_y_0spos", "backing_y_no_to", "backing_y_no_top", "backing_y_0xtop", "backing_y_0_pos", "backing_y_0stop", "backing_y_0xpos", "backing_y_zeroxorigin", "backing_y_zero_pos", "backing_y_zero_origin", "backing_y_zero_bottom", "backing_y_0__top", "backing_y_0xbottom", "backing_y_0__bottom"], "x": ["f", "fx", "i", "ux", "tx", " dx", "xy", "west", "xml", "ex", "yx", "id", "c", "index", "dx", "rx", "g", "ross", "r", "n", "p", "s", "X", "xx", "a", "l", "ox", "z", "window", "px", "e", "current", "xi", "t", "m", "v", "wx", "ix"], "y": ["my", "i", "gy", "xy", "dy", "hot", "ay", "yt", "v", "sky", "ry", "icy", "yy", "iy", "yer", "height", "iny", "top", "axy", "p", "s", "wy", "ny", "ery", "ye", "cy", "vy", "hy", "b", "l", "py", "isy", "z", "very", "ey", "ya", "oy", "t", "Y", "ym", "sy", "ly"], "w": ["f", "wid", "W", "fw", "wh", "d", "wm", "c", "ew", "wd", "ww", "wr", "wl", "what", "g", "n", "p", "we", "sw", "nw", "words", "wa", "b", "l", "weight", "wb", "wp", "wt", "window", "wn", "wind", "z", "rw", "wal", "win", "kw", "q", "t", "m", "v", "wx"], "h": ["f", "it", "hd", "ch", "i", "ih", "hash", "ph", "host", "he", "wh", "d", "hr", "c", "pp", "k", "hang", "rh", "uth", "hm", "height", "ah", "top", "p", "hhh", "kh", "hz", "s", "sh", "hal", "oh", "ht", "th", "hi", "a", "b", "l", "ac", "history", "z", "window", "uh", "bh", "ha", "H", "hh", "hl", "u", "t", "q", "m", "v", "ho"], "scon": ["gscon", " sconf", "sdon", "wsconv", "rsconst", "SCon", "pscon", "nsconn", "tsCon", "esoon", "hsconn", "Sco", "stsCon", "simplecon", "rscons", "Scon", "svcon", "stscon", "ascon", "scn", "atsco", "rscon", "nsdon", "oscon", "adsco", "sco", "tsconv", "sconst", "ascn", "dscons", "rsconn", "rsconf", "simplecons", "Scons", "osconv", "jscon", "pscons", "atsconn", "esconn", "adsconf", "Sconf", "lesscon", "jsconst", "escon", "lessconn", "atsconnect", "exdon", "dsconn", "sconn", "lessconf", "jsconn", "lessoon", "atsconv", "simpleconv", "jsco", "atsconst", " sconn", "jsconv", "soon", "asconst", "nscons", "lessconst", "hscons", " sconst", "wscons", "exconv", "gsconv", " sco", " sconv", "oscn", "statsconn", "statsconst", "tsconn", "sconv", "gsmon", "psconst", "Sconst", "svcons", "wsconn", "excons", "rsconv", "dscon", "statsconf", "hscon", "psdon", "stsconv", "dsconst", "tscon", "esconst", " scons", "asconv", "nsCon", " scn", "Scn", "gsCon", "scons", "lessco", "adscon", "nscn", "jsconf", "simpleconst", "dsdon", "osconst", "stsconst", "dsconv", "nsconv", "asconn", "hsconv", " sCon", "nscon", "atsoon", "adsconn", "tsconst", "sCon", "wscon", "excon", "nsmon", "svCon", "nsconf", "psconv", "nsconst", "lessconnect", "svco", "sconnect", "gsconst", "gscons", "stsmon", "statscon", "smon", "sconf", "Sconn", "atscon", "lesscn"]}}
{"project": "qemu", "commit_id": "40f08e87f613273f9dcc8df7d6a0f574b7d28d05", "target": 1, "func": "static void mm_stop_timer(struct qemu_alarm_timer *t)\n\n{\n\n    timeKillEvent(mm_timer);\n\n    timeEndPeriod(mm_period);\n\n}\n", "idx": 25185, "substitutes": {"t": ["f", "tm", "w", "c", "tc", "tt", "tz", "tn", "g", "r", "n", "p", "dt", "tty", "tim", "a", " T", "ts", "T", "bt", "tp", "e", "tr", "vt", "tmp", "m", "v", "tap"]}}
{"project": "qemu", "commit_id": "5c32be5baf41aec4f4675d2bf24f9948756abf3c", "target": 1, "func": "static void tcg_out_qemu_st(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop,\n\n                             offsetof(CPUTLBEntry, addr_write));\n\n\n\n    /* The fast path is exactly one insn.  Thus we can perform the entire\n\n       TLB Hit in the (annulled) delay slot of the branch over TLB Miss.  */\n\n    /* beq,a,pt %[xi]cc, label0 */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n    if (!SPARC64 && (memop & MO_SIZE) == MO_64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, data);\n\n\n\n    func = qemu_st_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    tcg_debug_assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n", "idx": 25189, "substitutes": {"s": ["sys", "ms", "i", "x", "as", "sb", "out", "o", "os", "ties", "comm", "fs", "rs", "w", "us", "c", "ses", "ds", "hs", "g", "r", "spec", "n", "p", "bis", "cs", "sts", "sw", "set", "an", "j", "ctx", "S", "js", "ss", "a", "is", "b", "ns", "ts", "ps", "ims", "sm", "y", "stats", "z", "qs", "es", "its", "e", "gs", "sv", "less", "sg", "self", "source", "h", "t", "q", "ls", "m", "socket", "this", "series"], "data": ["ad", "o", "obj", "address", "ata", "re", "d", "map", "id", "rc", "reg", "mem", "buffer", "r", "p", "cache", "fn", "rec", "rel", "msg", "di", "extra", "ctx", "np", "Data", "da", "ns", "size", "info", "dr", "attr", "dat", "src", " mem", "bin", "val", "DATA", "ptr", "t", "no", "m", "str", "name", "mu", "res"], "addr": ["x", "ad", "tx", "obj", "adr", "address", "ref", "ata", "pad", "rs", "map", "id", "rc", "nl", "index", " ip", "mem", "rr", "gz", "var", "target", "r", "cmd", "arg", "alias", "ord", "add", "msg", "usr", "ctx", "coord", "pos", " address", "np", "a", "attr", "ag", "dr", "ip", "src", " mem", "url", "loc", "link", "mt", "ptr", "offset", "pkg", "t", "oa", "m", "v", "str", "name", "hw"], "oi": ["iri", "i", "ui", "o", "ovi", " di", "igi", "ano", "xy", "rio", "obj", "ami", "obo", " ki", "eni", "pi", "ilo", "ini", "cpu", "mx", " mic", "coe", " bi", "bis", "pointer", "avi", "ois", " vi", "ori", "odi", "ctx", "asi", "mi", "ta", "oin", "uci", "oid", "ti", "eta", "uti", " tv", "attr", " ti", " pi", "bi", " mi", "ati", " iso", "eric", "udi", "ico", "ip", "link", "osi", " nic", " tid", "fp", "iso", "offset", "xi", "si", "off", "oa", "obi", "tmp", "ei"], "addrz": [" addrld", "addrj", "addrzo", " addrzone", "areazo", " addru", "addressZ", "ptrzone", "adru", "adrj", "ptrzo", "areaz", " addrzo", " addrj", "addressz", "ptrld", "areaj", "addrZ", " addrZ", "adrz", "offsetz", "offsetj", "offsetu", "addru", "addrld", "ptrz", "addresszone", "addrzone", "areald", "ptrj", "ptrZ"], "param": ["vm", "padding", "prop", "dim", "perm", "field", "cal", "min", "ref", "address", "pri", "col", "nam", "part", "config", "value", "index", "cpu", "error", "meter", "mem", "mm", "params", "var", "command", "member", "row", "comment", "p", "count", "alias", "prefix", "resp", "pointer", "dm", "par", "mod", "call", "imm", "sym", "Param", "pos", "coord", "ctx", "tag", "rank", "req", "attr", "mark", "weight", "info", "fac", "position", "num", "flag", "label", "offset", "admin", "tmp", "sum", "arg", "prom", "method", "m", "aram"], "func": ["f", "sys", "amd", "cf", "args", "obj", "fw", "lc", "result", "var", "act", "lambda", "cast", "cmd", "cond", "fn", "nc", "util", "cb", "call", "ctx", "function", "doc", "comp", "attr", "ac", "unc", "fun", "fac", "expr", "must", "con", "fc", "aux", "exec", "kw", "cc", "proc", "conv", "str", "callback"], "label_ptr": ["abel_ptr", " label_set", "abel_pointer", " label_pos", "labelmyptr", "label__ptr", "label_Ptr", "label_addr", "label_ctr", "labelmyaddr", "Label_addr", "abel_Ptr", "label__addr", "abel_addr", "label_pos", "label_set", "labelmypos", "label__offset", "label_offset", "Label_ptr", "Label_offset", "label_pointer", "Label_pointer", " label_ctr", "labelmyset", "label__pointer", " label_addr"]}}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "QEMUFile *qemu_fopen_fd(int fd)\n\n{\n\n    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));\n\n\n\n    if (s == NULL)\n\n        return NULL;\n\n\n\n    s->fd = fd;\n\n    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);\n\n    return s->file;\n\n}\n", "idx": 25223, "substitutes": {"fd": ["f", "sd", "fb", "pd", "hd", "ld", " d", "dir", "nd", "ff", " df", " dur", "fee", "fs", "d", " ed", "id", "cd", "dc", "bf", "ds", " ff", " fin", "fl", "fin", " td", " sd", "fi", "db", "ed", " filed", "pid", "ord", " fid", "buf", "fed", "ctx", "df", "td", "ind", " db", "size", "dl", "dd", "dat", "bd", "wind", "handle", "fc", "ud", "fp", "FD", "ptr", " fs", " f", "od"], "s": ["comm", "c", "sam", "r", "p", "S", "ns", "save", "sm", "y", "states", "ies", "less", "h", "v", "sq", "sd", "sa", "sb", "rs", "sl", "spec", "n", "sc", "cs", "services", "als", "ats", "ts", "its", "eds", "parts", "m", "sys", "as", "ins", "gets", "sts", "bs", "a", "is", "b", "l", "ps", "stats", "gs", "sf", "ls", "f", "ports", "se", "fs", "sol", "w", "ds", "hs", "params", "details", "g", "sh", "set", "js", "outs", "ss", "start", "qs", "es", "e", "sv", "self", "source", "t", "su"]}}
{"project": "FFmpeg", "commit_id": "04763c6f87690b31cfcd0d324cf36a451531dcd0", "target": 1, "func": "static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,\n\n                                       int *mb_type)\n\n{\n\n    int b8_stride = 2;\n\n    int b4_stride = h->b_stride;\n\n    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;\n\n    int mb_type_col[2];\n\n    const int16_t (*l1mv0)[2], (*l1mv1)[2];\n\n    const int8_t *l1ref0, *l1ref1;\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    unsigned int sub_mb_type = MB_TYPE_L0L1;\n\n    int i8, i4;\n\n    int ref[2];\n\n    int mv[2];\n\n    int list;\n\n\n\n    assert(sl->ref_list[1][0].reference & 3);\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent,\n\n                           sl->mb_y + !!IS_INTERLACED(*mb_type));\n\n\n\n#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \\\n\n                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)\n\n\n\n    /* ref = min(neighbors) */\n\n    for (list = 0; list < 2; list++) {\n\n        int left_ref     = sl->ref_cache[list][scan8[0] - 1];\n\n        int top_ref      = sl->ref_cache[list][scan8[0] - 8];\n\n        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];\n\n        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];\n\n        if (refc == PART_NOT_AVAILABLE) {\n\n            refc = sl->ref_cache[list][scan8[0] - 8 - 1];\n\n            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];\n\n        }\n\n        ref[list] = FFMIN3((unsigned)left_ref,\n\n                           (unsigned)top_ref,\n\n                           (unsigned)refc);\n\n        if (ref[list] >= 0) {\n\n            /* This is just pred_motion() but with the cases removed that\n\n             * cannot happen for direct blocks. */\n\n            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];\n\n            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];\n\n\n\n            int match_count = (left_ref == ref[list]) +\n\n                              (top_ref  == ref[list]) +\n\n                              (refc     == ref[list]);\n\n\n\n            if (match_count > 1) { // most common\n\n                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),\n\n                                      mid_pred(A[1], B[1], C[1]));\n\n            } else {\n\n                assert(match_count == 1);\n\n                if (left_ref == ref[list])\n\n                    mv[list] = AV_RN32A(A);\n\n                else if (top_ref == ref[list])\n\n                    mv[list] = AV_RN32A(B);\n\n                else\n\n                    mv[list] = AV_RN32A(C);\n\n            }\n\n        } else {\n\n            int mask = ~(MB_TYPE_L0 << (2 * list));\n\n            mv[list]  = 0;\n\n            ref[list] = -1;\n\n            if (!is_b8x8)\n\n                *mb_type &= mask;\n\n            sub_mb_type &= mask;\n\n        }\n\n    }\n\n    if (ref[0] < 0 && ref[1] < 0) {\n\n        ref[0] = ref[1] = 0;\n\n        if (!is_b8x8)\n\n            *mb_type |= MB_TYPE_L0L1;\n\n        sub_mb_type |= MB_TYPE_L0L1;\n\n    }\n\n\n\n    if (!(is_b8x8 | mv[0] | mv[1])) {\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n        return;\n\n    }\n\n\n\n    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n\n        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL\n\n            mb_y  = (sl->mb_y & ~1) + sl->col_parity;\n\n            mb_xy = sl->mb_x +\n\n                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;\n\n            b8_stride = 0;\n\n        } else {\n\n            mb_y  += sl->col_fieldoff;\n\n            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity\n\n        }\n\n        goto single_col;\n\n    } else {                                             // AFL/AFR/FR/FL -> AFR/FR\n\n        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR\n\n            mb_y           =  sl->mb_y & ~1;\n\n            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;\n\n            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];\n\n            b8_stride      = 2 + 4 * h->mb_stride;\n\n            b4_stride     *= 6;\n\n            if (IS_INTERLACED(mb_type_col[0]) !=\n\n                IS_INTERLACED(mb_type_col[1])) {\n\n                mb_type_col[0] &= ~MB_TYPE_INTERLACED;\n\n                mb_type_col[1] &= ~MB_TYPE_INTERLACED;\n\n            }\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&\n\n                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&\n\n                !is_b8x8) {\n\n                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */\n\n            } else {\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        } else {                                         //     AFR/FR    -> AFR/FR\n\nsingle_col:\n\n            mb_type_col[0] =\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {\n\n                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */\n\n            } else if (!is_b8x8 &&\n\n                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n\n                *mb_type |= MB_TYPE_DIRECT2 |\n\n                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));\n\n            } else {\n\n                if (!h->ps.sps->direct_8x8_inference_flag) {\n\n                    /* FIXME: Save sub mb types from previous frames (or derive\n\n                     * from MVs) so we know exactly what block size to use. */\n\n                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */\n\n                }\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        }\n\n    }\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);\n\n\n\n    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];\n\n    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];\n\n    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];\n\n    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];\n\n    if (!b8_stride) {\n\n        if (sl->mb_y & 1) {\n\n            l1ref0 += 2;\n\n            l1ref1 += 2;\n\n            l1mv0  += 2 * b4_stride;\n\n            l1mv1  += 2 * b4_stride;\n\n        }\n\n    }\n\n\n\n    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            int x8  = i8 & 1;\n\n            int y8  = i8 >> 1;\n\n            int xy8 = x8     + y8 * b8_stride;\n\n            int xy4 = x8 * 3 + y8 * b4_stride;\n\n            int a, b;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                ((l1ref0[xy8] == 0 &&\n\n                  FFABS(l1mv0[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv0[xy4][1]) <= 1) ||\n\n                 (l1ref0[xy8] < 0 &&\n\n                  l1ref1[xy8] == 0 &&\n\n                  FFABS(l1mv1[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv1[xy4][1]) <= 1))) {\n\n                a =\n\n                b = 0;\n\n                if (ref[0] > 0)\n\n                    a = mv[0];\n\n                if (ref[1] > 0)\n\n                    b = mv[1];\n\n                n++;\n\n            } else {\n\n                a = mv[0];\n\n                b = mv[1];\n\n            }\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);\n\n        }\n\n        if (!is_b8x8 && !(n & 3))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    } else if (IS_16X16(*mb_type)) {\n\n        int a, b;\n\n\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n            ((l1ref0[0] == 0 &&\n\n              FFABS(l1mv0[0][0]) <= 1 &&\n\n              FFABS(l1mv0[0][1]) <= 1) ||\n\n             (l1ref0[0] < 0 && !l1ref1[0] &&\n\n              FFABS(l1mv1[0][0]) <= 1 &&\n\n              FFABS(l1mv1[0][1]) <= 1 &&\n\n              h->sei.unregistered.x264_build > 33U))) {\n\n            a = b = 0;\n\n            if (ref[0] > 0)\n\n                a = mv[0];\n\n            if (ref[1] > 0)\n\n                b = mv[1];\n\n        } else {\n\n            a = mv[0];\n\n            b = mv[1];\n\n        }\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);\n\n    } else {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            const int x8 = i8 & 1;\n\n            const int y8 = i8 >> 1;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n\n\n            assert(b8_stride == 2);\n\n            /* col_zero_flag */\n\n            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                (l1ref0[i8] == 0 ||\n\n                 (l1ref0[i8] < 0 &&\n\n                  l1ref1[i8] == 0 &&\n\n                  h->sei.unregistered.x264_build > 33U))) {\n\n                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;\n\n                if (IS_SUB_8X8(sub_mb_type)) {\n\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];\n\n                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                        if (ref[0] == 0)\n\n                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        if (ref[1] == 0)\n\n                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        n += 4;\n\n                    }\n\n                } else {\n\n                    int m = 0;\n\n                    for (i4 = 0; i4 < 4; i4++) {\n\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n\n                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                            if (ref[0] == 0)\n\n                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);\n\n                            if (ref[1] == 0)\n\n                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);\n\n                            m++;\n\n                        }\n\n                    }\n\n                    if (!(m & 3))\n\n                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;\n\n                    n += m;\n\n                }\n\n            }\n\n        }\n\n        if (!is_b8x8 && !(n & 15))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    }\n\n}\n", "idx": 25245, "substitutes": {"h": ["help", "ch", "context", "ih", "hash", "host", "dh", "he", "w", "c", "rh", "hs", "zh", "hm", "hp", "ah", "p", "phi", "kh", "s", "sh", "util", "oh", "ctx", "ht", "hi", "l", "history", "bh", "handle", "ha", "H", "hh", "hl", "http", "t", "her", "v", "hw"], "sl": ["cl", "sn", "lit", "sb", "Sl", "ll", "rl", "bl", "slice", "service", "tl", "syn", "sol", "ln", "sil", "nl", "scl", "fl", "zh", "sel", "console", "phi", "SL", "sc", "sh", "asm", "spl", "sw", "sche", "sql", "pl", "isl", "l", "dl", "vl", "sm", "la", "str", "eval", "bh", "coll", "sp", "serv", "hl", "sv", "gl", "il", "pkg", "owl", "kl", "ls", "ml", "jl", "ssl"], "mb_type": ["mblyname", "mblytype", "mb7ype", "MB_type", "mb7Type", "MB_ype", "mb_Type", "mb_no", "mb_class", "MB_no", "mm_class", "MB_name", "mb_name", "mm_type", "mb_ype", "MB_Type", "mb7name", "mm_TYPE", "mblyclass", "mb7type", "mblynumber", "mblyTYPE", "mblyno", "mm_name", "MB_number", "MB_TYPE", "mb_TYPE", "mb_number"], "mb_type_col": ["mb_type_row", "mb_type2row", "mb_type2column", "mb_type2col", "mb_types_row", "mb_type_Col", "mb_type_column", "mb_types_column", "mb_types_Col", "mb_types_col", "mb_type2Col"], "l1mv0": ["l1mva8", "l1mv8", "l1mvc0", "l1mvc1", "l1mva0", "l1mv4", "l1mav1", "l1imvc1", "l1imv4", "l1mva1", "l1imvc8", "l1mvc4", "l1mva4", "l1imv0", "l1imv8", "l1imv1", "l1mav8", "l1mav4", "l1mvc8", "l1imvc0", "l1imvc4", "l1mav0"], "l1mv1": ["l1mvc0", "l1mvc1", "l1mV2", "l1mav1", "l1imvc1", "l1imvc2", "l1mv2", "l1imv0", "l1mav2", "l1imv2", "l1mvc2", "l1imv1", "l1mV1", "l1imvc0", "l1mav0", "l1mV0"], "l1ref0": ["l1ref2", "l2ref0", "l1reference0", "l1rel0", "l1re2", "l2ref2", "l1re1", "l2rel1", "l1rel2", "l1reference2", "l1rel1", "l2ref1", "l2rel0", "l1reference1", "l2rel2", "l1re0"], "l1ref1": ["l1ref2", "l0ref0", "l1refy", "l1reference0", "l1rel0", "l1rem0", "l0rel0", "l0refy", "l1remy", "l1rem1", "l1rem2", "l0rel1", "l1rely", "l0ref1", "l1referencey", "l0rel2", "l0ref2", "l1rel2", "l1reference2", "l1rel1", "l1reference1", "l0rely"], "i8": ["b4", "b08", "pi8", "b8", " i6", "i6", "pi08", "pi6", " i08", "i08", "pi4", "b6"], "i4": ["int4", "ip44", " i24", "int44", "ip24", "ip4", " i44", "i44", "int24", "i24"], "ref": ["range", "f", "type", "ef", "out", "obj", "reference", "null", "br", "mb", "col", "def", "map", "id", "index", "result", "mem", "buffer", "row", "p", "REF", "tab", "pointer", "rel", "ob", "resp", "pos", "ap", "rep", "Ref", "req", "loc", "val", "ret", "table", "all", "arg", "point", "ro", "conf"], "mv": ["rmvc", "Mvc", "MV", "mvc", "rmv", " mV", "rmV", "mav", "Mv", "rmav", " mav", " mvc", "Mav", "mV"], "list": ["range", "alt", "queue", "status", "array", "lists", "map", "id", "cont", "lt", "count", "call", "can", "pl", "li", "dl", "info", "page", "base", "listed", "table", "dict", "detail", "lvl", "parent", "i", "item", "code", "try", "entry", "error", "header", "spec", "add", "msg", "level", "chain", "ind", "reason", "net", "ist", "card", "type", "batch", "L", "def", "ul", "comment", "low", "print", "back", "old", "l", "test", "LIST", "st", "number", "stat", "all", "no", "stack", "alist", "block", "out", "err", "null", "commit", "result", "List", "local", "row", "record", "set", "line", "feat", "flat", "e", "loop", "index", "name"], "C": ["Q", "CC", "W", "Counter", "JC", "CG", "CCC", "L", "CR", "c", "D", "CU", "CA", "Cache", "CP", "CV", "I", "M", "CL", "K", "Chain", "S", "LC", "O", "V", "E", "CT", "T", "CS", "R", "N", "H", "P", "DC", "G", "F"]}}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static void boston_lcd_event(void *opaque, int event)\n\n{\n\n    BostonState *s = opaque;\n\n    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {\n\n        qemu_chr_fe_printf(&s->lcd_display, \"        \");\n\n        s->lcd_inited = true;\n\n    }\n\n}\n", "idx": 25247, "substitutes": {"opaque": [" opacity", "obaco", "Opaques", "oplacity", "oplaram", "opacity", "opause", " opaques", "obaque", "Opaque", "oparam", "opsaque", "opsause", "Opaco", "opsaram", " oparam", "opsacity", "oply", " oply", "Oply", "oplause", "oplaque", " opaco", "obaques", "obly", " opause", "opaco", "opaques"], "event": ["option", "type", "attribute", "thing", "address", "operation", "entity", "feature", "code", "topic", "ent", "commit", "change", "date", "ENT", "zero", "error", "request", "command", " Event", "what", "comment", " EVENT", "state", "future", "level", "function", "policy", "message", "tag", "image", "release", "task", "vent", "size", "text", "Event", "version", "e", "when", "style", "time", "t", "age", "events", "ion"], "s": ["sys", "sb", "store", "sis", "service", "se", "fs", "sports", "rs", "c", "ds", "hs", "sl", "r", "p", "sts", "sac", "sw", "j", "S", "als", "bs", "ss", "so", "is", "ats", "ts", "ns", "ps", "sm", "y", "states", "qs", "stats", "es", "st", "gs", "serv", "sv", "sp", "source", "ls", "q", "sq", "ess", "ssl"]}}
{"project": "qemu", "commit_id": "ba7806ad92a2f6b1625cfa67d44dc1b71e3be44e", "target": 1, "func": "void add_command(const cmdinfo_t *ci)\n\n{\n\n    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));\n\n    cmdtab[ncmds - 1] = *ci;\n\n    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);\n\n}\n", "idx": 25252, "substitutes": {"ci": ["ic", "CI", "i", "ki", "ce", "cu", "pi", "c", "ini", "dc", "ice", "oci", "fi", "gi", "di", "cm", "ai", "mi", "ii", "uci", "li", "co", "ti", "sci", "cci", "bi", "ati", "ico", "cgi", "ni", "si", "cc", "cli", "cit", "qi", "ani", "ei"]}}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static void openpic_update_irq(OpenPICState *opp, int n_IRQ)\n\n{\n\n    IRQ_src_t *src;\n\n    int i;\n\n\n\n    src = &opp->src[n_IRQ];\n\n\n\n    if (!src->pending) {\n\n        /* no irq pending */\n\n        DPRINTF(\"%s: IRQ %d is not pending\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ipvp & IPVP_MASK_MASK) {\n\n        /* Interrupt source is disabled */\n\n        DPRINTF(\"%s: IRQ %d is disabled\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (IPVP_PRIORITY(src->ipvp) == 0) {\n\n        /* Priority set to zero */\n\n        DPRINTF(\"%s: IRQ %d has 0 priority\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ipvp & IPVP_ACTIVITY_MASK) {\n\n        /* IRQ already active */\n\n        DPRINTF(\"%s: IRQ %d is already active\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ide == 0) {\n\n        /* No target */\n\n        DPRINTF(\"%s: IRQ %d has no target\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n\n\n    if (src->ide == (1 << src->last_cpu)) {\n\n        /* Only one CPU is allowed to receive this IRQ */\n\n        IRQ_local_pipe(opp, src->last_cpu, n_IRQ);\n\n    } else if (!(src->ipvp & IPVP_MODE_MASK)) {\n\n        /* Directed delivery mode */\n\n        for (i = 0; i < opp->nb_cpus; i++) {\n\n            if (src->ide & (1 << i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n            }\n\n        }\n\n    } else {\n\n        /* Distributed delivery mode */\n\n        for (i = src->last_cpu + 1; i != src->last_cpu; i++) {\n\n            if (i == opp->nb_cpus)\n\n                i = 0;\n\n            if (src->ide & (1 << i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n                src->last_cpu = i;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 25260, "substitutes": {"opp": ["ost", "it", "prop", "omp", "cmp", "perm", "typ", "obj", "ok", "ik", "jump", "ff", "op", "iv", "app", "eff", "piece", "ko", "ow", "impl", "pp", "och", "vp", "emp", "ipl", "ipp", "oop", "sup", "hack", "along", "ack", "supp", "pps", "tip", "img", "ripp", "sim", "ppo", "sie", "jit", "isu", "cod", "up", "pl", "setup", "kick", "oper", "comp", "req", "attr", "oc", "ip", "ij", "obb", "upp", "front", "udi", "imp", "pro", "prep", "off", "Opp", "oit", "pkg", "jp", "dep", "buff", "odd", "onet"], "n_IRQ": ["n_IRIQ", "n_ERC", "n_IrQ", "n_MIQB", "nAMIRQUEST", "n_MRQue", "n_IRMQ", "n__VRQ", "n_EARZ", "n__ARQue", "n_IVJ", "n_HRQuery", "n_IREQUEST", "n_MRQ", "n_AIRQUIRE", "n_EARQueue", "n_IMQ", "n_IRQB", "n__ARQ", "n_IRQuery", "n_IMQueue", "n_VRG", "n_WRJ", "n_MIW", "n__VRJ", "n_MIQ", "n_IRCQue", "n_VRQu", "nAMIREQ", "n_DIRQ", "n_ARQ", "n_RELHT", "n_IREJ", "n_RCW", "n_IrC", "n_IVQ", "n_IVQu", "n_IREU", "n_ERW", "n_MRq", "n_VRQUEST", "n_IRHT", "n_EARQ", "n__VRU", "n_IORJ", "nAMIREQUEST", "n_DIRQue", "n_IRC", "n_ARQU", "n_IMIQ", "n_IVHT", "n_IREQue", "n_IRQUIRE", "n_IRCZ", "n_ARQUEST", "n_IRCQueue", "n_irQUEST", "nAMIRG", "n_HRQ", "n_IREQL", "n_IRQUEST", "n_IRJ", "n_IORHT", "n_INTERIQ", "n_AIRQ", "n_IORQ", "n__VRMQ", "n_IRCJ", "n_IMQUEST", "n_IRQL", "nAMIREG", "n_IRQueue", "n_AIRQU", "n__IRZ", "n_HRW", "n_IRQue", "n_IRQU", "n_INTERQUEST", "n_DIRq", "n_Irq", "n_IRCU", "n_ARIQ", "n_IRq", "n_IORIQ", "n_MIQuery", "n_IrQB", "n_IREG", "n_VRMQ", "n__IRQue", "n_IRG", "n_MRQUIRE", "n_RCQ", "n_ARQue", "n__IRJ", "n_IREq", "n_WRQ", "n_irQ", "n_IRZ", "n_RCq", "n_irG", "n_VRQ", "n_VRHT", "n_IrQuery", "n_MRQU", "n__IRQ", "n_ARQUIRE", "n_irQL", "n__IRQueue", "nAMIREQL", "n_RELQu", "n_IREMQ", "n_ERQ", "n_VRJ", "n_VRIQ", "n_EARQue", "n_IRW", "nAMIRQ", "n_IRU", "n_HRQB", "n__ARZ", "n_WRHT", "n__IRMQ", "n_WRIQ", "n_IRQu", "n__ARQueue", "n_RELQ", "n_IRCMQ", "n_ARQueue", "n_IRCQ", "n_IREQ", "n_VRQL", "n_INTERQ", "n_ARZ", "n_VRU", "n_INTERQueue", "n_IrW", "nAMIRQL", "n_ERq", "n_RCC", "n__IRU", "n_RELJ"], "src": ["ost", "cur", "rol", "rl", "stick", "std", "sit", "ctr", "sync", "inst", "soc", "ser", "ctx", "uint", "sec", "nil", "rt", "attr", "loc", "btn", "snap", "stud", "http", "pkg", "iov", "sq", "sn", "sb", "obj", "store", "boot", "syn", "pri", "rs", "usc", "config", "sl", "tn", "sup", "spec", "send", "sc", "buf", "vr", "setup", "desc", "ind", "lib", "sur", "via", "stock", "warn", "sys", "bb", "nn", "ins", "iv", "sub", "rob", "ipp", "sel", "ripp", "sw", "input", "scenes", "bs", "addr", "stats", "st", "tp", "rb", "serv", "tmp", "stat", "str", "this", "ssl", "typ", "stream", "rc", "cmd", "sr", "supp", "ack", "sh", "usr", "dest", "dist", "np", "instance", "scan", "comp", "req", "https", "bj", "txt", "bh", "sing", "hl", "source", "unknown", "proc", "conv"], "i": ["ui", " j", "status", "docker", "ini", "id", " iter", "in", "I", " bi", "ai", "li", " k", "ip", "ij", "y", "ci", " si", "iu", " I", "si", "h", "ei", "ki", "\u0438", "ski", " x", " ni", " ii", "gu", "n", "j", "ind", "ims", "key", "iter", "uri", "m", "qi", "ix", "batch", "x", "multi", "ami", "ri", "phi", "di", "oi", "zi", "go", " v", "mi", "ii", "print", "is", "l", " ti", " pi", "bi", " index", "limit", " m", "xi", "im", "q", "mu", "f", "iri", "it", "ic", "pi", " n", "fi", "me", "gi", "list", " e", "span", "hi", "ti", "php", "shift", "wi", "u", "index", "cli", "init"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,\n\n                struct usb_hci_out_fifo_s *fifo,\n\n                void (*send)(struct HCIInfo *, const uint8_t *, int),\n\n                int (*complete)(const uint8_t *, int),\n\n                const uint8_t *data, int len)\n\n{\n\n    if (fifo->len) {\n\n        memcpy(fifo->data + fifo->len, data, len);\n\n        fifo->len += len;\n\n        if (complete(fifo->data, fifo->len)) {\n\n            send(s->hci, fifo->data, fifo->len);\n\n            fifo->len = 0;\n\n        }\n\n    } else if (complete(data, len))\n\n        send(s->hci, data, len);\n\n    else {\n\n        memcpy(fifo->data, data, len);\n\n        fifo->len = len;\n\n    }\n\n\n\n    /* TODO: do we need to loop? */\n\n}\n", "idx": 25263, "substitutes": {"s": ["sys", "i", "as", "sb", "os", "comm", "fs", "rs", "c", "ses", "ds", "sl", "conf", "sync", "r", "n", "p", "cs", "sts", "aws", "vs", "S", "bs", "js", "ss", "is", "b", "usb", "ts", "ns", "ats", "ps", "qs", "stats", "st", "es", "gs", "e", "sv", "less", "h", "t", "ls", "v", "ssl"], "fifo": ["pedpo", "Fifator", "fifaco", "helpo", "wifeoice", "lifpo", "helo", "histolo", "Fifoe", "Fifan", "fourota", "fenoo", "tipaco", "fifoc", "ritO", " fifodo", "lipi", "fetoe", "fifator", "wifeo", "fetator", " fifoker", "Fifado", "fifi", "fifado", "wifeO", "fifio", "Fifio", "ritaco", "feto", "fedo", "fouro", "heloo", "histano", "fifodo", "fifota", "tipator", " fifano", "rumo", "fenoker", " fifoice", "flexinator", " fifaco", "lifo", " femolo", "Fifo", "Fifpo", "fifpo", "Fifoo", "tippo", "fouroc", " femo", "histO", "fatpo", "flexo", "tipo", "fifano", "lifinator", "ruman", "lifodo", " fifinator", " fifpo", "pedoc", "ligodo", "fifoker", "fetO", "fedaco", "fourado", "fifoo", "fetodo", "fifan", "histo", "feno", " femO", " fifota", "fifinator", "lipo", "Fifi", "liginator", "flexodo", "rumado", "fatolo", "fourpo", "fifoice", "rumpo", "fetoo", "fifoe", "lifoo", "fetpo", "rito", "wifeaco", "lippo", "fetaco", " fifolo", "fenO", "ligo", "fifolo", "Fifaco", "fetinator", "lifi", "helio", "lifoe", " fifi", "FifO", "fati", " fifO", "Fifolo", "fetoker", " fifoo", "fedpo", "fedO", " fifoc", "fato", " femano", "pedo", "ritoice", "fetio", "lipolo", "pedota", "fouran", "ligi", "flexpo", "fifO"], "send": ["ceive", "pack", "Send", "reset", "nd", "se", "status", "update", "component", "pend", "push", "create", "connect", "transfer", "fin", "kill", "find", "command", "fire", "remote", "use", "sent", "add", "sh", "msg", "ense", "set", "bind", "sort", "call", "respond", "write", "message", "show", "spread", "kick", "ind", "size", "info", "save", "execute", "shift", "post", " transmit", "start", "link", "handle", "export", "sp", "exec", "self", "stat", "end", "init", "parse"], "complete": ["length", "repeat", "match", "ce", "see", "only", "status", "Complete", "success", "update", "COMPLE", "component", "commit", "plete", "done", "result", "create", "error", "buffer", "transfer", "secure", "empty", " completing", "replace", "close", "le", "te", "fail", "correct", "confirmed", "com", "total", "process", "test", "execute", "completely", "load", "scale", "require", "progress", "tif", "when", "partial", "check", "tle", "required", "final", "parse", "pletion", "closure"], "data": ["ll", "ata", "d", "none", "valid", "map", "done", "id", "buffer", "mem", "r", "p", "new", "raw", "attr", "size", "ip", "snap", "max", "tx", "only", "value", "error", "n", "msg", "buf", "next", "inner", "dat", "reason", "key", "window", "bin", "format", "batch", "length", "full", "def", "body", "read", "results", "bytes", "area", "file", "dr", "text", "url", "DATA", "all", "no", "str", "mu", "block", "out", "al", "result", "empty", "list", "cache", "ord", "rel", "message", "image", "Data", "load", "val", "cap", "ret", "content", "mid", "name", "res"], "len": ["cmp", "alt", "gen", "ll", " length", "valid", "mem", "del", "lt", "gz", "lis", "vol", "pos", "pl", "li", "size", "lan", "loc", "z", "lim", "coll", "gl", "ly", "lvl", "rev", "n", "el", "msg", "le", "buf", "level", "ind", "lib", "iter", "en", "label", "offset", " l", "length", "ld", "den", "full", "on", "L", "ln", "nl", "fl", "seq", "lf", "Len", "compl", "low", "bytes", "depth", "l", "lang", "limit", "lp", "kl", "ls", "all", "elt", "str", "wid", "lit", "err", "tl", "fin", "empty", "list", "lon", "lu", "ity", "line", "nt", "fac", "la", "fil", "num", "sp", "val", "hl", "cap", "ret", "tail", "t", "name"]}}
{"project": "FFmpeg", "commit_id": "c2c1726847fe3a043762062db40774bf0cc434c3", "target": 0, "func": "static void compute_status(HTTPContext *c)\n\n{\n\n    HTTPContext *c1;\n\n    FFStream *stream;\n\n    char *p;\n\n    time_t ti;\n\n    int i, len;\n\n    AVIOContext *pb;\n\n\n\n    if (avio_open_dyn_buf(&pb) < 0) {\n\n        /* XXX: return an error ? */\n\n        c->buffer_ptr = c->buffer;\n\n        c->buffer_end = c->buffer;\n\n        return;\n\n    }\n\n\n\n    avio_printf(pb, \"HTTP/1.0 200 OK\\r\\n\");\n\n    avio_printf(pb, \"Content-type: %s\\r\\n\", \"text/html\");\n\n    avio_printf(pb, \"Pragma: no-cache\\r\\n\");\n\n    avio_printf(pb, \"\\r\\n\");\n\n\n\n    avio_printf(pb, \"<html><head><title>%s Status</title>\\n\", program_name);\n\n    if (c->stream->feed_filename[0])\n\n        avio_printf(pb, \"<link rel=\\\"shortcut icon\\\" href=\\\"%s\\\">\\n\", c->stream->feed_filename);\n\n    avio_printf(pb, \"</head>\\n<body>\");\n\n    avio_printf(pb, \"<h1>%s Status</h1>\\n\", program_name);\n\n    /* format status */\n\n    avio_printf(pb, \"<h2>Available Streams</h2>\\n\");\n\n    avio_printf(pb, \"<table cellspacing=0 cellpadding=4>\\n\");\n\n    avio_printf(pb, \"<tr><th valign=top>Path<th align=left>Served<br>Conns<th><br>bytes<th valign=top>Format<th>Bit rate<br>kbits/s<th align=left>Video<br>kbits/s<th><br>Codec<th align=left>Audio<br>kbits/s<th><br>Codec<th align=left valign=top>Feed\\n\");\n\n    stream = first_stream;\n\n    while (stream != NULL) {\n\n        char sfilename[1024];\n\n        char *eosf;\n\n\n\n        if (stream->feed != stream) {\n\n            av_strlcpy(sfilename, stream->filename, sizeof(sfilename) - 10);\n\n            eosf = sfilename + strlen(sfilename);\n\n            if (eosf - sfilename >= 4) {\n\n                if (strcmp(eosf - 4, \".asf\") == 0)\n\n                    strcpy(eosf - 4, \".asx\");\n\n                else if (strcmp(eosf - 3, \".rm\") == 0)\n\n                    strcpy(eosf - 3, \".ram\");\n\n                else if (stream->fmt && !strcmp(stream->fmt->name, \"rtp\")) {\n\n                    /* generate a sample RTSP director if\n\n                       unicast. Generate an SDP redirector if\n\n                       multicast */\n\n                    eosf = strrchr(sfilename, '.');\n\n                    if (!eosf)\n\n                        eosf = sfilename + strlen(sfilename);\n\n                    if (stream->is_multicast)\n\n                        strcpy(eosf, \".sdp\");\n\n                    else\n\n                        strcpy(eosf, \".rtsp\");\n\n                }\n\n            }\n\n\n\n            avio_printf(pb, \"<tr><td><a href=\\\"/%s\\\">%s</a> \",\n\n                         sfilename, stream->filename);\n\n            avio_printf(pb, \"<td align=right> %d <td align=right> \",\n\n                        stream->conns_served);\n\n            fmt_bytecount(pb, stream->bytes_served);\n\n            switch(stream->stream_type) {\n\n            case STREAM_TYPE_LIVE: {\n\n                    int audio_bit_rate = 0;\n\n                    int video_bit_rate = 0;\n\n                    const char *audio_codec_name = \"\";\n\n                    const char *video_codec_name = \"\";\n\n                    const char *audio_codec_name_extra = \"\";\n\n                    const char *video_codec_name_extra = \"\";\n\n\n\n                    for(i=0;i<stream->nb_streams;i++) {\n\n                        AVStream *st = stream->streams[i];\n\n                        AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);\n\n                        switch(st->codec->codec_type) {\n\n                        case AVMEDIA_TYPE_AUDIO:\n\n                            audio_bit_rate += st->codec->bit_rate;\n\n                            if (codec) {\n\n                                if (*audio_codec_name)\n\n                                    audio_codec_name_extra = \"...\";\n\n                                audio_codec_name = codec->name;\n\n                            }\n\n                            break;\n\n                        case AVMEDIA_TYPE_VIDEO:\n\n                            video_bit_rate += st->codec->bit_rate;\n\n                            if (codec) {\n\n                                if (*video_codec_name)\n\n                                    video_codec_name_extra = \"...\";\n\n                                video_codec_name = codec->name;\n\n                            }\n\n                            break;\n\n                        case AVMEDIA_TYPE_DATA:\n\n                            video_bit_rate += st->codec->bit_rate;\n\n                            break;\n\n                        default:\n\n                            abort();\n\n                        }\n\n                    }\n\n                    avio_printf(pb, \"<td align=center> %s <td align=right> %d <td align=right> %d <td> %s %s <td align=right> %d <td> %s %s\",\n\n                                 stream->fmt->name,\n\n                                 stream->bandwidth,\n\n                                 video_bit_rate / 1000, video_codec_name, video_codec_name_extra,\n\n                                 audio_bit_rate / 1000, audio_codec_name, audio_codec_name_extra);\n\n                    if (stream->feed)\n\n                        avio_printf(pb, \"<td>%s\", stream->feed->filename);\n\n                    else\n\n                        avio_printf(pb, \"<td>%s\", stream->feed_filename);\n\n                    avio_printf(pb, \"\\n\");\n\n                }\n\n                break;\n\n            default:\n\n                avio_printf(pb, \"<td align=center> - <td align=right> - <td align=right> - <td><td align=right> - <td>\\n\");\n\n                break;\n\n            }\n\n        }\n\n        stream = stream->next;\n\n    }\n\n    avio_printf(pb, \"</table>\\n\");\n\n\n\n    stream = first_stream;\n\n    while (stream != NULL) {\n\n        if (stream->feed == stream) {\n\n            avio_printf(pb, \"<h2>Feed %s</h2>\", stream->filename);\n\n            if (stream->pid) {\n\n                avio_printf(pb, \"Running as pid %d.\\n\", stream->pid);\n\n\n\n#if defined(linux) && !defined(CONFIG_NOCUTILS)\n\n                {\n\n                    FILE *pid_stat;\n\n                    char ps_cmd[64];\n\n\n\n                    /* This is somewhat linux specific I guess */\n\n                    snprintf(ps_cmd, sizeof(ps_cmd),\n\n                             \"ps -o \\\"%%cpu,cputime\\\" --no-headers %d\",\n\n                             stream->pid);\n\n\n\n                    pid_stat = popen(ps_cmd, \"r\");\n\n                    if (pid_stat) {\n\n                        char cpuperc[10];\n\n                        char cpuused[64];\n\n\n\n                        if (fscanf(pid_stat, \"%9s %63s\", cpuperc,\n\n                                   cpuused) == 2) {\n\n                            avio_printf(pb, \"Currently using %s%% of the cpu. Total time used %s.\\n\",\n\n                                         cpuperc, cpuused);\n\n                        }\n\n                        fclose(pid_stat);\n\n                    }\n\n                }\n\n#endif\n\n\n\n                avio_printf(pb, \"<p>\");\n\n            }\n\n            avio_printf(pb, \"<table cellspacing=0 cellpadding=4><tr><th>Stream<th>type<th>kbits/s<th align=left>codec<th align=left>Parameters\\n\");\n\n\n\n            for (i = 0; i < stream->nb_streams; i++) {\n\n                AVStream *st = stream->streams[i];\n\n                AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);\n\n                const char *type = \"unknown\";\n\n                char parameters[64];\n\n\n\n                parameters[0] = 0;\n\n\n\n                switch(st->codec->codec_type) {\n\n                case AVMEDIA_TYPE_AUDIO:\n\n                    type = \"audio\";\n\n                    snprintf(parameters, sizeof(parameters), \"%d channel(s), %d Hz\", st->codec->channels, st->codec->sample_rate);\n\n                    break;\n\n                case AVMEDIA_TYPE_VIDEO:\n\n                    type = \"video\";\n\n                    snprintf(parameters, sizeof(parameters), \"%dx%d, q=%d-%d, fps=%d\", st->codec->width, st->codec->height,\n\n                                st->codec->qmin, st->codec->qmax, st->codec->time_base.den / st->codec->time_base.num);\n\n                    break;\n\n                default:\n\n                    abort();\n\n                }\n\n                avio_printf(pb, \"<tr><td align=right>%d<td>%s<td align=right>%d<td>%s<td>%s\\n\",\n\n                        i, type, st->codec->bit_rate/1000, codec ? codec->name : \"\", parameters);\n\n            }\n\n            avio_printf(pb, \"</table>\\n\");\n\n\n\n        }\n\n        stream = stream->next;\n\n    }\n\n\n\n    /* connection status */\n\n    avio_printf(pb, \"<h2>Connection Status</h2>\\n\");\n\n\n\n    avio_printf(pb, \"Number of connections: %d / %d<br>\\n\",\n\n                 nb_connections, nb_max_connections);\n\n\n\n    avio_printf(pb, \"Bandwidth in use: %\"PRIu64\"k / %\"PRIu64\"k<br>\\n\",\n\n                 current_bandwidth, max_bandwidth);\n\n\n\n    avio_printf(pb, \"<table>\\n\");\n\n    avio_printf(pb, \"<tr><th>#<th>File<th>IP<th>Proto<th>State<th>Target bits/sec<th>Actual bits/sec<th>Bytes transferred\\n\");\n\n    c1 = first_http_ctx;\n\n    i = 0;\n\n    while (c1 != NULL) {\n\n        int bitrate;\n\n        int j;\n\n\n\n        bitrate = 0;\n\n        if (c1->stream) {\n\n            for (j = 0; j < c1->stream->nb_streams; j++) {\n\n                if (!c1->stream->feed)\n\n                    bitrate += c1->stream->streams[j]->codec->bit_rate;\n\n                else if (c1->feed_streams[j] >= 0)\n\n                    bitrate += c1->stream->feed->streams[c1->feed_streams[j]]->codec->bit_rate;\n\n            }\n\n        }\n\n\n\n        i++;\n\n        p = inet_ntoa(c1->from_addr.sin_addr);\n\n        avio_printf(pb, \"<tr><td><b>%d</b><td>%s%s<td>%s<td>%s<td>%s<td align=right>\",\n\n                    i,\n\n                    c1->stream ? c1->stream->filename : \"\",\n\n                    c1->state == HTTPSTATE_RECEIVE_DATA ? \"(input)\" : \"\",\n\n                    p,\n\n                    c1->protocol,\n\n                    http_state[c1->state]);\n\n        fmt_bytecount(pb, bitrate);\n\n        avio_printf(pb, \"<td align=right>\");\n\n        fmt_bytecount(pb, compute_datarate(&c1->datarate, c1->data_count) * 8);\n\n        avio_printf(pb, \"<td align=right>\");\n\n        fmt_bytecount(pb, c1->data_count);\n\n        avio_printf(pb, \"\\n\");\n\n        c1 = c1->next;\n\n    }\n\n    avio_printf(pb, \"</table>\\n\");\n\n\n\n    /* date */\n\n    ti = time(NULL);\n\n    p = ctime(&ti);\n\n    avio_printf(pb, \"<hr size=1 noshade>Generated at %s\", p);\n\n    avio_printf(pb, \"</body>\\n</html>\\n\");\n\n\n\n    len = avio_close_dyn_buf(pb, &c->pb_buffer);\n\n    c->buffer_ptr = c->pb_buffer;\n\n    c->buffer_end = c->pb_buffer + len;\n\n}\n", "idx": 25265, "substitutes": {"c": ["f", "cl", "cur", "cf", "cam", "ce", "ca", "conv", "bc", "pc", "tc", "abc", "rc", "dc", "cont", "ec", "g", "cp", "n", "cache", "nc", "cs", "cb", "cm", "call", "can", "ctx", "enc", "com", "co", "chain", "b", "ct", "xc", "ac", "oc", "anc", "ci", "mc", "con", "fc", "coll", "e", "etc", "gc", "t", "cc", "C", "v", "lc", "m", "cv", "this", "conf"], "c1": ["Ctx", "c0", "C2", "ctx", "cctx", "C1", "c2", " ctx", " c0", " c2", "cc1", "cc2", "cc0", "C0"], "stream": ["handler", "clean", "status", "host", " upstream", "valid", "cont", "runtime", "buffer", "secure", "or", "sync", "pool", "s", "new", "REAM", "oooo", "STDOUT", "history", "progress", "draw", "http", "reader", "table", "sample", "v", "iterator", "parent", "download", "cf", "store", "video", "error", "sl", "close", "sc", "io", "remote", "transform", "tty", "stage", "session", "Streamer", "chain", "data", "READ", "ST", "poll", "window", "follow", "ream", "accept", "ready", "context", "engine", "length", "peer", "flash", "hold", "standard", "HEAD", "read", "console", "filter", "sw", "form", "Stream", "test", "version", "time", "driver", "tr", "zip", "ssl", "f", "stack", "client", "server", "upload", "RAW", "pipe", "wrapper", "event", "local", "row", "empty", "feed", "message", "speed", "present", "port", "pod", "check", "channel", "self", "source", "loop", "socket"], "p": ["o", "pc", "pp", "pi", "r", "cp", "n", "pn", "np", "b", "pa", "tp", "bp", "sp", "e", "fp", "lp", "P", "t", "q", "jp", "m", "v", "h"], "ti": ["tm", " di", "tu", " ki", "tt", "ri", "fi", " bi", " vi", " tu", "ai", " ta", "te", " li", "ta", "ii", " tv", "bi", " mi", "ci", " tf", " te", " ot", " si", " tid", "si", "t"], "i": ["f", "it", "x", " multi", "pi", " ni", " ii", "r", "I", " bi", "io", " vi", "ai", " v", " li", "li", "ii", "l", "ati", "ci", "e", " si", "si", " index"], "len": ["length", "nm", "ll", "ln", "nl", "mem", "fin", "lf", "el", "n", "fn", "Len", "le", "lon", "pos", "li", "l", "size", "lan", "lib", "lim", "en", "il", "lp", "ls", "ml", "lc"], "pb": ["vm", "pd", "bb", "pm", "fb", "patch", "typ", "sb", "tm", "tx", "pan", "emb", "PC", "uf", "bps", "pty", "mb", "bc", "pc", "mp", "vp", "tk", "pel", "stab", "pp", "nb", "tc", "xb", "buffer", "repl", "pool", "cp", "pg", "tab", "pid", "ob", "cb", "pn", "buf", "rpm", "ctx", "PB", "kb", "pl", "np", "bs", "td", "amp", "erb", "tg", "b", "py", "dp", "ps", "bj", "wb", "wp", "px", "tp", "bp", "rb", "fp", "gc", "pkg", "lp", "jp", "cc", "vt", "proc", "lb", "tap", "cv", "pt"], "sfilename": ["esFilename", "Susername", "ssusername", " sames", "sjournal", "Sfp", "jsFilename", "svusername", "jsfn", "sysFilename", "slength", "esdirectory", "Slength", "ssFilename", "ssfn", "jsusername", "SFilename", "lsjournal", "sysusername", "sfile", "sames", "sfn", "svFilename", " sfp", " susername", "ssfilename", "osames", "svfile", "esfile", "sfp", "lsfile", " sFilename", "susername", "osfilename", "sFilename", "sdirectory", " sfile", "esfilename", "sysfilename", "svfilename", "lsdirectory", "svdirectory", " sdirectory", "Sfilename", "ssfile", " slength", "sysjournal", "Sjournal", "sysfn", "osFilename", "svjournal", "lsfilename", " sfn", "svfn", "jsfilename"], "eosf": ["eoosfac", " eossfx", "eopensfl", "eossf", "eosfy", "nossv", "eoSp", "eoesp", "peosl", "peossfe", "nosf", "eOSfs", "eosfl", "eosesfo", "eosl", "xoesfy", "eaosfl", "eOSfo", "eosp", "peossfs", "eoosb", "eosfo", "Eosfs", "eoesl", "xosfy", "eostv", "eopensf", "eoesf", "eozfo", "eoosp", "eOSl", "eosc", "Eosfo", " eossp", " eossf", "eoSl", "Eoosl", "eosesfs", "eotf", "xoesfg", "Eoesf", "eostn", "eomfg", "eaosrf", "peossf", "eomfy", "eossc", "eosesf", "Eosf", "eosfx", "eosfac", "eosb", " eosfl", "erosfo", "peossl", "xosfg", "eossfl", "eopensp", "eoidfg", "eosesfl", "Eoosf", "peossb", "eoesfe", "xosfx", "Eosl", "eaosfo", "eoosfs", "eostp", "peosfo", "eossn", "eoSfs", "eoidf", "peosf", "eotfl", " eossfs", "eomfx", "eOSp", "nossp", "eosesfac", " eosp", "eosn", " eosfs", "Eosp", "nosn", "eopensfo", "eosv", "eozrf", "eosesfe", "eotrf", " eossfo", "eossv", "xoesfx", "eoosl", "peosfl", "peosfe", "eoesc", "peossp", "eozf", "eossfs", "eoesfx", "eoidfy", " eosfe", "Eoesp", "eoSf", "peotrf", "Eoesl", "eosesl", "nossn", "eotn", "eOSf", "Eoesfs", " eossfe", "nosp", "eoesfs", "eosesp", " eosl", "eotv", "eoidfx", " eossfl", "Eoosfac", "peosfs", "eossp", "eotp", "peosb", "nossf", " eosfo", "eosfg", "eosfe", "peotf", "eOSfac", " eosfx", "peosrf", "eoosfx", "eosfs", "xosf", "eoosfo", "peotfl", "eoosc", "eosesc", " eosc", "eoesb", "nosv", "eossb", "eomf", "peosp", "peotfo", "eozfl", "xoesf", "Eoosfo", "eoosf", "eaosf", "eossl", "eoesfy", "eossfo", "eossfx", "eoesfg", " eossl", "eotfo", "Eosfac", " eossc", "eosrf", "eoesfo", "erosl", "peossfo", "erosfs", "eostf", "erosf", "eossfe"]}}
{"project": "qemu", "commit_id": "b3be28969b797b27d7f7f806827e9898e4ee08f0", "target": 0, "func": "static int ram_save_compressed_page(QEMUFile *f, PageSearchStatus *pss,\n\n                                    bool last_stage,\n\n                                    uint64_t *bytes_transferred)\n\n{\n\n    int pages = -1;\n\n    uint64_t bytes_xmit;\n\n    uint8_t *p;\n\n    int ret;\n\n    RAMBlock *block = pss->block;\n\n    ram_addr_t offset = pss->offset;\n\n\n\n    p = block->host + offset;\n\n\n\n    bytes_xmit = 0;\n\n    ret = ram_control_save_page(f, block->offset,\n\n                                offset, TARGET_PAGE_SIZE, &bytes_xmit);\n\n    if (bytes_xmit) {\n\n        *bytes_transferred += bytes_xmit;\n\n        pages = 1;\n\n    }\n\n    if (block == last_sent_block) {\n\n        offset |= RAM_SAVE_FLAG_CONTINUE;\n\n    }\n\n    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {\n\n        if (ret != RAM_SAVE_CONTROL_DELAYED) {\n\n            if (bytes_xmit > 0) {\n\n                acct_info.norm_pages++;\n\n            } else if (bytes_xmit == 0) {\n\n                acct_info.dup_pages++;\n\n            }\n\n        }\n\n    } else {\n\n        /* When starting the process of a new block, the first page of\n\n         * the block should be sent out before other pages in the same\n\n         * block, and all the pages in last block should have been sent\n\n         * out, keeping this order is important, because the 'cont' flag\n\n         * is used to avoid resending the block name.\n\n         */\n\n        if (block != last_sent_block) {\n\n            flush_compressed_data(f);\n\n            pages = save_zero_page(f, block, offset, p, bytes_transferred);\n\n            if (pages == -1) {\n\n                set_compress_params(&comp_param[0], block, offset);\n\n                /* Use the qemu thread to compress the data to make sure the\n\n                 * first page is sent out before other pages\n\n                 */\n\n                bytes_xmit = do_compress_ram_page(&comp_param[0]);\n\n                acct_info.norm_pages++;\n\n                qemu_put_qemu_file(f, comp_param[0].file);\n\n                *bytes_transferred += bytes_xmit;\n\n                pages = 1;\n\n            }\n\n        } else {\n\n            pages = save_zero_page(f, block, offset, p, bytes_transferred);\n\n            if (pages == -1) {\n\n                pages = compress_page_with_multi_thread(f, block, offset,\n\n                                                        bytes_transferred);\n\n            }\n\n        }\n\n    }\n\n\n\n    return pages;\n\n}\n", "idx": 25284, "substitutes": {"f": ["fb", "i", "x", "ef", "cf", "o", "ref", "fw", "ff", "uf", "fs", "d", "tf", "w", "def", "c", "fr", "bf", "buffer", "fm", "g", "framework", "r", "fi", "lf", "s", "util", "rf", "file", "b", "l", "fac", "y", "window", "z", "fd", "fc", "e", "fo", "sf", "exec", "fp", "t", "h", "q", "m", "v", "lock", "F", "conf"], "pss": ["cse", "Pse", "css", "PSS", "Pess", " psp", "cpSS", " psi", "psi", "apsi", "Pss", "cpess", "ppsi", "ppSS", "apSS", "pSS", " pSS", " pess", "psp", "Pcss", " pcss", "apss", "apsp", "cpss", "pse", "pcss", "ppss", "ppsp", "pess", "cSS", " pse", "cess", "cpcss"], "last_stage": [" last2sent", " last_active", "last1active", "last1sent", "last2stage", "last_sent", " last_send", " last2stage", "last2send", "last_active", " last2active", "last2sent", " last2send", "last_send", "last1stage", " last_sent", "last1send", "last2active"], "bytes_transferred": ["bytes_sentferred", "bytes5transpired", "bytes_ranspleted", "bytes_transuted", "bytes5transreported", "bytes_redferred", "bytes_ranmitted", "bytes_reduted", "bytes_compfixed", "bytes64transfixed", "bytes_transoved", "bytes5transitted", "bytes2transpleted", "bytes_configferred", "bytes_costmitted", "bytes_sentoved", "bytes_transpired", "bytes5transferred", "bytes_translationformed", "bytes64reduted", "bytes_costpleted", "bytes_configuted", "bytes_foundferred", "bytes_paypleted", "bytes_ranoved", "bytes_costferred", "bytes2Transfer", "bytes_ranpleted", "bytes5transoved", "bytes_ranitted", "bytes_transformed", "bytes2transferred", "bytes_foundformed", "bytes_sentreported", "bytes_ranreported", "bytes64transmitted", "bytes64redferred", "bytes_translationinitialized", "bytes_createdlated", "bytes_configmitted", "bytes_perpleted", "bytes2transmitted", "bytes_excluded", "bytes_createdinitialized", "bytes5extmitted", "bytes_ransferred", "bytes5transmitted", "bytes5extferred", "bytes5paypleted", "bytes_Transpleted", "bytes_redmitted", "bytes_perferred", "bytes_compmitted", "bytes_payferred", "bytes_Transferred", "bytes_Transfer", "bytes_Transmitted", "bytes_extmitted", "bytes_translationlated", "bytes2transfer", "bytes_extferred", "bytes_extitted", "bytes_ransmitted", "bytes_redfixed", "bytes_ranpired", "bytes2Transferred", "bytes_transfixed", "bytes_transfer", "bytes_foundinitialized", "bytes_transcluded", "bytes_payreported", "bytes5payoved", "bytes_configfixed", "bytes64redmitted", "bytes_transitted", "bytes_foundlated", "bytes_ranscluded", "bytes_transmitted", "bytes_Transpired", "bytes_transpleted", "bytes_extpired", "bytes_createdformed", "bytes5extitted", "bytes_transinitialized", "bytes_Transitted", "bytes_transreported", "bytes_perfer", "bytes_payoved", "bytes_Transcluded", "bytes64transferred", "bytes_permitted", "bytes_translated", "bytes_expleted", "bytes64transuted", "bytes64redfixed", "bytes2Transmitted", "bytes_sentpleted", "bytes_compferred", "bytes_ranferred", "bytes_translationferred", "bytes5transpleted", "bytes_exmitted", "bytes5extpired", "bytes5payferred", "bytes2Transpleted", "bytes_createdferred", "bytes_exferred", "bytes_computed", "bytes_costfer", "bytes5payreported"], "bytes_xmit": ["bytes_ixmitted", "bytes_axvent", "bytes_xpmitter", "bytes_Xmitted", "bytes_xxmit", "bytes_axmitter", "bytes_rxmit", "bytes_ixmite", "bytes_relate", "bytes_uxceive", "bytes_xsmit", "bytes_mxmit", "bytes_intermitt", "bytes_uxmit", "bytes_consmitter", "bytes_rxmitted", "bytes_xMIT", "bytes_Xmite", "bytes_XMIT", "bytes_transmission", "bytes_exmit", "bytes_axmit", "bytes_uxot", "bytes_consvent", "bytes_xvert", "bytes_transmits", "bytes64uxmits", "bytes_reot", "bytes_uxmid", "bytes_mxmitted", "bytes_exmits", "bytes_mxferred", "bytes_axsend", "bytes_intermits", "bytes_rxwait", "bytes_remit", "bytes_exlate", "bytes_xsmitted", "bytes_consmit", "bytes_conshibit", "bytes_xferred", "bytes_txMIT", "bytes_xsMIT", "bytes_exmission", "bytes_xsend", "bytes_txmission", "bytes64uxmat", "bytes_uxmat", "bytes_xot", "bytes_xpvent", "bytes_remitted", "bytes_xceive", "bytes_xwait", "bytes_xpceive", "bytes_rxMIT", "bytes_wxmat", "bytes_xvent", "bytes_xpmit", "bytes64xmit", "bytes_Xmitt", "bytes_xslate", "bytes_txwait", "bytes_axmid", "bytes64xmat", "bytes_xpmid", "bytes64uxot", "bytes_intermit", "bytes_ixmit", "bytes_xmitter", "bytes_xmitted", "bytes_mxmission", "bytes_remits", "bytes_xxMIT", "bytes_xmite", "bytes_intermission", "bytes_axhibit", "bytes_transmitted", "bytes_wxmit", "bytes_remat", "bytes64uxmit", "bytes_xswait", "bytes_xpsend", "bytes_xsmitt", "bytes_txmit", "bytes64xmits", "bytes_xhibit", "bytes_transmit", "bytes_exmitt", "bytes_axceive", "bytes_wxot", "bytes_xmitt", "bytes_xlate", "bytes_xphibit", "bytes_txferred", "bytes64xot", "bytes_Xmit", "bytes_xmid", "bytes_txmitted", "bytes_wxmits", "bytes_exmitted", "bytes_xsmits", "bytes_Xvert", "bytes_uxmits", "bytes_xmits", "bytes_xxmitt", "bytes_xmission", "bytes_xmat", "bytes_uxsend", "bytes_xxmitted", "bytes_transmitt", "bytes_ixvert"], "p": ["ping", "it", "pre", "i", "pb", "o", "address", "op", "pc", "vp", "part", "pp", "c", "k", "g", "r", "cp", "n", "pid", "ap", "pos", "np", "up", "b", "ps", "ip", "page", "port", "pa", "wp", "sp", "tp", "pod", "bp", "u", "fp", "offset", "P", "h", "t", "jp", "q", "m", "point", "pkg", "lp", "pt"], "ret": ["it", "alt", "out", "reset", "pas", "RET", "ref", "re", "hash", "len", "att", "tf", "def", "result", "rev", "mem", "flags", "pages", "r", "reply", "resp", "rem", "rows", "j", "rt", "ts", "nt", "page", "rets", "prot", "url", "sp", "val", "flag", "mt", "Ret", "off", "offset", "tr", "jp", "t", "elt", "res"], "block": ["range", "field", "pb", "address", "bl", "host", "map", "container", "index", "disk", "word", "buffer", "mem", "pool", "prefix", "frame", "info", "work", "ip", "page", "link", "base", "snap", "bus", "table", "v", "pack", "byte", "Block", "config", "blocking", "header", "inv", "session", "tag", "chain", "data", "volume", "key", "window", "bin", "label", "fp", "offset", "model", "point", "lock", "type", "job", "box", "mb", "part", "def", "k", "BL", "blocks", "file", "b", "out", "ref", "man", "hash", "bit", "bo", "wall", "object", "group", "row", "list", "cache", "record", "image", "line", "load", "sp", "un", "proc", "name"], "acct_info": ["acctpoInfo", "acnt_INFO", "acnt_data", "acnt_state", "acncpostatus", "acctdblist", "acncpoinfo", "acctpoinf", "acct_INFO", "acnt_current", "acnc_status", "acct_inf", "acnt_info", "acncpoinf", "acct_list", "acnc_inf", "acct__current", "acct_state", "acct_current", "acctdbcurrent", "acctpostatus", "acctpoinfo", "acnt_list", "acnc_Info", "acct__list", "acct_Info", "acncpoInfo", "acnc_info", "acctdbinfo", "acct__info", "acct_data", "acct_status"], "norm_pages": ["normMBfiles", "normMBpointers", "normMBpages", "norm_blocks", "normal_pointers", "normal_files", "normal_blocks", "normal_pages", "normal_plugins", "normal_posts", "norm_files", "norm_plugins", "norm_posts", "norm_pointers", "normMBblocks"], "dup_pages": ["dupExpages", "dup_posts", "dupExfields", "dued_posts", "dued_pages", "dup_fields", "dup_files", "dued_files", "dupExfiles", "dupExposts", "dued_fields"]}}
{"project": "qemu", "commit_id": "554b614765090f47d97a20ca6981e17e96515ec1", "target": 0, "func": "void qmp_block_stream(bool has_job_id, const char *job_id, const char *device,\n\n                      bool has_base, const char *base,\n\n                      bool has_backing_file, const char *backing_file,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_on_error, BlockdevOnError on_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    AioContext *aio_context;\n\n    Error *local_err = NULL;\n\n    const char *base_name = NULL;\n\n\n\n    if (!has_on_error) {\n\n        on_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n\n\n    bs = qmp_get_root_bs(device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_STREAM, errp)) {\n\n        goto out;\n\n    }\n\n\n\n    if (has_base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_setg(errp, QERR_BASE_NOT_FOUND, base);\n\n            goto out;\n\n        }\n\n        assert(bdrv_get_aio_context(base_bs) == aio_context);\n\n        base_name = base;\n\n    }\n\n\n\n    /* if we are streaming the entire chain, the result will have no backing\n\n     * file, and specifying one is therefore an error */\n\n    if (base_bs == NULL && has_backing_file) {\n\n        error_setg(errp, \"backing file specified, but streaming the \"\n\n                         \"entire chain\");\n\n        goto out;\n\n    }\n\n\n\n    /* backing_file string overrides base bs filename */\n\n    base_name = has_backing_file ? backing_file : base_name;\n\n\n\n    stream_start(has_job_id ? job_id : NULL, bs, base_bs, base_name,\n\n                 has_speed ? speed : 0, on_error, block_job_cb, bs, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n\n\nout:\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 25310, "substitutes": {"has_job_id": ["has_job_name", "has_job_ids", "has_job_info", "has_jobityinfo", "has_job__id", "has_jobityid", "has_job__ids", "has_jobs_ids", "has_job__type", "has_jobs_type", "has_job__info", "has_job_type", "has_jobs_id", "has_jobityname", "has_jobitynumber", "has_job_number", "has_jobs_info"], "job_id": [" job_type", "job_details", "jobidident", "jobiddetails", " job_ident", " job_info", " job_ids", " job_event", "job_event", "job_ids", "jobidinfo", "job_type", "job_info", "job_ident", "jobidid", " job_details"], "device": ["block", "type", "engine", "Device", "address", "network", "feature", "status", "drive", "bank", "disk", "id", "dev", "buffer", "command", "password", "resource", "family", "remote", "mode", "devices", "module", "image", "connection", "project", "depth", "chain", "location", "volume", "template", "directory", "version", "handle", "serial", "pod", "driver", "number", "controller", "name", "database"], "has_base": ["has__buffer", "has_buffer", "has__child", "acts_base", "has__background", "has_bas", "Has_base", "has_child", "Has_Base", "acts_child", "has__base", "acts_buffer", "Has_bas", "acts_background", "has_background", "has_Base", "Has_buffer"], "base": ["basic", "padding", "type", "bare", "batch", "parent", "bas", "ASE", "address", "bound", "status", "se", "pad", "Base", "normal", "part", "binding", "id", "profile", "create", "common", "buffer", "local", "balance", "path", "relative", "family", "db", "resource", "p", "alias", "prefix", "root", "chain", "file", "back", "b", "pa", "template", "key", "stable", "version", "ase", "bin", "handle", "based", "source", "sample", "bid", "name"], "has_backing_file": ["has_backing_url", "has_backging_file", "has_backingablefile", "has_backing_number", "has_backingfulurl", "has_backbing_file", "has_backingfulfiles", "has_backing_files", "has_backingletfile", "has_backging_link", "has_backging_files", "has_backbing_link", "has_backingablelink", "has_backging_url", "has_backingfulfile", "has_backing_image", "has_backingableimage", "has_backingletfiles", "has_backingablefiles", "has_backingfullink", "has_backbing_files", "has_backingletnumber", "has_backing_link", "has_backbing_image", "has_backging_number"], "backing_file": ["backing_files", "backing___only", "backing___image", "backingFilefile", "backding_files", "backing___files", "backing_only", "backingFilefiles", "backding_image", "backingFileimage", "backding_table", "backding_file", "backing_table", "backingFiletable", "backing___file", "backding_only", "backing_image"], "has_speed": ["has__size", "has_size", "has_weight", "has__weight", " has__weight", "has__duration", "has_system", " has_size", "has_duration", "has___speed", " has_command", " has__size", "has___size", " has_weight", "has_command", "has__speed", " has_duration", " has_system", "has___duration", "has___weight", " has__duration", " has__speed"], "speed": ["type", "peed", "length", "efficiency", "engine", "stream", "power", "gain", "sex", "status", "Speed", "distance", "reshold", "read", "command", "secure", "sync", "attery", "rate", "count", "state", "sw", "performance", "density", "shape", "capacity", "priority", "data", "start", "size", "weight", "scale", "delay", "ower", "port", "seek", "interface", "driver", "timeout", "frequency", "index"], "has_on_error": ["has_onablechange", "has_oningerror", "has_on_command", "has_oningdefault", "has_on__command", "has_onablecommand", "has_on_errors", "has_oningsuccess", "has_onablesuccess", "has_oningerrors", "has_on_success", "has_on__error", "has_on__success", "has_on_default", "has_on_change", "has_onableerror", "has_on__change"], "on_error": ["onewsuccess", "on_info", " on_debug", "onewerror", "on_change", "on67success", "on_success", "on___ror", "on___error", "on__debug", "onmlror", "on67error", "onewinfo", "on67query", "on___change", "onmlerror", " on_change", "on_debug", " on_query", " on_info", "on__error", "on_query", " on_ror", "on67info", "on_ror", "onewquery", "on__ror", " on_success", "onmldebug"], "errp": ["nerr", "errorpa", "arrpb", "errper", "lrpy", " errpa", "eorcp", " errP", "errorping", "dieP", "errpe", "derp", "errP", "errping", " errr", "derpa", "dercp", "eorp", "rrping", "errorr", " errpe", " errping", "lrP", "sprping", "errr", "sprpr", "arrping", " errpr", "sprp", "sprP", "lrp", "errpy", "arrP", "diep", "arrp", "rrp", "nerP", "derper", "errorpr", "errcp", "arrper", " errpy", "erp", "eorP", "errpb", "errorp", "rrpb", "lrpa", "eorpa", "errpr", "arrpy", "derping", "diepe", "rrper", "nerpa", "erpe", "erP", "errorP", "derP", "derpb", " errcp", "arrpa", "nerp", "errpa"], "bs": ["ubis", "bb", "bed", "sb", "bas", "pb", "obj", "boxes", "bl", "bps", "lbs", "bles", "fs", "bc", "rs", "bes", "BS", "ses", "ubs", "ds", "aos", "bos", "bis", "s", "hz", "cs", "cks", "cb", "bytes", "bits", "vs", "js", "eb", "ss", "outs", "blocks", "b", "ns", "ts", "ps", "bi", "locks", "stats", "bh", "its", "gs", "bp", "obs", "ls", "socket"], "base_bs": ["domainPbs", "basePbh", "domain_bh", "domain_bs", " base_boxes", " base_base", "baseablebs", "baseablets", "base_ubis", "base_bits", "domainPblog", "base8bs", " base_sb", "base8blog", "base_ls", "base_bis", " base_vs", "base_sb", "base_obs", "base_boxes", "domainPbh", "base_blog", "base67bu", "back_ubis", "base___boxes", "base8vs", "bas_bb", "b_bs", "basePbs", "baseablebis", "base_bu", "back_bs", "base8bh", "base___sb", "bas_bis", "domainPbu", "base_bb", "basePblog", "base___bs", "base_vs", "bas_bs", "b_obs", "base_base", "base_ts", "basePbu", "base8ls", "base8base", "base_bps", "b_base", "base67bh", "domain_blog", "domain_bu", "baseablebb", "b_bits", "base67bs", " base_ls", "back_bis", "base67blog", "base8bu", "base_bh", "back_bps", "base___base", "bas_ts"], "aio_context": ["aIO_Context", "aio___context", "ai_config", "aio___ctx", "aio_environment", "aio_resource", "aao___translation", "aao___Context", "aio_choice", "aio_ctx", "aao_Context", "aIO_record", "aao_ctx", "aao_context", "aoy_environment", "aoy_information", "aio7environment", "ai_ctx", "aao___ctx", "aio_translation", "aoy_resource", "aio_record", "aoy_context", "aio7context", "ai_context", "aao_translation", "aio___Context", "aao___context", "aio_config", "aio_information", "aIO_choice", "ai_Context", "aio_manager", "aIO_ctx", "aio7resource", "aIO_context", "aIO_manager", "aio___translation", "aio7information", "aio_Context"], "local_err": ["local____attr", "localityerr", "global_er", " local_result", "localityobj", " local_attr", " local_error", "global_obj", "localitymsg", "global_err", "local_log", "local____err", "local__err", "local___attr", "local____rr", "local__exc", "local_rr", " local_log", "localityer", "local_obj", "local_msg", "local___error", "local__log", "local____error", "local_result", "local___err", " local_exc", "local_er", " local_msg", "local___rr", " local_rr", "local____exc", "local__error", "local_error", "global_msg", "local____log", "local_attr", "local_exc"], "base_name": ["base___name", "base2name", "base2Name", "base_file", "Base_name", "buffer_name", "Base_Name", "base_Name", "base_no", "baseNamename", "baseJname", "base___file", "baseNamefile", "base12image", "Base_image", "baseJName", "base_code", "base2no", "buffer_no", "base_named", "baseNameimage", "Base_id", "baseNameName", "base12Name", " base_file", "base_image", "base___Name", "baseJfile", "base___code", "buffer_Name", "base12file", "base12name", " base_code", "base_id", "Base_file", " base_Name", "baseJnamed", " base_named"]}}
{"project": "FFmpeg", "commit_id": "4dec101acc393fbfe9a8ce0237b9efbae3f20139", "target": 0, "func": "int ff_dxva2_commit_buffer(AVCodecContext *avctx,\n\n                           AVDXVAContext *ctx,\n\n                           DECODER_BUFFER_DESC *dsc,\n\n                           unsigned type, const void *data, unsigned size,\n\n                           unsigned mb_count)\n\n{\n\n    void     *dxva_data;\n\n    unsigned dxva_size;\n\n    int      result;\n\n    HRESULT hr;\n\n\n\n#if CONFIG_D3D11VA\n\n    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)\n\n        hr = ID3D11VideoContext_GetDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context,\n\n                                                 D3D11VA_CONTEXT(ctx)->decoder,\n\n                                                 type,\n\n                                                 &dxva_size, &dxva_data);\n\n#endif\n\n#if CONFIG_DXVA2\n\n    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)\n\n        hr = IDirectXVideoDecoder_GetBuffer(DXVA2_CONTEXT(ctx)->decoder, type,\n\n                                            &dxva_data, &dxva_size);\n\n#endif\n\n    if (FAILED(hr)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to get a buffer for %u: 0x%x\\n\",\n\n               type, hr);\n\n        return -1;\n\n    }\n\n    if (size <= dxva_size) {\n\n        memcpy(dxva_data, data, size);\n\n\n\n#if CONFIG_D3D11VA\n\n        if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {\n\n            D3D11_VIDEO_DECODER_BUFFER_DESC *dsc11 = dsc;\n\n            memset(dsc11, 0, sizeof(*dsc11));\n\n            dsc11->BufferType           = type;\n\n            dsc11->DataSize             = size;\n\n            dsc11->NumMBsInBuffer       = mb_count;\n\n        }\n\n#endif\n\n#if CONFIG_DXVA2\n\n        if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {\n\n            DXVA2_DecodeBufferDesc *dsc2 = dsc;\n\n            memset(dsc2, 0, sizeof(*dsc2));\n\n            dsc2->CompressedBufferType = type;\n\n            dsc2->DataSize             = size;\n\n            dsc2->NumMBsInBuffer       = mb_count;\n\n        }\n\n#endif\n\n\n\n        result = 0;\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"Buffer for type %u was too small\\n\", type);\n\n        result = -1;\n\n    }\n\n\n\n#if CONFIG_D3D11VA\n\n    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)\n\n        hr = ID3D11VideoContext_ReleaseDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context, D3D11VA_CONTEXT(ctx)->decoder, type);\n\n#endif\n\n#if CONFIG_DXVA2\n\n    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)\n\n        hr = IDirectXVideoDecoder_ReleaseBuffer(DXVA2_CONTEXT(ctx)->decoder, type);\n\n#endif\n\n    if (FAILED(hr)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Failed to release buffer type %u: 0x%x\\n\",\n\n               type, hr);\n\n        result = -1;\n\n    }\n\n    return result;\n\n}\n", "idx": 25344, "substitutes": {"avctx": ["avercmp", "avecontext", "averctx", "avinit", "aveinit", " avcmp", "vrcmp", "Avtx", "Avcmp", "avcp", "averinit", "vrcfg", "Avctx", "Avcontext", "evcp", "AVpkg", "avercontext", "savjp", "avekw", "avwp", "averkw", "AVinit", "evctx", "averwp", "afcp", "avercfg", "cvctx", "avejp", "savctx", "averjp", "AVctx", "vrcontext", "avectx", "avercp", "avconn", "evtx", "afctx", "AVconn", "avjp", " avconn", "savkw", "afcfg", "avtx", "vrctx", "AVwp", "avkw", "evcontext", " avtx", "cvpkg", "evcfg", "AVcontext", " avcfg", "afcmp", "avcfg", "avpkg", " avpkg", "avcmp", "avewp", "averconn", "savconn", "aveconn", " avcontext", "cvconn", "cvcontext", "vrtx", "avcontext", "evcmp"], "ctx": ["sys", "context", "cmp", "tm", "tx", "obj", "jac", "conn", "bc", "config", "c", "cpp", "tc", "kt", "rc", "dc", "crit", "gz", "tz", "ck", "act", "rx", "cmd", "ctl", "cp", "today", "sc", "nc", "cb", "cm", "voc", "setup", "cfg", "rt", "wcs", "ct", "xc", "nt", "loc", "txt", "alloc", "history", "kw", "pkg", "jp", "cc", "tmp", "lc", "init", "cv", "hw"], "dsc": ["dntc", "mpc", " dca", "cpc", "sdcs", "dtc", "ddsc", "dbc", "dnSC", "dcs", "rbc", "cesc", " dSC", "ddSC", "mesc", "indsc", "sdbc", "csc", "dpc", "rcs", " dcs", " dbc", "ddtc", "rca", "indpc", "mbc", "sdsc", "desc", "dca", "indesc", "rsc", "dSC", " dtc", "dnsc", "msc", "cbc", "sdca", "indbc"], "type": ["ping", "handler", "length", "typ", "address", "code", "unit", "value", "id", "role", "ty", "error", "buffer", "ype", " Type", "in", "family", "what", "spec", "ver", "p", "count", "to", "function", "pe", "tag", " ty", " typ", "file", "test", "weight", "info", "types", "desc", "color", "reason", "Type", "version", "TYPE", "style", "kind", "time", "ptr", "description", "t", "format", "method", "name", " TYPE"], "data": ["block", "length", "batch", "out", "ref", "ata", "w", "value", "map", "done", "id", "zero", "error", "buffer", "empty", "p", "cache", "mode", "bytes", "buf", "area", "message", "image", "Data", "raw", "a", "window", "bin", "iter", "DATA", "all", "format", "str", "name"], "size": ["sn", "dim", "length", "space", "full", " sizes", "see", "len", "code", "fee", "storage", "id", "sha", "buffer", "height", "empty", "g", "spec", "send", "count", "ize", "s", "small", "sh", "bytes", "set", "sw", "to", "area", "message", "shape", "capacity", "settings", "file", "start", "scale", "info", "SIZE", "sp", "time", "Size", "style", "scope", "number", "offset", "max", "sum", "format", "name"], "mb_count": ["mb_ount", "mbllen", "mbetyctr", "mblount", "mbptcount", "MB_ount", "mbetycontainer", "mb9ount", "MB_ctr", "MB_count", "mb9count", "mb9len", "mbptctr", "mblcount", "MB_len", "mb_len", "mb_ctr", "mb_container", "mbetycount", "MB_container", "mbptcontainer"], "dxva_data": ["dxva_name", "dxva2name", "dxva___data", "dxva2bytes", "dxva___mem", "dxva_bytes", "dxha_cache", "dxva64path", "dxva64size", "dxva___size", "dxvaistdata", "dxha_data", "dxba_mu", "dxva_mode", "dxba_data", "dxva_mu", "dxvaistsize", "dxva64mode", "dxva2cache", "dxva_cache", "dxva2data", "dxva_path", "dxvaistmem", "dxva64data", "dxba_mode", "dxba_bytes", "dxba_path", "dxva___mu", "dxba_mem", "dxva_mem", "dxba_cache", "dxha_bytes", "dxvaistmu", "dxba_name", "dxba_size"], "dxva_size": ["dxva____SIZE", "dxva_message", "dxova_scale", "dxvo_size", "dxVA_SIZE", "dxva____height", "dxva____size", "dxva____data", "dxva_SIZE", "dxva_height", "dxova_message", "dxva_scale", "dxova_size", "dxva_len", "dxVA_len", "dxvo_height", "dxvo_data", "dxva_count", "dxva_Size", "dxvo_SIZE", "dxova_Size", "dxVA_size", "dxVA_count"], "result": ["match", "Result", "err", "obj", "br", "success", "code", "status", "nr", "rc", "date", "error", "results", "r", " res", "ver", "p", "count", "mark", "attr", "num", "number", "duration", "res"], "hr": ["here", "hd", "HER", "err", "ih", "lr", "HR", "br", "then", "hour", "rs", " HR", "rd", "eh", "fr", "nr", "eor", "rh", "er", "rr", "pr", "hs", "or", "hm", " HDR", "r", "DR", "timer", "kh", "hz", "shr", " yr", "kr", "usr", "vr", "resh", " pr", " dr", "oh", " err", "HK", "yr", "rer", "dr", " cr", "mr", "Mr", "ocr", " er", "uh", "ha", "H", "hh", "hl", "tr", "h", "her", " h", "enth", "drm"], "dsc11": ["dsc1", "dirc1", "dsc12", "dbc11", "dbc31", "dbc12", "dsync1", "drc12", "nesc12", "dsc301", "nesc11", "nsc12", "dusc1", "nsc11", "dirc11", "desc91", " dsc001", " dbc301", " dsc31", "dbc10", "ddc112", "dpc1", "dbc1", " dbc10", " dsc20", "dss11", "dsc20", "dbc91", " dsc10", "nsc91", " dsc112", " dsc18", "ddc1", "dsc10", " dbc31", "dSC11", " dbc20", "dsc91", " dbc11", "dsync11", "nesc91", "dsec10", "dusc11", "ddc301", "dsc31", " dsc301", " dbc12", "desc1", " dbc1", "dsec1", "dsec001", "dpc11", "dpc001", "dSC20", "dirc20", "dbc301", "dsc001", "dsync301", "dbc18", "drc11", "desc11", "dss12", "dsc112", "dsec11", "dusc18", "dbc001", " dbc18", "dsc18", "drc1", "desc31", "dbc20", " dsc12", "ddc11", "dbc112", "drc31", " dbc112", "dSC1", "dsync112", "desc12", "dSC18", "dss91", " dbc001", " dsc1", "dpc10"], "dsc2": ["dSC3", " dSC6", "dsc1", "desc22", "dsync1", "src1", "ssc1", "dbc2", " dbc22", "dsc22", " dsc22", "dsp02", "ssc02", "dsc6", "dsec02", "dsync16", " dbc2", "sdsc2", "dpc1", "dbc1", "sdsc5", " dSC16", "sdsc02", "dsync6", "dbc3", "dsp5", "desc5", " dbc3", "dbc22", " dSC2", "dSC02", "ssc2", "src2", "desc02", "dSC6", "sdsp2", " dsc16", "dbc02", "dsync2", "drc2", "desc1", "sdsc3", " dbc1", "dSC2", "dpc6", "dsc16", "dsp3", "dSC16", "sdsp02", "dpc2", "desc2", "dpc16", "dsec2", "desc3", "drc1", "drc02", "dSC22", " dSC1", "dsp2", "dsc02", " dsc6", "dsc5", "dsec3", "dSC1", "dsec5", "sdsp5", " dsc1", " dsc3", "sdsp3", "dsc3", "src02"]}}
{"project": "qemu", "commit_id": "39f80521df1e7f1252960d1ada2bd1a41d4d2cd3", "target": 0, "func": "static int inet_listen_saddr(InetSocketAddress *saddr,\n\n                             int port_offset,\n\n                             bool update_addr,\n\n                             Error **errp)\n\n{\n\n    struct addrinfo ai,*res,*e;\n\n    char port[33];\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int slisten, rc, port_min, port_max, p;\n\n    Error *err = NULL;\n\n\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    if (saddr->has_numeric && saddr->numeric) {\n\n        ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;\n\n    }\n\n    ai.ai_family = inet_ai_family_from_address(saddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return -1;\n\n    }\n\n\n\n    if (saddr->host == NULL) {\n\n        error_setg(errp, \"host not specified\");\n\n        return -1;\n\n    }\n\n    if (saddr->port != NULL) {\n\n        pstrcpy(port, sizeof(port), saddr->port);\n\n    } else {\n\n        port[0] = '\\0';\n\n    }\n\n\n\n    /* lookup */\n\n    if (port_offset) {\n\n        unsigned long long baseport;\n\n        if (strlen(port) == 0) {\n\n            error_setg(errp, \"port not specified\");\n\n            return -1;\n\n        }\n\n        if (parse_uint_full(port, &baseport, 10) < 0) {\n\n            error_setg(errp, \"can't convert to a number: %s\", port);\n\n            return -1;\n\n        }\n\n        if (baseport > 65535 ||\n\n            baseport + port_offset > 65535) {\n\n            error_setg(errp, \"port %s out of range\", port);\n\n            return -1;\n\n        }\n\n        snprintf(port, sizeof(port), \"%d\", (int)baseport + port_offset);\n\n    }\n\n    rc = getaddrinfo(strlen(saddr->host) ? saddr->host : NULL,\n\n                     strlen(port) ? port : NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   saddr->host, port, gai_strerror(rc));\n\n        return -1;\n\n    }\n\n\n\n    /* create socket + bind */\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n\t\t        uaddr,INET6_ADDRSTRLEN,uport,32,\n\n\t\t        NI_NUMERICHOST | NI_NUMERICSERV);\n\n        slisten = qemu_socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (slisten < 0) {\n\n            if (!e->ai_next) {\n\n                error_setg_errno(errp, errno, \"Failed to create socket\");\n\n            }\n\n            continue;\n\n        }\n\n\n\n        socket_set_fast_reuse(slisten);\n\n\n\n        port_min = inet_getport(e);\n\n        port_max = saddr->has_to ? saddr->to + port_offset : port_min;\n\n        for (p = port_min; p <= port_max; p++) {\n\n            inet_setport(e, p);\n\n            if (try_bind(slisten, saddr, e) >= 0) {\n\n                goto listen;\n\n            }\n\n            if (p == port_max) {\n\n                if (!e->ai_next) {\n\n                    error_setg_errno(errp, errno, \"Failed to bind socket\");\n\n                }\n\n            }\n\n        }\n\n        closesocket(slisten);\n\n    }\n\n    freeaddrinfo(res);\n\n    return -1;\n\n\n\nlisten:\n\n    if (listen(slisten,1) != 0) {\n\n        error_setg_errno(errp, errno, \"Failed to listen on socket\");\n\n        closesocket(slisten);\n\n        freeaddrinfo(res);\n\n        return -1;\n\n    }\n\n    if (update_addr) {\n\n        g_free(saddr->host);\n\n        saddr->host = g_strdup(uaddr);\n\n        g_free(saddr->port);\n\n        saddr->port = g_strdup_printf(\"%d\",\n\n                                      inet_getport(e) - port_offset);\n\n        saddr->has_ipv6 = saddr->ipv6 = e->ai_family == PF_INET6;\n\n        saddr->has_ipv4 = saddr->ipv4 = e->ai_family != PF_INET6;\n\n    }\n\n    freeaddrinfo(res);\n\n    return slisten;\n\n}\n", "idx": 25353, "substitutes": {"saddr": ["sinaddr", "wadd", "rsaddr", "ssnode", " snode", "sinalign", "sinaddress", " sarp", "itsadr", "hadr", "wsaddr", "osaddress", "jsaddr", "jsadr", "eshost", "itsaddr", "jsctx", "smod", "esadd", "osadd", "esvr", "sarp", "rsconn", "wsvr", "ssaddr", "ssadd", "tsadr", "Salign", "jsaddress", "hconn", "sconn", "ssadr", "snode", "Sadr", "wsadr", "dsadr", "jshost", "Sadd", "tsaddr", "itsadder", " sconn", "wvr", "sadr", "sadder", "esarp", "haddr", "salign", "tsadd", "rsaddress", " saddress", "hadd", "wadr", "ssadder", "dsadd", "osaddr", "itsmod", "saddress", "Saddress", "sinadd", "esadr", "ssconn", "rsadr", "sadd", "esaddress", "esctx", " sadr", "shost", " salign", "Saddr", "wsadd", "dsaddress", "jsarp", "jsadd", " sadd", "waddr", "dsaddr", " shost", "haddress", "ssaddress", "esaddr", "sctx", "svr", "osnode", "ssmod", " sctx"], "port_offset": [" port_error", "port__Offset", " port_off", "port2off", "port_shift", "sort_style", "port_error", "Port_length", "port2shift", "sort_off", " port_Offset", "sort_shift", "sort_offset", "Port_offset", "port__off", "port_off", "port_padding", "port__offset", "Port_Offset", "port2style", "port_style", "port__error", "port_length", "Port_shift", "port2offset", "port_Offset", " port_padding"], "update_addr": ["updateipcache", " update_address", "update2cache", "updatepubcache", " update_map", "updatepubmap", "updatepubaddr", "updateipaddr", "updateipaddress", "update_map", "update_address", " update2address", "update2map", "updatepubaddress", "update2address", " update2map", "update_cache", "updateipmap", " update2cache", " update_cache", " update2addr", "update2addr"], "errp": ["strpa", "errper", " errP", "errpoint", "errorphp", "orderper", "ezpc", "erm", "rrP", " errpre", "orderP", "erp", "strpress", "orderphp", "dangerp", "erpad", "errorm", "derpc", "eorpoint", "wrp", "testpa", "testpc", "ererper", "dercache", "errpre", " errpa", "errpress", "ererphp", "errm", "erd", "errP", " errpad", "derpa", "derd", "orderpad", " errphp", "derper", "errphp", "derphp", "ezp", "orderp", "errpa", "errps", "strp", "eorp", "errorpad", "errcache", "errpad", "derm", "derps", "errd", "ererd", "erpre", " errpress", "ezpa", "errorp", "ererp", "dangercache", "derpoint", "eorpad", "orderd", "wrpa", "rrpre", "wrpress", "errord", "derp", "ezps", "derpad", "eorcache", "rrp", "errpc", "dangerpad", "testps", "erP", "dangerpoint", "errorP", "testp"], "ai": [" au", "ui", " ba", "ca", "cu", " da", "aci", "mem", "iam", "ar", " bi", "asm", "attr", "info", " mi", "pa", "ci", " na", "aq", "ei", "ras", "i", "ait", "sa", "ki", "pai", "pri", "AE", "auth", "aki", " ta", "au", "asi", "ali", "air", "ak", " sa", "acs", "ha", "cgi", "aaa", "ni", "ae", " ac", "arp", " ap", "ami", "ais", "alias", "ao", "mi", "a", " ad", "bi", "addr", "aud", "oa", " pa", "ro", " am", "api", "ay", "ka", " ha", "ia", "aim", "aos", "aa", " a", "an", "hai", " av", "iq", "hi", "am", "ti", "ac", "AI", "aus", "aj"], "res": ["sys", "pre", "pas", "ref", "re", "conn", "os", "rs", "ber", "ex", "fr", "result", "rev", "er", "reg", "mem", "ri", "results", "RES", "r", "ack", "rec", "ser", "gr", "resp", "rel", "rem", "req", "dr", "des", "addr", "progress", "pro", "val", "ir", "Res", "ret", "ress", "ro"], "e": ["ep", "ef", "eu", "o", "ce", "ev", "re", "c", "er", "ec", "me", "ed", "r", "ge", "oe", "et", "te", "eg", "pe", "E", "ele", "es", "em", "en", "ue", "t", "ee", "ae", "ei"], "port": ["pport", "ort", "address", "queue", "host", "none", "map", "pp", "index", "id", "buffer", "ice", "secure", "path", "pool", "pid", "pointer", "PORT", "et", "pair", "priority", "mobile", "ip", "page", "ptr", "table", "pt", "note", "padding", "direction", "bridge", "code", "value", "error", "pr", "cast", "header", "cp", "ace", " Port", "remote", "mit", "buf", "data", "dp", "key", "window", "handle", "point", "database", "ping", "device", "type", "length", "eport", "pad", "display", "family", "comment", "bind", "file", "test", "text", "interface", "version", "limit", "tp", "number", "tr", "P", "prop", "ports", "localhost", "client", "server", "stream", "null", "component", "Port", "proxy", "target", "row", "password", "phrase", "ve", " sport", "message", "connection", "project", "ORT", "line", "player", "position", "pro", "export", "pod", "channel", "trace", "be", "socket", "name"], "uaddr": ["uiaddress", "uires", "ures", "uaddress", "uladdr", " uAddress", "uladdress", "ulres", "ulAddress", " ures", "uiAddress", " uaddress", "uiaddr", "uAddress"], "uport": ["pport", "unionaddr", "uaddress", "paddr", "Uport", "Uaddress", "unionaddress", "unionport", "Uaddr", "paddress"], "slisten": ["slistern", "stopen", "sopen", "sopener", " sopener", "stopener", "sfilen", "sfilener", "stoper", "slistener", "sfilern", " slistern", " slistener", " sopen", " soper", "soper", " slister", "stopern", "sopern", "sfiler", "slister", " sopern"], "rc": ["uc", "cur", "cmp", "rl", "ror", "_", "c", "ctr", "sync", "r", "rec", "new", "isc", "call", "rt", "info", "src", "fc", "exec", "xff", "pc", "bc", "rs", "rr", "ec", "func", "sc", "cs", "co", "anc", "con", "nr", "rd", "def", "ry", "ck", "ge", "nc", "arc", "cas", "addr", "cc", "rn", "ro", "irc", "ok", "success", "cor", "result", "rx", "ack", "usr", "cb", "RC", "end"], "port_min": ["port_mod", " port_MIN", " port_mod", "port_MIN"], "port_max": ["port_range", "port_mod", " port_range", " port_mod", "port2range", "port2min", "port2mod", "port2max"], "p": ["f", "i", "pc", "pp", "pi", "c", "pr", "r", "cp", "n", "pn", "pe", "rep", "np", "b", "ps", "pa", "tp", "fp", "pkg", "P", "pat", "jp", "q", "t", "m", "pt"], "err": ["ere", "sys", "ch", "ait", "cer", "obj", "lr", "ev", "re", "conn", "try", "fee", "rs", "ex", "fr", "result", "Error", "eor", "error", "er", "rr", "gz", "conf", "later", "or", "ah", "r", "timer", "arr", "kr", "msg", "resp", "usr", "cb", "buf", "esp", "die", "cfg", "eas", "req", "attr", "notice", "dr", "mr", "cr", "addr", "txt", "iter", "aaa", "der", "errors", "Er", "exc", "rn", "str", "init", "ei"], "baseport": ["Basewater", " baseline", "baseewater", "Baseport", "Basport", "baaxy", " basport", "baleline", "basename", "benelist", "baseline", "basency", " baselist", "baeport", "Baseline", " basity", "balency", "bateport", "baseeport", " basency", "benename", "baename", "Basity", "benabel", "batelist", "basport", "balename", "baseelist", "baeline", "beneport", " basestamp", "baseestamp", " basename", "baseency", "Basaxy", "basestamp", "baseity", "baseeline", "baseabel", "baselist", "Baselist", "basaxy", "Basename", "baleport", "batabel", "Basestamp", "basity", "basewater", "basabel", "baseename", " basewater", "batename", " basaxy"]}}
{"project": "FFmpeg", "commit_id": "a7f27453f64d9020b92b01687baeb5909c6cdad0", "target": 0, "func": "static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;\n\n    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&\n\n        codec->codec_id == AV_CODEC_ID_H264 &&\n\n        atom.size > 11) {\n\n        avio_skip(pb, 10);\n\n        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */\n\n        if (avio_rb16(pb) == 0xd4d)\n\n            codec->width = 1440;\n\n        return 0;\n\n    }\n\n\n\n    return mov_read_avid(c, pb, atom);\n\n}\n", "idx": 25357, "substitutes": {"c": ["f", "cur", "cmp", "cf", "ce", "cu", "ca", "pc", "bc", "tc", "rc", "abc", "dc", "cont", "cd", "ec", "cp", "p", "nc", "cn", "cs", "cb", "cm", "call", "ctx", "enc", "com", "co", "chain", "ct", "xc", "ac", "anc", "l", "vc", "unc", "ci", "con", "fc", "coll", "e", "kw", "etc", "gc", "t", "cc", "C", "v", "lc", "cv", "conf"], "pb": ["fb", "bb", "sb", "apy", "pan", "emb", "orp", "uf", "pub", "mb", "mp", "pc", "nb", "vp", "tk", "pp", "bf", "cp", "p", "pg", "tab", "ob", "zb", "cb", "ctx", "ap", "PB", "amp", "td", "bs", "np", "eb", "b", "dp", "wb", "pa", "wp", "BP", "ub", "gb", "tp", "bp", "sp", "rb", "fp", "ib", "pkg", "lp", "jp", "lb", "tap"], "atom": ["prop", "x", "orm", "typ", "out", "obj", "byte", "ata", "item", "op", "unit", "term", "app", "xml", "part", "entry", "map", "abc", "atomic", "word", "at", "buffer", "um", "ext", "cmd", "md", "tem", "p", "band", "tab", "kat", "mat", "ob", "msg", "node", "buf", "ap", "amp", "com", "am", "b", "data", "attr", "om", "key", "text", "orb", "addr", "num", "tmp", "m", "name"], "codec": ["condEC", " codek", "Codec", " codEC", " coddec", "CodEC", "Codoc", "Codenc", "odisc", "oddec", " metek", "codrc", "codoc", "odek", "codeEC", "codek", "coder", "Coderer", " codrc", " metrc", "codEC", " coderer", "cEC", " codoc", "codeerer", "conddec", "odrc", " metoc", "cec", "codeenc", "odec", "codisc", " codect", "codeoder", " metec", " cododer", "coderer", "codeec", "condec", "coddec", "codenc", "Codrc", "coderc", "codeisc", " codenc", "odoc", "cenc", "cododer", "odEC", "condect", "odect", "Codisc", "codect", "codeoc"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            TAILQ_REMOVE(&savevm_handlers, se, entry);\n\n            qemu_free(se);\n\n        }\n\n    }\n\n}\n", "idx": 25370, "substitutes": {"vmsd": ["vtsdn", "ventsd", "vsssd", "vjsd", "mmsds", "vmesisd", "ventsds", " vmsisd", "vnsdc", "mmsr", "mmssd", "vssdc", "vnsd", "vmsr", "vjsr", "vmesds", " vmesdn", "vmesd", "vmessd", "vmesdc", "mmesr", "vssd", "vmsl", "vssds", "vmsds", "vmesr", "vnsds", "vtsr", " vmesds", "vjsl", "mmsl", "vmsisd", "ventsisd", "mmessd", " vmesisd", "vjsds", "vmsdn", "vtsl", "vtsisd", " vmesd", "mmsdc", "vmsdc", "mmesd", " vmsdn", "vtsd", "ventsdn", "mmesl", "vmesdn", "mmesdc", "mmesds", "vmesl", "vmssd", " vmsds", "vnssd", "mmsd", "vtsds"], "opaque": ["operaque", "oaque", "opsois", "ous", "ipus", "hopparency", "ipparency", "operacity", "opparency", "ompois", "opque", "opacity", "Opaque", "operois", "opsaque", "ompaque", "oacity", "opatile", "opsatile", "ompatile", "hopacity", "opsacity", "ompacity", "Opacity", "hopque", "ipque", "opois", "ipaque", "oparency", "ipacity", "oque", "hopaque", "opus", "Opus", "operatile", "Opque"], "se": ["sle", "sa", "sed", "SE", "ce", "ade", "sea", "see", "cle", "ie", "ke", "entry", "ent", "ses", "ste", "ry", "ine", "me", "ve", "ze", "ge", "she", "ace", "s", "ser", "ese", "ense", "sem", "sche", "le", "te", "pe", "sec", "spe", "ne", "pse", "so", "ele", "ene", "de", "Se", "es", "ase", "e", "sv", "est", "ide", "ae", "ree", "parse"], "new_se": ["new___se", "old_me", "old_se", "new___ge", "new_ce", "new_see", "new___me", "new__ge", "old___me", "new_ge", " new_ge", "new__see", "old___se", "new___ce", " new_ce", "old_ce", "old_see", "new__me", "new__se", "old___ce", "old___see", "new_me", "new__ce", "new___see"]}}
{"project": "qemu", "commit_id": "edc243851279e3393000b28b6b69454cae1190ef", "target": 1, "func": "static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd,\n\n                                 struct iovec *iov, unsigned int iov_cnt)\n\n{\n\n    struct virtio_net_ctrl_mac mac_data;\n\n    size_t s;\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n\n\n    if (cmd == VIRTIO_NET_CTRL_MAC_ADDR_SET) {\n\n        if (iov_size(iov, iov_cnt) != sizeof(n->mac)) {\n\n            return VIRTIO_NET_ERR;\n\n        }\n\n        s = iov_to_buf(iov, iov_cnt, 0, &n->mac, sizeof(n->mac));\n\n        assert(s == sizeof(n->mac));\n\n        qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);\n\n        rxfilter_notify(nc);\n\n\n\n        return VIRTIO_NET_OK;\n\n    }\n\n\n\n    if (cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET) {\n\n        return VIRTIO_NET_ERR;\n\n    }\n\n\n\n    int in_use = 0;\n\n    int first_multi = 0;\n\n    uint8_t uni_overflow = 0;\n\n    uint8_t multi_overflow = 0;\n\n    uint8_t *macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN > iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, macs,\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        uni_overflow = 1;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, mac_data.entries * ETH_ALEN);\n\n\n\n    first_multi = in_use;\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN != iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (in_use + mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, &macs[in_use * ETH_ALEN],\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        multi_overflow = 1;\n\n    }\n\n\n\n    n->mac_table.in_use = in_use;\n\n    n->mac_table.first_multi = first_multi;\n\n    n->mac_table.uni_overflow = uni_overflow;\n\n    n->mac_table.multi_overflow = multi_overflow;\n\n    memcpy(n->mac_table.macs, macs, MAC_TABLE_ENTRIES * ETH_ALEN);\n\n    g_free(macs);\n\n    rxfilter_notify(nc);\n\n\n\n    return VIRTIO_NET_OK;\n\n\n\nerror:\n\n    g_free(macs);\n\n    return VIRTIO_NET_ERR;\n\n}\n", "idx": 25382, "substitutes": {"n": ["note", "sn", "na", "on", "o", "nn", "nm", "network", "nd", "conn", "norm", "nb", "ln", "w", "config", "c", "nl", "ren", "ng", "tn", "nex", "fn", "p", "cn", "node", "an", "j", "nw", "nu", "np", "ne", "a", "nv", "ns", "l", "nt", "nor", "mn", "wn", "dn", "N", "gn", "num", "net", "en", "t", "rn", "m", "names", "name"], "cmd": ["type", "job", "batch", "cmp", "cf", "dq", "conn", "code", "tl", "comm", "tk", "def", " command", " cc", "qt", "cd", "ctr", "kt", "cont", "command", " msg", "act", "mk", "ctrl", "md", "ctl", "cp", "mode", "msg", "cb", "ctx", " typ", "cfg", "req", "ct", "ind", "CT", "nt", "fun", "Cmd", " chip", "kind", "pkg", "cc", "cli"], "iov": ["irc", "fax", "iva", "ux", "iol", "mpeg", "news", "nox", "conv", "voice", "comm", "icon", "iv", "iw", "mus", "uj", "tv", "vp", "rov", "ech", "ilo", "river", "aunts", "liv", "iris", "meyer", "nov", "browser", "dyl", "soc", "io", "iop", "org", "uart", "gov", "vr", "vg", "isco", "voc", "yon", "vo", "iq", "vec", "av", "rolet", "usb", "ever", "ij", "minecraft", "src", "ivo", "imp", "verbs", "when", "vector", "serv", "ir", "xp", "iu", "pkg", "uv", "v", "rn", "IV", "mu", "drm"], "iov_cnt": ["iov_est", "iov_count", "iov_uncnt", "iov_curgt", "iov_cnd", "iov_CNT", "iov0crowd", "iov_uncript", "iov_cry", "iov2cant", "iov_kry", "iov_acst", "iov_scnd", "iov2curnt", "iov_acount", "iov_cNT", "iov_ent", "iov_secres", "iov2count", "iov_ctgt", "iov_secounter", "iov_eounter", "iov0ctnd", "iov0cnt", "iov_arctry", "iov2curant", "iov2cry", "iov_scgt", "iov_curnd", "iov0ctnt", "iov_acry", "iov_scres", "iov_scnt", "iov0cnd", "iovolycript", "iov_acnt", "iov_curnt", "iov_curant", "iov_discnt", "iovolycuript", "iov_coud", "iov2acnt", "iov2acry", "iov2cnt", "iov_cres", "iov_kount", "iov_crt", "iov_Count", "iov_cst", "iov_ctnt", "iov2curres", "iov_arcnd", "iov_discrand", "iov_gcres", "iov_knt", "iov_cunt", "iov_secNT", "iov_scant", "iov2acount", "iov_counter", "iov_gcrt", "iov0ctgt", "iov_gcnt", "iov0cgt", "iovolycurand", "iov_Cry", "iov_eant", "iov_crand", "iov_Counter", "iov_cacheounter", "iov_cachent", "iov_curand", "iov2cres", "iov_secnt", "iovolycrand", "iov_scrt", "iov_cgt", "iovolycoud", "iov_currt", "iov_gcant", "iov_kst", "iov2currt", "iov_ctnd", "iov_ctrowd", "iov_discript", "iov_currowd", "iov_uncrand", "iov_Cres", "iov_uncoud", "iov_cacheres", "iov_Cnt", "iov_scrowd", "iov_cant", "iov_cript", "iov_curres", "iov_rst", "iov_rnt", "iovolycnt", "iov_ctry", "iov2crt", "iov_Cst", "iov_cacheNT", "iov_arcnt", "iovolycunt", "iov2acst", "iov2cst", "iov_arcst", "iov_cuript", "iov_cuoud", "iov_Cant", "iovolycuoud", "iov_discoud", "iov_rtry", "iov0ctrowd", "iov_crowd", "iov_rnd"], "mac_data": ["mac2DATA", "mac_", "macPtable", "mat_", "mac_def", "mac_group", "mac7def", "phrase_details", " macctl", "mac_good", "mac_dat", "phrasePdetails", "micnew", " mac_def", "mac2data", "mac_DATA", "ac_data", "mac_no", "mac2list", " mac_good", " mac_DATA", "mac_info", "phrase_data", "mac_entry", "ac_def", " macnew", "mac8def", "macnew", "mac_list", "Mac_entry", "mac_ata", "phrasePdata", "phrasePdat", "mac2entry", "mac8data", "mac7ata", "mac2info", "phrase_dat", " mac_group", "micctl", "mic_", " mac_ata", "mac7data", "mac2def", "phrase_table", "matnew", "mac67table", "macPdetails", "mac67data", " mac_table", " mac_res", "mac_res", "mac67res", "matctl", "mac8entry", "mac_table", "ac_no", "Mac_def", "macctl", " mac_", "macPdat", "macPdata", "phrasePtable", "Mac_info", "mac_details", "mac8info", "ac_ata", "Mac_data", " mac_list"], "s": ["f", "ms", "i", "as", "space", "sb", "conv", "gets", "os", "fs", "d", "rs", "w", "c", "rates", "ds", "hs", "sl", "g", "r", "spec", "p", "changes", "cs", "sts", "bytes", "sw", "j", "sym", "S", "js", "bs", "ss", "xs", "a", "is", "b", "ats", "ns", "ts", "https", "l", "ps", "y", "ies", "tes", "stats", "qs", "z", "south", "es", "its", "e", "gs", "less", "sv", "sp", "h", "t", "ls", "m", "v", "sq", "su"], "nc": ["sn", "nn", "nd", "conn", "bc", "nb", "pc", "yn", "nr", "c", "tc", "nl", "dc", "nic", "tn", "NC", "fn", "cn", "cs", "nw", "ctx", "nz", "np", "ne", "ct", "nv", "ns", "nt", "nec", "xc", "anc", "mn", "mc", "gc", "cc", "rn", "lc", "cv"], "macs": [" mats", "smamps", " maps", "gmacts", "maps", " macts", "gmats", "smats", "smacts", "mamps", "tmaps", "tmats", "smacs", "gmaps", "tmamps", "gmacs", "macts", " mamps", "mats", "tmacs", "smaps"]}}
{"project": "FFmpeg", "commit_id": "14a90c9ef09a4b046500dceab5ca1875e330a376", "target": 1, "func": "static av_cold int ffmmal_init_decoder(AVCodecContext *avctx)\n{\n    MMALDecodeContext *ctx = avctx->priv_data;\n    MMAL_STATUS_T status;\n    MMAL_ES_FORMAT_T *format_in;\n    MMAL_COMPONENT_T *decoder;\n    char tmp[32];\n    int ret = 0;\n    bcm_host_init();\n    if (mmal_vc_init()) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot initialize MMAL VC driver!\\n\");\n        return AVERROR(ENOSYS);\n    if ((ret = ff_get_format(avctx, avctx->codec->pix_fmts)) < 0)\n        return ret;\n    avctx->pix_fmt = ret;\n    if ((status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER, &ctx->decoder)))\n        goto fail;\n    decoder = ctx->decoder;\n    format_in = decoder->input[0]->format;\n    format_in->type = MMAL_ES_TYPE_VIDEO;\n    switch (avctx->codec_id) {\n        case AV_CODEC_ID_MPEG2VIDEO:\n            format_in->encoding = MMAL_ENCODING_MP2V;\n            break;\n        case AV_CODEC_ID_MPEG4:\n            format_in->encoding = MMAL_ENCODING_MP4V;\n            break;\n        case AV_CODEC_ID_VC1:\n            format_in->encoding = MMAL_ENCODING_WVC1;\n            break;\n        case AV_CODEC_ID_H264:\n        default:\n            format_in->encoding = MMAL_ENCODING_H264;\n            break;\n    format_in->es->video.width = FFALIGN(avctx->width, 32);\n    format_in->es->video.height = FFALIGN(avctx->height, 16);\n    format_in->es->video.crop.width = avctx->width;\n    format_in->es->video.crop.height = avctx->height;\n    format_in->es->video.frame_rate.num = 24000;\n    format_in->es->video.frame_rate.den = 1001;\n    format_in->es->video.par.num = avctx->sample_aspect_ratio.num;\n    format_in->es->video.par.den = avctx->sample_aspect_ratio.den;\n    format_in->flags = MMAL_ES_FORMAT_FLAG_FRAMED;\n    av_get_codec_tag_string(tmp, sizeof(tmp), format_in->encoding);\n    av_log(avctx, AV_LOG_DEBUG, \"Using MMAL %s encoding.\\n\", tmp);\n    if ((status = mmal_port_format_commit(decoder->input[0])))\n        goto fail;\n    decoder->input[0]->buffer_num =\n        FFMAX(decoder->input[0]->buffer_num_min, 20);\n    decoder->input[0]->buffer_size =\n        FFMAX(decoder->input[0]->buffer_size_min, 512 * 1024);\n    ctx->pool_in = mmal_pool_create(decoder->input[0]->buffer_num, 0);\n    if (!ctx->pool_in) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    if ((ret = ffmal_update_format(avctx)) < 0)\n        goto fail;\n    ctx->queue_decoded_frames = mmal_queue_create();\n    if (!ctx->queue_decoded_frames)\n        goto fail;\n    decoder->input[0]->userdata = (void*)avctx;\n    decoder->output[0]->userdata = (void*)avctx;\n    decoder->control->userdata = (void*)avctx;\n    if ((status = mmal_port_enable(decoder->control, control_port_cb)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->input[0], input_callback)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->output[0], output_callback)))\n        goto fail;\n    if ((status = mmal_component_enable(decoder)))\n        goto fail;\n    return 0;\nfail:\n    ffmmal_close_decoder(avctx);\n    return ret < 0 ? ret : AVERROR_UNKNOWN;", "idx": 25401, "substitutes": {"avctx": ["averctx", "aftx", " avreq", " avconf", "wavtx", "avdesc", "awtx", "auxcp", "abreq", "avwcs", "devval", "vrctx", "AVdj", "wavcmp", "avectl", "awctx", "avpkg", "averpkg", "averdesc", "avcmp", "averdl", "auwcs", "avdl", "vawcs", "avval", "avloc", "averdj", "vamsg", "avecmd", "averwcs", "wavctl", "vrcmp", "avedesc", "avercontext", "awcontext", "varconf", "cvctx", " avobj", "avcu", "devctl", "vardl", " avcmd", "avdj", "avpy", "avsys", " avdj", "afcontext", " avpkg", "averloc", " avcontext", "aveloc", "varpy", "avetxt", " avdesc", "avedl", "wavcu", "vrdesc", "vactx", "auctx", "avconf", "afcmd", "avecmp", "devctx", "cvcmp", "AVctx", "avectx", "aveval", "afctx", "avtxt", "abtx", "avmsg", "auxctx", "avtx", "avreq", "abctx", "varctx", "wavcmd", "avcmd", "auxcu", "afcmp", "avertxt", "ausys", "avetx", "wavobj", "avepy", "avepkg", "avcontext", "devtx", "abcontext", " avcmp", "averpy", "auxobj", "avobj", " avcu", "avcp", "avctl", "cvtx", "vasys", " avcp", "afreq", "wavctx", "aversys", "avercmd", "avertx", "wavcp", "aveconf", "averconf", " avtxt", "awcmp", "aumsg", " avtx", "cvdesc", "AVcontext", "AVtx", "avermsg", " avloc", "wavval", "vrtx", "AVcmp"], "ctx": ["context", "cmp", "tx", "cf", "obj", "jac", "ca", "Context", "conn", "qt", "tc", "kt", "dc", "mx", "conf", "ck", "act", "ctrl", "cmd", "pool", "ctl", "cp", "prefix", "resp", "cb", "cm", "set", "np", "setup", "cfg", "wcs", "ct", "xc", "req", "nt", "cas", "txt", "history", "window", "px", "handle", "val", "kw", "etc", "gc", "pkg", "timeout", "cc", "jp", "index", "conv", "cv", "hw"], "status": ["f", "sys", "type", "Status", "active", "out", "uses", "service", "code", "success", " ret", "id", "result", "error", "event", "wait", "s", "state", "prefix", "msg", "set", "sw", "data", "info", "access", "progress", "base", "st", "sp", "flag", "ret", "gc", "stat", "index", "str", "name", "this", "summary", "res"], "format_in": ["formatMixadd", "formatptin", "format101in", "format__in", "formatTYin", "formatableinn", "formatptgin", "filter_out", "format_gin", "filter_", "flatTYgin", "formatpyIn", "format_inn", " format_rin", "formatablevin", "pattern_in", "format__ini", "formatobjnin", "format_IN", "format23in", "format23gin", "formatMixin", "filter_ins", "format00nin", "format00IN", "format_init", " format_", "format__to", "format_din", "transformptin", " format_inn", "format_ini", "flat_in", "formatobjin", "format00in", "format_out", "formatixIN", "format101In", "filter_In", " format_In", "formatixvin", "format___in", "formatablein", "format_old", "flatTYini", "version_in", "transformptold", "format23ini", "formatpyin", "transform_old", "format00In", "formatobjdin", "transform_in", "formatptinf", "formatTYgin", "format101out", "format_nin", "formatMixIN", "format___inn", "filter_i", "formatptold", "formatixin", "format00inner", "pattern_inf", "filter_inner", "format_In", "filter_IN", "format23to", "transformptIn", " format_IN", "pattern_din", "filter_in", "formatixinn", " format_vin", "version_rin", "formatTYini", "format_", "formatTYto", "flat_to", "format00old", "format_inf", "format_to", "format___IN", "transformptnin", "version_nin", "flat_gin", "formatpyrin", "flatTYto", "format_rin", "formatptIn", "pattern_gin", "formatptdin", "filter_init", "formatpynin", "transform_In", "formatptnin", "formatobji", "format101init", "format_add", "flat_ini", "format_vin", "filter_din", "format00ins", "format_ins", "filter_nin", "transform_nin", "flatTYin", "transform_", " format_out", "format__gin", "format_i", "formatableIN", " format_add", "format_inner", "version_In"], "decoder": ["reccer", "deener", "decoding", "Decoder", "decoded", " decoding", "Decener", "ecoser", "ecoding", "unicode", "encoder", "unicoser", "deoder", "recoser", "ecressor", "decer", "recoder", "encoded", "encode", "eccer", "ecoder", "deccer", "decener", "deoser", "decode", "deoded", "recor", " deccer", " decoded", "ecor", "ecoded", " decode", "encoser", "Decode", "ecode", "encressor", "recoding", "recoded", "decoser", "unicoder", "decressor", " decor", "deode", "recressor", "decor", "recode", "Decoser", "unicener"], "tmp": [" img", "cmp", "perm", "obj", "pad", "result", "params", " msg", " proc", "cache", " rgb", " buff", "img", "cb", " ref", " params", " junk", "test", "lib", "base", " pts", "mask", "etc", "buff", "uv", "proc", "v", "name"]}}
{"project": "FFmpeg", "commit_id": "9e1c55cfdec1e1e46fa39b92ea5c425ba9499c68", "target": 1, "func": "static int ogg_get_length(AVFormatContext *s)\n\n{\n\n    struct ogg *ogg = s->priv_data;\n\n    int i;\n\n    int64_t size, end;\n\n    int streams_left=0;\n\n\n\n    if(!s->pb->seekable)\n\n        return 0;\n\n\n\n// already set\n\n    if (s->duration != AV_NOPTS_VALUE)\n\n        return 0;\n\n\n\n    size = avio_size(s->pb);\n\n    if(size < 0)\n\n        return 0;\n\n    end = size > MAX_PAGE_SIZE? size - MAX_PAGE_SIZE: 0;\n\n\n\n    ogg_save (s);\n\n    avio_seek (s->pb, end, SEEK_SET);\n\n\n\n    while (!ogg_read_page (s, &i)){\n\n        if (ogg->streams[i].granule != -1 && ogg->streams[i].granule != 0 &&\n\n            ogg->streams[i].codec) {\n\n            s->streams[i]->duration =\n\n                ogg_gptopts (s, i, ogg->streams[i].granule, NULL);\n\n            if (s->streams[i]->start_time != AV_NOPTS_VALUE){\n\n                s->streams[i]->duration -= s->streams[i]->start_time;\n\n                streams_left-= (ogg->streams[i].got_start==-1);\n\n                ogg->streams[i].got_start= 1;\n\n            }else if(!ogg->streams[i].got_start){\n\n                ogg->streams[i].got_start= -1;\n\n                streams_left++;\n\n            }\n\n        }\n\n    }\n\n\n\n    ogg_restore (s, 0);\n\n\n\n    ogg_save (s);\n\n    avio_seek (s->pb, s->data_offset, SEEK_SET);\n\n    ogg_reset(s);\n\n\n    while (!ogg_packet(s, &i, NULL, NULL, NULL)) {\n\n\n        int64_t pts = ogg_calc_pts(s, i, NULL);\n\n        if (pts != AV_NOPTS_VALUE && s->streams[i]->start_time == AV_NOPTS_VALUE && !ogg->streams[i].got_start){\n\n            s->streams[i]->duration -= pts;\n\n            ogg->streams[i].got_start= 1;\n\n            streams_left--;\n\n        }else if(s->streams[i]->start_time != AV_NOPTS_VALUE && !ogg->streams[i].got_start){\n\n            ogg->streams[i].got_start= 1;\n\n            streams_left--;\n\n        }\n\n        }\n\n            if(streams_left<=0)\n\n                break;\n\n    }\n\n    ogg_restore (s, 0);\n\n\n\n    return 0;\n\n}", "idx": 25404, "substitutes": {"s": ["irs", "ops", "o", "comm", "d", "sports", "c", "er", "r", "times", "p", "changes", "aws", "vs", "S", "ns", "ies", "z", "aps", "less", "h", "v", "sb", "os", "erences", "rs", "n", "sc", "cs", "ags", "ats", "ts", "ims", "its", "eds", "parts", "m", "sys", "ms", "as", "ins", "gets", "ses", "scripts", "results", "bis", "sts", "sw", "bs", "a", "is", "b", "ps", "stats", "ads", "gs", "ls", "ssl", "ears", "ports", "news", "fs", "w", "bes", "ds", "hs", "g", "webkit", "an", "ches", "js", "ss", "https", "qs", "terms", "es", "sv", "ys", "t"], "ogg": ["pb", "eps", "map", "ink", "pp", "tt", "ables", "og", "oci", "or", "umble", "pg", "pdf", "gg", "BB", "OG", "eg", "raw", "tg", "podcast", "http", "embed", "ogle", "ows", "ogs", "youtube", "ik", "voice", "oss", "config", "ang", "audio", "amps", "oga", "ott", "good", "agg", "ace", "ob", "able", "obs", "ream", "ib", "atts", "sys", "bb", "igm", "orm", "ble", "mp", "arb", "ais", "ible", "iop", "GG", "ast", "Stream", "ogl", "oc", "rss", "orb", "oggle", "aud", "gs", "errors", "ssl", "ears", "peg", "mpeg", "stream", "news", "ok", "ow", "gif", "article", "ebin", "ga", "important", "gp", "craft", "av", "eb", "annot", "obb", "ys", "owl", "uv"], "i": ["ui", "o", "status", "c", "ini", "id", "I", "p", "ori", "ai", "li", "used", "associated", "any", "info", "ip", "ij", "y", "ci", "history", "iu", "si", "h", "v", "ei", "ji", "\u0438", "rest", "ik", "try", " ii", "n", "remote", "io", "j", "inner", "ind", "uri", "m", "qi", "ix", "batch", "x", "multi", "ami", "ri", "phi", "di", "oi", "mi", "ii", "is", "b", "l", "bi", "ir", "xi", "im", "q", "mu", "iri", "it", "ic", "err", "pi", "fi", "g", "gi", "ed", "list", "rel", "hi", "ti", "start", "wi", "e", "u", "t", "index", "cli", "init"], "size": ["sn", "padding", "ms", "length", "space", "x", "large", "news", "see", "address", "len", "c", "storage", "body", "mem", "largest", "loss", "height", "empty", "g", "n", "send", "count", "amount", "inos", "ize", "small", "sent", "bytes", "set", "too", "area", "message", "total", "shape", "settings", "capacity", "any", "speed", "data", "start", "scale", "SIZE", "huge", "izes", "south", "st", "limit", "export", "sp", "time", "Size", "scroll", "resolution", "number", "offset", "parts", "max", "eng", "sum", "all", "name"], "end": ["it", "length", "END", "rest", "nd", "ff", "len", "bound", "begin", "ent", "pend", "id", "after", "fin", "End", "send", "add", "dest", "set", "ended", "pos", "next", "last", "stop", "ending", "start", "seek", "wind", "st", "limit", "export", "e", "en", "est", "ue", "offset", "off", "max", "h", "final"], "streams_left": ["streams_expected", "streams_old", "streamids_left", "streamers_Left", "streamids_expected", "streamgs_left", "streams_low", "streamids_old", "streamers_low", "streamids_all", "streams_bottom", "streams1low", "streams1left", "streamers_left", "streams_all", "streams_right", "streamers_bottom", "streams1Left", "streams_Left", "streamgs_right", "streamgs_Left", "streams1bottom"]}}
{"project": "FFmpeg", "commit_id": "80387f0e2568746dce4a68e2217297029a053dae", "target": 1, "func": "static int mimic_decode_frame(AVCodecContext *avctx, void *data,\n\n                              int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MimicContext *ctx = avctx->priv_data;\n\n    GetByteContext gb;\n\n    int is_pframe;\n\n    int width, height;\n\n    int quality, num_coeffs;\n\n    int swap_buf_size = buf_size - MIMIC_HEADER_SIZE;\n\n\n\n    if (buf_size <= MIMIC_HEADER_SIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"insufficient data\\n\");\n\n        return -1;\n\n    }\n\n\n\n    bytestream2_init(&gb, buf, MIMIC_HEADER_SIZE);\n\n    bytestream2_skip(&gb, 2); /* some constant (always 256) */\n\n    quality    = bytestream2_get_le16u(&gb);\n\n    width      = bytestream2_get_le16u(&gb);\n\n    height     = bytestream2_get_le16u(&gb);\n\n    bytestream2_skip(&gb, 4); /* some constant */\n\n    is_pframe  = bytestream2_get_le32u(&gb);\n\n    num_coeffs = bytestream2_get_byteu(&gb);\n\n    bytestream2_skip(&gb, 3); /* some constant */\n\n\n\n    if(!ctx->avctx) {\n\n        int i;\n\n\n\n        if(!(width == 160 && height == 120) &&\n\n           !(width == 320 && height == 240)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid width/height!\\n\");\n\n            return -1;\n\n        }\n\n\n\n        ctx->avctx     = avctx;\n\n        avctx->width   = width;\n\n        avctx->height  = height;\n\n        avctx->pix_fmt = PIX_FMT_YUV420P;\n\n        for(i = 0; i < 3; i++) {\n\n            ctx->num_vblocks[i] = -((-height) >> (3 + !!i));\n\n            ctx->num_hblocks[i] =     width   >> (3 + !!i) ;\n\n        }\n\n    } else if(width != ctx->avctx->width || height != ctx->avctx->height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"resolution changing is not supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(is_pframe && !ctx->buf_ptrs[ctx->prev_index].data[0]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"decoding must start with keyframe\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->buf_ptrs[ctx->cur_index].reference = 1;\n\n    ctx->buf_ptrs[ctx->cur_index].pict_type = is_pframe ? AV_PICTURE_TYPE_P:AV_PICTURE_TYPE_I;\n\n    if(ff_thread_get_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index])) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->next_prev_index = ctx->cur_index;\n\n    ctx->next_cur_index  = (ctx->cur_index - 1) & 15;\n\n\n\n    prepare_avpic(ctx, &ctx->flipped_ptrs[ctx->cur_index],\n\n                  (AVPicture*) &ctx->buf_ptrs[ctx->cur_index]);\n\n\n\n    ff_thread_finish_setup(avctx);\n\n\n\n    av_fast_malloc(&ctx->swap_buf, &ctx->swap_buf_size,\n\n                                 swap_buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if(!ctx->swap_buf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ctx->dsp.bswap_buf(ctx->swap_buf,\n\n                        (const uint32_t*) (buf + MIMIC_HEADER_SIZE),\n\n                        swap_buf_size>>2);\n\n    init_get_bits(&ctx->gb, ctx->swap_buf, swap_buf_size << 3);\n\n\n\n    if(!decode(ctx, quality, num_coeffs, !is_pframe)) {\n\n        if (avctx->active_thread_type&FF_THREAD_FRAME)\n\n            ff_thread_report_progress(&ctx->buf_ptrs[ctx->cur_index], INT_MAX, 0);\n\n        else {\n\n            ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    *(AVFrame*)data = ctx->buf_ptrs[ctx->cur_index];\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    ctx->prev_index = ctx->next_prev_index;\n\n    ctx->cur_index  = ctx->next_cur_index;\n\n\n\n    /* Only release frames that aren't used for backreferences anymore */\n\n    if(ctx->buf_ptrs[ctx->cur_index].data[0])\n\n        ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);\n\n\n\n    return buf_size;\n\n}\n", "idx": 25413, "substitutes": {"avctx": ["averctx", "aftx", "svtx", "avecookie", "wavtx", "AVpkg", "apkt", "afcp", "awtx", "ajsys", "avhandle", "vrcontext", "svsys", "avercp", "ajcontext", "vrctx", "awctx", "ajcu", "avcfg", "avpkg", "ajgc", "avcmp", "ajthis", "afsys", "ajgp", "avestate", "ajtx", "vrcmp", " avgp", "averstate", "avercontext", "awcontext", "avecv", "savcontext", "avcv", "cvctx", "awcu", "avcu", " avhandle", "vcfg", " avjac", "apctx", "avgp", "avsys", "afcontext", "aptx", " avpkg", "apcp", "avgc", " avcontext", "avstate", "wavmsg", "avecontext", "svcontext", "avcookie", "ajctx", "avercookie", "avecmp", "avemsg", "cvcmp", "savctx", "AVctx", "avectx", "avkt", "afctx", "vkt", "avmsg", "abtx", "afthis", "avtx", "abctx", " avcfg", "ajhandle", "AVcv", "avecp", "savstate", "avthis", "avetx", "svcp", "cvcontext", "avepkg", "avcontext", "svctx", "afgc", "abcontext", "averjac", " avcmp", "avergp", " avcu", "apcontext", "avcp", "apcfg", " avcv", "cvtx", "abcu", "avercu", " avcp", "ajjac", " avmsg", "wavctx", "avjac", " avkt", "aversys", "avertx", "savcookie", "avergc", "vcontext", " avtx", "AVcontext", "vctx", "AVtx", "averthis", "averhandle", "wavpkg", " avsys", "vrtx", "AVcmp"], "data": ["f", "block", "padding", "batch", "length", "stream", "ata", "d", "pad", "w", "def", "value", "body", "read", "buffer", "p", "feed", "bytes", "bits", "area", "input", "message", "frame", "image", "Data", "raw", "a", "size", "dat", "query", "text", "window", "bin", "DATA", "t", "content", "m", "name", "mu"], "data_size": [" data_length", " data_SIZE", " data_count", "data_count", "data_length", "data_SIZE"], "avpkt": ["wavwpet", "avPet", "avwpkt", "avpodkt", "avcpkt", "avwpst", "avPkt", "avpodfx", "avPst", "avcpst", "avpodacket", "wavwpct", "avcptt", "avdfx", "wavpet", "AVcpq", "wavpkt", "avcpq", "avpattt", "AVpacket", "avpatkt", "afcpfx", "avpoddr", "avpet", "afpkt", "avpst", "afpfx", "AVcpacket", "wavpct", "avdptt", "afpdr", "AVcptt", "afpacket", "wavwpkt", "wavwpst", "AVpkt", "avpacket", "avdacket", "wavpst", "avpfx", "afcpkt", "avdpacket", "avpq", "avcpfx", "avdpkt", "afcpdr", "avcpct", "afcpacket", "avptt", "AVpq", "AVcpkt", "avcpacket", "avpatacket", "avpct", "AVptt", "avPct", "avpatq", "avwpet", "avwpct", "avcpdr", "avpdr", "avdpq", "avcpet", "avddr", "avdkt"], "buf": ["pb", "queue", "uf", "bl", "br", "box", "map", "rc", "read", "buffer", "mem", "cmd", "db", "p", "img", "msg", "cb", "bytes", "vec", "raw", "b", "dat", "wb", "txt", "window", "text", "rb", "cap", "Buffer", "buff", "ptr", "pkg", "h", "t", "tmp", "v", "init", "cv"], "ctx": ["sys", "iat", "context", "cmp", "tx", "cf", "obj", "jac", "cu", "conn", "comm", "bc", "tk", "kt", "tc", "abc", "crit", "mem", "unk", "local", "gz", "ck", "act", "ctrl", "func", "cmd", "pool", "ack", "cp", "ctl", "sc", "prefix", "resp", "cb", "acl", "np", "cfg", "iac", "rt", "req", "ct", "xc", "ac", "nt", "unc", "expr", "desc", "loc", "addr", "txt", "utils", "history", "exec", "kw", "xp", "etc", "gc", "pkg", "timeout", "kl", "tmp", "cc", "jp", "wx", "lc", "cv", "hw"], "gb": ["bb", "sb", "pb", "args", "Gb", " rg", "bridge", "uf", " gu", "mb", "bc", "nb", "gt", "gom", "storage", "tc", "gif", " gcc", "bf", "GB", "sam", " gui", "gin", " GB", "g", "gu", "yg", "db", "ga", "git", "ge", " rgb", "pg", "cb", "gov", "gg", "hub", "gp", "eg", "gow", "kb", "bg", "gd", "eb", "cfg", "gm", "tg", "py", " db", "attr", "wb", "lib", "bd", "gio", "gs", "rb", " bu", "global", "sg", "gc", "rg", "cv"], "is_pframe": ["is_preframe", "is_prefram", "is_preFrame", "is_hchannel", "is_pchannel", "is_paFrame", "is_pFrame", "is_pafram", "is_paframe", "is_cchannel", "is_hFrame", "is_hframe", "is_cFrame", "is_prechannel", "is_cframe", "is_hfram", "is_pfram"], "height": ["range", "docker", "host", "id", "grow", "buffer", "count", "gh", "size", "images", "y", "history", "alpha", "base", "strength", "http", "dimension", "era", "h", "radius", "ows", " heights", "padding", "dim", "angle", "visible", "hang", "ty", "error", "tight", "level", "total", "layout", "shape", "rank", "volume", "window", "scroll", "density", "length", "title", "high", "family", "inches", "memory", "gravity", "rows", "input", "depth", "capacity", "resy", "huge", "version", "style", "resolution", "Height", "stroke", "power", "hash", "w", "pi", "above", "top", "holes", "html", "hi", "port", "SIZE", "bottom"], "quality": ["fficiency", "type", "context", "length", "confidence", "code", "status", "title", "flags", "secure", "Quality", "comments", "command", "comment", "equality", "family", "metadata", "important", "lace", "mode", "gallery", "area", "equal", "sequence", "depth", "qual", "priority", "weight", "quiet", "version", "channel", "frequency", "description", "q", "xff", "format", "name"], "num_coeffs": ["num_coffS", "num_coffes", "num_coefes", "num_coeffS", "num_coefS", "num_coefficS", "num_coeffls", "num_coffs", "num_coffls", "num_coEFFes", "num_coeffices", "num_coeffos", "num_coeffics", "num_coefficos", "num_coefs", "num_coEFFS", "num_coeffes", "num_coEFFls", "num_coefos", "num_coffos", "num_coefls", "num_coEFFs"], "i": ["ui", "o", "status", "none", "c", "ini", "id", "ice", "in", "I", "p", "count", "s", "sim", "ai", "li", "info", "ip", "ij", "y", "ci", "ico", "iu", "si", "h", "v", "ei", "ki", "\u0438", "us", " ii", "n", "io", "j", "chain", "init", "ind", "em", "m", "qi", "ix", "batch", "x", "multi", "ami", "yi", "phi", "di", "zi", "mi", "ii", "print", "is", "b", "l", "xi", "im", "f", "it", "ic", "pi", "ex", "ia", "fi", "g", "me", "gi", "set", "span", "ti", "json", "t", "index", "cli"]}}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0x8(IpvideoContext *s)\n\n{\n\n    int x, y;\n\n    unsigned char P[2];\n\n    unsigned int flags = 0;\n\n\n\n    /* 2-color encoding for each 4x4 quadrant, or 2-color encoding on\n\n     * either top and bottom or left and right halves */\n\n    CHECK_STREAM_PTR(2);\n\n\n\n    P[0] = *s->stream_ptr++;\n\n    P[1] = *s->stream_ptr++;\n\n\n\n    if (P[0] <= P[1]) {\n\n\n\n        CHECK_STREAM_PTR(14);\n\n        s->stream_ptr -= 2;\n\n\n\n        for (y = 0; y < 16; y++) {\n\n            // new values for each 4x4 block\n\n            if (!(y & 3)) {\n\n                P[0] = *s->stream_ptr++; P[1] = *s->stream_ptr++;\n\n                flags = bytestream_get_le16(&s->stream_ptr);\n\n            }\n\n\n\n            for (x = 0; x < 4; x++, flags >>= 1)\n\n                *s->pixel_ptr++ = P[flags & 1];\n\n            s->pixel_ptr += s->stride - 4;\n\n            // switch to right half\n\n            if (y == 7) s->pixel_ptr -= 8 * s->stride - 4;\n\n        }\n\n\n\n    } else {\n\n\n\n        /* need 10 more bytes */\n\n        CHECK_STREAM_PTR(10);\n\n\n\n        if (s->stream_ptr[4] <= s->stream_ptr[5]) {\n\n\n\n            flags = bytestream_get_le32(&s->stream_ptr);\n\n\n\n            /* vertical split; left & right halves are 2-color encoded */\n\n\n\n            for (y = 0; y < 16; y++) {\n\n                for (x = 0; x < 4; x++, flags >>= 1)\n\n                    *s->pixel_ptr++ = P[flags & 1];\n\n                s->pixel_ptr += s->stride - 4;\n\n                // switch to right half\n\n                if (y == 7) {\n\n                    s->pixel_ptr -= 8 * s->stride - 4;\n\n                    P[0] = *s->stream_ptr++; P[1] = *s->stream_ptr++;\n\n                    flags = bytestream_get_le32(&s->stream_ptr);\n\n                }\n\n            }\n\n\n\n        } else {\n\n\n\n            /* horizontal split; top & bottom halves are 2-color encoded */\n\n\n\n            for (y = 0; y < 8; y++) {\n\n                if (y == 4) {\n\n                    P[0] = *s->stream_ptr++;\n\n                    P[1] = *s->stream_ptr++;\n\n                }\n\n                flags = *s->stream_ptr++ | 0x100;\n\n\n\n                for (; flags != 1; flags >>= 1)\n\n                    *s->pixel_ptr++ = P[flags & 1];\n\n                s->pixel_ptr += s->line_inc;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* report success */\n\n    return 0;\n\n}\n", "idx": 25448, "substitutes": {"s": ["service", "comm", "sports", "c", "comments", "r", "ar", "p", "changes", "ares", "aws", "vs", "S", "gins", "ns", "states", "less", "http", "h", "v", "sq", "ess", "i", "sb", "os", "rs", "us", "n", "cs", "services", "als", "ats", "ts", "ims", "acs", "tes", "its", "parts", "m", "sys", "ms", "as", "ins", "ants", "results", "ids", "bis", "sts", "ast", "bs", "a", "is", "b", "l", "ps", "stats", "gs", "ls", "this", "ssl", "f", "ports", "se", "fs", "w", "ds", "hs", "details", "g", "ans", "webkit", "an", "js", "ss", "https", "qs", "es", "e", "sv", "sg", "t", "conf"], "x": ["f", "fx", "xa", "i", "ux", "tx", "on", "o", "xy", "xd", "ick", "att", "xml", "w", "xt", "ex", "xes", "at", "dx", "mx", "act", "rx", "g", "path", "n", "p", "el", "ord", "ax", "mat", "add", "lat", "j", "X", "xx", "lon", "xxx", "xs", "xf", "l", "xc", "php", "ct", "ip", "dr", "ox", "key", "z", "step", "px", "e", "u", "xp", "xi", "h", "q", "ml", "index", "wx", "m", "crop", "ix"], "y": ["o", "c", "yx", "er", "yout", "iley", "or", "axy", "p", "ny", "cy", "any", "ies", "z", "ey", "h", "ly", "sy", "v", "xxx", "pt", "hey", "ch", "i", "gy", "xy", "try", "ty", "yy", "uy", "height", "n", "ye", "j", "lat", "yo", "year", "py", "key", "scroll", "oy", "m", "ot", "sys", "my", "on", "hot", "yt", "yi", "ry", "iy", "wy", "yl", "xx", "kit", "vy", "b", "yr", "ya", "yet", "Y", "no", "it", "out", "ay", "yn", "sky", "yer", "lon", "html", "yes", "e", "by", "ys", "t", "ym"], "P": ["Progress", "TP", "A", "PR", "PI", "PT", "I", "p", "Ps", "S", "PUT", "Pay", "Query", "PK", "N", "G", "NP", "C", "SCP", "F", "Path", "PS", "PC", "Pro", "D", "Message", "LP", "PO", "Cache", "PA", "If", "YP", "AFP", "X", "Format", "T", "AP", "MP", "H", "Request", "Q", "Policy", "L", "AMP", "FP", "New", "M", "PD", "GP", "J", "Map", "PB", "O", "State", "vP", "All", "DP", "R", "BP", "Y", "PE", "Other", "Command", "IP", "Port", "SP", "List", "B", "CP", "Array", "K", "PIN", "V", "PP", "JP", "HP", "Copy", "Part", "CB"]}}
{"project": "qemu", "commit_id": "70976a7926b42d87e0c575412b85a8f5c1e48fad", "target": 1, "func": "static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#ifdef WORDS_BIGENDIAN\n\n        env->avr[n].u64[0] = ldq_p(mem_buf);\n\n        env->avr[n].u64[1] = ldq_p(mem_buf+8);\n\n#else\n\n        env->avr[n].u64[1] = ldq_p(mem_buf);\n\n        env->avr[n].u64[0] = ldq_p(mem_buf+8);\n\n#endif\n\n        return 16;\n\n    }\n\n    if (n == 33) {\n\n        env->vscr = ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    if (n == 34) {\n\n        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25459, "substitutes": {"env": ["see", "queue", "disk", "En", "er", "dev", "buffer", "var", "ten", "extra", "et", "ctx", "vs", "environment", "estate", "runner", "info", "expr", "equ", "EN", "ptr", "era", "h", "v", "ee", "enter", "here", "ev", "conn", "code", "entry", "erd", "operator", "ec", "spec", "buf", "te", "enc", "next", " Environment", "desc", "tern", "window", "global", "en", "exc", "Environment", "context", "kernel", "engine", "esc", "ef", "network", "console", "ah", "policy", "shell", "worker", "style", "manager", "stack", "ov", "server", "ner", "err", "viron", "w", "event", "ew", "empty", "ext", "message", " environment", "start", "query", "e", "sv", "hl", "end", "eng"], "mem_buf": ["memocbuf", "memdcat", " mem_queue", "mem_queue", "mem2buf", "mem2uf", "mem__bag", " mem_buffer", "memdbuf", " mem_bin", "memoccur", "mem__buffer", "mem2orig", "mem2bin", "memocmu", " mem_bag", "mem_orig", "memablequeue", "mem64buf", "mem__buf", "mem_cache", " mem_cache", "memablecomb", "mem__cur", " mem_buff", "mem64buff", "mem_comb", "memablebuf", "mem_mu", "mem_cat", "mem_cur", "memdcache", "mem2buff", " mem_orig", " mem_cat", "mem2buffer", " mem_mu", "mem64orig", "mem_block", "mem_buff", " mem_cur", "mem_buffer", "mem_bin", " mem_comb", "mem64buffer", "mem_bag", " mem_block", "mem_uf", " mem_uf"], "n": ["sn", "i", "na", " nm", "o", "nn", "nm", "conn", "norm", "len", "nb", "d", "nan", "nr", "none", "ln", " ni", "c", "ren", "ng", "tn", "g", " ns", " ng", "count", "fn", "p", "el", "nc", "cn", "ny", "new", "sw", "an", "nw", "j", "nu", "np", "ne", "any", "nil", "l", "ns", " num", "nt", "size", "y", "nor", "z", "dn", "N", "num", "gn", " fn", "en", "number", "un", "all", "no", "m", "v", "names", "name"]}}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "static void vga_draw_text(VGACommonState *s, int full_update)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int cx, cy, cheight, cw, ch, cattr, height, width, ch_attr;\n\n    int cx_min, cx_max, linesize, x_incr, line, line1;\n\n    uint32_t offset, fgcol, bgcol, v, cursor_offset;\n\n    uint8_t *d1, *d, *src, *dest, *cursor_ptr;\n\n    const uint8_t *font_ptr, *font_base[2];\n\n    int dup9, line_offset;\n\n    uint32_t *palette;\n\n    uint32_t *ch_attr_ptr;\n\n    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);\n\n\n\n    /* compute font data address (in plane 2) */\n\n    v = s->sr[VGA_SEQ_CHARACTER_MAP];\n\n    offset = (((v >> 4) & 1) | ((v << 1) & 6)) * 8192 * 4 + 2;\n\n    if (offset != s->font_offsets[0]) {\n\n        s->font_offsets[0] = offset;\n\n        full_update = 1;\n\n    }\n\n    font_base[0] = s->vram_ptr + offset;\n\n\n\n    offset = (((v >> 5) & 1) | ((v >> 1) & 6)) * 8192 * 4 + 2;\n\n    font_base[1] = s->vram_ptr + offset;\n\n    if (offset != s->font_offsets[1]) {\n\n        s->font_offsets[1] = offset;\n\n        full_update = 1;\n\n    }\n\n    if (s->plane_updated & (1 << 2) || s->has_chain4_alias) {\n\n        /* if the plane 2 was modified since the last display, it\n\n           indicates the font may have been modified */\n\n        s->plane_updated = 0;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_basic_params(s);\n\n\n\n    line_offset = s->line_offset;\n\n\n\n    vga_get_text_resolution(s, &width, &height, &cw, &cheight);\n\n    if ((height * width) <= 1) {\n\n        /* better than nothing: exit if transient size is too small */\n\n        return;\n\n    }\n\n    if ((height * width) > CH_ATTR_SIZE) {\n\n        /* better than nothing: exit if transient size is too big */\n\n        return;\n\n    }\n\n\n\n    if (width != s->last_width || height != s->last_height ||\n\n        cw != s->last_cw || cheight != s->last_ch || s->last_depth) {\n\n        s->last_scr_width = width * cw;\n\n        s->last_scr_height = height * cheight;\n\n        qemu_console_resize(s->con, s->last_scr_width, s->last_scr_height);\n\n        surface = qemu_console_surface(s->con);\n\n        dpy_text_resize(s->con, width, height);\n\n        s->last_depth = 0;\n\n        s->last_width = width;\n\n        s->last_height = height;\n\n        s->last_ch = cheight;\n\n        s->last_cw = cw;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_palette16(s);\n\n    palette = s->last_palette;\n\n    x_incr = cw * surface_bytes_per_pixel(surface);\n\n\n\n    if (full_update) {\n\n        s->full_update_text = 1;\n\n    }\n\n    if (s->full_update_gfx) {\n\n        s->full_update_gfx = 0;\n\n        full_update |= 1;\n\n    }\n\n\n\n    cursor_offset = ((s->cr[VGA_CRTC_CURSOR_HI] << 8) |\n\n                     s->cr[VGA_CRTC_CURSOR_LO]) - s->start_addr;\n\n    if (cursor_offset != s->cursor_offset ||\n\n        s->cr[VGA_CRTC_CURSOR_START] != s->cursor_start ||\n\n        s->cr[VGA_CRTC_CURSOR_END] != s->cursor_end) {\n\n      /* if the cursor position changed, we update the old and new\n\n         chars */\n\n        if (s->cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[s->cursor_offset] = -1;\n\n        if (cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[cursor_offset] = -1;\n\n        s->cursor_offset = cursor_offset;\n\n        s->cursor_start = s->cr[VGA_CRTC_CURSOR_START];\n\n        s->cursor_end = s->cr[VGA_CRTC_CURSOR_END];\n\n    }\n\n    cursor_ptr = s->vram_ptr + (s->start_addr + cursor_offset) * 4;\n\n    if (now >= s->cursor_blink_time) {\n\n        s->cursor_blink_time = now + VGA_TEXT_CURSOR_PERIOD_MS / 2;\n\n        s->cursor_visible_phase = !s->cursor_visible_phase;\n\n    }\n\n\n\n    dest = surface_data(surface);\n\n    linesize = surface_stride(surface);\n\n    ch_attr_ptr = s->last_ch_attr;\n\n    line = 0;\n\n    offset = s->start_addr * 4;\n\n    for(cy = 0; cy < height; cy++) {\n\n        d1 = dest;\n\n        src = s->vram_ptr + offset;\n\n        cx_min = width;\n\n        cx_max = -1;\n\n        for(cx = 0; cx < width; cx++) {\n\n            ch_attr = *(uint16_t *)src;\n\n            if (full_update || ch_attr != *ch_attr_ptr || src == cursor_ptr) {\n\n                if (cx < cx_min)\n\n                    cx_min = cx;\n\n                if (cx > cx_max)\n\n                    cx_max = cx;\n\n                *ch_attr_ptr = ch_attr;\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n                ch = ch_attr >> 8;\n\n                cattr = ch_attr & 0xff;\n\n#else\n\n                ch = ch_attr & 0xff;\n\n                cattr = ch_attr >> 8;\n\n#endif\n\n                font_ptr = font_base[(cattr >> 3) & 1];\n\n                font_ptr += 32 * 4 * ch;\n\n                bgcol = palette[cattr >> 4];\n\n                fgcol = palette[cattr & 0x0f];\n\n                if (cw == 16) {\n\n                    vga_draw_glyph16(d1, linesize,\n\n                                     font_ptr, cheight, fgcol, bgcol);\n\n                } else if (cw != 9) {\n\n                    vga_draw_glyph8(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol);\n\n                } else {\n\n                    dup9 = 0;\n\n                    if (ch >= 0xb0 && ch <= 0xdf &&\n\n                        (s->ar[VGA_ATC_MODE] & 0x04)) {\n\n                        dup9 = 1;\n\n                    }\n\n                    vga_draw_glyph9(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol, dup9);\n\n                }\n\n                if (src == cursor_ptr &&\n\n                    !(s->cr[VGA_CRTC_CURSOR_START] & 0x20) &&\n\n                    s->cursor_visible_phase) {\n\n                    int line_start, line_last, h;\n\n                    /* draw the cursor */\n\n                    line_start = s->cr[VGA_CRTC_CURSOR_START] & 0x1f;\n\n                    line_last = s->cr[VGA_CRTC_CURSOR_END] & 0x1f;\n\n                    /* XXX: check that */\n\n                    if (line_last > cheight - 1)\n\n                        line_last = cheight - 1;\n\n                    if (line_last >= line_start && line_start < cheight) {\n\n                        h = line_last - line_start + 1;\n\n                        d = d1 + linesize * line_start;\n\n                        if (cw == 16) {\n\n                            vga_draw_glyph16(d, linesize,\n\n                                             cursor_glyph, h, fgcol, bgcol);\n\n                        } else if (cw != 9) {\n\n                            vga_draw_glyph8(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol);\n\n                        } else {\n\n                            vga_draw_glyph9(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol, 1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            d1 += x_incr;\n\n            src += 4;\n\n            ch_attr_ptr++;\n\n        }\n\n        if (cx_max != -1) {\n\n            dpy_gfx_update(s->con, cx_min * cw, cy * cheight,\n\n                           (cx_max - cx_min + 1) * cw, cheight);\n\n        }\n\n        dest += linesize * cheight;\n\n        line1 = line + cheight;\n\n        offset += line_offset;\n\n        if (line < s->line_compare && line1 >= s->line_compare) {\n\n            offset = 0;\n\n        }\n\n        line = line1;\n\n    }\n\n}\n", "idx": 25472, "substitutes": {"s": ["sis", "status", "sports", "c", "sam", "comments", "sync", "r", "ar", "p", "changes", "vs", "S", "ns", "states", "less", "sq", "views", "space", "sb", "os", "rs", "sl", "spec", "n", "state", "cs", "services", "als", "ats", "ts", "ims", "acs", "styles", "its", "m", "sys", "as", "ins", "ses", "results", "sts", "sw", "bs", "is", "ps", "stats", "gs", "ls", "q", "this", "ports", "se", "fs", "w", "ds", "hs", "details", "g", "resource", "set", "js", "ss", "settings", "qs", "es", "sv", "self", "source", "t", "conf"], "full_update": [" full__update", "full2update", " full_up", "full_up", "full2updated", "full2Update", "complete_change", "complete_update", "complete_check", "full___update", "complete_up", "fulllyup", "full__Update", "fulllogcheck", "fulllogupdate", "full__fail", "full_edit", "fullvalup", "full_Update", " full_check", "full_fail", " full_fail", "full_flush", "fulllycheck", "full___change", "fullvalflush", "full__updated", "full_check", "fulllyfail", "full__update", "complete_buffer", "full___check", "full__check", " full__up", "fullvaledit", " full__check", "fulllyupdate", " full__fail", "fullvalupdate", "complete_flush", "complete_edit", "complete_Update", "complete_updated", "fulllogbuffer", "full_change", "full__up", "full_buffer", "full2up", "fulllogflush", "full_updated"], "surface": ["f", "plane", "ui", "client", "sheet", "uf", "cell", "display", "profile", "screen", "buffer", "console", "view", "tile", "layout", "image", "face", "port", "document", "fac", "sm", "window", "sur", "con", "source", "table", "manager"], "cx": ["pcpx", "pcw", "Cwd", "tcpx", "Cx", "cpx", "tcwd", "tcx", "Cw", "pcwd", "cwd", "Cpx", "tcw", "pcx"], "cy": ["my", "ce", "xy", "sty", "col", "cell", "cor", "c", "cd", "cycle", "ty", "ry", "dc", "sky", "currency", "cow", "wy", "cb", "cm", "ht", "center", "ct", "y", "cr", "ico", "scroll", "sy"], "cheight": ["riceight", "riceck", "clealth", "cleigh", "cleck", "ricealth", "ceights", "chearge", "cleight", "chyights", "scheight", "cheights", "scheuth", "cheuth", "ceight", "chyuth", "chight", "ceuth", "chck", "riceigh", "schearge", "cearge", "chigh", "chalth", "cheigh", "chyarge", "check", "scheights", "chealth", "chyight"], "cw": ["ctow", "ccw", " cwd", "ccwp", "xwd", "ctwd", "xw", " cwp", "cwp", "cow", "xx", "xow", "ctx", "ccow", "cox", "cowp", "cwd", "ccx", "ccwd", "ctw", "cowd"], "ch": ["chan", "CH", "chip", "col", "wh", "c", "ech", "cd", "zh", "high", "cp", "count", "tch", "cs", "cb", "cm", "ht", "th", "ach", "ct", "cht", "attr", "y", "channel", "ich"], "cattr": ["Cattribute", "Cdata", "Cattr", "catt", "qattribute", "qdata", "lcatt", "lcdata", "Catt", "lcattribute", "lcattr", "qattr", "cdata", "cattribute", "qatt"], "height": ["padding", "dim", "length", "x", "angle", "power", "hash", "stroke", "wh", "w", "hang", "ty", "sky", "zh", "high", "row", "kh", "sh", "rows", "ht", "hei", "depth", "shape", "th", "html", "hi", "gh", "capacity", "size", "scale", "volume", "y", "huge", "history", "window", "style", "resolution", "max", "radius", "Height", "density", "bottom"], "ch_attr": ["ch_attribute", "ch_err", "th_att", "th_attribute", "th_attr", "ch_att", "ch__err", "ch__att", "ch__attribute", "th_err", "ch__attr"], "cx_min": ["cw_min", "cx_mins", "cw_start", "cw_mins", "cw_max", "cx_start"], "cx_max": ["cw_scale", "cw_ax", "cw_total", "cx_total", "cx_ax", "cw_max", "cx_scale"], "linesize": ["linsiz", "inesized", "inesize", "linsize", " linesiz", "inesizer", "linesiz", "linesizer", " linesizer", " linesized", "linsizer", "linsized", "linesized", "inesiz"], "x_incr": ["x_scar", "x_acar", "x_incrs", "x_acr", "x_incar", "x_incer", "x_scer", "x_accr", "x_scr", "x_accrs", "x_scrs", "x_accar", "x_accer", "x_acrs", "x_acer"], "line": ["block", "pipe", "edge", "col", "cell", "ln", "path", "row", "ine", "eline", "lines", "column", "le", "lin", "Line", "l", "page", "color", "text", "link", "limit", "position", "draw", "index", "stroke"], "line1": ["link2", "Line2", "l0", "line2", "line0", "l1", "l2", "Line1", "link1", "link0", "Line0"], "offset": ["field", "o", "OFF", "address", "output", "buffer", "command", "pointer", "prefix", "et", "origin", "pos", "frame", "associated", "location", "size", "info", "vector", "usage", "table", "sample", "Offset", "padding", "item", "entry", "skip", "error", "translation", "transform", "layout", "key", "iter", "scroll", "slot", "timeout", "format", "point", "length", "peer", "reset", "op", "update", "pad", "coord", "seek", "version", "limit", "time", "style", "off", "iso", "frequency", "no", "f", "option", "attribute", "out", "append", "ref", "zero", "event", "adjusted", "set", "tile", "start", "shift", "position", "tif", "sp", "e", "flag", "seed", "trace", "encrypted", "index"], "fgcol": ["rgcol", "fxrc", "bgrc", "rgCol", "fgcolor", "bgCol", "fgrc", "rgrc", "fxCol", "fgCol", "rgcolor", "bgcolor", "fxcolor", "fxcol"], "bgcol": ["rgcol", "rgchar", "rgcycle", "BGcol", "bbcycle", "bgchar", "bgcycle", "BGcycle", "rgcolor", "bbcol", "BGchar", "bbcolor", "bbchar", "bgcolor", "BGcolor"], "v": ["f", "vm", "i", "conv", "ev", "lv", "iv", "vp", "w", "tv", "value", "c", "video", "dev", "NV", "buffer", "vv", "get", "g", "r", "n", "p", "ve", "ver", "va", "vol", "vr", "j", "view", "inv", "vo", "av", "V", "b", "l", "data", "vc", "size", "y", "color", "version", "vector", "sv", "u", "qv", "vi", "t", "vt", "q", "m", "uv", "cv"], "cursor_offset": ["crow_offset", "crow_address", "cursor_off", "crow_ptr", "cursor__offset", "crow_off", "cursor__ptr", "cursor_address", "cursor__off", "cursor__address"], "d1": ["d0", "ds0", "D0", "ds2", "D2", "dim0", "D1", "d2", "ds3", "ds1", "dim1", "dim3", "dim2", "D3", "d3"], "d": ["f", "dim", "direction", "dir", "c", "done", "D", "dc", "ds", "g", "r", "n", "p", "dt", "di", "dist", "depth", "ind", "l", "desc", "e", "draw", "du", "dimension", "t", "dep", "m"], "src": ["sys", "sn", "cur", "trans", "dir", "ins", "rl", "rs", "sub", "rc", "sl", "r", "inst", "sr", "sc", "img", "ser", "input", "bg", "rt", "ind", "start", "scale", "loc", "addr", "st", "source", "ptr"], "dest": ["prop", "cur", "err", "dir", "pipe", "id", "del", "target", "cat", "comment", "mode", "img", "usr", "buf", "origin", "coord", "Dest", "orig", "way", "desc", "port", "wb", "loc", "num", "iter", "source", "table", "name"], "cursor_ptr": ["cram_addr", "cursor_addr", "cram_pointer", "cram_ptr", "cram_offset", "cursor_pointer"], "font_ptr": ["fontityptr", "fontitytile", "font_pointer", "fontityoffset", "text_ptr", "text_tile", "fontitypointer", "text_pointer", "text_offset", "font_offset", "font_tile"], "font_base": ["fontalspace", "font_buffer", " font_bas", "font_bas", "fontalbase", "font4prefix", "font_Base", "font2Base", "tab_buffer", "font___base", "tab_bas", " font_mask", "fontalmask", " font_space", "font_prefix", "font_space", "font___space", "font4bas", "font_mask", "tab_base", "font___mask", "font4list", "font4base", " font_prefix", "font2base", "tab_Base", "font2buffer", "font2bas", "font_list", " font_list"], "dup9": ["duvwin", "dunp9", "duppwin", " derp9", " dernp3", " dernpwin", "duv9", "duv7", " derp7", "dupwin", "dunp7", "dup3", " dernp9", "dupp9", " dernp7", " derp3", "dunp3", "dupp7", "dunpwin", "dup7", " derpwin", "duv3", "dupp3"], "line_offset": ["line___pos", "line_position", "line___position", "line_Offset", "line___offset", "line_pos", "line__position", "line__pos", " line_no", "Line_position", "line__no", "line___index", "line__offset", " line_position", " line_Offset", "line_no", "line_set", "Line_set", "Line_offset", "line__index", "Line_pos", "line_index", "Line_index", "line__Offset"], "palette": ["Palbo", "Palette", "polettes", "Palcolor", "polette", "polcolor", "palbo", "plcolor", "plbo", "palettes", "plettes", "polbo", "palcolor", "plette", "Palettes"], "ch_attr_ptr": ["ch_att_pointer", "ch_attr__offset", "ch_att_addr", "ch_attr__ptr", "ch_attr_pointer", "ch_attr__addr", "ch_attr_addr", "ch_attr_offset", "ch_attr__pointer", "ch_att_ptr", "ch_att_offset"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int64_t qemu_ftell(QEMUFile *f)\n\n{\n\n    qemu_fflush(f);\n\n    return f->pos;\n\n}\n", "idx": 25492, "substitutes": {"f": ["fb", "af", "alf", "i", "cf", "ref", "uf", "ff", "fw", "fa", "fs", "d", "tf", "w", "c", "fr", "fi", "g", "fm", "r", "lf", "p", "fn", "df", "rf", "file", "a", "fab", "l", "b", "fac", "fe", "fd", "fc", "e", "fo", "sf", "fp", "t", "h", "q", "v", "F"]}}
{"project": "FFmpeg", "commit_id": "2d40a09b6e73230b160a505f01ed1acf169e1d9f", "target": 1, "func": "static int libquvi_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    LibQuviContext *qc = s->priv_data;\n\n    return av_read_frame(qc->fmtctx, pkt);\n\n}\n", "idx": 25501, "substitutes": {"s": ["sys", "i", "as", "sa", "sb", "ins", "os", "comm", "rs", "c", "ses", "ds", "spec", "n", "p", "cs", "sts", "set", "aws", "S", "js", "ss", "a", "ats", "b", "ns", "ts", "ps", "acs", "stats", "z", "gs", "sg", "h", "t", "q", "m", "sq"], "pkt": ["packqt", "Pet", "ppkt", "ppqt", "packnt", "ppnt", "pet", "packkt", "fkt", " pct", "facket", " packet", "packet", "fct", "packacket", "fet", "Packet", "pct", " pnt", " pet", "Pct", " pqt", "pqt", "Pkt", "pnt", "ppacket"], "qc": ["querypc", "qcor", " qdc", "quc", "qupc", " mypc", "qpc", "quci", "qdc", " qpc", "queryci", "qci", "queryc", " mydc", "ckcor", "sqpc", "querysc", " myc", " qcor", "ckc", "qusc", "ckpc", "qsc", "sqc", "ckdc", "sqsc", " mycor", "sqci"]}}
{"project": "qemu", "commit_id": "30d335d68d93705eb346387c03bb6aca0f52454a", "target": 1, "func": "static PCIDevice *qemu_pci_hot_add_storage(Monitor *mon,\n\n                                           const char *devaddr,\n\n                                           const char *opts)\n\n{\n\n    PCIDevice *dev;\n\n    DriveInfo *dinfo = NULL;\n\n    int type = -1;\n\n    char buf[128];\n\n    PCIBus *bus;\n\n    int devfn;\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", opts)) {\n\n        if (!strcmp(buf, \"scsi\"))\n\n            type = IF_SCSI;\n\n        else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n        } else {\n\n            monitor_printf(mon, \"type %s not a hotpluggable PCI device.\\n\", buf);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        monitor_printf(mon, \"no if= specified\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"file\", opts)) {\n\n        dinfo = add_init_drive(opts);\n\n        if (!dinfo)\n\n            return NULL;\n\n        if (dinfo->devaddr) {\n\n            monitor_printf(mon, \"Parameter addr not supported\\n\");\n\n            return NULL;\n\n        }\n\n    } else {\n\n        dinfo = NULL;\n\n    }\n\n\n\n    bus = pci_get_bus_devfn(&devfn, devaddr);\n\n    if (!bus) {\n\n        monitor_printf(mon, \"Invalid PCI device address %s\\n\", devaddr);\n\n        return NULL;\n\n    }\n\n\n\n    switch (type) {\n\n    case IF_SCSI:\n\n        if (!dinfo) {\n\n            monitor_printf(mon, \"scsi requires a backing file/device.\\n\");\n\n            return NULL;\n\n        }\n\n        dev = pci_create(bus, devfn, \"lsi53c895a\");\n\n        if (qdev_init(&dev->qdev) < 0)\n\n            dev = NULL;\n\n        if (dev) {\n\n            BusState *scsibus = QLIST_FIRST(&dev->qdev.child_bus);\n\n            scsi_bus_legacy_add_drive(DO_UPCAST(SCSIBus, qbus, scsibus),\n\n                                      dinfo, dinfo->unit);\n\n        }\n\n        break;\n\n    case IF_VIRTIO:\n\n        if (!dinfo) {\n\n            monitor_printf(mon, \"virtio requires a backing file/device.\\n\");\n\n            return NULL;\n\n        }\n\n        dev = pci_create(bus, devfn, \"virtio-blk-pci\");\n\n        qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n        if (qdev_init(&dev->qdev) < 0)\n\n            dev = NULL;\n\n        break;\n\n    default:\n\n        dev = NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 25505, "substitutes": {"mon": ["demon", "von", "gun", "ston", "Mon", "man", "conn", "MON", "rain", "ann", "mut", "sam", "mun", "mm", "mx", "chron", "mer", "cat", "det", "tem", "wat", "san", "vis", "dm", "mat", "monitor", "mot", "msg", "med", "monkey", "an", "mi", "hog", "annot", "dat", "mn", "met", "num", "net", "mt", "en", "dom", "mons", "tom", "onet", "mont", "mu", "admin"], "devaddr": ["deviceadd", " devname", "deviceAddress", "privaddr", "evaddr", "devname", "devsrc", " devsrc", " devid", "evid", " devadd", "devadd", "desptr", "privaddress", "evsrc", "devAddress", "privadd", "devaddress", " devptr", "evAddress", "developAddress", "devid", "desname", "deviceaddr", "developaddress", "evaddress", "desaddr", "developaddr", "evptr", " devaddress", " devadr", "privadr", "devadr", "deviceaddress", "deviceadr", "evname", "dessrc", "devptr", "deviceid"], "opts": ["opals", "optr", "OPals", "ops", "props", " opsp", "OPsp", "optionsals", "opsp", "optfs", "optionsps", "optals", " opfs", "optsp", " ops", "OPs", "opttr", "optionsfs", "prokt", " optr", "optters", "optionsts", "OPtr", "optkt", "opters", "OPts", "OPters", "opkt", " opkt", " opters", " opps", "prots", "opfs", "opps", "optps", "OPps", "optts", "OPfs"], "dev": ["tech", "jump", "stick", "d", "att", "valid", "er", "mem", "del", "var", "vo", "raw", "any", "info", "stable", "serial", "der", "dep", "v", "env", "sd", "dis", "obj", "ev", "boot", "conn", "adv", "gu", "db", "ver", "data", "de", "fun", "des", "window", "fo", "hw", "device", "den", "cam", "iv", "pad", "normal", "def", "wd", "comment", "di", "go", "doc", "dem", "serv", "driver", "off", "tr", "priv", "block", "ad", "out", "err", "home", "ow", "w", " device", "watch", "debug", "event", "local", "cmd", "DEV", "ve", "develop", "rent", "die", "nt", "dd", "Dev", "pro", " devs", "conf"], "dinfo": ["fdinformation", "pfo", " dinf", "pinfo", "dstate", "djiter", "ditype", "xfo", "sdfo", "didinformation", "dinf", "Dinf", "binformation", "pINFO", "DInfo", "binfo", "ddinformation", "linf", "dinformation", "destate", "djinf", "deinformation", "dti", "pInfo", " dinformation", "indti", "fdinf", "dxti", "dsINFO", " dno", "ddstate", "dditer", "binf", "diter", "dresult", "Dinfo", "vdresult", "vdinformation", "pinf", "indinit", "fdInfo", "fdinfo", "djinfo", " dfo", "bInfo", "indfo", "indinf", "dderror", "dxinfo", "xInfo", "dxinf", "deinf", "didresult", " dInfo", "linformation", "linfo", "dtype", "djerror", "sdinit", "lno", "indinfo", "dInfo", "dINFO", "deinfo", "sdinf", "ltype", "Dresult", "lfo", "vdinfo", "pinformation", " dINFO", "didInfo", "dsinfo", "sdinfo", "xinf", "diinfo", "didinfo", "dino", "dinit", " dinit", "ddinf", "pti", "lInfo", "dsfo", "difo", "ddinfo", "xinfo", "vdInfo", "piter", "dxfo", " dstate", "derror", " dtype", "dfo", "Dfo", "Dinformation", "dno"], "buf": ["pb", "queue", "comm", "map", "buffer", "mem", "path", "pool", "pg", "ctx", "raw", "orig", "bt", " buffer", "mt", "pkg", "v", "pack", "tx", "cf", "br", "bc", "phy", "good", "cp", "Buff", "msg", "bag", " b", "data", "aka", "window", "bin", "Buffer", "buff", "batch", "box", "pad", "seq", " buffers", "bytes", "bs", "doc", "cfg", "b", "addr", "alloc", "rb", "rw", "off", "tr", "tmp", "str", "cv", "block", " cmd", "err", "nm", "ref", "uf", "rc", "cmd", "cache", " buff", "img", "mat", "cb", "req", "txt", "bh", "cap", "eng", "proc", "conv"], "bus": ["block", "Bus", "sys", "board", "hand", "gen", "dir", "home", "bridge", "boot", "box", "stick", " BUS", "os", "host", "bc", "us", "bo", "bolt", "disk", "mount", "proxy", "book", "cat", "db", "cus", "soc", "BUS", "holder", "vol", "util", "hub", "root", "bal", "machine", "phys", "bs", "bug", "kit", "bill", "bu", "chain", "b", "usb", "way", "vc", "nt", "loc", "lib", "bur", "handle", "net", " buses", "buff", "loop", "lock", "bid"], "devfn": [" devFN", " devname", "devname", " Devln", "evaddr", "defnm", " devnm", " devnn", "linknn", "devsyn", "linkfun", "devln", " devln", " devfun", "devfun", " Devfn", " Devsyn", "testfn", "defaddr", "linkfn", "DEVfun", "evnm", "deffn", "evFN", "devnn", "DEVfn", "padsyn", "padfn", "devnm", "defname", "DEVln", "evfn", "evsyn", "testaddr", "devFN", "padFN", "padln", "evln", "DEVnn", "evname", "testFN", " DevFN", "linkln"], "scsibus": [" scssibus", " scsis", " scsisi", " scssis", "sccsis", "sccsisu", "scsgisi", " scssicol", " scssisu", "scsisi", "scisibus", " scsisu", "scssisi", "scssisu", "scsis", "scsgis", "sccsibus", "scisis", "scssicol", "scsgisu", " scssic", " scsic", "scsgibus", " scsicol", "scsisu", "scssic", "scsinicol", "scssis", "scisic", "scsinis", "scsicol", "scsinibus", "scsic", " scssisi", "scsinic", "scisicol", "sccsisi", "scssibus"]}}
{"project": "qemu", "commit_id": "6fedcaa1c5419fa89c31fd34dabbd71861c615d2", "target": 0, "func": "uint16_t eeprom93xx_read(eeprom_t *eeprom)\n\n{\n\n    /* Return status of pin DO (0 or 1). */\n\n    logout(\"CS=%u DO=%u\\n\", eeprom->eecs, eeprom->eedo);\n\n    return (eeprom->eedo);\n\n}\n", "idx": 25510, "substitutes": {"eeprom": ["meepprom", "ceEPprom", "eyprom", "ceeprom", "eebdem", "peepsprom", "eEPdem", "meecom", "eecom", "eepsram", "eEPprom", "meepchrom", "meepom", "eepdem", "ceEProm", "eepsdem", "peepsdem", "meecchrom", "eepram", "ceepdem", "eecprom", "eecdem", "peepsom", "meecrom", "eepsom", "eypom", "peepsrom", "meecprom", "peepram", "ceepchrom", "eEPom", "eypram", "meeprom", "eepschrom", "peepprom", "ceEPchrom", "eecrom", "eypdem", "eebram", "eebom", "peepom", "peepdem", "ceepprom", "eepsrom", "peepsram", "eEProm", "eebprom", "eebchrom", "eepchrom", "eEPram", "eecchrom", "eEPchrom", "eepom", "eepsprom", "eepprom", "eebrom", "peeprom", "ceEPdem"]}}
{"project": "qemu", "commit_id": "f3172a0e2e7bd983cada19f11d9bb59400e0dd3d", "target": 0, "func": "static void sysctl_write(void *opaque, target_phys_addr_t addr, uint32_t value)\n\n{\n\n    MilkymistSysctlState *s = opaque;\n\n\n\n    trace_milkymist_sysctl_memory_write(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_GPIO_OUT:\n\n    case R_GPIO_INTEN:\n\n    case R_TIMER0_COUNTER:\n\n        if (value > s->regs[R_TIMER0_COUNTER]) {\n\n            value = s->regs[R_TIMER0_COUNTER];\n\n            error_report(\"milkymist_sysctl: timer0: trying to write a \"\n\n                    \"value greater than the limit. Clipping.\");\n\n        }\n\n        /* milkymist timer counts up */\n\n        value = s->regs[R_TIMER0_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer0, value);\n\n        break;\n\n    case R_TIMER1_COUNTER:\n\n        if (value > s->regs[R_TIMER1_COUNTER]) {\n\n            value = s->regs[R_TIMER1_COUNTER];\n\n            error_report(\"milkymist_sysctl: timer1: trying to write a \"\n\n                    \"value greater than the limit. Clipping.\");\n\n        }\n\n        /* milkymist timer counts up */\n\n        value = s->regs[R_TIMER1_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer1, value);\n\n        break;\n\n    case R_TIMER0_COMPARE:\n\n        ptimer_set_limit(s->ptimer0, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER1_COMPARE:\n\n        ptimer_set_limit(s->ptimer1, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER0_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER0_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer0, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer0);\n\n        }\n\n        break;\n\n    case R_TIMER1_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER1_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer1, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer1);\n\n        }\n\n        break;\n\n    case R_ICAP:\n\n        sysctl_icap_write(s, value);\n\n        break;\n\n    case R_SYSTEM_ID:\n\n        qemu_system_reset_request();\n\n        break;\n\n\n\n    case R_GPIO_IN:\n\n    case R_CAPABILITIES:\n\n        error_report(\"milkymist_sysctl: write to read-only register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_sysctl: write access to unkown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n}\n", "idx": 25515, "substitutes": {"opaque": ["OPaque", "OPaques", "opsi", "iplay", "ipac", "OPac", " opac", "opque", "opacity", "Opsi", " opaques", "Opaque", "compaque", "compacity", "iopacity", "opac", "compsi", "iopsi", "OPlay", "Opacity", "iopaque", "Opque", "oplay", "compque", "ipaque", " oplay", "iopque", "ipaques", "opaques"], "addr": ["alt", "address", "host", "dh", "lag", "map", "id", "ctr", "index", "mem", "gate", "gz", "var", "arr", "prefix", "ctx", "pos", "rt", "attr", "expr", "src", "mt", "ptr", "pkg", "v", "inter", "tx", "args", "obj", "adr", "rs", "arm", "db", "ace", "state", "add", "msg", "tag", "eth", "data", "handle", "offset", "ix", "hw", "type", "x", "arp", "pad", "wd", "act", "ady", "coord", "phys", "dr", "alloc", "seek", "Address", "mask", "adj", "elt", "grad", "ad", "err", "nm", "ref", "hash", "md", "cmd", "ack", "ord", "usr", "set", "np", "align", "req", "start", "shift", "urg", "ret", "arg", "res"], "value": ["range", "field", "see", "address", "status", "unit", "vp", "done", "create", "buffer", "command", "new", "pair", "raw", "size", "weight", "scale", "save", "page", "vector", "max", "variable", "v", "sample", "parent", "byte", "condition", "code", "distance", "entry", "operator", "height", "Value", "state", "level", "function", "total", "example", "data", "key", "bin", "current", "label", "description", "format", "database", "type", "length", "expression", "peer", "update", "tv", "widget", "now", "get", "comment", "memory", "node", "always", "test", "version", "limit", "time", "package", "number", "ue", "all", "property", "hello", "sum", "no", "attribute", "where", "values", "null", "power", "hash", "fee", "w", "result", "password", "resource", "list", "VALUE", "initial", "we", "root", "set", "message", "sequence", "instance", "python", "port", "maximum", "json", "position", "val", "sv", "unknown", "content", "diff", "index", "name"], "s": ["ops", "sis", "service", "comm", "sam", "comments", "r", "p", "changes", "aws", "bits", "vs", "S", "ns", "sm", "ies", "states", "z", "less", "http", "h", "sq", "series", "sn", "i", "space", "sb", "os", "erences", "rs", "sl", "spec", "n", "state", "cs", "services", "als", "ats", "ts", "ims", "its", "parts", "m", "sys", "ms", "as", "ins", "gets", "ties", "ses", "bis", "sts", "sw", "bs", "is", "b", "ps", "stats", "gs", "ls", "ssl", "se", "fs", "bes", "ds", "hs", "details", "js", "ss", "qs", "es", "sp", "sv", "t", "conf"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "AVFrame *avcodec_alloc_frame(void)\n\n{\n\n    AVFrame *frame = av_mallocz(sizeof(AVFrame));\n\n\n\n    if (frame == NULL)\n\n        return NULL;\n\n\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avcodec_get_frame_defaults(frame);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n\n\n    return frame;\n\n}\n", "idx": 25526, "substitutes": {"frame": ["f", "block", "join", "cf", "ence", "ce", "point", "zone", "null", "queue", "feature", "Frame", "component", "none", "entry", "valid", "flow", "fr", "result", "profile", "word", "request", "event", "error", "object", "row", "empty", "cast", "me", "ace", "close", "state", "new", "shot", "we", "frames", "message", "sequence", "next", "image", "face", "file", "chain", "line", "process", "data", "feat", "info", "window", "base", "version", "draw", "figure", "instance", "trace", "scene", "all", "sample", "role"]}}
{"project": "FFmpeg", "commit_id": "ed1a6878564a97e67e5fe3a25bc099208cfed024", "target": 1, "func": "static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){\n\n    int i;\n\n\n\n    for(i=0; i<w-1; i++){\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n        i++;\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n    }\n\n\n\n    for(; i<w; i++){\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n    }\n\n\n\n    return acc;\n\n}\n", "idx": 25530, "substitutes": {"dst": ["pdst", "dspr", "bdsts", "ddsc", " dST", "delST", "idst", "pdpr", "dsc", "ddst", "dsist", "dsbl", "Dsc", "Dst", " dist", "Dsts", "bdST", " dpr", "Dpr", "delst", "dbl", "dest", "ddpr", "dist", "bdput", " dsts", "dpr", "dST", "idpr", "idest", "dsst", "bdpr", " dbl", "Dest", " dput", "pdest", " dest", "dput", "bdist", "delsts", "bdst", "delput", "dsts", "ddest", "idsc", "pdsts", "bdbl"], "src": ["sys", "sn", "cur", "sb", "inc", "ins", "rl", "syn", "iv", "bc", "rs", "usc", "ur", "sub", "rc", "ctr", "sl", "seq", "in", "inst", "sr", "supp", "sc", "s", "img", "ser", "sh", "dest", "input", "sec", "bs", "th", "raw", "comp", "ind", "attr", "loc", "txt", "st", "fc", "via", "hl", "source", "ptr", "tmp", "cc", "conv", "str", "sq"], "mask": ["type", "mac", "batch", "cmp", "pack", "perm", "match", " flag", "hold", "gain", "ma", "black", "bit", "map", "c", "result", "margin", "miss", "flags", " masked", "lay", "comment", "cache", "fix", "sc", "arr", "filter", "cm", "set", "mod", "level", "magic", "clear", "tag", "sk", "shift", "weight", "scale", "fac", "delay", "key", "window", "flag", "label", "ask", "sum", "m", "lock", "Mask", "sign", "conf"], "w": ["batch", "W", "x", "fw", "iw", "wh", "v", "d", "wm", "ew", "wait", "wo", "wk", "wr", "wl", "n", "we", "sw", "nw", "wa", "wcs", "start", "weight", "weights", "y", "wb", "wp", "wt", "window", "wi", "rw", "win", "kw", "wal", "h", "max", "end", "m", "wx", "aw"], "acc": ["f", "CC", "batch", "cmp", "perm", "out", "gam", "inc", "ca", "err", "aff", "gain", "score", "conn", "eff", "fee", "bc", "AC", "att", "ent", " cc", "c", "account", "rc", "tc", "result", "cont", "rev", "dev", " accuracy", "func", "comment", "Acc", "good", "ga", " ACC", "cache", "alias", "cum", "sc", "arr", " tc", "rec", "acl", " accum", " ac", "enc", "ACC", " gain", "attr", "ac", "unc", "ag", "fac", "auc", "cas", "con", "gn", "aaa", "uu", "adj", "gc", "u", "tr", "xff", " carry", "cc", "sum", " nu", "aq", "conf"], "i": ["ui", " j", "o", "status", "ini", "id", "I", "p", " bi", "sim", "ai", "li", "info", "ip", "ij", "y", "ci", "iu", " I", "si", "v", "ei", "ji", "ki", "\u0438", "ik", " ii", "io", "j", "asi", "chain", "ind", "ims", "em", "uri", "m", "point", "qi", "ix", "iii", "ms", "batch", "x", "multi", "ri", "iy", "phi", "di", "oi", "uli", "zi", "mi", "ii", "print", "is", " ti", "bi", " m", "xi", "im", "it", "ic", "slice", "pi", "me", "gi", "list", "record", "hi", "ti", "index", "cli", "init"]}}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    PXA2xxPICState *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (PXA2xxPICState *)\n\n            qemu_mallocz(sizeof(PXA2xxPICState));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(base, 0x00100000, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(NULL, \"pxa2xx_pic\", 0, 0, pxa2xx_pic_save,\n\n                    pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n", "idx": 25549, "substitutes": {"base": ["sys", "na", "bas", "server", "site", "null", "ASE", "address", " Base", "network", "bound", "Base", "ex", "binding", "id", "c", "bf", "cpu", "create", "buffer", "db", " bases", "use", "bind", "extra", "bal", "set", "origin", "bar", "kb", "bs", "kit", " b", "bu", "file", "b", " BASE", "eta", "data", "ip", "ba", "ase", "bp", "based", "end", "v", "name"], "env": ["context", "hw", "sb", "eu", "server", "obj", "home", "ev", "network", "conn", "code", "viron", "vp", "qt", "er", "dev", "ew", "ec", "act", "ah", "kh", "sc", "org", "gov", "set", "vr", "et", "ctx", "vs", "enc", "environment", "pe", "np", "nv", "txt", "window", "e", "EN", "net", "en", "scope", "ptr", "h", "jp", "vt", "end", "v", "cv", "conf"], "s": ["f", "i", "space", "sa", "sb", "ops", "o", "args", "store", "ins", "se", "os", "comm", "fs", "rs", "c", "storage", "sam", "ex", "ses", "er", "ds", "hs", "sl", "details", "g", "r", "spec", "p", "cs", "sts", "sh", "set", "aws", "vs", "S", "js", "bs", "ss", "settings", "a", "is", "ats", "l", "ns", "ts", "ps", "b", "ims", "y", "qs", "stats", "es", "sp", "gs", "sv", "less", "properties", "h", "q", "ls", "m", "v", "sq", "socket", "conf"], "iomemtype": ["omanomtype", "iomymtypes", "omanemtype", "iomymtype", "iomimtypes", "iomEMt", "xiemty", "xiemvalue", "iomimerType", "iomympe", "iomimType", "iemimpe", "iomemtypes", "iomhimvalue", "iomhimType", "iomimertype", "iomEMtype", "iemimtype", "iomemvalue", "iomemeType", "iomimtype", "iomemetype", "iomemty", "iometyvalue", "iememType", "iemimtypes", "omanemt", "iomhimtype", "iememtypes", "iomimerpe", "iomomt", "iomimvalue", "iomymType", "iememtype", "iomempe", "iemempe", "iometyType", "xiimtype", "xiemtype", "iomomtype", "iomEMype", "omanemype", "iomemype", "iomhimty", "iomomype", "iomemeype", "iomomType", "omanomype", "iomemt", "iomemet", "omanemType", "iomemType", "omanomt", "iemimType", "iomEMType", "iomimty", "xiemType", "xiimType", "iomimertypes", "omanomType", "xiimty", "iometytype", "xiimvalue", "iometyty", "iomimpe"], "qi": ["i", " cu", "ike", "ku", "ui", "ki", "cu", "dq", "Si", " IQ", " sq", "gui", "qt", " i", " ni", "eni", "squ", " ki", "ia", " Ni", "\u043e", "fi", "qu", "ique", "ifa", " MI", "quer", "Ni", "qq", "afi", "iza", "ii", "iq", "qa", "li", "esque", "eas", " cis", " fi", " ti", " pi", "query", " mi", "qs", " q", "cgi", " si", "qv", "ni", "si", "q", "IQ", "sq", "oka", "aq", "ei"]}}
{"project": "qemu", "commit_id": "4a917c39aed9ad7f648c435204a6586c4ca3f2f2", "target": 0, "func": "int net_init_vde(QemuOpts *opts, const NetClientOptions *new_opts,\n\n                 const char *name, VLANState *vlan)\n\n{\n\n    const char *sock;\n\n    const char *group;\n\n    int port, mode;\n\n\n\n    sock  = qemu_opt_get(opts, \"sock\");\n\n    group = qemu_opt_get(opts, \"group\");\n\n\n\n    port = qemu_opt_get_number(opts, \"port\", 0);\n\n    mode = qemu_opt_get_number(opts, \"mode\", 0700);\n\n\n\n    if (net_vde_init(vlan, \"vde\", name, sock, port, group, mode) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25550, "substitutes": {"opts": ["opt", "popats", "iopts", "syntx", "popte", "optuts", "props", "oputs", " opter", "optx", "optrs", "options", " optgs", "opter", " oputs", "opttions", "opds", "optjs", "iopt", " optjs", "opte", "opTS", "opws", " opds", "opsrs", "optte", "oprs", "iopps", " opjs", "prows", "opsgs", " opttions", "opsts", " opTS", "synuts", "opstions", " opns", "opns", "opgs", "synts", "iopws", "optns", " opws", "optTS", "synns", " optrs", " optx", "prot", "opttx", "opats", " optds", "optats", " optts", "opjs", "optds", " opps", "prots", "popTS", "optter", "opps", " opt", "popts", " opats", " optter", "optgs", "optts", " opte"], "new_opts": ["new_opTS", "newccsyns", "new_synTS", "new_prors", "new_OPs", "newccsynTS", "new_OPTS", "newccsynts", "new_syns", "new_proTS", "newccopts", "new_prots", "newccops", "new_OPts", "newccoprs", "new_ops", "new_oprs", "new_pros", "new_synrs", "newccopTS", "new_OPrs", "new_synts", "newccsynrs"], "name": ["type", "parent", "ident", "other", "code", "named", "nam", "normal", "part", "id", "word", "title", "common", "local", "path", "family", "n", "alias", " Name", "prefix", "new", "root", "order", "raw", "file", "data", "ns", "NAME", "key", "base", "ame", "net", "Name", "package", "ni", "format", "v", "names"], "vlan": ["vrale", "VLAN", "vale", "wireale", "svlad", " vnet", "svLAN", "vrni", "Vlan", "pLAN", "vnet", "svnet", "wireni", "Vni", "vLAN", "Vale", "pnet", "wirelan", "vni", " vlad", "svlan", "plan", " vLAN", "vrLAN", "vlad", "plad", "wireLAN", "vrlan"], "sock": ["voot", " sip", "sck", "tock", "slck", "slip", "soot", "vock", "snoot", "socks", " socket", "sncp", "wsrc", " socks", "snock", "tocket", "wsocks", "wsock", " src", " sockets", "vcp", "tip", "trc", "snockets", "scp", "sip", " sck", " scp", "slock", "src", "wsocket", " soot", "slocks", "vockets", "tocks", "sockets", "tck", "socket"], "group": ["block", "parent", "field", "dir", "host", "part", "roup", "id", "member", "owner", "g", "pool", "p", "band", "pg", "gr", "org", "mod", "module", "folder", "order", "tag", "chain", "file", "way", "back", "size", "key", "groups", "handle", "user", "GROUP", "coll", "mask", "by", "driver", "global", "scope", "pkg", "Group", "q", "manager", "v"], "port": ["pport", "it", "length", "ports", "ort", "pose", "queue", "len", "phone", "eport", "pc", "component", "Port", "index", "pr", "path", "n", "p", "pid", " sport", "PORT", "pe", "pos", "project", "print", "ORT", "file", "priority", "line", "size", "mobile", "page", "public", "iot", "version", "export", "limit", "position", "pro", "number", "import", "trace", "room", "m", "point", "pt"], "mode": ["range", "option", "type", "length", "perm", "direction", "MODE", "where", "rol", "pose", "power", "code", "status", "id", "operator", "mem", "mm", "command", "md", "me", "rate", "oe", "state", "mod", "module", "level", "order", "tag", "menu", "ode", "size", "scale", "version", "pro", "Mode", "mask", "time", "mt", "kind", "mate", "model", "m", "role"]}}
{"project": "FFmpeg", "commit_id": "f57b00e89749b559da7cd99a4b630c90617e17d4", "target": 1, "func": "static const ID3v2EMFunc *get_extra_meta_func(const char *tag, int isv34)\n\n{\n\n    int i = 0;\n\n    while (ff_id3v2_extra_meta_funcs[i].tag3) {\n\n        if (!memcmp(tag,\n\n                    (isv34 ?\n\n                        ff_id3v2_extra_meta_funcs[i].tag4 :\n\n                        ff_id3v2_extra_meta_funcs[i].tag3),\n\n                    (isv34 ? 4 : 3)))\n\n            return &ff_id3v2_extra_meta_funcs[i];\n\n        i++;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 25557, "substitutes": {"tag": ["type", "attribute", "pack", "product", "field", "pet", "bad", "trans", "byte", "ref", "code", "term", "Tag", "bit", "map", "word", "tags", "reg", "local", "var", "cat", "TAG", "mat", "prefix", "buf", "bug", "old", "data", "attr", "ag", "feat", "key", "text", "t", "arg", "str", "name"], "isv34": ["IsV34", " isV34", "isconv39", "isqv27", "isalrev34", "Isv346", "isV34", "isrev357", "isV35", "isqv34", "isvt35", "isv39", " isv37", "isV357", "isalrev357", "isconv35", "IsV346", "Isv27", "ish34", "ish37", "isV37", "isrev37", "isvol346", " isV35", "isalv357", "isvt34", "IsV37", "isvt39", "isV346", "ish357", "isqv346", "isalv37", "isvol37", "IsV27", "Isv34", "isv37", " isV37", "isV39", "isV349", "isv27", " isv35", "isconv34", "isrev34", "ish349", "isalrev349", "isalv34", "isalrev37", "isvt37", "Isv37", "isalv349", "isvol34", "isconv37", "isv35", " isv39", "isV27", "isv346", " isV39", "isqv37", "isvol27", "isrev349", "isv357", "isv349"], "i": ["iat", "ic", "it", "x", "batch", "ui", "client", " j", "multi", "\u0438", "err", "status", "try", "v", "pi", "ini", " ni", " ii", "id", "at", "iy", "fi", "gi", "I", " iii", "list", "phi", " bi", "oi", "di", "ori", "to", "sim", "j", "ai", "mi", "li", "ii", "iq", "hi", "ti", "ind", "info", " ti", "ij", "ip", "bi", "y", "ish", "ci", "z", "uri", "iu", "xi", "si", "im", "stat", "index", "conv", "cli", "init", "qi", "ei", "ix"]}}
{"project": "FFmpeg", "commit_id": "ac87c273a646eb8feba8e47f15da4934d119f650", "target": 1, "func": "int av_buffersrc_add_ref(AVFilterContext *buffer_filter,\n\n                         AVFilterBufferRef *picref, int flags)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    AVFilterBufferRef *buf;\n\n    int ret;\n\n\n\n    if (!picref) {\n\n        c->eof = 1;\n\n        return 0;\n\n    } else if (c->eof)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!av_fifo_space(c->fifo) &&\n\n        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +\n\n                                         sizeof(buf))) < 0)\n\n        return ret;\n\n\n\n    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {\n\n        ret = check_format_change(buffer_filter, picref);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n    if (flags & AV_BUFFERSRC_FLAG_NO_COPY)\n\n        buf = picref;\n\n    else\n\n        buf = copy_buffer_ref(buffer_filter, picref);\n\n\n\n\n\n    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {\n\n        if (buf != picref)\n\n            avfilter_unref_buffer(buf);\n\n        return ret;\n\n    }\n\n    c->nb_failed_requests = 0;\n\n\n\n    return 0;\n\n}", "idx": 25566, "substitutes": {"buffer_filter": ["buffermatmaster", " buffer_control", "buffer_spec", "buffertref", "buffer1filter", "bufferwcache", "filter_profile", "Buffer_source", " buffer1control", "buffer_ref", "bufferthandler", "filter_filter", "buffer_source", "buffer_context", "buffererprofile", "buffer_cache", "buffer_service", "buffer1cache", "callbackmatmaster", "Buffer_stream", "buffermatprofile", "Buffer_spec", "bufferermaster", "buffer_control", "buffer_handler", "buffer1context", "buffermatservice", "buffererfilter", "bufferwcontrol", "buffer_profile", "buffererservice", " buffer1context", "callback_master", "filter_handler", "Buffer_filter", "buffertfilter", " buffer_cache", "filter_ref", "callbackmatfilter", "callback_service", "callback_profile", "buffer_stream", " buffer_context", "bufferwfilter", "buffermatfilter", " buffer1cache", "buffertprofile", "buffer_master", " buffer1filter", "callbackmatprofile", "bufferwcontext", "callbackmatservice", "callback_filter", "buffer1control"], "picref": ["ericmb", "pictdef", "picbr", "ericarg", "picarg", "pindef", "picRef", "icref", " picreference", "pictRef", "ericdef", "nicdef", "picmb", "nicmb", "pinREF", " picdef", "pinref", "pictref", "pinbr", "pinreq", " picREF", "pcreference", "pictureRef", "icbr", "nicarg", "nicRef", "picturereference", " picbr", "nicadd", "icreq", "pcbr", "picREF", "pictureref", "pictarg", "nicreq", "picadd", "pcRef", "picdef", " picRef", "picreference", "pinRef", "pictREF", " picarg", "pictmb", "nicreference", "nicref", "nicbr", "pictureadd", "icdef", "picreq", " picadd", "pinarg", "pcref", "ericref", "pinreference"], "flags": ["ms", "ports", "limits", " Flags", "bugs", "args", "uses", "options", "fields", "ants", "lag", "members", "tags", "amps", "comments", "details", "Flags", "links", "caps", "acts", "cond", "ents", "ags", "bits", "faces", "words", "settings", "types", "ts", "ps", "weights", "ensions", "locks", "terms", "facts", "gs", "mask", "FLAG", "flag", "kind", "posts", "features", "actions", "properties", "atts", "parts", "events", "xxx", "names"], "c": ["f", "cl", "ic", "ch", "cur", "cmp", "cf", "cam", "ce", "cu", "ca", "conn", "col", "comm", "bc", "pc", "config", "rc", "tc", "cd", "cont", "dc", "ec", "ctrl", "g", "cp", "p", "cache", "nc", "cs", "cb", "cm", "can", "ctx", "enc", "com", "co", "a", "comp", "b", "ct", "xc", "ac", "l", "ci", "mc", "con", "fc", "coll", "u", "etc", "gc", "t", "cc", "C", "v", "lc", "m", "cv", "conf"], "buf": ["obj", "block", "fb", "prop", "batch", "pb", "tx", "cam", "err", "nm", "conv", "ref", "queue", "uf", "br", "bl", "box", "len", "bc", "foo", "nah", "ctr", "result", "buffer", "mem", "seq", "cmd", "pool", "Buff", "arr", "img", "msg", "cb", "bytes", "bar", "vec", "np", "next", "raw", "doc", "bn", "orig", "b", "data", "wb", "txt", "window", "alloc", "bin", "bt", "iter", "rb", "rw", "cap", "Buffer", "kw", "buff", "pkg", "tr", "tmp", "ptr", "uv", "off", "v", "str", "bp", "cv"], "ret": ["alt", "ter", "ll", "status", "att", "cont", "del", "arr", "rem", "rt", " RET", " Ret", "mt", "Ret", "rm", "re", "br", "try", "gt", "value", "after", "rev", "at", "det", "state", "j", "desc", "fun", "iter", "net", "final", "sys", "reset", "RET", "def", "ry", "pret", "print", "back", "dr", "tr", "elt", "vet", "str", "it", "lit", "out", "err", "pas", "hash", "len", "ber", "result", "reg", "ext", "cmd", "deg", "cert", "resp", "usr", "nt", "rets", "txt", "pro", "ft", "val", "flag", "t", "arg", "res"]}}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qstring_destroy_obj(QObject *obj)\n\n{\n\n    QString *qs;\n\n\n\n    assert(obj != NULL);\n\n    qs = qobject_to_qstring(obj);\n\n    g_free(qs->string);\n\n    g_free(qs);\n\n}\n", "idx": 25571, "substitutes": {"obj": ["opt", "o", "xy", "ok", "err", "opp", "po", "os", "utt", "piece", "none", "oss", "obo", "bo", "object", "og", "ck", "act", "now", "inst", "cmd", "org", "Object", "resp", "ob", "mo", "rect", "go", "od", "et", "Obj", "aco", "ctx", "js", "bs", "any", "nt", "obb", "bj", "addr", "oj", "bh", "imp", "obs", "iso", "pkg", "oy", "tmp", "ot", "onet", "pt", "hw"], "qs": ["ms", "irs", "ues", "dq", "eps", "ins", "csv", "gets", "fs", "ems", "ds", "hs", "ks", "ques", "igs", "qu", "uds", "s", "GS", "qq", "cs", "sts", "cks", "aws", "fits", "als", "ours", "bs", "qa", "outs", "ics", "js", "xs", "ats", "ts", "ns", "ims", "acs", "aus", "rets", "vals", "eks", "fts", "ads", "gs", "its", "obs", "ys", "q", "ls", "sq", "icks", "ips"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool aio_pending(AioContext *ctx)\n\n{\n\n    AioHandler *node;\n\n    bool result = false;\n\n\n\n    /*\n\n     * We have to walk very carefully in case aio_set_fd_handler is\n\n     * called while we're walking.\n\n     */\n\n    qemu_lockcnt_inc(&ctx->list_lock);\n\n    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.revents && node->io_notify) {\n\n            result = true;\n\n            break;\n\n        }\n\n\n\n        if ((node->pfd.revents & G_IO_IN) && node->io_read) {\n\n            result = true;\n\n            break;\n\n        }\n\n        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {\n\n            result = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    qemu_lockcnt_dec(&ctx->list_lock);\n\n    return result;\n\n}\n", "idx": 25574, "substitutes": {"ctx": ["sys", "cl", "hw", "context", "cmp", "tx", "cf", "cam", "jac", "Context", "conn", "bc", "c", "tc", "kt", "crit", "ck", "mk", "ctrl", "func", "cmd", "ctl", "cp", "resp", "cb", "cm", "setup", "cfg", "xs", "req", "ct", "xc", "nt", "anc", "parents", "loc", "txt", "alloc", "window", "kw", "mt", "etc", "scope", "pkg", "timeout", "tmp", "cc", "jp", "wx", "cv", "conf"], "node": ["handler", "field", "hop", "station", "host", "cell", "c", "pp", "or", "Node", "p", "new", "proc", "info", "link", "max", "note", "parent", "obj", "edge", "func", "good", "db", "n", "remote", "msg", "function", "data", "desc", "key", "window", "via", "m", "tree", "device", "context", "type", "peer", "nn", "normal", "cd", "k", "fn", "view", "addr", "worker", "adj", "tmp", "this", "parse", "f", "server", "ref", "se", "component", "event", "master", "local", "row", "resource", "cmd", "list", "cache", "holder", "root", "slave", "nw", "module", "np", "instance", "image", "nt", "post", "num", "e", "check", "t", "index", "name"]}}
{"project": "qemu", "commit_id": "e1f7b4812eab992de46c98b3726745afb042a7f0", "target": 0, "func": "static size_t get_request_size(VirtQueue *vq)\n\n{\n\n    unsigned int in, out;\n\n\n\n    virtqueue_get_avail_bytes(vq, &in, &out);\n\n    return in;\n\n}\n", "idx": 25578, "substitutes": {"vq": [" vqueue", "svqueue", "vqs", "fqs", "verq", "svqq", " vqs", "verdq", "svquant", "svqs", "vquant", "vqueue", " vquant", "verquant", " vdq", "vqq", "svq", "svg", "svdq", "vg", "fg", "vdq", "verqq", "fq", "fqueue", " vg", " vqq"], "in": ["isin", "i", "x", "inf", " input", "min", "ins", "len", " din", "pc", "from", "d", "bit", " i", "ex", "c", "id", "k", "gin", "g", "r", "n", "p", "s", "input", "mi", "doc", "inner", "req", "ind", "rin", "l", "In", "size", " inf", "inn", "din", "window", "en", "IN", "h", "t", "q", " IN", "m", "v", "sum"], "out": ["ch", "i", "x", "client", "gen", "o", "inc", "ins", "bit", "ent", "w", "c", "result", "output", "g", "list", "n", "io", "s", "bytes", "set", "j", "outs", "Out", "ne", "co", "print", "b", "l", "size", "nt", "ou", "window", "val", "net", "OUT", "by", "t", "m", "v"]}}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_quit(int argc, const char **argv)\n\n{\n\n    exit(0);\n\n}\n", "idx": 25580, "substitutes": {"argc": [" argC", "ArgC", "Argcs", "argC", "Argc", " argcs", "argcs", "argsc", "argscs", "argsC"], "argv": [" argvs", "argm", "Argm", " argm", "argsvs", "Argvs", "Argc", "argvs", "argsc", "Argv", "argsv", "argsm"]}}
{"project": "qemu", "commit_id": "63ffb564dca94f8bda01ed6d209784104630a4d2", "target": 0, "func": "static void pc_init1(ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename,\n\n                     const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     const char *cpu_model,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *isa_irq;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cmos_s3;\n\n    qemu_irq *smi_irq;\n\n    IsaIrqState *isa_irq_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    FDCtrl *floppy_controller;\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n\n\n    pc_cpus_init(cpu_model);\n\n\n\n    if (kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    pc_memory_init(ram_size, kernel_filename, kernel_cmdline, initrd_filename,\n\n                   &below_4g_mem_size, &above_4g_mem_size);\n\n\n\n    cpu_irq = pc_allocate_cpu_irq();\n\n    i8259 = i8259_init(cpu_irq[0]);\n\n    isa_irq_state = qemu_mallocz(sizeof(*isa_irq_state));\n\n    isa_irq_state->i8259 = i8259;\n\n    if (pci_enabled) {\n\n        ioapic_init(isa_irq_state);\n\n    }\n\n    isa_irq = qemu_allocate_irqs(isa_irq_handler, isa_irq_state, 24);\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, isa_irq, ram_size);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus_new(NULL);\n\n    }\n\n    isa_bus_irqs(isa_irq);\n\n\n\n    pc_register_ferr_irq(isa_reserve_irq(13));\n\n\n\n    pc_vga_init(pci_enabled? pci_bus: NULL);\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_irq, &floppy_controller, &rtc_state);\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!pci_enabled || (nd->model && strcmp(nd->model, \"ne2k_isa\") == 0))\n\n            pc_init_ne2k_isa(nd);\n\n        else\n\n            pci_nic_init_nofail(nd, \"e1000\", NULL);\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            dev = isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            idebus[i] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        }\n\n    }\n\n\n\n    audio_init(isa_irq, pci_enabled ? pci_bus : NULL);\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device,\n\n                 idebus[0], idebus[1], floppy_controller, rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n        i2c_bus *smbus;\n\n\n\n        cmos_s3 = qemu_allocate_irqs(pc_cmos_set_s3_resume, rtc_state, 1);\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              isa_reserve_irq(9), *cmos_s3, *smi_irq,\n\n                              kvm_enabled());\n\n        for (i = 0; i < 8; i++) {\n\n            DeviceState *eeprom;\n\n            eeprom = qdev_create((BusState *)smbus, \"smbus-eeprom\");\n\n            qdev_prop_set_uint8(eeprom, \"address\", 0x50 + i);\n\n            qdev_prop_set_ptr(eeprom, \"data\", eeprom_buf + (i * 256));\n\n            qdev_init_nofail(eeprom);\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n", "idx": 25583, "substitutes": {"ram_size": ["ram2Size", "ram2name", "RAM_size", "ram2space", "ram_space", "rametSIZE", " ram_space", "RAM_name", "rametmode", "RAM_SIZE", "ram2size", "ram_Size", "ram2SIZE", " ram_mode", "rametaddr", " ram_addr", "RAM_Size", "rametsize", " ram_SIZE", "ram_name", "ram_SIZE", "ram_addr", "RAM2name", " ram_name", "ram_mode", "RAM2Size", "RAM2SIZE", "RAM2size"], "boot_device": ["cpu_device", "boot_buffer", "cpu_node", "bootlydevice", "boot_node", "bootlydev", "bootlybuffer", "boot_dev", "cpu_dev", "cpu_buffer", "bootlynode"], "kernel_filename": [" kernel_network", "kernelablebinary", "kernel___filename", " kernelablefile", "kernelablefile", "kernelletpath", "kernel_binary", " kernel_path", "kernelablemodule", "kernelletfilename", " kernelablebinary", "kernelletnetwork", "kernel___file", " kernelablefilename", "kernel_path", "kernelletfile", "kernel___binary", " kernelablemodule", "kernel_network", " kernel_module", "kernel_module", " kernel_file", "kernelablefilename", "kernel_file", " kernel_binary", "kernel___module"], "kernel_cmdline": ["kernel_advline", "kernel_mdline", "kernel_mdlines", "kernel_commandline", "kernel_advcall", "kernel_cryptcode", "kernel_cryptcall", "kernel_callline", "kernel_callLine", "kernel_mdLine", "kernel_cmdcall", "kernel_commandlines", "kernel_cmdLine", "kernel_calllines", "kernel_cmdlines", "kernel_commandcode", "kernel_cmdcode", "kernel_commandLine", "kernel_cryptline", "kernel_commandcall", "kernel_advcode"], "initrd_filename": ["initdr_location", "initdretyfile", "initrdetyfile", "initrb_file", "initrdetylocation", "initrb_Filename", "initrd_Filename", "initdr_filename", "initrd_fn", "initdretylocation", "initrd_file", "initrdetydll", "initrd_dll", "initdr_dll", "initdr_file", "initrdetyfilename", "initrd_location", "initdretydll", "initrb_filename", "initdretyfilename", "initrb_fn"], "cpu_model": ["cpu_device", "cpu1models", "clock_controller", "cpupomodel", "clock_models", "cpu2models", "clock_network", "cpupocontroller", "cpu1model", "clock_model", "cpu2device", "cp_model", "cpu_link", "cpu2link", "cpu_network", "cpuponetwork", "cp_device", "cp_link", "cpu_controller", "cpu_models", "cpu1network", "cpu2model", "cpupomodels", "cp_models", "cpu1controller"], "pci_enabled": ["pcci_Enabled", "pcgi_enabled", "pci_Enabled", "pci2Enabled", "pcci_enabled", "pico_Enabled", "pci2enabled", "pci_checked", "pico_enable", "pico_activated", "pci_status", "pico_enabled", "pci_activated", "pci2enable", "pcgi_checked", "pcci_enable", "pcgi_status", "pcgi_enable", "pci_enable"], "kvmclock_enabled": ["kvmlock_Enabled", "kvmsync_created", "kvmclock2created", "kvmsync_Enabled", "kvmclock_Enabled", "kvmclock2enabled", "kvmclock_enable", "kvmclock_required", "kvmlock_enabled", "kvmclock_created", "kvmlock_created", "kvmclock2Enabled", "kvmlock_required", "kvmsync_enable", "kvmclock2enable", "kvmsync_enabled"], "i": ["f", " j", "o", "pi", "c", " ii", "ia", "fi", "I", "p", "phi", " bi", "di", "j", " v", "ii", "a", "l", "bi", "ip", " pi", "ci", "e", " I", "si", "t", "m", "v"], "below_4g_mem_size": ["below_4g_mem2name", "below_4g_mem2Size", "below_4g_mem_name", "below_4g_Mem_name", "below_4g_Mem_size", "below_4g_mem_SIZE", "below_4g_Mem_Size", "below_4g_mem_Size", "below_4g_mem2size"], "above_4g_mem_size": ["above_4g_mem_Size", "above_4g_mem_sum", "above_4g_mem2Size", "above_4g_mem2size", "above_4g_mem2sum"], "pci_bus": ["pci__boot", "pki_box", "pki_BUS", "pci__BUS", "pki__bus", "pci_board", "pci__bus", "pci___bus", "pci_BUS", "pki__home", "pci__box", "pki_state", "pki_home", "pci_box", "pki_board", "pki_bus", "pci__home", "pki__box", "pci___box", "pci___board", "pki__BUS", "pki__boot", "pci_boot", "pci__state", "pki_boot", "pci__board", "pki__board", "pci_state", "pci_home", "pci___home"], "i440fx_state": ["i440px_status", "i440fx___status", "i440fx_store", "i440ty_store", "i440fx2status", "i440fx_new", "i440fx___store", "i440fx___new", "i440fx_status", "i440fx_cache", "i440fx2store", "i440ty_new", "i440ty_state", "i440px_state", "i440fx2cache", "i440fx2state", "i440px_cache", "i440fx___state", "i440px_store", "i440ty_status"], "cpu_irq": ["cpu_erql", "cpu_ireqs", "cpu_erq", "cpu__irqs", "cpu_erqq", "cpu_virq", "cpu_ireq", "cpu_irqq", "cpu_pirqs", "cpu_irtqs", "cpu_pirity", "cpu_mirql", "cpu_erqs", "cpu__irp", "cpu_virQ", "cpu_irity", "cpu_irtity", "cpu_irqs", "cpu_ireQ", "cpu_irql", "cpu_mirqq", "cpu_mirq", "cpu_irp", "cpu__pirp", "cpu_pirQ", "cpu_irQ", "cpu_irtq", "cpu_mirity", "cpu_virp", "cpu_irep", "cpu__pirQ", "cpu_virqs", "cpu__irQ", "cpu__pirq", "cpu_pirp", "cpu_rinql", "cpu_pirq", "cpu_rinq", "cpu__irq", "cpu__pirqs", "cpu_mirqs", "cpu_rinqq", "cpu_rinqs"], "isa_irq": ["isa_drqq", "isa_drque", "isa_pirch", "isa_irch", "isa_irqs", "isa_pirque", "isa_irQ", "isa_mirq", "isa_mirque", "isa_pirqs", "isa_drqs", "isa_irmqs", "isa_virq", "isa_pird", "isa_drq", "isa_virQ", "isa_mirqq", "isa_ich", "isa_mirqs", "isa_virqs", "isa_irmQ", "isa_iterq", "isa_ird", "isa_irmd", "isa_mirch", "isa_irmq", "isa_vird", "isa_iterqq", "isa_pirq", "isa_iqs", "isa_iterque", "isa_irqq", "isa_irque", "isa_iq", "isa_iterqs", "isa_pirQ", "isa_ique"], "i8259": ["mi83260", "pi81024", "i9258", "i8254", "pi4259", " i8285", "mi83249", "i810249", "i4285", "pi8259", " i8265", " i4285", " i4260", "i805259", "i815258", "pi8249", "i9260", "mi83269", "i805258", "i8258", "i4269", "i4265", "i8151024", "i83249", "i8269", "mi8249", " i8260", "i810285", "pi4249", " i4259", "i12285", "i81024", "i810260", "i815249", "pi4258", "i8101024", "i8260", "mi8259", "i810265", "i12260", "i4260", "i805254", "i83269", "i83260", "i4258", "i4249", "i9259", "i815259", "i9254", "i4254", "i810258", "pi8258", "i12265", "i9249", "mi8269", "mi83259", "i8249", " i4265", "mi8260", "i8285", "i9269", "i12259", "i810259", "pi4254", "i4259", "i83259", "pi8254", "i8265", "i805249"], "cmos_s3": ["cmos2sin3", "cmos_tnd", "cmos_tip", "cmos2s2", "cmos_s2", "cmos2sinip", "cmos_rnd", "cmos2sinnd", "cmos2s3", "cmos_sin3", "cmos_r2", "cmos_sip", "cmos_sin2", "cmos_sinnd", "cmos_snd", "cmos_rip", "cmos2sin2", "cmos2sip", "cmos_t2", "cmos2snd", "cmos_r3", "cmos_t3", "cmos_sinip"], "smi_irq": ["smi_irQ", "smi_mirq", "smi_pirq", "smi_pirch", "smi__mirq", "smi_arqs", "smi_irqs", "smi_irch", "smi__irQ", "smi__irqs", "smi__mirch", "smi_arq", "smi_pirQ", "smi_arQ", "smi_pirqs", "smi_mirch", "smi_arch", "smi__irq", "smi__mirqs", "smi__mirQ", "smi_mirQ", "smi_mirqs", "smi__irch"], "isa_irq_state": ["isa_iru_state", "isa_irqq_stat", "isa_irq_init", "isa_irq_handler", "isa_iru_info", "isa_irq_cache", "isa_irz_cache", "isa_iru_out", "isa_irr_state", "isa_irr_handle", "isa_irq___handle", "isa_irqq_start", "isa_irq_stat", "isa_irq2state", "isa_irz_stat", "isa_irr2stat", "isa_irr_start", "isa_irz_new", "isa_irr_stat", "isa_irr2state", "isa_irq_handle", "isa_irq___start", "isa_irq___stat", "isa_irqq_handler", "isa_iru_init", "isa_irq____new", "isa_irqq_state", "isa_irr2handle", "isa_irz_State", "isa_irqq_area", "isa_irq_new", "isa_irq_out", "isa_irq2start", "isa_irq2stat", "isa_irq___state", "isa_irq_info", "isa_irqq_info", "isa_irz_state", "isa_irq____state", "isa_irq_State", "isa_irr2start", "isa_irz_info", "isa_irq_area", "isa_irq_start", "isa_irq____cache", "isa_irq2handle"], "hd": ["ld", "dylib", "hid", "ded", "him", "vd", "dh", "cd", "rh", "ds", "hs", "hard", "dri", "hp", "ah", "HD", "hz", "dm", "uda", "ht", "dr", "dd", "bd", "dn", "ha", "du", "h", "izon", "hw"], "MAX_IDE_BUS": ["MAX_IDES_PATH", "MAX_IDE_US", "MAX_IDELEPATH", "MAX_IDEONUS", "MAX_IDE_PATH", "MAX_IDES_USB", "MAX_IDELEBUS", "MAX_IDES_BUS", "MAX_IDES_OUT", "MAX_IDELEBS", "MAX_IDEONBUS", "MAX_IDE_OUT", "MAX_IDELEOUT", "MAX_IDES_BS", "MAX_IDE_BS", "MAX_IDEONUSB", "MAX_IDE_USB", "MAX_IDES_US"], "MAX_IDE_DEVS": ["MAX_IDE_PDVICE", "MAX_IDE_DISVICE", "MAX_IDE_DRVICE", "MAX_IDE_DRKS", "MAX_IDE_DEPS", "MAX_IDE_PDKS", "MAX_IDE_DISKS", "MAX_IDE_DISVS", "MAX_IDE_DEVICE", "MAX_IDE_DEKS", "MAX_IDE_DRPS", "MAX_IDE_PDVS", "MAX_IDE_DRVS", "MAX_IDE_DISPS", "MAX_IDE_PDPS"], "floppy_controller": ["floppy_ctrl", "floppyityctrl", "flppy_driver", "flppy_controller", "floppyitydriver", "flppy_model", "floppyitymodel", "flppy_ctrl", "floppyitycontroller", "floppy_model", "floppy_driver"], "idebus": ["coreBUS", "corebus", "rideBus", "ridebus", "IDEBus", "coreBus", "ridestate", "corestate", "IDEbus", "rideBUS", "ideBUS", "IDEBUS", "idestate", "ideBus", "IDEstate"], "rtc_state": ["rtf_port", "rtc_data", "rtc__info", "rtf_info", "rtf_state", "rtc__state", "rtf_data", "rtc_info", "rtc__data", "rtc__port", "rtc_port"]}}
{"project": "FFmpeg", "commit_id": "8be23d424feea50d4ee892cdbdd6abd9a807709f", "target": 0, "func": "static av_cold int roq_decode_init(AVCodecContext *avctx)\n\n{\n\n    RoqContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n\n\n    if (avctx->width % 16 || avctx->height % 16) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Dimensions must be a multiple of 16\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    s->width = avctx->width;\n\n    s->height = avctx->height;\n\n\n\n    s->last_frame    = av_frame_alloc();\n\n    s->current_frame = av_frame_alloc();\n\n    if (!s->current_frame || !s->last_frame) {\n\n        av_frame_free(&s->current_frame);\n\n        av_frame_free(&s->last_frame);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV444P;\n\n\n\n    return 0;\n\n}\n", "idx": 25593, "substitutes": {"avctx": ["apclient", "avtmp", "averctx", "aftx", "aveclient", "wavtx", "avhandle", "avetmp", "avwcs", "wavconfig", "averctl", "avectl", "iverctx", "avcfg", "ajgc", "avct", "cvtmp", "avetimeout", "afcfg", "wavcontext", "avercf", "avcf", "averwcs", "ajtx", "avcpu", "Avcontext", "aptaddr", "wavcfg", "cvctx", "avecpu", " avjac", "afcc", "apctx", "wavcc", "vartimeout", "avcam", "afcontext", "aptx", " avcam", " avwcs", " avct", "ajcam", "avgc", " avcontext", "avecf", "afclient", "avercam", "avecontext", "ajctx", "Avtx", " avconfig", "Avctx", "devctx", "avtimeout", "apttx", "avertimeout", "avectx", " avcc", "varhandle", "afctx", "abtx", "avtx", "abctx", " avcfg", "varctx", "devtimeout", "ajwcs", "avect", "avercpu", "avclient", "avetx", " avtmp", "cvcontext", "avcontext", "devtx", "iverct", "ivercontext", "devaddr", "abcontext", "apcontext", "avctl", "cvtx", "Avconfig", "avcc", "aveconfig", "ajctl", "wavctx", "avjac", "avertx", "iverconfig", "avergc", " avtx", "avegc", "abjac", "avaddr", "aptctx", "avejac", "averhandle", "varcpu", "avconfig", "avehandle", "ajcf", "apttimeout", "averaddr"], "s": ["ms", "as", "ports", "sb", "ops", "eps", "ins", "gets", "os", "comm", "fs", "sports", "rs", "c", "ses", "aunts", "scl", "hs", "ds", "details", "g", "tests", "spec", "pers", "p", "has", "changes", "cs", "sts", "sac", "ags", "set", "aws", "services", "sw", "vs", "S", "als", "js", "bs", "ss", "is", "ats", "l", "ts", "ns", "ps", "ims", "acs", "states", "stats", "z", "qs", "es", "its", "gs", "less", "sv", "ers", "parts", "ass", "ls", "v", "sq"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_bt_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    struct USBBtState *s = (struct USBBtState *) dev->opaque;\n\n    int ret = 0;\n\n\n\n    if (!s->config)\n\n        goto fail;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_IN:\n\n        switch (p->devep & 0xf) {\n\n        case USB_EVT_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->evt, p);\n\n            break;\n\n\n\n        case USB_ACL_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->acl, p);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->sco, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_OUT:\n\n        switch (p->devep & 0xf) {\n\n        case USB_ACL_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,\n\n                            usb_bt_hci_acl_complete, p->data, p->len);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,\n\n                            usb_bt_hci_sco_complete, p->data, p->len);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 25602, "substitutes": {"dev": ["priv", "device", "ad", "Device", "hid", "cam", "home", "ev", "conn", "os", "app", "att", "pad", "w", "def", " device", "phy", "ds", "mem", "cmd", "DEV", "ver", "buf", "devices", "an", "av", "raw", "scan", "ach", "usb", "test", "ac", "nt", "des", "Dev", "pro", "h", "t", "proc", "v", "hw"], "p": ["f", "ping", "pre", "i", "press", "pb", "o", "power", "br", "op", "pc", "d", "pad", "vp", "w", "part", "app", "pp", "c", "att", "phy", "at", "command", "g", "cp", "resp", "j", "pe", "ap", "rep", "np", "up", "b", "data", "dp", "l", "ps", "post", "ip", "y", "pa", "wp", "port", "prev", "tp", "bp", "e", "sp", "xp", "fp", "pkg", "P", "lp", "t", "jp", "pat", "m", "v", "q", "pt"], "s": ["sis", "comm", "app", "c", "sam", "tags", "r", "changes", "aws", "vs", "S", "ns", "y", "states", "less", "h", "v", "sq", "ess", "i", "space", "sb", "args", "os", "rs", "sl", "n", "state", "cs", "j", "session", "ats", "ts", "ims", "des", "its", "m", "sys", "ms", "as", "ins", "ses", "has", "res", "sts", "sw", "go", "bs", "is", "b", "l", "ps", "stats", "gs", "serv", "ls", "ssl", "fs", "w", "bes", "ds", "hs", "params", "g", "ans", "set", "an", "js", "ss", "es", "num", "sp", "sv", "self", "t", "conf"]}}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static void rtas_ibm_read_slot_reset_state2(PowerPCCPU *cpu,\n\n                                            sPAPREnvironment *spapr,\n\n                                            uint32_t token, uint32_t nargs,\n\n                                            target_ulong args, uint32_t nret,\n\n                                            target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    uint64_t buid;\n\n    int state, ret;\n\n\n\n    if ((nargs != 3) || (nret != 4 && nret != 5)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    sphb = find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_get_state) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_get_state(sphb, &state);\n\n    rtas_st(rets, 0, ret);\n\n    if (ret != RTAS_OUT_SUCCESS) {\n\n        return;\n\n    }\n\n\n\n    rtas_st(rets, 1, state);\n\n    rtas_st(rets, 2, RTAS_EEH_SUPPORT);\n\n    rtas_st(rets, 3, RTAS_EEH_PE_UNAVAIL_INFO);\n\n    if (nret >= 5) {\n\n        rtas_st(rets, 4, RTAS_EEH_PE_RECOVER_INFO);\n\n    }\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 25619, "substitutes": {"cpu": ["sys", "chip", "cu", "boot", "conn", "pc", "core", "gpu", "mem", "prof", "cp", "linux", "pid", "gp", "ctx", "nu", "phys", "np", "process", "processor", "CPU", "pu", "gc", "xi", "jp", "proc", "cli", "hw"], "spapr": [" spipr", "spapsrs", "spaptr", "spapir", " spiprar", "spaprs", "spopr", " spopir", "spopro", "spaptR", "spippr", "spopir", "spraprs", " spipR", "spoprs", " spapir", " spapR", " spoprs", "sprapr", "spapsr", " spaprar", "sprapro", "spapro", "spiprc", " spiprc", "spaptrar", "spaptrc", "spaprar", "spiprar", " spapro", "spipr", "spipR", "spaprc", "spapsro", " spopro", "spipprc", " spaprc", "spippR", "spapR", "sprapir", " spaprs", " spopr", "spapsir", "spipprar"], "token": ["secret", "tree", "Token", "ok", " tokens", "reset", "os", "kt", "oken", "tn", "target", "fn", "ens", "rf", "next", "ets", "rt", "ti", "ts", "info", "ns", "wt", "json", "mt", "hat", "vt", "init"], "nargs": ["Nargs", "trets", "Nret", "Nparams", "pparams", "Narg", "nrets", "Nrets", "targs", " nrets", "parg", "targ", "narg", "tret", "pargs", " nparams", " narg", "nparams", "prets"], "args": ["ras", "limits", "values", "ots", "ins", "fields", "gets", "mus", "rs", "issues", "flags", "params", "s", "arr", "GS", "cs", "ags", "arms", "aws", "Args", "bits", "rows", "ars", "js", "settings", "uments", "xs", "ns", "ts", "states", "vals", "stats", "terms", "uns", "its", "gs", "atts", "ires", "parts", "arg", "names", "res"], "nret": ["pnret", "pnalt", " nRet", "Nalt", "Nargs", "nRET", " nback", "sarg", "Nret", "cnargs", "Narg", "nRet", "drets", "nrets", "dret", "Nrets", "nalt", " nrets", "pnback", "NRET", "NRet", "dRet", "sargs", "narg", " nRET", "cnret", "srets", "Nback", "pnrets", "sret", "nback", " nalt", "dRET", " narg", "cnalt", "cnarg"], "rets": ["urs", "tails", "utes", "finals", "ails", "RET", "gets", "ants", "fs", "rs", "lists", "ses", "ds", "uts", "flags", "results", "tn", "tests", "uds", "sets", "sts", "ints", "bits", "ocks", "rows", "aws", "fits", "als", "els", "outs", "ets", "uments", "ats", "ts", "ns", "runs", "atives", "states", "vals", "uns", "tes", "qs", "des", "aus", "fts", "acs", "its", "aux", "gs", "ards", "ires", "ls", "unts", "ces", "events", "res"], "sphb": ["sphyr", "spha", "smphrb", "sphyrb", "sapha", "spscp", " smphl", " sphrb", "smpha", " smphr", " sphba", " smphbb", " smphrb", " smpha", "saphbb", " spha", "sphr", "sshl", "saphb", "smphc", "spscbb", "smphb", " smphu", "sppbb", "sshb", " sphp", "sphp", "smphr", "smphu", "sphyb", "skhb", "smphp", "sphba", "sphip", "sfxl", "sphyu", "skhrb", "sphrb", "saphu", " smphb", "spscba", " smphc", "sphl", "sshc", "sphya", "skhbb", " sphl", "sppb", "sphib", "sphiba", "smphba", " sphu", "spscb", " sphc", "sphc", "sfxr", " sphbb", "sfxb", "sshr", "sppr", " smphp", "smphl", "sphybb", "sfxc", "sphu", "smphbb", " smphba", " sphr", "sphibb", "sphbb"], "spc": ["mpc", "mpcr", "mpcu", " spsc", "spcs", "specs", "spcu", "splc", "spepc", " spf", "spcr", "ppc", "shc", "splC", "spsc", " spC", "shci", "splunc", "speunc", "spec", " spci", "shsc", " spcs", "apci", " spcu", "aspca", "apsc", "speC", " spunc", "spf", "spca", "shf", "apunc", "sppc", "apc", "specu", " sppc", "spC", "aspc", "ppcu", "mpca", "splpc", "apf", "spci", "apcu", "spunc", "ppcr", "apcs", "aspcr", "aspcu", "ppca"], "buid": ["suID", "buId", "bui", " bui", "gui", "uuids", "cuID", "guId", "suId", "luid", "uuId", "cuids", "luId", " buids", "uuid", "guID", "luID", " buId", "buids", "uuID", "guid", "cuid", "cuId", "suid", "buID", "lui", " buID"], "state": ["secret", "type", "i", "length", "out", "ort", "err", "reset", "store", "len", "status", "unit", "value", "id", "result", "error", "reg", "event", "local", "target", "row", "ose", "r", "fire", "resource", "n", "node", "set", "STATE", "State", "tag", "is", "test", "size", "start", "port", "trust", "data", "states", "key", "ate", "st", "style", "un", "t", "index", "lock", "name"], "ret": ["secret", "it", "alt", "lit", "out", "tech", "rest", "err", "reset", "RET", "ref", "re", "success", "status", "len", "gt", "def", "result", "rev", "nl", "error", "mem", "tn", "get", "det", "reply", "dt", "resp", "ne", "ert", "rt", "back", "ts", "nt", "nat", "ft", "val", "flag", "mt", "net", "Ret", "ptr", "tr", "elt", "vt", "jp", "arg", "res"]}}
{"project": "qemu", "commit_id": "c91e681a558fc21073ffc491b5a022d5f340fa0b", "target": 0, "func": "void qmp_migrate_set_cache_size(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    /* Check for truncation */\n\n    if (value != (size_t)value) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                  \"exceeding address space\");\n\n        return;\n\n    }\n\n\n\n    s->xbzrle_cache_size = xbzrle_cache_resize(value);\n\n}\n", "idx": 25636, "substitutes": {"value": ["type", "attribute", "length", "expression", "currently", "values", "see", "min", "byte", "fee", "unit", "vp", "tv", "w", "index", "create", "zero", "buffer", "now", "Value", "p", "VALUE", "new", " compute", "node", "set", "total", "instance", "eth", "data", "test", "size", "scale", "key", "bin", "val", "current", "sv", "number", "ue", "unknown", "max", "t", "hello", "v", "name", "hw"], "errp": [" errpa", "usrp", "timerlp", " Errpa", "timerp", " errP", "errP", " Errphp", "usrpa", "sprpr", " Errpr", "sprpd", "sprp", " errphp", "errpd", "timerpd", "errlp", " Errp", "errphp", "timerpr", "errpr", " ErrP", "usrphp", "usrP", "sprlp", " Errlp", "errpa", " Errpd"], "s": ["sys", " self", "ms", "i", "sb", "mos", "o", " ss", "sis", "fs", "v", "rs", "c", "ses", "hs", "sl", "g", "r", "n", "p", "state", "S", "bs", "ss", "a", "is", "b", "ts", "ps", "st", "es", "gs", "e", "sv", "ls", "t", "m", "sq", "ess", "ssl"]}}
{"project": "qemu", "commit_id": "f53f4da9c68941fe70a3ca9e3fc792c8acf69c0c", "target": 1, "func": "int path_is_absolute(const char *path)\n\n{\n\n    const char *p;\n\n#ifdef _WIN32\n\n    /* specific case for names like: \"\\\\.\\d:\" */\n\n    if (*path == '/' || *path == '\\\\')\n\n        return 1;\n\n#endif\n\n    p = strchr(path, ':');\n\n    if (p)\n\n        p++;\n\n    else\n\n        p = path;\n\n#ifdef _WIN32\n\n    return (*p == '/' || *p == '\\\\');\n\n#else\n\n    return (*p == '/');\n\n#endif\n\n}\n", "idx": 25669, "substitutes": {"path": ["ath", "context", "join", "length", "x", "full", "where", "dir", "point", "temp", "d", "w", "config", "part", "c", "skip", "index", "value", "error", "local", "empty", "relative", "r", "cmd", "cp", "phi", "route", "pid", "prefix", "pointer", "dest", "root", "transform", "message", "next", "PATH", "th", "chain", "file", "raw", "php", "anc", "port", "template", "text", "progress", "dn", "link", "current", "time", "package", "self", "pkg", "pattern", "h", "t", "stat", "format", "pat", "v", "m", "name", "pt", "Path"], "p": ["ping", "ep", "pre", "i", "pb", "pc", "d", "v", "vp", "part", "pad", "pp", "c", "pr", "g", "r", "pers", "cp", "n", "pid", "pointer", "pn", "j", "ap", "pos", "pe", "pl", "np", "rep", "a", "b", "l", "php", "ps", "ip", "post", "y", "pa", "port", "wp", "pro", "sp", "bp", "tp", "fp", "pard", "pkg", "P", "h", "jp", "t", "lp", "m", "point", "pat", "q", "pt"]}}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "opts_end_struct(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    GHashTableIter iter;\n\n    GQueue *any;\n\n\n\n    if (--ov->depth > 0) {\n\n        return;\n\n    }\n\n\n\n    /* we should have processed all (distinct) QemuOpt instances */\n\n    g_hash_table_iter_init(&iter, ov->unprocessed_opts);\n\n    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {\n\n        const QemuOpt *first;\n\n\n\n        first = g_queue_peek_head(any);\n\n        error_setg(errp, QERR_INVALID_PARAMETER, first->name);\n\n    }\n\n    g_hash_table_destroy(ov->unprocessed_opts);\n\n    ov->unprocessed_opts = NULL;\n\n    if (ov->fake_id_opt) {\n\n        g_free(ov->fake_id_opt->name);\n\n        g_free(ov->fake_id_opt->str);\n\n        g_free(ov->fake_id_opt);\n\n    }\n\n    ov->fake_id_opt = NULL;\n\n}\n", "idx": 25670, "substitutes": {"ov": ["OV", "von", "sov", "ovi", "o", "oval", "ev", "oos", "iv", "ova", "oss", "vp", "ow", "roc", "rov", "dev", "og", "vv", "auth", "hov", "liv", "nov", "ouch", "van", "ove", "oo", "aven", "gov", "ob", "ovan", "vr", "forge", "oh", "always", "vs", "oooo", "own", "vo", "av", "osh", "oid", "lov", "nv", "oc", "kov", "ocr", "akov", "anon", "ware", "oops", "fo", "offic", "obs", "off", "oa", "uv", "iov", "v", "env", "once", " cov", "od"], "iter": ["iterator", "ator", "it", "ic", "inter", "ait", "ter", "cer", "gen", "star", "item", "oder", "er", "master", "buffer", "seq", "r", "Iter", "n", "list", "ser", " iterator", "ipper", "walker", "actor", "next", "th", "chain", "inner", "init", "rer", "dr", "expr", "ip", "iver", "its", "coll", "former", "ir", "reader", "writer", "ptr", "tr", "h", "q", "loop", "t", "est", "v", "str", "enter"], "any": ["sys", "ANY", "parent", "as", "other", "x", "nas", "args", "null", "each", "some", "none", "never", "at", "er", "reg", "or", "known", "empty", "g", "either", "n", "arr", "maybe", "new", "cs", "can", " ANY", "ast", "Any", "raw", "ns", "must", "same", "native", "optional", "current", "by", "unknown", "gc", "all", "t", "q", "m", "this"], "depth": ["lvl", "stack", "tree", "context", "dim", "dq", "conn", "debug", "tips", "dc", "path", "tip", "root", "Depth", "deep", "level", "priority", "rank", "DEP", "ns", "dr", "scale", "progress", "roots", "driver", "scope", "ptr", "dep"], "first": ["f", "pre", "full", "latest", "star", "fresh", "only", "op", "with", "part", "fr", "after", "result", "top", "header", "use", "new", "initial", "util", "transform", "quick", "next", "last", "primary", "start", "prev", "must", "info", "front", "st", "fc", "current", "self", "second", "before", "head", "unknown", "all", "First", "format", "final", "stat", "str", "name"]}}
{"project": "FFmpeg", "commit_id": "204cb29b3c84a74cbcd059d353c70c8bdc567d98", "target": 1, "func": "static av_cold int shorten_decode_close(AVCodecContext *avctx)\n\n{\n\n    ShortenContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < s->channels; i++) {\n\n        s->decoded[i] -= s->nwrap;\n\n        av_freep(&s->decoded[i]);\n\n        av_freep(&s->offset[i]);\n\n    }\n\n    av_freep(&s->bitstream);\n\n    av_freep(&s->coeffs);\n\n\n\n    return 0;\n\n}\n", "idx": 25672, "substitutes": {"avctx": ["avecontext", " avctl", "Avtx", "Avctx", "avctl", "Avcontext", "camcontext", "avjac", "AVctx", "avectx", " avjac", "avtx", "camjac", " avtx", "Avctl", "avectl", "camctx", "AVcontext", "camtx", "AVtx", "avetx", " avcontext", "avcontext", "AVjac"], "s": ["f", "sys", "ms", "space", "sb", "ops", "os", "comm", "sports", "v", "rs", "w", "c", "sam", "ds", "scl", "hs", "spec", "p", "sc", "bis", "state", "cs", "sts", "aws", "bits", "vs", "S", "als", "js", "bs", "ss", "settings", "so", "is", "ats", "b", "ts", "ns", "ps", "l", "sm", "stats", "qs", "z", "its", "gs", "less", "sv", "self", "h", "ls", "q", "t", "stat", "sq", "ess"], "i": ["ui", " j", " di", " multi", "ini", "id", " iter", "I", " bi", "sim", "ai", " li", "li", "info", "ip", "ij", "y", " mi", "ci", " si", "iu", " I", "si", "h", "v", "ei", "ji", "ki", "\u0438", "us", " ni", " ii", "gu", "remote", "io", "j", "chain", "ind", "ims", "key", "uri", "m", "point", "mount", "qi", "ix", "ms", "batch", "x", "multi", "ami", "ri", "phi", "di", "zi", "mi", "ii", "print", "is", " ti", " pi", "bi", " index", " m", "xi", "im", "q", "it", "ic", "pi", " ki", "ex", "fi", "g", "me", "gi", "hi", "ti", "u", " wi", "t", "index", "init"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,\n\n                                         src - (stride * 2),\n\n                                         stride, dst, stride);\n\n}\n", "idx": 25693, "substitutes": {"dst": ["Dput", " Dst", "dsrc", " dsrc", "sst", " Dsrc", "sput", "Dst", "dsest", " Dest", " Dput", "dest", "Dsrc", "dsst", "Dest", " dput", "sdest", " dest", "dput", " ddest", "dsput", "dsdest", "sest", "ddest"], "src": ["sys", "sn", "cur", "length", "sb", "rl", "ins", "iv", "bc", "ipl", "rs", "usc", "ur", "sub", "rc", "ctr", "sl", "gin", "in", "r", "inst", "sr", "supp", "sc", "s", "img", "ser", "dest", "dist", "input", "sec", "RC", "rt", "comp", "b", "req", "ind", "desc", "rin", "loc", "txt", "st", "imp", "source", "ptr", "cc", "str"], "stride": [" strack", "tsime", "shrope", " strIDE", "constide", "stIDE", "shrend", "privido", "STRack", "strend", "Strride", " strride", " strido", "strape", "strider", "STRope", "Strape", "Strope", "privide", "STRido", "shride", "strack", "strido", "stide", " strape", " strime", "constope", "tsride", "strride", "privack", "STRend", "constride", "trride", "tsider", "StrIDE", "privride", "STRride", "trime", "Stride", "trider", "shrride", "strIDE", "strope", "strime", " strider", "tride", " strend", " strope", "stape", "constend", "STRide", "tside", "Strend"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t apic_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    DeviceState *d;\n\n    APICCommonState *s;\n\n    uint32_t val;\n\n    int index;\n\n\n\n    d = cpu_get_current_apic();\n\n    if (!d) {\n\n        return 0;\n\n    }\n\n    s = DO_UPCAST(APICCommonState, busdev.qdev, d);\n\n\n\n    index = (addr >> 4) & 0xff;\n\n    switch(index) {\n\n    case 0x02: /* id */\n\n        val = s->id << 24;\n\n        break;\n\n    case 0x03: /* version */\n\n        val = 0x11 | ((APIC_LVT_NB - 1) << 16); /* version 0x11 */\n\n        break;\n\n    case 0x08:\n\n        apic_sync_vapic(s, SYNC_FROM_VAPIC);\n\n        if (apic_report_tpr_access) {\n\n            cpu_report_tpr_access(s->cpu_env, TPR_ACCESS_READ);\n\n        }\n\n        val = s->tpr;\n\n        break;\n\n    case 0x09:\n\n        val = apic_get_arb_pri(s);\n\n        break;\n\n    case 0x0a:\n\n        /* ppr */\n\n        val = apic_get_ppr(s);\n\n        break;\n\n    case 0x0b:\n\n        val = 0;\n\n        break;\n\n    case 0x0d:\n\n        val = s->log_dest << 24;\n\n        break;\n\n    case 0x0e:\n\n        val = s->dest_mode << 28;\n\n        break;\n\n    case 0x0f:\n\n        val = s->spurious_vec;\n\n        break;\n\n    case 0x10 ... 0x17:\n\n        val = s->isr[index & 7];\n\n        break;\n\n    case 0x18 ... 0x1f:\n\n        val = s->tmr[index & 7];\n\n        break;\n\n    case 0x20 ... 0x27:\n\n        val = s->irr[index & 7];\n\n        break;\n\n    case 0x28:\n\n        val = s->esr;\n\n        break;\n\n    case 0x30:\n\n    case 0x31:\n\n        val = s->icr[index & 1];\n\n        break;\n\n    case 0x32 ... 0x37:\n\n        val = s->lvt[index - 0x32];\n\n        break;\n\n    case 0x38:\n\n        val = s->initial_count;\n\n        break;\n\n    case 0x39:\n\n        val = apic_get_current_count(s);\n\n        break;\n\n    case 0x3e:\n\n        val = s->divide_conf;\n\n        break;\n\n    default:\n\n        s->esr |= ESR_ILLEGAL_ADDRESS;\n\n        val = 0;\n\n        break;\n\n    }\n\n    trace_apic_mem_readl(addr, val);\n\n    return val;\n\n}\n", "idx": 25704, "substitutes": {"opaque": ["ospatile", "opcode", "appaque", "occode", "opatile", "appatile", "ospaque", "ocaque", "appcache", "appcode", "ospcache", "ospcode", "occache", "ocatile", "opcache"], "addr": ["block", "sys", "hw", "inter", "x", "ad", "tx", "on", "obj", "adr", "address", "ref", "store", "hash", "len", "host", "dh", "pad", "id", "at", "cmd", "ace", "alias", "add", "prefix", "set", "ctx", " address", "align", "info", "work", "ip", "src", "loc", "alloc", "link", "Address", "ptr", "offset", "t", "v", "ix"], "d": ["f", "sd", "pd", "ld", "ad", "dq", "dy", "dh", "w", "c", "cd", "D", "dc", "ds", "dev", "g", "r", "db", "ed", "n", "p", "dt", "dm", "di", "did", "gd", "da", "b", "ind", "l", "dr", "dd", "dat", "bd", "dn", "fd", "e", "t", "dict", "m", "v", "dos"], "s": ["sis", "comm", "c", "sam", "tests", "r", "p", "changes", "aws", "bits", "vs", "S", "xs", "ns", "less", "h", "v", "sq", "series", "sd", "sn", "sb", "args", "obj", "os", "rs", "sl", "spec", "n", "state", "cs", "j", "ats", "ts", "ims", "des", "tes", "its", "m", "sys", "ms", "as", "full", "ins", "ses", "results", "sts", "sw", "bs", "a", "is", "b", "l", "ps", "stats", "ads", "gs", "ls", "socket", "se", "fs", "sol", "w", "ds", "hs", "params", "details", "g", "cmd", "an", "js", "ss", "settings", "qs", "terms", "es", "sp", "e", "sv", "t"], "val": [" el", "alt", "rol", "bl", "valid", "crit", " res", "vol", " arg", "pos", "pl", "li", "loc", "il", "v", "pol", "cal", "tx", "oval", " resp", " ret", "value", "pr", "el", "bal", "fail", "tag", "pass", " value", "Val", "lib", "eval", "label", "point", "def", " bl", "abel", "fl", "sel", " eval", "compl", "pret", "vec", "doc", " al", "serv", "elt", "stat", "it", "prop", "lit", "spot", "al", "aval", "ref", "len", "sol", "cho", "ail", "pal", "resp", "rel", "hal", "util", "am", "req", "urg", "VAL", "vals", "ival", "ret", "res"], "index": ["active", "address", "status", "host", "unit", "valid", "id", "connect", "open", "pos", "location", "size", "info", "page", "loc", "link", "max", "dim", "i", "code", "config", "value", "error", "height", "n", "sort", "j", "Index", "level", "shape", "chain", "ind", "key", "handle", "iter", "label", "offset", "timeout", "point", "ix", "device", "type", "length", "x", "batch", "cycle", "axis", "di", "depth", "ne", "is", "test", "seek", "version", "number", "no", "server", "ref", "slice", "success", "sol", "date", "zero", "find", "row", "empty", "list", "set", "order", "instance", "dd", "position", "num", "check", "loop"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddressLegacy *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddressLegacy, 1);\n\n    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n", "idx": 25711, "substitutes": {"host_port": ["host_file", "Host_port", " host_file", "host_PORT", "Host_name", "host_ports", " host_ports", " host_PORT", "Host_PORT", "host_name", "Host_ports"], "errp": ["errorpe", " errpa", "errps", "excping", " errP", " Errpe", "errpe", " Errr", "errping", "errP", "rrping", " errr", "excpa", "errorps", " Errps", "errorr", " errpe", " errping", "errr", "rrP", "rrp", " Errp", "errorp", "excP", "rrpa", " errps", "excp", "errpa"], "iaddr": [" iadd", "diaddr", "iadd", "icoord", "iiadd", "piarp", " ipad", "fadd", "Ipad", "faddr", "dicoord", "Iaddress", "Iaddr", "fptr", "Iadd", "siaddr", "iarp", "iptr", "piaddr", " icoord", "iiadr", "iipad", "iaddress", " iaddress", "iadr", "siptr", "iiptr", "ialloc", "iiaddress", "inarp", "ipad", "sicoord", "fadr", "pialloc", "inalloc", " iarp", "inaddr", "sadr", "sadd", "iiaddr", "inpad", "pipad", " ialloc", "sptr", " iptr", "diptr"], "saddr": [" saddress", "jsptr", "tsadr", " sadr", "jsaddress", "Sptr", "Saddr", "ssadr", "Sadr", "stsadd", "atsptr", "stsadr", "stsptr", "jsaddr", "atsaddr", "saddress", "stsaddr", "jsadr", "Saddress", "spkg", "atsadr", "atsadd", "jsadd", " sadd", "Sadd", "tsaddr", "jspkg", " spkg", "sadd", "ssptr", "sadr", "Spkg", " sptr", "tsptr", "sptr", "ssaddr", "ssadd", "tsadd"]}}
{"project": "FFmpeg", "commit_id": "24947d4988012f1f0fd467c83418615adc11c3e8", "target": 1, "func": "static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)\n\n{\n\n    int dy  = y1 - y0;\n\n    int adx = x1 - x0;\n\n    int ady = FFABS(dy);\n\n    int sy  = dy < 0 ? -1 : 1;\n\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n\n    if (ady*2 <= adx) { // optimized common case\n\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n\n    } else {\n\n        int base  = dy / adx;\n\n        int x     = x0;\n\n        uint8_t y = y0;\n\n        int err   = -adx;\n\n        ady -= FFABS(base) * adx;\n\n        while (++x < x1) {\n\n            y += base;\n\n            err += ady;\n\n            if (err >= 0) {\n\n                err -= adx;\n\n                y   += sy;\n\n            }\n\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n\n        }\n\n    }\n\n}\n", "idx": 25729, "substitutes": {"x0": ["ax0", "X1", "tx1", " x7", "xt0", "dx1", "ixzero", "axzero", "tx0", "xt1", " xzero", "ax1", "ix10", "ix1", "xt10", "y2", "dx7", "ax7", "X2", " x2", "x10", "ex0", "X0", "ex2", "xzero", "x7", "x2", "ex1", "dxzero", "ix0", " x10", "dx0", "xtzero"], "y0": ["dy0", " yzero", "iy8", "Y1990", "yyzero", "iyzero", "ey00", "yy1", "iy0", "yZero", "eyarg", "vy0", "y1990", " yStart", "vy1", "vyStart", "ey8", "dynull", "yy0", "nyZero", "ny00", "oynull", "oy0", "oy1", "Ynull", " yZero", "yzero", "yarg", "ey0", "oy1990", "Y0", "yStart", "Y1", "ny0", "nyStart", "vyZero", "y8", "ny8", "dy1", "iy00", "iy1", "nyarg", "ynull", "iyarg", "y00", "dy1990"], "x1": [" x3", "X1", "z1", "fxOne", "fx3", "fx1", " xOne", "xOne", "y2", "x3", " x2", "y3", "rx0", "X0", "fx0", "rxOne", "rx3", "x2", "X3", "yOne", "rx2", "z0", "zOne", "rx1"], "y1": ["tyOne", "iy01", "xOne", "Y2", "y2", "YOne", "x3", "y3", "y01", "iyOne", "xy1", "Y0", "x01", "iy3", "Y1", " y2", "xy3", "ty1", "iy1", "yOne", "ty2", " yOne", "xy01", "ty0", "xyOne"], "buf": ["block", "fb", "pack", "batch", "out", "pb", "cam", "err", "ref", "queue", "uf", "ff", "box", "br", "bc", "bo", "map", "result", "grid", "buffer", "mem", "var", "cast", "cmd", "pool", "db", "list", "Buff", "cache", "arr", "img", "tab", "cb", "ctx", "vec", "bs", "doc", "bn", "b", "req", "wb", "ba", "txt", "window", "bin", "rb", "cap", "Buffer", "buff", "pkg", "table", "v", "alph", "cv"], "x": ["fx", "i", "ux", "tx", "on", "xy", "d", "w", "xt", "ex", "xes", "yx", "k", "c", "ice", "dx", "rx", "r", "n", "p", "inx", "ax", "j", "X", "xx", "xxx", "ity", "xs", "l", "xc", "y", "ox", "ware", "z", "base", "px", "e", "xp", "xi", "t", "index", "v", "wx", "m", "ix"]}}
{"project": "qemu", "commit_id": "47c6d3ecdfc3fc354cf996f873a9f854c2325160", "target": 1, "func": "static const QObject *qmp_input_get_object(QmpInputVisitor *qiv,\n\n                                           const char *name)\n\n{\n\n    const QObject *qobj;\n\n\n\n    if (qiv->nb_stack == 0) {\n\n        qobj = qiv->obj;\n\n    } else {\n\n        qobj = qiv->stack[qiv->nb_stack - 1].obj;\n\n    }\n\n\n\n    if (name && qobject_type(qobj) == QTYPE_QDICT) {\n\n        return qdict_get(qobject_to_qdict(qobj), name);\n\n    } else if (qiv->nb_stack > 0 && qobject_type(qobj) == QTYPE_QLIST) {\n\n        return qlist_entry_obj(qiv->stack[qiv->nb_stack - 1].entry);\n\n    }\n\n\n\n    return qobj;\n\n}\n", "idx": 25734, "substitutes": {"qiv": ["giver", "queryivable", "checkiver", "queryiva", "quij", "qtv", " qij", " qiver", "requiver", "acquiver", "qIv", "quiver", "requivo", "sqIv", "quIV", "quiter", "acquiva", "quivo", "quiva", "qiva", " qIv", "oxiva", "eqiv", " qistor", "eqiter", "quIv", "quivist", "giv", "qiter", " qtv", "giva", "queryiro", "queryivo", "qivist", "checkiv", "dqiver", "oxiver", "acquiv", "dqiv", "quiro", "qutv", "quivable", "dqival", "oxIV", "qivo", "sqiv", "qiver", "checkIV", "acquivable", "eqiver", "dqIV", "requivist", "queryiver", "queryij", "oxiv", "qival", "qivable", "requiv", "eqistor", "qiro", "sqIV", "qij", "queryiv", "queryivist", "qIV", "sqiver", "sqival", "dqtv", "sqij", "checkival", "qistor", "quiv", " qiter", "gIV", "quistor", " qiro"], "name": ["type", "length", "x", "active", "o", "search", "item", "code", "term", "named", "normal", "part", "w", "valid", "c", "value", "id", "k", "word", "title", "local", "common", "path", "group", "r", "comment", "family", "n", "alias", "prefix", "new", "equal", "unique", "data", "attr", "size", "NAME", "key", "text", "ame", "missing", "flag", "Name", "label", "no", "filename", "str", "names"], "qobj": ["eqobj", "qualconn", "qObj", "dqObj", "questonet", "sqobj", " qrb", "qualobj", "dqobject", " qog", "qso", "eqbo", "iqObj", "eqobject", "dqjs", "qqobj", "qqrb", "qqconn", "questObj", "qrb", "qqaddr", "querybo", "iqobj", "questobj", "queryobject", "questobject", "eqog", "qualaddr", "questso", "qonet", "qualrb", "qobject", "sqonet", " qObj", " qjs", " qconn", "eqelt", "sqelt", "dqrect", " qaddr", "eqoy", "aqObj", "qog", "sqjs", "qjs", "aqobject", "questrect", "sqso", "qconn", "questjs", " qbo", "sqconn", "iqobject", "qbo", " qonet", " qso", "sqbo", " qobject", "qoy", "qrect", "dqobj", "eqconn", "queryconn", "aqobj", "queryobj", "sqog", "qqoy", "qaddr", "aqjs", "qqelt", "iqrect", "qelt", "sqoy"]}}
{"project": "FFmpeg", "commit_id": "fbd6c97f9ca858140df16dd07200ea0d4bdc1a83", "target": 1, "func": "static BufferPoolEntry *get_pool(AVBufferPool *pool)\n\n{\n\n    BufferPoolEntry *cur = NULL, *last = NULL;\n\n\n\n    do {\n\n        FFSWAP(BufferPoolEntry*, cur, last);\n\n        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);\n\n        if (!cur)\n\n            return NULL;\n\n    } while (cur != last);\n\n\n\n    return cur;\n\n}\n", "idx": 25737, "substitutes": {"pool": ["block", "padding", "type", "context", "batch", "protected", "out", "client", "server", "queue", "network", "hash", "status", "host", "pc", "vp", "config", "container", "wrapper", "profile", "buffer", "PO", "mem", "list", "cp", "p", "cache", "memory", "pg", "util", "buf", "policy", "connection", "chain", "php", "port", "ool", "Pool", "work", "window", "history", "alloc", "handle", "access", "pro", "http", "slot", "pkg", "timeout", "table", "manager", "lock", "socket", "program"], "cur": ["cmp", "kar", " curs", "c", "ctr", "cont", "r", "pg", "arr", " current", "ctx", "ct", " cr", "loc", "stable", "coll", "gc", "ptr", "pkg", "ch", "currently", " ob", "cf", "obj", "pri", "occ", "entry", " ret", "ur", "func", "cat", "cp", "sc", "msg", "buf", " rc", "desc", "sur", "con", "current", " prev", "col", "now", "ah", " cursor", "Cur", "gr", "coord", "oc", "dr", "public", "cr", "still", " cont", "serv", "tr", "tmp", "str", "cv", "err", "cor", " sc", "rc", "result", "car", "row", "cmd", "req", "unc", "ocr", "fac", " Cur"], "last": ["parent", "length", "full", "latest", "nd", " Last", " LAST", "v", "highest", "entry", "first", "push", "nl", "master", "ul", "local", "largest", "row", "empty", "good", "best", "list", "las", "count", "new", "slave", "set", "total", "show", "next", "th", "stop", "Last", "old", "l", "prev", "nt", "stable", "base", "st", "est", "tail", "most", "max", "end", "all", "final", "index", "tmp", "leaf"]}}
{"project": "FFmpeg", "commit_id": "74b1bf632f125a795e66e5fd0a060b9c7c55b7a3", "target": 1, "func": "static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,\n\n                          int *end_pos2)\n\n{\n\n    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {\n\n        s->gb           = s->in_gb;\n\n        s->in_gb.buffer = NULL;\n\n        assert((get_bits_count(&s->gb) & 7) == 0);\n\n        skip_bits_long(&s->gb, *pos - *end_pos);\n\n        *end_pos2 =\n\n        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;\n\n        *pos      = get_bits_count(&s->gb);\n\n    }\n\n}\n", "idx": 25738, "substitutes": {"s": ["sys", "ms", "space", "as", "sa", "sb", "store", "eps", "se", "comm", "os", "fs", "rs", "c", "sam", "ses", "ds", "hs", "sl", "details", "sync", "g", "r", "n", "p", "changes", "bis", "cs", "ains", "sts", "sw", "aws", "set", "services", "vs", "S", "als", "js", "bs", "setup", "ss", "so", "is", "ats", "b", "ts", "ns", "ps", "ims", "l", "y", "acs", "qs", "stats", "south", "es", "gs", "less", "sv", "serv", "sg", "parts", "h", "ls", "t", "sq"], "pos": ["ping", "padding", "prop", "lit", "out", "pose", "po", "len", "os", "op", "Pos", "pc", "sol", "def", "body", "at", "seq", "mon", "neg", "cond", "p", "n", "POS", "pid", "add", "rel", "proc", "buf", "bits", "coord", "nos", "pl", "vs", "doc", "ps", "post", "port", "loc", "position", "pro", "num", "limit", "val", "pres", "off", "offset", "rot", "pat", "no", "index", "pt", "res"], "end_pos": ["end___pos", "end___mon", "stop_comp", "endlypo", "end__ps", "end_po", "end___neg", "end_post", "end__pos", "ending_mon", "end_mon", "stop_po", "stop_pos", "end_limit", " end_ps", "ending___neg", "endlypos", "ending_pid", "end__loc", "ending_pos", "ending___mon", "end_ps", "endlycomp", "ending___pid", "endlypost", "stop_post", "end_neg", "ending___pos", " end_limit", "end__limit", "end_comp", "end_pid", "end___pid", "ending_neg", "end_loc", " end_loc"], "end_pos2": ["end_pos4", "end_pt4", "end_os2", "end_pos3", "end_neg2", "end_pos02", "end_Pos4", "end_ps02", "end_size2", "end_neg02", "end_Pos02", "end_Pos3", "end_POS3", "end_Pos2", "end_pt2", "end_POS2", "end_POS4", "end_po2", "end_ps2", "end_pt3"]}}
{"project": "qemu", "commit_id": "0d4cc3e715f5794077895345577725539afe81eb", "target": 1, "func": "static int vpc_write(BlockDriverState *bs, int64_t sector_num,\n\n    const uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    int64_t offset;\n\n    int64_t sectors, sectors_per_block;\n\n    int ret;\n\n    VHDFooter *footer =  (VHDFooter *) s->footer_buf;\n\n\n\n    if (cpu_to_be32(footer->type) == VHD_FIXED) {\n\n        return bdrv_write(bs->file, sector_num, buf, nb_sectors);\n\n    }\n\n    while (nb_sectors > 0) {\n\n        offset = get_sector_offset(bs, sector_num, 1);\n\n\n\n        sectors_per_block = s->block_size >> BDRV_SECTOR_BITS;\n\n        sectors = sectors_per_block - (sector_num % sectors_per_block);\n\n        if (sectors > nb_sectors) {\n\n            sectors = nb_sectors;\n\n        }\n\n\n\n        if (offset == -1) {\n\n            offset = alloc_block(bs, sector_num);\n\n            if (offset < 0)\n\n                return -1;\n\n        }\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, buf, sectors * BDRV_SECTOR_SIZE);\n\n        if (ret != sectors * BDRV_SECTOR_SIZE) {\n\n            return -1;\n\n        }\n\n\n\n        nb_sectors -= sectors;\n\n        sector_num += sectors;\n\n        buf += sectors * BDRV_SECTOR_SIZE;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25741, "substitutes": {"bs": ["ubis", "bb", "sb", "pb", "boxes", "bl", "lbs", "bps", "fs", "bc", "rs", "bes", "BS", "ubs", "ds", "hs", "bm", "aos", "bos", "bis", "fps", "cs", "cks", "sts", "aws", "bits", "vs", "iss", "als", "js", "outs", "ss", "b", "ts", "ns", "aus", "locks", "qs", "bh", "its", "gs", "bp", "obs", "ls", "blog"], "sector_num": ["sectoritymn", "sector_NUM", "entry_comb", "ector_num", "sector_sum", "sector2nr", "secondaryidnum", "entry_n", "entryityum", "sectoridnum", " sector_number", "ector2nr", "sectoritynumber", "sector_Num", "character_NUM", "sector_n", "sector_mn", "ector2Num", "character_num", "sectorityn", " sector_um", "sectoritycomb", "sectoritynum", "sector_nr", "secondaryidnumber", "sector_nom", " sector_un", "sector2number", "character_n", " sector_Num", "character_sum", "entry_num", "ector_nr", "sector_no", " sector_no", "secondary_nom", "sectoridnumber", "entryityn", "secondary_num", "sectorityno", " sector_mn", "sector_un", "sectoridnom", "entryitynum", "sectorityum", "secondaryidnom", "ector_number", "sector_number", "entryitycomb", "sectoridnr", "entry_um", "secondaryidnr", "secondary_number", "secondary_nr", "sector_comb", "sector2Num", "ector_Num", "sector_um", "ector2number", "ector2num", "sector2num"], "buf": ["block", "cur", "batch", "length", "out", "pb", "ref", "queue", "uf", "ff", "br", "box", "len", "bc", "nb", "w", "map", "result", "output", "buffer", "mem", "seq", "empty", "func", "cmd", "db", "Buff", "img", "msg", "cb", "bytes", "bar", "vec", "raw", "doc", "b", "data", "port", "wb", "addr", "text", "window", "alloc", "bin", "limit", "rb", "cap", "Buffer", "etc", "buff", "off", "half", "h", "BU", "tmp", "end", "xff", "v", "cv"], "nb_sectors": ["nb__pellers", "nb_sesackers", "nb__sectors", "nb_esctors", "nb_pseors", "nb__sellers", "nb_vechers", "nb_begments", "nb_sesllers", "nb_spellers", "nb_sechers", "nb__seors", "nb_spechers", "nb_specs", "nb_seackers", "nb_tectors", "nb_peors", "nb_sebuilders", "nb_spegments", "nb_tegments", "nb_esors", "nb_vevers", "nb_seivers", "nb_sellers", "nb_serctors", "nb_bedrivers", "nb_psectors", "nb_suctors", "nb_kedrivers", "nb_pellers", "nb_psellers", "nb__pectors", "nb__pevers", "nb_vedrivers", "nb_sesbuilders", "nb_vellers", "nb_psegments", "nb_speors", "nb_veackers", "nb_pectors", "nb_serivers", "nb_tecs", "nb_bectors", "nb_sergments", "nb_teivers", "nb_vectors", "nb_sercs", "nb_veors", "nb_sullers", "nb_kectors", "nb_esackers", "nb_secs", "nb_esbuilders", "nb_sesctors", "nb_suvers", "nb_sesors", "nb__peors", "nb_vebuilders", "nb_severs", "nb_bellers", "nb_speivers", "nb_segments", "nb_vegments", "nb_pevers", "nb_seschers", "nb_seors", "nb_beors", "nb_kegments", "nb_suors", "nb_sedrivers", "nb_keors", "nb_spectors", "nb__severs"], "s": ["sn", "i", "sb", "sis", "fs", "rs", "c", "ses", "ds", "hs", "sl", "g", "plays", "n", "p", "bis", "cs", "sts", "ares", "aws", "bits", "j", "vs", "S", "js", "ss", "a", "is", "b", "ats", "ts", "ns", "ps", "stats", "its", "gs", "sv", "h", "ls", "t", "sq"], "offset": ["block", "padding", "option", "type", "parent", "batch", "alt", "out", "peer", "o", "reset", "address", "ref", "bound", "op", "pad", "entry", "error", "at", "buffer", "command", "row", "offs", "pointer", "prefix", "util", "set", "transform", "et", "origin", "order", "pos", "coord", "area", "ta", "tile", "align", "location", "start", "shift", "port", "info", "loc", "addr", "key", "seek", "url", "base", "alloc", "position", "sp", "mask", "offer", "mt", "slot", "off", "ptr", "rot", "trace", "t", "timeout", "index", "point", "end", "Offset"], "sectors": ["sections", "pectors", "speports", "vections", "perseors", "spelements", "seurers", "seters", "spectors", "sexors", "veors", "vegments", "desters", "vectors", "peors", "pellers", "pegments", "persectors", "pseters", "pselements", "vellers", "desctions", "sexports", "seports", "vevers", "sexllers", "desctors", "veters", "desllers", " sellers", "perseurers", " severs", "spellers", "veurers", "veports", "velements", "psectors", "persevers", "pseors", "sexctors", " seurers", "severs", "spevers", "seors", "spegments", "psellers", " seors", "psections", "speors", " selements", "sellers", "segments", "selements"], "sectors_per_block": ["sectors_PER_block", "sectors_PER_byte", "sectors_per_byte", "sectors_Per_Block", "sectors_in_byte", "sectors_in_block", "sectors_per_bin", "sectors_PER_group", "sectors_per_group", "sectors_per_Block", "sectors_Per_blocks", "sectors_PER_Block", "sectors_per__Block", "sectors_per__group", "sectors_per__block", "sectors_per_bit", "sectors_PER_bit", "sectors_per_blocks", "sectors_in_bin", "sectors_Per_block"], "ret": ["it", "alt", "ter", "out", "not", "reset", "RET", "re", "len", "success", "att", "gt", "result", "rev", "cont", "ctr", "mem", "r", "cat", "det", "cmd", "reply", "deg", "arr", "rem", "et", "j", "nz", "ne", "print", "rt", "nt", "fun", "expr", "rets", " RET", "ft", "iter", "val", "net", "mt", "aux", "Ret", "ptr", "tail", "tr", "t", "elt", "final", "conv", "Return", "res"], "footer": ["coolER", "tuneder", "tunER", "throwter", " Footer", " Footers", "Footers", "tuners", "throwner", "footeder", "Footner", "footner", "Footter", "cooler", "tuner", "footter", " Footeder", "thrower", "Footeder", "coolter", "throwER", "Footer", "footER", "FootER", "coolner", " FootER", "footers"]}}
{"project": "FFmpeg", "commit_id": "4ffe5e2aa5241f8da9afd2c8fbc854dcc916c5f9", "target": 1, "func": "static int read_old_huffman_tables(HYuvContext *s){\n\n#if 1\n\n    GetBitContext gb;\n\n    int i;\n\n\n\n    init_get_bits(&gb, classic_shift_luma, sizeof(classic_shift_luma)*8);\n\n    if(read_len_table(s->len[0], &gb)<0)\n\n        return -1;\n\n    init_get_bits(&gb, classic_shift_chroma, sizeof(classic_shift_chroma)*8);\n\n    if(read_len_table(s->len[1], &gb)<0)\n\n        return -1;\n\n\n\n    for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i];\n\n    for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i];\n\n\n\n    if(s->bitstream_bpp >= 24){\n\n        memcpy(s->bits[1], s->bits[0], 256*sizeof(uint32_t));\n\n        memcpy(s->len[1] , s->len [0], 256*sizeof(uint8_t));\n\n    }\n\n    memcpy(s->bits[2], s->bits[1], 256*sizeof(uint32_t));\n\n    memcpy(s->len[2] , s->len [1], 256*sizeof(uint8_t));\n\n\n\n    for(i=0; i<3; i++){\n\n        ff_free_vlc(&s->vlc[i]);\n\n        init_vlc(&s->vlc[i], VLC_BITS, 256, s->len[i], 1, 1, s->bits[i], 4, 4, 0);\n\n    }\n\n\n\n    generate_joint_tables(s);\n\n\n\n    return 0;\n\n#else\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"v1 huffyuv is not supported \\n\");\n\n    return -1;\n\n#endif\n\n}\n", "idx": 25748, "substitutes": {"s": ["sys", "ms", "as", "ops", "ins", "reads", "os", "se", "gets", "fs", "comm", "rs", "w", "c", "rates", "ses", "ds", "hs", "conf", "comments", "details", "in", "n", "p", "changes", "bis", "cs", "sts", "sw", "aws", "set", "an", "vs", "S", "als", "js", "bs", "ss", "a", "is", "b", "ats", "ts", "ns", "l", "ims", "ps", "y", "acs", "qs", "stats", "es", "its", "gs", "http", "less", "sv", "sg", "self", "parts", "h", "t", "ls", "events", "v", "sq", "m", "ssl"], "gb": ["bb", "fb", "sb", "args", " rg", "Gb", "bridge", "mb", " eg", " g", "nb", "bc", "gt", "storage", "bf", "GB", "gpu", "bm", "gin", " pg", " GB", "g", "gu", "yg", "db", "ge", " rgb", "deg", "pg", "img", "cb", "gov", "hub", "gg", "bytes", "gp", "eg", "kb", "bg", " b", "gd", "fg", "cfg", "gm", "tg", "b", "py", " db", "wb", "bd", "gs", "rb", "disabled", "sv", "gc", "rg"], "i": ["ui", " j", " di", " multi", "status", "ini", "id", "er", "PI", "in", "I", "p", " bi", "sim", "ai", "li", "info", "ip", "ij", "y", " mi", "ci", " si", "iu", " I", "si", "v", "ei", "ji", "ki", "\u0438", "ik", "us", " ii", "gu", "n", "io", "j", "chain", "ind", "ims", "uri", "m", "point", "qi", "ix", "iii", "batch", "x", "multi", "ami", "ri", "iy", "phi", "di", "oi", "zi", "mi", "ii", "depth", "print", "is", "bi", " ti", " pi", " m", "xi", "im", "q", "f", "it", "ic", "mac", "eu", "err", "slice", "pi", "ex", "g", "me", "gi", "to", "hi", "ti", "json", "e", "t", "index", "cli", "name"]}}
{"project": "qemu", "commit_id": "7264961934130df50d151def5eb415efa2e28ec5", "target": 0, "func": "exynos4_boards_init_common(MachineState *machine,\n\n                           Exynos4BoardType board_type)\n\n{\n\n    Exynos4BoardState *s = g_new(Exynos4BoardState, 1);\n\n    MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n\n\n    if (smp_cpus != EXYNOS4210_NCPUS && !qtest_enabled()) {\n\n        error_report(\"%s board supports only %d CPU cores, ignoring smp_cpus\"\n\n                     \" value\",\n\n                     mc->name, EXYNOS4210_NCPUS);\n\n    }\n\n\n\n    exynos4_board_binfo.ram_size = exynos4_board_ram_size[board_type];\n\n    exynos4_board_binfo.board_id = exynos4_board_id[board_type];\n\n    exynos4_board_binfo.smp_bootreg_addr =\n\n            exynos4_board_smp_bootreg_addr[board_type];\n\n    exynos4_board_binfo.kernel_filename = machine->kernel_filename;\n\n    exynos4_board_binfo.initrd_filename = machine->initrd_filename;\n\n    exynos4_board_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    exynos4_board_binfo.gic_cpu_if_addr =\n\n            EXYNOS4210_SMP_PRIVATE_BASE_ADDR + 0x100;\n\n\n\n    PRINT_DEBUG(\"\\n ram_size: %luMiB [0x%08lx]\\n\"\n\n            \" kernel_filename: %s\\n\"\n\n            \" kernel_cmdline: %s\\n\"\n\n            \" initrd_filename: %s\\n\",\n\n            exynos4_board_ram_size[board_type] / 1048576,\n\n            exynos4_board_ram_size[board_type],\n\n            machine->kernel_filename,\n\n            machine->kernel_cmdline,\n\n            machine->initrd_filename);\n\n\n\n    exynos4_boards_init_ram(s, get_system_memory(),\n\n                            exynos4_board_ram_size[board_type]);\n\n\n\n    s->soc = exynos4210_init(get_system_memory());\n\n\n\n    return s;\n\n}\n", "idx": 25753, "substitutes": {"s": ["sys", "i", "sa", "sb", "os", "se", "fs", "sports", "v", "rs", "us", "w", "c", "ses", "er", "ds", "hs", "sl", "g", "r", "n", "p", "cs", "sts", "sw", "ches", "S", "js", "bs", "ss", "is", "b", "ats", "ns", "ts", "ps", "ies", "y", "sand", "qs", "stats", "south", "es", "its", "gs", "ers", "sv", "self", "sg", "h", "t", "ls", "m", "sq"], "mc": ["vm", "ms", "mac", "cmp", "tm", "ma", "mb", "Mc", "mp", "pc", "c", "tc", "dc", "nic", "MC", "mm", "bm", "mx", "mic", "mk", "md", "cp", "di", "cm", "machine", "mi", "cfg", "mr", "mn", "meta", "mt", "gc", "cc", "m", "lc"]}}
{"project": "FFmpeg", "commit_id": "29d46d7bce1c67852e4c6e22605144eb32b21072", "target": 1, "func": "static void json_print_section_header(WriterContext *wctx)\n\n{\n\n    JSONContext *json = wctx->priv;\n\n    AVBPrint buf;\n\n    const struct section *section = wctx->section[wctx->level];\n\n    const struct section *parent_section = wctx->level ?\n\n        wctx->section[wctx->level-1] : NULL;\n\n\n\n    if (wctx->level && wctx->nb_item[wctx->level-1])\n\n        printf(\",\\n\");\n\n\n\n    if (section->flags & SECTION_FLAG_IS_WRAPPER) {\n\n        printf(\"{\\n\");\n\n        json->indent_level++;\n\n    } else {\n\n        av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n        json_escape_str(&buf, section->name, wctx);\n\n        JSON_INDENT();\n\n\n\n        json->indent_level++;\n\n        if (section->flags & SECTION_FLAG_IS_ARRAY) {\n\n            printf(\"\\\"%s\\\": [\\n\", buf.str);\n\n        } else if (!(parent_section->flags & SECTION_FLAG_IS_ARRAY)) {\n\n            printf(\"\\\"%s\\\": {%s\", buf.str, json->item_start_end);\n\n        } else {\n\n            printf(\"{%s\", json->item_start_end);\n\n\n\n            /* this is required so the parser can distinguish between packets and frames */\n\n            if (parent_section->id == SECTION_ID_PACKETS_AND_FRAMES) {\n\n                if (!json->compact)\n\n                    JSON_INDENT();\n\n                printf(\"\\\"type\\\": \\\"%s\\\"%s\", section->name, json->item_sep);\n\n            }\n\n        }\n\n        av_bprint_finalize(&buf, NULL);\n\n    }\n\n}\n", "idx": 25787, "substitutes": {"wctx": ["wdreq", " wcmp", "wcp", "sawpatch", "wdcp", "Wkw", "wdctx", "wdat", "wacmd", "wdesc", " wcfg", "sawcp", "nwcontext", "Wctx", " wcontext", "kwctx", "sawjac", "kwcmp", "wjac", "wfx", "Wpx", "awctx", "kwcontext", "wnp", "wacmp", "fwjp", "fwkl", "awfx", "awjac", "wanp", "wdcontext", " wcp", "wacp", "wkw", " wdesc", "wgc", "fwjac", "Wfx", "awkw", "wagc", "wcmd", "awcontext", "sawctx", "wajac", "wdpkg", "wapatch", "wddat", "walcontext", "wpatch", " wfx", "Wtx", "fwctx", " wdat", "wdbatch", "wdtx", "wkl", "rwpkg", "nwdesc", "wadat", "Wcontext", "wdgc", "wdkw", "nwctx", " wkl", "rwkw", "awcp", " wnp", "watx", "writerbatch", "wdmk", "walctx", "kwnp", "wabatch", "rwctx", "wpx", "awpatch", "waljp", "wactx", "nwcp", "rwfx", "writercmd", "writerreq", "wamk", "wtx", "wjp", "wpkg", "fwcontext", "wdfx", " wpx", " wgc", "wakl", " wkw", "writerctx", "wapkg", " wpkg", "wdpx", "wreq", "walcfg", "fwcfg", " wmk", " wjac", "rwcontext", " wtx", "wddesc", "wdcmd", "wcmp", "wmk", "wcontext", "wbatch", "wareq", " wjp", "wapx", "fwtx", "wacontext", "wcfg"], "json": ["note", "sys", "tree", "opt", "context", "tm", "tx", "news", "media", "obj", "server", "ja", "network", "csv", "son", "update", "xml", "ruby", "config", "javascript", "value", "journal", "wire", "params", "graph", "ose", "spec", "git", "metadata", "n", "kj", "node", "gov", "mint", "j", "module", "ctx", "np", "js", "html", "jack", "JSON", "data", "info", "document", "txt", "stats", "java", "export", "twitter", "kw", "global", "gc", "ml", "format", "m", "jj", "aw", "database"], "buf": ["block", "bed", "job", "batch", "out", "cf", "tx", "cam", "obj", "pb", "conv", "queue", " resp", "uf", "box", "br", "norm", "bc", "result", "bf", "cv", "buffer", "mem", "seq", "aos", "cmd", "pool", "db", "Buff", " buff", "pg", "tab", "img", "uffy", "msg", "cb", "bytes", "usr", "j", "filename", "ctx", "bag", "vec", "bs", " b", "bn", "b", "builder", "port", "fac", "aka", "btn", "txt", "window", "bh", " buffer", "iter", "rb", "kw", "aux", "Buffer", "writer", "buff", "pkg", "etc", "rw", "tmp", "uv", "v", " bu"], "section": ["operation", "feature", "service", "child", "array", "journal", "container", "sector", "environment", "uration", "size", "page", "reader", "usage", "table", "variable", "region", "parent", "action", "item", "definition", "config", "entry", "value", "header", "tab", "j", "level", "function", "session", "tag", "setup", "data", "key", "window", "global", "description", "format", "sections", "there", "context", "network", "part", "member", "comment", "node", "area", "setting", "file", "test", "version", "package", "number", "second", "sect", "block", "option", "server", "man", "component", "language", "side", "group", "list", "set", "division", "connection", "line", "element", "port", "heading", "position", "channel", "Section", "name", "ion"], "parent_section": [" parent_item", " parent_sect", "parent___parent", " parent_parent", " parent_sector", "parent_parent", " parent_channel", "parent_item", "parent___sect", "parent___side", "parent_channel", "parent_sect", " parent_side", "parent_option", "parent_side", "parent_sector", "parent___channel", " parent_option", "parent___section", "parent___item"], "indent_level": ["indent_top", "indentsmaxlevel", "indentmaxlimit", "indentexoutput", "indency_group", "indent_vel", "indents_output", "indent__limit", "indency_level", "indent_group", "indency_status", "indent__level", "indentmaxtop", "indent__top", "indentmaxlevel", "indentexlimit", "indent_status", "indentsmaxtop", "indentmaxoutput", "indency_vel", "indentsmaxoutput", "indent_limit", "indentextop", "indentexlevel", "indentsmaxlimit", "indents_limit", "indent__output", "indents_top", "indent_output", "indents_level"]}}
{"project": "qemu", "commit_id": "2231f69b4e4523c43aa459cab18ab77c0e29b4d1", "target": 0, "func": "build_madt(GArray *table_data, BIOSLinker *linker, VirtGuestInfo *guest_info)\n\n{\n\n    int madt_start = table_data->len;\n\n    const MemMapEntry *memmap = guest_info->memmap;\n\n    const int *irqmap = guest_info->irqmap;\n\n    AcpiMultipleApicTable *madt;\n\n    AcpiMadtGenericDistributor *gicd;\n\n    AcpiMadtGenericMsiFrame *gic_msi;\n\n    int i;\n\n\n\n    madt = acpi_data_push(table_data, sizeof *madt);\n\n\n\n    gicd = acpi_data_push(table_data, sizeof *gicd);\n\n    gicd->type = ACPI_APIC_GENERIC_DISTRIBUTOR;\n\n    gicd->length = sizeof(*gicd);\n\n    gicd->base_address = memmap[VIRT_GIC_DIST].base;\n\n    gicd->version = guest_info->gic_version;\n\n\n\n    for (i = 0; i < guest_info->smp_cpus; i++) {\n\n        AcpiMadtGenericInterrupt *gicc = acpi_data_push(table_data,\n\n                                                     sizeof *gicc);\n\n        ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(i));\n\n\n\n        gicc->type = ACPI_APIC_GENERIC_INTERRUPT;\n\n        gicc->length = sizeof(*gicc);\n\n        if (guest_info->gic_version == 2) {\n\n            gicc->base_address = memmap[VIRT_GIC_CPU].base;\n\n        }\n\n        gicc->cpu_interface_number = i;\n\n        gicc->arm_mpidr = armcpu->mp_affinity;\n\n        gicc->uid = i;\n\n        gicc->flags = cpu_to_le32(ACPI_GICC_ENABLED);\n\n\n\n        if (armcpu->has_pmu) {\n\n            gicc->performance_interrupt = cpu_to_le32(PPI(VIRTUAL_PMU_IRQ));\n\n        }\n\n    }\n\n\n\n    if (guest_info->gic_version == 3) {\n\n        AcpiMadtGenericTranslator *gic_its;\n\n        AcpiMadtGenericRedistributor *gicr = acpi_data_push(table_data,\n\n                                                         sizeof *gicr);\n\n\n\n        gicr->type = ACPI_APIC_GENERIC_REDISTRIBUTOR;\n\n        gicr->length = sizeof(*gicr);\n\n        gicr->base_address = cpu_to_le64(memmap[VIRT_GIC_REDIST].base);\n\n        gicr->range_length = cpu_to_le32(memmap[VIRT_GIC_REDIST].size);\n\n\n\n        if (its_class_name()) {\n\n            gic_its = acpi_data_push(table_data, sizeof *gic_its);\n\n            gic_its->type = ACPI_APIC_GENERIC_TRANSLATOR;\n\n            gic_its->length = sizeof(*gic_its);\n\n            gic_its->translation_id = 0;\n\n            gic_its->base_address = cpu_to_le64(memmap[VIRT_GIC_ITS].base);\n\n        }\n\n    } else {\n\n        gic_msi = acpi_data_push(table_data, sizeof *gic_msi);\n\n        gic_msi->type = ACPI_APIC_GENERIC_MSI_FRAME;\n\n        gic_msi->length = sizeof(*gic_msi);\n\n        gic_msi->gic_msi_frame_id = 0;\n\n        gic_msi->base_address = cpu_to_le64(memmap[VIRT_GIC_V2M].base);\n\n        gic_msi->flags = cpu_to_le32(1);\n\n        gic_msi->spi_count = cpu_to_le16(NUM_GICV2M_SPIS);\n\n        gic_msi->spi_base = cpu_to_le16(irqmap[VIRT_GIC_V2M] + ARM_SPI_BASE);\n\n    }\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + madt_start), \"APIC\",\n\n                 table_data->len - madt_start, 3, NULL, NULL);\n\n}\n", "idx": 25810, "substitutes": {"memmap": ["regcode", "memap", "ramap", "regmap", "regap", "memoryMap", "mmmap", "ramMap", "regapper", "mmcode", "MemMap", "Memcache", "Memstore", "memorystore", "memcode", " memapper", "memcache", " memMap", "memorymap", " memap", "Memap", "mmapper", "ramcache", "memoryap", "memapper", "mmcache", "mmap", "mmMap", "Memmap", "rammap", " memcache", "memstore", " memcode", "ramstore", "memMap"], "irqmap": ["irqumap", "irqttable", "pirqumaps", "irwtable", "pirqsm", "pirwcap", "irqcap", "irquset", "pirqusm", "pirqset", "irQmap", "irqsm", "irqtmap", "irQset", "irqtmaps", "pirqumap", "irqusm", "irwcap", "irQcap", "pirqmap", "irqtsm", "irQtable", "irqucap", "irqutable", "pirqmaps", "irqmaps", "irwmap", "pirqcap", "pirwmap", "irwmaps", "irqtable", "irwsm", "pirqutable", "irwset", "pirwtable", "irqumaps", "pirqtable", "irqset", "pirwset"], "madt": ["madT", "goodta", " madwt", "maT", "madta", "mastT", "mawt", "goodT", "radt", "mandT", "medta", "medt", "adwt", "madwt", "adt", "radtu", "adT", "mata", "mastwt", "radT", "madtu", "medT", "goodt", "mandt", "mastta", " madta", "mat", "medtu", "medwt", "mastt", "mandta", "adta", "mandtu", "radta", "goodwt", " madT"], "gicd": ["gicosd", "gocrdb", "gocrdc", "garicdl", "garicd", "agizd", "giacdir", "giccdir", "giacd", "agicde", "gaicde", "gocrdl", "garicdc", "gikD", "genaicdo", "giccdo", "gikdl", "genericond", "glicda", "agicdo", "agiacde", "glicd", "gicodo", "giacsd", "glicdn", "gaicdx", "glicdj", "agizda", "genikd", "garicdb", "gicdj", "agicdj", "gikdx", "gikdc", "gricd", "giqds", "gicdl", "genaicds", "giqda", "Gicd", "gricdb", "gicod", "agicd", "genicdl", "gaicda", "gicdc", "gicdb", "gicdo", "gaicdt", "genaicda", "gaicd", "giccdt", "gaicdl", "gicondn", "gizD", "giccd", "gaikdb", "genicda", "gicedb", "giccda", "gicdn", "gicsd", "gocrd", "gaikdx", "agizdj", "agicdn", "gicde", "gicbd", "gricdt", "agiacsd", "gmicda", "Gikd", "gaicds", "giconda", "gicD", "gikdt", "gaicdb", "gicdt", "giceda", "gicondj", "genericdir", "gikd", "agicda", "giced", "genericonbd", "gicedx", "gricdl", "gikdb", "Gicdi", "giconbd", "gwicD", "gaicdc", "genericondir", "agicsd", "gicondir", "giqdo", "gicondt", "genicdt", "giqd", "gicode", "genericd", "giacdo", "agizdn", "giccds", "gicda", "gizdi", "genikdl", "genikdt", "gicdi", "gaicsd", "gizd", "gizda", "genicdo", "gizdj", "giccbd", "gaikd", "genericondt", "giacdt", "genericdt", "genericbd", "GicD", "gicdir", "gizdn", "gaicdo", "Gikdi", "gmicdb", "genikdc", "gwicd", "giacde", "gizdb", "Gicdb", "gikda", "genicdc", "genicd", "gmicdx", "agiacd", "gicds", "genaicd", "gmicd", "GikD", "gaikda", "giacbd", "gicond", "gricdc", "gwicdb", "agiacdo", "Gikdb", "genicds", "gwicdi", "gikdi", "gicdx"], "gic_msi": ["gic__ssis", "gic_tsig", "gic_msis", "gic__ssi", "gic_mesis", "gic_ssig", "gic__ssig", "gic_msid", "gic_mesig", "gic__msis", "gic_tsis", "gic_mesid", "gic_msig", "gic_ssi", "gic__msig", "gic_tsi", "gic_ssid", "gic_ssis", "gic__msid", "gic_tsid", "gic_mesi", "gic__ssid", "gic__msi"], "i": ["ui", " j", " di", "o", "status", "c", "ini", "id", "in", "r", "I", "p", " bi", "sim", "ai", "li", "info", "ij", "y", " mi", "ci", " si", "iu", " I", "si", "h", "v", "ji", "ki", " x", " ii", "n", "j", "ind", "ims", "m", "qi", "ix", "x", "multi", " pos", "ami", "k", "ri", "phi", "di", "zi", "go", "mi", "ii", "is", "l", "bi", " ti", " pi", " m", "xi", "im", "q", "mu", "f", "it", "ic", "pi", "me", "gi", "to", "hi", "ti", "e", "u", "index", " index", "name"], "gicc": ["genikh", "ogaic", "gusc", "gario", "gpivic", "gpik", " gitech", "ogario", " giac", "ggiac", "ggicc", "generigg", "genarc", "ogiac", "giac", "goique", "mgicc", "gniac", " gics", " gario", "generirc", "gifa", "gencci", "gnerc", "msgerc", "ogicc", "cicc", "genario", "gaisc", "gic", "agaic", "gaics", "gaitech", "agicc", "agisc", "goinc", "genericc", "generc", "geario", "mgikh", "gcci", "genique", "geicc", "gikh", "gnisc", " givic", "mario", "mcc", "genifa", "genirc", "msgicc", "agik", "msgusc", "gaicc", "agusc", " gusc", "ggivic", "geniac", "gaic", "ginc", "micc", "garc", "gpics", "circ", "gnarc", "mgarc", "genisc", "gnirc", "geik", "mgifa", "gnikh", "goicc", "gcc", "gaiac", "gics", "genererc", "gpic", "goerc", "gpcc", "ogivic", "ogitech", "gpusc", "gitech", "gocci", "girc", "msgiac", "ogisc", "gique", "gisc", "gaario", "agario", "genaic", "gnicc", "genivic", "cigg", "geusc", "gairc", "msgcci", "gnigg", "goivic", "gpario", "gpicc", " gcc", "gpiac", " gic", "cerc", "ggusc", "mic", "geninc", "msgivic", "gpitech", "gigg", "goario", "genicc", "msgique", "ogifa", "gerc", "agifa", "gik", "oginc", "givic", "gnifa"], "armcpu": ["ymcomputer", "armcomputer", "amgpu", "armcp", "ymproc", "warmcomputer", "Armnic", "warmnic", "iamcpu", "armpu", "armgpu", "romcpu", "iamproc", "smcpu", "amnic", "warmgpu", "warmcpu", "romcu", "Armpu", "warmcp", "Armgpu", "smcomputer", "iamlinux", "smcp", "ampu", "warmproc", "Armcpu", "romlinux", "warmcu", "ymcpu", "armproc", "armcu", "smproc", "armnic", "romproc", "iamcu", "warmlinux", "ymcp", "armlinux", "warmpu", "amcpu"], "gic_its": ["gic2ms", "gic_ts", "gic_ms", "gik2ms", "gik_its", "gic2its", "gic2ls", "gik2ts", "gik_ms", "gik_ls", "gik_ts", "gik2ls", "gic2ts", "gic_ls", "gik2its"]}}
{"project": "qemu", "commit_id": "d6cf84e1de0a167963f0803d6e39f6ca03e27eaa", "target": 0, "func": "int slirp_can_output(void)\n\n{\n\n    return !slirp_vc || qemu_can_send_packet(slirp_vc);\n\n}\n", "idx": 25813, "substitutes": {}}
{"project": "qemu", "commit_id": "7f595609b49615b07c50b7182c4ef125c39cb5da", "target": 0, "func": "static void usb_tablet_class_initfn(ObjectClass *klass, void *data)\n\n{\n\n    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);\n\n\n\n    uc->init           = usb_tablet_initfn;\n\n    uc->product_desc   = \"QEMU USB Tablet\";\n\n    uc->usb_desc       = &desc_tablet;\n\n    uc->handle_packet  = usb_generic_handle_packet;\n\n    uc->handle_reset   = usb_hid_handle_reset;\n\n    uc->handle_control = usb_hid_handle_control;\n\n    uc->handle_data    = usb_hid_handle_data;\n\n    uc->handle_destroy = usb_hid_handle_destroy;\n\n}\n", "idx": 25814, "substitutes": {"klass": ["Klasses", "klasses", " klad", "wklass", "Kazz", "Kls", " klasses", "tklass", "Klad", "tkls", "kls", "tklasses", "wklasses", "tkazz", " kazz", "klad", "Klass", "wklad", " kls", "wkls", "kazz"], "data": ["type", "rew", " Data", "ata", "d", "w", "def", "id", "ds", " sd", "func", "rec", "new", "Data", "raw", " dat", "attr", "dat", "json", "bin", "DATA", " DATA", "init", "name", "mu", " datas", "res"], "uc": ["urn", "cmp", "eu", "userc", "cu", "uf", "ucc", "orc", "bc", "pc", "us", "usc", "uch", "roc", "tc", "asc", "icc", "pac", "nic", "ul", "ugen", "um", "ec", "UC", "cus", "soc", " su", "ut", "isc", "ust", "lu", "uci", "uk", "ach", "ct", "auc", "ac", "unc", "oc", "ocr", "anc", "aus", "xc", "ou", "uh", "ci", "ub", "mc", "fc", " unc", "uu", "ud", "u", "etc", "gc", "cc", "uv", " ac"]}}
{"project": "FFmpeg", "commit_id": "77d98898211eeb0241e8411428b0b364a6231744", "target": 1, "func": "static int pixlet_decode_frame(AVCodecContext *avctx, void *data,\n                               int *got_frame, AVPacket *avpkt)\n{\n    PixletContext *ctx = avctx->priv_data;\n    int i, w, h, width, height, ret, version;\n    AVFrame *p = data;\n    ThreadFrame frame = { .f = data };\n    uint32_t pktsize;\n    bytestream2_init(&ctx->gb, avpkt->data, avpkt->size);\n    pktsize = bytestream2_get_be32(&ctx->gb);\n    if (pktsize <= 44 || pktsize - 4 > bytestream2_get_bytes_left(&ctx->gb)) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid packet size %\"PRIu32\"\\n\", pktsize);\n    }\n    version = bytestream2_get_le32(&ctx->gb);\n    if (version != 1)\n        avpriv_request_sample(avctx, \"Version %d\", version);\n    bytestream2_skip(&ctx->gb, 4);\n    if (bytestream2_get_be32(&ctx->gb) != 1)\n    bytestream2_skip(&ctx->gb, 4);\n    width  = bytestream2_get_be32(&ctx->gb);\n    height = bytestream2_get_be32(&ctx->gb);\n    w = FFALIGN(width,  1 << (NB_LEVELS + 1));\n    h = FFALIGN(height, 1 << (NB_LEVELS + 1));\n    ctx->levels = bytestream2_get_be32(&ctx->gb);\n    if (ctx->levels != NB_LEVELS)\n    ctx->depth = bytestream2_get_be32(&ctx->gb);\n    if (ctx->depth < 8 || ctx->depth > 15) {\n        avpriv_request_sample(avctx, \"Depth %d\", ctx->depth);\n    }\n    ret = ff_set_dimensions(avctx, w, h);\n    if (ret < 0)\n        return ret;\n    avctx->width  = width;\n    avctx->height = height;\n    if (ctx->w != w || ctx->h != h) {\n        free_buffers(avctx);\n        ctx->w = w;\n        ctx->h = h;\n        ret = init_decoder(avctx);\n        if (ret < 0) {\n            free_buffers(avctx);\n            ctx->w = 0;\n            ctx->h = 0;\n            return ret;\n        }\n    }\n    bytestream2_skip(&ctx->gb, 8);\n    p->pict_type = AV_PICTURE_TYPE_I;\n    p->key_frame = 1;\n    p->color_range = AVCOL_RANGE_JPEG;\n    ret = ff_thread_get_buffer(avctx, &frame, 0);\n    if (ret < 0)\n        return ret;\n    for (i = 0; i < 3; i++) {\n        ret = decode_plane(avctx, i, avpkt, frame.f);\n        if (ret < 0)\n            return ret;\n        if (avctx->flags & AV_CODEC_FLAG_GRAY)\n            break;\n    }\n    postprocess_luma(frame.f, ctx->w, ctx->h, ctx->depth);\n    postprocess_chroma(frame.f, ctx->w >> 1, ctx->h >> 1, ctx->depth);\n    *got_frame = 1;\n    return pktsize;\n}", "idx": 25828, "substitutes": {"avctx": ["afctl", " avctl", "averctx", " avcb", "aftx", "avercb", "afcp", " avcookie", "jamcb", "awtx", "vrctx", "abcmp", "averctl", "avectl", "awctx", "avcfg", "ajconn", "avcmp", "devcookie", "vrcmp", "avcpu", "abcpu", "avecam", "afcookie", "abcp", "navcookie", "navtx", "afcam", "awcm", "jamcpu", "avcam", "afcontext", "vrcp", "ajcam", "averconn", " avcontext", "jamctx", "avecontext", "avcookie", "ajctx", "avercookie", "navconn", "avecmp", "devctx", "avecm", "devconn", "avectx", "afctx", "awcfg", "abtx", "avtx", "abctx", "navctx", " avcfg", "avecfg", "avecb", "avecp", "avercpu", "avetx", "afconn", " avcm", "avcb", "ajcp", "aveconn", "avcontext", "devtx", "avcp", "avctl", "avercfg", "jamtx", "avertx", "avconn", " avtx", "abcb", "vrtx", "avcm"], "data": ["f", "block", "padding", "action", "x", "length", "out", "o", "obj", "ref", "ata", "d", "pad", "def", "value", "map", "id", "result", "body", "video", "buffer", "empty", "r", "feed", "bytes", "buf", "extra", "form", "message", "frame", "image", "Data", "next", "raw", "file", "a", "example", "response", "size", "info", "text", "window", "json", "bin", "DATA", "offset", "table", "t", "content", "format", "m", "str", "name"], "got_frame": ["got_channel", "gotopdepth", "gotopframe", "new_frame", "gotopchannel", "new_channel", "new_depth", "got_depth", "gotopcode", "new_code", "got_code"], "avpkt": ["avppkt", "avppvt", "avcpkt", "avcpck", "avpbkt", "avPkt", "avpidkg", "avpck", "avPwk", "avpcwk", "avpcct", "avpckt", "avpbck", "avpetta", "avpadft", "avpcvt", " avpvt", "avppct", "avejpet", "avpidft", "avpft", "avpet", "avpidkt", "avepet", "avepck", "averpidetta", " avpwk", "averpidkt", "averpetta", "avjpet", "avppetta", "avppkg", "avpadkt", "avejpact", "avcpact", " avPkt", " avPct", "avpadetta", "avepact", "avpact", "avpwk", "avpidetta", " avPwk", "avpvt", "avpct", "avppft", "avpkg", "avjpkt", "avejpkt", "averpkg", "averpidft", "avPct", "averpkt", "avejpck", " avPvt", "avjpact", "avpbet", "avjpck", "averpidkg", "avPvt", " avpct", "avpbact", "averpft", "avppwk", "avpadkg", "avcpet", "avepkt"], "ctx": ["cmp", "na", "cu", "ca", "comm", "std", "that", "_", "tc", "index", "c", "dc", "crit", "mem", "inst", "pool", "ctl", "prefix", "new", "uint", "dad", "ct", "ns", "loc", "history", "px", "fc", "exec", "scope", "pkg", "v", "parent", "tm", "tx", "cf", "args", "obj", "conn", "bc", "config", "gt", "ctrl", "func", "cp", "buf", "setup", "co", "iac", "wcs", "desc", "timeout", "warn", "hw", "sys", "context", "batch", "cam", "jac", "def", "kt", "abc", "ck", "act", "bytes", "cm", "acl", "cfg", "cas", "addr", "cookie", "kw", "xp", "kl", "cc", "wx", "lc", "cv", "ka", "tk", "cmd", "resp", "cb", "module", "np", "xc", "nt", "vals", "txt", "aux", "check", "etc", "jp", "proc", "conv", "utils", "conf"], "i": ["x", " j", " pos", " info", " it", " offset", " ni", " ii", "id", " id", " ip", "I", " bi", "j", " e", " v", " out", " err", " b", " fi", " mi", " tid", " m", " f", "t", " wi", " t", " index"], "w": ["f", "wid", "x", "W", "length", "fw", "iw", "d", "wh", "v", "widget", "wm", "c", "ew", "wall", "wd", "ww", "wr", "wl", "g", "r", "n", "we", "sw", "nw", "wa", "wcs", "l", "weights", "weight", "wb", "wp", "wt", "window", "wi", "wn", "z", "rw", "win", "wal", "kw", "t", "m", "wx", "aw", "hw"], "h": ["f", "it", "hd", "ch", "length", "ih", "hash", "ph", "host", "dh", "he", "d", "hr", "k", "hang", "high", "hm", "ah", "g", "n", "kh", "hz", "sh", "hal", "oh", "ht", "html", "hi", "b", "l", "y", "history", "bh", "ha", "H", "hh", "t", "m", "v", "ho"], "height": ["range", "padding", "ch", "dim", "length", "angle", "gy", "power", "hash", "host", "wh", "distance", "he", "widget", "thus", "hang", "ty", "grow", "buffer", "high", "above", "kh", "memory", "gravity", "holes", "view", "level", "ht", "hei", "depth", "shape", "quality", "html", "th", "capacity", "gh", "rank", "size", "volume", "y", "history", "window", "H", "style", "resolution", "era", "Height", "radius", "density", "bottom"], "ret": ["alt", "ter", "not", "err", "reset", "ll", "ref", "RET", "re", "len", "status", "success", "try", "tf", "gt", "def", "value", "valid", "result", "rev", "nl", "after", "ry", "mem", "r", "ext", "cmd", "resp", "usr", "pret", "rem", "set", "print", "rt", "back", "nt", "dr", "rets", "txt", " RET", "ft", "tif", "val", "flag", "mt", " Ret", "Ret", "tr", "elt", "jp", "final", "conv", "res"], "version": ["f", "class", "option", "type", "major", "VER", "server", "latest", "grade", "conv", "hash", "versions", "feature", "status", "vert", "none", "part", "VERSION", "date", "video", "title", "currency", "family", "VERS", "spec", "ver", "browser", "beta", "supported", "mode", "mint", "order", "level", "sequence", "depth", "vers", "quality", "release", "tag", "python", "test", "size", "scale", "volume", "virtual", "key", "vision", "position", "ison", "serial", "vector", "time", "driver", "number", "package", "iso", "current", "tr", "Version", "required", "format", "index", "v", "final", "name", "alone", "summary"], "p": ["f", "pb", "o", "pc", "d", "pp", "c", "pr", "r", "cp", "n", "j", "ap", "rep", "np", "a", "b", "ps", "pa", "sp", "fp", "P", "t", "jp", "q", "m", "pt"], "pktsize": ["pktersizer", "puktsizer", "pktionsization", "pktsource", "pktersize", "pektersiz", "pktionsiz", "pktesize", "pktsizer", "pkcsource", "pktsization", "pektsiz", "pkutsiz", "pkTSource", "pektesize", "pkTSizer", "pkutsized", "pktesizes", "pktessize", "pkTSized", "pktypesizer", "puktsource", "pukutsize", "pkTSization", "pklsate", "pkTsiz", "pktsizes", "puktsized", "pktypesize", "pkTsize", "pkutsource", "pektsizer", "pektsization", "pektsizes", "pkutssize", "pukTSized", "pukutsiz", "pktssize", "pukTSiz", "pektersizer", "pektesate", "pukTSize", "pektsize", "pkcsiz", "puktsiz", "pekutssize", "pktionsize", "pukTSizer", "pklsize", "pektersize", "pektssize", "pktersiz", "pkutsizer", "pekutsize", "pkcsize", "pktersizes", "puktsize", "pktersization", "pekutsiz", "pkTsizer", "pkTsized", "pkutsize", "pektersization", "pktsized", "pukutsource", "pkTSiz", "pukutsized", "pkcsized", "pktesate", "pktsiz", "pktsate", "pkTSize", "pktionsizer", "pktypesiz", "pektesizes", "pklsizer", "pktesizer", "pklsizes", "pektsate", "pktesiz", "pktypesized", "pektesizer", "pktersate", "pekutsizer"]}}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_2_9_class_options(MachineClass *mc)\n\n{\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->gs_allowed = false;\n\n    ccw_machine_2_10_class_options(mc);\n\n    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);\n\n    s390mc->css_migration_enabled = false;\n\n}\n", "idx": 25831, "substitutes": {"mc": ["ic", "ms", "mac", "tm", "ming", "ma", "Mc", "bc", "mp", "pc", "c", "tc", "dc", "icc", "nic", "MC", "mm", "mem", "mic", "mk", "mx", "md", "cus", "nc", "cs", "mot", "cm", "mi", "ac", "anc", "cci", "mr", "vc", "mn", "met", "fc", "mt", "gc", "cms", "cc", "m", "lc"], "s390mc": [" s90ms", "rs390c", "s390MC", "saturatedmic", "s90mic", "s380ms", " s90mc", "s380mm", " s390mic", "s390ms", " s40mm", "s90cc", " s390ms", "rs390mc", "saturatedcc", "s90ms", "s390cc", "rs380cc", "s30mic", " s90mic", "s350mc", "s40mic", " s40mic", "s90mc", "s350MC", "s380mc", " s40MC", "s30ms", "s90c", "rs380mc", "s390mm", "rs380c", "s30mc", "s40mc", "rs390cc", "rs380mic", "s40MC", "s350mm", " s90cc", "s30cc", "s390mic", "rs390mic", "s40mm", " s390MC", "s390c", "saturatedc", "saturatedmc", "s380c", "s380mic", "s350mic", " s40mc", " s390mm", "s380MC", " s390cc", "s380cc"]}}
{"project": "FFmpeg", "commit_id": "d9fe6b926cd619c311e45e0ae352cf09713c482c", "target": 1, "func": "static int matroska_read_header(AVFormatContext *s)\n\n{\n\n    MatroskaDemuxContext *matroska = s->priv_data;\n\n    EbmlList *attachements_list = &matroska->attachments;\n\n    MatroskaAttachement *attachements;\n\n    EbmlList *chapters_list = &matroska->chapters;\n\n    MatroskaChapter *chapters;\n\n    MatroskaTrack *tracks;\n\n    uint64_t max_start = 0;\n\n    int64_t pos;\n\n    Ebml ebml = { 0 };\n\n    AVStream *st;\n\n    int i, j, k, res;\n\n\n\n    matroska->ctx = s;\n\n\n\n    /* First read the EBML header. */\n\n    if (ebml_parse(matroska, ebml_syntax, &ebml)\n\n        || ebml.version > EBML_VERSION       || ebml.max_size > sizeof(uint64_t)\n\n        || ebml.id_length > sizeof(uint32_t) || ebml.doctype_version > 3) {\n\n        av_log(matroska->ctx, AV_LOG_ERROR,\n\n               \"EBML header using unsupported features\\n\"\n\n               \"(EBML version %\"PRIu64\", doctype %s, doc version %\"PRIu64\")\\n\",\n\n               ebml.version, ebml.doctype, ebml.doctype_version);\n\n        ebml_free(ebml_syntax, &ebml);\n\n        return AVERROR_PATCHWELCOME;\n\n    } else if (ebml.doctype_version == 3) {\n\n        av_log(matroska->ctx, AV_LOG_WARNING,\n\n               \"EBML header using unsupported features\\n\"\n\n               \"(EBML version %\"PRIu64\", doctype %s, doc version %\"PRIu64\")\\n\",\n\n               ebml.version, ebml.doctype, ebml.doctype_version);\n\n    }\n\n    for (i = 0; i < FF_ARRAY_ELEMS(matroska_doctypes); i++)\n\n        if (!strcmp(ebml.doctype, matroska_doctypes[i]))\n\n            break;\n\n    if (i >= FF_ARRAY_ELEMS(matroska_doctypes)) {\n\n        av_log(s, AV_LOG_WARNING, \"Unknown EBML doctype '%s'\\n\", ebml.doctype);\n\n    }\n\n    ebml_free(ebml_syntax, &ebml);\n\n\n\n    /* The next thing is a segment. */\n\n    pos = avio_tell(matroska->ctx->pb);\n\n    res = ebml_parse(matroska, matroska_segments, matroska);\n\n    // try resyncing until we find a EBML_STOP type element.\n\n    while (res != 1) {\n\n        res = matroska_resync(matroska, pos);\n\n        if (res < 0)\n\n            return res;\n\n        pos = avio_tell(matroska->ctx->pb);\n\n        res = ebml_parse(matroska, matroska_segment, matroska);\n\n    }\n\n    matroska_execute_seekhead(matroska);\n\n\n\n    if (!matroska->time_scale)\n\n        matroska->time_scale = 1000000;\n\n    if (matroska->duration)\n\n        matroska->ctx->duration = matroska->duration * matroska->time_scale\n\n                                  * 1000 / AV_TIME_BASE;\n\n    av_dict_set(&s->metadata, \"title\", matroska->title, 0);\n\n\n\n    if (matroska->date_utc.size == 8)\n\n        matroska_metadata_creation_time(&s->metadata, AV_RB64(matroska->date_utc.data));\n\n\n\n    tracks = matroska->tracks.elem;\n\n    for (i=0; i < matroska->tracks.nb_elem; i++) {\n\n        MatroskaTrack *track = &tracks[i];\n\n        enum CodecID codec_id = CODEC_ID_NONE;\n\n        EbmlList *encodings_list = &track->encodings;\n\n        MatroskaTrackEncoding *encodings = encodings_list->elem;\n\n        uint8_t *extradata = NULL;\n\n        int extradata_size = 0;\n\n        int extradata_offset = 0;\n\n        uint32_t fourcc = 0;\n\n        AVIOContext b;\n\n\n\n        /* Apply some sanity checks. */\n\n        if (track->type != MATROSKA_TRACK_TYPE_VIDEO &&\n\n            track->type != MATROSKA_TRACK_TYPE_AUDIO &&\n\n            track->type != MATROSKA_TRACK_TYPE_SUBTITLE) {\n\n            av_log(matroska->ctx, AV_LOG_INFO,\n\n                   \"Unknown or unsupported track type %\"PRIu64\"\\n\",\n\n                   track->type);\n\n            continue;\n\n        }\n\n        if (track->codec_id == NULL)\n\n            continue;\n\n\n\n        if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {\n\n            if (!track->default_duration)\n\n                track->default_duration = 1000000000/track->video.frame_rate;\n\n            if (!track->video.display_width)\n\n                track->video.display_width = track->video.pixel_width;\n\n            if (!track->video.display_height)\n\n                track->video.display_height = track->video.pixel_height;\n\n            if (track->video.color_space.size == 4)\n\n                fourcc = AV_RL32(track->video.color_space.data);\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {\n\n            if (!track->audio.out_samplerate)\n\n                track->audio.out_samplerate = track->audio.samplerate;\n\n        }\n\n        if (encodings_list->nb_elem > 1) {\n\n            av_log(matroska->ctx, AV_LOG_ERROR,\n\n                   \"Multiple combined encodings not supported\");\n\n        } else if (encodings_list->nb_elem == 1) {\n\n            if (encodings[0].type ||\n\n                (encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP &&\n\n#if CONFIG_ZLIB\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_ZLIB &&\n\n#endif\n\n#if CONFIG_BZLIB\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_BZLIB &&\n\n#endif\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_LZO)) {\n\n                encodings[0].scope = 0;\n\n                av_log(matroska->ctx, AV_LOG_ERROR,\n\n                       \"Unsupported encoding type\");\n\n            } else if (track->codec_priv.size && encodings[0].scope&2) {\n\n                uint8_t *codec_priv = track->codec_priv.data;\n\n                int offset = matroska_decode_buffer(&track->codec_priv.data,\n\n                                                    &track->codec_priv.size,\n\n                                                    track);\n\n                if (offset < 0) {\n\n                    track->codec_priv.data = NULL;\n\n                    track->codec_priv.size = 0;\n\n                    av_log(matroska->ctx, AV_LOG_ERROR,\n\n                           \"Failed to decode codec private data\\n\");\n\n                } else if (offset > 0) {\n\n                    track->codec_priv.data = av_malloc(track->codec_priv.size + offset);\n\n                    memcpy(track->codec_priv.data,\n\n                           encodings[0].compression.settings.data, offset);\n\n                    memcpy(track->codec_priv.data+offset, codec_priv,\n\n                           track->codec_priv.size);\n\n                    track->codec_priv.size += offset;\n\n                }\n\n                if (codec_priv != track->codec_priv.data)\n\n                    av_free(codec_priv);\n\n            }\n\n        }\n\n\n\n        for(j=0; ff_mkv_codec_tags[j].id != CODEC_ID_NONE; j++){\n\n            if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,\n\n                        strlen(ff_mkv_codec_tags[j].str))){\n\n                codec_id= ff_mkv_codec_tags[j].id;\n\n                break;\n\n            }\n\n        }\n\n\n\n        st = track->stream = avformat_new_stream(s, NULL);\n\n        if (st == NULL)\n\n            return AVERROR(ENOMEM);\n\n\n\n        if (!strcmp(track->codec_id, \"V_MS/VFW/FOURCC\")\n\n            && track->codec_priv.size >= 40\n\n            && track->codec_priv.data != NULL) {\n\n            track->ms_compat = 1;\n\n            fourcc = AV_RL32(track->codec_priv.data + 16);\n\n            codec_id = ff_codec_get_id(ff_codec_bmp_tags, fourcc);\n\n            extradata_offset = 40;\n\n        } else if (!strcmp(track->codec_id, \"A_MS/ACM\")\n\n                   && track->codec_priv.size >= 14\n\n                   && track->codec_priv.data != NULL) {\n\n            int ret;\n\n            ffio_init_context(&b, track->codec_priv.data, track->codec_priv.size,\n\n                          AVIO_FLAG_READ, NULL, NULL, NULL, NULL);\n\n            ret = ff_get_wav_header(&b, st->codec, track->codec_priv.size);\n\n            if (ret < 0)\n\n                return ret;\n\n            codec_id = st->codec->codec_id;\n\n            extradata_offset = FFMIN(track->codec_priv.size, 18);\n\n        } else if (!strcmp(track->codec_id, \"V_QUICKTIME\")\n\n                   && (track->codec_priv.size >= 86)\n\n                   && (track->codec_priv.data != NULL)) {\n\n            fourcc = AV_RL32(track->codec_priv.data);\n\n            codec_id = ff_codec_get_id(ff_codec_movvideo_tags, fourcc);\n\n        } else if (codec_id == CODEC_ID_PCM_S16BE) {\n\n            switch (track->audio.bitdepth) {\n\n            case  8:  codec_id = CODEC_ID_PCM_U8;     break;\n\n            case 24:  codec_id = CODEC_ID_PCM_S24BE;  break;\n\n            case 32:  codec_id = CODEC_ID_PCM_S32BE;  break;\n\n            }\n\n        } else if (codec_id == CODEC_ID_PCM_S16LE) {\n\n            switch (track->audio.bitdepth) {\n\n            case  8:  codec_id = CODEC_ID_PCM_U8;     break;\n\n            case 24:  codec_id = CODEC_ID_PCM_S24LE;  break;\n\n            case 32:  codec_id = CODEC_ID_PCM_S32LE;  break;\n\n            }\n\n        } else if (codec_id==CODEC_ID_PCM_F32LE && track->audio.bitdepth==64) {\n\n            codec_id = CODEC_ID_PCM_F64LE;\n\n        } else if (codec_id == CODEC_ID_AAC && !track->codec_priv.size) {\n\n            int profile = matroska_aac_profile(track->codec_id);\n\n            int sri = matroska_aac_sri(track->audio.samplerate);\n\n            extradata = av_mallocz(5 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (extradata == NULL)\n\n                return AVERROR(ENOMEM);\n\n            extradata[0] = (profile << 3) | ((sri&0x0E) >> 1);\n\n            extradata[1] = ((sri&0x01) << 7) | (track->audio.channels<<3);\n\n            if (strstr(track->codec_id, \"SBR\")) {\n\n                sri = matroska_aac_sri(track->audio.out_samplerate);\n\n                extradata[2] = 0x56;\n\n                extradata[3] = 0xE5;\n\n                extradata[4] = 0x80 | (sri<<3);\n\n                extradata_size = 5;\n\n            } else\n\n                extradata_size = 2;\n\n        } else if (codec_id == CODEC_ID_TTA) {\n\n            extradata_size = 30;\n\n            extradata = av_mallocz(extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (extradata == NULL)\n\n                return AVERROR(ENOMEM);\n\n            ffio_init_context(&b, extradata, extradata_size, 1,\n\n                          NULL, NULL, NULL, NULL);\n\n            avio_write(&b, \"TTA1\", 4);\n\n            avio_wl16(&b, 1);\n\n            avio_wl16(&b, track->audio.channels);\n\n            avio_wl16(&b, track->audio.bitdepth);\n\n            avio_wl32(&b, track->audio.out_samplerate);\n\n            avio_wl32(&b, matroska->ctx->duration * track->audio.out_samplerate);\n\n        } else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 ||\n\n                   codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) {\n\n            extradata_offset = 26;\n\n        } else if (codec_id == CODEC_ID_RA_144) {\n\n            track->audio.out_samplerate = 8000;\n\n            track->audio.channels = 1;\n\n        } else if (codec_id == CODEC_ID_RA_288 || codec_id == CODEC_ID_COOK ||\n\n                   codec_id == CODEC_ID_ATRAC3 || codec_id == CODEC_ID_SIPR) {\n\n            int flavor;\n\n            ffio_init_context(&b, track->codec_priv.data,track->codec_priv.size,\n\n                          0, NULL, NULL, NULL, NULL);\n\n            avio_skip(&b, 22);\n\n            flavor                       = avio_rb16(&b);\n\n            track->audio.coded_framesize = avio_rb32(&b);\n\n            avio_skip(&b, 12);\n\n            track->audio.sub_packet_h    = avio_rb16(&b);\n\n            track->audio.frame_size      = avio_rb16(&b);\n\n            track->audio.sub_packet_size = avio_rb16(&b);\n\n            track->audio.buf = av_malloc(track->audio.frame_size * track->audio.sub_packet_h);\n\n            if (codec_id == CODEC_ID_RA_288) {\n\n                st->codec->block_align = track->audio.coded_framesize;\n\n                track->codec_priv.size = 0;\n\n            } else {\n\n                if (codec_id == CODEC_ID_SIPR && flavor < 4) {\n\n                    const int sipr_bit_rate[4] = { 6504, 8496, 5000, 16000 };\n\n                    track->audio.sub_packet_size = ff_sipr_subpk_size[flavor];\n\n                    st->codec->bit_rate = sipr_bit_rate[flavor];\n\n                }\n\n                st->codec->block_align = track->audio.sub_packet_size;\n\n                extradata_offset = 78;\n\n            }\n\n        }\n\n        track->codec_priv.size -= extradata_offset;\n\n\n\n        if (codec_id == CODEC_ID_NONE)\n\n            av_log(matroska->ctx, AV_LOG_INFO,\n\n                   \"Unknown/unsupported CodecID %s.\\n\", track->codec_id);\n\n\n\n        if (track->time_scale < 0.01)\n\n            track->time_scale = 1.0;\n\n        avpriv_set_pts_info(st, 64, matroska->time_scale*track->time_scale, 1000*1000*1000); /* 64 bit pts in ns */\n\n\n\n        st->codec->codec_id = codec_id;\n\n        st->start_time = 0;\n\n        if (strcmp(track->language, \"und\"))\n\n            av_dict_set(&st->metadata, \"language\", track->language, 0);\n\n        av_dict_set(&st->metadata, \"title\", track->name, 0);\n\n\n\n        if (track->flag_default)\n\n            st->disposition |= AV_DISPOSITION_DEFAULT;\n\n        if (track->flag_forced)\n\n            st->disposition |= AV_DISPOSITION_FORCED;\n\n\n\n        if (!st->codec->extradata) {\n\n            if(extradata){\n\n                st->codec->extradata = extradata;\n\n                st->codec->extradata_size = extradata_size;\n\n            } else if(track->codec_priv.data && track->codec_priv.size > 0){\n\n                st->codec->extradata = av_mallocz(track->codec_priv.size +\n\n                                                  FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if(st->codec->extradata == NULL)\n\n                    return AVERROR(ENOMEM);\n\n                st->codec->extradata_size = track->codec_priv.size;\n\n                memcpy(st->codec->extradata,\n\n                       track->codec_priv.data + extradata_offset,\n\n                       track->codec_priv.size);\n\n            }\n\n        }\n\n\n\n        if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {\n\n            MatroskaTrackPlane *planes = track->operation.combine_planes.elem;\n\n\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            st->codec->codec_tag  = fourcc;\n\n            st->codec->width  = track->video.pixel_width;\n\n            st->codec->height = track->video.pixel_height;\n\n            av_reduce(&st->sample_aspect_ratio.num,\n\n                      &st->sample_aspect_ratio.den,\n\n                      st->codec->height * track->video.display_width,\n\n                      st->codec-> width * track->video.display_height,\n\n                      255);\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n            if (track->default_duration)\n\n                st->avg_frame_rate = av_d2q(1000000000.0/track->default_duration, INT_MAX);\n\n\n\n            /* export stereo mode flag as metadata tag */\n\n            if (track->video.stereo_mode && track->video.stereo_mode < MATROSKA_VIDEO_STEREO_MODE_COUNT)\n\n                av_dict_set(&st->metadata, \"stereo_mode\", matroska_video_stereo_mode[track->video.stereo_mode], 0);\n\n\n\n            /* if we have virtual track, mark the real tracks */\n\n            for (j=0; j < track->operation.combine_planes.nb_elem; j++) {\n\n                char buf[32];\n\n                if (planes[j].type >= MATROSKA_VIDEO_STEREO_PLANE_COUNT)\n\n                    continue;\n\n                snprintf(buf, sizeof(buf), \"%s_%d\",\n\n                         matroska_video_stereo_plane[planes[j].type], i);\n\n                for (k=0; k < matroska->tracks.nb_elem; k++)\n\n                    if (planes[j].uid == tracks[k].uid) {\n\n                        av_dict_set(&s->streams[k]->metadata,\n\n                                    \"stereo_mode\", buf, 0);\n\n                        break;\n\n                    }\n\n            }\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            st->codec->sample_rate = track->audio.out_samplerate;\n\n            st->codec->channels = track->audio.channels;\n\n            if (st->codec->codec_id != CODEC_ID_AAC)\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_SUBTITLE) {\n\n            st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;\n\n        }\n\n    }\n\n\n\n    attachements = attachements_list->elem;\n\n    for (j=0; j<attachements_list->nb_elem; j++) {\n\n        if (!(attachements[j].filename && attachements[j].mime &&\n\n              attachements[j].bin.data && attachements[j].bin.size > 0)) {\n\n            av_log(matroska->ctx, AV_LOG_ERROR, \"incomplete attachment\\n\");\n\n        } else {\n\n            AVStream *st = avformat_new_stream(s, NULL);\n\n            if (st == NULL)\n\n                break;\n\n            av_dict_set(&st->metadata, \"filename\",attachements[j].filename, 0);\n\n            av_dict_set(&st->metadata, \"mimetype\", attachements[j].mime, 0);\n\n            st->codec->codec_id = CODEC_ID_NONE;\n\n            st->codec->codec_type = AVMEDIA_TYPE_ATTACHMENT;\n\n            st->codec->extradata  = av_malloc(attachements[j].bin.size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if(st->codec->extradata == NULL)\n\n                break;\n\n            st->codec->extradata_size = attachements[j].bin.size;\n\n            memcpy(st->codec->extradata, attachements[j].bin.data, attachements[j].bin.size);\n\n\n\n            for (i=0; ff_mkv_mime_tags[i].id != CODEC_ID_NONE; i++) {\n\n                if (!strncmp(ff_mkv_mime_tags[i].str, attachements[j].mime,\n\n                             strlen(ff_mkv_mime_tags[i].str))) {\n\n                    st->codec->codec_id = ff_mkv_mime_tags[i].id;\n\n                    break;\n\n                }\n\n            }\n\n            attachements[j].stream = st;\n\n        }\n\n    }\n\n\n\n    chapters = chapters_list->elem;\n\n    for (i=0; i<chapters_list->nb_elem; i++)\n\n        if (chapters[i].start != AV_NOPTS_VALUE && chapters[i].uid\n\n            && (max_start==0 || chapters[i].start > max_start)) {\n\n            chapters[i].chapter =\n\n            avpriv_new_chapter(s, chapters[i].uid, (AVRational){1, 1000000000},\n\n                           chapters[i].start, chapters[i].end,\n\n                           chapters[i].title);\n\n            av_dict_set(&chapters[i].chapter->metadata,\n\n                             \"title\", chapters[i].title, 0);\n\n            max_start = chapters[i].start;\n\n        }\n\n\n\n    matroska_add_index_entries(matroska);\n\n\n\n    matroska_convert_tags(s);\n\n\n\n    return 0;\n\n}\n", "idx": 25854, "substitutes": {"s": ["sys", "as", "sb", "ins", "fs", "sports", "rs", "c", "ses", "ds", "scl", "hs", "g", "spec", "n", "p", "sc", "cs", "sts", "set", "aws", "ctx", "S", "session", "js", "bs", "ss", "a", "ats", "ts", "ns", "ps", "stats", "z", "es", "gs", "e", "sv", "sp", "sg", "self", "h", "t", "m", "v", "sq", "socket"], "matroska": ["umatroskas", "matricsKA", "matroker", "Matroaka", "matrysker", " matrokas", "mitrosko", "Matroka", " matroko", "matrorsKA", "umatrosker", "matrosla", "mitrisko", "matrusko", "matrokas", "matrosko", "matrusKA", "matrorska", "matriskas", "matrisaka", "matroka", "matstrosker", "Matroski", "masstrosla", "mitroka", " matrosker", "matroha", "matrsha", "metstroska", "matrsaka", "matrosker", " matrosjava", "matriskaya", "matroKA", "matrasko", " matrosaka", "metroskaya", "matrusha", " matrosko", "matstrosaka", "matcoska", "matruskas", "mitroaka", " matryska", "matrsko", "matrosKA", " matroha", "mitrosha", "umatrosko", "matronesla", "matruskaya", "umatruska", "matrosha", "matstrosla", "matriska", "masrosKA", "mitrisha", "matrojava", "matstroskaya", "matrysaka", "mitriskaya", "matrusaka", "metrosaka", " matrysjava", "matrska", "matstrosKA", "matcosha", "matrasker", "matrorsker", "matroskaya", "Matroska", "matroaka", "metroskas", "umatroska", "matruska", "matronesKA", "matricsla", "mitroskaya", " matrosha", "matraska", " matrysker", "umatrusker", "metstrosaka", "masstroska", "Matrosaka", "matraskas", "mitroska", "MatroKA", "matrokaya", "umatrusko", "matcoskaya", "matrisha", "matroki", "matronesker", "matricska", "metroska", "mitrokas", "matroski", "MatrosKA", "matrisko", "Matroki", "matroneska", "matryska", "mitroker", "mitrosker", "matrorski", "matrorsaka", "matruski", "matcosko", "matrskas", "matrosaka", "mitroskas", "metstroskas", "masstrosker", "umatruskas", "matrosjava", "mitrosaka", "matstroskas", "masrosla", "masroska", "matstroska", "masrosker", "mitriska", "matrusker", "matrysjava", "matrsker", "matricsker", " matroka", "matrorsjava", "masstrosKA", "matroskas", " matroskas", "matroko", " matrysaka", "metstroskaya"], "attachements_list": ["attachement_set", "attachements_set", "attachement_list", "attachements_LIST", "attachement_type", "attachement_LIST", "attachements_type"], "attachements": ["attachment", "attachesments", "accacheMENTS", "attacheMENTS", "accachment", "accachMENTS", "attattachMENTS", "accachements", "attattachments", "attattachts", "attachement", "attachesment", "attachets", "accachments", "accachts", "attattachment", "accachement", "attachMENTS", "attachesMENTS", "attachts", "attachments", "attachests", "accachets"], "chapters_list": ["chapters2LIST", "chapters_st", "chapters2list", "chapter_LIST", "chapter_st", "chapters_LIST", "chapter_list", "chapters_List", "chapters2st", "chapter_List", "chapters2List"], "chapters": ["cleapters", "churches", "clears", "cars", "chards", "cleaps", "hurches", "achars", "charms", "caps", " churches", "echars", "cards", "achapters", "chars", "capters", "harms", "cleards", " chars", "achurches", "echards", "echaps", " charms", "acharms", "hapters", "chaps", "echapters", "hars"], "tracks": ["staff", "uploads", "shots", "items", "utters", "reads", "forms", "lists", "dds", "hops", "tags", "maps", "aunts", "thumbnails", "charges", "ks", "pages", "pps", "ids", "shows", "rows", "bands", "acks", "heads", "orders", "events", "reports"], "pos": ["client", "trans", "o", "pose", " position", "po", "len", "Pos", "os", "pc", "def", "pi", "index", "pr", "params", "seq", "top", "spec", "p", "POS", "pid", "pointer", "start", "ps", "port", "base", "Position", "position", "limit", "pro", "meta", "pres", "slot", "offset", "P", "tmp", "no", "proc", "point", "pt"], "st": ["sn", "ost", "rest", "se", "std", "ste", "tt", "sl", "St", "sc", "sh", "sts", "sw", "ust", "ast", "ss", "so", "ct", "ST", "src", "stable", "bt", "sp", "sv", "est", "ist", "tmp", "str"], "i": ["f", "it", "ic", "x", "ui", "multi", "o", "\u0438", "ami", "pi", "c", " ii", "ini", "g", "in", "me", "gi", "I", "p", " bi", "di", "zi", "go", "sim", "ai", "mi", "li", "ii", "depth", "hi", "a", "is", "ti", "ind", "bi", "ims", "y", "key", "ci", "z", "e", "xi", "si", "t", "im", "h", "index", "v", "cli", "m", "qi", "ei", "ix"], "j": ["ji", "x", "o", "jump", "v", "uj", "index", "g", "n", "p", "kj", "J", "js", "jc", "l", "bi", "ij", "bj", "z", "jp", "q", "m", "jj", "jl", "aj"], "k": ["ku", "kk", "ki", "ok", "ik", "kn", "km", "ka", "ko", "ke", "tk", "ck", "ks", "ket", "kh", "kr", "K", "kj", "sk", "ak", "kid", "key", "kw", "q", "m", "v", "ek"], "res": ["ms", "tx", "rest", "err", "reset", "ref", "ins", "re", "os", "rs", "us", "rc", "result", "RES", "new", "resp", "rel", "vol", "js", "ss", "req", "ps", "R", "vals", "Res", "pres", "resolution", "ress"]}}
{"project": "FFmpeg", "commit_id": "feb13aed794a7f1a1f8395159e9b077351348a34", "target": 1, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *picref)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    SignatureContext *sic = ctx->priv;\n\n    StreamContext *sc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);\n\n    FineSignature* fs;\n\n\n\n    static const uint8_t pot3[5] = { 3*3*3*3, 3*3*3, 3*3, 3, 1 };\n\n    /* indexes of words : 210,217,219,274,334  44,175,233,270,273  57,70,103,237,269  100,285,295,337,354  101,102,111,275,296\n\n    s2usw = sorted to unsorted wordvec: 44 is at index 5, 57 at index 10...\n\n    */\n\n    static const unsigned int wordvec[25] = {44,57,70,100,101,102,103,111,175,210,217,219,233,237,269,270,273,274,275,285,295,296,334,337,354};\n\n    static const uint8_t      s2usw[25]   = { 5,10,11, 15, 20, 21, 12, 22,  6,  0,  1,  2,  7, 13, 14,  8,  9,  3, 23, 16, 17, 24,  4, 18, 19};\n\n\n\n    uint8_t wordt2b[5] = { 0, 0, 0, 0, 0 }; /* word ternary to binary */\n\n    uint64_t intpic[32][32];\n\n    uint64_t rowcount;\n\n    uint8_t *p = picref->data[0];\n\n    int inti, intj;\n\n    int *intjlut;\n\n\n\n    uint64_t conflist[DIFFELEM_SIZE];\n\n    int f = 0, g = 0, w = 0;\n\n    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b;\n\n    int64_t denom;\n\n    int i, j, k, ternary;\n\n    uint64_t blocksum;\n\n    int blocksize;\n\n    int64_t th; /* threshold */\n\n    int64_t sum;\n\n\n\n    int64_t precfactor = (sc->divide) ? 65536 : BLOCK_LCM;\n\n\n\n    /* initialize fs */\n\n    if (sc->curfinesig) {\n\n        fs = av_mallocz(sizeof(FineSignature));\n\n        if (!fs)\n\n            return AVERROR(ENOMEM);\n\n        sc->curfinesig->next = fs;\n\n        fs->prev = sc->curfinesig;\n\n        sc->curfinesig = fs;\n\n    } else {\n\n        fs = sc->curfinesig = sc->finesiglist;\n\n        sc->curcoarsesig1->first = fs;\n\n    }\n\n\n\n    fs->pts = picref->pts;\n\n    fs->index = sc->lastindex++;\n\n\n\n    memset(intpic, 0, sizeof(uint64_t)*32*32);\n\n    intjlut = av_malloc_array(inlink->w, sizeof(int));\n\n    if (!intjlut)\n\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < inlink->w; i++) {\n\n        intjlut[i] = (i*32)/inlink->w;\n\n    }\n\n\n\n    for (i = 0; i < inlink->h; i++) {\n\n        inti = (i*32)/inlink->h;\n\n        for (j = 0; j < inlink->w; j++) {\n\n            intj = intjlut[j];\n\n            intpic[inti][intj] += p[j];\n\n        }\n\n        p += picref->linesize[0];\n\n    }\n\n    av_freep(&intjlut);\n\n\n\n    /* The following calculates a summed area table (intpic) and brings the numbers\n\n     * in intpic to the same denominator.\n\n     * So you only have to handle the numinator in the following sections.\n\n     */\n\n    dh1 = inlink->h / 32;\n\n    if (inlink->h % 32)\n\n        dh2 = dh1 + 1;\n\n    dw1 = inlink->w / 32;\n\n    if (inlink->w % 32)\n\n        dw2 = dw1 + 1;\n\n    denom = (sc->divide) ? dh1 * dh2 * dw1 * dw2 : 1;\n\n\n\n    for (i = 0; i < 32; i++) {\n\n        rowcount = 0;\n\n        a = 1;\n\n        if (dh2 > 1) {\n\n            a = ((inlink->h*(i+1))%32 == 0) ? (inlink->h*(i+1))/32 - 1 : (inlink->h*(i+1))/32;\n\n            a -= ((inlink->h*i)%32 == 0) ? (inlink->h*i)/32 - 1 : (inlink->h*i)/32;\n\n            a = (a == dh1)? dh2 : dh1;\n\n        }\n\n        for (j = 0; j < 32; j++) {\n\n            b = 1;\n\n            if (dw2 > 1) {\n\n                b = ((inlink->w*(j+1))%32 == 0) ? (inlink->w*(j+1))/32 - 1 : (inlink->w*(j+1))/32;\n\n                b -= ((inlink->w*j)%32 == 0) ? (inlink->w*j)/32 - 1 : (inlink->w*j)/32;\n\n                b = (b == dw1)? dw2 : dw1;\n\n            }\n\n            rowcount += intpic[i][j] * a * b * precfactor / denom;\n\n            if (i > 0) {\n\n                intpic[i][j] = intpic[i-1][j] + rowcount;\n\n            } else {\n\n                intpic[i][j] = rowcount;\n\n            }\n\n        }\n\n    }\n\n\n\n    denom = (sc->divide) ? 1 : dh1 * dh2 * dw1 * dw2;\n\n\n\n    for (i = 0; i < ELEMENT_COUNT; i++) {\n\n        const ElemCat* elemcat = elements[i];\n\n        int64_t* elemsignature;\n\n        uint64_t* sortsignature;\n\n\n\n        elemsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));\n\n        if (!elemsignature)\n\n            return AVERROR(ENOMEM);\n\n        sortsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));\n\n        if (!sortsignature)\n\n            return AVERROR(ENOMEM);\n\n\n\n        for (j = 0; j < elemcat->elem_count; j++) {\n\n            blocksum = 0;\n\n            blocksize = 0;\n\n            for (k = 0; k < elemcat->left_count; k++) {\n\n                blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);\n\n                blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);\n\n            }\n\n            sum = blocksum / blocksize;\n\n            if (elemcat->av_elem) {\n\n                sum -= 128 * precfactor * denom;\n\n            } else {\n\n                blocksum = 0;\n\n                blocksize = 0;\n\n                for (; k < elemcat->block_count; k++) {\n\n                    blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);\n\n                    blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);\n\n                }\n\n                sum -= blocksum / blocksize;\n\n                conflist[g++] = FFABS(sum * 8 / (precfactor * denom));\n\n            }\n\n\n\n            elemsignature[j] = sum;\n\n            sortsignature[j] = FFABS(sum);\n\n        }\n\n\n\n        /* get threshold */\n\n        qsort(sortsignature, elemcat->elem_count, sizeof(uint64_t), (void*) cmp);\n\n        th = sortsignature[(int) (elemcat->elem_count*0.333)];\n\n\n\n        /* ternarize */\n\n        for (j = 0; j < elemcat->elem_count; j++) {\n\n            if (elemsignature[j] < -th) {\n\n                ternary = 0;\n\n            } else if (elemsignature[j] <= th) {\n\n                ternary = 1;\n\n            } else {\n\n                ternary = 2;\n\n            }\n\n            fs->framesig[f/5] += ternary * pot3[f%5];\n\n\n\n            if (f == wordvec[w]) {\n\n                fs->words[s2usw[w]/5] += ternary * pot3[wordt2b[s2usw[w]/5]++];\n\n                if (w < 24)\n\n                    w++;\n\n            }\n\n            f++;\n\n        }\n\n        av_freep(&elemsignature);\n\n        av_freep(&sortsignature);\n\n    }\n\n\n\n    /* confidence */\n\n    qsort(conflist, DIFFELEM_SIZE, sizeof(uint64_t), (void*) cmp);\n\n    fs->confidence = FFMIN(conflist[DIFFELEM_SIZE/2], 255);\n\n\n\n    /* coarsesignature */\n\n    if (sc->coarsecount == 0) {\n\n        if (sc->curcoarsesig2) {\n\n            sc->curcoarsesig1 = av_mallocz(sizeof(CoarseSignature));\n\n            if (!sc->curcoarsesig1)\n\n                return AVERROR(ENOMEM);\n\n            sc->curcoarsesig1->first = fs;\n\n            sc->curcoarsesig2->next = sc->curcoarsesig1;\n\n            sc->coarseend = sc->curcoarsesig1;\n\n        }\n\n    }\n\n    if (sc->coarsecount == 45) {\n\n        sc->midcoarse = 1;\n\n        sc->curcoarsesig2 = av_mallocz(sizeof(CoarseSignature));\n\n        if (!sc->curcoarsesig2)\n\n            return AVERROR(ENOMEM);\n\n        sc->curcoarsesig2->first = fs;\n\n        sc->curcoarsesig1->next = sc->curcoarsesig2;\n\n        sc->coarseend = sc->curcoarsesig2;\n\n    }\n\n    for (i = 0; i < 5; i++) {\n\n        set_bit(sc->curcoarsesig1->data[i], fs->words[i]);\n\n    }\n\n    /* assuming the actual frame is the last */\n\n    sc->curcoarsesig1->last = fs;\n\n    if (sc->midcoarse) {\n\n        for (i = 0; i < 5; i++) {\n\n            set_bit(sc->curcoarsesig2->data[i], fs->words[i]);\n\n        }\n\n        sc->curcoarsesig2->last = fs;\n\n    }\n\n\n\n    sc->coarsecount = (sc->coarsecount+1)%90;\n\n\n\n    /* debug printing finesignature */\n\n    if (av_log_get_level() == AV_LOG_DEBUG) {\n\n        av_log(ctx, AV_LOG_DEBUG, \"input %d, confidence: %d\\n\", FF_INLINK_IDX(inlink), fs->confidence);\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"words:\");\n\n        for (i = 0; i < 5; i++) {\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d:\", fs->words[i] );\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d\", fs->words[i] / pot3[0] );\n\n            for (j = 1; j < 5; j++)\n\n                av_log(ctx, AV_LOG_DEBUG, \",%d\", fs->words[i] % pot3[j-1] / pot3[j] );\n\n            av_log(ctx, AV_LOG_DEBUG, \";\");\n\n        }\n\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"framesignature:\");\n\n        for (i = 0; i < SIGELEM_SIZE/5; i++) {\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d\", fs->framesig[i] / pot3[0] );\n\n            for (j = 1; j < 5; j++)\n\n                av_log(ctx, AV_LOG_DEBUG, \",%d\", fs->framesig[i] % pot3[j-1] / pot3[j] );\n\n        }\n\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n\n    }\n\n\n\n    if (FF_INLINK_IDX(inlink) == 0)\n\n        return ff_filter_frame(inlink->dst->outputs[0], picref);\n\n    return 1;\n\n}\n", "idx": 25859, "substitutes": {"inlink": ["inink", "Inlock", " inink", "innlink", "cinframe", "INlock", "inLink", "outLink", "INscan", " inframe", "Inink", "outlock", "Inlink", "innscan", " inlock", "inscan", "Inframe", "cinline", "cinlock", "outink", "INlink", "innlock", "innline", "InLink", "outlink", "cinlink", "inlock", "Inline", " inscan", "inframe", "INline", " inLink"], "picref": ["picRef", "icref", " picreference", "icRef", "picReference", "sciReference", " picdef", "sciRef", "Picreference", "PicReference", "PicRef", "picdef", " picRef", "picreference", "icdef", "sciref", "icreference", "scireference", "Picdef", " picReference", "Picref"], "ctx": ["sys", "cl", "ic", "context", "cmp", "tx", "cf", "cu", "jac", "ref", "ca", "conn", "sq", "bc", "std", "tc", "icc", "dc", "ctrl", "kh", "nc", "cm", "sec", "voc", "ct", "xc", "sci", "unc", "loc", "ci", "mc", "gc", "pkg", "jp", "cc", "lc", "init", "conf"], "sic": ["aic", "tic", "ic", "cens", "ih", "Si", "sis", "sit", "aci", "usc", "sat", "sil", "tc", "icc", "Sac", "pac", "crit", "mic", "tis", "cus", "itis", "sac", "webkit", "isc", "sie", "sec", "ksh", "ics", "sci", "cci", "ritz", "SI", "ci", "sing", "si"], "sc": ["sys", "cl", "ic", "uc", "ch", "esc", "ca", "bc", "pc", "lc", "usc", "c", "rc", "tc", "asc", "icc", "dc", "scl", "ec", "sync", "ctrl", "sch", "Sc", "nc", "cs", "arc", "sac", "cm", "sw", "isc", "osc", "sec", "ss", "sci", "desc", "ac", "anc", "unc", "cr", "ci", "mc", "sp", "scope", "gc", "SC", "cc", "sq", "cv", "psc"], "fs": ["sys", "flows", "fb", "rys", "ms", "irs", "cf", "FS", "Fs", "fw", "uf", "gets", "pc", "rs", "us", "fr", "bf", "ds", "hs", "aos", "fi", "fn", "fps", "cells", "cs", "faces", "vs", "ils", "ours", "bs", "ics", "js", "ss", "xf", "ats", "wcs", "ts", "ns", "ps", "ims", "acs", "rss", "qs", "files", "fd", "fts", "fc", "gs", "sf", "obs", "fp", "ls", "ows"], "pot3": ["pos03", "pot5", "op03", "sky3", "pos3", "op5", "pos5", "sky0", "op3", "sky5", "op0", "pot0", "pot03", "sky03", "pos0"], "wordvec": ["wordsvec", "wordcap", "wordsbuf", "wordv", "bytebuf", "charv", "wordscap", "wordsv", "bytecap", "charvec", "charbuf", "wordbuf", "charcap", "bytev", "bytevec"], "s2usw": ["s2ux", "s2uy", "s2uws", "s2uw", "s2psws", "s2sws", "s2sy", "s0usx", "s2usy", "s2usws", "s2usx", "s2psy", "s2sx", "s2psw", "s0psws", "s0usws", "s2psx", "s0psy", "s0usw", "s0psw", "s2sw", "s0psx", "s0usy"], "wordt2b": ["worde2b", "wordt5be", "wordt_bb", "worde1b", "worde2bb", "wordt_a", "worde1be", "wordt5b", "wordt2a", "wordt_be", "worde2a", "wordt2bb", "wordt1a", "worde1bb", "worde2be", "wordt1bb", "wordt2be", "wordt1be", "wordt5a", "wordt_b", "worde1a", "wordt1b", "wordt5bb"], "intpic": ["structpic", "structfc", "intfc", "structarr", "intspic", "structPic", " intfc", "intsarr", "intsPic", "intarr", "intPic", "intsfc", " intarr", " intPic"], "rowcount": ["rowsum", "runsum", "rowscount", "rollcount", "rollCount", "rollsum", "rowssum", "runCount", "rowlength", "runcount", "rolllength", "rowslength", "rowCount", "runlength", "rowsCount"], "p": ["pb", "o", "op", "pc", "d", "c", "pi", "pp", "pr", "g", "n", "cp", "rep", "ip", "pa", "u", "fp", "P", "h", "t", "jp", "m", "v", "pic"], "inti": ["interj", "indj", "intersi", " intsi", "intsi", "interi", "indi", "indsi"], "intj": ["interj", "intn", " intb", "in", "ib", "intern", "intb", " intn", "interb", "ij"], "intjlut": ["intknuts", "intjlute", " intgloud", " intjloud", "intknoud", " intjluts", "intgloud", "intknut", "intjluts", " intglut", "intglut", " intgluts", "intglute", "intlut", "intloud", "intlute", "intluts", " intjlute", "intgluts", "intjloud", "intknute", " intglute"], "conflist": ["coclost", "conclost", "coclist", "conselite", "coflist", "conflite", "coflabel", "conselabel", "conselost", "conclist", "conselist", "conflabel", "conmlite", "conflost", "conmlost", "conclite", "coflite", "coclabel", "conmlabel", "conmlist", "coclite", "coflost", "conclabel"], "a": ["as", "sa", "x", "o", "ca", "c", "at", "A", "r", "aa", "ar", "va", "an", "area", "ap", "au", "am", "ak", "ac", "ba", "alpha", "e", "ab", "m", "v", "ae"], "b": ["bb", "fb", "bc", "d", "c", "bf", "B", "g", "r", "db", "n", "cb", "bs", "eb", "l", "bi", "y", "ba", "e", "rb", "ab", "be", "m", "v"], "denom": ["enoms", "genoms", "genoc", "enom", "gnomin", "denoc", "genom", "denoms", "enoc", "genomin", "gnoms", "gnom", "denomin", "gnoc", "enomin"], "i": ["ic", "x", "o", "pi", "c", "g", "in", "r", "I", "n", "mi", "li", "ii", "l", "y", "ci", "u", "xi", "h", "t", "m", "v", "ix"], "j": ["ji", "je", "o", "ja", "jump", "br", "v", "dj", "g", "r", "n", "kj", "J", "jc", "l", "ij", "y", "z", "jp", "q", "t", "m", "jj", "aj"], "k": ["ku", "kk", "o", "ik", "ka", "km", "ko", "tk", "c", "ck", "mk", "n", "kh", "kr", "K", "kj", "ak", "y", "key", "kw", "kind", "u", "max", "q", "m", "v", "ek"], "ternary": ["tonaries", "ternaries", "ternal", "internary", "internical", "ineraries", "tonal", "tonary", "tonical", "ternical", "internaries", "inerical", "inerary", "ineral"], "blocksum": ["bsums", "ksum", "offsum", "offsumer", "blocksumm", "bsum", "bsumer", "offsums", "bsumm", "ksums", "ksumer", "offsumm", "blocksums", "ksumm", "blocksumer"], "blocksize": ["namesization", "kspace", "rowsization", "rowspace", "ksize", "blocksization", "kside", "ksization", "blockside", "rowsize", "namesize", "namespace", "nameside", "blockspace", "rowside"], "th": ["oth", "ths", "ch", "third", "foot", "TH", "bl", "each", "std", "hr", "ctr", "chron", "kh", "thread", "sh", "ht", "sec", "td", "eth", "ct", "bh", "st", "kw", "half", "head", "tr", "h", "proc", "thin"], "sum": ["dim", "pack", "cal", "hash", "ma", "mult", "sam", "Sum", "mem", "um", "prof", "gram", "count", "cum", "add", "vol", "asm", "sim", "mod", "sym", "total", "size", "scale", "fac", "mean", "bin", "num", "head"], "w": ["W", "x", "fw", "d", "wh", "wd", "g", "wl", "r", "n", "sw", "nw", "wa", "wb", "y", "wp", "wt", "z", "rw", "u", "h", "q", "t", "m", "v"], "f": ["x", "ef", "cf", "o", "ff", "fa", "d", "c", "fi", "g", "r", "n", "l", "z", "fc", "e", "u", "h", "t", "m", "v", "F"]}}
{"project": "qemu", "commit_id": "248de4a89915001e64176580d620d22b612e06f2", "target": 1, "func": "static void test_dma_fragmented(void)\n\n{\n\n    AHCIQState *ahci;\n\n    AHCICommand *cmd;\n\n    uint8_t px;\n\n    size_t bufsize = 4096;\n\n    unsigned char *tx = g_malloc(bufsize);\n\n    unsigned char *rx = g_malloc0(bufsize);\n\n    uint64_t ptr;\n\n\n\n    ahci = ahci_boot_and_enable(NULL);\n\n    px = ahci_port_select(ahci);\n\n    ahci_port_clear(ahci, px);\n\n\n\n    /* create pattern */\n\n    generate_pattern(tx, bufsize, AHCI_SECTOR_SIZE);\n\n\n\n    /* Create a DMA buffer in guest memory, and write our pattern to it. */\n\n    ptr = guest_alloc(ahci->parent->alloc, bufsize);\n\n    g_assert(ptr);\n\n    bufwrite(ptr, tx, bufsize);\n\n\n\n    cmd = ahci_command_create(CMD_WRITE_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    cmd = ahci_command_create(CMD_READ_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    /* Read back the guest's receive buffer into local memory */\n\n    bufread(ptr, rx, bufsize);\n\n    guest_free(ahci->parent->alloc, ptr);\n\n\n\n    g_assert_cmphex(memcmp(tx, rx, bufsize), ==, 0);\n\n\n\n    ahci_shutdown(ahci);\n\n\n\n    g_free(rx);\n\n    g_free(tx);\n\n}\n", "idx": 25862, "substitutes": {"ahci": ["achcci", "ohcin", "hcu", "akhcci", "ohco", " ahdi", "ehpi", "hcin", "ahcos", "ohcu", "ehcin", "thermi", "ahcil", "hci", "acheini", "akhcin", "hdi", "ahanic", "ahcu", "ohcil", "akhci", "ehco", "hnic", "aphdi", "ahcit", "therci", "achcit", "ehcil", "aphpi", " ahcu", "hfi", "ashcli", "ohcos", "ashcu", "ashnic", " ahcin", "ashmi", "achecu", " ahcli", "achecci", "ahpi", "aphci", " ahcil", " ahmi", "ohpi", "hini", "achci", "achecin", "ahcci", "amci", "hacit", "achecit", "haco", "hcci", "ashci", "ahacu", "yahnic", "aphcu", "amco", " ahcit", "achcu", "ohfi", "yahci", "ehdi", "achcin", "hcos", "ahcin", "amcci", "achdi", "ehcci", "ayci", "haci", "achecos", "ayfi", "aycci", "ashpi", "ahini", " ahcci", "achenic", "ahcli", "aycin", "akhcit", "thercin", "ahnic", "yahcu", "ehci", " ahpi", "amcit", "ashco", "ohcit", " ahco", "yahcil", "aydi", "ahco", "hacci", "ashcit", "ahdi", "achecil", "ashcin", "ohcci", "thercli", "ashini", "ahfi", "ahacil", "achpi", "ahaci", "ashcil", "acheci", "ehcit", "ahmi", "ashcci", "ohci"], "cmd": ["cmp", "fw", "norm", "comm", "std", "vp", "qt", "ctr", "cont", "command", "mg", "ctl", "mson", "call", "ctx", "quick", "ct", "draw", "exec", "mt", "pkg", "pt", "cf", "obj", "dq", "canon", "conn", "phy", "mk", "ctrl", "func", "cat", "good", "det", "cp", "send", "tab", "qq", "msg", "buf", "inv", "ind", "vc", "fun", "Cmd", "handle", "method", "help", "job", "batch", "col", "op", "normal", "def", "cd", "kt", "core", "wd", "ck", "act", "bind", "form", "cod", "process", "cfg", "cr", "cc", "control", "rpm", "grad", "opt", "prop", "quit", "wo", "md", "ext", "cn", "cb", "js", "kick", "comp", "req", "nt", "om", "wp", "txt", "cli", "init"], "px": ["fx", "padding", "ping", "ms", "x", "tm", " pos", "xy", "pc", "pad", "ex", "yx", "pi", "pr", "mx", "dx", "act", "pixel", "cp", "p", "pps", "pointer", "prefix", "ax", "yp", "ctx", "xx", "pos", "pex", "xs", "xf", "xc", "ts", "ps", "port", "ip", "png", "addr", "sp", "bp", "tp", "xp", "lex", "tmp", "wx", "pt", "pic", "ix"], "tx": ["fx", "TX", "Tx", "context", "x", "tm", "trans", "ref", "ix", "op", "xml", "def", "xt", "ex", "tc", "word", "ty", "mem", "pr", " TX", "dx", "mx", "act", "p", "prefix", "ax", "msg", "buf", "ctx", "ta", " ty", "xs", "rt", "xf", "ts", "nt", "addr", "txt", "ox", "text", "str", "mt", "tr", "lex", "t", "tmp", "index", "wx", "hea", "pt", "res"], "rx": ["rys", "fx", "TX", "x", "rew", "ux", "xy", "rm", "rl", "rip", "re", "rs", "rd", "xt", "ex", "rc", "ry", "ty", "rr", "pr", "dx", "ri", "mx", "act", "r", "rax", "rex", "ax", "vr", "ctx", "xx", "xs", "rt", "xf", "rez", "xc", "expr", "ox", "txt", "addr", "rw", "rb", "xp", "lex", "xff", "wx", "hea", "res"], "ptr": ["eps", "ctr", "grow", "dev", "inst", "p", "pointer", "yp", "proc", "ctx", "rep", "pl", "rt", "loc", "checked", "v", "pt", "fx", "inter", "br", "try", "pc", "fr", "ty", "pr", "cp", "tip", "vr", "eth", "ind", "ts", "handle", "offset", "vt", "ped", "pointers", "hw", "ix", "ping", "TX", "x", "trans", "Ptr", "pad", "ry", "act", "rect", "esp", "resh", "inters", "prime", "ps", "dr", "addr", "tp", "xp", "tr", "tmp", "err", "ref", "xt", "push", "md", "rel", "resp", "nz", "js", "req", "txt", "sp", "t", "jp", "index"]}}
{"project": "qemu", "commit_id": "ba737541edddf9d0026460eb7b1d1c599b4c8ae9", "target": 1, "func": "static uint32_t pcihotplug_read(void *opaque, uint32_t addr)\n\n{\n\n    uint32_t val = 0;\n\n    struct pci_status *g = opaque;\n\n    switch (addr) {\n\n        case PCI_BASE:\n\n            val = g->up;\n\n            break;\n\n        case PCI_BASE + 4:\n\n            val = g->down;\n\n            break;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    PIIX4_DPRINTF(\"pcihotplug read %x == %x\\n\", addr, val);\n\n    return val;\n\n}\n", "idx": 25865, "substitutes": {"opaque": ["OPaque", "OPatile", "oaque", "oposter", "osposter", "ospeno", "openo", "paque", "opque", "opacity", "ospaque", "Opaque", "peno", "pacity", "Oplay", "oacity", "opatile", "ooster", "OPlay", "ospacity", "OPque", "oplay", "oeno", " opatile", " opque", " oplay", "poster", "Opatile", "Opque"], "addr": ["help", "block", "x", "ad", "cmp", "alt", "tx", "obj", "err", "adr", "address", "arp", "hash", "ref", "ix", "host", "pad", "rs", "id", "nl", "rev", "mem", "act", "r", "cmd", "ext", "ack", "alias", "arr", "state", "prefix", "add", "msg", "rel", "ord", "coord", "pos", " address", "tag", "align", "attr", "dr", "src", "loc", "url", "Address", "handle", "hl", "mt", "ptr", "offset", "str", "name", "hw"], "g": ["game", "gen", "gas", "ger", "d", "gt", "c", " G", "og", "mg", "gu", "ga", "gi", "arg", "ge", "pg", "gr", "msg", "gg", "j", "ig", "gp", "go", "eg", "greg", "bg", "gd", "fg", "cfg", "gm", "tg", "ag", "gb", "gs", "gl", "sg", "gc", "h", "q", "G", "m", "v"]}}
{"project": "FFmpeg", "commit_id": "ca402f32e392590a81a1381dab41c4f9c2c2f98a", "target": 1, "func": "static int w64_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    int64_t size;\n\n    AVIOContext *pb  = s->pb;\n\n    WAVContext    *wav = s->priv_data;\n\n    AVStream *st;\n\n    uint8_t guid[16];\n\n\n\n    avio_read(pb, guid, 16);\n\n    if (memcmp(guid, guid_riff, 16))\n\n        return -1;\n\n\n\n    if (avio_rl64(pb) < 16 + 8 + 16 + 8 + 16 + 8) /* riff + wave + fmt + sizes */\n\n        return -1;\n\n\n\n    avio_read(pb, guid, 16);\n\n    if (memcmp(guid, guid_wave, 16)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find wave guid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    size = find_guid(pb, guid_fmt);\n\n    if (size < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find fmt guid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    /* subtract chunk header size - normal wav file doesn't count it */\n\n    ff_get_wav_header(pb, st->codec, size - 24);\n\n    avio_skip(pb, FFALIGN(size, INT64_C(8)) - size);\n\n\n\n    st->need_parsing = AVSTREAM_PARSE_FULL;\n\n\n\n    av_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n\n\n    size = find_guid(pb, guid_data);\n\n    if (size < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find data guid\\n\");\n\n        return -1;\n\n    }\n\n    wav->data_end = avio_tell(pb) + size - 24;\n\n    wav->w64      = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 25868, "substitutes": {"s": ["f", "sys", "ssl", "ms", "i", "sa", "sb", "out", "ins", "os", "comm", "fs", "pc", "v", "rs", "w", "c", "ses", "ds", "g", "n", "p", "sc", "cs", "sts", "aws", "j", "ctx", "vs", "S", "js", "bs", "ss", "a", "is", "ats", "b", "ns", "ts", "ps", "l", "sm", "aus", "ims", "stats", "qs", "z", "south", "es", "its", "gs", "sp", "sv", "sg", "h", "ls", "t", "m", "sq", "summary", "conf"], "ap": ["ep", "ad", "al", "ape", " af", "op", "mp", "att", "pp", " p", "pac", "ar", " sp", "amp", "np", " pars", "ac", "ps", "ip", "pa", "aps", "sp", "bp", " sam", "cap", " mp", "rap", "tap"], "size": ["see", "address", "c", "storage", "grow", "mem", "buffer", "gz", "count", "any", "scale", "z", "dimension", "gc", "max", "sample", "v", "sn", "dim", "space", "args", "zone", "code", "height", "n", "send", "ize", "shape", "data", "window", "global", "offset", "format", "type", "length", "body", "member", "now", "sent", "gravity", "sw", "area", "form", "capacity", "l", "time", "number", "sum", "news", "len", "fee", "zero", "g", "empty", "ze", "cache", "small", "sh", "set", "to", "span", "message", "align", "SIZE", "position", "num", "export", "sp", "e", "Size", "name"], "pb": ["patch", "vp", "pp", "buffer", "p", "soc", "pg", "pid", "ctx", "pl", "tg", "wb", "pa", "prot", "snap", "px", "mt", "pkg", "pt", "sb", "tx", "obj", "pc", "at", "pr", "db", "cp", "ob", "msg", "buf", "ts", "py", "bp", "fp", "ib", "sys", "peer", "mb", "mp", "stab", "jpg", "PB", "cod", "td", "bs", "b", "ps", "tp", "rb", "xp", "lp", "rpm", "cv", "pm", "client", "pan", "uf", "tk", "resp", "cb", "span", "np", "bj", "wp", "txt", "bh", "pro", "sp", "pod", "jp", "proc", "conv", "lb"], "wav": ["AV", "ait", "aft", "mpeg", "tx", "news", "cam", "web", "conv", "voice", "uf", "ff", "mp", "v", "waves", "w", "aw", "mus", "ech", "audio", "pac", "mem", "ww", "wl", "arr", "asm", "ra", "mson", "buf", "sw", "craft", "au", " av", "av", "raw", "acc", "wa", "aver", "auc", "aus", "wp", "txt", "wi", "aux", "rw", "fp", "uv", "wave", "cv", "mu", "hw"], "st": ["sn", "ost", "sb", "stream", "rest", "obj", "nd", "sta", "sty", "se", "std", "fr", "ste", "tt", "irst", "sl", "St", "inst", "p", "sc", "new", "sh", "sts", "ut", "sw", "ust", "ctx", "ast", "td", "stan", "th", "art", "so", "rt", "stop", "ct", "ts", "nt", "start", "ST", "src", "stable", "z", "step", "sp", "mt", "sv", "est", "ist", "ptr", "t", "tmp", "stat", "v", "str", "pt"], "guid": ["Guoid", "uuaid", "Guaid", "GUide", "euiden", "euido", "uuide", "Guiden", "euid", "giide", "gnido", "camid", "Guids", "juard", "giiden", "uuids", "juid", "gruide", "GUid", "guoid", "juids", "Guard", "uuid", "guID", "gruid", "gnid", "gniden", "gruID", "camids", "guiden", "gnide", "ggid", "ggard", "guard", "camaid", "ggids", "giido", "eeido", "Guide", "camide", "eeid", "gruoid", "guids", "guaid", "GUID", "GUoid", "guido", "guide", "Guid", "GuID", "eeiden", "Guido", "giid"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tlong i;\n\n\tlong num_pixels = src_size >> 1;\n\n\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x3E0)>>5;\n\n\t    b = (rgb&0x7C00)>>10;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);\n\n\t}\n\n}\n", "idx": 25869, "substitutes": {"src": ["sys", "sn", "ch", "our", "sb", "stream", "rl", "iv", "ipl", "rs", "usc", "ur", "sub", "rc", "cont", "screen", "sl", "secure", "sel", "in", "inst", "sr", "supp", "sc", "s", "img", "ser", "usr", "dest", "input", "sec", "scan", "load", "sur", "st", "gb", "check", "source", "sq"], "dst": ["Dcr", "scr", "adST", "rest", "drc", " dST", "sst", "Dst", "rST", "Drc", " drc", "adest", "dcr", "dbl", "dest", "adst", "dST", " dbl", " dcr", " dest", "sbl", " ddest", "rst", "Dbl", "rdest", "ddest", "addest"], "src_size": ["rc_shape", "rc_length", "src_scale", "rc_scale", "rc_space", "rc_size", "src_space", "src_shape", "src_Size", "src_length", "rc_Size"], "i": ["ji", "it", "ic", "x", "batch", "ui", " j", "multi", "ki", "\u0438", "ik", "status", " x", "us", "pi", "ini", " ii", "ex", "id", "index", "ri", "gu", "me", "gi", "I", "n", "p", "phi", " bi", "series", "di", "zi", "sim", "j", "ai", "asi", "mi", "li", "ii", "print", "is", "ti", "ind", "info", "ip", " ti", "bi", "y", "ij", "ci", "json", "uri", "iu", " I", "xi", "si", "im", "jp", "m", "cli", "init", "qi", "ix"], "b": ["f", "bb", "fb", "x", "sb", "o", "br", "bound", "bc", "d", "nb", "c", "B", "db", "n", "p", "bis", "s", "ob", "cb", "j", "bs", "bg", "a", "back", "l", "bi", "y", "ba", "base", "bin", "gb", "e", "rb", "by", "u", "ab", "t", "be", "v", "m"], "g": ["f", "game", "gre", "gen", "gray", "ug", "ger", "d", "gt", "c", "reg", "mg", "group", "gu", "gi", "ga", "n", "p", "ge", "green", "pg", "gr", "gg", "go", "gp", "ig", "j", "eg", "bg", "gd", "fg", "gm", "gh", "l", "tg", "gb", "gs", "e", "u", "gc", "G", "rg", "m"], "r": ["range", "f", "red", "err", "rm", "rl", "re", "br", "term", "d", "rs", "w", "rd", "ur", "c", "rc", "rh", "reg", "rr", "pr", "ri", "or", "rat", "ar", "rate", "p", "sr", "n", "s", "gr", "rel", "rar", "rect", "usr", "vr", "rt", "l", "attr", "dr", "mr", "R", "cr", "e", "rb", "u", "t", "rg", "m", "ro", "res"], "rgb": [" rbg", "trxy", "ratgb", "ratbg", " rggb", " rgg", "trpy", " rimg", " rg", "rimg", "rcgg", "trval", "rimage", " rgd", "rataspberry", "srimg", "urimg", "rraspberry", "rval", "rxy", "rbimage", "rpy", "rrgd", "srg", "raspberry", "rbgg", "rgd", "rcgt", "urgb", "rrgg", " rgimage", "rcgb", "rrgb", " rimage", "trgb", " rgt", "ratimg", "rbg", "rrbg", " rpy", "urg", "rcgd", "rrgt", "urgg", " rxy", "rrimg", "srgg", "srval", "srpy", "rbgb", "rgt", " rval", " raspberry", "rg", "srgb", "rgg", "srxy", " rggg"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)\n\n{\n\n    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));\n\n\n\n    entry->rect.x = x;\n\n    entry->rect.y = y;\n\n    entry->rect.w = w;\n\n    entry->rect.h = h;\n\n\n\n    vnc_lock_queue(queue);\n\n    QLIST_INSERT_HEAD(&job->rectangles, entry, next);\n\n    vnc_unlock_queue(queue);\n\n    return 1;\n\n}\n", "idx": 25872, "substitutes": {"job": ["jar", "block", "batch", "web", "dq", "queue", "item", "cell", "jobs", "journal", "command", "row", "cmd", "db", "cp", "ob", "msg", "node", "gov", "plot", "j", "module", "Job", "bug", "image", "project", "process", "task", "work", "worker", "package", "obs", "slot", "scene", "jp", "jj", "lock"], "x": ["fx", "i", "tx", "on", "xy", "min", "d", "xt", "ex", "yx", "ry", "at", "dx", "rx", "g", "r", "p", "ax", "lat", "lon", "X", "xs", "xf", "l", "ox", "z", "px", "position", "xp", "ue", "xi", "t", "m", "v", "wx", "ix"], "y": ["my", "ch", "i", "gy", "xy", "dy", "ay", "fy", "yt", "ry", "ty", "yy", "uy", "iy", "yer", "iny", "top", "axy", "p", "wy", "ny", "ery", "yl", "ym", "ye", "cy", "yo", "vy", "hy", "b", "py", "ies", "ey", "ya", "ys", "oy", "t", "Y", "sy", "v", "asy", "m"], "w": ["wid", "W", "fw", "iw", "wh", "v", "d", "ow", "ex", "ew", "wd", "ww", "wr", "wl", "g", "n", "p", "we", "sw", "nw", "wa", "a", "l", "wb", "wp", "wi", "wn", "z", "wt", "window", "rw", "win", "kw", "q", "t", "m", "wx", "hw"], "h": ["hd", "ch", "i", "length", "ih", "hash", "ph", "dh", "wh", "d", "c", "k", "rh", "high", "height", "ah", "r", "g", "p", "kh", "s", "sh", "oh", "ht", "hei", "th", "hi", "gh", "b", "l", "ish", "z", "history", "bh", "ha", "H", "hh", "t", "q", "m", "v", "ho"], "entry": ["basic", "Entry", "attribute", "inter", "cur", "match", "field", "obj", "see", "store", "queue", "item", "try", "error", "component", "cell", "ie", "ent", "def", "insert", "ry", "escape", "event", "member", "or", "cue", "row", "command", "owner", "r", "oe", "record", "add", "set", "pair", "up", "and", "connection", "qa", "next", "section", "line", "back", "element", "desc", "primary", "info", "nt", "query", "RY", "access", "ient", "aux", "check", "import", "ue", "tmp", "manager", "enter"]}}
{"project": "qemu", "commit_id": "54f254f973a1b2ed0f3571390f4de060adfe23e8", "target": 0, "func": "static void uhci_async_complete_packet(USBPacket * packet, void *opaque)\n\n{\n\n    UHCIState *s = opaque;\n\n    UHCI_QH qh;\n\n    UHCI_TD td;\n\n    uint32_t link;\n\n    uint32_t old_td_ctrl;\n\n    uint32_t val;\n\n    uint32_t frame_addr;\n\n    int ret;\n\n\n\n    /* Handle async isochronous packet completion */\n\n    frame_addr = s->async_frame_addr;\n\n    if (frame_addr) {\n\n        cpu_physical_memory_read(frame_addr, (uint8_t *)&link, 4);\n\n        le32_to_cpus(&link);\n\n\n\n        cpu_physical_memory_read(link & ~0xf, (uint8_t *)&td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, &td, &s->pending_int_mask, 1);\n\n\n\n        /* update the status bits of the TD */\n\n        if (old_td_ctrl != td.ctrl) {\n\n            val = cpu_to_le32(td.ctrl);\n\n            cpu_physical_memory_write((link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        if (ret == 2) {\n\n            s->async_frame_addr = frame_addr;\n\n        } else if (ret == 0) {\n\n            /* update qh element link */\n\n            val = cpu_to_le32(td.link);\n\n            cpu_physical_memory_write(frame_addr,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        return;\n\n    }\n\n\n\n    link = s->async_qh;\n\n    if (!link) {\n\n        /* This should never happen. It means a TD somehow got removed\n\n           without cancelling the associated async IO request.  */\n\n        return;\n\n    }\n\n    cpu_physical_memory_read(link & ~0xf, (uint8_t *)&qh, sizeof(qh));\n\n    le32_to_cpus(&qh.link);\n\n    le32_to_cpus(&qh.el_link);\n\n    /* Re-process the queue containing the async packet.  */\n\n    while (1) {\n\n        cpu_physical_memory_read(qh.el_link & ~0xf,\n\n                                 (uint8_t *)&td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, &td, &s->pending_int_mask, 1);\n\n\n\n        /* update the status bits of the TD */\n\n        if (old_td_ctrl != td.ctrl) {\n\n            val = cpu_to_le32(td.ctrl);\n\n            cpu_physical_memory_write((qh.el_link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        if (ret < 0)\n\n            break; /* interrupted frame */\n\n        if (ret == 2) {\n\n            s->async_qh = link;\n\n            break;\n\n        } else if (ret == 0) {\n\n            /* update qh element link */\n\n            qh.el_link = td.link;\n\n            val = cpu_to_le32(qh.el_link);\n\n            cpu_physical_memory_write((link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n            if (!(qh.el_link & 4))\n\n                break;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 25925, "substitutes": {"packet": ["preset", "ppkt", "preskt", "ppacket", "octacket", "octet", "ppet", "packkt", "presacket", "packacket", "octkt"], "opaque": ["opposit", "Opaques", "oppaques", "opoid", "oppacity", "opacity", "popaque", " opaques", "obaque", "Opaque", "poposit", "popacity", "oposit", "Opacity", "obaques", " opoid", "oboid", "Oposit", "Opoid", "oppaque", "opaques", "popaques"], "s": ["sys", "sn", "i", "space", "as", "sb", "store", "sis", "service", "status", "se", "os", "fs", "d", "rs", "c", "ses", "ds", "hs", "sl", "g", "r", "spec", "n", "p", "bis", "state", "cs", "sts", "set", "services", "sw", "S", "bs", "js", "ss", "settings", "a", "is", "b", "ts", "ns", "ps", "https", "sm", "y", "stats", "es", "sp", "e", "sv", "gs", "less", "self", "serv", "h", "t", "ls", "m", "sq", "socket", "ssl"], "qh": ["qe", " qq", "qah", "qqph", "requg", "qug", "qualoh", "thinkh", " qih", "quih", "qualhe", "thinkoh", "sqx", "thinkph", "requoh", "quph", " sqq", "sqhe", "quhe", "sqe", "qg", "qhi", "querye", "qx", "quah", "qq", "que", "queryhe", "qqoh", "requhi", "iqoh", "iqph", "sqoh", "requh", "queryah", "sqph", "queryhi", "quale", "queryh", "queryg", " sqh", " sqih", "quoh", "qih", "qualh", "qqx", "qqh", "queryoh", "qoh", "sqah", "quh", "sqh", "thinkhe", "iqh", "iqhe", "qux", "qph", "qhe", "quq", "quhi"], "td": ["tar", "sd", "pd", "hd", "ld", "ad", "typ", "red", "pb", "dial", "nd", "tl", "dll", "pc", "d", "tf", "dh", "ent", "rd", "def", "att", "std", "tc", "cd", "tk", "sam", "tt", "ds", "tn", "edd", "md", "db", "cmd", "ctl", "TD", "dt", "ord", "th", "cz", "tg", "ssl", "desc", "ts", "dl", "nt", "trust", "dd", "dat", "bd", "dn", "fd", "tif", "disabled", "tp", "ud", "ptr", "tr", "t", "elt", "tmp", " TD", "tap", "pt", "od"], "link": ["ll", "address", "host", "child", "lag", "map", "ink", "bolt", "id", "disk", "path", "ctl", "open", "light", "li", "frame", "task", "weight", "lan", "page", "loc", "base", "bus", "ptr", "parent", "enable", "links", "tool", "ctrl", "cp", "close", "Link", "thread", "le", "tag", "chain", "ind", "key", "lib", "handle", "uri", "button", "label", "lock", "device", "type", "ld", "lo", "network", "ln", "linked", "low", "node", "share", "l", "addr", "url", "style", "control", "ssl", "block", "stream", "local", "target", "group", "list", "route", "rel", "slave", "connection", "scan", "line", "start", "port", "load", "delay", "sp", "check", "channel", "self", "source", "loop", "index"], "old_td_ctrl": ["old_sd_ctrl", "old_td_ctr", "old_td_cur", "old_nd_ctr", "old_td_rl", "old_th_ctr", "old_td_control", "old_td_trl", "old_nd_control", "old_nd_ctrl", "old_th_rl", "old_td_compl", "old_sd_ctr", "old_sd_compl", "old_th_ctrl", "old_nd_cur", "old_th_trl", "old_sd_control"], "val": ["pol", "prop", "alt", "tx", "cal", "rol", "al", "ref", "aval", "ev", "len", "col", "sol", "def", "value", "valid", "sil", "reg", "dev", "pr", "crit", "var", "cho", "sel", "pal", "ver", "el", "arr", "vol", "rel", "msg", "pret", "resp", "bal", "rem", "util", "mod", "ctx", "fail", "pl", "doc", "data", "Val", "test", "VAL", "vals", "key", "lib", "eval", "bin", "num", "serv", "il", "elt", "stat", "vt", "v", "vet", "pt", "res"], "frame_addr": [" frame_rel", "frame_store", "frameLogcoord", "frame2addr", "frame_rel", "frame2src", "Frame_addr", "framelyconn", " frame_ix", "frame___ix", "frame_ref", " frame_ptr", "frame___addr", " frame_store", "frame_ix", "frame_coord", "frame_mod", "frame_conn", "frame2ptr", " frame_mod", "framelystore", "Frame_ref", "frame2address", " frame_conn", "frame_address", "frameLogaddr", " frame_coord", " frame_src", "Frame_ptr", "frame_src", "framelyaddr", "frameLogag", " frame_ag", "Frame_address", " frame_address", "frame___conn", "frame_ag", "frame_ptr"], "ret": ["inter", "alt", "ter", "out", "lit", "err", "reset", "ll", "RET", "re", "len", "success", "try", "att", "gt", "def", " fut", "sat", "result", "cont", "ry", "lt", "virt", "repl", "cat", "ext", "det", "backed", "reply", "deg", "cert", "resp", "pret", "usr", "rem", "leg", "fit", "rt", "back", "test", "nt", "rets", "ft", " Ret", "flag", "Ret", " alt", "tr", "t", "elt", "arg", "vet", "res"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void tracked_request_end(BdrvTrackedRequest *req)\n\n{\n\n    if (req->serialising) {\n\n        req->bs->serialising_in_flight--;\n\n    }\n\n\n\n    QLIST_REMOVE(req, list);\n\n    qemu_co_queue_restart_all(&req->wait_queue);\n\n}\n", "idx": 25932, "substitutes": {"req": ["cur", "cmp", "err", "quest", "dq", "needed", "subject", "comm", "qt", "fr", "ctr", "request", "crit", "rr", "requ", "reg", "seq", "rx", "ext", "cmd", "r", "good", "ack", "rec", "gr", "qq", "resp", "msg", "rel", "org", "compl", "low", "ord", "j", "inv", "ctx", "coord", "decl", "js", "iq", "task", "comp", "desc", "ind", "urg", "nt", "expr", "query", "rss", "txt", "require", "exec", "pkg", "required", "q", "jp", "dep", "wx", "sq", "rpm", "res"], "bs": ["sys", "bb", "ms", "as", "pb", "lbs", "os", "mb", "fs", "bc", "us", "BS", "ds", "bm", "hz", "cs", "vs", "iss", "ss", "bn", "ts", "ps", "bi", "bh", "es", "gs", "bp", "ib", "res"], "serialising_in_flight": ["serialising_out_Flight", "serialising_in_Flight", "serialising_in_processing", "serialising_inqFlight", "serialising_inqflight", "serialising_inlequeue", "serialising_inleFlight", "serialising_inqprocessing", "serialising_out_flight", "serialising_inleprocessing", "serialising_in_queue", "serialising_out_processing", "serialising_out_queue", "serialising_inqqueue", "serialising_inleflight"]}}
{"project": "FFmpeg", "commit_id": "ac94b8bcc6cdba000ada0c84b4c287f7f37f2384", "target": 0, "func": "static int adpcm_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    ADPCMDecodeContext *c = avctx->priv_data;\n\n    ADPCMChannelStatus *cs;\n\n    int n, m, channel, i;\n\n    int block_predictor[2];\n\n    short *samples;\n\n    short *samples_end;\n\n    const uint8_t *src;\n\n    int st; /* stereo */\n\n\n\n    /* DK3 ADPCM accounting variables */\n\n    unsigned char last_byte = 0;\n\n    unsigned char nibble;\n\n    int decode_top_nibble_next = 0;\n\n    int diff_channel;\n\n\n\n    /* EA ADPCM state variables */\n\n    uint32_t samples_in_chunk;\n\n    int32_t previous_left_sample, previous_right_sample;\n\n    int32_t current_left_sample, current_right_sample;\n\n    int32_t next_left_sample, next_right_sample;\n\n    int32_t coeff1l, coeff2l, coeff1r, coeff2r;\n\n    uint8_t shift_left, shift_right;\n\n    int count1, count2;\n\n    int coeff[2][2], shift[2];//used in EA MAXIS ADPCM\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    //should protect all 4bit ADPCM variants\n\n    //8 is needed for CODEC_ID_ADPCM_IMA_WAV with 2 channels\n\n    //\n\n    if(*data_size/4 < buf_size + 8)\n\n        return -1;\n\n\n\n    samples = data;\n\n    samples_end= samples + *data_size/2;\n\n    *data_size= 0;\n\n    src = buf;\n\n\n\n    st = avctx->channels == 2 ? 1 : 0;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_ADPCM_IMA_QT:\n\n        n = buf_size - 2*avctx->channels;\n\n        for (channel = 0; channel < avctx->channels; channel++) {\n\n            int16_t predictor;\n\n            int step_index;\n\n            cs = &(c->status[channel]);\n\n            /* (pppppp) (piiiiiii) */\n\n\n\n            /* Bits 15-7 are the _top_ 9 bits of the 16-bit initial predictor value */\n\n            predictor = AV_RB16(src);\n\n            step_index = predictor & 0x7F;\n\n            predictor &= 0xFF80;\n\n\n\n            src += 2;\n\n\n\n            if (cs->step_index == step_index) {\n\n                int diff = (int)predictor - cs->predictor;\n\n                if (diff < 0)\n\n                    diff = - diff;\n\n                if (diff > 0x7f)\n\n                    goto update;\n\n            } else {\n\n            update:\n\n                cs->step_index = step_index;\n\n                cs->predictor = predictor;\n\n            }\n\n\n\n            if (cs->step_index > 88){\n\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n\n                cs->step_index = 88;\n\n            }\n\n\n\n            samples = (short*)data + channel;\n\n\n\n            for(m=32; n>0 && m>0; n--, m--) { /* in QuickTime, IMA is encoded by chuncks of 34 bytes (=64 samples) */\n\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] & 0x0F, 3);\n\n                samples += avctx->channels;\n\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] >> 4  , 3);\n\n                samples += avctx->channels;\n\n                src ++;\n\n            }\n\n        }\n\n        if (st)\n\n            samples--;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WAV:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n//        samples_per_block= (block_align-4*chanels)*8 / (bits_per_sample * chanels) + 1;\n\n\n\n        for(i=0; i<avctx->channels; i++){\n\n            cs = &(c->status[i]);\n\n            cs->predictor = *samples++ = (int16_t)bytestream_get_le16(&src);\n\n\n\n            cs->step_index = *src++;\n\n            if (cs->step_index > 88){\n\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n\n                cs->step_index = 88;\n\n            }\n\n            if (*src++) av_log(avctx, AV_LOG_ERROR, \"unused byte should be null but is %d!!\\n\", src[-1]); /* unused */\n\n        }\n\n\n\n        while(src < buf + buf_size){\n\n            for(m=0; m<4; m++){\n\n                for(i=0; i<=st; i++)\n\n                    *samples++ = adpcm_ima_expand_nibble(&c->status[i], src[4*i] & 0x0F, 3);\n\n                for(i=0; i<=st; i++)\n\n                    *samples++ = adpcm_ima_expand_nibble(&c->status[i], src[4*i] >> 4  , 3);\n\n                src++;\n\n            }\n\n            src += 4*st;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_4XM:\n\n        cs = &(c->status[0]);\n\n        c->status[0].predictor= (int16_t)bytestream_get_le16(&src);\n\n        if(st){\n\n            c->status[1].predictor= (int16_t)bytestream_get_le16(&src);\n\n        }\n\n        c->status[0].step_index= (int16_t)bytestream_get_le16(&src);\n\n        if(st){\n\n            c->status[1].step_index= (int16_t)bytestream_get_le16(&src);\n\n        }\n\n        if (cs->step_index < 0) cs->step_index = 0;\n\n        if (cs->step_index > 88) cs->step_index = 88;\n\n\n\n        m= (buf_size - (src - buf))>>st;\n\n        for(i=0; i<m; i++) {\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[i] & 0x0F, 4);\n\n            if (st)\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[1], src[i+m] & 0x0F, 4);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[i] >> 4, 4);\n\n            if (st)\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[1], src[i+m] >> 4, 4);\n\n        }\n\n\n\n        src += m<<st;\n\n\n\n        break;\n\n    case CODEC_ID_ADPCM_MS:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n        n = buf_size - 7 * avctx->channels;\n\n        if (n < 0)\n\n            return -1;\n\n        block_predictor[0] = av_clip(*src++, 0, 6);\n\n        block_predictor[1] = 0;\n\n        if (st)\n\n            block_predictor[1] = av_clip(*src++, 0, 6);\n\n        c->status[0].idelta = (int16_t)bytestream_get_le16(&src);\n\n        if (st){\n\n            c->status[1].idelta = (int16_t)bytestream_get_le16(&src);\n\n        }\n\n        c->status[0].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor[0]];\n\n        c->status[0].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor[0]];\n\n        c->status[1].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor[1]];\n\n        c->status[1].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor[1]];\n\n\n\n        c->status[0].sample1 = bytestream_get_le16(&src);\n\n        if (st) c->status[1].sample1 = bytestream_get_le16(&src);\n\n        c->status[0].sample2 = bytestream_get_le16(&src);\n\n        if (st) c->status[1].sample2 = bytestream_get_le16(&src);\n\n\n\n        *samples++ = c->status[0].sample2;\n\n        if (st) *samples++ = c->status[1].sample2;\n\n        *samples++ = c->status[0].sample1;\n\n        if (st) *samples++ = c->status[1].sample1;\n\n        for(;n>0;n--) {\n\n            *samples++ = adpcm_ms_expand_nibble(&c->status[0 ], src[0] >> 4  );\n\n            *samples++ = adpcm_ms_expand_nibble(&c->status[st], src[0] & 0x0F);\n\n            src ++;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_DK4:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n        c->status[0].predictor  = (int16_t)bytestream_get_le16(&src);\n\n        c->status[0].step_index = *src++;\n\n        src++;\n\n        *samples++ = c->status[0].predictor;\n\n        if (st) {\n\n            c->status[1].predictor  = (int16_t)bytestream_get_le16(&src);\n\n            c->status[1].step_index = *src++;\n\n            src++;\n\n            *samples++ = c->status[1].predictor;\n\n        }\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v >> 4  , 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_DK3:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n        if(buf_size + 16 > (samples_end - samples)*3/8)\n\n            return -1;\n\n\n\n        c->status[0].predictor  = (int16_t)AV_RL16(src + 10);\n\n        c->status[1].predictor  = (int16_t)AV_RL16(src + 12);\n\n        c->status[0].step_index = src[14];\n\n        c->status[1].step_index = src[15];\n\n        /* sign extend the predictors */\n\n        src += 16;\n\n        diff_channel = c->status[1].predictor;\n\n\n\n        /* the DK3_GET_NEXT_NIBBLE macro issues the break statement when\n\n         * the buffer is consumed */\n\n        while (1) {\n\n\n\n            /* for this algorithm, c->status[0] is the sum channel and\n\n             * c->status[1] is the diff channel */\n\n\n\n            /* process the first predictor of the sum channel */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n\n\n\n            /* process the diff channel predictor */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[1], nibble, 3);\n\n\n\n            /* process the first pair of stereo PCM samples */\n\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n\n\n\n            /* process the second predictor of the sum channel */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n\n\n\n            /* process the second pair of stereo PCM samples */\n\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_ISS:\n\n        c->status[0].predictor  = (int16_t)AV_RL16(src + 0);\n\n        c->status[0].step_index = src[2];\n\n        src += 4;\n\n        if(st) {\n\n            c->status[1].predictor  = (int16_t)AV_RL16(src + 0);\n\n            c->status[1].step_index = src[2];\n\n            src += 4;\n\n        }\n\n\n\n        while (src < buf + buf_size) {\n\n            uint8_t v1, v2;\n\n            uint8_t v = *src++;\n\n            /* nibbles are swapped for mono */\n\n            if (st) {\n\n                v1 = v >> 4;\n\n                v2 = v & 0x0F;\n\n            } else {\n\n                v2 = v >> 4;\n\n                v1 = v & 0x0F;\n\n            }\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v1, 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v2, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WS:\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  v >> 4  , 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_XA:\n\n        while (buf_size >= 128) {\n\n            xa_decode(samples, src, &c->status[0], &c->status[1],\n\n                avctx->channels);\n\n            src += 128;\n\n            samples += 28 * 8;\n\n            buf_size -= 128;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_EA_EACS:\n\n        samples_in_chunk = bytestream_get_le32(&src) >> (1-st);\n\n\n\n        if (samples_in_chunk > buf_size-4-(8<<st)) {\n\n            src += buf_size - 4;\n\n            break;\n\n        }\n\n\n\n        for (i=0; i<=st; i++)\n\n            c->status[i].step_index = bytestream_get_le32(&src);\n\n        for (i=0; i<=st; i++)\n\n            c->status[i].predictor  = bytestream_get_le32(&src);\n\n\n\n        for (; samples_in_chunk; samples_in_chunk--, src++) {\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  *src>>4,   3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], *src&0x0F, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_EA_SEAD:\n\n        for (; src < buf+buf_size; src++) {\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[0] >> 4, 6);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st],src[0]&0x0F, 6);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_EA:\n\n        /* Each EA ADPCM frame has a 12-byte header followed by 30-byte pieces,\n\n           each coding 28 stereo samples. */\n\n        if (buf_size < 12) {\n\n            av_log(avctx, AV_LOG_ERROR, \"frame too small\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n        samples_in_chunk = AV_RL32(src);\n\n        if (samples_in_chunk / 28 > (buf_size - 12) / 30) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid frame\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n        src += 4;\n\n        current_left_sample   = (int16_t)bytestream_get_le16(&src);\n\n        previous_left_sample  = (int16_t)bytestream_get_le16(&src);\n\n        current_right_sample  = (int16_t)bytestream_get_le16(&src);\n\n        previous_right_sample = (int16_t)bytestream_get_le16(&src);\n\n\n\n        for (count1 = 0; count1 < samples_in_chunk/28;count1++) {\n\n            coeff1l = ea_adpcm_table[ *src >> 4       ];\n\n            coeff2l = ea_adpcm_table[(*src >> 4  ) + 4];\n\n            coeff1r = ea_adpcm_table[*src & 0x0F];\n\n            coeff2r = ea_adpcm_table[(*src & 0x0F) + 4];\n\n            src++;\n\n\n\n            shift_left  = (*src >> 4  ) + 8;\n\n            shift_right = (*src & 0x0F) + 8;\n\n            src++;\n\n\n\n            for (count2 = 0; count2 < 28; count2++) {\n\n                next_left_sample  = (int32_t)((*src & 0xF0) << 24) >> shift_left;\n\n                next_right_sample = (int32_t)((*src & 0x0F) << 28) >> shift_right;\n\n                src++;\n\n\n\n                next_left_sample = (next_left_sample +\n\n                    (current_left_sample * coeff1l) +\n\n                    (previous_left_sample * coeff2l) + 0x80) >> 8;\n\n                next_right_sample = (next_right_sample +\n\n                    (current_right_sample * coeff1r) +\n\n                    (previous_right_sample * coeff2r) + 0x80) >> 8;\n\n\n\n                previous_left_sample = current_left_sample;\n\n                current_left_sample = av_clip_int16(next_left_sample);\n\n                previous_right_sample = current_right_sample;\n\n                current_right_sample = av_clip_int16(next_right_sample);\n\n                *samples++ = (unsigned short)current_left_sample;\n\n                *samples++ = (unsigned short)current_right_sample;\n\n            }\n\n        }\n\n\n\n        if (src - buf == buf_size - 2)\n\n            src += 2; // Skip terminating 0x0000\n\n\n\n        break;\n\n    case CODEC_ID_ADPCM_EA_MAXIS_XA:\n\n        for(channel = 0; channel < avctx->channels; channel++) {\n\n            for (i=0; i<2; i++)\n\n                coeff[channel][i] = ea_adpcm_table[(*src >> 4) + 4*i];\n\n            shift[channel] = (*src & 0x0F) + 8;\n\n            src++;\n\n        }\n\n        for (count1 = 0; count1 < (buf_size - avctx->channels) / avctx->channels; count1++) {\n\n            for(i = 4; i >= 0; i-=4) { /* Pairwise samples LL RR (st) or LL LL (mono) */\n\n                for(channel = 0; channel < avctx->channels; channel++) {\n\n                    int32_t sample = (int32_t)(((*(src+channel) >> i) & 0x0F) << 0x1C) >> shift[channel];\n\n                    sample = (sample +\n\n                             c->status[channel].sample1 * coeff[channel][0] +\n\n                             c->status[channel].sample2 * coeff[channel][1] + 0x80) >> 8;\n\n                    c->status[channel].sample2 = c->status[channel].sample1;\n\n                    c->status[channel].sample1 = av_clip_int16(sample);\n\n                    *samples++ = c->status[channel].sample1;\n\n                }\n\n            }\n\n            src+=avctx->channels;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_EA_R1:\n\n    case CODEC_ID_ADPCM_EA_R2:\n\n    case CODEC_ID_ADPCM_EA_R3: {\n\n        /* channel numbering\n\n           2chan: 0=fl, 1=fr\n\n           4chan: 0=fl, 1=rl, 2=fr, 3=rr\n\n           6chan: 0=fl, 1=c,  2=fr, 3=rl,  4=rr, 5=sub */\n\n        const int big_endian = avctx->codec->id == CODEC_ID_ADPCM_EA_R3;\n\n        int32_t previous_sample, current_sample, next_sample;\n\n        int32_t coeff1, coeff2;\n\n        uint8_t shift;\n\n        unsigned int channel;\n\n        uint16_t *samplesC;\n\n        const uint8_t *srcC;\n\n        const uint8_t *src_end = buf + buf_size;\n\n\n\n        samples_in_chunk = (big_endian ? bytestream_get_be32(&src)\n\n                                       : bytestream_get_le32(&src)) / 28;\n\n        if (samples_in_chunk > UINT32_MAX/(28*avctx->channels) ||\n\n            28*samples_in_chunk*avctx->channels > samples_end-samples) {\n\n            src += buf_size - 4;\n\n            break;\n\n        }\n\n\n\n        for (channel=0; channel<avctx->channels; channel++) {\n\n            int32_t offset = (big_endian ? bytestream_get_be32(&src)\n\n                                         : bytestream_get_le32(&src))\n\n                           + (avctx->channels-channel-1) * 4;\n\n\n\n            if ((offset < 0) || (offset >= src_end - src - 4)) break;\n\n            srcC  = src + offset;\n\n            samplesC = samples + channel;\n\n\n\n            if (avctx->codec->id == CODEC_ID_ADPCM_EA_R1) {\n\n                current_sample  = (int16_t)bytestream_get_le16(&srcC);\n\n                previous_sample = (int16_t)bytestream_get_le16(&srcC);\n\n            } else {\n\n                current_sample  = c->status[channel].predictor;\n\n                previous_sample = c->status[channel].prev_sample;\n\n            }\n\n\n\n            for (count1=0; count1<samples_in_chunk; count1++) {\n\n                if (*srcC == 0xEE) {  /* only seen in R2 and R3 */\n\n                    srcC++;\n\n                    if (srcC > src_end - 30*2) break;\n\n                    current_sample  = (int16_t)bytestream_get_be16(&srcC);\n\n                    previous_sample = (int16_t)bytestream_get_be16(&srcC);\n\n\n\n                    for (count2=0; count2<28; count2++) {\n\n                        *samplesC = (int16_t)bytestream_get_be16(&srcC);\n\n                        samplesC += avctx->channels;\n\n                    }\n\n                } else {\n\n                    coeff1 = ea_adpcm_table[ *srcC>>4     ];\n\n                    coeff2 = ea_adpcm_table[(*srcC>>4) + 4];\n\n                    shift = (*srcC++ & 0x0F) + 8;\n\n\n\n                    if (srcC > src_end - 14) break;\n\n                    for (count2=0; count2<28; count2++) {\n\n                        if (count2 & 1)\n\n                            next_sample = (int32_t)((*srcC++ & 0x0F) << 28) >> shift;\n\n                        else\n\n                            next_sample = (int32_t)((*srcC   & 0xF0) << 24) >> shift;\n\n\n\n                        next_sample += (current_sample  * coeff1) +\n\n                                       (previous_sample * coeff2);\n\n                        next_sample = av_clip_int16(next_sample >> 8);\n\n\n\n                        previous_sample = current_sample;\n\n                        current_sample  = next_sample;\n\n                        *samplesC = current_sample;\n\n                        samplesC += avctx->channels;\n\n                    }\n\n                }\n\n            }\n\n\n\n            if (avctx->codec->id != CODEC_ID_ADPCM_EA_R1) {\n\n                c->status[channel].predictor   = current_sample;\n\n                c->status[channel].prev_sample = previous_sample;\n\n            }\n\n        }\n\n\n\n        src = src + buf_size - (4 + 4*avctx->channels);\n\n        samples += 28 * samples_in_chunk * avctx->channels;\n\n        break;\n\n    }\n\n    case CODEC_ID_ADPCM_EA_XAS:\n\n        if (samples_end-samples < 32*4*avctx->channels\n\n            || buf_size < (4+15)*4*avctx->channels) {\n\n            src += buf_size;\n\n            break;\n\n        }\n\n        for (channel=0; channel<avctx->channels; channel++) {\n\n            int coeff[2][4], shift[4];\n\n            short *s2, *s = &samples[channel];\n\n            for (n=0; n<4; n++, s+=32*avctx->channels) {\n\n                for (i=0; i<2; i++)\n\n                    coeff[i][n] = ea_adpcm_table[(src[0]&0x0F)+4*i];\n\n                shift[n] = (src[2]&0x0F) + 8;\n\n                for (s2=s, i=0; i<2; i++, src+=2, s2+=avctx->channels)\n\n                    s2[0] = (src[0]&0xF0) + (src[1]<<8);\n\n            }\n\n\n\n            for (m=2; m<32; m+=2) {\n\n                s = &samples[m*avctx->channels + channel];\n\n                for (n=0; n<4; n++, src++, s+=32*avctx->channels) {\n\n                    for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) {\n\n                        int level = (int32_t)((*src & (0xF0>>i)) << (24+i)) >> shift[n];\n\n                        int pred  = s2[-1*avctx->channels] * coeff[0][n]\n\n                                  + s2[-2*avctx->channels] * coeff[1][n];\n\n                        s2[0] = av_clip_int16((level + pred + 0x80) >> 8);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        samples += 32*4*avctx->channels;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_AMV:\n\n    case CODEC_ID_ADPCM_IMA_SMJPEG:\n\n        c->status[0].predictor = (int16_t)bytestream_get_le16(&src);\n\n        c->status[0].step_index = bytestream_get_le16(&src);\n\n\n\n        if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n\n            src+=4;\n\n\n\n        while (src < buf + buf_size) {\n\n            char hi, lo;\n\n            lo = *src & 0x0F;\n\n            hi = *src >> 4;\n\n\n\n            if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n\n                FFSWAP(char, hi, lo);\n\n\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                lo, 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                hi, 3);\n\n            src++;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_CT:\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_ct_expand_nibble(&c->status[0 ], v >> 4  );\n\n            *samples++ = adpcm_ct_expand_nibble(&c->status[st], v & 0x0F);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_SBPRO_4:\n\n    case CODEC_ID_ADPCM_SBPRO_3:\n\n    case CODEC_ID_ADPCM_SBPRO_2:\n\n        if (!c->status[0].step_index) {\n\n            /* the first byte is a raw sample */\n\n            *samples++ = 128 * (*src++ - 0x80);\n\n            if (st)\n\n              *samples++ = 128 * (*src++ - 0x80);\n\n            c->status[0].step_index = 1;\n\n        }\n\n        if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_4) {\n\n            while (src < buf + buf_size) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    src[0] >> 4, 4, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    src[0] & 0x0F, 4, 0);\n\n                src++;\n\n            }\n\n        } else if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_3) {\n\n            while (src < buf + buf_size && samples + 2 < samples_end) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                     src[0] >> 5        , 3, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    (src[0] >> 2) & 0x07, 3, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    src[0] & 0x03, 2, 0);\n\n                src++;\n\n            }\n\n        } else {\n\n            while (src < buf + buf_size && samples + 3 < samples_end) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                     src[0] >> 6        , 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    (src[0] >> 4) & 0x03, 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    (src[0] >> 2) & 0x03, 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    src[0] & 0x03, 2, 2);\n\n                src++;\n\n            }\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_SWF:\n\n    {\n\n        GetBitContext gb;\n\n        const int *table;\n\n        int k0, signmask, nb_bits, count;\n\n        int size = buf_size*8;\n\n\n\n        init_get_bits(&gb, buf, size);\n\n\n\n        //read bits & initial values\n\n        nb_bits = get_bits(&gb, 2)+2;\n\n        //av_log(NULL,AV_LOG_INFO,\"nb_bits: %d\\n\", nb_bits);\n\n        table = swf_index_tables[nb_bits-2];\n\n        k0 = 1 << (nb_bits-2);\n\n        signmask = 1 << (nb_bits-1);\n\n\n\n        while (get_bits_count(&gb) <= size - 22*avctx->channels) {\n\n            for (i = 0; i < avctx->channels; i++) {\n\n                *samples++ = c->status[i].predictor = get_sbits(&gb, 16);\n\n                c->status[i].step_index = get_bits(&gb, 6);\n\n            }\n\n\n\n            for (count = 0; get_bits_count(&gb) <= size - nb_bits*avctx->channels && count < 4095; count++) {\n\n                int i;\n\n\n\n                for (i = 0; i < avctx->channels; i++) {\n\n                    // similar to IMA adpcm\n\n                    int delta = get_bits(&gb, nb_bits);\n\n                    int step = ff_adpcm_step_table[c->status[i].step_index];\n\n                    long vpdiff = 0; // vpdiff = (delta+0.5)*step/4\n\n                    int k = k0;\n\n\n\n                    do {\n\n                        if (delta & k)\n\n                            vpdiff += step;\n\n                        step >>= 1;\n\n                        k >>= 1;\n\n                    } while(k);\n\n                    vpdiff += step;\n\n\n\n                    if (delta & signmask)\n\n                        c->status[i].predictor -= vpdiff;\n\n                    else\n\n                        c->status[i].predictor += vpdiff;\n\n\n\n                    c->status[i].step_index += table[delta & (~signmask)];\n\n\n\n                    c->status[i].step_index = av_clip(c->status[i].step_index, 0, 88);\n\n                    c->status[i].predictor = av_clip_int16(c->status[i].predictor);\n\n\n\n                    *samples++ = c->status[i].predictor;\n\n                    if (samples >= samples_end) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"allocated output buffer is too small\\n\");\n\n                        return -1;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        src += buf_size;\n\n        break;\n\n    }\n\n    case CODEC_ID_ADPCM_YAMAHA:\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[0 ], v & 0x0F);\n\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[st], v >> 4  );\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_THP:\n\n    {\n\n        int table[2][16];\n\n        unsigned int samplecnt;\n\n        int prev[2][2];\n\n        int ch;\n\n\n\n        if (buf_size < 80) {\n\n            av_log(avctx, AV_LOG_ERROR, \"frame too small\\n\");\n\n            return -1;\n\n        }\n\n\n\n        src+=4;\n\n        samplecnt = bytestream_get_be32(&src);\n\n\n\n        for (i = 0; i < 32; i++)\n\n            table[0][i] = (int16_t)bytestream_get_be16(&src);\n\n\n\n        /* Initialize the previous sample.  */\n\n        for (i = 0; i < 4; i++)\n\n            prev[0][i] = (int16_t)bytestream_get_be16(&src);\n\n\n\n        if (samplecnt >= (samples_end - samples) /  (st + 1)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"allocated output buffer is too small\\n\");\n\n            return -1;\n\n        }\n\n\n\n        for (ch = 0; ch <= st; ch++) {\n\n            samples = (unsigned short *) data + ch;\n\n\n\n            /* Read in every sample for this channel.  */\n\n            for (i = 0; i < samplecnt / 14; i++) {\n\n                int index = (*src >> 4) & 7;\n\n                unsigned int exp = 28 - (*src++ & 15);\n\n                int factor1 = table[ch][index * 2];\n\n                int factor2 = table[ch][index * 2 + 1];\n\n\n\n                /* Decode 14 samples.  */\n\n                for (n = 0; n < 14; n++) {\n\n                    int32_t sampledat;\n\n                    if(n&1) sampledat=  *src++    <<28;\n\n                    else    sampledat= (*src&0xF0)<<24;\n\n\n\n                    sampledat = ((prev[ch][0]*factor1\n\n                                + prev[ch][1]*factor2) >> 11) + (sampledat>>exp);\n\n                    *samples = av_clip_int16(sampledat);\n\n                    prev[ch][1] = prev[ch][0];\n\n                    prev[ch][0] = *samples++;\n\n\n\n                    /* In case of stereo, skip one sample, this sample\n\n                       is for the other channel.  */\n\n                    samples += st;\n\n                }\n\n            }\n\n        }\n\n\n\n        /* In the previous loop, in case stereo is used, samples is\n\n           increased exactly one time too often.  */\n\n        samples -= st;\n\n        break;\n\n    }\n\n\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n", "idx": 25936, "substitutes": {"avctx": ["vrcu", "avecontext", "Avconn", "averctx", " avcpp", "abcontext", "ajtx", "aftx", "ajctx", "Avtx", "avercpp", "apcontext", " avcu", "avobj", "Avctx", "Avcontext", "aveobj", "avercontext", "avercu", "ajjac", " avobj", "avcu", "avjac", "aversys", "abkb", "vrconn", "avconn", "avectx", "abconn", "afctx", " avjac", " avconn", "apctx", "avtx", "avkb", "airconn", "vrctx", "ajcontext", " avtx", "abctx", "avsys", "avecu", "airctx", "afjac", " avkb", "avecpp", "afcontext", "aptx", "vrsys", "airsys", "avcpp", "apconn", "aircu", "averconn", "abobj", "aveconn", " avcontext", "avcontext", "averkb"], "data": ["block", "padding", "batch", "length", "stream", "values", "ata", "len", "d", "pad", "map", "value", "first", "id", "body", "read", "audio", "video", "buffer", "r", "p", "new", "feed", "bytes", "to", "input", "message", "frame", "image", "Data", "raw", "next", "a", "size", "dat", "text", "window", "bin", "DATA", "t", "sample", "str"], "data_size": ["data00SIZE", "DATA_index", "data00dimension", "data00resolution", " data_len", "data5dimension", "data2Size", "dataPSize", "DATA_size", "data5resolution", "data2size", "dataPsize", " data_resolution", "DATA_SIZE", "data5size", " data_length", "data5SIZE", "data_len", " data_SIZE", "data_index", "data00size", "data_length", "dataPindex", " data_dimension", "DATA_Size", "data_dimension", "data_Size", "data_resolution", "data2len", "data2length", " data_Size", "dataPSIZE", "data_SIZE", " data_index"], "avpkt": ["avpwp", "avpodtxt", "avcpkt", "avpud", "avPkt", "avPtxt", " avopct", "avopmt", "avpcmt", "avpodacket", "avdpwp", "avpcct", "avpckt", "avpodud", "avoptxt", "avpodct", " avopacket", "campodud", "campct", " avpacket", " avopmt", "avpodmsg", "avdpud", "avpcacket", "iverpodtxt", "avopkt", "iverpkt", "avPmsg", "avpacket", "avdpct", "avpmt", "avdpkt", "campwp", "campkt", "avcpct", "avpmsg", " avopkt", "iverpmsg", " avpmt", "avcpacket", "avcpmt", "campodct", "avpct", "avopacket", "avpodwp", "avPacket", "avPct", "avPud", "iverpacket", "iverpodmsg", "iverpodkt", "iverpodacket", "avPwp", "campud", "campodkt", "avopct", " avpct", "campodwp", "avopmsg", "avpodkt", "iverptxt", "avptxt"], "buf": ["block", "batch", "pb", "queue", "uf", "box", "br", "bl", "pad", "map", "buffer", "mem", "seq", "r", "cmd", "p", "img", "msg", "cb", "bytes", "vec", "raw", "doc", "orig", "b", "dat", "wb", "txt", "window", "text", "rb", "Buffer", "buff", "pkg", "tmp", "t", "v", "cv"], "c": ["f", "cmp", "ca", "comm", "bc", "tc", "dc", "ec", "g", "cp", "p", "cm", "ctx", "co", "a", "b", "ct", "l", "vc", "ac", "ci", "mc", "C", "fc", "con", "t", "cc", "v", "lc", "cv", "conf"], "cs": ["sys", "css", "ms", "cmp", "cf", "ca", "ins", "csv", "pc", "fs", "rs", "Cs", "tc", "ds", "hs", "ec", "ks", "cp", "sc", "cus", "cks", "cb", "cm", "ars", "vs", "ics", "bs", "js", "cons", "wcs", "ats", "ns", "vc", "ps", "CS", "ac", "acs", "ts", "stats", "ci", "qs", "fc", "gs", "ls", "cc", "lc", "cv"], "n": ["f", "x", "o", "nn", "nm", "len", "nb", "d", "index", "k", "g", "r", "p", "nc", "cn", "j", "b", "l", "ns", "nt", "z", "mn", "N", "num", "e", "en", "u", "ni", "h", "t", "v"], "m": ["dim", "o", "nm", "min", "rm", "man", "mut", "k", "bm", "middle", "r", "p", "M", "dm", "cm", "an", "mi", "gm", "l", "mn", "mc", "num", "h", "im", "mid", "v"], "channel": ["context", "batch", "attribute", "chan", "direction", "field", "client", "chip", "cam", "byte", "col", "annels", "component", "unit", "cell", "config", "character", "part", "ann", "id", "change", "which", "category", "video", "member", "chron", "row", "command", "CHO", "pixel", "panel", "camera", "sc", "mode", "axis", "monitor", "cm", "column", "can", "Channel", "coord", "message", "frame", "instance", "connection", "face", "chain", "section", "ind", "key", "window", "version", "user", "button", "course", "label", "number", "variable", "manager", "index", "name", "anger", "broad"], "i": ["it", "x", "pi", "id", "k", "in", "I", "p", "di", "j", "ai", "mi", "ii", "b", "ind", "l", "ti", "bi", "ip", "y", "ci", "ir", "si", "im", "index", "v"], "block_predictor": ["block_Predictory", "block_predictors", "block_posterive", "block_Predictive", "block_pensors", "block_pensive", "block_Predictor", "block_Predictors", "block_pensor", "block_predictory", "block_posterors", "block_pensory", "block_posterory", "block_predictive", "block_posteror"], "samples": ["tamps", "spamps", "sents", "Sents", "nsimens", "sample", "nsamps", "tents", "Samps", "Samples", "rsamps", "sems", "Sores", "Sources", "tamples", " samps", "sources", "rsamples", " sample", "rsems", "nsample", "simens", "tores", "rsources", "Sems", "spamples", " simens", "nsamples", "spents", "samps", "spores", "sores"], "samples_end": ["samps_append", "samples_max", "samples2END", "samps_start", "samps_END", "samples2ended", "samples_start", "samps_max", "samps_stop", "samples2max", "samples_ended", "samples_append", "samples_stop", "samples_END", "samps_ended", "samps_end", "samples2end"], "src": ["sys", "sn", "sb", "stream", "conv", "rl", "slice", "syn", "iv", "bc", "rs", "sub", "ur", "rc", "ctr", "buffer", "sync", "in", "r", "inst", "sr", "supp", "sc", "ser", "img", "dest", "vr", "input", "origin", "bs", "raw", "scan", "ind", "addr", "txt", "seek", "loc", "url", "bin", "fc", "iter", "u", "fp", "source", "ptr", "seed", "tmp", "proc", "filename", "str", "sq"], "st": ["it", "ost", "sn", "x", "out", "rest", "nd", "sta", "len", "se", "status", "br", "std", "d", "storage", "ste", "tt", "St", "r", "inst", "sc", "sw", "set", "pos", "next", "stop", "l", "start", "ST", "z", "step", "sth", "sp", "est", "ist", "ptr", "offset", "end", "t", "stat", "str"], "nibble": ["nbsp", "nib", "Nbsp", "snbsp", " nib", "snibble", "snib", " nbsp", "nig", "Nig", " nig", "Nib", "Nibble", "snig"], "diff_channel": [" delta_Channel", "diff_Channel", " deltaPerdirection", " deltaPerChannel", "diffPerchannel", "diffPerdirection", "diffPerChannel", " deltaPerbatch", " delta_batch", "diff_batch", " delta_channel", " delta_direction", "diffPerbatch", "diff_direction", " deltaPerchannel"], "samples_in_chunk": ["samples_in_punks", "samples_in_Chack", "samples_in_chacket", "samples_in_packet", "samples_in_Chacket", "samples_in_cack", "samples_in_Chunk", "samples_in_pack", "samples_in_Chunks", "samples_in_chack", "samples_in_chunks", "samples_in_cunk", "samples_in_cacket", "samples_in_cunks", "samples_in_punk"], "previous_left_sample": ["previous_right_Sample", "previous_right_space", "previous_left_space", "previous_left_Sample", "previous_left_system", "previous_right_system"], "previous_right_sample": ["previous_right_Sample", "previous_righttenanceprofile", "previous_right_mouse", "previous_righttenanceSample", "previous_right___Sample", "previous_left_Sample", "previous_righttenancesample", "previous_righttenancemouse", "previous_right___mouse", "previous_left_mouse", "previous_right___profile", "previous_right_profile", "previous_right___sample", "previous_left_profile"], "current_left_sample": ["current_right_sound", "current_leftxsound", "current_left_ample", "current_right_ample", "current_left_sound", "current_leftxSample", "current_leftxample", "current_leftxsample", "current_left_Sample", "current_right_Sample"], "current_right_sample": ["current_rightlyrange", "current_left_channel", "current_rightlySample", "current_right_range", "current_right_channel", "current_left_range", "current_rightlychannel", "current_left_Sample", "current_right_Sample", "current_rightlysample"], "next_left_sample": ["next_leftlysample", "next_left_Sample", "next_right_space", "next_right_seed", "next_leftlyseed", "next_left_space", "next_leftlySample", "next_left_seed", "next_right_Sample", "next_leftlyspace"], "next_right_sample": ["next_left_Sample", "next_left_sound", "next_right_frame", "next_right_Sample", "next_left_frame", "next_right_sound"], "coeff1l": ["coeff2b", "coff1l", "coeff0z", "coeff1L", "coff2z", "coff1L", "coeff1b", "coff1b", "coeff0l", "coff2l", "coeff0L", "coff2b", "coff1z", "coeff2L", "coeff0b", "coff2L", "coeff1z", "coeff2z"], "coeff2l": ["coefficient2l", "coefficient2L", "coeff12L", "coeff1L", "coefficient1l", "coeff2ls", "coeff12ll", "coeff4L", "coefficient2ls", "coefficient1ll", "coefficient1ls", "coeff2L", "coeff4l", "coeff1ll", "coefficient2ll", "coeff1ls", "coeff4ls", "coeff12ls", "coeff4ll", "coefficient1L", "coeff2ll", "coeff12l"], "coeff1r": ["coefficient2l", "coeff01l", "coeff2R", "coefficient1r", "coeff01dr", "coeff3dr", "coeff1R", "coefficient2R", "coefficient1l", "coeff2dr", "coeff1dr", "coeff3l", "coefficient2r", "coeff01R", "coefficient2dr", "coefficient1R", "coeff3r", "coeff01r", "coeff3R", "coefficient1dr"], "coeff2r": ["coefficient2l", "coeff2R", "coefficient1r", "coeff4r", "coeff4R", "coeff1R", "coefficient2R", "coefficient1l", "coeff3z", "coeff3l", "coeff4z", "coefficient2r", "coeff4l", "coefficient1R", "coeff3r", "coefficient1z", "coeff1z", "coeff2z", "coeff3R", "coefficient2z"], "shift_left": ["shift2right", "shift_l", "shift2left", "shift2l", " shift_l"], "shift_right": ["shift1r", "shift_r", "shift2r", "shift1Right", "shift1right", " shift_r", "shift_Right", "shift2right", "shift2left", "shift1left", "shift2Right", " shift_Right"], "count1": ["comment2", "comment1", "countone", "commenty", "nameone", "name2", "name1", "namey", " county", "county", " countone", "commentone"], "count2": ["count3", "County", "comment2", "Count3", "comment1", "comment3", "commenty", " county", "county", "Count1", " count3", "Count2"], "coeff": ["COeff", "coneff", "coef", "coefficient", " coef", " coff", "conff", " coefficient", "COef", "conef", "COefficient", "coff", "COff", "conefficient"], "shift": ["field", "hold", "slice", "sq", "Shift", "distance", "value", "push", "reverse", "send", "shr", "sh", "dist", "sort", "transform", "pull", "center", "align", "scale", "window", "offset", "diff", "index", "hift"], "predictor": ["epredictory", "pector", "pictoration", "peredictory", "ppector", "peocolator", "puppetorer", "puppetutor", "panchion", "predictior", "predictessor", "pocolable", "predictorer", "patredictutor", "predictora", "predictator", "pprioration", "peocolor", "pectoration", "panchor", "prredictora", "pictor", "prentory", "perediction", "priptutor", "ppectutor", "peprior", "prresentora", "ppectensor", "ppriutor", "pocolor", "periptoration", "periptor", "priptory", "epriptory", "priptessor", "prresentori", "prentable", "ppectored", "predictoration", "peredictor", "posponsor", "posponsensor", "pectutor", "predictutor", "pection", "pveyoration", "priptori", "prentator", "patriptutor", "posteressor", "predictory", "presentora", "patredictor", "presentessor", "pprior", "pictory", "epriptor", "peredictable", "posponsoration", "prredictessor", "ppectorer", "pjectator", "peredictensor", "pveyor", "prresentor", "prresentessor", "puppetor", "pveyior", "pepriutor", "prredictor", "peocolory", "posponsori", "periptori", "pictior", "epredictor", "puppetored", "presentor", "pocolory", "pveyory", "peprioration", "epriptoration", "prentor", "patriptor", "priptora", "pepriion", "priptor", "prediction", "predictori", "periptensor", "patriptored", "priptoration", "priptensor", "pjectory", "epredictoration", "peredictator", "priptorer", "panchutor", "peredictori", "presentori", "ppriion", "pjectable", "peredictoration", "pjector", "peredictutor", "prredictori", "ppectori", "patriptorer", "priptior", "patredictorer", "epriptior", "epredictior", "predictable", "posterora", "peocolable", "posterori", "predictensor", "ppectoration", "pocolator", "posteror", "predictored", "priptored", "panchoration", "patredictored"], "step_index": ["stepvaloffset", "step67index", "step2Index", " step_offset", " step_ind", "step_position", "step_number", "status_index", "step67result", " step2i", "stepvalindex", "STEP_ind", "step_ind", " step2Index", "stepxindex", "STEP_Index", " step_Index", "step2i", "step_offset", "step2index", " step_i", "stepxind", " step2index", "step_result", "status_number", "step67offset", " step2ind", " step_result", "stepxnumber", "step_i", "STEP_index", "status_position", "stepxposition", "status_ind", "stepvalresult", "step2ind", "step_Index"]}}
{"project": "FFmpeg", "commit_id": "50cbe09d8ced75422571d29bbec1f35a33a0d3ed", "target": 0, "func": "static int smacker_decode_header_tree(SmackVContext *smk, GetBitContext *gb, int **recodes, int *last, int size)\n\n{\n\n    int res;\n\n    HuffContext huff;\n\n    HuffContext tmp1, tmp2;\n\n    VLC vlc[2] = { { 0 } };\n\n    int escapes[3];\n\n    DBCtx ctx;\n\n    int err = 0;\n\n\n\n    if(size >= UINT_MAX>>4){ // (((size + 3) >> 2) + 3) << 2 must not overflow\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"size too large\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    tmp1.length = 256;\n\n    tmp1.maxlength = 0;\n\n    tmp1.current = 0;\n\n    tmp1.bits = av_mallocz(256 * 4);\n\n    tmp1.lengths = av_mallocz(256 * sizeof(int));\n\n    tmp1.values = av_mallocz(256 * sizeof(int));\n\n\n\n    tmp2.length = 256;\n\n    tmp2.maxlength = 0;\n\n    tmp2.current = 0;\n\n    tmp2.bits = av_mallocz(256 * 4);\n\n    tmp2.lengths = av_mallocz(256 * sizeof(int));\n\n    tmp2.values = av_mallocz(256 * sizeof(int));\n\n\n\n    if(get_bits1(gb)) {\n\n        smacker_decode_tree(gb, &tmp1, 0, 0);\n\n        skip_bits1(gb);\n\n        if(tmp1.current > 1) {\n\n            res = init_vlc(&vlc[0], SMKTREE_BITS, tmp1.length,\n\n                        tmp1.lengths, sizeof(int), sizeof(int),\n\n                        tmp1.bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE);\n\n            if(res < 0) {\n\n                av_log(smk->avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n    if (!vlc[0].table) {\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"Skipping low bytes tree\\n\");\n\n    }\n\n    if(get_bits1(gb)){\n\n        smacker_decode_tree(gb, &tmp2, 0, 0);\n\n        skip_bits1(gb);\n\n        if(tmp2.current > 1) {\n\n            res = init_vlc(&vlc[1], SMKTREE_BITS, tmp2.length,\n\n                        tmp2.lengths, sizeof(int), sizeof(int),\n\n                        tmp2.bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE);\n\n            if(res < 0) {\n\n                av_log(smk->avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n    if (!vlc[1].table) {\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"Skipping high bytes tree\\n\");\n\n    }\n\n\n\n    escapes[0]  = get_bits(gb, 16);\n\n    escapes[1]  = get_bits(gb, 16);\n\n    escapes[2]  = get_bits(gb, 16);\n\n\n\n    last[0] = last[1] = last[2] = -1;\n\n\n\n    ctx.escapes[0] = escapes[0];\n\n    ctx.escapes[1] = escapes[1];\n\n    ctx.escapes[2] = escapes[2];\n\n    ctx.v1 = &vlc[0];\n\n    ctx.v2 = &vlc[1];\n\n    ctx.recode1 = tmp1.values;\n\n    ctx.recode2 = tmp2.values;\n\n    ctx.last = last;\n\n\n\n    huff.length = ((size + 3) >> 2) + 3;\n\n    huff.maxlength = 0;\n\n    huff.current = 0;\n\n    huff.values = av_mallocz(huff.length * sizeof(int));\n\n\n\n    if (smacker_decode_bigtree(gb, &huff, &ctx) < 0)\n\n        err = -1;\n\n    skip_bits1(gb);\n\n    if(ctx.last[0] == -1) ctx.last[0] = huff.current++;\n\n    if(ctx.last[1] == -1) ctx.last[1] = huff.current++;\n\n    if(ctx.last[2] == -1) ctx.last[2] = huff.current++;\n\n    if(huff.current > huff.length){\n\n        ctx.last[0] = ctx.last[1] = ctx.last[2] = 1;\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"bigtree damaged\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    *recodes = huff.values;\n\n\n\n    if(vlc[0].table)\n\n        ff_free_vlc(&vlc[0]);\n\n    if(vlc[1].table)\n\n        ff_free_vlc(&vlc[1]);\n\n    av_free(tmp1.bits);\n\n    av_free(tmp1.lengths);\n\n    av_free(tmp1.values);\n\n    av_free(tmp2.bits);\n\n    av_free(tmp2.lengths);\n\n    av_free(tmp2.values);\n\n\n\n    return err;\n\n}\n", "idx": 25937, "substitutes": {"smk": ["simck", "svik", "skak", "Smunk", "smck", "simkg", "smik", "simk", " smak", "smunk", "mk", "smuk", "memunk", "swkg", "Smk", "schekg", "mak", "scheak", "simik", "skkg", "skmk", "memuk", "memk", "swk", "Smuk", "simmk", "symunk", "smkg", "svk", "schemk", "symk", "svkg", "symuk", " smck", "symck", "swik", " smkg", "schek", "smak", "smack", "skk", "swack", "mkg", "smmk", "svack", "mck", "simack", "memck", "Smck", "simak"], "gb": ["vm", "sys", "bb", "fb", "sb", "pb", "bridge", "rl", "vd", "csv", "mb", "pc", "ruby", "gt", "again", "storage", "gif", "bf", "GB", "gz", "bm", "g", "yg", "db", "pg", "io", "dt", "rect", "cb", "gov", "hub", "gg", "bytes", "gow", "vg", "eg", "kb", "cm", "bg", "gd", "eb", "cfg", "gm", "tg", "erb", "py", "dd", "px", "bt", "gs", "rb", "gnu", "sv", "gc", "tmp", "rg", "cv", "hw"], "recodes": ["rccodes", "Recodes", "codes", "coded", "Recents", "cents", "rcents", "Recoded", "rcodes", "Reccodes", "rcoded", "recoded", "recents", "ccodes", "reccodes"], "last": ["parent", "cur", "latest", "rest", "needed", "first", "id", "list", "count", "cache", "new", "extra", "ast", "total", "next", "used", "since", "chain", "old", "prev", "base", "st", "est", "max", "end", "final"], "size": ["sn", "length", "space", "len", "fee", "w", "c", "storage", "mem", "buffer", "empty", "g", "send", "n", "count", "ize", "s", "small", "new", "sh", "bytes", "set", "sw", "message", "total", "shape", "capacity", "l", "data", "scale", "SIZE", "huge", "z", "sp", "Size", "max", "sum", "name"], "res": ["sys", "ms", "i", "out", "red", "rest", "err", "reset", "pas", "re", "status", "rs", "def", "ber", "rc", "result", "rev", "conf", "results", "act", "RES", "details", "r", "resource", "ver", "pers", "count", " RES", "cond", "ser", "resp", "cs", " Res", "rel", "rem", "resh", " err", "clear", "js", "ne", "cons", "req", "yes", "ps", "expr", "vals", "val", "Res", "ret", "der", "pres", "ress"], "huff": ["Huff", "hhuff", "Huffy", "huf", "huffy", " huf", "hhUFF", " huffy", " hUFF", "hUFF", "HUFF", "Huf", "hhuffy", "hhuf"], "tmp1": ["mpOne", "ppo5", "mpMap", "temp1", "tmp0", "tmpOne", "soc101", "tc001", " tmp3", "mp1", "node3", "yyOnce", "mpOnce", "mp91", " tmp0", "temp7", "stuff2", "mp5", "tmpOnce", "yy3", "stuff1", "temp3", " tmpMap", "stuffone", "mp01", "etc01", "tmp101", "cmp2", "mp101", "etc101", "tmpMap", "node2", "yy1", "tmp01", "cmp0", " tmpone", "tmp6", " tmp7", "mpone", "stuff11", " tmp11", "mp0", "tmp9", "etc11", "soc1", "permone", "ppoone", "tmp7", " tmpOnce", "tcOne", "tmp5", "node01", " tmp91", " tmp01", "tmp91", " tmp5", "ppo1", "tc1", "perm1", "mp2", "mp9", "yy2", "ppo9", "temp2", " tmp6", "mp001", "perm9", "mp6", "temp101", "temp01", "mp11", "node1", "ppo101", "tmp001", "tc9", " tmp101", "tmp11", "tempOne", "cmp5", "mp7", "etc1", "mp3", "temp0", "temp001", "permOne", "stuffMap", "ppoOne", "tmp3", "tempone", "ppo6", "stuff91", "temp9", "temp11", "soc01", "cmp1", "cmpone", "cmp11", "soc11", "tmpone"], "tmp2": ["exprtwo", "ppo5", " tmp22", "tmptwo", "tmp02", "temp1", "tempTwo", " tmptwo", "etc22", " tmp14", " tmp3", "temp02", "mp02", "_", "mp1", "cont", "buffer", "new", "temptwo", "tc2", "mp5", " tmpable", "temp3", "td2", "etc10", "ppo02", "expr02", "expr5", "prop2", "prop22", "tmpTwo", "mpTwo", "exprTwo", " tmpTwo", "func", "etc2", "expr2", "tmp22", "etc02", "termable", "tmp10", "tmp5", "proc2", "tdable", "prop10", " tmp5", " tmp02", "tmp14", "ppo14", "mp2", "etcTwo", "tc02", "etctwo", "def", "ppo2", "tdtwo", "temp2", "td02", "term2", "permtwo", "procTwo", "all", "termtwo", "tmpable", " tmp10", "mp3", "prop02", "tmp3", "mp14", "term02", "temp5", "perm5", "proc02", "perm2", "tcTwo", "big"], "vlc": ["tlc", "vell", "cll", "vrcu", "vrc", "vlC", "vlcs", "tlci", "wlci", "velC", "tll", "vlcu", "vrci", "velc", "tlcu", "clcs", "wlcu", "flc", "vrpc", "vrC", "wll", "vll", "wlcs", "flcs", "wlpc", "wlC", "vlpc", "vlci", "fll", "flpc", "vrl", "clc", "wlc", "clpc", "velpc"], "escapes": ["Escales", "escales", "encaper", "escape", "Escape", "esape", "Escaper", "encales", "esapes", "encapes", "Escapes", "encape", "esaper", "escaper", "esales"], "ctx": [" cx", "context", "parent", "tx", "cf", " c", "obj", "bc", " sc", " loc", " cc", "c", "tc", " td", "cmd", " cs", "cp", "cb", "buf", " cp", "xc", " context", "txt", " kb", "kw", "gc", "tmp", "cc", "cv"]}}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int standard_decode_picture_primary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status = 0;\n\n\n\n    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);\n\n    skip_bits(gb, 2); //framecnt unused\n\n    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);\n\n    v->s.pict_type = get_bits(gb, 1);\n\n    if (v->s.avctx->max_b_frames)\n\n    {\n\n        if (!v->s.pict_type)\n\n        {\n\n            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;\n\n            else v->s.pict_type = B_TYPE;\n\n        }\n\n        else v->s.pict_type = P_TYPE;\n\n    }\n\n    else v->s.pict_type++;\n\n\n\n    switch (v->s.pict_type)\n\n    {\n\n    case I_TYPE: status = decode_i_picture_header(v); break;\n\n    case P_TYPE: status = decode_p_picture_primary_header(v); break;\n\n    case BI_TYPE:\n\n    case B_TYPE: status = decode_b_picture_primary_header(v); break;\n\n    }\n\n\n\n    if (status == FRAME_SKIPED)\n\n    {\n\n      av_log(v->s.avctx, AV_LOG_INFO, \"Skipping frame...\\n\");\n\n      return status;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25947, "substitutes": {"v": ["vm", "f", "ch", "ov", "i", "x", "cam", "conv", "vd", "ev", "lv", "iv", "vp", "w", "tv", "value", "c", "pp", "rev", "video", "wire", "vv", "g", "qu", "ver", "p", "ve", "n", "env", "vr", "j", "view", "vs", "inv", "form", "message", "up", "av", "V", "co", "b", "nv", "l", "vc", "y", "window", "z", "version", "e", "val", "current", "sv", "vim", "qv", "vi", "etc", "h", "t", "vt", "uv", "m", "q", "cv", "detail"], "gb": ["bb", "fb", "sb", "gy", "gam", "Gb", "xy", "bridge", "vd", "uf", "mb", "nb", "ruby", "gt", "gif", "goo", "bf", "GB", "phy", "gpu", "bm", "fm", "g", "gu", "yg", "db", " rgb", "hz", "cb", "hub", "bys", "gg", "bits", "ctx", "vg", "eg", "kb", "bs", "bg", "gd", "fg", "eb", "cfg", "gm", "tg", "html", "hog", "py", " db", "attr", "bt", "gs", "rb", "gnu", "gc", "ib", "rg", "cv"], "s": ["sys", "ms", "i", "sb", "store", "ins", "temp", "os", "comm", "se", "fs", "sports", "rs", "att", "w", "c", "ses", "ds", "hs", "g", "tests", "pers", "p", "has", "sc", "bis", "cs", "sh", "sts", "sw", "aws", "bits", "an", "go", "set", "vs", "S", "esm", "js", "ss", "is", "b", "ats", "ts", "ns", "ps", "ims", "stats", "qs", "z", "es", "its", "gs", "sv", "parts", "h", "ls", "t", "m"], "pict_type": ["picture_type", "pictacytype", "pict_TYPE", " pictutationtype", "pict_trace", "pai_type", "shit_time", "stat_class", " pict_class", "pictacyindex", "pictencyindex", "stat_name", "pictutationindex", "pict_kind", "pictureType", "pictacyclass", "picttTYPE", "pictutationclass", "pai_kind", " pictutationindex", "pictencychain", "pictowerrole", "pictttime", "picture_name", "picturetype", "feat_type", "pictttype", "pict_chain", "shit_trace", "shit_type", "pict2types", "pictencyclass", "pictowertype", "pai_Type", " pictutationchain", "pict_name", "pictowerype", "aunt_type", "feat_name", "pai_ype", "pict_types", "pict2length", "pictencytype", "pict_class", "pictureype", "picture_length", "pictacychain", "pict_index", "pictutationchain", "pict_time", " pict_index", "stat_type", "aunt_ype", "pict_length", "pict_typ", "picture_types", "aunt_operator", "pict_role", "pictoweroperator", "pict_operator", "pict2name", "stat_TYPE", "shit_TYPE", "feat_TYPE", "pictttrace", "pict2type", "pictutationtype", " pict_chain", "picturekind", "pict_Type", "pict_ype", "feat_typ", "aunt_role", " pictutationclass"]}}
{"project": "FFmpeg", "commit_id": "a18456a2032e49385447a1d0d2f146f65fe9a5e1", "target": 0, "func": "static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)\n\n{\n\n    FILE* f;\n\n    char line[1024];\n\n    char  cmd[1024];\n\n    FFServerIPAddressACL *acl = NULL;\n\n    int line_num = 0;\n\n    const char *p;\n\n\n\n    f = fopen(stream->dynamic_acl, \"r\");\n\n    if (!f) {\n\n        perror(stream->dynamic_acl);\n\n        return NULL;\n\n    }\n\n\n\n    acl = av_mallocz(sizeof(FFServerIPAddressACL));\n\n\n\n    /* Build ACL */\n\n    for(;;) {\n\n        if (fgets(line, sizeof(line), f) == NULL)\n\n            break;\n\n        line_num++;\n\n        p = line;\n\n        while (av_isspace(*p))\n\n            p++;\n\n        if (*p == '\\0' || *p == '#')\n\n            continue;\n\n        ffserver_get_arg(cmd, sizeof(cmd), &p);\n\n\n\n        if (!av_strcasecmp(cmd, \"ACL\"))\n\n            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);\n\n    }\n\n    fclose(f);\n\n    return acl;\n\n}\n", "idx": 25948, "substitutes": {"stream": ["stack", "ost", "context", "length", "engine", "download", "server", "pipe", "store", "status", "os", "host", "fr", "wrapper", "platform", "buffer", "sl", "secure", "sync", "console", "steam", "spec", "ack", "metadata", "pool", "mode", "filter", "feed", "sw", "hook", "REAM", "transform", "view", "stage", "form", "message", "Stream", "test", "ocr", "port", "src", "poll", "window", "link", "st", "draw", "http", "style", "driver", "ream", "source", "accept", "channel", "h", "reader", "loop", "Steam", "sample", "socket", "ssl"], "c": ["cl", "ch", "bc", "d", "w", "tc", "rc", "dc", "g", "r", "s", "ctx", "b", "ct", "ac", "vc", "ci", "mc", "fc", "e", "h", "t", "cc", "C", "v", "lc", "m"], "f": ["fb", "af", "i", "out", "cf", "uf", "ff", "fa", "fs", "d", "w", "fr", "bf", "fl", "buffer", "fi", "g", "fm", "r", "in", "far", "lf", "n", "fn", "j", "form", "rf", "file", "xf", "b", "l", "fac", "y", "elf", "fe", "fd", "ile", "fc", "e", "fo", "fp", "h", "t", "v", "F"], "line": ["range", "block", "cl", "lo", "field", "pipe", "lane", "se", "ole", "ln", "id", "nl", "buffer", "command", "path", "row", "ine", "header", "comment", "list", "lf", "online", "eline", "mode", "lines", "pointer", "le", "lin", "level", "pe", "pos", "frame", "LINE", "chain", "file", "Line", "ode", "l", "de", "ip", "port", "page", "load", "link", "limit", "e", "time", "label", "m", "point", "lock"], "cmd": ["cl", "custom", "batch", "cmp", "args", "dir", "nd", "code", "op", "comm", "col", "try", "normal", "term", "def", "rc", "id", "cd", "ctr", "cont", "command", "path", "act", "md", "ext", "comment", "cp", "send", "msg", "bind", "call", "quick", "ctx", "cod", "com", "raw", "cfg", "req", "desc", "vc", "ip", "load", "addr", "text", "Cmd", "txt", "handle", "pkg", "content", "rn", "arg", "point", "cli", "name"], "acl": ["ull", "cl", "mac", "client", "pb", "null", "al", "pc", "AC", "nl", "scl", "fl", "ul", "auth", "act", "g", "ah", "wl", "ACP", "iam", "cp", "cache", "ace", "list", "alias", "resp", "ACA", "policy", "ctx", "ap", " ACL", "acc", "a", "am", "ak", "l", "ac", "anc", "ip", "acs", "cas", "anon", "cli", "alloc", "fc", "cap", "fp", "gc", "kl", "all", "abl", "v", "lc"], "p": ["ping", "padding", "prop", "pre", "i", "perm", "pb", "point", "pipe", "ph", "col", "pc", "d", "pad", "vp", "part", "pi", "pp", "pr", "g", "r", "pers", "cp", "n", "pid", "pointer", "pn", "to", "j", "pe", "pos", "ap", "pl", "np", "rep", "pass", "b", "l", "ps", "post", "port", "pa", "wp", "pro", "sp", "bp", "tp", "u", "pard", "fp", "pkg", "lp", "P", "t", "h", "jp", "m", "v", "q", "pat", "tmp", "pt"], "line_num": ["Line_num", "line2NUM", "Line_no", "Line_im", "Line2NUM", "line_en", "line_Num", "Line_sum", "Line2num", "line2num", "line_mult", "Line_en", "linePsum", "Line_Num", "line_number", "Line2im", "line2sum", "line_no", "Line_NUM", "line_NUM", "linePnum", "linePNUM", "Line2sum", "line_sum", "Line_number", "line2im", "line_im", "linePim", "Line_mult"]}}
{"project": "qemu", "commit_id": "dc38852aaa4ac187d8b44201f75fc2835241912d", "target": 0, "func": "static int discard_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0;\n\n    int c, ret;\n\n    int64_t offset, count;\n\n\n\n    while ((c = getopt(argc, argv, \"Cq\")) != -1) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        default:\n\n            return qemuio_command_usage(&discard_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return qemuio_command_usage(&discard_cmd);\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        print_cvtnum_err(offset, argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        print_cvtnum_err(count, argv[optind]);\n\n        return 0;\n\n    } else if (count >> BDRV_SECTOR_BITS > INT_MAX) {\n\n        printf(\"length cannot exceed %\"PRIu64\", given %s\\n\",\n\n               (uint64_t)INT_MAX << BDRV_SECTOR_BITS,\n\n               argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    ret = blk_discard(blk, offset >> BDRV_SECTOR_BITS,\n\n                      count >> BDRV_SECTOR_BITS);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"discard failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    if (!qflag) {\n\n        t2 = tsub(t2, t1);\n\n        print_report(\"discard\", &t2, offset, count, count, 1, Cflag);\n\n    }\n\n\n\nout:\n\n    return 0;\n\n}\n", "idx": 25958, "substitutes": {"blk": [" blkt", "clk", " blkid", " plak", " plkid", " blck", " blak", "blkt", "plkid", "clkt", "plck", "plkt", "plk", "plak", "blck", " plk", "clak", " plck", "clck", "blkid", "blak"], "argc": ["Argcs", "Argfc", "argumentv", "argumentc", "Argc", "argsc", "argfc", "Argl", " argfc", "calc", "calfc", "argumentl", " argcs", "argscs", "targetl", "argsl", "argsv", "argct", "call", " argct", "argsct", " argl", "calcs", "targetc", "targetcs", "argcs", "targetv", "argl", "argumentct"], "argv": ["agv", "argumentv", "argumentc", "argf", "Argc", "argsV", "docc", "argsc", "argsp", "Argp", "agp", "argb", "argV", " argvs", "paramV", "docv", "regv", "argvr", "argumentvs", "argvin", "regl", " argvin", "argvs", "argp", "paramv", "Argv", "argsl", "argsv", " argV", "argm", " argm", "regc", "argsvs", "argsvin", "argumentp", "argsb", "regf", " argl", "argsvr", "agc", "argumentV", " argb", "argsm", "docvin", "argumentb", "paramvs", "Argm", "agvr", "docm", " argvr", " argf", "paramc", "argl", "argsf", " argp"], "t1": ["t8", "tt3", "tt2", "T64", "v3", "T1", "t4", "t3", " t64", "T2", "T0", "t64", " t3", "tt1", "p4", " t8", " t0", "p8", "t0", "v1", "v0", "T8", "tt64", "T3", " t4", "v2", "T4", "p2", "p1"], "t2": ["dt1", "T02", "v7", "int2", " ttwo", " t256", "dt02", "p0", "v3", " t4", "T1", "t4", "T256", "t3", " t02", "t02", "t256", "T2", "T0", "int1", " t7", " t3", "at3", " t0", "dt3", "t0", "attwo", "v1", "dt2", "int4", "t7", "Ttwo", "int256", "T3", "T7", "ttwo", "v2", "T4", "at1", "at2", "p2", "p1"], "c": ["f", "ic", "ch", "cur", "i", "cf", "o", "ce", "code", "col", "pc", "bc", " cc", "k", "abc", "dc", "ec", "g", "n", "cp", "p", "cache", "sc", "nc", "cs", "arc", "cm", " C", "cod", "cut", "co", "a", "comp", "b", "ind", "ct", "ac", "unc", " cr", "l", "ci", " cont", "mc", "z", "con", "fc", "e", "t", "cc", "C", "v", "lc"], "ret": ["f", "alt", "ter", "out", "err", "reset", "ll", "ref", "RET", "re", "store", "len", "try", "bit", "att", "gt", "def", "std", "rc", "result", "rev", "nl", "lt", "mem", "r", "ext", "reply", "RT", "dt", "arr", "ord", "resp", "pret", "cb", "rem", "magic", "nz", "print", "rt", "back", "ct", "ts", "nt", "rets", "txt", "ft", "iter", "val", "flag", "Ret", "tail", "tr", "gc", "t", "elt", "arg", "res"], "offset": ["range", "padding", "type", "length", "out", "o", "needed", "reset", "store", "address", "ref", "item", "len", "bound", "op", "flag", "entry", "skip", "id", "after", "zero", "error", "buffer", "local", "command", "top", "offs", "alias", "pointer", "oo", "util", "set", "et", "origin", "coord", "pos", "order", "total", "image", "style", "data", "location", "start", "info", "size", "shift", "loc", "addr", "key", "seek", "window", "base", "position", "limit", "sp", "time", "package", "mt", "slot", "off", "ptr", "timeout", "trace", "before", "pkg", "index", "point", "end", "Offset", "frequency", "name"], "count": ["ch", "length", "batch", "not", "ount", "latest", "force", "err", "only", "len", "code", "try", "nb", "child", "part", "cloud", "result", "core", "cont", "zero", "find", "group", "comment", "cmd", "list", "n", "collection", "amount", "cache", "counter", "non", "record", "add", "call", "order", "message", "total", "depth", "Count", "found", "ct", "size", "nt", "info", "more", "z", "base", "C", "num", "limit", "iter", "current", "flag", "check", "number", "time", "table", "max", "q", "all", "sum", "index", "no", "t", "name"], "optind": ["optedinn", "OptIND", "opIND", "optionIND", "checkint", "vertfind", "optIND", "opindex", "optionptr", "optstrong", "altstart", "optionind", "opind", "optInd", "helpind", "optedstart", " optmind", "optbind", "optionine", "optedInd", "letmind", " optptr", "altIND", "altind", "optint", "opbind", " optinn", "optimindex", "letIND", " optstart", "checkreq", " optbind", "optimbind", " optint", "vertstrong", "optimptr", "optionreq", "optedind", "helpstart", " optindex", "checkind", "optimInd", "opInd", "optmind", "optinn", " optine", "opinn", "optimind", "optreq", "helpfind", "optfind", "optiminn", "optindex", "optionint", "altinn", "checkine", "helpstrong", "vertstart", "optimstart", "optimmind", " optIND", "optionInd", "optionindex", "letind", "Optind", "optedstrong", " optreq", "optedbind", "vertind", "Optindex", "optedfind", "optptr", "OptInd", "optimIND", "optstart", "letbind", "optine"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,\n\n                             hwaddr size)\n\n{\n\n    assert(mr->terminates);\n\n    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,\n\n                                        memory_region_get_dirty_log_mask(mr));\n\n}\n", "idx": 25997, "substitutes": {"mr": ["pm", "ms", "lr", "rm", "adr", "br", "rl", "rs", "nr", "hr", "ln", "rr", "pr", "mx", "bm", "mk", "hm", "fm", "wr", "r", "sr", "MR", "gr", "kr", "irm", "rar", "vr", "RM", "rt", "yr", "ocr", "cr", "Mr", "mn", "rb", "mt", "tr", "ml", "rn", "m", "MT", "lc", "rpm", "drm"], "addr": ["wid", "oad", "hw", "inter", "as", "ad", "ort", "tx", "adr", "address", "ref", "hash", "arp", "pad", "rs", "ow", "map", "id", "var", "act", "ack", "ace", "alias", "res", "arr", "ord", "add", "coord", " address", "art", "ast", "align", "eth", "a", "ak", "attr", "ag", "ip", "src", "url", "ash", "ha", "mt", "ptr", "offset", "ress", "ix"], "size": ["range", "sn", "ms", "length", " sizes", "len", "code", "fee", "iz", "storage", "body", "sha", "gz", "mem", "count", "ize", "mode", "small", "s", "sh", "bytes", "set", "area", "sec", "shape", "scale", "SIZE", "z", "Size", "sized", "offset", "max", "sum", "sy", "sq", "m", "name"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void vnc_display_print_local_addr(VncDisplay *vd)\n\n{\n\n    SocketAddressLegacy *addr;\n\n    Error *err = NULL;\n\n\n\n    if (!vd->nlsock) {\n\n        return;\n\n    }\n\n\n\n    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);\n\n    if (!addr) {\n\n        return;\n\n    }\n\n\n\n    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {\n\n        qapi_free_SocketAddressLegacy(addr);\n\n        return;\n\n    }\n\n    error_printf_unless_qmp(\"VNC server running on %s:%s\\n\",\n\n                            addr->u.inet.data->host,\n\n                            addr->u.inet.data->port);\n\n    qapi_free_SocketAddressLegacy(addr);\n\n}\n", "idx": 26003, "substitutes": {"vd": ["sd", "pd", "hd", "ld", "xd", "nd", "dll", "d", "erd", "rd", "vv", "wd", "VD", " sd", "md", "uds", "ed", "ve", "dt", "vr", "kb", " od", "cod", "td", "gd", "nv", "vc", "dl", "vid", "dd", "bd", "udi", "dn", "gb", "du", "ud", " dd", "vt", "uv", "v", "lv", "od"], "addr": ["hd", "alt", "address", "sta", "host", "att", "map", "gate", "ar", "arr", "call", "pos", "attr", "work", "expr", "loc", "ame", "mt", "ptr", "pkg", "ress", "obj", "adr", "conn", "rs", "gt", "rev", "at", "rr", "mk", "func", "ace", "add", "inv", " address", "tag", "eth", "ach", "ak", "ag", "ash", "iter", "aaa", "hw", "ld", "arp", "pad", "kt", "nl", "act", "ah", "alias", "coord", "a", "dr", "alloc", "url", "Address", "adj", "kl", "elt", "oa", "aw", "grad", "ad", "news", "ref", "hash", "ext", "cmd", "md", "ack", "ord", "usr", "order", "align", "am", "ac", "hl", "u", "aj"], "err": ["ch", "ef", "ev", "conn", "fee", "rs", "erd", "fr", "Error", "er", " terr", "rr", "error", "ah", "r", "ar", "oe", "arr", "kr", "resp", "msg", "usr", "buf", "bar", "die", "req", "attr", "urg", "dr", "mr", "cr", " er", " Err", "iter", "aaa", "e", "der", "ptr", "Er", "exc", "rn", "warn", "res"]}}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_lstat(FsContext *fs_ctx,\n\n                            V9fsPath *fs_path, struct stat *stbuf)\n\n{\n\n    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;\n\n\n\n    v9fs_synth_fill_statbuf(node, stbuf);\n\n    return 0;\n\n}\n", "idx": 26008, "substitutes": {"fs_ctx": ["fs2tx", "fs__ctx", " fs2obj", "fs2ctx", "fs__obj", " fs_context", "fs_tx", "fs_context", "fs_obj", "fs2context", " fs2tx", "fs2obj", "fs__tx", " fs_obj", "fs__context", " fs_tx", " fs2ctx", " fs2context"], "fs_path": ["fs2Path", "fs_stream", "fs2ctx", "fsmyPath", "sys_context", "fs2path", "sys_path", " fs2Path", " fs_context", "fs_context", "fsmypath", " fs_stream", "fs2context", "fsmystream", " fs2stream", "sys_ctx", "fs_Path", " fs_Path", " fs2path", "fsmycontext", " fs2context", "fs2stream", "sys_Path"], "stbuf": ["stdbuffer", "strbuf", "strcap", "istcv", "stdbuff", "stcv", "istcap", " stbuffer", " stcv", "istbuff", "stcap", "stdcv", "istbuf", "strbuff", "strbuffer", " stcap", "stdbuf", "stbuff", " stbuff", "istbuffer", "stbuffer"], "node": ["tree", "job", "our", "field", "server", "brain", "box", "nb", "child", "cell", "normal", "component", "valid", "object", "local", "now", "row", "Node", "good", "ack", "n", "db", "cache", "shot", "msg", "root", "slave", "proc", "bar", "session", "np", "and", "line", "ode", "data", "nt", "post", "window", "link", "leaf", "t", "tmp", "manager", "index", "aw"]}}
{"project": "FFmpeg", "commit_id": "f2e9a0ecbef5027f9532c49ffcdfc11d199f6150", "target": 1, "func": "static av_cold int qsv_decode_close(AVCodecContext *avctx)\n{\n    QSVOtherContext *s = avctx->priv_data;\n    ff_qsv_decode_close(&s->qsv);\n    qsv_clear_buffers(s);\n    av_fifo_free(s->packet_fifo);\n    return 0;\n}", "idx": 26030, "substitutes": {"avctx": ["avecontext", " avctl", "svcontext", "svjac", "Avctx", "avctl", "Avcontext", "camcontext", "avjac", "avectx", " avjac", " avtxt", "avtxt", "avkw", "camkw", "camjac", "Avctl", "avectl", "camctx", " avkw", "svkw", " avcontext", "avetxt", "avcontext", "Avtxt", "svctx"], "s": ["sys", "cl", "sb", "os", "fs", "rs", "c", "ds", "hs", "g", "p", "sc", "cs", "sts", "ares", "set", "aws", "j", "S", "als", "js", "bs", "ss", "a", "is", "ats", "b", "ts", "ns", "ps", "acs", "qs", "es", "its", "gs", "less", "sv", "h", "ls", "q", "m", "v", "sq", "ess"]}}
{"project": "FFmpeg", "commit_id": "c83002a4f8042ccfa0688a9a18e8fa0369c1fda8", "target": 1, "func": "int ff_ass_split_override_codes(const ASSCodesCallbacks *callbacks, void *priv,\n\n                                const char *buf)\n\n{\n\n    const char *text = NULL;\n\n    char new_line[2];\n\n    int text_len = 0;\n\n\n\n    while (*buf) {\n\n        if (text && callbacks->text &&\n\n            (sscanf(buf, \"\\\\%1[nN]\", new_line) == 1 ||\n\n             !strncmp(buf, \"{\\\\\", 2))) {\n\n            callbacks->text(priv, text, text_len);\n\n            text = NULL;\n\n        }\n\n        if (sscanf(buf, \"\\\\%1[nN]\", new_line) == 1) {\n\n            if (callbacks->new_line)\n\n                callbacks->new_line(priv, new_line[0] == 'N');\n\n            buf += 2;\n\n        } else if (!strncmp(buf, \"{\\\\\", 2)) {\n\n            buf++;\n\n            while (*buf == '\\\\') {\n\n                char style[2], c[2], sep[2], c_num[2] = \"0\", tmp[128] = {0};\n\n                unsigned int color = 0xFFFFFFFF;\n\n                int len, size = -1, an = -1, alpha = -1;\n\n                int x1, y1, x2, y2, t1 = -1, t2 = -1;\n\n                if (sscanf(buf, \"\\\\%1[bisu]%1[01\\\\}]%n\", style, c, &len) > 1) {\n\n                    int close = c[0] == '0' ? 1 : c[0] == '1' ? 0 : -1;\n\n                    len += close != -1;\n\n                    if (callbacks->style)\n\n                        callbacks->style(priv, style[0], close);\n\n                } else if (sscanf(buf, \"\\\\c%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\c&H%X&%1[\\\\}]%n\", &color, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]c%1[\\\\}]%n\", c_num, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]c&H%X&%1[\\\\}]%n\", c_num, &color, sep, &len) > 2) {\n\n                    if (callbacks->color)\n\n                        callbacks->color(priv, color, c_num[0] - '0');\n\n                } else if (sscanf(buf, \"\\\\alpha%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\alpha&H%2X&%1[\\\\}]%n\", &alpha, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]a%1[\\\\}]%n\", c_num, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]a&H%2X&%1[\\\\}]%n\", c_num, &alpha, sep, &len) > 2) {\n\n                    if (callbacks->alpha)\n\n                        callbacks->alpha(priv, alpha, c_num[0] - '0');\n\n                } else if (sscanf(buf, \"\\\\fn%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\fn%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) {\n\n                    if (callbacks->font_name)\n\n                        callbacks->font_name(priv, tmp[0] ? tmp : NULL);\n\n                } else if (sscanf(buf, \"\\\\fs%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\fs%u%1[\\\\}]%n\", &size, sep, &len) > 1) {\n\n                    if (callbacks->font_size)\n\n                        callbacks->font_size(priv, size);\n\n                } else if (sscanf(buf, \"\\\\a%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\a%2u%1[\\\\}]%n\", &an, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\an%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\an%1u%1[\\\\}]%n\", &an, sep, &len) > 1) {\n\n                    if (an != -1 && buf[2] != 'n')\n\n                        an = (an&3) + (an&4 ? 6 : an&8 ? 3 : 0);\n\n                    if (callbacks->alignment)\n\n                        callbacks->alignment(priv, an);\n\n                } else if (sscanf(buf, \"\\\\r%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\r%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) {\n\n                    if (callbacks->cancel_overrides)\n\n                        callbacks->cancel_overrides(priv, tmp);\n\n                } else if (sscanf(buf, \"\\\\move(%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, sep, &len) > 4 ||\n\n                           sscanf(buf, \"\\\\move(%d,%d,%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, &t1, &t2, sep, &len) > 6) {\n\n                    if (callbacks->move)\n\n                        callbacks->move(priv, x1, y1, x2, y2, t1, t2);\n\n                } else if (sscanf(buf, \"\\\\pos(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) {\n\n                    if (callbacks->move)\n\n                        callbacks->move(priv, x1, y1, x1, y1, -1, -1);\n\n                } else if (sscanf(buf, \"\\\\org(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) {\n\n                    if (callbacks->origin)\n\n                        callbacks->origin(priv, x1, y1);\n\n                } else {\n\n                    len = strcspn(buf+1, \"\\\\}\") + 2;  /* skip unknown code */\n\n                }\n\n                buf += len - 1;\n\n            }\n\n            if (*buf++ != '}')\n\n                return AVERROR_INVALIDDATA;\n\n        } else {\n\n            if (!text) {\n\n                text = buf;\n\n                text_len = 1;\n\n            } else\n\n                text_len++;\n\n            buf++;\n\n        }\n\n    }\n\n    if (text && callbacks->text)\n\n        callbacks->text(priv, text, text_len);\n\n    if (callbacks->end)\n\n        callbacks->end(priv);\n\n    return 0;\n\n}\n", "idx": 26031, "substitutes": {"callbacks": ["functionators", "cachebacks", "callingands", "callboards", "cacheabases", "callators", "callingables", "coinboards", "callosures", " Callabases", " callrers", "callors", "coineners", "callingbs", "functionosures", "callingchecks", "labeners", "allchers", "callingbanks", "labands", "allators", "cobs", "Callback", " Callboards", "callbackbacks", "codbacks", "callables", "callingchers", "callblocks", "cochecks", "callplugins", "callabases", "callbackblocks", "coinbacks", "coinbs", "cachebs", "callingrers", "codback", "callingosures", "liceners", " Callplugins", " callers", "callback", "canbs", "allosures", " Callbacks", " Callbs", " Callables", "callingors", "coinbanks", "callingers", " callsbacks", "callers", "licands", "Callables", "functionbs", "callingators", "callingplugins", "callchecks", "canbanks", "callbanks", "cacheboards", "callbackables", "coinabases", "callbs", "callands", "callchers", " callplugins", " callblocks", "licors", "calleners", " callsers", "caneners", "licbacks", "allbacks", "callingeners", "callrers", "callingbacks", "Callbacks", " callbs", "functionbacks", "callingblocks", " callsrers", "allchecks", "callbackplugins", "cochers", "labbacks", "cobacks", " callback", " callables", "codables", "allbs", "canbacks", "labors"], "priv": ["sys", "prop", "pack", "rib", "pb", "pub", "pri", "conn", "pi", "rc", "rev", "dev", "pr", "mem", "var", "password", "cp", "cert", "pg", "org", "prefix", "pdf", "usr", "cb", "ctx", "policy", "phys", "sec", "private", "req", "Priv", "attr", "trust", "public", "nick", "txt", "alloc", "access", "pro", "sp", "deb", "cap", "reader", " Priv", "ptr", "pkg", "riv", "vt", "proc", "env", "conf"], "buf": ["paren", "cur", "pb", "queue", "ctr", "buffer", "mem", "var", "pool", "pg", "ctx", "pos", "raw", "orig", "wb", "src", "front", "history", "bt", "pkg", "ptr", "xff", "env", "pack", "tx", "emb", "canon", "br", "term", "bang", "bc", "rev", "bf", "cast", "cat", "Buff", "msg", "brace", "bar", "next", "desc", "quote", "aka", "bur", "bin", "iter", "bp", "Buffer", "buff", "fb", "batch", "length", "cam", "box", "bound", "pad", "def", "read", "keep", "bytes", "coord", "vec", "bs", "doc", "b", "old", "addr", "limit", "rb", "kw", "off", "str", "cv", "lit", "err", "nm", "home", "ref", "uf", "foo", "rc", "row", "cmd", "img", "cb", "usr", "np", "bu", "bn", "req", "port", "txt", "num", "cap", "etc", "loop", "proc", "conv"], "text": ["TEXT", "context", "type", "length", "x", "tx", "Text", "br", "font", "code", "term", "entry", "config", "value", "read", "word", "event", "cont", "buffer", "title", "command", "ty", "path", "translation", "empty", "ext", "comment", "p", "phrase", "close", "tab", "prefix", "msg", "ut", "write", "binary", "message", "image", "tag", "print", "inner", "old", "data", "ct", "quote", "nt", "ind", "color", "txt", "select", "button", "writer", "buff", "t", "content", "format", "str", "name"], "new_line": ["ew_LINE", "newableline", "new_block", "New_lines", "new_lin", "newablechar", "newerlink", "new_link", " new_tab", "new_Line", "new_row", "newablelines", " new_lin", "new_tab", "ew_row", "newerline", "newerLine", "ew_Line", "newletline", "newablelin", "New_Line", "new_char", "New_char", "new_LINE", " new_lines", "newletlines", "ew_line", "New_link", "new_lines", "newerlines", "New_line", "newlettab", " new_block", "newletblock", " new_LINE", "New_lin"], "text_len": ["text_length", "text_ln", " text_Len", "text_gen", "txt_len", "txt_ln", "txt_Len", "text_Len", " text_mem", "text_mem", " text_gen", "txt_length"], "style": ["class", "block", "type", "css", "prop", "o", "make", "sty", "font", "se", "code", "try", "feature", "status", "tc", "date", "ty", "sl", "Style", "estyle", "top", "comment", "family", "close", "mode", "s", "state", "sh", "sche", "set", "sort", "te", "magic", "show", "light", "tag", "rule", "image", "ss", "html", "script", "file", "line", "py", "start", "size", "weight", "attr", "color", "lib", "link", "styles", "theme", "shadow", "head", "si", "t", "stat", "format", "lock", "name", "role", "parse"], "c": ["f", "ic", "ch", "css", "o", "cu", "code", "col", "w", "tc", "rc", "dc", "g", "r", "cmd", "n", "p", "cp", "cache", "count", "close", "s", "cs", "cb", "ctx", "cod", "co", "a", "comp", "b", "ct", "l", "ac", "unc", "color", "con", "fc", "e", "h", "t", "cc", "C", "v", "m"], "sep": [" sexp", "peg", "serm", "eleper", " seper", "eleep", "lookp", "seit", " sepa", "pepa", "psexp", "seep", "gep", "geit", "sexxp", "peit", "sexm", "serper", "elep", "lookpa", "peep", "seg", "sepa", "sem", "serep", "elem", "geep", "pexp", "serp", " seep", "sexp", " sem", "geg", "seper", "pem", "lookep", "pep", " seg", "psep", "pseg", "sexg", "lookg", " seit"], "c_num": ["c_number", "cp_ref", "c_um", "co_sum", "c_sum", "c__mon", "c_ref", "co_no", "c2no", "c_Num", "c2num", "c__n", "c_no", "cp_um", "c2um", " c_ver", " c_n", "c_n", "c_index", "co_num", " c_Num", "c__Num", "cp_nam", "c_ver", " c_number", "c_nam", " c_index", "cp_num", " c_mon", "c__num", "co_um", "c_mon", "c2sum"], "tmp": ["cur", "cmp", "obj", "temp", "mp", "tc", "rc", "tt", "params", "sup", "cp", "cache", "img", "prefix", "cb", "extra", "ctx", "np", "td", "html", "test", "gb", "sp", "etc", "buff", "uv", "proc", "cv"], "len": ["wid", "dim", "length", "cmp", "lit", "den", "ld", "gen", "args", "err", "ll", "ref", "syn", "ln", "ann", "ell", "rev", "mem", "del", "sl", "fin", "seq", "mon", "cmd", "n", "cp", "count", "fn", "Len", "cond", "p", "compl", "msg", "mat", "bytes", "par", "open", "call", "lon", "pos", "lif", "cod", "vec", "depth", "align", "last", "line", "comp", "l", "size", "fun", "vals", "lib", "la", "lim", "link", "num", "sp", "val", "gl", "en", "cap", "label", "rot", "lp", "xff", "ls", "elt", "no", "ler"], "x1": [" x4", "y4", "p4", "x4", "p2", "p1"], "y1": ["t2", "x0", " y0", "x01", "y01", " y01", "t01", "t0", "y0", "t1"], "x2": ["xs2", "xs1", "rx02", "x02", " x02", "rx2", "xs02", "rx1"], "y2": ["y6", "i2", "x4", "y4", "x6", "i4", " y4", " y6", "i6", "i1"]}}
{"project": "FFmpeg", "commit_id": "2453f40602dd6f5fa670954ee733a4155675f645", "target": 1, "func": "static void compute_scale_factors(unsigned char scale_code[SBLIMIT],\n\n                                  unsigned char scale_factors[SBLIMIT][3],\n\n                                  int sb_samples[3][12][SBLIMIT],\n\n                                  int sblimit)\n\n{\n\n    int *p, vmax, v, n, i, j, k, code;\n\n    int index, d1, d2;\n\n    unsigned char *sf = &scale_factors[0][0];\n\n\n\n    for(j=0;j<sblimit;j++) {\n\n        for(i=0;i<3;i++) {\n\n            /* find the max absolute value */\n\n            p = &sb_samples[i][0][j];\n\n            vmax = abs(*p);\n\n            for(k=1;k<12;k++) {\n\n                p += SBLIMIT;\n\n                v = abs(*p);\n\n                if (v > vmax)\n\n                    vmax = v;\n\n            }\n\n            /* compute the scale factor index using log 2 computations */\n\n            if (vmax > 0) {\n\n                n = av_log2(vmax);\n\n                /* n is the position of the MSB of vmax. now\n\n                   use at most 2 compares to find the index */\n\n                index = (21 - n) * 3 - 3;\n\n                if (index >= 0) {\n\n                    while (vmax <= scale_factor_table[index+1])\n\n                        index++;\n\n                } else {\n\n                    index = 0; /* very unlikely case of overflow */\n\n                }\n\n            } else {\n\n                index = 62; /* value 63 is not allowed */\n\n            }\n\n\n\n#if 0\n\n            printf(\"%2d:%d in=%x %x %d\\n\",\n\n                   j, i, vmax, scale_factor_table[index], index);\n\n#endif\n\n            /* store the scale factor */\n\n            assert(index >=0 && index <= 63);\n\n            sf[i] = index;\n\n        }\n\n\n\n        /* compute the transmission factor : look if the scale factors\n\n           are close enough to each other */\n\n        d1 = scale_diff_table[sf[0] - sf[1] + 64];\n\n        d2 = scale_diff_table[sf[1] - sf[2] + 64];\n\n\n\n        /* handle the 25 cases */\n\n        switch(d1 * 5 + d2) {\n\n        case 0*5+0:\n\n        case 0*5+4:\n\n        case 3*5+4:\n\n        case 4*5+0:\n\n        case 4*5+4:\n\n            code = 0;\n\n            break;\n\n        case 0*5+1:\n\n        case 0*5+2:\n\n        case 4*5+1:\n\n        case 4*5+2:\n\n            code = 3;\n\n            sf[2] = sf[1];\n\n            break;\n\n        case 0*5+3:\n\n        case 4*5+3:\n\n            code = 3;\n\n            sf[1] = sf[2];\n\n            break;\n\n        case 1*5+0:\n\n        case 1*5+4:\n\n        case 2*5+4:\n\n            code = 1;\n\n            sf[1] = sf[0];\n\n            break;\n\n        case 1*5+1:\n\n        case 1*5+2:\n\n        case 2*5+0:\n\n        case 2*5+1:\n\n        case 2*5+2:\n\n            code = 2;\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        case 2*5+3:\n\n        case 3*5+3:\n\n            code = 2;\n\n            sf[0] = sf[1] = sf[2];\n\n            break;\n\n        case 3*5+0:\n\n        case 3*5+1:\n\n        case 3*5+2:\n\n            code = 2;\n\n            sf[0] = sf[2] = sf[1];\n\n            break;\n\n        case 1*5+3:\n\n            code = 2;\n\n            if (sf[0] > sf[2])\n\n              sf[0] = sf[2];\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        default:\n\n            assert(0); //cannot happen\n\n            code = 0;           /* kill warning */\n\n        }\n\n\n\n#if 0\n\n        printf(\"%d: %2d %2d %2d %d %d -> %d\\n\", j,\n\n               sf[0], sf[1], sf[2], d1, d2, code);\n\n#endif\n\n        scale_code[j] = code;\n\n        sf += 3;\n\n    }\n\n}\n", "idx": 26038, "substitutes": {"scale_code": [" scale_operator", "scale_codes", "scale_factor", "scale_operator", "scaleitycode", " scale_factor", " scale_codes", "scaleityoperator", "scaleityfactor", "scaleitycodes"], "scale_factors": ["scale_ctories", "scale_factsors", "scale_ctters", "scale_factories", "scale_ctorset", "scale_factor", "scale_actor", "scale_factsters", "scale_factorset", "scale_ctors", "scale_factters", "scale_factsorset", "scale_Factor", "scale_actores", "scale_actories", "scale_Factories", "scale_actters", "scale_Factores", "scale_factsories", "scale_actors", "scale_actorset", "scale_Factors", "scale_factores"], "sb_samples": ["sb2examples", "sb_samamples", "sb_samources", "sb_tources", "sb2sources", "sb2examps", "sb2exources", "sb_sources", "sb_samamps", "sb_seamps", "sb_exources", "sb_seources", "sb_ssources", "sb_sores", "sb2exores", "sb_seamples", "sb_tamps", "sb_saces", "sb_samps", "sb_examps", "sb_ssamps", "sb_examples", "sb_tamples", "sb2samps", "sb2sores", "sb_ssamples", "sb_ssores", "sb2samples", "sb_samaces", "sb_taces", "sb_seores", "sb_seaces", "sb_exores"], "sblimit": ["sblemIT", "splemit", "sblemify", "sblIMIT", "splimitate", "sbllimIT", "sblumite", "sblumIT", "sblIMitate", "sblIMit", "splemitate", "splimit", "sblIMite", "sblemite", "sflumit", "splimify", "sflimit", "sblimIT", "sblumiter", "splemIT", "sflumIT", "sflumiter", "sblimify", "sblemit", "sblIMiter", "sblimite", "sblIMify", "sblimiter", "sbllimify", "sbllimit", "splemify", "sblumit", "sflimIT", "sblemitate", "sflimiter", "sblemiter", "sbllimitate", "splimIT", "sflumite", "sflimite", "sblimitate"], "p": ["f", "ping", "prop", "pm", "x", "perm", "pb", "point", "power", "ph", "op", "pc", "d", "vp", "part", "pp", "pi", "c", "pr", "g", "pers", "cp", "par", "ap", "pe", "pair", "pl", "rep", "ps", "ip", "y", "pa", "wp", "tp", "bp", "u", "pkg", "lp", "P", "jp", "t", "q", "m", "pt", "parse"], "vmax": ["vmin", "qvprint", "nax", " vgt", "vMAX", "volMAX", "Vmax", "nMAX", " vmin", "vdefault", " vdefault", "avright", "vgt", "avax", "avMAX", " vconf", "Vright", "nmax", "vpy", "volmin", "svpy", "volgt", "Vgt", "VMax", "volmax", "nMax", "svmax", "cvprint", "vconf", "Vmin", "svmin", "svax", "vprint", " vax", "Vax", "vMax", " vpy", "qvconf", "vax", "svMax", " vprint", "nmin", "qvdefault", "volpy", "vright", "VMAX", "cvdefault", " vMAX", "volMax", " vMax", "svgt", "avMax", "avmax", " vright", "qvmax", "svMAX", "cvconf", "cvmax"], "v": ["f", "vm", "ov", "x", "values", "conv", "ev", "lv", "iv", "d", "vert", "vp", "tv", "w", "value", "dev", "vv", "ve", "ver", "va", "vol", "vr", "vs", "inv", "vo", "av", "V", "nv", "l", "vc", "y", "val", "sv", "u", "qv", "vi", "h", "q", "vt", "uv", "m", "cv"], "n": ["sn", "na", "x", "nn", "nm", "nd", "len", "nan", "d", "nb", "nr", "w", "c", "nl", "ng", "g", "r", "nc", "Ni", "cn", "nw", "nu", "np", "ot", "ne", "b", "nv", "ns", "size", "l", "nt", "y", "mn", "N", "num", "net", "max", "q", "t", "no", "m"], "i": ["f", "it", "iat", "ic", "x", "out", "multi", "ki", "o", "point", "ik", "ie", "ami", "pi", "ini", "id", "ex", "ia", "at", "c", "ri", "um", "jj", "in", "me", "I", "phi", "io", "s", "di", "zi", "ai", "mi", "ii", "li", "iq", "a", "is", "init", "ti", "ind", "l", "b", "ip", "ij", "y", "bi", "ci", "z", "e", "by", "iu", "xi", "si", "im", "q", "t", "m", "qi", "ix"], "j": ["ji", "f", "it", "job", "x", "o", "obj", "ja", "jump", "br", "aj", "d", "uj", "bo", "c", "dj", "fr", "g", "r", "jo", "kj", "to", "jit", "J", "js", "bs", "jc", "b", "l", "ind", "bi", "ij", "y", "bj", "key", "z", "json", "str", "e", "ret", "off", "be", "jp", "t", "q", "jj", "jl", "m", "h", "ion"], "k": ["kin", "ku", "kk", "ki", "ok", "ik", "kn", "km", "ph", "ka", "ko", "ke", "tk", "c", "kt", "unk", "mk", "ks", "wk", "g", "ck", "kh", "kr", "K", "kj", "sk", "kick", "uk", "ak", "b", "ac", "kid", "key", "z", "kw", "kind", "kl", "q", "t", "m", "ijk", "ek"], "code": ["note", "codes", "type", "ch", "action", "length", "force", "ce", "definition", "condition", "status", "try", "component", "entry", "cause", "c", "change", "cycle", "id", "error", "event", "command", "comment", "header", "coe", "count", "close", "use", "state", "Code", "call", " Code", "function", "pos", "message", "cod", "sequence", "tag", "next", "ode", "test", "ind", "size", "data", "desc", "info", "reason", "key", "check", "label", "second", "offset", "description", "content", "cc", "name", "sign", "one"], "index": ["address", "status", "id", "connect", "ice", "gate", "count", "open", "pos", "write", "location", "size", "info", "page", "loc", "link", "draw", "max", "note", "zone", "search", "condition", "try", "value", "error", "close", "state", "EX", "Index", "level", "shape", "ind", "key", "iter", "scroll", "label", "offset", "timeout", "point", "lock", "ix", "type", "length", "x", "network", "update", "cycle", "axis", "node", "capacity", "is", "test", "time", "number", "iso", "second", "option", "out", "slice", "success", "ex", "change", "result", "date", "zero", "find", "row", "list", "initial", "set", "order", "instance", "connection", "scan", "start", "port", "position", "num", "val", "check", "seed", "loop", "ion"], "d1": [" d0", "n5", " d5", "fdOne", "d7", "v7", "D1", "dup", "bd5", " done", "fdone", "none", "Done", "d0", "done", "bd2", "bd1", "n1", "bdOne", " d7", "d5", "bdone", "DOne", "v1", "fd2", "bd0", "fd1", "vup", "v5", " dup", "D2", "doup", "do1", "n0", "dOne", "do7", "do5"], "d2": [" d5", "D1", "bd5", "D3", "d3", "D02", " d3", "n2", "bd2", "Dtwo", "da3", "dd02", "d02", "bd42", "dd3", "dd2", " dtwo", "d5", "n02", "ntwo", "da2", "da42", " d42", " d02", "da5", "dtwo", "d42", "bd3", "D2", "dd1"], "sf": ["f", "fx", "sn", "sd", "hw", "ssh", "alf", "sb", "SF", "cf", "pb", "see", "rm", "fw", "fy", "uf", "csv", "fee", "fs", "sol", "tf", "stab", "vp", "bf", "ty", "ds", "hs", "scl", "sl", "fi", "fm", "sr", "lf", "supp", "ctl", "ze", "qq", "sh", "sw", "sql", "df", "rf", "sk", "ss", "xf", "php", "sm", "isf", "bj", "fd", "tif", "sp", "gs", "sv", "tp", "fo", "buff", "ief", "zz", "si", "rn", "sy", "sq", "ssl"]}}
{"project": "qemu", "commit_id": "2fb50a33401a2415b71ddc291e8a77bcd2f9e547", "target": 0, "func": "static void armv7m_nvic_clear_pending(void *opaque, int irq)\n\n{\n\n    NVICState *s = (NVICState *)opaque;\n\n    VecInfo *vec;\n\n\n\n    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);\n\n\n\n    vec = &s->vectors[irq];\n\n    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);\n\n    if (vec->pending) {\n\n        vec->pending = 0;\n\n        nvic_irq_update(s);\n\n    }\n\n}\n", "idx": 26059, "substitutes": {"opaque": [" opoch", "oppaques", "ipane", " opossibly", " opaques", "obaque", "obossibly", "onetaque", "oppane", "oboch", "onetoch", " opane", "onetossibly", "obaques", "opane", "opossibly", "ipaque", "onetaques", "opoch", "ipaques", "oppaque", "opaques"], "irq": ["ibrquire", "earQ", "rirdq", "irtq", "irtqu", "irmq", "irforce", " sirq", " irqu", "irtquest", "irQ", "irque", "ibrq", "irqu", "pirquire", "irquest", "pirdq", "rinQ", "pirqu", "ibrqu", "iorq", "pirquest", " irquest", "iroq", "irqi", "iraqu", "irmquire", "iordq", "irmquest", "pirq", "rirqi", "earq", " sirqi", "rrquire", "iraforce", "irqq", "pirforce", " sirqu", "rirq", "rrQ", "earqq", "irquire", "ibrquest", "irdq", "rinqq", " irque", "iroque", "rinq", "iorquest", " sirforce", "earquire", "iraq", "irmqu", "irtque", "rrq", "rirquest", "rinquire", "iraqi", "iroquest", "rrqq", "iorqi", "pirqi", "iroqu"], "s": ["sys", "i", "sa", "sb", "sis", "syn", "se", "comm", "fs", "sol", "v", "rs", "c", "sam", "ses", "ds", "hs", "sl", "g", "r", "spec", "p", "soc", "sc", "cs", "sts", "sim", "iss", "S", "vs", "als", "js", "bs", "ss", "so", "ts", "ns", "ps", "sm", "acs", "stats", "gs", "less", "sv", "serv", "self", "h", "ls", "t", "m", "sq", "ess"], "vec": ["rib", "cam", "conv", "ev", "lv", "iv", "vert", "vp", "def", "kt", "veh", "rev", "crit", "virt", "vv", "dev", "var", "ec", "seq", "verb", "sel", "miss", "cast", "cmd", "VID", "spec", "ver", "ve", "buf", "vr", "resh", "vs", "enc", "Vector", "js", "vo", "vy", "ele", "wcs", "nv", "desc", "vc", "feat", "req", "expr", "des", "coll", "vector", "serv", "sv", "val", "ret", "buff", "vi", "vt", "uv", "v", "vet", "cv", "vre"]}}
{"project": "qemu", "commit_id": "363e13f86eb60bce1e112a35a4c107505a69c9fe", "target": 0, "func": "static void vararg_string(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *decoded;\n\n    } test_cases[] = {\n\n        { \"hello world\" },\n\n        { \"the quick brown fox jumped over the fence\" },\n\n        {}\n\n    };\n\n\n\n    for (i = 0; test_cases[i].decoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_jsonf(\"%s\", test_cases[i].decoded);\n\n\n\n        g_assert(obj != NULL);\n\n        g_assert(qobject_type(obj) == QTYPE_QSTRING);\n\n        \n\n        str = qobject_to_qstring(obj);\n\n        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);\n\n\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 26061, "substitutes": {"i": ["ui", " j", " di", " multi", " info", "status", "ini", " iter", "I", " bi", "sim", "ai", " li", "li", "info", "ij", "y", " mi", "ci", " si", "iu", " I", "si", "ei", "ji", "ki", "\u0438", " x", " ni", " ii", "asi", "chain", "ind", "ims", " im", "iter", "uri", "m", "qi", "ix", "my", "batch", "x", "multi", " p", "yi", "ri", "phi", "di", "oi", "zi", " err", "mi", "ii", "is", " ti", " pi", "bi", " index", " m", "xi", "im", "it", "ic", "pi", " id", " n", "fi", "me", "gi", " my", "list", "hi", "ti", "e", " wi", "index", "cli", "init"], "decoded": ["decrypted", " decaled", "descrypted", "deccoded", "deressed", "decressed", " deccoded", "decanded", "strcoded", " decrypted", "strleted", "encaled", "enccoded", "descanded", "stroded", "deanded", "Decoded", "strrypted", "Decressed", "encoded", "Deccoded", "descode", "encode", "decaled", "encanded", "encleted", "descressed", "Decrypted", "decode", "deoded", " decode", "descoded", "derypted", "decleted", " decleted", "encrypted", "descaled", "desccoded"], "test_cases": ["dev_bags", "Test_times", "test5case", "test_lets", "test__cases", "test__caps", "test5posts", "dev__bags", "dev_steps", "test67case", "Test_case", "test67times", "testcasecases", "test__steps", "dev__caps", "test_times", "test5atts", "Test_cases", " test_times", "testcaseatts", " test_atts", "test_bags", "test_posts", "dev__steps", "test_caps", "test_atts", "test67lets", "test5cases", "testcaseposts", "test__bags", "dev_cases", "test_case", "testcasecase", " test_case", "test67cases", " test_lets", "dev__cases", "test_steps", "dev_caps", " test_posts"], "obj": ["it", "out", "o", "xy", "po", "stick", "os", "utt", "att", "ent", "obo", "bo", "tk", "cont", "object", "og", "wo", "pr", "act", "inst", "cmd", "db", "n", "arr", "img", "org", "Object", "ob", "rect", "resp", "ut", "j", "et", "Obj", "ctx", "nu", "pl", "np", "js", "cod", "oid", "so", "nt", "bj", "ox", "txt", "oj", "bh", "imp", "rb", "copy", "obs", "ist", "adj", "pkg", "buff", "tmp", "t", "elt", "ot", "onet", "pt", "od"], "str": ["priv", "out", "nm", "err", "bl", "temp", "br", "fr", "ctr", "cont", "buffer", "pr", "sl", "seq", "g", "r", "n", "arr", "s", "gr", "vol", "sts", "msg", "rel", "sw", "buf", "j", "String", "enc", "bs", "print", "desc", "ns", "dr", "cr", "dat", "txt", "text", "url", "st", "sp", "mt", "tr", "t", "pt", "Str", "jp", "v", "name", "STR"]}}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_qdev_exit(DeviceState *qdev)\n\n{\n\n    SCSIDevice *dev = SCSI_DEVICE(qdev);\n\n\n\n    if (dev->vmsentry) {\n\n        qemu_del_vm_change_state_handler(dev->vmsentry);\n\n    }\n\n    scsi_device_destroy(dev);\n\n    return 0;\n\n}\n", "idx": 26069, "substitutes": {"qdev": ["qqpad", "Qdata", "qqdev", "qev", "qudef", "qpad", " qdata", "gdef", "gpad", "Qdef", "qdef", "qudevice", "qudev", "gdev", "iqdef", "qudata", " qdevice", "iqpad", "Qdevice", " qdef", "iqdev", "iqev", "qdata", "qqdef", "qdevice", "gev", "qqev", "Qdev"], "dev": ["priv", "sd", "block", " priv", "device", " env", "tech", "cam", "obj", " prod", "ev", "pub", "app", "d", "pad", "adv", "def", " device", "sky", "local", "mem", "var", "gu", "comment", "md", "det", "DEV", "ver", "cmd", "spec", "van", "develop", " def", "go", " des", "form", "av", "raw", "doc", "desc", "de", "nt", "des", "dem", "Dev", "pro", "aux", "serial", "serv", "unknown", " devs", "dep", "v", " vo", "hw"]}}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int gen_sub_bitmap(TeletextContext *ctx, AVSubtitleRect *sub_rect, vbi_page *page, int chop_top)\n\n{\n\n    int resx = page->columns * BITMAP_CHAR_WIDTH;\n\n    int resy = (page->rows - chop_top) * BITMAP_CHAR_HEIGHT;\n\n    uint8_t ci, cmax = 0;\n\n    int ret;\n\n    vbi_char *vc = page->text + (chop_top * page->columns);\n\n    vbi_char *vcend = page->text + (page->rows * page->columns);\n\n\n\n    for (; vc < vcend; vc++) {\n\n        if (vc->opacity != VBI_TRANSPARENT_SPACE) {\n\n            cmax = VBI_NB_COLORS;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (cmax == 0) {\n\n        av_log(ctx, AV_LOG_DEBUG, \"dropping empty page %3x\\n\", page->pgno);\n\n        sub_rect->type = SUBTITLE_NONE;\n\n        return 0;\n\n    }\n\n\n\n    if ((ret = avpicture_alloc(&sub_rect->pict, AV_PIX_FMT_PAL8, resx, resy)) < 0)\n\n        return ret;\n\n    // Yes, we want to allocate the palette on our own because AVSubtitle works this way\n\n    sub_rect->pict.data[1] = NULL;\n\n\n\n    vbi_draw_vt_page_region(page, VBI_PIXFMT_PAL8,\n\n                            sub_rect->pict.data[0], sub_rect->pict.linesize[0],\n\n                            0, chop_top, page->columns, page->rows - chop_top,\n\n                            /*reveal*/ 1, /*flash*/ 1);\n\n\n\n    fix_transparency(ctx, sub_rect, page, chop_top, cmax, resx, resy);\n\n    sub_rect->x = ctx->x_offset;\n\n    sub_rect->y = ctx->y_offset + chop_top * BITMAP_CHAR_HEIGHT;\n\n    sub_rect->w = resx;\n\n    sub_rect->h = resy;\n\n    sub_rect->nb_colors = (int)cmax + 1;\n\n    sub_rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n\n    if (!sub_rect->pict.data[1]) {\n\n        av_freep(&sub_rect->pict.data[0]);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    for (ci = 0; ci < cmax; ci++) {\n\n        int r, g, b, a;\n\n\n\n        r = VBI_R(page->color_map[ci]);\n\n        g = VBI_G(page->color_map[ci]);\n\n        b = VBI_B(page->color_map[ci]);\n\n        a = VBI_A(page->color_map[ci]);\n\n        ((uint32_t *)sub_rect->pict.data[1])[ci] = RGBA(r, g, b, a);\n\n        av_dlog(ctx, \"palette %0x\\n\", ((uint32_t *)sub_rect->pict.data[1])[ci]);\n\n    }\n\n    ((uint32_t *)sub_rect->pict.data[1])[cmax] = RGBA(0, 0, 0, 0);\n\n    sub_rect->type = SUBTITLE_BITMAP;\n\n    return 0;\n\n}\n", "idx": 26075, "substitutes": {"ctx": ["sys", "iat", " cx", "context", "cmp", "tm", "tx", "cam", "obj", "cu", "jac", "Context", "ca", "conn", "qt", "c", "cpp", "tc", "kt", "ctr", "dc", "crit", "unk", "conf", "ck", "act", "ctrl", "cmd", "pool", "ctl", "cp", "sc", "nc", "resp", "msg", "cb", "cm", "np", "mom", "cfg", "req", "ct", "xc", "wcs", "cas", "addr", "kw", "net", "kg", "check", "pkg", "timeout", "tmp", "cc", "jp", "conv", "cv", "hw"], "sub_rect": ["subpyerr", "sub___rect", "sub_lat", " sub_dial", "sub_mod", "subthemod", "sub_cmd", "subjrest", "suburtr", "sub_dir", "sub_tr", "singobjcoll", "sing___rect", "subobjrest", "super_coord", "subjround", "Sub_dir", "sub_txt", "sub_obj", "Sub_tr", "sub_void", "subtherect", "subpyrect", "sub_Rect", "subobjregion", "singobjregion", "test_void", "sub_assert", "subthecoord", "short___dir", "Sub_rect", "sub_tip", "short_dir", "sing_desc", "sub_rest", "subvalregion", "sub___txt", "subpyassert", "short_rect", "sub___desc", "Sub_txt", "subPrdial", "short_dial", "subvalrest", "short___dial", "subPrrect", "sing_tar", " sub_region", "subletrect", " sub_Rect", "sub___tip", "srcpyrect", "suburRect", "subpycmd", " sub_hist", "src_rect", "subtassert", "subpyregion", "test_round", "sublettip", "srcpyerr", "subpylat", "singobjRect", "sub_round", "sub_err", "subpyRect", "singobjrect", "subpycoll", "subtrect", "subserverround", "subpyround", "suburrect", "Sub_cmd", "sub___Rect", "sub_tar", "subobjcoll", "subletdir", "sing_rect", "subtround", "homeserverround", "sub_dial", "test_rect", "sing_coll", "sub_desc", "sub___dial", "sub___tr", "subpyvoid", "homeserverrect", "sub_coll", "subobjRect", "suburtxt", "Sub_obj", "srcpyRect", "short_tip", "src_err", "sing_hist", "homeserverrest", "super_mod", "sing_region", "subvalobj", "subletdial", "subjrect", "home_round", "sub___dir", "Sub_lat", "home_tri", "home_rest", "subtvoid", " sub_rest", "sub_coord", "sub_hist", "subvalrect", "subserverrest", "subobjdial", "subobjrect", " sub_err", "subPrdir", "home_rect", " sub_mat", "subservertri", "sub___rest", "subPrtip", "src_Rect", "sing___Rect", "homeservertri", "sub_region", "sing_Rect", "sub_tri", "short___rect", "sub_mat", " sub_obj", "sing___desc", "test_assert", "super_rect", "Sub_Rect", "short___tip", "subjtri", "subserverrect"], "page": ["see", "address", "pp", "c", "word", "buffer", "office", "pool", "p", "pg", "pdf", "frame", "size", "document", "table", "v", "parent", "site", "code", "pty", "pc", "config", "pages", "pixel", "Page", "apache", "tab", "total", "next", "window", "meta", "net", "point", "ping", "device", "context", "network", "node", "cm", "go", "view", "application", "form", "doc", "file", "wikipedia", "number", "mu", "parse", "block", "web", "server", "pi", "date", "article", "event", "wait", "report", "row", "list", "phrase", "cache", "record", "plot", "module", "order", "message", "np", "image", "html", "line", "port", "post", "num", "wiki", "age"], "chop_top": ["chop_tops", "chopp_top", "chop_origin", "chumb_origin", "chhop_TOP", "chip_bottom", "chop___y", "chop_TOP", "chpop_tops", "chpop_bottom", "chop___origin", "chumb___y", "chang_client", "chumb___top", "chop__bottom", "chpop_to", "chop_to", "chopmmtop", "chop__top", "chop___top", "chip_below", "chumb___origin", "choppttop", "chumb___bottom", "chang_to", "chang_bottom", "chopp_upper", "chop_height", "chopmmbottom", "chop_below", "chop_html", "chop___bottom", "chpop_top", "chopp_bottom", "chumb_top", "chang_top", "chopptTOP", "chop_upper", "chumb_y", "chang_html", "chopmmbelow", "chopp__bottom", "chopptto", "chang_TOP", "chop__height", "chhop_offset", "chip_top", "chopp__upper", "chopptoffset", "chop__upper", "chopp_height", "chop_bottom", "chop_offset", "chop_y", "chopp__height", "chhop_top", "chhop_to", "chop_client", "chumb_bottom", "chopp__top"], "ci": ["ic", "ki", "ce", "ca", "c", "cd", "ia", "cia", "dc", "lic", "fi", "cp", "cs", "di", "cb", "cm", "ai", "cod", "ii", "li", "co", "ti", "ct", "xc", "bi", "cci", "ico", "si"], "ret": ["it", "alt", "not", "out", "reset", "ll", "RET", "ref", "re", "len", "status", "try", "att", "gt", "def", "value", "result", "cont", "ry", "reg", "mem", "mel", "resp", "pret", "rem", "j", "print", "fit", "rt", "back", "req", "nt", "rets", "progress", "ft", "aux", "val", "Ret", "gc", "elt", "vt", "final", "tmp", "t", "res"], "vc": ["vm", "cil", "ic", "cf", "cu", "conv", "voice", "vd", "ev", "pc", "vp", "c", "vine", "veh", "cv", "vv", "lic", "var", "mk", "ctrl", "ve", "forcer", "vol", "WC", "vr", "vet", "vg", "ht", "voc", "VC", "vo", "vec", "av", "vy", "wcs", "nv", "xc", "cul", "vl", "fc", "coll", "sv", "qv", "vi", "vt", "uv", "vin", "v", "wx", "lc", "lv", "ix"], "vcend": ["vpent", "vccend", " vhend", " vdesc", "vrecent", "chend", "ccend", "tcend", "gcend", "vhend", "grecent", " vend", "tpent", "vcd", " vcd", "tdesc", "cend", "vdesc", "ccd", " vrecent", "vccd", "vchend", "gdesc", "trecent", "gpent", "vend", " vpent"]}}
{"project": "FFmpeg", "commit_id": "41a052a6badc9ed672a810a40b8e54af5d093b5d", "target": 1, "func": "int opt_default(const char *opt, const char *arg)\n\n{\n\n    const AVOption *oc, *of, *os, *oswr;\n\n    char opt_stripped[128];\n\n    const char *p;\n\n    const AVClass *cc = avcodec_get_class(), *fc = avformat_get_class(), *sc, *swr_class;\n\n\n\n    if (!(p = strchr(opt, ':')))\n\n        p = opt + strlen(opt);\n\n    av_strlcpy(opt_stripped, opt, FFMIN(sizeof(opt_stripped), p - opt + 1));\n\n\n\n    if ((oc = av_opt_find(&cc, opt_stripped, NULL, 0,\n\n                         AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)) ||\n\n        ((opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') &&\n\n         (oc = av_opt_find(&cc, opt + 1, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ))))\n\n        av_dict_set(&codec_opts, opt, arg, FLAGS(oc));\n\n    if ((of = av_opt_find(&fc, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)))\n\n        av_dict_set(&format_opts, opt, arg, FLAGS(of));\n\n#if CONFIG_SWSCALE\n\n    sc = sws_get_class();\n\n    if ((os = av_opt_find(&sc, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {\n\n        // XXX we only support sws_flags, not arbitrary sws options\n\n        int ret = av_opt_set(sws_opts, opt, arg, 0);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Error setting option %s.\\n\", opt);\n\n            return ret;\n\n        }\n\n    }\n\n#endif\n\n    swr_class = swr_get_class();\n\n    if (!oc && !of && !os && (oswr = av_opt_find(&swr_class, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {\n\n        int ret = av_opt_set(swr_opts, opt, arg, 0);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Error setting option %s.\\n\", opt);\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    if (oc || of || os || oswr)\n\n        return 0;\n\n    av_log(NULL, AV_LOG_ERROR, \"Unrecognized option '%s'\\n\", opt);\n\n    return AVERROR_OPTION_NOT_FOUND;\n\n}\n", "idx": 26087, "substitutes": {"opt": ["ost", "cmp", "alt", "hop", "intern", "rop", "vp", "pp", "c", "crit", "lt", "mem", "var", "OP", "prefix", "proc", "pair", "pl", "IT", "orig", "rt", "attr", "ip", "expr", "png", "loc", "anon", "snap", "opted", "pkg", "max", "pt", "obj", "term", "oss", "after", "pr", "cat", "spec", "cp", "tip", "msg", "buf", "j", "tag", "init", "ts", "iter", "fo", "fp", "slot", "timeout", "offset", "ot", "x", "op", "pot", "optim", "iop", "Opt", "text", "tp", "pres", "adj", "off", "tr", "stat", "tmp", "str", "block", "it", "option", "prop", "out", "ok", "options", "ref", "nom", "w", "oop", "cho", "ext", "cmd", "top", "usr", "dest", "np", "comp", "feat", "wp", "txt", "num", "sp", "ret", "jp", "t"], "arg": ["it", "prop", "args", "argument", "star", "err", "ref", "arp", "op", "w", "gt", "aug", "pp", "alg", "asc", "reg", "mem", "local", "var", "Arg", "target", "ext", "cmd", "ar", "agg", "ack", "arr", "add", "ax", "msg", "vol", "par", "buf", "call", "tag", "doc", "req", "ag", "urg", "loc", "addr", "bin", "iter", "val", "flag", "ret", "pat", "param", "rg", "v", "aw"], "oc": ["ost", "ocon", "uc", "ov", "toc", "o", "obj", "ok", "op", "pc", "bc", "oss", "ow", "roc", "c", "rc", "og", "oci", "ec", "ocal", "cp", "ocation", "soc", "nc", "org", "oo", "ob", "arc", "osc", "voc", "OC", "co", "oid", "ac", "unc", "ocr", "om", "ox", "loc", "alloc", "oco", "ot"], "of": ["orf", "omp", "por", "alf", "other", "af", "out", "on", "o", "obj", "ok", "cf", "ous", "from", "with", "ol", "Of", "at", "er", "wo", "or", "oga", "fi", "el", "oe", "io", "org", "ob", "to", "ont", "et", "ong", "OF", "so", "unc", "oln", "bj", "om", "des", "ou", "osi", "less", "en", "oft", "off", "oa", "ot", " fo", "one"], "os": ["sys", "ost", "i", "out", "ops", "oes", "on", "o", "osa", "ok", "op", "oos", "pc", "oss", "us", "oses", "ol", "at", "ds", "ose", "s", "io", "oo", "ob", "cs", "OS", "osc", "bs", "ss", "oid", "oS", "is", "ts", "om", "osi", "obs", "ls", "oa", "ows", "ot", "dos"], "oswr": ["OSWr", " osrw", " osw", "ossvr", "osrw", " osWr", " osWR", "OSwr", "OSWR", "osw", "OSrw", "owr", "oWr", "ossw", "orw", "osvr", "OSw", "osswr", "oWR", "osWR", " osvr", "ossrw", "OSvr", "osWr"], "opt_stripped": ["opt_cropacked", "opt_wrapled", "opt_striped", "opt_cropped", "opt_wrapped", "opt_ripped", "opt_strips", "opt_strippping", "opt_crops", "opt_improged", "opt_strapped", "opt_rips", "opt_ripacked", "opt_impropped", "opt_straged", "opt_stropping", "opt_ripping", "opt__strips", "opt_stried", "opt_wrapping", "opt_wraed", "opt_striged", "opt__stropped", "opt__strops", "opt__stropping", "opt_supped", "opt_impropled", "opt_stripping", "opt__stripped", "opt_cropping", "opt_strippped", "opt__stripping", "opt_wraged", "opt_strops", "opt_supping", "opt_sued", "opt_stripps", "opt_strippacked", "opt_strapled", "opt_stripled", "opt_stropped", "opt_stripacked"], "p": ["f", "padding", "pre", "i", "x", "pb", "o", "ph", "op", "pc", "d", "c", "pp", "pr", "r", "cp", "n", "s", "par", "j", "pos", "per", "b", "l", "dp", "ps", "wp", "sp", "tp", "bp", "u", "fp", "P", "lp", "t", "jp", "q", "v", "m", "pt"], "cc": ["cl", "uc", "CC", "cmp", "cf", "ca", "pc", "bc", "roc", "c", "rc", "tc", "ctr", "dc", "cca", "ec", "ck", "ctrl", "cp", "nc", "soc", "cs", "ctx", "co", "acc", "ct", "ac", "unc", "ci", "mc", "con", "gc", "lc", "cv"], "fc": ["f", "uc", "cf", "ff", "col", "bc", "pc", "tf", "c", "fr", "rc", "dc", "fl", "ec", "fi", "func", "FC", "fn", "soc", "nc", "cs", "vol", "co", "ac", "unc", "loc", "con", "fp", "format", "conv", "lc", "cv"], "sc": ["sys", "cl", "uc", "esc", "cf", "sq", "pc", "bc", "config", "c", "rc", "tc", "asc", "dc", "scl", "ec", "Sc", "nc", "soc", "ser", "cs", "arc", "sac", "sw", "set", "isc", "osc", "sec", "ss", "co", "sci", "ct", "anc", "scale", "loc", "mc", " SC", "sp", " Sc", "sv", "scope", "gc", "SC", "lc", "cv"], "swr_class": ["swer_group", "swr__class", "swer_classes", "swr__Class", "swr_file", "swrr_CLASS", "swr_CLASS", "swr_classes", "swer_class", "swrr_Class", "swr_group", "swr_Class", "swr___classes", "swrr_file", "swr__CLASS", "swrr_class", "swr___class", "swr__file", "swr___group"]}}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void slavio_misc_init(target_phys_addr_t base,\n\n                             target_phys_addr_t aux1_base,\n\n                             target_phys_addr_t aux2_base, qemu_irq irq,\n\n                             qemu_irq fdc_tc)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"slavio_misc\");\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    if (base) {\n\n        /* 8 bit registers */\n\n        /* Slavio control */\n\n        sysbus_mmio_map(s, 0, base + MISC_CFG);\n\n        /* Diagnostics */\n\n        sysbus_mmio_map(s, 1, base + MISC_DIAG);\n\n        /* Modem control */\n\n        sysbus_mmio_map(s, 2, base + MISC_MDM);\n\n        /* 16 bit registers */\n\n        /* ss600mp diag LEDs */\n\n        sysbus_mmio_map(s, 3, base + MISC_LEDS);\n\n        /* 32 bit registers */\n\n        /* System control */\n\n        sysbus_mmio_map(s, 4, base + MISC_SYS);\n\n    }\n\n    if (aux1_base) {\n\n        /* AUX 1 (Misc System Functions) */\n\n        sysbus_mmio_map(s, 5, aux1_base);\n\n    }\n\n    if (aux2_base) {\n\n        /* AUX 2 (Software Powerdown Control) */\n\n        sysbus_mmio_map(s, 6, aux2_base);\n\n    }\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_connect_irq(s, 1, fdc_tc);\n\n    qemu_system_powerdown = qdev_get_gpio_in(dev, 0);\n\n}\n", "idx": 26090, "substitutes": {"base": ["basic", "block", "tree", "bare", "type", "parent", "active", "space", "pre", "full", "bas", "padding", "server", "address", "se", "mb", "status", "normal", "Base", "bit", "valid", "c", "binding", "id", "bf", "zero", "master", "buffer", "local", "common", "beta", "alias", "use", "prefix", "range", "root", "set", "area", "origin", "bar", "bs", "bg", "used", "bu", "file", "prime", "chain", "b", "pse", "start", "bi", "scale", "ba", "key", "alpha", "stable", "ase", "bp", "check", "shadow", "bus", "based", "domain", "all", "big", "format", "m", "bid", "name"], "aux1_base": ["aux1__bas", "aux1_ref", "aux1_old", "aux1__Base", "aux1__old", "aux1_full", "aux1_buffer", "aux2_name", "aux2_Base", "aux1_name", "aux2_old", "auxone_buffer", "aux1___base", "aux2_full", "aux1_bas", "auxone_base", "aux1__name", "aux1_back", "aux1___old", "aux2_bas", "auxone_back", "aux1__full", "aux2_ref", "aux1_Base", "aux1__base", "aux1___ref", "auxone_Base", "aux1___bas", "aux1__ref"], "aux2_base": ["aux1_bp", "aux2_buffer", "aux2_bp", "aux2_name", "aux4_base", "aux1_buffer", "aux4_name", "aux2_Base", "aux2_bare", "aux1_bas", "aux2_bas", "aux4_bas", "aux4_bare", "aux1_Base"], "irq": ["mrp", "irQ", "mrQ", "irqu", "ibrQ", " cirqu", "irp", "rQ", " cirqs", "mirq", "IRQ", " cirQ", " cirq", "rq", "irqs", "ibrqs", "mirQ", "ibrp", "IRqs", "mirp", "IRq", "mrq", "mirqs", "rqs", "IRqu", "mrqs", "rqu", "ibrq"], "fdc_tc": ["fdsc_tm", "fdcftx", "fdc_t", "fdsc_fc", "fdec_TC", "fdc_fc", "fdc8tm", "fdec_tc", "fdc_tx", "fdsc_tc", "fdcffc", "fdc8tx", "fdc8tc", "fdec_t", "fdcftm", "fdc_TC", "fdcftc", "fdc8fc", "fdsc_tx", "fdc_tm"], "dev": ["priv", "sd", "sys", "device", "hw", "ad", "Device", "out", "dis", "cam", "obj", "ev", "conn", "os", "d", "pad", "adv", "w", "def", " device", "debug", "ds", "mem", "conf", "var", "gu", "g", "db", "DEV", "det", "ver", "ve", "p", "cmd", "sh", "di", "go", "av", "data", "nt", "de", "dd", "DE", "des", "dem", "Dev", "serv", "tr", "h", "v", "res"], "s": ["sys", "ms", "i", "as", "space", "sb", "args", "eps", "ins", "os", "se", "ties", "fs", "d", "comm", "rs", "c", "ses", "ds", "sync", "g", "tests", "spec", "n", "p", "changes", "cs", "sts", "sw", "set", "bits", "j", "sym", "vs", "S", "als", "js", "bs", "ss", "is", "b", "l", "ns", "ts", "ps", "ims", "ats", "y", "des", "stats", "z", "es", "its", "sp", "gs", "sv", "self", "h", "t", "ls", "v", "sq", "socket", "series"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)\n\n{\n\n    if (!mb_x) {\n\n        return mb_y ? VERT_VP8_PRED : DC_129_PRED;\n\n    } else {\n\n        return mb_y ? mode : HOR_VP8_PRED;\n\n    }\n\n}\n", "idx": 26100, "substitutes": {"mode": ["option", "type", "dim", "MODE", "power", "nom", "only", "status", "code", "none", "wise", "error", "mm", "command", "md", "cmd", "me", "use", "state", "mit", "move", "mod", "transform", "module", "tag", "ode", "primary", "size", "scale", "key", "position", "Mode", "style", "kind", "time", "format", "m", "name", "role"], "mb_x": ["MB_y", "mb_xy", "MB_xy", "emb_x", "mb_m", "emb_y", "emb_m", "MB_z", "emb_X", "mb_X", "MB_x", "mb_z"], "mb_y": ["md_x", "tmp_ny", "mb__x", "mb_yy", "md_y", "bb_y", "mbableyy", "tmpabley", "mb_ty", "bb_x", "md_ty", "tmpablex", "tmp_y", "tmpableny", "mb__yy", "mb___y", "mb_ny", "mb___x", "mb__ny", "bb_yy", "mb___ey", "mbablex", "mb__y", "md_ey", "mb___ty", "tmp_x", "mb_ey", "bb_i", "mb_i", "mbableny", "mbabley", "tmpableyy", "tmp_yy"]}}
{"project": "FFmpeg", "commit_id": "da34e4e13238b755bb0e6ebf549015797d9b4467", "target": 1, "func": "static struct ResampleContext *create(struct ResampleContext *c, int out_rate, int in_rate, int filter_size, int phase_shift, int linear,\n\n        double cutoff, enum AVSampleFormat format, enum SwrFilterType filter_type, double kaiser_beta, double precision, int cheby, int exact_rational){\n\n    soxr_error_t error;\n\n\n\n    soxr_datatype_t type =\n\n        format == AV_SAMPLE_FMT_S16P? SOXR_INT16_S :\n\n        format == AV_SAMPLE_FMT_S16 ? SOXR_INT16_I :\n\n        format == AV_SAMPLE_FMT_S32P? SOXR_INT32_S :\n\n        format == AV_SAMPLE_FMT_S32 ? SOXR_INT32_I :\n\n        format == AV_SAMPLE_FMT_FLTP? SOXR_FLOAT32_S :\n\n        format == AV_SAMPLE_FMT_FLT ? SOXR_FLOAT32_I :\n\n        format == AV_SAMPLE_FMT_DBLP? SOXR_FLOAT64_S :\n\n        format == AV_SAMPLE_FMT_DBL ? SOXR_FLOAT64_I : (soxr_datatype_t)-1;\n\n\n\n    soxr_io_spec_t io_spec = soxr_io_spec(type, type);\n\n\n\n    soxr_quality_spec_t q_spec = soxr_quality_spec((int)((precision-2)/4), (SOXR_HI_PREC_CLOCK|SOXR_ROLLOFF_NONE)*!!cheby);\n\n    q_spec.precision = linear? 0 : precision;\n\n#if !defined SOXR_VERSION /* Deprecated @ March 2013: */\n\n    q_spec.bw_pc = cutoff? FFMAX(FFMIN(cutoff,.995),.8)*100 : q_spec.bw_pc;\n\n#else\n\n    q_spec.passband_end = cutoff? FFMAX(FFMIN(cutoff,.995),.8) : q_spec.passband_end;\n\n#endif\n\n\n\n    soxr_delete((soxr_t)c);\n\n    c = (struct ResampleContext *)\n\n        soxr_create(in_rate, out_rate, 0, &error, &io_spec, &q_spec, 0);\n\n    if (!c)\n\n        av_log(NULL, AV_LOG_ERROR, \"soxr_create: %s\\n\", error);\n\n    return c;\n\n}\n", "idx": 26110, "substitutes": {"c": ["f", "ch", "cur", "err", "bc", "d", "w", "config", "tc", "k", "dc", "g", "r", "ar", "n", "p", "cp", "s", "cs", "cb", "cm", "ctx", "a", "b", "ct", "l", "ci", "con", "e", "h", "t", "cc", "C", "v", "lc", "m"], "out_rate": ["in_frequency", "out_rates", "out_range", "in_rates", "out_frequency", "in_range"], "in_rate": ["in_frequency", "out_rates", "out_range", "in_rates", "out_frequency", "in_range"], "filter_size": ["sample_size", "filter_shape", "filter_offset", "filter_scale", "sample_shape", "sample_scale", "sample_offset"], "phase_shift": ["phasemmshift", "pha_shift", "phase_size", "phase_type", "phasemmscale", "pha_scale", "pha_size", "phasemmsize", "phase_scale", "pha_type", "phasemmtype"], "linear": ["length", "major", "repeat", "regular", "standard", "len", "flex", "ln", "k", "zero", "ear", "margin", "local", "random", "lambda", "relative", "positive", "initial", "rel", "lin", "equal", "binary", "total", "olar", "central", "priority", "line", "location", "l", "scale", "physical", "alpha", "serial", "time", "kl", "model", "loop", "final"], "cutoff": ["breakup", " cutup", "bitoffset", "cutoffset", "cropoffer", "cleanbefore", "tipbefore", " cutOFF", "bitOff", " cutoffer", " cutover", "clipoffer", "cutup", "bitoffs", " cutoffset", "clipon", "setOff", " cutbefore", "critoff", "filteroffer", "cropon", "cutOff", "cutbefore", "critoffer", "cropoff", "butoff", "cleanoff", "setoffset", "bitoff", "tipoff", "cutoffer", "tipdown", "filteroff", " cutoffs", "critOFF", "filterOFF", "setoffs", "tipoffer", "clipoff", "setoff", "butOFF", " cutOff", " cuton", "breakoff", "butup", "filterover", "cleandown", "cleanoffer", "cutoffs", "breakOFF", "clipOFF", "cuton", " cutdown", "cropOFF", "cutdown", "cutOFF", "cutover", "breakon", "critover", "buton"], "format": ["f", "pretty", "option", "type", "it", "length", "pre", "field", "force", "err", "address", "api", "only", "feature", "service", "status", "unit", "valid", "map", "after", "category", "act", "path", "cat", "spec", "list", "fix", "use", "filter", "prefix", "set", "sche", "sort", "transform", "Format", "policy", "module", "function", "form", "lat", "sequence", "and", "print", "settings", "file", "old", "l", "data", "size", "feat", "scale", "port", "interface", "base", "version", "limit", "style", "mt", "channel", "domain", "pattern", "t", "all", "model", "method", "init", "name"], "filter_type": [" filter_types", "filter_types", "filter_time", " filter_time"], "kaiser_beta": ["kaise2phi", "kaise_beta", "kaiser2Beta", "kaiser1alpha", "kaiser2phi", "kaiser2alpha", "kaise2beta", "kaise2Beta", "kaise2alpha", "kaiser_phi", "kaiser5alpha", "kaise_phi", "kaiser_Beta", "kaiser5Beta", "kaiser1phi", "kaiser5beta", "kaiser5phi", "kaise_Beta", "kaise_alpha", "kaiser2beta", "kaiser_alpha", "kaiser1beta", "kaiser1Beta"], "cheby": ["cuego", "cheBY", " chebys", "wheby", " chego", "schebys", "chebys", "scheBY", "bleby", "diebys", "blebys", "dieBy", "dieBY", "cheBy", "scheby", "bleBY", "cuebys", "blego", " cheBY", "cueBY", "scheBy", "wheBY", "wheBy", "whebys", "cueby", "dieby", "chego"], "exact_rational": ["exactor_quality", "exactor_sample", "exactistsample", "exactedquality", "exactor_value", "exactoredvalue", "exactedrational", "exact_sample", "exact_value", "exactoredrational", "exactistrational", "exact_quality", "exactor_rational", "exactistvalue", "exactedvalue", "exactedsample", "exactoredsample", "exactistquality", "exactoredquality"], "error": ["attribute", "angle", "err", "ror", "code", "Error", "event", "command", "r", "ERROR", "close", "rec", "sc", "extra", "function", " Error", "data", "info", "scale", "query", "base", "e", "channel", "iso", "errors", "exc", "parse"]}}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "static void bdrv_put_buffer(void *opaque, const uint8_t *buf,\n\n                            int64_t pos, int size)\n\n{\n\n    QEMUFileBdrv *s = opaque;\n\n    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);\n\n}\n", "idx": 26113, "substitutes": {"opaque": ["obque", " opacity", "patile", "paque", "ropaque", "opque", "opacity", "obacity", " opaques", "obaque", "pen", "Opaque", "ropen", "pacity", "open", "opatile", "Open", "Opacity", "obaques", "ipque", "ropatile", "ipaque", " opque", "ipacity", "ipaques", "Opatile", "opaques", "ropacity"], "buf": ["block", "fb", "bb", "batch", "pb", "ref", "queue", "uf", "br", "bl", "bound", "bc", "map", "bf", "buffer", "mem", "og", "seq", "late", "cmd", "p", "Buff", "tab", "msg", "cb", "bytes", "bar", "vec", "raw", "doc", "b", "data", "wb", "txt", "window", "rb", "cap", "Buffer", "buff", "BU", "cv"], "pos": ["length", "o", "ref", "pose", " position", "po", "len", "Pos", "os", "op", " offset", "from", "pc", "def", "spec", "p", "POS", "pid", "pointer", " len", "origin", "start", "oc", "port", "ps", "loc", "base", "position", "num", "pro", "pres", "off", "offset", "ptr", "no", "index", "pt", "conf"], "size": ["sn", "type", "length", "space", "needed", "len", "fee", "iz", "c", "body", " Size", "gz", "loss", "empty", "ose", "send", "n", "count", "ize", "mode", "small", "sent", "set", "message", "shape", "since", "notice", "scale", "start", "SIZE", "Size", "en", "offset", "sum", "m"], "s": [" os", " self", "as", "sa", " ss", "ins", " us", "sis", "store", "se", "comm", "v", "rs", "c", "ses", "ds", "hs", "sl", "r", "p", "bis", "cs", "sts", "iss", "S", "session", "als", "bs", "js", "ss", "a", "is", "b", "ts", "ns", "ps", "acs", "y", "qs", "stats", "es", "gs", "less", "sv", "ass", "ls", "q", "h", "sq", "ess", "ssl"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void qemu_clock_init(QEMUClockType type)\n\n{\n\n    QEMUClock *clock = qemu_clock_ptr(type);\n\n\n\n    /* Assert that the clock of type TYPE has not been initialized yet. */\n\n    assert(main_loop_tlg.tl[type] == NULL);\n\n\n\n    clock->type = type;\n\n    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);\n\n    clock->last = INT64_MIN;\n\n    QLIST_INIT(&clock->timerlists);\n\n    notifier_list_init(&clock->reset_notifiers);\n\n    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);\n\n}\n", "idx": 26117, "substitutes": {"type": ["range", "address", "status", "unit", "_", "id", "create", "request", "command", "p", "day", "pe", "types", "token", "info", "y", "ico", "link", "http", "scope", "table", "role", "parent", "inter", "action", "temp", "code", "try", "value", "ty", "error", "tool", "spec", "ver", "state", "level", "total", "shape", "year", "key", "handle", "TYPE", "lock", "class", "ping", "length", "title", "ype", "now", "family", "rule", "file", "test", "template", "version", "tp", "style", "kind", "time", "number", "all", "block", "typ", "null", "change", "result", "event", "currency", "rel", "set", "module", "sequence", "instance", "port", "txt", "Type", "position", "source", "t", "index", "name"], "clock": ["shop", "c", "sync", "pool", "ctl", "count", "soc", "mint", "ct", "work", "step", "gc", "Clock", "contact", "ch", "ock", "forth", "chart", "boot", "pc", "config", "tz", "chron", "tool", "cp", "year", "poll", "penter", "timeout", "lock", "cl", "job", "batch", "length", "starter", "reset", "cker", "cycle", "tick", "liv", "ck", "console", "library", "always", "print", "version", "tp", "course", "time", "number", "frequency", "controller", "hello", "block", "client", "server", "watch", "profile", "sky", "cpu", "currency", "list", "ack", "counter", "craft", "sequence", "instance", "php", "ac", "load", "vision", "position", "check", "loop", "conv"]}}
{"project": "qemu", "commit_id": "586502189edf9fd0f89a83de96717a2ea826fdb0", "target": 1, "func": "static CharDriverState *qemu_chr_open_pty(QemuOpts *opts)\n\n{\n\n    CharDriverState *chr;\n\n    PtyCharDriver *s;\n\n    struct termios tty;\n\n    int master_fd, slave_fd, len;\n\n#if defined(__OpenBSD__) || defined(__DragonFly__)\n\n    char pty_name[PATH_MAX];\n\n#define q_ptsname(x) pty_name\n\n#else\n\n    char *pty_name = NULL;\n\n#define q_ptsname(x) ptsname(x)\n\n#endif\n\n\n\n    if (openpty(&master_fd, &slave_fd, pty_name, NULL, NULL) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    /* Set raw attributes on the pty. */\n\n    tcgetattr(slave_fd, &tty);\n\n    cfmakeraw(&tty);\n\n    tcsetattr(slave_fd, TCSAFLUSH, &tty);\n\n    close(slave_fd);\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    len = strlen(q_ptsname(master_fd)) + 5;\n\n    chr->filename = g_malloc(len);\n\n    snprintf(chr->filename, len, \"pty:%s\", q_ptsname(master_fd));\n\n    qemu_opt_set(opts, \"path\", q_ptsname(master_fd));\n\n    fprintf(stderr, \"char device redirected to %s\\n\", q_ptsname(master_fd));\n\n\n\n    s = g_malloc0(sizeof(PtyCharDriver));\n\n    chr->opaque = s;\n\n    chr->chr_write = pty_chr_write;\n\n    chr->chr_update_read_handler = pty_chr_update_read_handler;\n\n    chr->chr_close = pty_chr_close;\n\n\n\n    s->fd = master_fd;\n\n    s->timer = qemu_new_timer_ms(rt_clock, pty_chr_timer, chr);\n\n\n\n    return chr;\n\n}\n", "idx": 26136, "substitutes": {"opts": ["operps", "opth", "iopts", "iopths", "props", "opty", " opty", "optws", "iopcs", " opths", "proty", "opws", "operts", "operty", "iopws", " opws", "optths", "operth", "proth", "opths", "opcs", "optcs", " opps", "prots", "opps", " opcs", " opth", "optts"], "chr": ["cherry", "CHR", "echrt", "chrs", "echrb", "echlr", " Chrs", "cherr", " chrb", "chert", " chry", "achrer", "echrs", "chatrs", "chsr", "chrr", "chp", " chsr", "ichsr", "chatrr", "ichrs", "Chp", " cher", "schr", "chdr", "chry", "echar", "ichr", "Chdr", "achdr", "chatr", "ChR", "chrar", "chlr", "schrb", "echdr", " chnr", " chrer", "Chr", "chrb", "corr", "CHrb", "chrt", " chp", "achr", "chernr", "acher", "chelr", "ichrr", "achar", " chrr", "chR", "chrer", " chdr", "cherrb", " Chr", " chrs", "cherar", "achp", "corrb", "cher", "Char", "cherrer", "Chrc", "Cher", " Chrar", "achrb", " chlr", "CHrc", "Chnr", "chatsr", "schR", " chrar", "echr", "chers", "corar", "chnr", " Chrt", "schrc", " chrt", "cordr", "CHr", "achry", "Chrb", "chrc"], "s": ["sys", "css", "i", "sb", "o", "os", "fs", "rs", "w", "c", "ses", "ds", "hs", "g", "r", "spec", "n", "p", "cs", "sts", "set", "S", "session", "als", "bs", "js", "ss", "a", "is", "ats", "b", "ns", "ts", "ps", "save", "stats", "qs", "es", "its", "gs", "less", "sv", "ys", "self", "h", "ls", "q", "t", "sq", "socket", "ssl"], "tty": ["type", "sett", "tx", "pipe", "null", "temp", "readable", "term", "pty", "echo", "tf", "tc", "kt", "tt", "ty", "title", "password", "console", "ctl", "phrase", "tab", "thread", "prefix", "slave", "ctor", "input", "shell", " ty", "private", "tiny", "token", "sudo", "test", "trust", "username", "key", "txt", "interface", "quiet", "reader", "writer", "ptr", "table", " t", "t", "vt", "tmp", "TY", "filename", "println", "pt"], "master_fd": ["male_fa", "master_fp", "master_fin", "master_fc", "master_ctx", "slave_lf", " slave_dn", "proxyingpid", "slave_fi", "slave_id", "masteringpid", "slave_FD", " slave64df", " slave64fd", "slave_dir", "master_dn", "slave_fp", "proxyingds", "master_lf", "proxy_dev", "master64df", " slave_ld", "male_fc", "master_id", "master_win", " slave64pipe", "master____dn", "master_ds", "master____fd", "slave_pid", "male_sd", "slave_win", "proxyingfd", " slave_df", " slave_pipe", "master_fa", "master_pipe", " slave_fin", "master_dev", "master_sd", " slave64ctx", "proxyingdev", "master_dir", "proxy_ds", "master64pipe", "master_df", "master_pid", "master64fd", "master____ld", "master_ld", "master____fin", "masteringdev", "male_fd", "masteringds", "master64ctx", " slave_ctx", "master_fi", "masteringfd", "master_FD", "proxy_fd", "proxy_pid"], "slave_fd": ["master_fp", "master_port", " slave_ds", " slave_pid", "slave_FD", " slave_fc", "slave_dir", "slave_fp", "slave_port", "master_ds", "pty_fc", "slave_pid", "pty_dir", "pty_FD", "pty_fd", "master_dir", " slave_dir", "master_pid", "slave_ds", "slave_fc", " slave_FD"], "len": ["wid", "cl", "length", "ld", "cmp", "Length", "err", "ll", "ref", "bl", "L", "ln", "mil", "nl", "mem", "gz", "fin", "seq", "sl", "fl", "list", "n", "lf", "count", "el", "Len", "compl", "resp", "bytes", "le", "lon", "pos", "enc", "pl", "li", "vec", "l", "size", "nt", "lan", "dl", "fil", "lim", "z", "coll", "en", "lp", "kl", "ls", "elt", "all", "str"], "pty_name": ["pty_nam", "slave_Name", "pt_name", "slave_no", "slave_names", "pt_n", "pty_names", "slave_name", "pty_len", "pty_Name", "pty_no", "pipe_NAME", "pty_path", "slave_path", "slave_len", "pipe_name", "pt_nam", "pt_names", "pipe_names", "pty_NAME", "pipe_no", "pty_n"]}}
{"project": "qemu", "commit_id": "601b9a9008c5a612d76073bb3f178621cff41980", "target": 0, "func": "uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,\n\n                      uint64_t cpu_addr)\n\n{\n\n    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n\n\n    HELPER_LOG(\"%s: %016\" PRIx64 \" %08x %016\" PRIx64 \"\\n\",\n\n               __func__, order_code, r1, cpu_addr);\n\n\n\n    /* Remember: Use \"R1 or R1 + 1, whichever is the odd-numbered register\"\n\n       as parameter (input). Status (output) is always R1. */\n\n\n\n    switch (order_code) {\n\n    case SIGP_SET_ARCH:\n\n        /* switch arch */\n\n        break;\n\n    case SIGP_SENSE:\n\n        /* enumerate CPU status */\n\n        if (cpu_addr) {\n\n            /* XXX implement when SMP comes */\n\n            return 3;\n\n        }\n\n        env->regs[r1] &= 0xffffffff00000000ULL;\n\n        cc = 1;\n\n        break;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    case SIGP_RESTART:\n\n        qemu_system_reset_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n    case SIGP_STOP:\n\n        qemu_system_shutdown_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n#endif\n\n    default:\n\n        /* unknown sigp */\n\n        fprintf(stderr, \"XXX unknown sigp: 0x%\" PRIx64 \"\\n\", order_code);\n\n        cc = SIGP_CC_NOT_OPERATIONAL;\n\n    }\n\n\n\n    return cc;\n\n}\n", "idx": 26152, "substitutes": {"env": ["vm", "stack", "context", "engine", "esc", "sb", "server", "obj", "store", "ev", "conn", "code", "viron", "vp", "config", "w", "erd", "entry", "er", "ew", "dev", "mem", "ec", "ah", "ext", "cmd", "ve", "state", "forge", "esp", "buf", "et", "ctx", "te", "stage", "environment", "doc", "cfg", "init", "desc", "info", "worker", "window", "txt", "e", "EN", "sp", "en", "h", "t", "eng", "manager", "proc", "v", "enter", "conf"], "order_code": ["order_no", "order_name", "Order_code", " order_type", "orderNameno", "Order_no", "orderNamecode", "orderopcod", "Order_Code", "Order_cod", "orderertype", "orderercode", "order_cod", "orderopcode", "order_data", " order_cmd", " order_data", "orderername", "ordererdata", "order_cmd", "order_type", "orderopCode", "Order_cc", "order_Code", " order_Code", "orderNameCode", "orderNamecc", " order_name", "order_cc"], "r1": ["r2", "rank1", "c0", "c3", "rank0", "p6", "R0", "r0", "r61", "r3", " r6", "c2", "r6", "p0", " r0", "tr2", " rFirst", "rar61", "tr1", " r61", " r2", "rarFirst", "R1", "rank3", "c1", "R6", "rar2", " r3", "rank2", "tr61", "R2", "rFirst", "rar1", "trFirst", "p2", "p1"], "cpu_addr": ["gpu_add", "cpumyaddr", "cpumyconn", "gpu_address", "pu_conn", "cpu_conn", "cpu_address", "cpu_ptr", "gpu_addr", "cpu_src", "cpu__add", "cpu__addr", "gpu_ptr", "pu_ref", "cpu_ref", "pu_addr", "cpumyadd", "pu_add", "cpu_add", "pu_src", "cpu__conn"]}}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2rgb_1_c_template(SwsContext *c, const uint16_t *buf0,\n\n                     const uint16_t *ubuf0, const uint16_t *ubuf1,\n\n                     const uint16_t *vbuf0, const uint16_t *vbuf1,\n\n                     const uint16_t *abuf0, uint8_t *dest, int dstW,\n\n                     int uvalpha, enum PixelFormat dstFormat,\n\n                     int flags, int y, enum PixelFormat target,\n\n                     int hasAlpha)\n\n{\n\n    int i;\n\n\n\n    if (uvalpha < 2048) {\n\n        for (i = 0; i < (dstW >> 1); i++) {\n\n            int Y1 = buf0[i * 2]     >> 7;\n\n            int Y2 = buf0[i * 2 + 1] >> 7;\n\n            int U  = ubuf1[i]        >> 7;\n\n            int V  = vbuf1[i]        >> 7;\n\n            int A1, A2;\n\n            const void *r =  c->table_rV[V],\n\n                       *g = (c->table_gU[U] + c->table_gV[V]),\n\n                       *b =  c->table_bU[U];\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] >> 7;\n\n                A2 = abuf0[i * 2 + 1] >> 7;\n\n            }\n\n\n\n            yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                          r, g, b, y, target, hasAlpha);\n\n        }\n\n    } else {\n\n        for (i = 0; i < (dstW >> 1); i++) {\n\n            int Y1 =  buf0[i * 2]          >> 7;\n\n            int Y2 =  buf0[i * 2 + 1]      >> 7;\n\n            int U  = (ubuf0[i] + ubuf1[i]) >> 8;\n\n            int V  = (vbuf0[i] + vbuf1[i]) >> 8;\n\n            int A1, A2;\n\n            const void *r =  c->table_rV[V],\n\n                       *g = (c->table_gU[U] + c->table_gV[V]),\n\n                       *b =  c->table_bU[U];\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] >> 7;\n\n                A2 = abuf0[i * 2 + 1] >> 7;\n\n            }\n\n\n\n            yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                          r, g, b, y, target, hasAlpha);\n\n        }\n\n    }\n\n}\n", "idx": 26154, "substitutes": {"i": ["ui", " j", "status", "c", "ini", "id", "in", "I", "p", " bi", "ori", "sim", "ai", "origin", "li", "complete", "any", "info", "ip", "ij", "y", "ci", "iu", " I", "si", "v", "ei", "series", "ji", "parent", "ki", "\u0438", "item", "ski", " ii", "gu", "n", "remote", "io", "j", "ind", "ims", "key", "iter", "uri", "m", "point", "qi", "ix", "iii", "batch", "x", "multi", "ami", "ri", "phi", "di", "oi", "zi", "go", "mi", "ii", "depth", "print", "is", "l", " ti", "bi", "dr", "xi", "im", "q", "this", "iri", "it", "ic", "err", "slice", "pi", "ia", "wait", "me", "gi", "list", "to", "ti", "load", "json", "e", "copy", "t", "index", "cli", "init", "name"], "A1": ["ATAone", "AOne", " A7", " Aone", "GOne", "A7", " AOne", "CA2", "A01", "AM3", "ATA01", "HA1", "G1", "HA2", "CA1", "E1", "Aone", "ATAOne", "G3", "AT1", " A3", "HAone", "AUone", "CAOne", "HA7", "Eone", "ATA1", "AMOne", "AUOne", "ATone", "G7", "HA3", "AU01", "HAOne", "A3", "AM2", "E2", "CA3", "AU1", "AM1", "ATOne", "EOne", "AT01"], "A2": [" A05", "aTwo", "P2", "HA4", "AR02", "A4", "PA2", "PA02", "HA02", "PAtwo", "a2", "Array4", "Atwo", "A05", "Array05", "ARtwo", "LA4", "A02", "PTwo", "HA2", " A4", "GA2", "a02", "PATwo", " ATwo", "ATwo", "P05", "GA1", "Array2", "ArrayTwo", "ARTwo", "AR2", " A02", "HATwo", "HAtwo", "GATwo", "P4", "GA02", "a1", "LA2", "LATwo"], "r": ["f", "x", "o", "br", "d", "rs", "w", "c", "rc", "k", "er", "ren", "var", "rx", "sr", "n", "p", "s", "rar", "usr", "vr", "rt", "a", "l", "dr", "R", "y", "mr", "e", "rb", "u", "tr", "h", "q", "t", "rg", "v", "m", "ro"], "g": ["f", "x", "gy", "d", "gt", "w", "c", "k", "er", "mg", "group", "gu", "n", "p", "ge", "gr", "gg", "go", "j", "gp", "bg", "gd", "fg", "a", "l", "dr", "y", "gb", "e", "u", "gc", "h", "q", "G", "rg", "m", "v"], "b": ["f", "bb", "o", "bl", "br", "bc", "nb", "d", "w", "c", "B", "db", "n", "p", "bis", "ob", "j", "bs", "bg", "eb", "a", "l", "bi", "y", "ba", "lib", "bd", "z", "base", "gb", "e", "rb", "u", "ib", "h", "t", "be", "v"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,\n\n                void *src)\n\n{\n\n    int result = 0;\n\n\n\n    if (secn > 0) {\n\n        uint32_t size = (uint32_t)secn * 512;\n\n        const uint8_t *sp = (const uint8_t *)src;\n\n        uint8_t *dp = 0;\n\n        if (s->bdrv_cur) {\n\n            dp = g_malloc(size);\n\n            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {\n\n                result = 1;\n\n            }\n\n        } else {\n\n            if (sec + secn > s->secs_cur) {\n\n                result = 1;\n\n            } else {\n\n                dp = (uint8_t *)s->current + (sec << 9);\n\n            }\n\n        }\n\n        if (!result) {\n\n            uint32_t i;\n\n            for (i = 0; i < size; i++) {\n\n                dp[i] &= sp[i];\n\n            }\n\n            if (s->bdrv_cur) {\n\n                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;\n\n            }\n\n        }\n\n        if (dp && s->bdrv_cur) {\n\n            g_free(dp);\n\n        }\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 26158, "substitutes": {"s": ["sys", "sa", "sb", "ops", "store", "syn", "se", "comm", "os", "sports", "rs", "c", "ex", "ses", "ds", "hs", "sync", "g", "r", "spec", "n", "p", "sc", "sh", "sts", "cs", "sw", "aws", "set", "S", "js", "bs", "ss", "so", "a", "is", "b", "ats", "ts", "ns", "ps", "stats", "z", "qs", "south", "st", "es", "its", "gs", "e", "sv", "less", "self", "h", "t", "ls", "stat", "m", "v", "sq", "conf"], "sec": ["sd", "sys", "sn", "cur", "esc", "pas", "syn", "se", "pri", "bc", "seconds", "c", "rc", "tc", "ctr", "reg", "security", "fin", "seq", "secure", "ec", "sr", "SEC", "n", "rec", "sc", "deg", "ser", "sch", "proc", "Sec", "j", "sector", "secondary", "ctx", "enc", "td", "next", "th", "isec", "ss", "section", "ct", "desc", "loc", "sur", "st", "con", "exec", "time", "second", "ptr", "stat", "cc", "sect", "str", "sq"], "secn": ["secno", "secN", "Secn", "securitymn", "seqns", "secsn", "ecns", "prins", "Secns", "rcsn", "securityN", "secnan", "Secd", "procnan", "secmn", "secd", "securityn", "condN", "descN", "ecN", "eccn", "seqmn", "seqn", "seqsn", "seqN", "SecN", " seccn", "condmn", "descsn", "priN", "securityns", "sectN", "ecsn", "seccn", "prin", "pricn", "securityno", "descn", "sectn", "seqd", "condno", "proclen", "Secsn", "secns", "descns", "seqno", "condn", " secns", "ecn", "sectnan", "rcn", "sectlen", " secN", "rcN", "securitysn", " secd", "rcns", "procn", "seqlen", "procN", "seclen", "seqnan"], "src": ["sys", "sn", " dst", "cur", "sb", "stream", "inf", "iv", "rs", "ur", "sub", "rc", "ctr", "sup", "tn", "inst", "r", "sr", "sc", "ser", "img", "sh", "dest", "usr", "bs", "th", "scan", "attr", "start", "loc", "txt", "sur", "st", "source", "ptr", "tmp", "proc"], "sp": ["ep", "prov", "space", "se", "mp", "pp", " Sp", "SP", "bsp", "sl", "ipp", "p", "sch", "sc", "sh", "isp", "esp", "spl", "sw", "ap", "span", "sk", "osp", "spe", "ps", "ip", "sm", " esp", "snap", "tp", "serv", "bp", "sv", "Sp", "lp", "si", "jp"], "dp": ["pd", "dim", "pb", "xy", "dq", "adr", "pipe", "pas", "csv", "pc", "d", "dh", "vp", "pend", "mp", "pp", "cd", "result", "dc", "ds", "buffer", "wd", "db", "cp", "p", "dt", "dm", "di", "buf", "lat", "gp", "coord", "df", "np", "DP", "dl", "ps", "dr", "ip", "dd", "dat", "wp", "delay", "drop", "fd", "tp", "deb", "du", "dk", "fp", "aaa", "ptr", "lp", "pkg", "jp", "dep", "DC", "grad", "broad"], "i": ["it", "ic", "mac", "x", "dim", "ui", "multi", "\u0438", "ie", "ami", "pi", " ni", " ii", "ini", "ex", "spin", "ice", "ri", "fi", "gu", "in", "gi", "I", "p", "phi", "di", "oi", "zi", "sim", "j", "ai", "asi", "mi", "li", "ii", "iq", "print", "is", "ti", "ind", "size", "info", "bi", " ti", "ip", "ij", "y", "ci", "uri", "iu", "ni", "xi", "si", "index", "cli", "m", "qi", "ei", "ix"]}}
{"project": "qemu", "commit_id": "943cec86d0864464ab29b42940c49d1ccbe8d268", "target": 0, "func": "static int nbd_receive_list(QIOChannel *ioc, char **name, Error **errp)\n\n{\n\n    uint64_t magic;\n\n    uint32_t opt;\n\n    uint32_t type;\n\n    uint32_t len;\n\n    uint32_t namelen;\n\n    int error;\n\n\n\n    *name = NULL;\n\n    if (read_sync(ioc, &magic, sizeof(magic)) != sizeof(magic)) {\n\n        error_setg(errp, \"failed to read list option magic\");\n\n        return -1;\n\n    }\n\n    magic = be64_to_cpu(magic);\n\n    if (magic != NBD_REP_MAGIC) {\n\n        error_setg(errp, \"Unexpected option list magic\");\n\n        return -1;\n\n    }\n\n    if (read_sync(ioc, &opt, sizeof(opt)) != sizeof(opt)) {\n\n        error_setg(errp, \"failed to read list option\");\n\n        return -1;\n\n    }\n\n    opt = be32_to_cpu(opt);\n\n    if (opt != NBD_OPT_LIST) {\n\n        error_setg(errp, \"Unexpected option type %\" PRIx32 \" expected %x\",\n\n                   opt, NBD_OPT_LIST);\n\n        return -1;\n\n    }\n\n\n\n    if (read_sync(ioc, &type, sizeof(type)) != sizeof(type)) {\n\n        error_setg(errp, \"failed to read list option type\");\n\n        return -1;\n\n    }\n\n    type = be32_to_cpu(type);\n\n    error = nbd_handle_reply_err(ioc, opt, type, errp);\n\n    if (error <= 0) {\n\n        return error;\n\n    }\n\n\n\n    if (read_sync(ioc, &len, sizeof(len)) != sizeof(len)) {\n\n        error_setg(errp, \"failed to read option length\");\n\n        return -1;\n\n    }\n\n    len = be32_to_cpu(len);\n\n\n\n    if (type == NBD_REP_ACK) {\n\n        if (len != 0) {\n\n            error_setg(errp, \"length too long for option end\");\n\n            return -1;\n\n        }\n\n    } else if (type == NBD_REP_SERVER) {\n\n        if (len < sizeof(namelen) || len > NBD_MAX_BUFFER_SIZE) {\n\n            error_setg(errp, \"incorrect option length\");\n\n            return -1;\n\n        }\n\n        if (read_sync(ioc, &namelen, sizeof(namelen)) != sizeof(namelen)) {\n\n            error_setg(errp, \"failed to read option name length\");\n\n            return -1;\n\n        }\n\n        namelen = be32_to_cpu(namelen);\n\n        len -= sizeof(namelen);\n\n        if (len < namelen) {\n\n            error_setg(errp, \"incorrect option name length\");\n\n            return -1;\n\n        }\n\n        if (namelen > 255) {\n\n            error_setg(errp, \"export name length too long %\" PRIu32, namelen);\n\n            return -1;\n\n        }\n\n\n\n        *name = g_new0(char, namelen + 1);\n\n        if (read_sync(ioc, *name, namelen) != namelen) {\n\n            error_setg(errp, \"failed to read export name\");\n\n            g_free(*name);\n\n            *name = NULL;\n\n            return -1;\n\n        }\n\n        (*name)[namelen] = '\\0';\n\n        len -= namelen;\n\n        if (len) {\n\n            char *buf = g_malloc(len + 1);\n\n            if (read_sync(ioc, buf, len) != len) {\n\n                error_setg(errp, \"failed to read export description\");\n\n                g_free(*name);\n\n                g_free(buf);\n\n                *name = NULL;\n\n                return -1;\n\n            }\n\n            buf[len] = '\\0';\n\n            TRACE(\"Ignoring export description: %s\", buf);\n\n            g_free(buf);\n\n        }\n\n    } else {\n\n        error_setg(errp, \"Unexpected reply type %\" PRIx32 \" expected %x\",\n\n                   type, NBD_REP_SERVER);\n\n        return -1;\n\n    }\n\n    return 1;\n\n}\n", "idx": 26160, "substitutes": {"ioc": ["tioco", "liocal", "oosc", "piect", "not", " iect", "iocy", "liosc", "iniod", "liocol", "iocom", "ooco", "pioco", "piod", "piocol", "oect", "liect", "piocon", "iocal", " iot", "ciocal", "lioci", "piot", "oocon", "iniocol", "ciocy", "tiocol", "tiosc", "oOC", " iosc", "noc", "iniect", "ioci", "piocom", "iect", "inioc", " iocom", "inocal", "tioci", "liod", "inoc", "tiect", "ioco", "ciosc", "tiocy", "ooc", "liocr", "tioc", "iOC", "piosc", "inosc", "lioc", "piOC", "nOC", "iot", " ioco", "cioco", "iocr", "ciocr", "pioci", "iod", "piocy", "iosc", "oocom", "cioc", "nocon", " iocon", "pioc", "iocol", "iocon", " iOC", "inocr"], "name": ["out", "ref", "code", "nam", "w", "part", "c", "id", "word", "mem", "buffer", "var", "path", "comment", "cmd", "family", "n", "p", "alias", "prefix", "new", "msg", "call", "order", "data", "NAME", "key", "base", "ame", "version", "Name", "channel", "no", "str", "names"], "errp": [" errP", "nerpatch", "aerwp", "erm", "errg", " errping", "rersp", "rrP", "errorcp", "sprp", " errwp", " errpos", "errorpos", "errwp", " errv", "errcp", "errsp", "rerpp", "erp", "resultpat", "rerP", "errorm", "privp", "privP", "rrv", "errorpa", " errm", " errpa", "rerpatch", "errm", "erd", "errpos", "errP", "rrpat", "nerpc", "sprping", "sprP", "arrp", "erpat", "diesp", "resultcp", "eorg", " errps", "erwp", "errpa", "rrd", "errpt", "rercp", "errps", "aerp", "rerp", "resultd", "arrpt", "rrm", "errping", "aerr", "eorp", "errorps", "errr", "erpp", "errd", "rrcp", "errpatch", "eorP", "errorp", "privnp", "resultp", "rerg", "diepatch", "nerp", "sprpos", "eornp", "rerps", "errorping", "err", "errorpp", "rerpa", " errr", "eorpp", "nersp", "rerpt", "ernp", "arrg", "diep", "rrp", "errpc", "rerpc", "errv", "eorpt", "errnp", "eorpa", "errpat", "errorv", "diepc", "erP", "errorP", "privpp", "arrpa", "errpp", "ercp"], "magic": ["tech", "icon", "id", "virt", "prefix", "vol", "phot", "bug", "agic", "info", "serial", "usage", "pkg", "xxx", "jar", "zone", "code", "try", "auth", "mag", "header", "spec", "mode", "tab", "inv", "tag", "Magic", "notice", "volume", "meta", "format", "method", "pic", "ix", "phone", "op", "part", "seq", "comment", "metadata", "alias", "area", "xx", "policy", "phys", "generic", "eric", "cookie", "version", "style", "kind", "iso", "stat", "hello", "ic", "photo", "mac", "options", "power", "hash", "MAG", "zero", "md", "cmd", "module", "iq", "flag", "encrypted", "mist", "psy", "mid", "init", "conf"], "opt": ["other", "alt", "cmp", "hop", "id", "mem", "lt", "p", "OP", "open", "pos", "rt", "attr", "size", "info", "expr", "ox", "opted", "max", "pt", "tx", "obj", "xy", "temp", "oss", "cat", "ver", "tip", "mode", "tag", "ts", "window", "trial", "bin", "iter", "net", "slot", "timeout", "offset", "format", "ot", "op", "eff", "pot", "optim", "mot", "fit", "Opt", "alloc", "serv", "rot", "off", "stat", "no", "option", "prop", "typ", "out", "err", "options", "nom", "bit", "vert", "oop", "cho", "ext", "cmd", "list", "org", "util", "usr", "order", "feat", "num", "val", "psy", "init"], "type": ["other", "field", "ror", "icon", "id", "word", "er", "var", "um", "command", "p", "dt", "call", "pe", "rt", "types", "size", "color", "mt", " TYPE", "pt", "role", "action", "font", "temp", "try", " kind", "code", "ty", "tool", "cat", "spec", "ver", "sort", "tag", " typ", "TYPE", "ped", "class", "ping", "cl", "box", "op", "part", "ype", " Type", "family", "form", "rule", " ty", "file", "test", "tp", "style", "kind", "time", "all", "no", "block", "pre", "typ", "where", "err", "options", "like", "event", "what", "ack", "rel", "set", "to", "start", "Type", "check", "t"], "len": ["wid", "length", "ld", "lit", "gen", "err", "ll", "tl", "syn", "L", "ln", "ell", "nl", "mem", "lt", "sl", "seq", "lic", "late", "fin", "del", "fl", "n", "el", "lf", "Len", "resp", "msg", "bytes", "le", "lon", "lin", "pos", "enc", "els", "vec", "li", "l", "ind", "dl", "size", "lan", "nt", "loc", "lib", "data", "lim", "mn", "lang", "num", "coll", "iter", "val", "en", "hl", "label", "il", "lp", "kl", "elt", "ls", "lex", "ml", "t"], "namelen": [" Namelens", " Namelem", "namelsize", "namelax", "namELem", "basellower", "namelsax", "sanlen", "namelem", "namellize", "namellen", "baselower", "namelsem", "namellon", "scriblen", "baselon", "namelsower", "namelens", " Namelsize", "basellen", "basellax", "baselen", " Namelsens", "namelower", "namELize", "namelsens", "namELens", "namellem", " Namelsem", "namellens", " Namelen", "baselax", " Namelsen", "namelon", "namearon", "namELen", "sequlen", "san_", "namellax", "basellon", "namlen", "namelize", "scrib_", "namearen", "namelson", "nam_", "namearax", " Namelize", "namearower", "namelsen", "namellower", "sequ_"], "error": ["option", "danger", "length", "err", "ror", "feature", "success", "status", "code", "fee", "none", "pad", " ERROR", "valid", "panic", "rc", "result", "Error", "debug", "event", "er", "command", "or", "row", "loss", "empty", "comment", "r", "ack", "ERROR", "state", "order", "coord", " Error", "message", "total", "bug", "complete", "rank", "size", "info", "start", "progress", "relation", "draw", "serial", "style", "e", "iso", "offset", "errors", "end", "no", "ro", "ion"]}}
{"project": "FFmpeg", "commit_id": "bf238a6a3ca92de686e0e103135c1336f33f685b", "target": 1, "func": "static int hwupload_query_formats(AVFilterContext *avctx)\n\n{\n\n    HWUploadContext *ctx = avctx->priv;\n\n    AVHWFramesConstraints *constraints = NULL;\n\n    const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;\n\n    AVFilterFormats *input_formats = NULL;\n\n    int err, i;\n\n\n\n    if (!avctx->hw_device_ctx) {\n\n        av_log(ctx, AV_LOG_ERROR, \"A hardware device reference is required \"\n\n               \"to upload frames to.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx);\n\n    if (!ctx->hwdevice_ref)\n\n        return AVERROR(ENOMEM);\n\n    ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data;\n\n\n\n    constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL);\n\n    if (!constraints) {\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    input_pix_fmts  = constraints->valid_sw_formats;\n\n    output_pix_fmts = constraints->valid_hw_formats;\n\n\n\n    input_formats = ff_make_format_list(output_pix_fmts);\n\n    if (!input_formats) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    if (input_pix_fmts) {\n\n        for (i = 0; input_pix_fmts[i] != AV_PIX_FMT_NONE; i++) {\n\n            err = ff_add_format(&input_formats, input_pix_fmts[i]);\n\n            if (err < 0) {\n\n                ff_formats_unref(&input_formats);\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats);\n\n\n\n    ff_formats_ref(ff_make_format_list(output_pix_fmts),\n\n                   &avctx->outputs[0]->in_formats);\n\n\n\n    av_hwframe_constraints_free(&constraints);\n\n    return 0;\n\n\n\nfail:\n\n    av_buffer_unref(&ctx->hwdevice_ref);\n\n    av_hwframe_constraints_free(&constraints);\n\n    return err;\n\n}\n", "idx": 26173, "substitutes": {"avctx": ["avercmp", "avecontext", "averctx", " avcmp", "aftx", "avercv", "wavca", "avobj", "avcp", "avecmp", "wavtx", "wavcv", "aveobj", "avemsg", "avercontext", "afhandle", "avesys", " avcv", "avecv", " avcp", "avcv", " avobj", "avejp", " avmsg", "wavctx", "aversys", "averjp", "AVctx", "avertx", "avhandle", "averobj", "avectx", "avjp", "avecrit", "afctx", "avercp", "avercrit", "avmsg", "avcrit", "avtx", " avtx", "avsys", "AVcontext", "afcmp", "afcontext", "AVtx", "averca", "avecp", "afjp", "avcmp", "avetx", "averhandle", "avermsg", "avehandle", "aveca", "afcrit", " avcontext", "afsys", "avcontext", "AVcmp", "avca"], "ctx": ["cl", "context", "cmp", "x", "tm", "tx", "cf", "obj", "jac", "ca", "cu", "conn", "ka", "comm", "bc", "config", "tc", "ctr", "kt", "rc", "abc", "ck", "mk", "act", "ctrl", "func", "cmd", "ctl", "cp", "p", "today", "sc", "pg", "nc", "prefix", "cb", "cm", "np", "co", "cfg", "rt", "CT", "ct", "xc", "ac", "nt", "req", "unc", "aus", "loc", "txt", "alloc", "utils", "Conn", "kw", "xp", "etc", "gc", "pkg", "timeout", "kl", "jp", "cc", "proc", "wx", "lc", "cv", "hw"], "constraints": ["Constubs", "Constraint", "conbritions", "cospats", "constantacts", "aconstantinters", "contencies", "aconstraints", " conjains", "consts_", "Constaint", "const_", "constraint", "contrubs", "constsaints", "costritions", "confst_", " conjaint", "conspitions", "comtencies", "constantinters", "contraints", "conjaints", "comtaints", "constracts", "costraints", "comstraints", "costrats", "constantaints", "aconstantaints", "constencies", "confstfree", "construbs", "convertitions", "contrencies", "convertents", "conjents", "constaints", "contrains", "conbraints", "Constaints", " constrains", "constains", " conjents", "constsacts", "conspaints", "Constains", "constrats", "constsinters", "comtains", "containt", " constraint", "constsfree", "concontaint", "concontaints", "comstraint", "comstrencies", "Constrains", "Construbs", "aconstantures", "aconstrures", "constaint", "constsures", "containts", "cospitions", "constrfree", "constr_", "conjains", "construres", "conformaints", "constfree", "conspats", "cospents", "aconstantacts", "costrents", "conformures", "constrinters", " constrents", "constantures", "constritions", "contraint", "comtaint", "conspents", "conjaint", "constrains", "Constraints", "conforminters", "confstrfree", "concompl_", "constrents", "convertaints", "aconstracts", "aconstrinters", " conjaints", "convertats", "confstr_", "conbrents", "concontains", "comstrains", "contrents", "concontubs", "constubs", "concomplfree", "contains", "cospaints", "constrencies", "conformacts", "conbrats", "constents"], "input_pix_fmts": ["input_pix_famls", "input_pix_famts", "input_pix_formls", "input_pix_rmodes", "input_pix__fmts", "input_pix_famats", "input_pix_flets", "input_pix_rmls", "input_pix__fmats", "input_pix_fleats", "input_pix_formts", "input_pix_famters", "input_pix_flems", "input_pix__fmcs", "input_pix_fnts", "input_pix_mts", "input_pix_fmls", "input_pix__famts", "input_pix_fmats", "input_pix_cmats", "input_pix__famters", "input_pix__famcs", "input_pix_rmats", "input_pix_mcs", "input_pix_fnats", "input_pix_cmcs", "input_pix_rmters", "input_pix__fmters", "input_pix_fncs", "input_pix_fnms", "input_pix_cmms", "input_pix_flecs", "input_pix_cmts", "input_pix_formodes", "input_pix_famcs", "input_pix__famats", "input_pix_mters", "input_pix_fleters", "input_pix_mats", "input_pix_fmcs", "input_pix_formats", "input_pix_famodes", "input_pix_cmters", "input_pix_fmters", "input_pix_rmcs", "input_pix_fnters", "input_pix_fmms", "input_pix_fmodes", "input_pix_rmts"], "output_pix_fmts": ["output_pix_cmters", "output_pix_mars", "output_pix_mms", "output_pix_famats", "output_pix_mters", "output_pix_famts", "output_pix_cmats", "output_pix_rmts", "output_pix_fxats", "output_pix_mcs", "output_pix_fmms", "output_pix_fxts", "output_pix_formars", "output_pix_rmms", "output_pix_formms", "output_pix_rmats", "output_pix_famcs", "output_pix_fmters", "output_pix_famters", "output_pix_mats", "output_pix_fmats", "output_pix_fxters", "output_pix_fnts", "output_pix_rmcs", "output_pix_cmcs", "output_pix_rmars", "output_pix_fmars", "output_pix_fmcs", "output_pix_rmters", "output_pix_cmts", "output_pix_fncs", "output_pix_fxcs", "output_pix_fnters", "output_pix_formts", "output_pix_fnats", "output_pix_mts"], "input_formats": ["input_spets", "input_formsATS", "input_formslations", "input_streamats", "input_handATS", "input_facATS", "input_handts", "input_fmts", "input_forATS", "input_facts", "input_forulas", "input_regorts", "input_formations", "input_speats", "input_regats", "input_transformorts", "input_formims", "input_formatations", "input_fmlations", "input_formsits", "input_formsels", "input_formatates", "input_parentits", "input_fmats", "input_formsations", "input_parentats", "input_formits", "input_formsims", "input_famatted", "input_formts", "input_transformats", "input_formulas", "input_facats", "input_regits", "input_parentuts", "input_transformits", "input_parentorts", "input_formlations", "input_factums", "input_formatts", "input_formuts", "input_reguts", "input_formsulas", "input_formsts", "input_famats", "input_transformuts", "input_formATS", "input_formatats", "input_formates", "input_famlations", "input_formums", "input_factats", "input_compATS", "input_forats", "input_speates", "input_formsats", "input_factates", "input_compits", "input_compats", "input_handims", "input_factels", "input_streamels", "input_famts", "input_formatted", "input_formels", "input_streamums", "input_formsatted", "input_handats", "input_compulas", "input_forits", "input_fmatted", "input_facims", "input_formsums", "input_formorts", "input_formsates", "input_speations", "input_streamates"], "err": ["it", "peer", "ner", "obj", "lr", "ev", "br", "score", "norm", "try", "fee", "nr", "c", "fr", "ctr", "Error", "rev", "error", "er", "rr", "gz", "conf", "pr", "or", "later", "r", "cmd", "oe", "arr", "gr", "kr", "resp", "rar", "usr", "rel", "buf", "msg", "order", "warn", "die", "cfg", "inner", "ach", "req", "test", "attr", "eas", "notice", "yr", "mr", "cr", "txt", "e", "rb", "aaa", "iter", "der", "trace", "errors", "Er", "t", "elt", "str", "cli", "drm", "res"], "i": ["ji", "it", "ic", "batch", "x", "ui", "multi", "\u0438", "ki", "ma", "us", "ami", "pi", "c", "id", "ini", "yi", "g", "r", "gi", "me", "I", "n", "p", "phi", "s", "di", "zi", "sim", "j", "ai", "asi", "mi", "li", "ii", "hi", "init", "ti", "ind", "ip", "bi", "y", "ims", "ci", "iter", "ir", "iu", "xi", "si", "index", "v", "cli", "m", "qi", "mu", "ei", "ix"]}}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    char *msg1, *msg2;\n\n\n\n    if (errp == NULL) {\n\n        return;\n\n    }\n\n\n\n    va_start(ap, fmt);\n\n    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);\n\n    va_end(ap);\n\n\n\n    if (win32_err != 0) {\n\n        msg1 = (*errp)->msg;\n\n        msg2 = g_win32_error_message(win32_err);\n\n        (*errp)->msg = g_strdup_printf(\"%s: %s (error: %x)\", msg1, msg2,\n\n                                       (unsigned)win32_err);\n\n        g_free(msg2);\n\n        g_free(msg1);\n\n    }\n\n}\n", "idx": 26175, "substitutes": {"errp": [" errpar", "errorpa", " erpa", "erping", " errpa", "thinkpar", "thinkpa", "attrp", "attrping", " erpar", " errP", "errorping", "dieP", "dier", "errping", "errP", " errr", "rrping", "attrcp", "errorr", " errping", "errr", "ferp", "rrP", "thinkP", "errorcp", "diep", "rrp", "diepar", "errcp", " err", "ferpar", "erp", "errorp", "thinkp", "ferpa", "ferP", "diepa", "rrpa", " erp", "erP", "errorP", "errpar", "erpa", " errcp", "attrP", "errpa"], "win32_err": ["win32__er", "win32_buf", "win32_er", "win64_msg", "win32__err", "win32_rr", "win32_dist", "win64_error", "win32_error", "win32__error", "win32_msg", "win64_buf", "win64_err"], "fmt": ["Fformat", "frtt", "facfm", "fMT", "flt", "Flt", "frfm", "forprintf", "formt", "Fprintf", " ftxt", " flt", "fformat", "xfformat", "forMT", "xftxt", "frformat", "ftt", "frmt", "factt", "ffm", "xfmt", "forformat", "xflt", "facmt", " fMT", "Ftxt", " ffm", "Fmt", "ftxt", " ftt", "FMT", "facformat", " fformat"], "ap": [" app", " tap", " pc", "al", "op", "api", "ape", "arp", "aj", " map", "app", "att", "mp", "vp", " sc", "pad", "map", "pp", " p", "sam", " ip", "at", "ipp", "um", "apt", " pat", "apa", "ar", "p", "ax", " sp", " av", "amp", "up", "av", " rep", " cp", "html", "AP", " sa", " sap", "ip", "ac", "pa", " sv", " cap", " op", "aps", "snap", "sp", "tp", "cap", "ab", " pad", " mp", "rap", "tap", " ac"], "msg1": ["reasonp", "msg0", "lem30", "cmd2", "good1", "lem1", " msg3", "lemOne", " msg0", "cmd0", "MsgOne", "goodp", "reason001", "Msg2", "Msg1", "Msg51", "good001", "reason2", "lem2", "good2", " msg001", "msg001", " msgOne", "Msg0", "Msg3", "msg51", "cmd3", "Msg30", "msg3", " msgp", "msgOne", "msgp", "reason1", " msg51", "msg30", "imm1", "cmd1", "imm2", "imm51", " msg30", "imm3"], "msg2": [" msg02", "message3", "g3", "gent1", "gemB", " msg3", "message1", "Msgtwo", "message2", " msgB", "msgTwo", "gemTwo", " msgtwo", "Msg2", "msg82", "Msg02", "Msg1", "ogTwo", "og82", "g1", " msg82", " msgTwo", "msgtwo", "msg02", "g2", "Msg3", "gent02", "gem2", "gtwo", "msg3", "og2", "ogB", "gem82", "msgB", "gent2"]}}
{"project": "FFmpeg", "commit_id": "0114c571d4c8cc1036850ced924683709390681a", "target": 1, "func": "void ff_MPV_frame_end(MpegEncContext *s)\n\n{\n\n    int i;\n\n    /* redraw edges for the frame if decoding didn't complete */\n\n    // just to make sure that all data is rendered.\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {\n\n        ff_xvmc_field_end(s);\n\n   } else if((s->error_count || s->encoding || !(s->avctx->codec->capabilities&CODEC_CAP_DRAW_HORIZ_BAND)) &&\n\n              !s->avctx->hwaccel &&\n\n              !(s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU) &&\n\n              s->unrestricted_mv &&\n\n              s->current_picture.f.reference &&\n\n              !s->intra_only &&\n\n              !(s->flags & CODEC_FLAG_EMU_EDGE)) {\n\n        int hshift = av_pix_fmt_descriptors[s->avctx->pix_fmt].log2_chroma_w;\n\n        int vshift = av_pix_fmt_descriptors[s->avctx->pix_fmt].log2_chroma_h;\n\n        s->dsp.draw_edges(s->current_picture.f.data[0], s->current_picture.f.linesize[0],\n\n                          s->h_edge_pos, s->v_edge_pos,\n\n                          EDGE_WIDTH, EDGE_WIDTH,\n\n                          EDGE_TOP | EDGE_BOTTOM);\n\n        s->dsp.draw_edges(s->current_picture.f.data[1], s->current_picture.f.linesize[1],\n\n                          s->h_edge_pos >> hshift, s->v_edge_pos >> vshift,\n\n                          EDGE_WIDTH >> hshift, EDGE_WIDTH >> vshift,\n\n                          EDGE_TOP | EDGE_BOTTOM);\n\n        s->dsp.draw_edges(s->current_picture.f.data[2], s->current_picture.f.linesize[2],\n\n                          s->h_edge_pos >> hshift, s->v_edge_pos >> vshift,\n\n                          EDGE_WIDTH >> hshift, EDGE_WIDTH >> vshift,\n\n                          EDGE_TOP | EDGE_BOTTOM);\n\n    }\n\n\n\n    emms_c();\n\n\n\n    s->last_pict_type                 = s->pict_type;\n\n    s->last_lambda_for [s->pict_type] = s->current_picture_ptr->f.quality;\n\n    if (s->pict_type!= AV_PICTURE_TYPE_B) {\n\n        s->last_non_b_pict_type = s->pict_type;\n\n    }\n\n#if 0\n\n    /* copy back current_picture variables */\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n\n        if (s->picture[i].f.data[0] == s->current_picture.f.data[0]) {\n\n            s->picture[i] = s->current_picture;\n\n            break;\n\n        }\n\n    }\n\n    assert(i < MAX_PICTURE_COUNT);\n\n#endif\n\n\n\n    if (s->encoding) {\n\n        /* release non-reference frames */\n\n        for (i = 0; i < s->picture_count; i++) {\n\n            if (s->picture[i].f.data[0] && !s->picture[i].f.reference\n\n                /* && s->picture[i].type != FF_BUFFER_TYPE_SHARED */) {\n\n                free_frame_buffer(s, &s->picture[i]);\n\n            }\n\n        }\n\n    }\n\n    // clear copies, to avoid confusion\n\n#if 0\n\n    memset(&s->last_picture,    0, sizeof(Picture));\n\n    memset(&s->next_picture,    0, sizeof(Picture));\n\n    memset(&s->current_picture, 0, sizeof(Picture));\n\n#endif\n\n    s->avctx->coded_frame = &s->current_picture_ptr->f;\n\n\n\n    if (s->codec_id != AV_CODEC_ID_H264 && s->current_picture.f.reference) {\n\n        ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX, 0);\n\n    }\n\n}\n", "idx": 26183, "substitutes": {"s": ["ops", "comm", "sports", "c", "comments", "tests", "p", "changes", "ains", "aws", "vs", "S", "ns", "ies", "y", "states", "less", "h", "sq", "ess", "args", "os", "erences", "rs", "us", "ges", "n", "sc", "cs", "ags", "services", "j", "als", "ats", "ts", "ims", "tes", "styles", "its", "ers", "eds", "parts", "m", "sys", "ms", "as", "ins", "gets", "ants", "ties", "ses", "has", "ids", "sts", "sw", "bs", "a", "is", "b", "ps", "stats", "gs", "ls", "ports", "csv", "se", "fs", "w", "bes", "aunts", "ds", "hs", "details", "g", "sets", "ans", "js", "ss", "qs", "es", "sv", "t", "events"], "i": ["it", " j", " c", "o", "pi", "c", " ii", "I", "p", " bi", "j", " v", "mi", "ii", "is", "ti", "l", "b", " ti", " pi", "bi", "ati", "ci", " m", "si", "t", "m", "v"]}}
{"project": "qemu", "commit_id": "b9ce1454e14ec918acb90d899ce7724f69682f45", "target": 0, "func": "int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)\n\n{\n\n    int size, l;\n\n\n\n    if (f->is_write)\n\n        abort();\n\n\n\n    size = size1;\n\n    while (size > 0) {\n\n        l = f->buf_size - f->buf_index;\n\n        if (l == 0) {\n\n            qemu_fill_buffer(f);\n\n            l = f->buf_size - f->buf_index;\n\n            if (l == 0)\n\n                break;\n\n        }\n\n        if (l > size)\n\n            l = size;\n\n        memcpy(buf, f->buf + f->buf_index, l);\n\n        f->buf_index += l;\n\n        buf += l;\n\n        size -= l;\n\n    }\n\n    return size1 - size;\n\n}\n", "idx": 26191, "substitutes": {"f": ["fx", "fb", "af", "x", "ef", "full", "i", "cf", "o", "inf", "of", "ref", "fw", "uf", "ff", "fee", "fs", "d", "tf", "w", "part", "c", "fr", "flow", "bf", "fl", "um", "fm", "fi", "g", "r", "lf", "p", "util", "form", "df", "rf", "fg", "print", "file", "xf", "b", "fal", "fab", "info", "fac", "ct", "ac", "fe", "fd", "fc", "e", "fo", "sf", "exec", "fp", "self", "t", "h", "q", "m", "v", "F", "conf"], "buf": ["block", "fb", "cur", "batch", "length", "pb", "err", "obj", "ref", "queue", "uf", "br", "bl", "mb", "bc", "w", "map", "result", "bf", "buffer", "mem", "seq", "var", "cmd", "p", "Buff", "cache", "arr", "img", "msg", "cb", "dest", "ctx", "bar", "pos", "vec", "raw", "orig", "b", "data", "loc", "addr", "txt", "bin", "iter", "rb", "cap", "Buffer", "buff", "ptr", "tr", "h", "pkg", "tmp", "off", "end", "v", "str", "init", "cv", "mu"], "size1": ["position001", "style0", " size0", "SIZE0", "SIZE2", "position0", "sizeOne", "ize2", "offset2", "ize1", "position1", "sizeone", " sizeone", " sizeOne", "typeOne", "size2", "offset1", "offset01", "positionone", "type2", "size01", " size001", "style001", " size01", "size0", "type0", "SIZEOne", " size2", "style1", "type1", "styleone", "size001", "SIZE1", "ize01"], "size": ["status", "c", "storage", "id", "count", "s", "any", "scale", "z", "scope", "il", "si", "h", "max", "v", "sn", "space", "i", "negative", "ce", "code", "ose", "height", "n", "send", "ize", "le", "total", "shape", "notice", "offset", "m", "type", "length", "x", "iz", "body", "now", "sent", "capacity", "is", "st", "gs", "style", "sized", "number", "all", "sum", "no", "al", "len", "w", "zero", "g", "empty", "small", "set", "message", "since", "shift", "SIZE", "south", "e", "sp", "Size", "t", "name"], "l": ["it", "i", "length", "lit", "ld", "lo", "o", "ll", "lr", "al", "lv", "rl", "len", "tl", "L", "d", "v", "ln", "c", "ell", "nl", "er", "lt", "sl", "fl", "ul", "lay", "g", "list", "lf", "el", "p", "n", "s", "le", "lin", "j", "dL", "pl", "li", "shell", "h", "b", "dl", "loc", "lib", "la", "z", " L", "limit", "hl", "u", "il", "lp", "kl", "ls", "ly", "all", "m", "lb", "lc", "loop"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void *rom_ptr(target_phys_addr_t addr)\n\n{\n\n    Rom *rom;\n\n\n\n    rom = find_rom(addr);\n\n    if (!rom || !rom->data)\n\n        return NULL;\n\n    return rom->data + (addr - rom->addr);\n\n}\n", "idx": 26225, "substitutes": {"addr": [" wr", " dst", "oad", "inter", " ax", "ad", "alt", "tx", "err", "obj", "adr", "address", "ref", "dir", "len", "conn", "dh", "pad", "rs", "xt", "rc", "id", "at", "reg", "mem", " amp", "wd", "rid", "act", "r", "cmd", "ack", " alk", "ar", "res", "arr", "add", "ord", "irm", " arg", "rel", "arity", "coord", "pos", " err", " address", "eth", "rt", "req", "data", "attr", "ag", "dr", "load", "loc", "src", "igh", "Address", " ptr", " plat", "tp", " tid", "mt", "hl", "ret", "ptr", "offset", "max", "cap", "mid", "pt", "ix"], "rom": ["ost", " chrom", "red", "mos", "chrom", "rome", "rol", "rm", "rum", "nom", "prem", "norm", "comm", "stim", "rock", "rs", "roc", "crypt", "rd", "rc", "core", "rob", "ck", "rx", "arm", "r", "ro", "cmd", "ROM", "rax", "res", "irm", "cm", "rem", "rep", "com", "stan", "mom", "any", "ind", "dr", "mr", "ocr", "om", "ox", "cr", "dem", "gem", "serv", "dom", "tom", "ram", "roma", "lex", "m", "prom", "rn", "drm", "rim"]}}
{"project": "qemu", "commit_id": "90e56fb46d0a7add88ed463efa4e723a6238f692", "target": 0, "func": "static void *do_data_decompress(void *opaque)\n\n{\n\n    DecompressParam *param = opaque;\n\n    unsigned long pagesize;\n\n\n\n    while (!quit_decomp_thread) {\n\n        qemu_mutex_lock(&param->mutex);\n\n        while (!param->start && !quit_decomp_thread) {\n\n            qemu_cond_wait(&param->cond, &param->mutex);\n\n        }\n\n        if (!quit_decomp_thread) {\n\n            pagesize = TARGET_PAGE_SIZE;\n\n            /* uncompress() will return failed in some case, especially\n\n             * when the page is dirted when doing the compression, it's\n\n             * not a problem because the dirty page will be retransferred\n\n             * and uncompress() won't break the data in other pages.\n\n             */\n\n            uncompress((Bytef *)param->des, &pagesize,\n\n                       (const Bytef *)param->compbuf, param->len);\n\n        }\n\n        param->start = false;\n\n        qemu_mutex_unlock(&param->mutex);\n\n\n\n        qemu_mutex_lock(&decomp_done_lock);\n\n        param->done = true;\n\n        qemu_cond_signal(&decomp_done_cond);\n\n        qemu_mutex_unlock(&decomp_done_lock);\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 26226, "substitutes": {"opaque": ["OPaque", " opulse", "oaque", "spaques", "OPaques", "iopaques", "OPane", "spaque", "spque", "oulse", "opque", " opaques", "oaques", "spane", " Oplay", " Opaque", " Opulse", "olay", " Opaques", "iopaque", "iopane", "OPque", "opane", "opulse", "oplay", " oplay", "iopque", "opaques"], "param": ["argument", "service", "nam", "common", "mem", "command", "var", "iam", "p", "prefix", "asm", "monitor", "par", "rem", "info", "sm", "ams", "pt", "cal", "pai", "canon", "item", "pri", "term", "park", "config", "error", "add", "dm", "tag", "mark", "ram", "m", "prom", "program", "aram", "admin", "min", "def", "mm", "member", "comment", "arg", "cm", "view", "Param", "form", "dem", "package", "im", "sum", "property", "parse", "pm", "attribute", "prop", "client", "mont", "pas", "ref", "man", "ann", "meter", "local", "params", "resp", "module", "project", "am", "num", "check", "unknown", "jp", "index", "name", "conf"], "pagesize": ["blocksiz", "mapspeed", " pagesizer", "planesized", "pagesizer", "mapsize", " pagesized", "blocksIZE", "Pagessize", "mapsized", "imagesized", " pagesiz", "mapsizer", "blockssize", "blocksz", "blocksized", "pagesiz", "planesize", "Pagesize", " pagespeed", "pagesz", "Pagesz", "pagessize", " pagesIZE", "PagesIZE", " pagessize", "pagesized", "pagesIZE", "imagesiz", "imagesize", "blocksize", "blocksizer", "planesizer", "imagesizer", "pagespeed", "planespeed", " pagesz"]}}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "long do_sigreturn(CPUSH4State *regs)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t target_set;\n\n    target_ulong r0;\n\n    int i;\n\n    int err = 0;\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    fprintf(stderr, \"do_sigreturn\\n\");\n\n#endif\n\n    frame_addr = regs->gregs[15];\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n   \tgoto badframe;\n\n\n\n    __get_user(target_set.sig[0], &frame->sc.oldmask);\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        __get_user(target_set.sig[i], &frame->extramask[i - 1]);\n\n    }\n\n\n\n    if (err)\n\n        goto badframe;\n\n\n\n    target_to_host_sigset_internal(&blocked, &target_set);\n\n    do_sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    if (restore_sigcontext(regs, &frame->sc, &r0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return r0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 26234, "substitutes": {"regs": ["secals", "regS", " regS", "sects", "regds", "secrs", " regns", " regds", "Regrs", " regts", "secs", "Regs", "mems", "Regns", "memrs", " regals", "regts", "memS", " regrs", "secns", "memals", "RegS", "Regts", "regals", "regns", "Regals", "Regds", "secds", "regrs"], "frame": ["f", "block", "range", "context", "type", "field", "fram", "cf", "force", "reset", "zone", "feature", "code", "Frame", "component", "def", "flow", "fr", "profile", "word", "event", "error", "buffer", "object", "request", "target", "row", "framework", "header", "ace", "state", "call", "module", "ctx", "frames", "rame", "function", "session", "hide", "next", "sequence", "image", "face", "chain", " Frame", "line", "connection", "file", "process", "hole", "feat", "orig", "iframe", "window", "base", "step", "version", "style", "channel", "scope", "trace", "source", "fake", "ptr", "t", "scene", "dict", "point", "lock", "role", "locked"], "frame_addr": ["frame_offset", "range____pat", "frame_add", "frame_id", "frame_pat", " frame_add", "range_addr", "Frame_addr", "range_pos", " frame_ptr", "range____pos", " frame_id", "frame___addr", "frame___pos", "profile_ptr", "profile_addr", "frame_address", "range_pat", "frame____pat", "Frame_ptr", "frame____addr", "profile_offset", "Frame_address", "frame____pos", "range____addr", " frame_address", "frame___pat", "frame_ptr", "frame_pos"], "blocked": ["block", "blanned", "BLocked", " blacked", "BLocking", " blanned", "Block", "slocked", "bloved", "blocking", "gloved", "glocking", "blOCK", "Bloved", "flacked", "BlOCK", "flocked", "Blocking", "slocking", "bracked", "flanned", "brock", "brocked", " block", "flock", "glock", "BLock", "Blocked", "blacked", "BLOCK", "glOCK", "sloved", "slOCK", "branned", "glocked"], "target_set": ["target_name", " target_SET", "targetlysc", "arg2name", "target2sets", "target2set", "taskvalsetting", "arg2sets", "target2setting", "taskvalset", "target_sc", "taskvalsets", "target_setting", "arg_name", "arg2sc", "target_Set", "targetlyname", "task_setting", "task_set", "target_list", "arg_sets", "targetingtag", " target_tag", "targetvalsetting", "targetingset", "target2sc", "target_tag", "task_sets", "target_sets", "targetlysets", "arg2set", "arg_set", "target___set", "target___list", "targetingSET", "targetvalset", "arg_sc", " target_list", "targetlyset", "target2name", "targetvalsets", "target___Set", " target_Set", "target_SET"], "r0": ["r2", " roval", "R0", "pzero", "mr1", "mroval", "errzero", "err2", "p0", "mr0", "err0", " rzero", "rar0", "err1", " r2", "R1", "mr2", "rzero", " r1", "roval", "Rzero", "Roval", "R2", "r1", "rarzero", "rar1", "p2", "p1"], "i": ["it", "ic", "ms", "x", "ui", " j", "multi", "\u0438", "ki", "ami", "pi", "c", " ii", "id", "ini", "index", "ri", "fi", "g", "in", "me", "gi", "I", "n", "p", "phi", "io", "di", "oi", "zi", "sim", "j", "ai", "span", "mi", "li", "ii", "hi", "is", "ti", "ind", "l", "info", "bi", "ip", "y", "ci", "z", "uri", "e", "xi", "si", "t", "im", "m", "v", "cli", "qi", "ei", "ix"]}}
{"project": "qemu", "commit_id": "b8eb5512fd8a115f164edbbe897cdf8884920ccb", "target": 0, "func": "static void apic_reset_common(DeviceState *dev)\n\n{\n\n    APICCommonState *s = APIC_COMMON(dev);\n\n    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);\n\n    bool bsp;\n\n\n\n    bsp = cpu_is_bsp(s->cpu);\n\n    s->apicbase = APIC_DEFAULT_ADDRESS |\n\n        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;\n\n\n\n    s->vapic_paddr = 0;\n\n    info->vapic_base_update(s);\n\n\n\n    apic_init_reset(dev);\n\n\n\n    if (bsp) {\n\n        /*\n\n         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization\n\n         * time typically by BIOS, so PIC interrupt can be delivered to the\n\n         * processor when local APIC is enabled.\n\n         */\n\n        s->lvt[APIC_LVT_LINT0] = 0x700;\n\n    }\n\n}\n", "idx": 26242, "substitutes": {"dev": ["sd", "sys", "device", "ad", "Device", "hid", "ev", "conn", "os", "d", "pad", "adv", "w", "def", "watch", "debug", "er", "ds", "mem", "spec", "DEV", "ver", "p", "ve", "res", "dm", "go", "an", "devices", "doc", "test", "nt", "de", "des", "dem", "Dev", "pro", "serv", "self", "proc", "v", "hw"], "s": ["sd", "sys", "i", "sb", "out", "o", "obj", "os", "se", "d", "v", "rs", "c", "ses", "ds", "sl", "g", "r", "n", "p", "state", "cs", "sts", "go", "an", "S", "js", "ss", "so", "a", "is", "b", "ts", "ns", "ps", "y", "utils", "es", "gs", "e", "sv", "serv", "self", "h", "t", "ls", "m", "sq"], "info": ["f", "class", "sys", "type", "i", "where", "inf", "o", "os", "op", "id", "auth", "details", "now", "fi", "res", "io", "j", "isu", "information", "INFO", "is", "ti", "data", "inner", "rt", "ip", "txt", "user", "Info", "fo", "by", "check", "kind", "si", "t", "conv", "name", "ro", "conf"], "bsp": ["ic", "wic", "i", "space", "sb", "pb", "cf", "bridge", "bl", "br", "lbs", "bps", "bc", " bl", "sil", "bf", "SP", "lt", "sync", "fi", "lf", "p", "ffff", "cp", "sc", "shr", "bitcoin", "soc", "nob", "isp", "bol", "esp", "sw", " sp", "amp", "np", "bs", "osp", "eb", "is", "b", "xf", "ns", "dp", "ps", "ip", "rap", "wp", " esp", "bt", "gb", "sp", "bp", "Sp", "px", "biz", "fp", "gc", "ab", "lp", "tmp", "loop", "jp", "abl", "elt", "gap", "pic", "split"]}}
{"project": "qemu", "commit_id": "b854bc196f5c4b4e3299c0b0ee63cf828ece9e77", "target": 0, "func": "static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwt.base = base;\n\n    s->pwt.clk = clk;\n\n    omap_pwt_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,\n\n                    omap_pwt_writefn, s);\n\n    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);\n\n}\n", "idx": 26243, "substitutes": {"base": ["basic", "f", "range", "bare", "type", "i", "bas", "out", "server", "null", "ASE", "address", " Base", "ref", "store", "re", "bound", "mb", "se", "nb", "Base", "id", "index", "zero", "bf", "create", "buffer", "local", "cpu", "balance", "target", "db", "p", " bases", "state", "prefix", "root", "bind", "bal", "origin", "pos", "bu", "ada", "chain", "last", "b", "eta", "start", "scale", "ip", "y", "pa", "key", "ase", "limit", "e", "bp", "mask", "scope", "based", "offset", "source", "h", "m", "bid", "name"], "s": ["sys", "i", "sa", "sb", "out", "args", "eps", "ins", "service", "se", "comm", "status", "fs", "os", "v", "rs", "w", "c", "ses", "ds", "hs", "sl", "params", "details", "sync", "r", "spec", "p", "changes", "state", "cs", "sts", "set", "aws", "services", "vs", "S", "js", "bs", "ss", "settings", "a", "is", "b", "ats", "ns", "ts", "ps", "ims", "ies", "states", "qs", "stats", "es", "its", "gs", "sv", "self", "source", "h", "t", "ls", "m", "sq"], "clk": [" clm", "Clm", "clik", "slck", "slk", "plck", "plc", " cltk", "Clik", " clck", "lck", "plk", "Clk", "Clp", "blk", "blck", "clm", "ltk", "lltk", "Clck", "llp", "blm", " clp", "slp", "clp", "slc", "blik", "lk", "cltk", "llck", "clck", "llk", " clik", "plp", "lp", "clc", "Clc"], "iomemtype": ["iomeemtype", "iomymype", "xiemype", "iomymtype", "iomormtype", "xiempe", "iomemposition", "iemimertype", "iomympe", "xiEMpe", "iomimerType", "xiEMtype", "iomimType", "iomymplate", "iomimertype", "iemimerype", "xiEMType", "iomEMtype", "iomimerplate", "iememplate", "iomimtype", "iomormposition", "iomepe", "iometerpe", "xiimerpe", "iometype", "iomimerpe", "iomormType", "iomeplate", "iememtype", "iometerype", "iomempe", "iomemplate", "iemimerpe", "iemempe", "xiimerType", "xiemtype", "iomeempe", "iomEMype", "xiemposition", "iomemype", "xiimerposition", "iomeype", "iemimerplate", "iometerType", "iomormpe", "iomimerposition", "iomeemposition", "iomimype", "iomemType", "iometertype", "iomimerype", "iomeemType", "iomEMType", "iememype", "xiemType", "iomEMpe", "xiimertype", "xiEMype", "iomimpe"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n\n                                        int y, int w, int h)\n\n{\n\n    int i, j;\n\n    int has_fg, has_bg;\n\n    uint8_t *last_fg, *last_bg;\n\n    VncDisplay *vd = vs->vd;\n\n\n\n    last_fg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    last_bg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    has_fg = has_bg = 0;\n\n    for (j = y; j < (y + h); j += 16) {\n\n        for (i = x; i < (x + w); i += 16) {\n\n            vs->send_hextile_tile(vs, i, j,\n\n                                  MIN(16, x + w - i), MIN(16, y + h - j),\n\n                                  last_bg, last_fg, &has_bg, &has_fg);\n\n        }\n\n    }\n\n    free(last_fg);\n\n    free(last_bg);\n\n\n\n    return 1;\n\n}\n", "idx": 26245, "substitutes": {"vs": ["vm", "ms", "Vs", "ops", "fs", "rs", "vp", "ds", "hs", "vv", "ks", "pages", "s", "cs", "vr", "vg", "ils", "vers", "js", "bs", "ss", "is", "VS", "ts", "vc", "ps", "ns", " VS", "vals", "qs", "es", "its", "gs", "sv", "obs", "ys", "vi", "ls", "vt", "uv", "v", "views", "cv"], "x": ["fx", "tx", "on", "xy", "xml", "xt", "ex", "c", "pi", "yx", "at", "dx", "mm", "act", "rx", "height", "n", "p", "el", "wy", "ax", "lat", "X", "xx", "xxx", "xs", "xf", "l", "xc", "ct", "ox", "key", "z", "px", "current", "xe", "xp", "xi", "t", "m", "v", "wx", "ix"], "y": ["sys", "my", "ch", "gy", "xy", "hot", "ay", "yt", "c", "yi", "ry", "ty", "yy", "sky", "uy", "or", "iy", "row", "yer", "iny", "axy", "p", "wy", "ny", "ery", "ym", "ye", "cy", "yo", "vy", "hy", "b", "yr", "py", "yes", "ies", "z", "yd", "ey", "ya", "by", "ys", "yet", "oy", "t", "Y", "sy", "v", "asy"], "w": ["wid", "W", "fw", "iw", "wh", "d", "v", "ow", "ex", "ew", "wd", "ww", "wr", "wl", "g", "r", "n", "sw", " W", "nw", "wa", "wcs", "wb", "wp", "wi", "wn", "wt", "window", "rw", "win", "kw", "xp", "m", "wx", "pt", "hw"], "h": ["it", "hd", "ch", "him", "ih", "ph", "he", "ow", "hr", "c", "k", "rh", "hs", "height", "ah", "g", "hp", "p", "kh", "sh", "oh", "ht", "hei", "th", "html", "hi", "b", "ish", "z", "bh", "ha", "H", "hh", "hl", "q", "m", "v", "ho", "hw"], "i": ["f", "ji", "it", "ic", "iii", "ui", "ki", "multi", "\u0438", "o", "Si", "ik", "ie", "ami", "us", "pi", "ini", "ia", "yi", "ri", "PI", "in", "gi", "I", "p", "phi", "di", "oi", "ori", "zi", "ai", "mi", "ii", "li", "hi", "is", "b", "ti", "l", "ip", "ij", "bi", "ci", "iter", "uri", "u", "iu", " I", "xi", "si", "im", "m", "v", "init", "qi", "ei", "ix"], "j": ["ji", "note", "it", "je", "job", "o", "obj", "err", "ja", "jac", "jump", "br", "try", "v", "uj", "bo", "dj", "fr", "at", "pr", "g", "n", "p", "jo", "di", "kj", "jit", "J", "ii", "js", "ot", "bs", "ne", "li", "jc", "jas", "b", "l", "bi", "ij", "bj", "z", "oj", "json", "bot", "adj", "off", "ret", "si", "jp", "q", "t", "m", "jj", "jl", "im", "aj"], "has_fg": ["has___bg", "has_nz", " has_fig", "has_fig", "has___fg", "has____fg", "last_nz", "has_opt", "having_fg", "has___opt", "having_bg", "having____cfg", " has_opt", "having____fg", "has____bg", "has____usr", "has___fig", "has_cfg", "has_cmd", "hasAbg", "hasAfig", "having_usr", "having_cfg", "hasAopt", "has____cfg", "last_cmd", "has_usr", "having____usr", "having____bg", "hasAfg"], "has_bg": ["has___bg", "has______pic", "has______bp", " has_pic", " has_background", "having_exc", "having_bb", "has___bp", "has___pic", "having_BG", " has___background", " has___pic", "has___background", "has___fg", " has___bg", "has___fab", "having_bg", "had_fab", "had_fg", "has_exc", "has___cmd", " has_bp", "has_cmd", "has______background", "has_bp", "has_bb", "has_fab", "has______bg", "had_bg", "had_cmd", "has_BG", "has_background", "has_pic", " has___bp"], "last_fg": ["last_sty", "last_buf", "last_FG", "old___sty", "old___bg", "last___bg", "last___fab", "last64fg", "last64FG", " last_err", "old_sty", "last_fab", "old_css", "old_fg", "last_pu", "last64bg", " last_pu", " last_FG", "last___pu", "old_bg", "last64err", "last___css", "last_err", " last_buf", "last_css", "old___css", "last___sty", "last___fg", "old___fg", " last_fab", " last_font", "last_font"], "last_bg": ["last_rg", "last_db", " last_gy", " last_background", "last_sb", "last_gg", "highest_gd", "last___gy", " last_db", "highest_bg", " last_bp", "last___sb", " last_gg", "highest_sb", "last___bg", " last_rg", "last___BG", "last_BG", "last___bp", " last_BG", "last___gg", "highest_bp", "last_gd", "last___gd", "last_background", "last_bp", "last_gy"], "vd": ["vm", "sd", "pd", "hd", "ld", "sb", "server", "xd", "nd", "d", "dh", "vp", "erd", "dj", "dds", "ds", "vv", " dh", "wd", "VD", "md", "db", "uds", "ve", "dt", "dm", "vr", "vg", "df", "td", "gd", "nv", "dl", "vc", "dr", "dd", "vid", "bd", "vision", "udi", "fd", "gb", "sv", "ud", "vi", "vt", "uv", "v", "lv", "od"]}}
{"project": "qemu", "commit_id": "f8c35c1d59c9fecf79f6d5a02cd09f472a6f411d", "target": 0, "func": "static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,\n\n                        uint8_t *buf, int nb_sectors)\n\n{\n\n    int async_ret;\n\n    BlockDriverAIOCB *acb;\n\n    struct iovec iov;\n\n    QEMUIOVector qiov;\n\n\n\n    async_ret = NOT_DONE;\n\n    iov.iov_base = (void *)buf;\n\n    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,\n\n                                  bdrv_rw_em_cb, &async_ret);\n\n    if (acb == NULL) {\n\n        async_ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    while (async_ret == NOT_DONE) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\n\n\nfail:\n\n    return async_ret;\n\n}\n", "idx": 26251, "substitutes": {"bs": ["bb", "bid", "sb", "bas", "pb", "bl", "bps", "lbs", "fs", "bc", "rs", "bes", "BS", "bf", "ds", "hs", "bm", "bsp", "ks", "bos", "bis", "cs", "cks", "sts", "bits", "vs", "js", "ss", "bn", "b", "ts", "ns", "ps", "bi", "qs", "bh", "bt", "its", "gs", "bp", "obs", "ls", "blog"], "sector_num": ["sectorNameNum", " sector_temp", "sector_max", " sector_Num", "sector_number", "sectorNamenumber", "sector1num", " sector_max", " sector_man", "sectorIDnumber", "sectorIDnum", "sector1max", "sectorIDman", "sectorNamemax", "sectorNamenum", "sector1Num", " sector_number", "sector_man", "sector_temp", "sector1number", "sector_Num", "sectorIDtemp"], "buf": ["block", "fb", "batch", "pb", "obj", "ref", "queue", "uf", "br", "bc", "bf", "buffer", "mem", "seq", "cmd", "Buff", "img", "new", "msg", "bytes", "cb", "ctx", "vec", "raw", "b", "data", "wb", "txt", "rb", "cap", "Buffer", "buff", "accept", "tmp", "v", "cv"], "nb_sectors": ["nb_pectors", "nb_neivers", "nb_peivers", "nb_serors", "nb_severs", "nb_ectors", "nb_seivers", "nb_veves", "nb_serctors", "nb_nectors", "nb_veivers", "nb_pevers", "nb_neors", "nb_seriers", "nb_neves", "nb_tractors", "nb_travers", "nb_traves", "nb_veriers", "nb_serriers", "nb_vectors", "nb_seors", "nb_eivers", "nb_speriers", "nb_traivers", "nb_sercs", "nb_seitors", "nb_veors", "nb_vecs", "nb_evers", "nb_secs", "nb_peitors", "nb_spectors", "nb_eitors", "nb_traitors", "nb_seves", "nb_specs", "nb_traors", "nb_speors"], "async_ret": ["assync_out", "async___ret", "asyncixret", "async_del", "assync_nt", "assync_return", "async__RET", "assync_alt", "async_out", "async_return", "assync_res", "async__rt", "async___del", "assync_rt", "async_Ret", "asyncixres", "assync_reply", "async__nt", "asyncixreturn", "assync_RET", "async_RET", "async_reply", "async_flag", "assync_del", "async__res", "async___Ret", "async___res", "async_res", "assync_Ret", "async___reply", "async__ret", "assync_len", "async___out", "async_alt", "async_rt", "async_len", "assync_flag", "assync_ret", "async__Ret", "async___return", "asyncixreply", "async_nt"], "acb": ["pacrb", "facB", "acbh", "facob", "icb", "ecbb", "ACb", " acbb", "icbb", "pacb", "ACB", " acB", "icba", "facb", "acob", "ACsb", "ecba", "ascob", "ACrb", "acbb", "ACob", "facbh", "acsb", "ACbh", "pacsb", " acsb", "ecb", " acba", "ascbh", "acba", "ascB", "pacB", "icB", " acrb", "ecB", "acrb", "ascb", "acB"], "iov": [" mosqu", "iva", "ux", "iol", "chrom", "ih", "dq", "voice", "nom", " resp", " unim", "rio", "iv", " bio", "iw", "vp", "uj", " imb", " repertoire", "rov", "drm", "ech", " rav", "veh", " announcer", " mus", "tv", "river", "liv", " VII", "nov", " narr", " motiv", " pir", "iop", "iev", " multimedia", "vr", " supporters", "inv", "isco", " vec", "voc", "ibl", " civ", "vo", "nil", "Iv", " io", "iq", "ichael", "av", " mech", "ever", " volley", "ij", " vom", "igroup", "minecraft", " inver", "username", "imp", " mor", " impulse", "vector", " morale", "qv", "iu", "pkg", "conv", "iph", " vib", "iour", " vers"], "qiov": ["qviour", "aqveh", "qovi", "qiol", "qiv", "sqiov", "qviov", "queryiv", "quveh", "aqiol", "aqrolet", " qiour", "sqiol", "quiol", "queryiro", "qrolet", " qiv", "qvovi", "qvrolet", "sqveh", "qqiour", "aqiov", "qveh", "queryiov", "qiro", "qqiv", "sqrolet", "qqiov", "quiov", "qiour", "qqiro", "queryiour", " qiro", "qurolet"]}}
{"project": "qemu", "commit_id": "e57ca75ce3b2bd33102573a8c0555d62e1bcfceb", "target": 0, "func": "static int kvmppc_get_books_sregs(PowerPCCPU *cpu)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    struct kvm_sregs sregs;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_SREGS, &sregs);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (!env->external_htab) {\n\n        ppc_store_sdr1(env, sregs.u.s.sdr1);\n\n    }\n\n\n\n    /* Sync SLB */\n\n#ifdef TARGET_PPC64\n\n    /*\n\n     * The packed SLB array we get from KVM_GET_SREGS only contains\n\n     * information about valid entries. So we flush our internal copy\n\n     * to get rid of stale ones, then put all valid SLB entries back\n\n     * in.\n\n     */\n\n    memset(env->slb, 0, sizeof(env->slb));\n\n    for (i = 0; i < ARRAY_SIZE(env->slb); i++) {\n\n        target_ulong rb = sregs.u.s.ppc64.slb[i].slbe;\n\n        target_ulong rs = sregs.u.s.ppc64.slb[i].slbv;\n\n        /*\n\n         * Only restore valid entries\n\n         */\n\n        if (rb & SLB_ESID_V) {\n\n            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* Sync SRs */\n\n    for (i = 0; i < 16; i++) {\n\n        env->sr[i] = sregs.u.s.ppc32.sr[i];\n\n    }\n\n\n\n    /* Sync BATs */\n\n    for (i = 0; i < 8; i++) {\n\n        env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;\n\n        env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;\n\n        env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;\n\n        env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26257, "substitutes": {"cpu": ["vm", "bench", "chip", "cu", "home", "boot", "conn", "ork", "pc", "ruby", "us", "c", "rc", "core", "gpu", "nic", "mem", "upt", "clock", "ck", "CP", "cmd", "pool", "ack", "cp", "linux", "p", "cum", "apache", "nc", "rom", "util", "buf", "aco", "nu", "ctx", "np", "setup", "process", "rt", "comp", "anc", "processor", "mu", "CPU", "hap", "pu", "uu", "gnu", "u", "gc", "jp", "cc", "pt", "proc", "cli", "rpm", "aq", "hw"], "env": ["cur", "ent", "disk", "er", "common", "dev", "vv", "command", "kh", "extra", "et", "ctx", "vs", "pe", "environment", "runner", "equ", "editor", "head", "era", "param", "v", "ee", "vm", "here", "obj", "ce", "chart", "ev", "conn", "code", "config", "entry", "eh", "eni", "operator", "ec", "header", "cp", "el", "apache", "gear", "buf", "enc", "goal", "next", "eco", "desc", "window", "net", "en", "vt", "Environment", "hw", "device", "context", "engine", "ef", "esc", "den", "core", "console", "ah", "nc", "node", "door", "doc", "nv", "worker", "tmp", "outer", "manager", "cv", "ov", "server", "ner", "viron", "vert", "rc", "event", "ew", "ext", "cmd", "ve", "oe", "org", "cb", "image", "menu", "query", "txt", "eve", "export", "e", "end", "eng", "uv", "proc", "conf"], "sregs": ["sregges", "surgs", "powersregensions", "unsregs", "sroundges", "sroundies", "srealensions", "sargts", "swarnjs", "Sreges", "sregps", "sorgs", "sroundgs", " sgraphges", "itsrecges", "sregensions", "sorgls", " sgraphles", "gesreplacs", "sgrjs", "sarchgs", "sREGs", "powersconnitions", "sgraphs", "sargies", "sstatgs", "sargs", "powersregitions", "spatternges", "sREGps", "sreals", "unsregations", "spatterns", "srogis", "srepls", "srendses", " sregses", " srecings", "scmds", "awsregments", "swarns", "sreges", "sroundis", "smemges", "sregls", "powersconnses", "powersregs", "scmdils", " srecensions", "sregacs", "sgraphges", "awsservjs", " sREGs", "srels", "srejs", "gesregacs", "sservments", "awsservs", "sregings", "scmdacs", "smemps", "sreplims", "sgrses", "gesregs", "sgrs", "sstatations", "sroundations", "SREGps", "sconnitions", " srecs", "sarchjs", "unsroundis", "gesreplils", "slocs", "smems", "srendensions", "sreplacs", "sorgings", "slocils", "smemjs", "swarnls", " sreggs", "awsregs", " sregles", "itsrecs", "srogations", "sstats", "sres", "sREGn", " sregls", " sgraphs", "sredn", "surgls", "unsrounds", "smemments", " sregensions", "sregn", "awsservments", "srendles", "sreds", "sconnensions", "SREGes", "spatternments", "sregts", "sREGjs", "awsregjs", "unsroundations", "SREGn", "powersconnensions", "surgensions", "awsregges", " sregges", "smemn", "sredps", "gesreplims", " sREGjs", "srenditions", "srealitions", "sorgensions", " sgraphjs", "sgrgs", "awsservges", "sregations", "sgraphjs", "sregils", "gesregils", "sregles", "srounds", "sreggs", "sstatis", "sarchses", "sregitions", " sregings", "Sregs", "itsregts", "sservges", "srecs", "Sregps", "itsrecies", "sredes", "sconns", "Sregn", "sregses", "slocacs", "slocims", "powersconns", "srecges", "sregments", "sregjs", " sregjs", " srecls", "srecensions", "sgraphles", "sarchs", "unsregis", "sreplils", "itsregges", "sregims", "sservles", "unsreggs", "srects", "srogs", "powersregses", " sREGgs", "gesregims", "sREGgs", "srecies", "sservs", " sREGses", "sregies", "srendges", "srendjs", "sREGses", "srealses", "sregis", "gesrepls", "unsroundgs", "itsrects", "scmdims", "srecls", "sservjs", "SREGs", "srecings", "smemes", "sroggs", "surgings", "sREGes", "itsregies", "itsregs", "srends", "sroundts", "spatternjs", "sconnses", "sargges"], "ret": ["f", "inter", "alt", "ter", "out", "red", "err", "reset", "RET", "ref", "re", "hash", "len", "status", "code", "gt", "def", "result", "ry", "fi", "ext", "cmd", "det", "git", "deg", "resp", "rem", "j", "print", "rt", "nt", "rets", "txt", " RET", "ft", " Ret", "val", "flag", "mt", "Ret", "gc", "tr", "t", "elt", "v", "Return", "res"], "i": ["ui", " j", "status", "ini", "id", "er", "um", "in", "I", " bi", "sim", "ai", "li", "info", "ip", "ij", "y", "ci", "z", " si", "iu", " I", "si", "v", "ei", "series", "ji", "ki", "\u0438", "try", "us", " ii", "gu", "remote", "io", "esi", "j", "tim", "chain", "ind", "ims", "key", "uri", "m", "qi", "ix", "batch", "x", "multi", "ami", "ri", "phi", "oi", "di", "zi", "mi", "ii", "is", "b", "l", "bi", "dr", "xi", "im", "q", "all", "this", "f", "it", "ic", "eu", "err", "pi", "ex", "fi", "g", "me", "gi", "list", "to", "hi", "ti", "json", "sp", "u", "t", "jp", "index", "cli", "init", "name"]}}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void integratorcp_init(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    uint32_t ram_offset;\n\n    qemu_irq *pic;\n\n    qemu_irq *cpu_pic;\n\n    int sd;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    ram_offset = qemu_ram_alloc(ram_size);\n\n    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero*/\n\n    cpu_register_physical_memory(0, ram_size, ram_offset | IO_MEM_RAM);\n\n    /* And again at address 0x80000000 */\n\n    cpu_register_physical_memory(0x80000000, ram_size, ram_offset | IO_MEM_RAM);\n\n\n\n    integratorcm_init(ram_size >> 20);\n\n    cpu_pic = arm_pic_init_cpu(env);\n\n    pic = icp_pic_init(0x14000000, cpu_pic[ARM_PIC_CPU_IRQ],\n\n                       cpu_pic[ARM_PIC_CPU_FIQ]);\n\n    icp_pic_init(0xca000000, pic[26], NULL);\n\n    icp_pit_init(0x13000000, pic, 5);\n\n    pl031_init(0x15000000, pic[8]);\n\n    pl011_init(0x16000000, pic[1], serial_hds[0], PL011_ARM);\n\n    pl011_init(0x17000000, pic[2], serial_hds[1], PL011_ARM);\n\n    icp_control_init(0xcb000000);\n\n    pl050_init(0x18000000, pic[3], 0);\n\n    pl050_init(0x19000000, pic[4], 1);\n\n    sd = drive_get_index(IF_SD, 0, 0);\n\n    if (sd == -1) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital card\\n\");\n\n        exit(1);\n\n    }\n\n    pl181_init(0x1c000000, drives_table[sd].bdrv, pic[23], pic[24]);\n\n    if (nd_table[0].vlan) {\n\n        if (nd_table[0].model == NULL\n\n            || strcmp(nd_table[0].model, \"smc91c111\") == 0) {\n\n            smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n        } else if (strcmp(nd_table[0].model, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported NICs: smc91c111\\n\");\n\n            exit (1);\n\n        } else {\n\n            fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model);\n\n            exit (1);\n\n        }\n\n    }\n\n    pl110_init(ds, 0xc0000000, pic[22], 0);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(env, &integrator_binfo);\n\n}\n", "idx": 26259, "substitutes": {"ram_size": ["mem_name", "ram_type", " ram_limit", "mem_set", "ram_limit", "ram_fee", "ram67size", " ram_lock", "cpu_count", "ramptoffset", "mem_size", " ram_SIZE", "ram_name", "cpu_size", " ram_fee", "ram67fee", "ram_count", "ramptlimit", "ram_addr", "cpu_SIZE", "cpu_type", "ramptsize", "ram67lock", "ram_set", " ram_cache", "mem_addr", "ram_cache", "ram_SIZE", "ram_lock"], "vga_ram_size": ["vga_mem_name", "vga_mem_size", "vga_ram_space", "vga_ram2name", "vga_ram_name", "vga_ram2SIZE", "vga_mem_space", "vga_ram2space", "vga_ram_SIZE", "vga_mem_SIZE", "vga_ram2size"], "boot_device": ["bootdevnumber", "cpu_device", "bootablenumber", "boot_number", "bootdevmodel", "bootabledev", "boot_model", "bootdevdev", "boot_dev", "bootdevdevice", "bootabledevice", "cpu_number", "cpu_dev", "bootablemodel"], "ds": ["sys", "eps", "vd", "os", "dh", "d", "rs", "Ds", "dds", "DS", "dev", "ks", "db", "uds", "dt", "cs", "di", "bs", "xs", "ps", "dr", "dd", "des", "bd", "du", "ys", "eds", "ls"], "kernel_filename": [" kernel_device", "kernel_device", " kernel_module", "kernel_module", " kernel_file", "kernel_file"], "kernel_cmdline": ["kernel_commandline", "kernel_cmdl", "kernel_ctrl", "kernel_extline", "kernel_extpath", "kernel_commandpath", "kernel_commandl", "kernel_ctrpath", "kernel_extl", "kernel_cmdpath", "kernel_ctrline"], "initrd_filename": ["initrd_fil", "initrar_filename", "initrar_path", "initrd_exe", "initrar_fil", "initrar_exe", "initrd_path", "initrdfilefil", "initrdfilepath", "initrdfileexe", "initrdfilefilename"], "cpu_model": ["cpu_mode", "cpu_brand", "cpu_link", " cpu_library", "cpu_models", "cpu2mode", "gpu_mode", "pu_Model", "cpu2type", "pu_link", "gpu_type", "cpu_library", "CPU_model", "cpu_Model", "pu_model", "CPU_models", "pu_brand", "CPU_mode", "cpu_type", "gpu_model", " cpu_type", "CPU_Model", "cpu2model"], "env": ["priv", "here", "context", "cur", "ef", "esc", "eu", "sb", "tx", "obj", "ev", "conn", "ent", "er", "dev", "ew", "conf", "virt", "ec", "pen", "ah", "ped", "org", "set", "loader", "et", "ctx", "vs", "enc", "environment", "shell", "np", "js", "up", "eas", "nv", "attr", "ps", "worker", "window", "em", "con", "sp", "e", "en", "sv", "cap", "ptr", "tmp", "vt", "eng", "proc", "v", "end", "init", "cv", "hw"], "ram_offset": ["mem_address", "ram_offer", "rammlayout", "mem_offset", "ram0start", "rammOffset", " ram_start", "ramxoffset", "ram0offset", "mem_size", "rammoffer", "ram_address", "ramxstart", "ramxaddr", "ram_start", "rammoffset", "ram_layout", "ramxsize", "space_layout", "mem_start", "ram_addr", "space_Offset", "ram_Offset", "ram0size", "mem_addr", "space_offset", "space_offer"], "pic": ["pol", "ic", "ping", "mac", "Pic", "pet", "capt", "pan", "cam", "rip", "pc", "pi", "pp", "pot", "sam", "vine", "nic", "pac", "pr", "lic", "mic", "virt", "tick", "pen", "caps", "spec", "pin", "p", "record", "pick", "vol", "shot", "sac", "cs", "par", "wit", "sim", "ig", "magic", "picture", "pl", "pit", "ics", "pins", "js", "doc", "script", "iac", "ts", "ac", "spr", "ps", "eric", "png", "pa", "lib", "txt", "py", "mc", "snap", "pict", "sp", "style", "cap", "pres", "lp", "jp", "str", "fig"], "cpu_pic": ["cpu_script", "componentmycapt", "cpu__pic", "util_pc", "cpu_capt", "cpu___pict", "cpu_chat", "cp_ic", "cpu67pc", "cpuptjp", "util67mic", "cpu___pic", "cpumychat", "cpu67mic", "cpu_jp", "componentmypict", "componentmychat", "cpu_p", "component_chat", "cpu67pic", "util67pic", "cpuptmic", "componentmypic", "cp_pc", "util_pic", "cpu67jp", "cpu67chat", "cpu2pc", "cpu__nic", "component_pict", "cpuptpc", "cpu2pic", "cpu67capt", "cpu_nic", "component_capt", "util67jp", "cpu_ic", "util_mic", "cpuptpic", "cpu_pict", "pu_nic", "cpu___chat", "cp_pic", "pu_p", "util67pc", "cpumycapt", "pu_script", "cpu__script", "cpumypict", "cpu_pc", "component_pic", "cpu67pict", "util_jp", "cpu___capt", "cpu_mic", "cpu_pipe", "cpu__p", "cpu2ic", "cp_pipe", "cpu2pipe", "pu_pic", "cpumypic"], "sd": ["pd", "hd", "sn", "ld", "sb", "dis", "vd", "nd", "d", "std", "cd", "disk", "sam", "sky", "dev", "md", "db", " SD", "sc", "san", "sh", "od", "td", "sk", "gd", "ss", "SD", "da", "ind", "dl", "sid", " sh", "dd", "des", "bd", "south", "fd", "sp", "dk", "sv", "ud", "si", "sy", "ix"]}}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "void hmp_cont(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockInfoList *bdev_list, *bdev;\n\n    Error *err = NULL;\n\n\n\n    bdev_list = qmp_query_block(NULL);\n\n    for (bdev = bdev_list; bdev; bdev = bdev->next) {\n\n        if (key_is_missing(bdev->value)) {\n\n            monitor_read_block_device_key(mon, bdev->value->device,\n\n                                          hmp_cont_cb, NULL);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    qmp_cont(&err);\n\n    hmp_handle_error(mon, &err);\n\n\n\nout:\n\n    qapi_free_BlockInfoList(bdev_list);\n\n}\n", "idx": 26291, "substitutes": {"mon": ["demon", "von", "my", "den", "min", "Mon", "man", "conn", "MON", "comm", "unit", "rain", "map", "ann", "mut", "sam", "meter", "mun", "mx", "mm", "chron", "cat", "timer", "mir", "san", "dm", "mit", "monitor", "mat", "util", "mint", "coord", "mi", " monitor", "Monitor", "sm", "mn", "bin", "mt", "dom", "mons", "manager", "m", "onet", "mont", "mu", "admin"], "qdict": ["qdb", "qmap", "dqd", " qdb", " qd", "qqdict", " qmap", "dqdb", "dqdict", "qqdb", "qqd", "qqmap", "qd", "dqmap"], "bdev_list": ["bsw_map", "bDev_map", "bdevlistcollection", "bsw_dict", "bdevishst", "bswlistdict", "bdev__list", "bdev_lists", "bdevishmap", "bmem_map", "bdev_map", "bdev_List", "bdev_collection", "bdev_st", "bswlistmap", "bdev_no", "bswlistcollection", "bdev__map", "bmem_st", "bdevlistdict", "bmem_list", "bmem_listed", "bdev__no", "bdevlistmap", "bdevlistlist", "bdevishlist", "bdev_dict", "bDev_no", "bDev_lists", "bDev_List", "bdev_listed", "bDev_list", "bdevishlisted", "bsw_collection", "bsw_list", "bswlistlist"], "bdev": ["bcdoc", "bgdevice", "bdoc", "rdec", "dbver", "ldev", " bdoc", "bserv", "brdevice", "pdevice", "bbserv", " bdevice", "btver", "bdevice", "brdev", "bpriv", "rdevice", " bver", "bcev", "lver", "bbdev", "bdec", "bbdec", "ldevice", "brdef", "bcdev", "Bdev", "bdef", "bgdec", "bDev", "dbdev", "pev", "rbdev", "rdev", "Bpriv", "bbver", " bdef", "rbdevice", "btdev", "dbev", "BDev", "bgdev", "sbev", "lDev", "dbdevice", "Bdevice", "rserv", "brent", "bgserv", "bbdevice", "sbdoc", "pdev", "rbver", "brev", " bDev", "bbrent", "btrent", "sbdev", "bver", " brent", "bbdef", "bev", " bev", "sbDev", "pdef", "rbpriv", "btdef", "Bver", "bcDev", "bbev", " bpriv"], "err": ["sys", "ch", "obj", "ev", "fee", "rs", "erd", "fr", "Error", "er", "error", "rr", "dev", "conf", "ah", "r", "cmd", "timer", "arr", "gr", "fam", "kr", "msg", "resp", "cb", "usr", "buf", "order", "bar", "coord", "die", "cfg", "attr", "urg", "notice", "mr", "txt", "iter", "aaa", "e", "der", "errors", "exc", "Er", "proc", "str", "res"]}}
{"project": "FFmpeg", "commit_id": "49cf36f4e3e9183611859af1a07dc6a82ab47288", "target": 1, "func": "static int decode_5(SANMVideoContext *ctx)\n\n{\n\n#if HAVE_BIGENDIAN\n\n    uint16_t *frm;\n\n    int npixels;\n\n#endif\n\n    uint8_t *dst = (uint8_t*)ctx->frm0;\n\n\n\n    if (rle_decode(ctx, dst, ctx->buf_size))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n#if HAVE_BIGENDIAN\n\n    npixels = ctx->npixels;\n\n    frm = ctx->frm0;\n\n    while (npixels--)\n\n        *frm++ = av_bswap16(*frm);\n\n#endif\n\n\n\n    return 0;\n\n}\n", "idx": 26294, "substitutes": {"ctx": ["sys", " cx", "context", "cmp", "tx", "cf", "obj", "jac", "ca", "cu", "Context", "conn", "bc", "pc", "std", "config", "tc", "kt", "abc", "dc", "gz", "conf", "wd", "ck", "act", "cmd", "ctl", "cp", "p", "pause", "today", "sc", "nc", "prefix", "resp", "cb", "acl", "np", "js", "xs", "req", "ct", "xc", "wcs", "nt", "work", "unc", "anc", "desc", "cas", "history", "bh", "px", "fc", "aux", "kw", "kind", "xp", "etc", "gc", "pkg", "timeout", "kl", "jp", "cc", "tmp", "proc", "wx", "lc", "init", "cv", "hw"], "frm": ["frmm", " frp", " frk", "grp", "fram", " frmt", "drv", "frem", "frk", "flgm", "grmi", " frgm", "fremt", "fm", "flM", "frp", "fxp", "fxmt", "frmi", "Frn", "drM", "fn", "ferm", "frgm", "fermt", "frv", "flm", "fam", "Fram", "grmt", " frmi", "Frgm", "frmt", "Frv", "fxmi", "grm", "fgm", "frek", "ferk", "fremm", "flv", "frM", "FrM", "fxm", "frn", "Frm", "drgm", " frmm", "fermm", " frn", " fram", "drm"], "npixels": ["nix", "npinches", "npix", "pngixel", "npixel", "pnris", "nsixels", "npips", "wpinches", "nixel", "vpoms", "ncix", "ncairs", "nrinches", "wpris", "ncixels", "vpixel", "pnixels", "ncixel", "npris", " npips", "nrixels", " npinches", " npix", "pixel", "nsris", "wpixels", "nairs", "pixels", "nrips", "vpinches", " npixel", "pairs", "vpixels", "pnips", "wpips", "nrix", "nsips", "wpixel", " npoms", "nixels", "pnginches", "npairs", "wpix", "npoms", "pix", "nsixel", "pnixel", "pngoms", "pngixels"], "dst": ["dast", "dnd", "sdbr", "Dbr", "ddest", "Dist", "Dst", " dist", "Dsts", "sdst", "sdist", "dest", "dist", " dsts", "Ddest", "Dest", "dand", "sdsts", " dest", " dbr", "daest", " dnd", " ddest", "Dnd", "dsts", "dadest", "dbr"]}}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "static void aux_bridge_init(Object *obj)\n\n{\n\n    AUXTOI2CState *s = AUXTOI2C(obj);\n\n\n\n    s->i2c_bus = i2c_init_bus(DEVICE(obj), \"aux-i2c\");\n\n}\n", "idx": 26306, "substitutes": {"obj": ["it", "cmp", "o", "comm", "att", "tk", "obo", "ex", "id", "sky", "cont", "object", "og", "ck", "act", "cmd", "org", "gr", "ob", "resp", "rect", "gov", "vr", "j", "Obj", "ht", "ctx", "js", "gm", "attr", "nt", "oc", "expr", "bj", "ij", "txt", "bh", "obs", "tmp", "t", "jp", "v", "onet", "pt", "hw"], "s": ["sys", "ms", "sb", "o", "sis", "se", "fs", "rs", "ses", "ds", "hs", "sl", "sts", "set", "j", "iss", "S", "js", "bs", "ss", "so", "is", "ats", "b", "ns", "ts", "ps", "sm", "stats", "st", "es", "gs", "sv", "ls", "sq", "su"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void bdrv_co_drain_bh_cb(void *opaque)\n\n{\n\n    BdrvCoDrainData *data = opaque;\n\n    Coroutine *co = data->co;\n\n\n\n    qemu_bh_delete(data->bh);\n\n    bdrv_drain_poll(data->bs);\n\n    data->done = true;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 26315, "substitutes": {"opaque": ["OPaque", " opute", "OPempty", "opempty", " opacity", "OPaques", "opute", "obempty", " opempty", "ropaque", "opacity", "popaque", "obacity", " opaques", "obaque", "ropute", "popacity", "opatile", "OPacity", "obaques", "ropatile", " opatile", "popatile", "opaques", "ropacity", "popute"], "data": ["device", "join", "type", "batch", "action", "ad", "where", "client", "obj", "al", "store", "ata", "roy", "d", "config", "def", "value", "that", "result", "zero", "error", "dev", "ATA", "params", "report", "details", "results", "empty", "command", "spec", "list", "delete", "p", "cache", "rec", "mode", "state", "rel", "extra", "area", "view", "form", "ta", "image", "Data", "ne", "da", "share", "size", "info", "dat", "still", "query", "window", "missing", "by", "val", "reader", "DATA", " DATA", "table", "writer", "self", "content", "no", "index", "str", "aw", "name", "this", "ion"], "co": ["lo", "CO", "o", "cu", "flo", "ror", "po", "ko", "cro", "cor", "bo", "c", "cover", "local", "wo", "cho", "coe", "soc", "nc", "ob", "mo", "que", "ra", "go", "can", "aco", "coord", "Co", "ctx", "cod", "mi", "vo", "com", "cons", "oc", "loc", "ci", "ico", "con", "coll", "fo", "cv", "ro"]}}
{"project": "qemu", "commit_id": "b224e5e2162a767dd56dbc366f796fbe45ca5baa", "target": 1, "func": "static int add_graphics_client(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    const char *protocol  = qdict_get_str(qdict, \"protocol\");\n\n    const char *fdname = qdict_get_str(qdict, \"fdname\");\n\n    CharDriverState *s;\n\n\n\n    if (strcmp(protocol, \"spice\") == 0) {\n\n        int fd = monitor_get_fd(mon, fdname, NULL);\n\n        int skipauth = qdict_get_try_bool(qdict, \"skipauth\", 0);\n\n        int tls = qdict_get_try_bool(qdict, \"tls\", 0);\n\n        if (!using_spice) {\n\n            /* correct one? spice isn't a device ,,, */\n\n            qerror_report(QERR_DEVICE_NOT_ACTIVE, \"spice\");\n\n            return -1;\n\n        }\n\n        if (qemu_spice_display_add_client(fd, skipauth, tls) < 0) {\n\n            close(fd);\n\n        }\n\n        return 0;\n\n#ifdef CONFIG_VNC\n\n    } else if (strcmp(protocol, \"vnc\") == 0) {\n\n\tint fd = monitor_get_fd(mon, fdname, NULL);\n\n        int skipauth = qdict_get_try_bool(qdict, \"skipauth\", 0);\n\n\tvnc_display_add_client(NULL, fd, skipauth);\n\n\treturn 0;\n\n#endif\n\n    } else if ((s = qemu_chr_find(protocol)) != NULL) {\n\n\tint fd = monitor_get_fd(mon, fdname, NULL);\n\n\tif (qemu_chr_add_client(s, fd) < 0) {\n\n\t    qerror_report(QERR_ADD_CLIENT_FAILED);\n\n\t    return -1;\n\n\t}\n\n\treturn 0;\n\n    }\n\n\n\n    qerror_report(QERR_INVALID_PARAMETER, \"protocol\");\n\n    return -1;\n\n}\n", "idx": 26320, "substitutes": {"mon": ["demon", "von", "den", "por", "min", "Mon", "man", "pai", "conn", "MON", "ann", "mut", "mond", "meter", "mem", "mun", "mm", "mong", "mind", "tem", "wat", "mir", "vis", "dm", "san", "monitor", "mot", "mat", "mint", "mi", "jon", "zon", " monitor", "don", "isen", "mn", "amon", "met", "num", "mt", "dom", "mons", "manager", "m", "onet", "mont", "mu", "admin"], "qdict": ["dqdef", " qbind", "qtdef", "qdb", "qualdict", "questdir", "requmap", " qdel", "questcond", "requdict", "dqbody", " qd", "requtable", "qcompl", "qlist", " qlist", "dqdict", "requparams", "dqbind", "querytable", "questdict", "requdot", "dqdel", "questdel", "requdb", "qdef", "qualmap", "qqmd", " qparams", "qqmap", "qqcompl", " qbody", "qdot", "qd", "questmd", "qbody", "qparams", "requcompl", " qdir", "qqdir", "requdir", "dqlist", "questlist", "qcond", " qcompl", "qualdot", "qqdict", "questbody", "qdir", "querydir", "qbind", "qqdot", " qdef", " qcond", "qtdict", "querydict", "questcompl", "qtbind", "qualdb", "qmap", "qdel", " qmd", "questparams", "qtd", "qtable", "requcond", "qqdb", "qmd", "questtable", "dqd", "querycompl"], "ret_data": ["aux_Data", "ret_image", "aux_data", "retJData", "retrowimage", "retJimage", "retrowdata", "ret_DATA", "ret_Data", "retrowData", "retJdata", "aux_image", "retJDATA", "retrowDATA", "aux_DATA"], "protocol": ["interotype", "proid", "scheotype", "pronoid", "prototype", "protype", "protolean", "interolean", "scheocol", "protol", "interocol", "scheoid", "prootype", "procol", "pronotype", "proocol", "patocol", "propol", "propotype", "scheication", " protistor", "pronocol", "propolean", "protistor", "proication", "interol", "patol", "prication", "pronication", "patistor", " prototype", "patolean", "patication", "protication", "proistor", "patotype", "protoid", " protication", "propocol"], "fdname": ["flnames", "dfnames", " fidon", "fbno", "fdid", " fidid", "fbname", " fidname", "fdnames", "fednam", "FDnam", "fdnam", "flon", "FDame", "FDid", "fedname", "FDname", "fdon", "fcno", "fcnam", " fidstable", " fidame", "fnno", "dfon", "fdstable", "fbnam", "fcnew", "fnstable", "dfname", "flname", "fcname", "fdame", " fidmax", "fnni", "fedame", "fedid", "fdmax", "fcni", "fcstable", " fidni", "flmax", "fnname", " fidnam", "fdno", "dfmax", " fidnames", " fidnew", "fbnew", " fidno", "fdni", "fdnew"], "s": ["f", "sd", "sys", "i", "sb", "fs", "d", "rs", "w", "c", "sam", "ds", "g", "r", "spec", "n", "p", "sts", "j", "S", "session", "bs", "js", "ss", "a", "ps", "stats", "es", "e", "sv", "sg", "h", "t", "ls", "m", "v", "sq", "socket", "ssl"]}}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,\n\n                                             GIOCondition condition,\n\n                                             gpointer user_data)\n\n{\n\n    QIOTask *task = user_data;\n\n    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(\n\n        qio_task_get_source(task));\n\n\n\n    qio_channel_tls_handshake_task(\n\n       tioc, task);\n\n\n\n    object_unref(OBJECT(tioc));\n\n\n\n    return FALSE;\n\n}\n", "idx": 26330, "substitutes": {"ioc": ["tioco", "eiocon", "iuoco", "ioci", "iuocon", "eioc", "eioci", "tioci", "iuoci", "eioco", "ioco", "iocon", "tiocon", "iuoc"], "condition": [" chain", "Condition", " input", " argument", " computation", " contract", " requisite", " command", "event", "command", "cond", "choice", "ition", " error", "connection", " status", "process", " connection", " conditional", " thread", "reason", " reason", "when", "check", "ITION", " constraint", " dependency", " completion"], "user_data": ["user_dat", "User_content", "User_dat", "user____data", "user_DATA", "user____content", "user____dat", " user_DATA", "user_content", "user____DATA", "User_DATA", "user_input", "User_data", " user_input"], "task": ["job", "parent", "out", "tx", "asks", "term", "piece", "config", "event", "master", "unk", "request", "command", "target", "resource", "thread", "msg", "node", "slave", "tty", "input", "session", "form", "total", "connection", "project", "process", "chain", "release", "req", "data", "test", "nt", "work", "key", "worker", "Task", "activity", "link", "problem", "missing", "course", "source", "table", "t", "ask", "index", "name", "role"], "tioc": ["tioco", "utioco", "itaOC", "itiol", " tiocy", "atioci", "nioc", " tioci", "iioci", "atiocl", "itaocl", "tiOC", "piocon", "nioco", "atiol", "atiOC", "atiocon", "iiocl", "utiocy", "utioci", "tioci", "tiocl", "itiocy", "atiocy", "piol", "itiocon", "tiocy", "itioc", "itaoc", "iioc", "itaoci", "utioc", "niocy", "iiOC", "piocy", "atioc", "tiol", "nioci", " tioco", "pioc", "tiocon"]}}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "static void pm_update_sci(VT686PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0);\n\n    qemu_set_irq(s->dev.irq[0], sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n", "idx": 26333, "substitutes": {"s": ["sys", "ms", "sb", "ops", "ins", "sis", "gets", "os", "comm", "fs", "rs", "bes", "ses", "aunts", "ds", "hs", "details", "bis", "changes", "cs", "sts", "ares", "ains", "aws", "ches", "vs", "S", "als", "js", "bs", "ss", "is", "ats", "ns", "ts", "ps", "ims", "ies", "states", "tes", "stats", "uns", "des", "es", "its", "gs", "sv", "ys", "self", "h", "ls", "events"], "sci_level": ["sci_count", " sci_count", "scale_level", "sci_left", " sci_state", "sciacylow", "scaleacylow", "scale_left", "sciacyleft", " sci_type", "sci___level", " sci_levels", "sciacygoal", "sci_value", "scaleacyleft", "sci_goal", "sci___levels", "sci_levels", "sci_low", "sci___type", "scaleacygoal", "scale_goal", "sci_type", "sciacylevel", "sci_state", "scale_low", "scaleacylevel", "sci___count", " sci_value"], "pmsts": ["amplays", "amces", "pmrs", " pmrs", " pmgs", "pmns", " pmeps", "mpctr", " pmcasts", " pmst", " pmctr", "pmcasts", " pmplays", "pminces", "pkgsts", "amsts", "rpmns", "rpmces", "mpst", "gmgs", "amcasts", "gmst", "gmeps", "mprs", "pkgcasts", "rpmsts", " pminces", "pmplays", "pmgs", "pkgst", "pxinces", "mpgs", "pmst", "mpeps", "pmces", "pkgplays", "pxctr", "pxsts", "mpsts", "gmsts", "pmctr", " pmns", " pmces", "pmeps", "pxrs", "amns", "amst", "mpinces"]}}
{"project": "FFmpeg", "commit_id": "01e4537f66c6d054f8c7bdbdd5b3cfb4220d12fe", "target": 0, "func": "static void flat_print_key_prefix(WriterContext *wctx)\n\n{\n\n    FlatContext *flat = wctx->priv;\n\n    const struct section *parent_section = wctx->section[wctx->level-1];\n\n\n\n    printf(\"%s\", flat->section_header[wctx->level].str);\n\n\n\n    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {\n\n        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?\n\n            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];\n\n        printf(\"%d%s\", n, flat->sep_str);\n\n    }\n\n}\n", "idx": 26360, "substitutes": {"wctx": ["wspkg", "wdreq", " wcmp", "wdgl", "wdctx", "wsys", "wacmd", "wdalloc", "walloc", "Wctx", " wcontext", " walloc", "writergc", "rwcm", "writerpy", "rwgc", "wtcmp", " wdc", "Wgl", "wdpy", " wcm", "wsctx", "wdcontext", "wgc", "wrctx", "wcmd", "wctl", "wdcmp", "wcm", "rwtx", "wscontext", "wdpkg", "wrdc", " wpy", " wctl", "Wtx", "wtctx", "wrpkg", "wscmp", "wdtx", "wxctl", "rwpy", "wxcmp", "Wcontext", "wsctl", "wdgc", "rwcmd", "Wpy", "wstx", "wpy", "rwcmp", " wsys", "rwctx", "rwreq", "wacm", "wactx", "Wpkg", "wssys", "writerreq", "wtx", "wtcontext", "wpkg", "wxtx", "wxctx", " wcmd", "wsdc", "writerctx", " wpkg", "rwalloc", "wreq", "wrcmp", "wdc", " wgl", "rwcontext", " wtx", "wtsys", "wcmp", "wcontext", "wgl", "wacontext"], "flat": ["parent", "dim", "batch", "full", "cf", "tx", "uf", "clean", "raft", "plain", "att", "normal", "nan", "sat", "tf", "wide", "cont", "at", "fl", "local", "late", "cat", "pool", "san", "mat", "util", "lat", "ctx", "oat", "layout", "plan", "nil", "fare", "old", "tiny", "feat", "wt", "stable", "utf", "mt", "hat", "fat", "single", "format", "atten", "conv", "final"], "parent_section": [" parent_sect", " parent_sector", "parent___sections", " parent_Section", "parent_Section", "parent___sect", "parent___Section", " parent_sections", "parent_sect", "parent_option", "parent___sector", "parent_entry", " parent_entry", "parent_sector", " parent_option", "parent_sections", "parent___section", "parent___option"]}}
{"project": "FFmpeg", "commit_id": "b97d21e4d6813498f458777ff42c7eab1eed3adf", "target": 1, "func": "static int sdp_parse_fmtp_config_h264(AVStream *stream,\n\n                                      PayloadContext *h264_data,\n\n                                      char *attr, char *value)\n\n{\n\n    AVCodecContext *codec = stream->codec;\n\n    assert(codec->codec_id == CODEC_ID_H264);\n\n    assert(h264_data != NULL);\n\n\n\n    if (!strcmp(attr, \"packetization-mode\")) {\n\n        av_log(codec, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n\n        h264_data->packetization_mode = atoi(value);\n\n        /*\n\n         * Packetization Mode:\n\n         * 0 or not present: Single NAL mode (Only nals from 1-23 are allowed)\n\n         * 1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed.\n\n         * 2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A),\n\n         *                      and 29 (FU-B) are allowed.\n\n         */\n\n        if (h264_data->packetization_mode > 1)\n\n            av_log(codec, AV_LOG_ERROR,\n\n                   \"Interleaved RTP mode is not supported yet.\");\n\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n\n        if (strlen(value) == 6) {\n\n            char buffer[3];\n\n            // 6 characters=3 bytes, in hex.\n\n            uint8_t profile_idc;\n\n            uint8_t profile_iop;\n\n            uint8_t level_idc;\n\n\n\n            buffer[0]   = value[0];\n\n            buffer[1]   = value[1];\n\n            buffer[2]   = '\\0';\n\n            profile_idc = strtol(buffer, NULL, 16);\n\n            buffer[0]   = value[2];\n\n            buffer[1]   = value[3];\n\n            profile_iop = strtol(buffer, NULL, 16);\n\n            buffer[0]   = value[4];\n\n            buffer[1]   = value[5];\n\n            level_idc   = strtol(buffer, NULL, 16);\n\n\n\n            av_log(codec, AV_LOG_DEBUG,\n\n                   \"RTP Profile IDC: %x Profile IOP: %x Level: %x\\n\",\n\n                   profile_idc, profile_iop, level_idc);\n\n            h264_data->profile_idc = profile_idc;\n\n            h264_data->profile_iop = profile_iop;\n\n            h264_data->level_idc   = level_idc;\n\n        }\n\n    } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n\n        codec->extradata_size = 0;\n\n        codec->extradata      = NULL;\n\n\n\n        while (*value) {\n\n            char base64packet[1024];\n\n            uint8_t decoded_packet[1024];\n\n            int packet_size;\n\n            char *dst = base64packet;\n\n\n\n            while (*value && *value != ','\n\n                   && (dst - base64packet) < sizeof(base64packet) - 1) {\n\n                *dst++ = *value++;\n\n            }\n\n            *dst++ = '\\0';\n\n\n\n            if (*value == ',')\n\n                value++;\n\n\n\n            packet_size = av_base64_decode(decoded_packet, base64packet,\n\n                                           sizeof(decoded_packet));\n\n            if (packet_size > 0) {\n\n                uint8_t *dest = av_malloc(packet_size + sizeof(start_sequence) +\n\n                                          codec->extradata_size +\n\n                                          FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if (!dest) {\n\n                    av_log(codec, AV_LOG_ERROR,\n\n                           \"Unable to allocate memory for extradata!\");\n\n                    return AVERROR(ENOMEM);\n\n                }\n\n                if (codec->extradata_size) {\n\n                    memcpy(dest, codec->extradata, codec->extradata_size);\n\n                    av_free(codec->extradata);\n\n                }\n\n\n\n                memcpy(dest + codec->extradata_size, start_sequence,\n\n                       sizeof(start_sequence));\n\n                memcpy(dest + codec->extradata_size + sizeof(start_sequence),\n\n                       decoded_packet, packet_size);\n\n                memset(dest + codec->extradata_size + sizeof(start_sequence) +\n\n                       packet_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n                codec->extradata       = dest;\n\n                codec->extradata_size += sizeof(start_sequence) + packet_size;\n\n            }\n\n        }\n\n        av_log(codec, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)!\",\n\n               codec->extradata, codec->extradata_size);\n\n    }\n\n    return 0;\n\n}\n", "idx": 26367, "substitutes": {"stream": ["stack", "context", "store", "each", "read", "video", "secure", "ec", "sync", "console", "steam", "spec", "ack", "filter", "feed", "sw", "open", "transform", "REAM", "input", "enc", "form", "message", "session", "connection", "shape", "chain", "Stream", "data", "ocr", "port", "window", "seek", "pod", "http", "channel", "ream", "reader", "accept", "source", "socket"], "h264_data": ["h264ptsession", "h323ptwindow", "h264_cache", "h264ptdetails", "h64_cache", "h204_cache", "hutil67data", "happy_data", "h2645window", "h264ptwindow", "h26467connection", "h264ptconnection", "h264ptDATA", "hutil_DATA", "hutil_connection", "h323ptsession", "h264ptnot", "h264_not", "happy_details", "happyptdetails", "h544_settings", "hutil67not", "h264_window", "h26400data", "h544_Data", "h264__DATA", "h2645data", "happyptdata", "h264ptdefault", "h264ptoptions", "h323ptdefault", "h264_Data", "hutil_not", "h323_session", "h264acsettings", "h544_params", "h26467not", "hutil67connection", "h26467DATA", "h26400options", "h544_data", "h264__Data", "h264_options", "h264_session", "h2645session", "h264_default", "h264acdata", "h26467data", "h264_ata", "h264_status", "happyptData", "h264ptdata", "h64_config", "h264__data", "h26400details", "h264_DATA", "h323_default", "happy_options", "h264__params", "happyptoptions", "h323_window", "h264acData", "hutil67DATA", "h264_details", "happy_Data", "hutil_data", "h544_DATA", "h64_data", "h204_data", "h264acstatus", "h544_status", "h264_settings", "h323_data", "h264_params", "h264_connection", "h204_config", "h264ptData", "h64_ata", "h26400Data", "h323ptdata", "h2645default", "h264_config"], "attr": ["priv", "prop", "attribute", "cmp", "perm", "rib", "typ", "err", "adr", "rm", "op", "att", "tk", "adv", "tt", "reg", "rr", "pr", "dev", "var", "apt", "wr", "cmd", "p", "msg", "vr", "imm", "ctx", "tag", "acc", "rt", "eas", "req", "data", "wcs", "urg", "spr", "key", "addr", "tp", "adj", "pkg", "atts", "ptr", "stat", "elt", "tr", "str"], "value": ["range", "field", "see", "queue", "feature", "unit", "vp", "array", "valid", "output", "word", "command", "new", "pair", "raw", "size", "document", "vector", "variable", "v", "padding", "parent", "pack", "media", "byte", "code", "try", "entry", "operator", "Value", "function", "total", "tag", "example", "data", "key", "button", "current", "label", "description", "format", "tree", "type", "length", "batch", "expression", "widget", "now", "get", "comment", "node", "always", "input", "rule", "process", "b", "test", "text", "version", "package", "ue", "all", "property", "hello", "this", "block", "option", "attribute", "pre", "values", "server", "null", "bo", "result", "password", "what", "list", "cache", "VALUE", "initial", "set", "message", "up", "image", "python", "element", "json", "position", "val", "unknown", "content", "name"], "codec": ["codeeco", "CodEC", "codeco", "odisc", "codeEC", "Coderer", "modEC", "codEC", "odec", "libec", "cdac", "catect", "cdoc", "cateco", "cdstream", "mododer", "Codoc", "catec", "Codac", "chec", "codoc", " codocol", "modec", "modeco", "chener", "chocol", "codeeca", " codoc", "chEC", " codiac", "coderer", "odstream", " codef", "codender", "odc", "Codiac", "choc", "codeect", "cododer", "odEC", "modener", "cec", "odac", "Codisc", "codect", "chef", "codac", "cmdEC", "Codef", "Codoe", "cener", "codef", "codeender", "Codocol", "liberer", "codoe", "Codeca", "codocol", "codc", "codstream", "codeerer", " codisc", "codisc", "codeec", "codeoe", "liboe", "odoc", "codener", "Codec", "Cododer", " codEC", "codeiac", "cmdc", "cdec", " codener", " codender", "Codstream", "coder", "codiac", "modect", "chisc", "cEC", "cmdec", "Codc", "Codender", "Codener", "libeca", "catEC", "codeca", "cmdisc"], "buffer": ["block", "stack", "batch", "length", "match", "server", "append", "store", "bridge", "queue", "temp", "entry", "bo", "commit", "result", "profile", "screen", "command", "sync", "row", "empty", "password", "comment", "db", "absolute", "header", "phrase", "cache", "memory", "filter", "buf", "function", "bar", "paste", "message", "stage", "sequence", "face", "print", "b", "save", "document", "page", "template", "window", "seek", "base", "history", "limit", "button", "iter", "vector", "package", "Buffer", "buff", "trace", "table", "variable", "callback", "database", "texture"], "profile_idc": ["profile_IDc", "profile_adm", "profile_iddc", "profile_nameci", "profile_trycd", "profile__idsx", "profile_aida", "profile_idn", "profile__idsco", "profile_Ida", "profile_idedc", "profileListadc", "profile_nameh", "profileListidn", "profile_idel", "profile_idscd", "profile_idemx", "profile_adn", "profile_ida", "profile__idco", "profile_idl", "profile_idm", "profile_adc", "profile_idsx", "profile_namel", "profile_sourcec", "profile_idC", "profile_idcd", "profile_aidx", "profile_inc", "profile_idemcd", "profile_sourceC", "profileListadac", "profile_mainac", "profile__idsci", "profile_idsC", "profile_mainc", "profile__idh", "profile_idec", "profileListadn", "profile_mainm", "profile_IDa", "profile_IDx", "profile_aidc", "profile_idci", "profile__idci", "profile_idsco", "profile_Idci", "profile_Idc", "profile_idh", "profile_idemco", "profile_tryx", "profile_inh", "profile__idcd", "profile_namec", "profile_aidci", "profile__idsl", "profile_idsl", "profile_Idx", "profile_inci", "profile_adac", "profileListidm", "profile_idsc", "profileListidc", "profile__idsc", "profile__idl", "profile_sourcedc", "profile_mainn", "profile_idsdc", "profile_sourcel", "profile_ideC", "profile_idx", "profile__idc", "profile_IDci", "profile_idco", "profileListadm", "profile_idac", "profile__idsh", "profile_tryco", "profile__idx", "profile_ideac", "profileListidac", "profile_iden", "profile_idem", "profile_idsh", "profile_inl", "profile_idsci", "profile_tryc", "profile_idemc", "profile__idscd"], "profile_iop": ["result_iot", "profile2orp", "profile_op", "history_iov", "history_orp", "result_op", "prof_ios", "result_iop", "profile2iot", "prof_ep", "result_orp", "profile_ios", "volume_ios", "profileAccessiop", "profiletwikipedia", "profile_iot", "profileAccessiov", "prof_iov", "profileAccessorp", "profile_ep", "person_ip", "volume_iop", "profile2iov", "profile_istor", "profile_ival", "prof_iop", "profile_wikipedia", "profile_orp", "volume_wikipedia", "profile_iov", "person_iop", "person_osp", "profiletiop", "profiletios", "history_iot", "profile_osp", "volume_istor", "person_ival", "profile2iop", "history_iop", "profile_ip", "profiletistor", "profileAccessiot"], "level_idc": ["level_idsci", "level_showe", "level_ida", "level__idetc", "level_ide", "level__idp", "level_idci", "level_idsc", "level_oidlc", "level_showc", "level_identp", "level_ipc", "level_IdC", "level_ipcu", "level_hidel", "level_identc", "level_pyci", "level_oidc", "level_numci", "level_iqx", "level_oidci", "level_idetc", "level_oidC", "level_Ide", "level_idlc", "level_ideC", "level__idC", "level_pyc", "level_numlc", "level_iql", "level_Idtc", "level_pydc", "level_sidlc", "level__ideC", "level_identtc", "level_numc", "level_idp", "level_idsx", "level_showC", "level__idec", "level_iqa", "level_hidedc", "level_hideci", "level_idC", "level_idtc", "level_idl", "level_iddc", "level_idcu", "level__idtc", "level_sidC", "level_showcu", "level_sidc", "level_hidec", "level_Idc", "level_ipe", "level_sidci", "level_idec", "level_pyl", "level_Idcu", "level_numC", "level_idsdc", "level__idep", "level_idep", "level_ipC", "level_idsl", "level_Idp", "level__idc", "level_iqc", "level_identC", "level_idsa", "level_idx"], "base64packet": ["base32picket", "base32octets", "base64Packeter", "base64packET", "base64bucketer", "base64pickets", "base64bucket", "base64octetter", "base32packetter", "base64packetter", "base32octetter", "base64Packet", "base64packets", "base64compets", "base64octET", "base64mixet", "base64packacket", "base32picketer", "base64Packacket", "base64pickacket", "base32packeter", "base64octet", "base32packET", "base64packeter", "base32packets", "base64picket", "base64buckacket", "base32pickacket", "base64buckets", "base64octets", "base64mixetter", "base64picketer", "base32packacket", "base32octET", "base64compET", "base64Packets", "base64competter", "base32packet", "base64mixET", "base64compet", "base64mixets", "base32octet", "base32pickets"], "decoded_packet": ["decoded_packer", "decoded_packacket", "decoded_octets", "decoded_packets", "decoded_octacket", "decoded_packset", "decoded_packser", "decoded_packsacket", "decoded_packsets", "decoded_payacket", "decoded_payets", "decoded_payer", "decoded_payet", "decoded_octer", "decoded_octet"], "packet_size": ["packets_size", "packets_length", "packets_count", "packet_count", "packet_length", "packet_SIZE", "packets_SIZE"], "dst": ["cmp", "descr", "of", "rbl", "def", "_", "cont", "cmd", "fstr", "dcr", "fbl", "rstr", "desstr", "rcr", "dstr", "raw", "fcr", "rst", "desbl", "fst", "dbl", "desst"]}}
{"project": "qemu", "commit_id": "ba2ab2f2ca4150a7e314fbb19fa158bd8ddc36eb", "target": 1, "func": "static int qcow2_create2(const char *filename, int64_t total_size,\n                         const char *backing_file, const char *backing_format,\n                         int flags, size_t cluster_size, int prealloc,\n                         QEMUOptionParameter *options, int version,\n                         Error **errp)\n{\n    /* Calculate cluster_bits */\n    int cluster_bits;\n    cluster_bits = ffs(cluster_size) - 1;\n    if (cluster_bits < MIN_CLUSTER_BITS || cluster_bits > MAX_CLUSTER_BITS ||\n        (1 << cluster_bits) != cluster_size)\n    {\n        error_setg(errp, \"Cluster size must be a power of two between %d and \"\n                   \"%dk\", 1 << MIN_CLUSTER_BITS, 1 << (MAX_CLUSTER_BITS - 10));\n        return -EINVAL;\n    /*\n     * Open the image file and write a minimal qcow2 header.\n     *\n     * We keep things simple and start with a zero-sized image. We also\n     * do without refcount blocks or a L1 table for now. We'll fix the\n     * inconsistency later.\n     *\n     * We do need a refcount table because growing the refcount table means\n     * allocating two new refcount blocks - the seconds of which would be at\n     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file\n     * size for any qcow2 image.\n     */\n    BlockDriverState* bs;\n    QCowHeader header;\n    uint8_t* refcount_table;\n    Error *local_err = NULL;\n    int ret;\n    ret = bdrv_create_file(filename, options, &local_err);\n    if (ret < 0) {\n        return ret;\n    ret = bdrv_file_open(&bs, filename, NULL, BDRV_O_RDWR, &local_err);\n    if (ret < 0) {\n        return ret;\n    /* Write the header */\n    memset(&header, 0, sizeof(header));\n    header.magic = cpu_to_be32(QCOW_MAGIC);\n    header.version = cpu_to_be32(version);\n    header.cluster_bits = cpu_to_be32(cluster_bits);\n    header.size = cpu_to_be64(0);\n    header.l1_table_offset = cpu_to_be64(0);\n    header.l1_size = cpu_to_be32(0);\n    header.refcount_table_offset = cpu_to_be64(cluster_size);\n    header.refcount_table_clusters = cpu_to_be32(1);\n    header.refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT);\n    header.header_length = cpu_to_be32(sizeof(header));\n    if (flags & BLOCK_FLAG_ENCRYPT) {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);\n    } else {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);\n    if (flags & BLOCK_FLAG_LAZY_REFCOUNTS) {\n        header.compatible_features |=\n            cpu_to_be64(QCOW2_COMPAT_LAZY_REFCOUNTS);\n    ret = bdrv_pwrite(bs, 0, &header, sizeof(header));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write qcow2 header\");\n    /* Write an empty refcount table */\n    refcount_table = g_malloc0(cluster_size);\n    ret = bdrv_pwrite(bs, cluster_size, refcount_table, cluster_size);\n    g_free(refcount_table);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write refcount table\");\n    /*\n     * And now open the image and make it consistent first (i.e. increase the\n     * refcount of the cluster that is occupied by the header and the refcount\n     * table)\n     */\n    BlockDriver* drv = bdrv_find_format(\"qcow2\");\n    assert(drv != NULL);\n        BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);\n    if (ret < 0) {\n    ret = qcow2_alloc_clusters(bs, 2 * cluster_size);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not allocate clusters for qcow2 \"\n                         \"header and refcount table\");\n    } else if (ret != 0) {\n        error_report(\"Huh, first cluster in empty image is already in use?\");\n        abort();\n    /* Okay, now that we have a valid image, let's give it the right size */\n    ret = bdrv_truncate(bs, total_size * BDRV_SECTOR_SIZE);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not resize image\");\n    /* Want a backing file? There you go.*/\n    if (backing_file) {\n        ret = bdrv_change_backing_file(bs, backing_file, backing_format);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not assign backing file '%s' \"\n                             \"with format '%s'\", backing_file, backing_format);\n    /* And if we're supposed to preallocate metadata, do that now */\n    if (prealloc) {\n        BDRVQcowState *s = bs->opaque;\n        qemu_co_mutex_lock(&s->lock);\n        ret = preallocate(bs);\n        qemu_co_mutex_unlock(&s->lock);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not preallocate metadata\");\n    ret = 0;\nout:\n    bdrv_unref(bs);\n    return ret;", "idx": 26388, "substitutes": {"filename": ["f", "length", "nm", "subject", "fs", "ln", "journal", "Filename", "title", "buffer", "jpg", "path", "FN", "family", "ames", "metadata", "fn", "n", "p", "prefix", "kj", "buf", "nil", "file", "stem", "location", "size", "ename", "username", "fil", "txt", "files", "directory", "ame", "fp", "source", "description", "stat", "kl", "format", "names", "name", "FIL"], "total_size": ["total_Size", "Total_Size", "Total_name", "Total_mem", "totalmodSize", "total_name", "totalmodname", "Total_size", "totalmodmem", "total_mem", "totalmodsize"], "backing_file": ["backingetybuffer", "backding_buffer", "backing_data", "backing_buffer", "backingetydata", "backingetyformat", "backding_file", "backding_data", "backingetyfile", "backding_format"], "backing_format": ["backoring_file", "backing__data", "backoring__type", "backoring__file", "backing_data", "backoring_data", "backoring_type", "backoring__data", "backing__file", "backoring_format", "backing_type", "backing__type", "backoring__format", "backing__format"], "flags": ["ops", "args", "fields", "versions", "status", "ants", "fs", "tags", "params", "comments", "links", "Flags", "details", "missions", "headers", "mode", "ags", "bits", "magic", "settings", "types", "weights", "locks", "stats", "mask", "flag", "kind", "FLAG", "actions", "features", "properties", "heads", "format"], "cluster_size": ["closer_size", "cluster2Size", "closer_Size", "cluster2SIZE", "closer2SIZE", "cluster2size", "clusters_count", "closer2Size", "closer2name", "closer_name", "closer2size", "cluster2name", "cluster_name", "cluster_SIZE", "cluster_count", "clusters_SIZE", "clusters_length", "cluster_length", "clusters_size", "closer_SIZE", "cluster_Size"], "prealloc": ["prepalloc", "prepavailable", "autoproc", "prefree", "Prealloc", "prepproc", "autoalloc", "autofree", "prepfree", "preproc", "Preproc", "preavailable", "Prefree", "Preavailable", "autoavailable"], "options": ["sections", "option", "opt", "length", "ops", "values", "args", "phones", "versions", "config", "tags", "params", "details", "currency", "caps", "spec", "offs", "headers", "objects", "bits", "outs", "settings", "abilities", "wcs", "ts", "weights", "types", "info", "vals", "stats", "styles", "oops", "optional", "Options", "actions", "features", "properties", "parts", "errors", "name"], "version": ["option", "type", "VER", "name", "direction", "software", "power", "hash", "versions", "feature", "status", "generation", "value", "VERSION", "date", "command", "currency", "family", "spec", "ver", "mode", "bits", "sector", "magic", "level", "sequence", "vers", "tag", "depth", "release", "section", "size", "interface", "vision", "serial", "flag", "style", "number", "time", "features", "usage", "package", "Version", "description", "format", "v", "program"], "errp": [" errP", "errorping", "errorpb", "errP", "errping", "rrping", " errping", "rrP", "rrp", "erpb", "erp", "errpb", "errorp", " errpb", "rrpb", "erP", "errorP"], "cluster_bits": ["clutter___bits", "cluster_jobs", "clocker___bits", "cluster___pieces", "clust_length", "cluster___ops", "clique___bits", "cluster_ops", "cluster_codes", "clique___obs", "clutter_size", "cluster_pieces", "clusterPobs", "clusterablestates", "cluster2bs", "clocker_bits", "clusterPbits", "cluster___obs", "clutter_bit", "clique_bits", "clique___locks", "cluster_locks", "clusteritybits", "clique___states", "clique_obs", "cluster2size", "clusterableobs", "cluster___states", "clusteritycodes", "clusterPstates", "cluster_obs", "clique_states", "clutter___pieces", "clusterablelocks", "clust_size", "clutter_pieces", "cluster_parts", "cluster_bs", "cluster2tops", "cluster_bit", "clutter___bit", "cluster_length", "clocker_ops", "cluster_tops", "cluster_its", "clusteritysize", "cluster_plugins", "cluster_states", "clocker_parts", "cluster_changes", "cluster___bit", "cluster___bits", "cluster___parts", "clocker___parts", "cluster___size", "clique_locks", "clusterablebits", "clust_codes", "clocker___ops", "clutter_bits", "cluster___locks", "cluster___changes", "cluster___plugins", "clusterPlocks", "clutter___size", "clusteritylength", "clust_bits", "clust_changes", "clust_plugins", "cluster2bits"], "bs": ["sys", "bb", "sb", "bas", "pb", "bl", "br", "lbs", "os", "bc", "fs", "rs", "BS", "bf", "ubs", "ds", "uts", "bm", "ks", "aos", "bos", "bis", "cs", "cks", "bits", "vs", "js", "bn", "ts", "ns", "ps", "bi", "qs", "bd", "bh", "bt", "its", "gs", "bp", "obs", "ls"], "header": ["hd", "handler", "protected", "address", "journal", "er", "buffer", "headers", "magic", "document", "history", "Header", "writer", "head", "table", "h", "detail", "tar", "padding", "parent", "definition", "term", "xml", "entry", "fr", "error", "pr", "spec", "layout", "section", "primary", "data", "window", "handle", "offset", "description", "summary", "tree", "peer", "HEAD", "part", "body", "title", "member", "owner", "comment", "metadata", "fn", "filter", "policy", "file", "dr", "public", "package", "number", "tr", "lp", "drm", "block", "attribute", "client", "null", "component", "wrapper", "profile", "event", "master", "row", "list", "cache", "layer", "module", "line", "response", "heading", "txt", "position", "channel", "content", "index", "name"], "refcount_table": ["refcache_table", "refcount_TABLE", "refcache_TABLE", "refcache_data", "refcache_cache", "refcount_data", "refcountstable", "refcountsTABLE", "refcount_cache", "refcountsdata", "refcountscache"], "local_err": [" local_notice", "global_er", "local__rr", "local__buf", "local_notice", "local2buf", " local_error", "global_err", "local_buf", "local____err", "local__err", " local_buf", "local_rr", "local_r", "global_buf", "local____error", "local____notice", "local__r", " local_rr", "local_error", " local_r", "local2er", "local2err", "local_er"], "ret": ["alt", "ter", "ort", "ll", "status", "att", "cont", "del", "arr", "dt", "rem", "rt", " RET", " Ret", "mt", "Ret", "gc", "inter", "rest", "rm", "re", "br", "try", "plain", "gt", "after", "cat", "det", "desc", "eval", "final", "sys", "not", "reset", "RET", "def", "nl", "ry", "get", "mel", "rect", "pret", "ne", "print", "back", "url", "tr", "elt", "lit", "err", "ref", "len", "ure", "ber", "result", "reg", "ext", "cmd", "resp", "gov", "usr", "nt", "rets", "ft", "val", " alt", "pat", "t", "arg", "res"]}}
{"project": "FFmpeg", "commit_id": "3dea28cc2ef22861347918b6740c4c05c46a6614", "target": 0, "func": "static void idr(H264Context *h){\n\n    int i;\n\n    ff_h264_remove_all_refs(h);\n\n    h->prev_frame_num= -1;\n\n    h->prev_frame_num_offset= 0;\n\n    h->prev_poc_msb= 1<<16;\n\n    h->prev_poc_lsb= 0;\n\n    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)\n\n        h->last_pocs[i] = INT_MIN;\n\n}\n", "idx": 26390, "substitutes": {"h": ["help", "here", "f", "hd", "ch", "it", "ih", "hash", "conn", "ph", "comm", "host", "temp", "he", "dh", "w", "c", "eh", "pp", "k", "event", "rh", "hs", "mem", "hm", "g", "hp", "ah", "header", "p", "el", "kh", "cache", "hz", "sh", "go", "j", "oh", "ht", "hist", "th", "html", "b", "l", "info", "dr", "uh", "history", "bh", "z", "H", "hh", "hl", "en", "gc", "q", "m", "v", "hw"], "i": ["f", "it", "x", "batch", "ui", " j", " c", "multi", "ki", " pos", " multi", "pi", " ni", " ii", " p", "ini", " iter", "yi", "index", "ri", "PI", "gu", "in", "me", "gi", "I", "p", "phi", " bi", " vi", "di", "zi", "sim", "j", "ai", "uni", "span", " err", "mi", "li", "iq", "asi", "ii", "chain", "is", "ti", "ind", " ti", " pi", "ims", " mi", "bi", "ij", "ci", "y", "iter", " si", "iu", " I", " m", "xi", "t", "qi", "si", "m", "q", "cli", " index", " l", "mu", "ei", "ix"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xffffffff);\n\n}\n", "idx": 26396, "substitutes": {"opaque": ["obque", "opsiera", "boque", "ropaques", "ropque", " opiera", "ropaque", "opque", " opaques", "obaque", "opiera", "opsaque", "opasus", "boasus", "opsque", "ropasus", "opsaques", "obiera", "obaques", " opasus", " opque", "boaques", "boaque", "opaques"], "addr": ["oad", "inter", "x", "ad", "tx", "trans", "err", "adr", "address", "arp", "ref", "host", "dh", "pad", "rs", "id", "at", "act", "now", "r", "cmd", "ack", "ar", "add", "ord", "coord", "pos", " address", "eth", "rt", "attr", "work", "dr", "loc", "src", "alloc", "Address", "handle", "ptr", "offset", "tr", "hw"], "val": [" vol", "pol", "it", " tx", " update", "lit", "tx", "rol", "al", "aval", "ref", "sol", " valid", "bit", "value", "valid", " bl", "mem", " msg", "sel", " slot", " eval", "p", "state", "vol", "buf", " v", " pref", "pos", "ctx", " ty", " value", " al", "data", " seq", "Val", "VAL", "vals", "loc", "ival", " lac", " cal", "serv", "ret", " weight", "vt", "abl", "v"], "d": ["f", "sd", "pd", "ld", "ad", "cal", "o", "ade", "dq", "w", "c", "done", "D", "dc", "debug", "ds", "g", "r", "db", "n", "p", "dm", "di", "j", "da", "b", "ind", "de", "dr", "dd", "dat", "bd", "dra", "dn", "fd", "e", "draw", "h", "t", "dict", "m", "od"], "reg": ["region", "red", "rol", "rm", "ref", "re", "Reg", "br", "ress", "mb", "map", "mem", "rr", "repl", "g", "r", "db", "rec", "REG", "gr", "rel", "rar", "disc", "rem", "ig", "eg", "rt", "loc", "ret", "ptr", "tr", "rg", "ro", "res"]}}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "static void abort_codec_experimental(AVCodec *c, int encoder)\n\n{\n\n    const char *codec_string = encoder ? \"encoder\" : \"decoder\";\n\n    AVCodec *codec;\n\n    av_log(NULL, AV_LOG_FATAL, \"%s '%s' is experimental and might produce bad \"\n\n            \"results.\\nAdd '-strict experimental' if you want to use it.\\n\",\n\n            codec_string, c->name);\n\n    codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);\n\n    if (!(codec->capabilities & CODEC_CAP_EXPERIMENTAL))\n\n        av_log(NULL, AV_LOG_FATAL, \"Or use the non experimental %s '%s'.\\n\",\n\n               codec_string, codec->name);\n\n    exit(1);\n\n}\n", "idx": 26428, "substitutes": {"c": ["f", "cl", "ch", "cmp", "ce", "cu", "err", "comm", "cand", "pc", "bc", "w", "rc", "abc", "tc", "cont", "ec", "g", "cp", "n", "p", "cs", "ctx", "enc", "cod", "com", "co", "b", "ct", "wcs", "vc", "anc", "ac", "mc", "con", "fc", "coll", "e", "etc", "gc", "h", "t", "cc", "C", "v", "lc", "cv", "conf"], "encoder": ["octaler", "entoder", "ecolder", "decoded", "octoder", "encolder", "decolder", "enoder", "octoding", "encaler", "encoded", "decoder", "entoding", "ENCoded", " encolder", "decuter", "octoded", "ecoder", "encuter", "enoding", "enoded", "encoding", " encoding", " encuter", "ENCoder", "ecoded", "ecuter", " encaler", "entoded", "ENCaler", " encoded", "ENCoding", "entuter", "enuter"], "codec_string": ["codec_prefix", "codec_String", "codpeg_String", "codenc_String", "codpeg_string", "codenc_string", "codpeg_prefix", "codec_name", "codisc_String", "codisc_string", "codenc_prefix", "codec_strings", "codenc_name", "codisc_strings"], "codec": ["Codef", "octpeg", "Codec", "odfc", "octEC", "Codoe", "CodEC", " codEC", " codpeg", "Codoc", "odep", "cdec", "octdec", "codep", "codef", "Coddec", " codoe", "codoc", "octec", "codeEC", "codpeg", "cdef", "codoe", "cdoe", " codep", " codfc", "odpeg", "codEC", "odenc", " codoc", "octoc", "codeep", "codeenc", "odec", "codeec", " codef", "codenc", "coddec", "codedec", "octfc", "cdoc", " codenc", "odoc", "odEC", "codfc", "codeoc"]}}
{"project": "FFmpeg", "commit_id": "877f76ad33bb9b0b0d09565dd9ec1cf8e91096f1", "target": 1, "func": "static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,\n\n                                  const uint8_t *src, int srcW, int xInc)\n\n{\n\n    int i;\n\n    unsigned int xpos=0;\n\n    for (i=0;i<dstWidth;i++) {\n\n        register unsigned int xx=xpos>>16;\n\n        register unsigned int xalpha=(xpos&0xFFFF)>>9;\n\n        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\n\n        xpos+=xInc;\n\n    }\n\n\n\n}", "idx": 26435, "substitutes": {"c": ["f", "x", "d", "w", "tc", "dc", "g", "p", "cache", "sc", "s", "cs", "ctx", "a", "b", "ct", "ac", "ci", "fc", "e", "u", "h", "t", "cc", "C", "v", "lc", "m"], "dst": ["Dput", "dsrc", " dsrc", " dST", "ldput", "ldst", "Dst", "Dsts", " dsts", "Ddest", "dssts", "Dsrc", "dsst", "dST", "ldST", " dput", "dput", "DST", " ddest", "dsput", "dsdest", "dsts", "ddest", "ldsrc"], "dstWidth": ["DstWidth", "drcwidth", " dstW", "dstW", "dsrcwidth", "dsrcLen", "dstHeight", "dsrcWidth", "DstW", "DstHeight", "dbrW", "dbrHeight", " dstwidth", "destW", "DstPath", " dblWidth", "drcLen", "dstwidth", " dblwidth", "drcPath", "drcW", " dstLen", "DestW", "dstPath", "dblLen", "drcWidth", "DestHeight", "destPath", "drcHeight", " dblLen", "dstLen", "dblWidth", "dblwidth", "dbrPath", "destHeight", "DestPath", "dbrWidth", "destWidth", "dblW", "DestWidth", " dblW", "dsrcW"], "src": ["sn", "pack", "cur", "sb", "ins", "rl", "syn", "iv", "rs", "usc", "sub", "rc", "cont", "sl", "seq", "secure", "sync", "sup", "in", "r", "inst", "sr", "supp", "sc", "s", "img", "ser", "dest", "usr", "input", "sec", "RC", "bs", "raw", "rt", "b", "req", "desc", "loc", "txt", "sur", "st", "bin", "aux", "iter", "copy", "source", "pkg", "cc", "stock", "proc", "str", "sq"], "srcW": ["srcLength", " srcLength", "sourceWeight", "srcWeight", "rcWidth", " srcWidth", "rcWeight", "sourceW", "srcWidth", "rcW", "sourceLength", " srcWeight", "rcLength", "sourceWidth"], "xInc": ["exIncre", " xinc", "Xinc", "xyinc", " xIncre", "XInc", "xyCond", "XCond", "xCond", "XINC", "xINC", "exINC", "xIncre", "xyINC", " xINC", "exInc", "xinc", "XIncre", "exinc", "xyInc", " xCond"], "i": ["f", "it", "ic", "x", "batch", "ui", "ki", "multi", " di", " multi", "ski", "pi", "ini", " ii", "id", "index", " iter", " Xi", "ri", "r", "gi", "I", " my", "p", "phi", " bi", "di", "oi", "zi", "sim", "j", "ai", "span", " li", "asi", "mi", "li", "ii", "iq", "is", "ti", "ind", "l", "b", " ti", " pi", "y", " mi", "bi", "ims", "ci", "ip", "ij", "z", "iter", "e", "iu", " I", "xi", "si", "im", "m", "v", "qi", "ei", "ix"]}}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int standard_decode_i_mbs(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    MpegEncContext *s = &v->s;\n\n    int current_mb = 0; /* MB/Block Position info */\n\n    uint8_t cbpcy[4], previous_cbpcy[4], predicted_cbpcy,\n\n        *p_cbpcy /* Pointer to skip some math */;\n\n\n\n    /* Reset CBPCY predictors */\n\n    memset(v->previous_line_cbpcy, 0, s->mb_stride<<2);\n\n\n\n    /* Select ttmb table depending on pq */\n\n    if (v->pq < 5) v->ttmb_vlc = &vc9_ttmb_vlc[0];\n\n    else if (v->pq < 13) v->ttmb_vlc = &vc9_ttmb_vlc[1];\n\n    else v->ttmb_vlc = &vc9_ttmb_vlc[2];\n\n\n\n    for (s->mb_y=0; s->mb_y<s->mb_height; s->mb_y++)\n\n    {\n\n        /* Init CBPCY for line */\n\n        *((uint32_t*)previous_cbpcy) = 0x00000000;\n\n        p_cbpcy = v->previous_line_cbpcy+4;\n\n\n\n        for (s->mb_x=0; s->mb_x<s->mb_width; s->mb_x++, p_cbpcy += 4)\n\n        {\n\n            /* Get CBPCY */\n\n            GET_CBPCY(ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS);\n\n\n\n            s->ac_pred = get_bits(gb, 1);\n\n\n\n            /* TODO: Decode blocks from that mb wrt cbpcy */\n\n\n\n            /* Update for next block */\n\n#if TRACE > 2\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"Block %4i: p_cbpcy=%i%i%i%i, previous_cbpcy=%i%i%i%i,\"\n\n                   \" cbpcy=%i%i%i%i\\n\", current_mb,\n\n                   p_cbpcy[0], p_cbpcy[1], p_cbpcy[2], p_cbpcy[3],\n\n                   previous_cbpcy[0], previous_cbpcy[1], previous_cbpcy[2], previous_cbpcy[3],\n\n                   cbpcy[0], cbpcy[1], cbpcy[2], cbpcy[3]);\n\n#endif\n\n            *((uint32_t*)p_cbpcy) = *((uint32_t*)previous_cbpcy);\n\n            *((uint32_t*)previous_cbpcy) = *((uint32_t*)cbpcy);\n\n            current_mb++;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 26437, "substitutes": {"v": ["vm", "f", "ov", "i", "x", "o", "conv", "ev", "lv", "iv", "vp", "tv", "us", "value", "c", "w", "rev", "video", "wire", "dev", "vv", "um", "g", "r", "ed", "n", "p", "ve", "ver", "va", "env", "vr", "j", "view", "vs", "inv", "message", "av", "V", "b", "l", "nv", "vc", "y", "version", "e", "sv", "qv", "vi", "h", "t", "vt", "uv", "m", "q", "cv"], "gb": ["bb", "fb", "sb", "pb", "Gb", "vd", "uf", "csv", "mb", "nb", "gt", "gif", "bf", "GB", "ds", "gz", "bm", "g", "db", "pg", "img", "cb", "cm", "buf", "gg", "hub", "ctx", "vg", "kb", "bs", "bg", "gd", "bn", "cfg", "gm", "tg", "py", "wb", "bd", "bt", "gs", "rb", "sv", "sg", "gc", "uv", "cv"], "s": ["mys", "ops", "o", "sis", "d", "sports", "c", "tests", "p", "changes", "ctx", "vs", "S", "ns", "states", "less", "h", "ows", "sq", "sd", "sn", "i", "sb", "os", "rs", "us", "spec", "n", "sc", "cs", "services", "j", "als", "ats", "ts", "ims", "its", "parts", "m", "sys", "ms", "x", "as", "ins", "ses", "bis", "sts", "sw", "bs", "a", "is", "b", "l", "ps", "stats", "st", "gs", "ls", "q", "f", "csv", "se", "fs", "ds", "hs", "details", "g", "sh", "js", "ss", "settings", "qs", "south", "es", "sv", "sg", "ys", "t", "conv"], "cbpcy": ["corephpoway", "cbappcy", "cbfmy", "cbpagemy", "cbppcu", "cbphpyr", "cbcpby", "nbcpyr", "callbackpcy", "cbcpyr", "cbfsty", "rbpmy", "cbply", "rbpcmy", "cbphply", "cbpointvy", "nbcpcy", "bufpcy", "cbfcy", "cbpce", "cbpcsty", "cbnpyth", "cbppwy", "bufpwy", "cbpcu", "cbpointcy", "bufappwy", "cbpyr", "corephpyth", "rbpcin", "callbackpky", "rbpvy", "rbpccin", "callbackpmy", "cbfky", "cbpagecin", "cbppcy", "cbpsty", "cbpcky", "callbackfky", "cbppby", "cbppyr", "nbpcy", "corepyth", "cbpnoway", "cbpvy", "cbpcwy", "nbpby", "cbjpky", "rbpcvy", "cbphpby", "cbpby", "cbpply", "cbappcu", "cbpmy", "nbpyr", "cbnpoway", "corepoway", "bufpcu", "cbpnce", "nbcply", "rbpcy", "cbappwy", "cbphpcy", "cbpnyth", "bufappcu", "corepcy", "cbpagevy", "cbappyr", "cbpncy", "cbpcvy", "cbpccu", "cbpagecy", "cbpwy", "cbpointmy", "cbpyth", "callbackfcy", "bufappcy", "cbcpcy", "bufappyr", "cbnpcy", "bufpyr", "cbpcmy", "corephpce", "cbpccy", "cbphpoway", "cbpcyr", "callbackpsty", "nbply", "cbpcin", "cbjpcy", "cbjpsty", "cbpoway", "cbnpce", "callbackfmy", "cbpointcin", "corepce", "cbjpmy", "cbphpyth", "cbphpce", "corephpcy", "nbcpby", "cbcply", "rbpccy", "cbpky", "callbackfsty", "cbpccin"], "previous_cbpcy": ["previous_abbpsy", "previous_cbtpcy", "previous_cfgpyr", "previous_cfgpsct", "previous_abbpcy", "previous_gobpincy", "previous_cbpyr", "previous_cbpcre", "previous_cbptry", "previous_bcpcy", "previous_gobpcy", "previous_cbcply", "previous_cbwpcre", "previous_abbpsty", "previous_bcpwy", "previous_cbparcre", "previous_cbpsy", "previous_cbpartsty", "previous_cbbck", "previous_cbtpsty", "previous_cbccr", "previous_cbcly", "previous_debparcre", "previous_cfgpcy", "previous_cbparsty", "previous_cfgpwy", "previous_cbpck", "previous_sbcpce", "previous_cfgpct", "previous_cbparck", "previous_cbperct", "previous_cbnpcr", "previous_abbpody", "previous_cbperyr", "previous_cbparcy", "previous_cbcpcy", "previous_bcbck", "previous_cbpacre", "previous_cbbwy", "previous_cfgpscy", "previous_abbpsody", "previous_cbpacy", "previous_gobpinyth", "previous_abbpscy", "previous_cbpartody", "previous_gobpyth", "previous_debparyr", "previous_cbperwy", "previous_cbparyr", "previous_cbpartcy", "previous_debpyr", "previous_cbpresty", "previous_sbply", "previous_cbtpody", "previous_cbpyth", "previous_cbply", "previous_cbpsyr", "previous_sbpce", "previous_sbcpcy", "previous_cbparty", "previous_cbprect", "previous_gobpintry", "previous_cbpayth", "previous_gobptry", "previous_cbcce", "previous_sbpcy", "previous_abbpssty", "previous_cbpercy", "previous_cbparwy", "previous_debpsty", "previous_cbnpck", "previous_cbprecre", "previous_cbbcre", "previous_cbnply", "previous_cbpsct", "previous_cbpreyr", "previous_cbnpcy", "previous_debpcy", "previous_gobpcre", "previous_cbcpce", "previous_cfgpsyr", "previous_cbnpcre", "previous_cbpincre", "previous_sbcpcr", "previous_cfgpswy", "previous_bcpck", "previous_cbpincy", "previous_cbpinyth", "previous_abbpy", "previous_debpcre", "previous_cbwpcy", "previous_cbpssty", "previous_cbpwy", "previous_cbcpcr", "previous_cbpintry", "previous_cbpatry", "previous_cbtpy", "previous_bcbwy", "previous_cbprewy", "previous_cbccy", "previous_cbpscy", "previous_cbpcr", "previous_cbpody", "previous_cbbcy", "previous_gobpincre", "previous_cbwpyr", "previous_cbpsty", "previous_sbcply", "previous_cbpy", "previous_bcbcy", "previous_debparcy", "previous_cbwpsty", "previous_cbpsody", "previous_bcbcre", "previous_bcpcre", "previous_debparsty", "previous_cbpct", "previous_cbpce", "previous_cbnpce", "previous_sbpcr", "previous_cbprecy", "previous_cbpswy", "previous_cbnpwy"], "predicted_cbpcy": ["predicted_cbphpwy", "predicted_cbpcry", "predicted_cbphpyr", "predicted_cbcwy", "predicted_cbccy", "predicted_curpcry", "predicted_curphpwy", "predicted_cbfpcry", "predicted_cbphpcry", "predicted_cbcyr", "predicted_curphpcy", "predicted_cbfpcy", "predicted_curpyr", "predicted_cbccry", "predicted_cbfpwy", "predicted_cbfpyr", "predicted_cbpwy", "predicted_curpwy", "predicted_curphpcry", "predicted_cbphpcy", "predicted_cbpyr", "predicted_curpcy", "predicted_curphpyr"], "p_cbpcy": ["p_cblpcy", "p_cbmcy", "p_cbpccr", "p_cbopty", "p_cbcpmy", "p_cbpsyr", "p_cblpyr", "p_cbpinghey", "p_cvcpsty", "p_cbpcu", "p_cbopyr", "p_cbpocy", "p_cbcpry", "p_cbpingry", "p_cbpcyr", "p_cbcptry", "p_cbcpny", "p_rbpry", "p_cvcpcy", "p_cbpmy", "p_CBPocy", "p_cbpry", "p_bbpccy", "p_cbmmy", "p_cbgcr", "p_wbpty", "p_wblpcy", "p_cbpdcy", "p_gbpsty", "p_cbpcr", "p_cbptry", "p_cbpcsty", "p_cbhsty", "p_wbpcy", "p_cbPocy", "p_cbphey", "p_cbpci", "p_cbhocy", "p_cbpsy", "p_cbpade", "p_wbpyr", "p_cvpny", "p_gbpcy", "p_wblpyr", "p_cbpaocy", "p_gbcptry", "p_cinhcy", "p_cvpsty", "p_cblpry", "p_cinpde", "p_bbpcy", "p_cvpcy", "p_cbopci", "p_CBpcy", "p_rbcpry", "p_cbpctry", "p_cbhcy", "p_cbpany", "p_cblpci", "p_cbcpcu", "p_gbptry", "p_cbpty", "p_CBPsy", "p_cinhocy", "p_bbpcyr", "p_cbpcny", "p_cinpocy", "p_cinhde", "p_gbpcu", "p_cbgcy", "p_cbctry", "p_cvmcy", "p_wblpci", "p_wbpci", "p_rbcpcy", "p_cbjpsty", "p_cbccy", "p_cblpmy", "p_cbpyr", "p_cvmci", "p_cinpcy", "p_gbcpcy", "p_cbpczy", "p_cvptry", "p_cbcde", "p_cbcpzy", "p_cbpingyr", "p_wblpty", "p_cbpasty", "p_cblpty", "p_cbcpsty", "p_cinpsty", "p_cbhde", "p_cbghey", "p_cvpci", "p_CBPcy", "p_cvcpny", "p_bbpchey", "p_cbpingocy", "p_cbccu", "p_cbgyr", "p_CBPry", "p_cbpscy", "p_cbPry", "p_cbpdzy", "p_cbpsci", "p_cbPcy", "p_CBpry", "p_cbpatry", "p_cbpzy", "p_cbpde", "p_cbPsy", "p_cvcptry", "p_cvmmy", "p_gbcpcu", "p_bbphey", "p_cbpchey", "p_cvpmy", "p_cbpingcy", "p_cbjpcu", "p_cinhsty", "p_rbpcy", "p_bbpyr", "p_bbpcr", "p_cblpocy", "p_cbpny", "p_cbpsty", "p_cblpsy", "p_cbpccy", "p_cbpacy", "p_cbjpcy", "p_cbcsty", "p_gbcpsty", "p_cbpingcr", "p_cbpingsy", "p_cbcpci", "p_cbpcry", "p_cbcocy", "p_bbpccr", "p_cbpdry", "p_cbjptry", "p_cbopcy", "p_CBpocy", "p_cbcpcy", "p_rbpzy", "p_rbcpzy", "p_CBpsy", "p_cbmci"], "mb_y": ["mb_yy", "MB_y", "bb__y", "mbtimex", "mb_ye", "MB_yy", "mb_my", "bb__yy", "bb_y", "bb_x", "MB_j", "bb_my", "mb__yy", "mb__ey", "bb_yy", "mb__ye", "mb__y", "bb_ey", "mbtimemy", "bb__ye", "bb__ey", "mb_ey", "mbtimeey", "mb_j", "mbtimey", "MB_x", "bb_ye"], "mb_x": ["mb_wx", "mg_y", "mp__ex", "mb__x", "mb_ex", "ib_x", "mb_inner", "mbpoy", "mb_xy", "mgpoinner", "mgpoy", "mp__x", "mbpox", "mp_y", "mb__xy", "mp_x", "mb__ex", "mp_xy", "mp__y", "mb__y", "mp_ex", "mp__xy", "mb__inner", "mb_el", "ib_y", "ib_el", "mgpox", "mbpoex", "mgpoex", "mg_ex", "mbpoinner", "mg_inner", "mg_x", "ib_wx"], "current_mb": [" current_ob", "current_ob", "current2mt", " current_MB", " current_mt", "current2MB", " current2MB", "current_bound", "current_mt", " current2bound", " current_bound", "current_MB", "current2mb", " current2mb", " current2mt", " current_mp", "current_mp", "current2bound"]}}
{"project": "qemu", "commit_id": "167351020420c285b67cdf0603501b3d3b15e3f7", "target": 1, "func": "static int jazz_led_init(SysBusDevice *dev)\n\n{\n\n    LedState *s = FROM_SYSBUS(LedState, dev);\n\n\n\n    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    s->ds = graphic_console_init(jazz_led_update_display,\n\n                                 jazz_led_invalidate_display,\n\n                                 jazz_led_screen_dump,\n\n                                 jazz_led_text_update, s);\n\n\n\n    return 0;\n\n}\n", "idx": 26443, "substitutes": {"dev": ["priv", "sd", "sys", "device", "ad", "Device", "hid", "dis", "cam", "obj", "home", "ev", "app", "d", "pad", "adv", "w", "disk", "ds", "mem", "var", "g", "md", "db", "DEV", "ver", "p", "ve", "dm", "devices", "go", "ctx", "usb", "nt", "de", "dd", "des", "dem", "window", "Dev", "tr", "proc", "v", "hw"], "s": ["f", "sys", "ms", "i", "as", "sb", "out", "ins", "os", "comm", "fs", "sol", "v", "rs", "d", "w", "c", "sam", "ses", "ds", "hs", "g", "r", "spec", "n", "p", "has", "state", "cs", "sts", "services", "aws", "j", "S", "als", "js", "bs", "ss", "a", "is", "b", "l", "ns", "ts", "ps", "sm", "y", "qs", "gs", "less", "sv", "e", "sp", "h", "ls", "t", "q", "m", "sq"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)\n\n{\n\n        struct fs_dma_ctrl *ctrl = opaque;\n\n\tint c;\n\n\tuint32_t r = 0;\n\n\n\n\tif (size != 4) {\n\n\t\tdma_rinvalid(opaque, addr);\n\n\t}\n\n\n\n\t/* Make addr relative to this channel and bounded to nr regs.  */\n\n\tc = fs_channel(addr);\n\n\taddr &= 0xff;\n\n\taddr >>= 2;\n\n\tswitch (addr)\n\n\t{\n\n\t\tcase RW_STAT:\n\n\t\t\tr = ctrl->channels[c].state & 7;\n\n\t\t\tr |= ctrl->channels[c].eol << 5;\n\n\t\t\tr |= ctrl->channels[c].stream_cmd_src << 8;\n\n\t\t\tbreak;\n\n\n\n\t\tdefault:\n\n\t\t\tr = ctrl->channels[c].regs[addr];\n\n\t\t\tD(printf (\"%s c=%d addr=\" TARGET_FMT_plx \"\\n\",\n\n\t\t\t\t  __func__, c, addr));\n\n\t\t\tbreak;\n\n\t}\n\n\treturn r;\n\n}\n", "idx": 26451, "substitutes": {"ctrl": ["cl", "ch", "cur", "cmp", "Ctrl", "cf", "rl", "tl", "comm", "Controller", " cur", "config", "Control", "rc", "ctr", "cont", "rh", "trl", "cmd", "ctl", "cp", "bitcoin", "tab", "nc", "compl", "cb", "cm", "acl", "forge", "ctx", "co", "cfg", "ach", "req", "ct", "attr", "cr", "addr", "history", "fc", "aux", "exec", "rb", "cap", "ptr", "tr", "ls", "jp", "cc", "controller", "manager", "control", "lc", "cv"], "c": ["f", "cl", "ch", "cur", "uc", "x", "cmp", "cf", "ce", "cu", "ca", "col", "d", "w", " cc", "rc", "k", "tc", "dc", "cont", "cd", "id", "ec", "r", "cat", "n", "p", "cp", "cache", "sc", "nc", "cn", "cs", "cb", "cm", " C", "ctx", "enc", "co", "chain", "a", "ach", "b", "ct", "attr", "ac", "unc", " cr", "fac", "cr", "l", "ci", "mc", "con", "fc", "current", "gc", "h", "t", "cc", "C", "v", "lc", "cv"]}}
{"project": "qemu", "commit_id": "b0457b69209fca3fb40a85bd54d7f27eb4bad7e7", "target": 0, "func": "static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s)\n\n{\n\n    struct pxa_frame_descriptor_s desc;\n\n    target_phys_addr_t descptr;\n\n    int i;\n\n\n\n    for (i = 0; i < PXA_LCDDMA_CHANS; i ++) {\n\n        s->dma_ch[i].source = 0;\n\n\n\n        if (!s->dma_ch[i].up)\n\n            continue;\n\n\n\n        if (s->dma_ch[i].branch & FBR_BRA) {\n\n            descptr = s->dma_ch[i].branch & FBR_SRCADDR;\n\n            if (s->dma_ch[i].branch & FBR_BINT)\n\n                pxa2xx_dma_bs_set(s, i);\n\n            s->dma_ch[i].branch &= ~FBR_BRA;\n\n        } else\n\n            descptr = s->dma_ch[i].descriptor;\n\n\n\n        if (!(descptr >= PXA2XX_SDRAM_BASE && descptr +\n\n                    sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))\n\n            continue;\n\n\n\n        cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));\n\n        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);\n\n        s->dma_ch[i].source = tswap32(desc.fsaddr);\n\n        s->dma_ch[i].id = tswap32(desc.fidr);\n\n        s->dma_ch[i].command = tswap32(desc.ldcmd);\n\n    }\n\n}\n", "idx": 26458, "substitutes": {"s": ["ops", "eps", "service", "status", "comm", "c", "sync", "p", "changes", "asm", "aws", "vs", "S", "ns", "sm", "y", "less", "h", "series", "sa", "sb", "args", "store", "os", "rs", "sl", "spec", "sc", "state", "cs", "services", "j", "als", "so", "ats", "ts", "ims", "its", "parts", "m", "sys", "ms", "ins", "ses", "sts", "sw", "bs", "is", "ps", "stats", "st", "gs", "ls", "stat", "ssl", "ports", "se", "fs", "w", "ds", "hs", "params", "details", "g", "set", "js", "ss", "settings", "qs", "south", "es", "sp", "sv", "self", "source", "conf"], "desc": ["sd", "dim", "esc", "cmp", "pb", "cript", "dir", "obj", "err", "d", "def", "sub", "rc", "asc", "cd", "dc", "cont", "ds", "dev", "seq", "ec", "md", "cmd", "ext", "comment", "good", "rec", "sc", "ser", "Desc", "disc", "msg", "dest", "dist", "buf", "sort", "decl", "ctx", "enc", "sec", "cod", "td", "gd", "doc", "ript", "req", "test", "data", "de", "DES", "info", "ind", "des", "loc", "txt", " Desc", "ptr", "tr", "description", "tmp", "dict", "str"], "descptr": ["Descpr", "descaddr", "escpointer", "decPtr", "descrect", "descriptionPtr", "escrect", "scPtr", "descriptionaddr", "scptr", "deppointer", "escoffset", " descrect", " descaddr", "depPtr", "decaddress", "descaddress", "descriptionpointer", "escptr", "scpointer", "testoffset", "descriptionpr", "testptr", "Descaddr", "descoffset", "escPtr", " descpointer", "descpr", "Descpointer", "descriptionptr", " descPtr", "descpointer", "escaddress", "descPtr", "depptr", "testPtr", "decpointer", "scoffset", "escaddr", "DescPtr", "Descptr", " descaddress", " descpr", "decptr", "testpointer", "deprect"], "i": ["ui", "o", " multi", "status", "ini", "spin", "id", "I", "p", "ori", "sim", "ai", " li", "li", "any", "info", "ip", "ij", "y", " mi", "ci", "history", "gl", " si", "iu", " I", "si", "v", "ei", "series", "ji", "\u0438", "ski", "us", " ni", " ii", "gu", "n", "remote", "io", "j", "chain", "ind", "ims", "key", "window", "uri", "m", "qi", "ix", "batch", "x", "length", "multi", "ami", "ri", "phi", "di", "oi", "zi", "mi", "ii", "print", "is", "l", " ti", "bi", "xi", "im", "q", "f", "iri", "it", "ic", "client", "err", "pi", " ki", "ex", "fi", "g", "me", "gi", "list", "rel", "hi", "ti", "index", "cli"]}}
{"project": "qemu", "commit_id": "5f1d1fc5928a6f8f63089b3d0768e0dc42c05fbb", "target": 0, "func": "int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)\n\n{\n\n    DeviceState *qdev, **qdevs;\n\n    BusChild *kid;\n\n    int i, num, ret = 0;\n\n\n\n    /* Count qdevs on the bus list */\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        num++;\n\n    }\n\n\n\n    /* Copy out into an array of pointers */\n\n    qdevs = g_malloc(sizeof(qdev) * num);\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        qdevs[num++] = kid->child;\n\n    }\n\n\n\n    /* Sort the array */\n\n    qsort(qdevs, num, sizeof(qdev), compare_reg);\n\n\n\n    /* Hack alert. Give the devices to libfdt in reverse order, we happen\n\n     * to know that will mean they are in forward order in the tree. */\n\n    for (i = num - 1; i >= 0; i--) {\n\n        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);\n\n\n\n        ret = vio_make_devnode(dev, fdt);\n\n\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    free(qdevs);\n\n\n\n    return ret;\n\n}\n", "idx": 26468, "substitutes": {"bus": ["Bus", "board", "queue", "stick", "status", "host", "child", "disk", "id", "bolt", "gate", "sync", "book", "build", "vol", "hub", "ctx", "machine", "ud", "bridge", "boot", "conn", "os", " BUS", "bc", "piece", "us", "config", "ship", "state", "buf", "data", "vc", "bur", "handle", "mount", "lock", "sys", "bb", "device", "length", "dir", "box", "body", "ck", "BUS", "phys", "bs", "kit", "way", "back", "usb", "interface", "serv", "kind", " buses", "controller", "block", "hand", "home", "component", "bo", "proxy", "target", "group", "ack", "list", "route", "util", "root", "line", "port", "self", "loop"], "fdt": ["fdtn", "pedT", "efft", "dldt", "dlt", "fdtx", "fddt", "efftx", "ffT", "fftn", "peddt", "fdT", "effdt", "pedt", "fxtd", "fbtx", "fbtd", "fxt", "dlT", "fdtd", "dltn", "fxtx", "pedtn", "efftd", "fft", "fxdt", "fbdt", "ffdt", "fbt"], "qdev": ["dqdef", "qqdev", "qudec", "sqserv", "qualtr", "qqmem", "sqpro", "sqdev", "qqdec", "qumem", "qualpro", "qqserv", "eqdev", "qdef", "qualdebug", "qdebug", "qudev", "eqdebug", "qmem", "sqdec", "quserv", "qtr", "eqpro", "qpro", " qpro", "qutr", "dqde", "qserv", "qualdev", "qde", " qdef", "sqde", "dqdev", "sqmem", "eqtr", "qupro", "qudebug", " qde", "sqdef", "dqpro", "qdec"], "qdevs": ["qwarnjs", "qdefaulters", " qdivS", "qdevids", "qtdevp", " qdivos", "qDevm", "qDevss", "qevs", "qqdefaulters", "qbufm", "qdevss", "QDevs", "qqdevers", "qevS", "Qdevs", "qdefaultn", "aqdevs", "qcmdn", "qdefaultS", "qcmders", "qtdefaults", "qtdevn", "qDevos", "qtdefaultn", "qdataS", "qbufS", "qevm", " qdevos", "qbufs", "qwarns", "QdevS", "aqwarns", "qtdevs", "QDevm", "qdatan", "QDevjs", "qdevers", "aqwarnjs", "qdefaults", "qqdefaultS", "qDevS", "qdevn", "QDevS", "qdevp", "qcmdp", "qdevicesjs", "qcmdids", "qtdefaultS", " qdevS", "qdatas", "aqdevids", "qtdevS", "qdefaultss", "Qdevm", "qtdefaultp", "qcmdss", "aqwarnids", "qdevos", "qqdefaults", "qdevjs", "qdivs", "qdevicesids", " qdivs", "qDevjs", "qqdefaultss", "aqdevjs", "qqdevs", "Qdevjs", "qwarnids", "qevjs", "qDevs", "qdivos", "qdefaultp", "qdivm", " qdevm", "qqdevS", " qdivm", "qdevS", "qcmdS", "qbufos", "qbufjs", "qcmdjs", "qdevm", "qdivS", "qcmds", "qdatap", "qqdevss", "qdevicess", "qDevers"], "kid": ["hd", "king", "kids", "kk", "ki", "ih", "ik", "kn", "ka", "ko", "tk", "ke", "kt", "k", "id", "sky", "hs", "mk", "ck", "wk", "ks", "tek", "ket", "kok", "kh", "pid", "kr", "kj", " kh", "ctx", "kb", "sk", "kit", "wcs", "sid", "ker", "kw", "kind", "kg", "kl", "Kid", "jp", "ijk"], "i": ["ji", "it", "ic", "my", "x", "ui", " j", "multi", "ki", "\u0438", "o", " x", "pi", " ni", " ii", "id", "ini", " iter", "index", "ri", "fi", "gu", "me", "gi", "I", "n", "phi", " bi", "di", "zi", "sim", "j", "ai", "mi", "li", "ii", "iq", "hi", "is", "ti", "ind", "l", "info", " ti", "bi", "y", " mi", "ims", "ish", "ci", "ij", "mc", "e", " si", "iu", "ni", " m", "si", "xi", "im", "m", "qi", "ix"], "num": ["note", "NUM", "dim", "na", "prim", "perm", "cal", "gen", "multi", "nm", "nn", "nom", "len", "temp", "col", "nam", "nb", "us", "mult", "id", "hum", "common", "ul", "mun", "um", "mon", "Num", "n", "p", "count", "cum", "add", "mat", "msg", "node", "pn", "rem", "mod", "set", "nu", "coord", "tim", "uni", "total", "np", "pl", "pos", "doc", "desc", "ind", "nt", "fun", "mn", "snap", "con", "draw", "net", "en", "number", "ret", "un", "off", "max", "sum", "index", "no", "final", "alph", "m"], "dev": ["sd", "device", "prop", "hd", "ad", "tech", "cam", "ev", "conn", "att", "d", "adv", "w", "def", "pert", "wd", "var", "cho", "gu", "md", "cmd", "det", "DEV", "ve", "disc", "rem", "av", "test", "de", "dd", "des", "dem", "Dev", "pro", "fo", "serv", "val", "v"]}}
{"project": "qemu", "commit_id": "4656e1f01289cc3aa20986deb6a407165826abe5", "target": 1, "func": "void ppc_tlb_invalidate_all(CPUPPCState *env)\n\n{\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_REAL:\n\n        cpu_abort(env, \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_MPC8xx:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        tlb_flush(env, 1);\n\n        break;\n\n    case POWERPC_MMU_BOOKE206:\n\n        booke206_flush_tlb(env, -1, 0);\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_620:\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_2_06:\n\n\n#endif /* defined(TARGET_PPC64) */\n\n        tlb_flush(env, 1);\n\n        break;\n\n    default:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Unknown MMU model\\n\");\n\n        break;\n\n    }\n\n}", "idx": 26472, "substitutes": {"env": ["vm", "here", "block", "context", "ov", "engine", "cur", "den", "server", "obj", "ev", "conn", "code", "viron", "vp", "entry", "erd", "eh", "er", "dev", "vv", "ew", "ec", "act", "ah", "cmd", "ten", "ve", "timer", "dt", "org", "msg", "gov", "forge", "gear", "buf", "usr", "ctx", "vs", "environment", "shell", "chain", "init", "req", "nv", "desc", "info", "addr", "worker", "window", "e", "iter", "serv", "en", "net", "rod", "era", "exc", "eng", "end", "proc", "v", "outer", "enter", "cv", "uv", "hw"]}}
{"project": "qemu", "commit_id": "5d7fd045cafeac1831c1999cb9e1251b7906c6b2", "target": 0, "func": "uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)\n\n{\n\n    env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);\n\n\n\n    return set_cc_nz_f32(env->fregs[f1].l.upper);\n\n}\n", "idx": 26480, "substitutes": {"env": ["ee", "here", "context", "ov", "engine", "esc", "ef", "sb", "server", "ner", "obj", "ev", "network", "Environment", "conn", "code", "config", "w", "erd", "er", "event", "dev", "buffer", "mem", "ew", "ec", "vv", "ah", "db", "oe", "nc", "state", "cb", "sw", "buf", "open", "et", "ctx", "te", "pe", "environment", "walker", "shell", "order", "desc", "neck", "worker", "window", "con", "e", "EN", "en", "hl", "era", "h", "end", "vt", "manager", "v", "init", "cv", "conf"], "f1": ["formpre", "ft9", "uf1", "forpre", "uf01", "form001", " f9", "F001", "ft2", "form2", "for1", "form1", "F2", "f01", "for001", "f9", "F1", "fpre", "v1", "for2", "ft01", " f0", "v0", " f01", "Fpre", "f001", "v01", "F01", "ft1", "uf9", "uf2", "v2", "f0", "F0"], "f2": ["uf1", "sf2", "F02", "float2", "float02", "uftwo", "v02", "F2", "sfTwo", "floatTwo", "F1", "uf02", "f02", "Ftwo", "sf02", "fTwo", "vTwo", " ftwo", "ftwo", "uf2", "v2", " f02"]}}
{"project": "FFmpeg", "commit_id": "2f9ca64556cba9a7edcca9a1c55923a60022937d", "target": 0, "func": "static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n\n                    AVDictionary *opts, AVDictionary *opts2, int *is_http)\n\n{\n\n    HLSContext *c = s->priv_data;\n\n    AVDictionary *tmp = NULL;\n\n    const char *proto_name = NULL;\n\n    int ret;\n\n\n\n    av_dict_copy(&tmp, opts, 0);\n\n    av_dict_copy(&tmp, opts2, 0);\n\n\n\n    if (av_strstart(url, \"crypto\", NULL)) {\n\n        if (url[6] == '+' || url[6] == ':')\n\n            proto_name = avio_find_protocol_name(url + 7);\n\n    }\n\n\n\n    if (!proto_name)\n\n        proto_name = avio_find_protocol_name(url);\n\n\n\n    if (!proto_name)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    // only http(s) & file are allowed\n\n    if (av_strstart(proto_name, \"file\", NULL)) {\n\n        if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"\n\n                \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",\n\n                url);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else if (av_strstart(proto_name, \"http\", NULL)) {\n\n        ;\n\n    } else\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n\n        ;\n\n    else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n\n        ;\n\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (c->http_persistent && *pb && av_strstart(proto_name, \"http\", NULL)) {\n\n        ret = open_url_keepalive(c->ctx, pb, url);\n\n        if (ret == AVERROR_EXIT) {\n\n            return ret;\n\n        } else if (ret < 0) {\n\n            if (ret != AVERROR_EOF)\n\n                av_log(s, AV_LOG_WARNING,\n\n                    \"keepalive request failed for '%s', retrying with new connection: %s\\n\",\n\n                    url, av_err2str(ret));\n\n            ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n\n        }\n\n    } else {\n\n        ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n\n    }\n\n    if (ret >= 0) {\n\n        // update cookies on http response with setcookies.\n\n        char *new_cookies = NULL;\n\n\n\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n\n\n\n        if (new_cookies) {\n\n            av_free(c->cookies);\n\n            c->cookies = new_cookies;\n\n        }\n\n\n\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n\n    }\n\n\n\n    av_dict_free(&tmp);\n\n\n\n    if (is_http)\n\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n\n\n\n    return ret;\n\n}\n", "idx": 26481, "substitutes": {"s": ["f", "sys", "sa", "sb", "os", "fs", "rs", "tc", "ses", "ds", "hs", "r", "spec", "n", "p", "sc", "cs", "sts", "set", "j", "ctx", "S", "session", "js", "ss", "settings", "a", "ssl", "b", "l", "ns", "ts", "ps", "es", "sp", "e", "gs", "sv", "h", "t", "ls", "m", "v", "sq", "socket", "conf"], "pb": ["pm", "sb", "typ", "uf", "pub", "mb", "mp", "pc", "tf", "vp", "tk", "def", "pp", "_", "tc", "func", "cp", "p", "cb", "ctx", "ht", "PB", "pl", "np", "bs", "dp", "wb", "pa", "wp", "ub", "pro", "tp", "bp", "sp", "rb", "fp", "pkg", "lp", "jp", "lb", "pt"], "url": ["ll", "rl", "norm", "host", "id", "buffer", "path", "r", "use", "email", "raw", "location", "dl", "page", "loc", "base", "http", "gl", "il", "obj", "item", "term", "xml", "ur", "sl", "db", "git", "el", "remote", "ob", "msg", "fail", "data", "window", "handle", "uri", "format", "mount", "job", "full", "impl", "nl", "fl", "ul", "get", "www", "browser", "file", "l", "text", "ls", "all", "str", "ssl", "f", "external", "web", "server", "URL", "github", "lr", "err", "null", "result", "date", "row", "Url", "list", "mail", "cert", "org", "rel", "util", "html", "https", "load", "json", "hl", "un", "name", "res"], "opts": ["ropts", "verms", "options", "protions", "opds", "opTS", "vertions", "ropcs", " opds", "verts", "copcs", " opTS", "vercs", "copTS", "optTS", "copts", "copds", "opms", "procs", "proms", "opcs", "optcs", "ropms", "optds", "prots", "roptions", " opcs", "optts"], "opts2": ["prots1", "opt2", "prot1", "opdsTwo", "optsTwo", "optTwo", "protsTwo", "prots2", "props4", "props3", "props02", "opts3", "opps2", "opTS2", "opts1", "opTS3", "opps4", "opts4", "oputsTwo", "prot2", "opds1", "opps3", "prots4", "opt1", "opds2", "oputs2", "opTS4", "opts02", "oputs1", "protTwo", "opTS02", "prots3", "prots02", "opps02", "props2"], "is_http": ["iswebhttps", "is_https", "iswebhtml", " is_html", "is_HTTP", "iswebHTTP", "is_html", " is_https", "iswebhttp", " is_HTTP"], "c": ["f", "cl", "cur", "cf", "cam", "ce", "cu", "conv", "ca", "comm", "bc", "pc", "w", "tc", "abc", "dc", "cont", "ec", "g", "cp", "p", "sc", "cs", "cb", "cm", "ctx", "enc", "com", "co", "b", "l", "ct", "ac", "mc", "con", "fc", "coll", "gc", "h", "t", "cc", "C", "v", "lc", "m", "cv", "conf"], "tmp": ["tar", "opt", "cmp", "tm", "out", "obj", "temp", "mb", "mp", "tf", "emp", "tt", "mem", "mk", "empty", "metadata", "cp", "cache", "tab", "msg", "cb", "buf", "ctx", "np", "td", "nt", "txt", "pro", "sp", "aaa", "rb", "aux", "buff", "pkg", "etc", "table", "vt", "t", "proc", "cv", "this"], "proto_name": ["protoJid", "protoNamename", "propo2name", "proto_number", "proTO_num", "profrom_parent", "proto_str", "proto_parent", "protoetyname", "proto2names", "proto_default", "proportamelink", "proco_NAME", "proco2ame", "proportamename", "profixed_name", "propo_prefix", "proto_type", "proto_field", "proto_key", "protoJname", "proto___str", "probe_name", "proocol_type", "profromNamenumber", "prototname", "profromNameparent", "proto0NAME", "profromNamestr", "proto___parent", "proportamenames", "proto0ame", "protoetyfield", "protonamecomment", "protoamename", "profixed_NAME", "protoNameparent", "profrom_str", "proto2ame", "propo2prefix", "proto_ame", "protoamenames", "proto_comment", "proocol_comment", "propo_parent", "proto_path", "profixed_call", "proto__Name", "proport_name", "proto__prefix", "proco2NAME", "proco_ame", "proto_search", "protoNamefield", "probe_path", "proto2parent", "propo2names", "proco_Name", "proto__key", "protoamelink", "protonamenumber", "proto_size", "proto2name", "protonamestr", "proTO_prefix", "profrom_name", "proto__name", "protoNamestr", "proocol_key", "protonameparent", "proto___Name", "proport_link", "propo2parent", "proto2Name", "proto_link", "proto2NAME", "proto_no", "prototdefault", "proco_name", "proto0name", "protonameName", "proto_call", "propo_name", "proto_cache", "probe_word", "proco2name", "proTO_Name", "proto_id", "profrom_number", "proport_names", "proto___number", "proto___name", "protonamedefault", "proocol_default", "probe_cache", "profromNamename", "proto_NAME", "protoNameame", "protoetyame", "proto_word", "protoJsearch", "proto_info", "proto_Name", "proTO_name", "proco2Name", "proto___comment", "proocol_Name", "prototName", "proto2prefix", "protonamename", "proto0Name", "protoNamenumber", "prototcomment", "proto_names", "proto_prefix", "proto_num", "propo_names", "proocol_name"], "ret": ["alt", "out", "err", "reset", "ll", "RET", "ref", "re", "rm", "len", "try", "att", "gt", "result", "get", "r", "mel", "resp", "rem", "print", "rt", "nt", "rets", " RET", "ft", " Ret", "val", "flag", "mt", "Ret", "il", "tr", "t", "elt", "Return", "res"]}}
{"project": "qemu", "commit_id": "1dbd2fd9cbf29c74131e439ce80fb2efde56ee32", "target": 0, "func": "static int qemu_rdma_dest_init(RDMAContext *rdma, Error **errp)\n\n{\n\n    int ret = -EINVAL, idx;\n\n    struct rdma_cm_id *listen_id;\n\n    char ip[40] = \"unknown\";\n\n    struct rdma_addrinfo *res;\n\n    char port_str[16];\n\n\n\n    for (idx = 0; idx < RDMA_WRID_MAX; idx++) {\n\n        rdma->wr_data[idx].control_len = 0;\n\n        rdma->wr_data[idx].control_curr = NULL;\n\n    }\n\n\n\n    if (rdma->host == NULL) {\n\n        ERROR(errp, \"RDMA host is not set!\");\n\n        rdma->error_state = -EINVAL;\n\n        return -1;\n\n    }\n\n    /* create CM channel */\n\n    rdma->channel = rdma_create_event_channel();\n\n    if (!rdma->channel) {\n\n        ERROR(errp, \"could not create rdma event channel\");\n\n        rdma->error_state = -EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    /* create CM id */\n\n    ret = rdma_create_id(rdma->channel, &listen_id, NULL, RDMA_PS_TCP);\n\n    if (ret) {\n\n        ERROR(errp, \"could not create cm_id!\");\n\n        goto err_dest_init_create_listen_id;\n\n    }\n\n\n\n    snprintf(port_str, 16, \"%d\", rdma->port);\n\n    port_str[15] = '\\0';\n\n\n\n    if (rdma->host && strcmp(\"\", rdma->host)) {\n\n        struct rdma_addrinfo *e;\n\n\n\n        ret = rdma_getaddrinfo(rdma->host, port_str, NULL, &res);\n\n        if (ret < 0) {\n\n            ERROR(errp, \"could not rdma_getaddrinfo address %s\", rdma->host);\n\n            goto err_dest_init_bind_addr;\n\n        }\n\n\n\n        for (e = res; e != NULL; e = e->ai_next) {\n\n            inet_ntop(e->ai_family,\n\n                &((struct sockaddr_in *) e->ai_dst_addr)->sin_addr, ip, sizeof ip);\n\n            trace_qemu_rdma_dest_init_trying(rdma->host, ip);\n\n            ret = rdma_bind_addr(listen_id, e->ai_dst_addr);\n\n            if (!ret) {\n\n                if (e->ai_family == AF_INET6) {\n\n                    ret = qemu_rdma_broken_ipv6_kernel(errp, listen_id->verbs);\n\n                    if (ret) {\n\n                        continue;\n\n                    }\n\n                }\n\n                    \n\n                goto listen;\n\n            }\n\n        }\n\n\n\n        ERROR(errp, \"Error: could not rdma_bind_addr!\");\n\n        goto err_dest_init_bind_addr;\n\n    } else {\n\n        ERROR(errp, \"migration host and port not specified!\");\n\n        ret = -EINVAL;\n\n        goto err_dest_init_bind_addr;\n\n    }\n\nlisten:\n\n\n\n    rdma->listen_id = listen_id;\n\n    qemu_rdma_dump_gid(\"dest_init\", listen_id);\n\n    return 0;\n\n\n\nerr_dest_init_bind_addr:\n\n    rdma_destroy_id(listen_id);\n\nerr_dest_init_create_listen_id:\n\n    rdma_destroy_event_channel(rdma->channel);\n\n    rdma->channel = NULL;\n\n    rdma->error_state = ret;\n\n    return ret;\n\n\n\n}\n", "idx": 26485, "substitutes": {"rdma": ["redman", "ddna", "rdmac", "rendgo", "ldmac", "rdm", "ardm", "redMA", "rendsche", "rodna", "rwmc", "ddmo", "ldna", "rownman", "ardbase", "ddma", "rodam", "rodwa", "drMA", "rodman", "redme", "redmag", "rdfa", "nderMA", "rustmas", "redm", "redmi", "rendna", "rrMA", "ddmon", "rdrule", "rownm", "rdmag", "rtmedia", "ddmac", "ndersche", "rdwa", "redlia", "rdman", "ldmc", "rdme", "rodma", "rustmm", "ruma", "ridka", "rdbase", "redgo", "ddfa", "ridmm", "rdka", "rodMA", "rownMA", "ndermar", "ldma", "rugo", "rdmar", "drmon", "rrman", "rdcal", "ldcal", "ridmo", "rodmi", "ridna", "drmedia", "rodm", "rdmon", "rodmedia", "rendmag", "rwwa", "ridcal", "rnrule", "nderna", "rdpa", "rodpa", "ridm", "ddrule", "ldmo", "rustma", "rnfa", "rdmo", "rtme", "ridwa", "rrfa", "radman", "ndercal", "rtma", "rodmc", "ridmac", "rendma", "rodka", "redmedia", "rdmas", "drlia", "drsche", "drbase", "radpa", "rogmas", "rdna", "rumag", "drma", "rdmi", "ridbase", "rrmo", "nderm", "rodmm", "rodmas", "ldsche", "rdmm", "rnma", "nderma", "ridme", "rdsta", "rrmac", "drman", "rdmedia", "drmu", "ridman", "rdam", "rogma", "ridmedia", "drrule", "radma", "rnmon", "drm", "redma", "rwmm", "rustam", "redmar", "rodlia", "ridma", "rdlia", "ardma", "ridmc", "ridsche", "drfa", "rownfa", "radmu", "ridMA", "rdmu", "rodmac", "drpa", "ardsche", "rodmu", "rownma", "rwma", "redka", "rdmc", "redsta", "rusta", "rendmc", "rdsche", "rdgo", "rogmm", "rodmo", "rdMA", "rendsta", "rtsta", "rownmar", "ridmi", "rogam", "rrma", "ridsta"], "errp": ["rerphp", "erpress", "rrr", "errps", "confpa", "ererwp", "arrpost", " errP", "err", "rerp", "rerr", "errpress", "rrpy", "rerps", "yrp", "yrphp", "erps", "confpress", "ererphp", "errP", "eorp", "sprphp", "sprv", "rerpy", "errr", "errpa", "sprp", "arrP", "lrp", "errpy", "rerwp", " erpress", "rrp", "arrp", "errwp", "erpost", "errv", "erp", "rrps", "eorP", "errphp", " errpress", "lrpress", "errpost", "ererp", "eorpa", "yrpa", "erpy", "lrphp", " erp", "confp", "ererv", "erP", "rerv", " erP", "yrpress", "eorpost", "confphp", "erpa", "arrpa", "sprwp", "lrpa"], "idx": ["indx", "indX", "IDxes", "Idxs", "indexxs", " idnz", "idst", "indux", "Idux", "dex", "adx", "dxs", "IDex", "idnz", "idxes", "likex", "adxs", "dx", "likeX", "Idix", " idst", "indexk", "indk", " idex", "idux", " idxs", " idX", " idix", "idex", "adst", "indxs", "idix", "indix", "indexux", "idxs", "indexx", " idux", "IDxs", " idxes", "dxes", "indnz", "adix", "adex", "adux", "Idk", "idk", "indexX", "IDx", "Idx", "IdX", "indst", "index", "likeix", "likenz", "idX"], "listen_id": ["listen__name", "listen___name", "listen_pid", "listEN_name", "listen__ID", "listen_ident", "listen__pid", "listEN_id", "listener_id", "listen__ident", "listen__id", "listEN_ID", "listen_ID", "listener_ident", "listen_name", "listen__info", "listener_info", "listen_info", "listen___data", "listener_name", "listener_data", "listEN_pid", "listen_data", "listen___id", "listen___info"], "ip": ["block", " sip", "ic", "ep", "mac", "i", "ock", "it", "hop", "pipe", "rip", "arp", "address", "inet", "ix", "op", "host", "IP", "pp", "ex", "id", "ipp", "cp", "p", "tip", "alias", "isp", "et", "hip", " IP", "ap", "np", "up", "a", "php", "port", "addr", "wp", "link", "imp", "tif", "tp", "mask", "sp", "cap", "iter", "fp", "pkg", "zip", "name", "ips"], "res": ["here", "out", "red", "rest", "err", "reset", "pas", "ref", "obj", "re", "conn", "status", "rs", "rc", "result", "rev", "er", "reg", "results", "details", "rx", "RES", "r", "resource", "ack", "remote", "gr", "resp", "msg", "rek", "rem", "resources", "rep", "raw", "rt", "response", "rez", "req", "info", "ps", "expr", "vals", "progress", "Res", "ret", "pres", "ress"], "port_str": ["ports_Str", "port_len", " port_arr", "portpyStr", "port2br", "port_br", " transport_STR", "port_arr", "ports_str", " port2str", "port2data", "port2arr", "port_data", "portpylen", " transport_str", " port_br", " port2br", "ports_len", "port_list", " port_data", "port_STR", "port_sl", " port2arr", "portpystr", "port_Str", "ports_sl", " port_fr", "port_fr", " port2data", "portpysl", " transport_data", " transport_list", "port2str", "port2fr"], "e": ["f", "ep", "x", "ea", "eu", "ef", "o", "ce", "ev", "re", "eeee", "entity", "se", "ie", "d", "ent", "w", "c", "eh", "ex", "er", "ec", "m", "g", "r", "ed", "me", "el", "ge", "oe", "p", "ve", "le", "et", "te", "pe", "eg", "ne", "eb", "E", "a", "ele", "element", "ffe", "de", "es", "xe", "en", "ue", "h", "elt", "eng", "eur", "ee", "ae", "ei"]}}
{"project": "qemu", "commit_id": "2d26512b45b5236fa521c4492608fe9fb5bedf46", "target": 0, "func": "int cksum(struct mbuf *m, int len)\n\n{\n\n\tregister uint16_t *w;\n\n\tregister int sum = 0;\n\n\tregister int mlen = 0;\n\n\tint byte_swapped = 0;\n\n\n\n\tunion {\n\n\t\tuint8_t  c[2];\n\n\t\tuint16_t s;\n\n\t} s_util;\n\n\tunion {\n\n\t\tuint16_t s[2];\n\n\t\tuint32_t l;\n\n\t} l_util;\n\n\n\n\tif (m->m_len == 0)\n\n\t   goto cont;\n\n\tw = mtod(m, uint16_t *);\n\n\n\n\tmlen = m->m_len;\n\n\n\n\tif (len < mlen)\n\n\t   mlen = len;\n\n#ifdef DEBUG\n\n\tlen -= mlen;\n\n#endif\n\n\t/*\n\n\t * Force to even boundary.\n\n\t */\n\n\tif ((1 & (long) w) && (mlen > 0)) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\ts_util.c[0] = *(uint8_t *)w;\n\n\t\tw = (uint16_t *)((int8_t *)w + 1);\n\n\t\tmlen--;\n\n\t\tbyte_swapped = 1;\n\n\t}\n\n\t/*\n\n\t * Unroll the loop to make overhead from\n\n\t * branches &c small.\n\n\t */\n\n\twhile ((mlen -= 32) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tsum += w[4]; sum += w[5]; sum += w[6]; sum += w[7];\n\n\t\tsum += w[8]; sum += w[9]; sum += w[10]; sum += w[11];\n\n\t\tsum += w[12]; sum += w[13]; sum += w[14]; sum += w[15];\n\n\t\tw += 16;\n\n\t}\n\n\tmlen += 32;\n\n\twhile ((mlen -= 8) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tw += 4;\n\n\t}\n\n\tmlen += 8;\n\n\tif (mlen == 0 && byte_swapped == 0)\n\n\t   goto cont;\n\n\tREDUCE;\n\n\twhile ((mlen -= 2) >= 0) {\n\n\t\tsum += *w++;\n\n\t}\n\n\n\n\tif (byte_swapped) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\tif (mlen == -1) {\n\n\t\t\ts_util.c[1] = *(uint8_t *)w;\n\n\t\t\tsum += s_util.s;\n\n\t\t\tmlen = 0;\n\n\t\t} else\n\n\n\n\t\t   mlen = -1;\n\n\t} else if (mlen == -1)\n\n\t   s_util.c[0] = *(uint8_t *)w;\n\n\n\ncont:\n\n#ifdef DEBUG\n\n\tif (len) {\n\n\t\tDEBUG_ERROR((dfd, \"cksum: out of data\\n\"));\n\n\t\tDEBUG_ERROR((dfd, \" len = %d\\n\", len));\n\n\t}\n\n#endif\n\n\tif (mlen == -1) {\n\n\t\t/* The last mbuf has odd # of bytes. Follow the\n\n\t\t standard (the odd byte may be shifted left by 8 bits\n\n\t\t\t   or not as determined by endian-ness of the machine) */\n\n\t\ts_util.c[1] = 0;\n\n\t\tsum += s_util.s;\n\n\t}\n\n\tREDUCE;\n\n\treturn (~sum & 0xffff);\n\n}\n", "idx": 26489, "substitutes": {"m": ["f", "vm", "ms", "i", "x", "mac", "perm", "o", "man", "d", "mem", "mm", "bm", "g", "r", "md", "me", "n", "p", "M", "mat", "dm", "msg", "mo", "cm", "mod", "j", "module", "imm", "mi", "a", "am", "b", "l", "gm", "mr", "y", "sm", "z", "mc", "mt", "h", "t", "v", "em", "this"], "len": ["cl", "length", "cmp", "lit", "Length", "ll", "al", "min", "L", "ln", "nl", "mem", "lt", "sl", "seq", "n", "el", "p", "Len", "mat", "msg", "le", "lon", "pos", "pl", "li", "l", "size", "nt", "lan", "loc", "lib", "lim", "z", "mn", "lang", "num", "val", "en", "il", "lp", "h", "t", "ls", "elt", "ml", "kl", "lc", " l"], "w": ["rew", "ui", "fw", "wh", "d", "word", "mem", "var", "wk", "wl", "r", "p", "new", "words", "raw", "weight", "wb", "y", "wt", "z", "wal", "writer", "h", "v", "temp", "term", "iw", "n", "wat", "wcs", "window", "win", "hw", "x", "cam", "wd", "sw", "go", "wa", "a", "way", "b", "l", "weights", "rw", "kw", "q", "all", "sum", "wx", "aw", "f", "W", "out", "power", "man", "wm", "ex", "ew", "g", "wr", "cache", "we", "nw", "up", "wp", "wi", "tw", "e", "self", "t", "end"], "c": ["f", "ic", "ch", "ca", "cu", "pc", "d", "rc", "dc", "cont", "ec", "g", "r", "n", "p", "count", "cache", "cp", "sc", "cn", "cs", "cm", "co", "a", "b", "l", "xc", "ct", "oc", "unc", "z", "C", "u", "gc", "h", "t", "cc", "v", "lc"], "s_util": ["s2il", "sptutils", "l2utils", "l2util", "g_universal", " s_ul", "s_utils", "sptuniversal", "l_il", "l2il", "s___util", "s_ul", "sptil", "s_universal", "s___urg", " s_pkg", "g_il", "s___il", "s___pkg", "s_urg", "s2urg", " s_il", "s2util", "l_utils", "s_pkg", "s_il", "s___utils", " s_utils", "l2urg", "g_utils", "g_util", "sptutil", "s2utils", "l_urg"], "s": ["sd", "ms", "i", "x", "sa", "os", "pc", "d", "rs", "g", "r", "n", "p", "sc", "cs", "ss", "xs", "a", "is", "b", "l", "ts", "ns", "ps", "z", "es", "gs", "sv", "si", "t", "ls", "v"], "l_util": ["s_alloc", "l_alloc", "l__alloc", "l_il", "s_utils", "lmsutils", "l__il", "l__util", "l_utils", "lmsalloc", "s_il", "l__utils", "lmsil", "lmsutil"], "mlen": ["llenn", "mnenum", "mlin", "fmlaren", "milize", "mxaren", "mnend", " mllen", "mlenn", "melense", "mmoen", "milenum", "ullen", "llad", "llon", "mlength", "mrena", "mlist", "mxen", "mnin", "mnain", "millena", "millaren", "llan", "malense", "mraren", "mlatten", "mmin", " mlatten", "mloen", "mlenum", "mmeng", " mlist", "milon", "mxain", "mnang", "mnax", "mnEN", "MLatten", "mnen", "mlain", "ulon", "ulan", " mlEN", "milen", "fmlen", "mlun", "fmlain", "mnade", "mleng", "fmlena", "mla", "mlize", "mmun", "mmang", "mmate", "mlense", "mnenge", "millatten", "mnense", "mnist", "mmenge", "mman", "malain", "mneng", "mnun", "mlad", "malen", "malenum", "mllen", "mlax", "mma", "malang", "mnan", "fmlatten", "mnoen", "fmlenn", "mlon", "millen", "uloen", "mnon", "mlate", "malize", "MLen", "mmend", "melen", "mlade", "mmen", "lllen", "MLa", "mmain", "malan", "mratten", "melatten", "mnad", "mlan", "milain", "milade", "mnate", "mna", "mlenge", "malin", "maleng", "mlena", "milan", "mnatten", "llain", "MLeng", "llize", "malenge", "mlend", "mlEN", "MLan", "mlang", "mlaren", "mren", "ulen", "llength", "malate", "llaren", "ulend", "ulength", " mlan", "malon", "MLEN", "mmax", "malun", "malatten", "mxenn", "ulade", "malad", "malax", "MList", "llen", " mlength"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,\n\n                         int is_write, target_phys_addr_t access_len)\n\n{\n\n    if (buffer != bounce.buffer) {\n\n        if (is_write) {\n\n            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);\n\n            while (access_len) {\n\n                unsigned l;\n\n                l = TARGET_PAGE_SIZE;\n\n                if (l > access_len)\n\n                    l = access_len;\n\n                invalidate_and_set_dirty(addr1, l);\n\n                addr1 += l;\n\n                access_len -= l;\n\n            }\n\n        }\n\n        if (xen_enabled()) {\n\n            xen_invalidate_map_cache_entry(buffer);\n\n        }\n\n        return;\n\n    }\n\n    if (is_write) {\n\n        address_space_write(as, bounce.addr, bounce.buffer, access_len);\n\n    }\n\n    qemu_vfree(bounce.buffer);\n\n    bounce.buffer = NULL;\n\n    cpu_notify_map_clients();\n\n}\n", "idx": 26496, "substitutes": {"as": ["ras", "pack", "ms", "sa", "nas", "asse", "sis", "ay", "os", "each", "with", "oss", "rs", "us", "at", "aos", "cast", "las", "ar", "cs", "ias", "an", "ars", "ast", "bs", "a", "ach", "ak", "am", "eas", "ag", "is", "ns", "aus", "es", "As", "ab", "ass", "ams", "ask", "AS"], "buffer": ["address", "queue", "map", "command", "pool", "write", "raw", "size", "page", "document", "base", "vector", "ptr", "table", "padding", "byte", "bridge", "value", "error", "header", "db", "send", "dirty", "buf", "tty", "function", "binary", "shape", "data", "window", "handle", "iter", "Buffer", "buff", "offset", "callback", "program", "device", "type", "context", "batch", "engine", "length", "pad", "read", "screen", "comment", "alias", "memory", "b", "template", "addr", "interface", "limit", "package", "block", "stream", "server", "append", "null", "result", "profile", "zero", "target", "row", "empty", "phrase", "cache", "message", "sequence", "port", "position", "index"], "len": ["type", "length", "ld", "alt", "ll", "ref", "bl", "ln", "lt", "fl", "mem", "seq", "ail", "count", "Len", "pl", "size", "lan", "loc", "addr", "lib", "la", "link", "num", "win", "en", "ls", "elt"], "is_write": [" is_only", "is__write", "is_change", "isfulwait", "isfulwrite", "isfulchange", " is_delete", "is_wait", "is__writ", "is_read", "is__only", " is_read", "isfulread", "isEnwrite", "isEnonly", "isEndelete", "is_delete", " is_change", " is_writ", "is__read", " is_wait", "isEnread", "is_only", "is_writ"], "access_len": ["accessmingcompl", " access_ld", "access_ln", "accesstlang", "accessitylen", "accessLengthln", "accessetylen", "access_lon", " access_addr", " access_gen", "priLengthcompl", " access_lang", "access_str", "access_lang", "access_comp", "access___Len", "access2lang", "accessetyLen", " access2lang", " access_max", "priLengthln", " access_lon", "access___str", "accessetycomp", " access2lon", " access_loc", "access2gen", "access_ld", "access_req", "access67gen", "accessityln", "access67lon", "access_addr", "access___len", "pri_ln", "accessLengthreq", "accessitycompl", "access2lon", "access_gen", "access67lang", "access_loc", "accessmingln", " access_comp", "accessLengthcompl", " access2len", "access_compl", "accessminglen", "accesstlon", "access___max", "accessityreq", " access_priv", "access2len", "accessmingreq", "priLengthlen", "accesstgen", "access_Len", " access2gen", "access___ld", "pri_len", "access_priv", "pri_req", "accessetyaddr", "access67len", " access_Len", "priLengthreq", "access_max", " access_str", "accesstlen", "pri_compl", "accessLengthlen"], "l": ["it", "i", "ld", "length", "lit", "lo", "ll", "al", "rl", "lv", "tl", "L", "d", "v", "ln", "nl", "fl", "lt", "sl", "g", "list", "n", "el", "p", "lf", "kl", "s", "le", "lin", "j", "dL", "level", "els", "pl", "li", "line", "dl", "size", "lan", "la", " L", "z", "hl", "il", "lp", "h", "ls", "ly", "ml", "m", "lb", "lc", "t"]}}
{"project": "FFmpeg", "commit_id": "44d854a518f97cb65090420b0b9f55611a0ea932", "target": 1, "func": "static av_cold int atrac3_decode_init(AVCodecContext *avctx)\n\n{\n\n    int i, ret;\n\n    int version, delay, samples_per_frame, frame_factor;\n\n    const uint8_t *edata_ptr = avctx->extradata;\n\n    ATRAC3Context *q = avctx->priv_data;\n\n\n\n    if (avctx->channels <= 0 || avctx->channels > 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Channel configuration error!\\n\");\n\n\n    }\n\n\n\n    /* Take care of the codec-specific extradata. */\n\n    if (avctx->extradata_size == 14) {\n\n        /* Parse the extradata, WAV format */\n\n        av_log(avctx, AV_LOG_DEBUG, \"[0-1] %d\\n\",\n\n               bytestream_get_le16(&edata_ptr));  // Unknown value always 1\n\n        edata_ptr += 4;                             // samples per channel\n\n        q->coding_mode = bytestream_get_le16(&edata_ptr);\n\n        av_log(avctx, AV_LOG_DEBUG,\"[8-9] %d\\n\",\n\n               bytestream_get_le16(&edata_ptr));  //Dupe of coding mode\n\n        frame_factor = bytestream_get_le16(&edata_ptr);  // Unknown always 1\n\n        av_log(avctx, AV_LOG_DEBUG,\"[12-13] %d\\n\",\n\n               bytestream_get_le16(&edata_ptr));  // Unknown always 0\n\n\n\n        /* setup */\n\n        samples_per_frame    = SAMPLES_PER_FRAME * avctx->channels;\n\n        version              = 4;\n\n        delay                = 0x88E;\n\n        q->coding_mode       = q->coding_mode ? JOINT_STEREO : STEREO;\n\n        q->scrambled_stream  = 0;\n\n\n\n        if (avctx->block_align !=  96 * avctx->channels * frame_factor &&\n\n            avctx->block_align != 152 * avctx->channels * frame_factor &&\n\n            avctx->block_align != 192 * avctx->channels * frame_factor) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unknown frame/channel/frame_factor \"\n\n                   \"configuration %d/%d/%d\\n\", avctx->block_align,\n\n                   avctx->channels, frame_factor);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else if (avctx->extradata_size == 10) {\n\n        /* Parse the extradata, RM format. */\n\n        version                = bytestream_get_be32(&edata_ptr);\n\n        samples_per_frame      = bytestream_get_be16(&edata_ptr);\n\n        delay                  = bytestream_get_be16(&edata_ptr);\n\n        q->coding_mode         = bytestream_get_be16(&edata_ptr);\n\n        q->scrambled_stream    = 1;\n\n\n\n    } else {\n\n        av_log(NULL, AV_LOG_ERROR, \"Unknown extradata size %d.\\n\",\n\n               avctx->extradata_size);\n\n\n    }\n\n\n\n    /* Check the extradata */\n\n\n\n    if (version != 4) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Version %d != 4.\\n\", version);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (samples_per_frame != SAMPLES_PER_FRAME &&\n\n        samples_per_frame != SAMPLES_PER_FRAME * 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown amount of samples per frame %d.\\n\",\n\n               samples_per_frame);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (delay != 0x88E) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown amount of delay %x != 0x88E.\\n\",\n\n               delay);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (q->coding_mode == STEREO)\n\n        av_log(avctx, AV_LOG_DEBUG, \"Normal stereo detected.\\n\");\n\n    else if (q->coding_mode == JOINT_STEREO)\n\n        av_log(avctx, AV_LOG_DEBUG, \"Joint stereo detected.\\n\");\n\n    else {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown channel coding mode %x!\\n\",\n\n               q->coding_mode);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (avctx->block_align >= UINT_MAX / 2)\n\n\n\n\n    q->decoded_bytes_buffer = av_mallocz(FFALIGN(avctx->block_align, 4) +\n\n                                         FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (q->decoded_bytes_buffer == NULL)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n\n\n\n    /* initialize the MDCT transform */\n\n    if ((ret = ff_mdct_init(&q->mdct_ctx, 9, 1, 1.0 / 32768)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");\n\n        av_freep(&q->decoded_bytes_buffer);\n\n        return ret;\n\n    }\n\n\n\n    /* init the joint-stereo decoding data */\n\n    q->weighting_delay[0] = 0;\n\n    q->weighting_delay[1] = 7;\n\n    q->weighting_delay[2] = 0;\n\n    q->weighting_delay[3] = 7;\n\n    q->weighting_delay[4] = 0;\n\n    q->weighting_delay[5] = 7;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        q->matrix_coeff_index_prev[i] = 3;\n\n        q->matrix_coeff_index_now[i]  = 3;\n\n        q->matrix_coeff_index_next[i] = 3;\n\n    }\n\n\n\n    avpriv_float_dsp_init(&q->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n    ff_fmt_convert_init(&q->fmt_conv, avctx);\n\n\n\n    q->units = av_mallocz(sizeof(*q->units) * avctx->channels);\n\n    if (!q->units) {\n\n        atrac3_decode_close(avctx);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avcodec_get_frame_defaults(&q->frame);\n\n    avctx->coded_frame = &q->frame;\n\n\n\n    return 0;\n\n}", "idx": 26512, "substitutes": {"avctx": ["afctl", "avtmp", "averctx", "aftx", "ajkt", "jampkg", " avconf", "wavtx", "abconf", "avesys", "avercb", "averct", "ajsys", "avhandle", "ajkw", "avetmp", "avwcs", "wavconfig", "avcrit", "ajcfg", "ajcontext", "abcmp", "afjac", "aucrit", "wavcmp", "avectl", "avcfg", "avpkg", "averpkg", "ajconn", "avct", "wavconn", "aftmp", "avcmp", "avaljac", "afcfg", "wavcontext", "wavkw", "ajcb", "avertmp", "avecmd", "afkw", "ajtx", "wavctl", "ajtxt", "avaltx", "avercontext", "abcp", "avcu", "navcontext", "afpid", "ajcmd", " avcmd", "avsys", "varcontext", "avecu", "wavkt", "afcontext", "avekt", " avct", " avwcs", " avpkg", "ajpid", "averconn", "avgc", "afpkg", "wavcrit", " avcontext", "avetxt", "jamctx", "avewcs", "wavcu", "avecontext", "auconn", "ajcmp", "ajctx", "avconf", "auctx", "afcmd", "avaltmp", "avpid", "avectx", "avkt", "jamkw", "afctx", "avtxt", "abtx", "avtx", "avkw", "averpid", "abctx", "navctx", " avcfg", "varctx", "wavcmd", "avcmd", "afcmp", "avecfg", "avertxt", "avecb", "avect", "avecp", "avetx", "navcp", "absys", "afconn", "avcb", "ajcp", "aveconn", "avepkg", "avalctx", "avcontext", "varsys", "wavgc", "abcontext", "varwcs", "averjac", " avcmp", "avcp", "avctl", "avercu", " avcp", "avercfg", "ajjac", "avejp", "aveconfig", " avkt", "avjac", "aversys", "averjp", "wavctx", "ajjp", "jamtx", "aveconf", "avertx", "avercmd", "avconn", "avecrit", "avjp", "averconf", "autx", "wavcp", "afkt", "abcmd", "wavtmp", " avtx", "avegc", "averkt", "avejac", "navcfg", "abpkg", "averhandle", "ajconf", "augc", "averconfig", "wavhandle", "avconfig", "wavpkg", "avehandle", "aukw", " avsys", "ajpkg"], "i": ["it", "iat", "x", "pi", "c", "id", "I", "n", "p", "j", "ai", "mi", "ii", "is", "b", "ti", "ip", "bi", "ij", "ci", "ir", "si", "im", "t", "index", "v", "m"], "ret": ["alt", "ter", "out", "ll", "RET", "rm", "re", "status", "result", "mem", "reply", "new", "rel", "rt", "fun", "rets", "txt", "ft", "aux", "val", "mt", "Ret", "jp", "res"], "version": ["type", "action", "length", "VER", "name", "direction", "batch", "versions", "feature", "status", "component", "distance", "VERSION", "result", "error", "sample", "ver", "count", "mode", "state", "ception", "sector", "order", "level", "actor", "sequence", "depth", "vers", "section", "size", "scale", "volume", "vision", "step", "position", "serial", "vector", "time", "driver", "channel", "number", "dimension", "timeout", "offset", "Version", "description", "format", "index", "v"], "delay": ["length", "hold", "sleep", "dq", "distance", "skip", "debug", "error", "wait", "del", "buffer", "late", "sync", "rate", "memory", "remember", "hide", "policy", "effect", "sequence", "priority", "speed", "response", "dp", "dl", "shift", "scale", "slow", "position", "time", "driver", "seed", "label", "timeout", "offset", "zip", "frequency", "description", "duration"], "samples_per_frame": ["samples_per2sequence", "samples_per_frames", "samples_PER_frames", "samples_PER_frame", "samples_PER_stream", "samples_per2frame", "samples_per_fram", "samples_PER_sequence", "samples_per_stream", "samples_per2frames", "samples_PER_fram", "samples_per_sequence"], "frame_factor": ["force67loader", "frame10fact", "frame10number", "force_scale", "frame10factor", "block_factor", "frame_relation", "framemodlower", "framemodfactor", "filterxfact", "block_operator", "filterxdomain", "frame_number", "framexfact", "force_loader", "frame67loader", "force67per", "block_actor", "frame_loader", "filterxfactor", "frame_per", "framelexloader", "frame10relation", " frame_relation", "frame_actor", "framelexscale", "block_lower", "framemodoperator", "filter_fact", "frame_step", " frame_number", "force_factor", "frame_operator", "framexdomain", "frame67factor", "force_per", "framelexfactor", "framelexper", "frame_lower", "frame67domain", "force67scale", "framemodactor", " frame_fact", "frame_scale", "frame_domain", "frame_fact", "filter_domain", "frame67fact", "framexfactor", "frame67per", "filter_factor", "frame67scale", "force67factor", " frame_step"], "edata_ptr": ["edapo_Ptr", "edadata48prime", "edata3inter", "edadata48prot", "edola_tr", "edATA_sp", "edata_tr", "edATA_pointer", "edola_grad", "edra_ptr", "edata_pers", "edata_prot", "edoff_ps", "edra_pointers", "edadata_pointer", "edapo_inter", "edata48ptr", "edata__pointers", "edapo48inter", "edata_ctr", "edelta_ptr", "edata___fp", "edadata48pt", "edata48prime", "edata___addr", "edata_pointer", "edata48inter", "edATA_ptr", "edATA_tr", "edadata_tp", "edata_ps", "edadata_ptr", "edata_fd", "edata2prot", "edata48tp", "edata_deg", "edataacptr", "edata48pt", "edola_ctr", "edoff_ptr", "edadata_pt", "edata__ptr", "edATA_addr", "edata_tp", "edadata_prot", "edata__pers", "edata___pointer", "edata_prime", "edata_grad", "edadata48ptr", "edra_pt", "edola_ptr", "edata_sp", "edapo48tp", "edata2pt", "edataacpointers", "edata_pointers", "edata3ptr", "edataacpers", "edadata_prime", "edata_Ptr", "edoff_pointers", "edelta_addr", "edapo48Ptr", "edapo_ptr", "edATA_deg", "edapo_tp", "edata_fp", "edata3tp", "edelta_pointer", "edapo48ptr", "edataacps", "edata2prime", "edata_pt", "edata48Ptr", "edata___ptr", "edata2ptr", "edadata_fd", "edata3Ptr", "edoff_pers", "edra_pers", "edelta_fp", "edata48prot", "edata_addr", "edata__pt", "edata_inter"], "q": ["f", "it", "ch", "Q", "quit", "quant", "tx", "quest", "dq", "queue", "d", "w", "qt", "c", "k", "er", "cv", "requ", "ck", "g", "qu", "r", "ve", "cache", "p", "qq", "que", "j", "ctx", "iq", "qa", "req", "quote", "query", "qs", "z", "e", "eq", "qv", "ue", "pkg", "h", "cc", "t", "m", "v", "sq", "qi", "aq"]}}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n#ifdef DEBUG_UNASSIGNED\n\n    printf(\"Unassigned mem read \" TARGET_FMT_plx \"\\n\", addr);\n\n#endif\n\n#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)\n\n    do_unassigned_access(addr, 0, 0, 0, 4);\n\n#endif\n\n    return 0;\n\n}\n", "idx": 26530, "substitutes": {"opaque": ["ocgate", "achc", "achaque", "opque", "ocaque", " opque", "opc", "ocque", " opgate", "achgate", "achque", "occ", "opgate", " opc"], "addr": ["x", "ad", "tx", "obj", "err", "adr", "address", "ref", "xy", "hash", "arp", "dh", "pad", "rs", "gt", "at", "mem", "var", "act", "r", "cmd", "ace", "arr", "add", "ord", "ctx", "coord", "pos", " address", "eth", "a", "data", "info", "dr", "loc", "src", "alloc", "Address", "handle", "mt", "hl", "self", "ptr", "offset", "pat", "arch", "pkg", "index", "point", "name", "hw"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)\n\n{\n\n    TCGv_i64 tmp64 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_extu_i32_i64(tmp64, b);\n\n    dead_tmp(b);\n\n    tcg_gen_shli_i64(tmp64, tmp64, 32);\n\n    tcg_gen_add_i64(a, tmp64, a);\n\n\n\n    tcg_temp_free_i64(tmp64);\n\n    return a;\n\n}\n", "idx": 26531, "substitutes": {"a": ["f", "i", "as", "sa", "x", "out", "o", "ma", "app", "d", "w", "c", "result", "ia", "A", "g", "r", "aa", "ar", "n", "p", "s", "new", "an", "area", "up", "am", "ach", "l", "ac", "y", "ba", "e", "aaa", "val", "u", "ab", "h", "t", "m", "v", "this"], "b": ["f", "bb", "fb", "i", "sb", "out", "pb", "bc", "d", "w", "c", "bf", "B", "g", "r", "db", "p", "new", "cb", "to", "j", "bs", "eb", "l", "bi", "y", "ba", "bh", "base", "bt", "gb", "e", "rb", "by", "ab", "h", "t", "be", "m", "v"]}}
{"project": "qemu", "commit_id": "a980f7f2c2f4d7e9a1eba4f804cd66dbd458b6d4", "target": 0, "func": "static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < vs->num_queues + 2; i++) {\n\n        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);\n\n    }\n\n    pc_alloc_uninit(vs->alloc);\n\n    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));\n\n    g_free(vs->dev);\n\n    qpci_free_pc(vs->bus);\n\n    g_free(vs);\n\n}\n", "idx": 26535, "substitutes": {"vs": ["otes", "ms", "Vs", "ports", "ops", "values", "args", "ins", "fs", "v", "rs", "vp", "lists", "ds", "hs", "vv", "flags", "ks", "details", "pages", "caps", " cs", "ver", "changes", "s", "lines", "blogs", "ves", "cs", "sts", "alls", "services", "bits", "inv", "ups", "js", "bs", "vers", "ss", "xs", "wcs", "VS", "ns", "vc", "ts", "ims", "ps", "docs", "vals", "qs", "es", "its", "gs", "sv", "obs", "atts", "ls", "vt", "views"], "i": ["ui", " j", " di", " multi", " info", "ini", "id", " iter", "in", "I", " bi", "sim", "ai", " li", "li", "ip", "y", " mi", "ci", "base", " si", "iu", " I", "si", "ji", " ex", "ki", "us", " ni", " ii", "gu", "j", "chain", "ind", "ims", "uri", "iter", "m", "point", "qi", "ix", "my", "x", "multi", " pos", "ami", "ri", "phi", "di", "oi", " err", "mi", "ii", "print", " port", "is", "l", " ti", " pi", "bi", " key", " m", "xi", "im", "it", "ic", " c", " mc", " it", "ex", "pi", "fi", "me", "gi", " my", "iq", "hi", "ti", "e", " wi", "index", "cli", " index"]}}
{"project": "qemu", "commit_id": "d492a75cfefd9a09125ba2b007c817c1417c3820", "target": 0, "func": "void spapr_clear_pending_events(sPAPRMachineState *spapr)\n\n{\n\n    sPAPREventLogEntry *entry = NULL;\n\n\n\n    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {\n\n        QTAILQ_REMOVE(&spapr->pending_events, entry, next);\n\n        g_free(entry->extended_log);\n\n        g_free(entry);\n\n    }\n\n}\n", "idx": 26538, "substitutes": {"spapr": [" spipr", "spapsrb", "asprapr", "spapsR", "spaprb", "spamprr", "aspapres", "spapsres", "asprapres", "spampr", " spapsrb", "sprapw", " spapscr", "asprapar", " spiprr", "spamprb", " spipR", "spapprb", "spaprr", " spapR", "spapear", "asprapw", "aspapw", " spaprr", "spappcr", "spapsr", "sprapr", "sprapar", "spaperes", "spampp", "spampcr", "spapw", "spapres", "spapew", "spappr", " spapcr", "spapep", "spapsar", "spapscr", " spapsr", "spipp", "spampR", "spipr", "spipR", " spaprb", "spappR", "sprapres", " spapsR", "spaperr", "spapeR", "spapsw", "aspapar", "spapcr", "aspapr", "spapp", "spaper", "spapR", " spipp", " spapp", "spapar", "spiprr"], "entry": ["Entry", "it", "inter", "quit", "attribute", "ment", "match", "field", "eu", "job", "cur", "obj", "see", "entity", "item", "se", "try", "cell", "xml", "ent", "ie", "ENT", "insert", "result", "ry", "event", "buffer", "escape", "command", "or", "cue", "row", "member", "empty", "comment", "office", "delete", "list", "ace", "record", "add", "set", "next", "instance", "image", "section", "inner", "line", "element", "nt", "key", "RY", "window", "link", "interface", "e", "import", "writer", "table", "index", "enter"]}}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static void sclp_set_write_mask(void)\n\n{\n\n    WriteEventMask *sccb = (void*)_sccb;\n\n\n\n    sccb->h.length = sizeof(WriteEventMask);\n\n    sccb->mask_length = sizeof(unsigned int);\n\n    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n\n\n    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);\n\n}\n", "idx": 26540, "substitutes": {"sccb": ["sccabb", "scusbe", "dsuccb", "tsckba", "succbd", "socb", "scfbd", "sccbb", "jsclb", "desuccbc", "sclnb", "sckab", "scknb", "scldb", "desuccfb", "scusbc", "sclbd", "simpleccab", "simpleccnb", "nsccbb", "sccba", "socab", "jsccb", "sclrb", "scusb", "saccbs", "dsuccerb", "sctrlfb", "lessccbr", "scastbs", "sctrlnb", "sclfb", "nsclerb", "lessccfb", "sdcerb", "saccb", "sccbc", "jsclbb", "sckb", " sccc", "lesscusbr", "sdcb", "sclbr", "sclba", "tsccba", "sclbc", "succbs", "sCCbd", " sccbe", "jsccbs", "succfb", "succbc", "nscldb", "sCCbe", "nsccerb", "succb", "scccb", "scedb", "desccfb", "scastb", "scusab", "sceba", "lessccnb", " scfbe", " sccbd", "sckrb", " scfbd", "scederb", "simplecusb", "scastab", "sccaerb", "sccerb", " scfc", "sccnb", "sdccb", "desccb", "sccabc", "lesscusfb", "sccafb", "desccbc", "dscccb", "sccbr", "dsucccb", "tsckb", "sclbb", "saccbb", "dsuccbs", "nsclb", "sclerb", "lesscusb", "sccbe", "sccabd", "scastbb", "sctrlb", "sckba", "tsccrb", "jsclbs", "scusbr", "jsccbb", "sdcbs", "scedbs", "sccab", "scusc", "dsccb", "sctrlbr", "sccadb", " scfb", "scfbe", "desccbd", "sccbd", "tsccb", "scusbd", "sccfb", "dsccerb", "scusfb", "sckbc", "sclab", "succcb", "scerb", "lessccb", "sclbs", "desuccbd", "simpleccb", "simplecusab", "nsccdb", "sccc", "tsckbd", "socbc", "scedcb", "scusnb", "scfc", "sccbs", "jsccab", "scfb", "lesscusnb", "simplecusnb", "sclb", "jsclab", "succerb", "sCCb", "sCCc", "nsccb", "tsccbd", "simplecusbc", "simpleccbc", "sckbd", "sccrb", "socnb", "dsccbs", "nsclbb", "scebd", "desuccb", "sceb", "tsckrb", "sccdb", "saccab"]}}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "void json_prop_int(QJSON *json, const char *name, int64_t val)\n\n{\n\n    json_emit_element(json, name);\n\n    qstring_append_int(json->str, val);\n\n}\n", "idx": 26543, "substitutes": {"json": ["tree", "my", "job", "latest", "mos", "obj", "xy", "ja", "jac", "son", "yt", "xml", "javascript", "journal", "sky", "report", "graph", "ose", "cmd", "metadata", "kj", "gov", "mson", "lost", "j", "jay", "np", "js", "bs", "nil", "html", "doc", "jas", "closed", "jack", "JSON", "test", "kid", "ij", "document", "stats", "txt", "mn", "oj", "java", "dump", "gc", "final", "format", "jj"], "name": ["type", "on", "nm", " names", "item", "nam", "named", "nan", "normal", "def", "c", "id", "k", "word", "local", "var", "path", "ext", "cmd", "n", "p", "prefix", "par", "j", "order", "init", "comp", "start", "attr", "NAME", "key", "ame", "e", "Name", "label", "v", "str", "names"], "val": ["pol", "it", "x", "lit", "tx", "obj", " lit", "al", "aval", "xy", "ref", "len", " valid", "def", "value", "valid", " fut", "local", "sl", " slot", " eval", "vol", " v", "ctx", "pos", " aval", " ty", "doc", " value", " al", "test", "Val", "VAL", "vals", "ival", "eval", "px", "num", " lac", "serv", "index", "v", "pt"]}}
{"project": "qemu", "commit_id": "e4f308bbf9f360ee2af5b94b87aef170d8f20dc4", "target": 0, "func": "static void pm_update_sci(PIIX4PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||\n\n        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &\n\n          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);\n\n\n\n    qemu_set_irq(s->irq, sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n", "idx": 26552, "substitutes": {"s": ["sys", "ms", "sb", "ins", "sis", "gets", "os", "comm", "erences", "fs", "v", "rs", "w", "c", "bes", "ses", "ds", "hs", "sl", "details", "n", "changes", "cs", "sts", "ains", "ares", "aws", "ches", "vs", "S", "als", "js", "bs", "ss", "is", "ats", "ts", "ns", "ps", "ims", "ies", "states", "uns", "stats", "qs", "des", "es", "its", "gs", "serv", "sv", "ys", "parts", "ls", "m"], "sci_level": ["ei_level", " sci_index", "sciacyl", "sci_success", " sci_levels", "sci_index", "sciacysuccess", "sci_l", "sci_quality", " sci_lvl", "sci_levels", "sciacylvl", " sci_status", "sci_lvl", "ei_lvl", "sciacylevel", "ei_success", "ei_l", " sci_quality", "sci_status"], "pmsts": ["mlists", "pmants", "hmservices", "tmcasts", "pmlists", "hmstates", "rpmants", "cminces", "rpmst", "rpminces", "iamsta", "pmns", "iamservices", " pmcasts", " pmants", " pmst", "pmcasts", "rpmstates", "pminces", "mns", "amlists", "amsts", "pmars", "hmsts", "tmsts", "iamsts", "cmst", "rpmars", "rpmsts", " pminces", " pmlists", "pmservices", "rpmservices", "pmsta", "tmars", "pmst", "pmstates", "iamstates", " pmists", " pmars", "msts", "pmists", "rpmcasts", "rpmsta", "tmants", "amists", "cmsts", " pmns", "amns", "mists", "hmsta"]}}
{"project": "FFmpeg", "commit_id": "beefafda639dd53fc59c21d8a7cf8334da9a1062", "target": 1, "func": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)\n\n{\n\n    int bit;\n\n\n\n    if(s->extra_bits){\n\n        S <<= s->extra_bits;\n\n\n\n        if(s->got_extra_bits){\n\n            S |= get_bits(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);\n\n        }\n\n    }\n\n    bit = (S & s->and) | s->or;\n\n    return (((S + bit) << s->shift) - bit) << s->post_shift;\n\n}\n", "idx": 26559, "substitutes": {"s": ["comm", "sports", "c", "comments", "r", "ar", "p", "changes", "aws", "sym", "ns", "ies", "y", "z", "less", "h", "ows", "v", "sq", "series", "i", "sb", "os", "rs", "spec", "n", "cs", "als", "so", "ats", "ts", "ims", "its", "parts", "sys", "ms", "x", "as", "ins", "ants", "ses", "bis", "sts", "sw", "bs", "a", "is", "b", "ps", "stats", "gs", "ls", "se", "fs", "w", "ex", "bes", "ds", "hs", "details", "set", "an", "js", "ss", "settings", "qs", "es", "sv", "source", "t", "conf"], "crc": ["ctRC", "ccc", " cdr", "lcrc", "prc", "lcRC", "hrib", "rcrc", "lcirc", "pc", "hdr", "pdr", " cRC", " cc", "crib", "cdr", "currc", "hrc", "rccc", "rcRC", "cron", " cce", "prib", "curce", "ctcc", "lcce", "ctron", " circ", "hc", "curRC", "cce", "curirc", "cRC", "circ", " cron", " crib", "cc", " ccc", "ctrc", "rcron"], "S": ["Q", "W", " IS", "SF", "TS", "SE", "RAW", "STAT", "Si", "US", "U", " B", "SS", "SU", "L", "BS", "D", "SP", "Session", "DS", "B", "A", "SOURCE", "NS", "I", "SEC", "SL", "M", "GS", "Source", "set", "JS", "String", "X", " C", "SAM", "Sample", "RS", "O", " N", "SA", "V", "Set", " T", "T", "CS", "IS", "R", " SS", "ST", "SI", "SR", "SER", "N", "SK", "H", "P", "G", "C", "F", "SM"], "bit": ["block", "it", "ch", "i", "x", "bool", "field", "out", "byte", "status", "sat", "bo", "digit", "id", "word", "lt", "B", "or", "p", "state", "ut", "set", "bits", "mod", "jit", "pair", "binary", "and", "tag", "Bit", "back", "b", "test", "key", "base", "version", "bin", "position", " BIT", "flag", "mask", "number", "slot", "t", "BIT", "big", "point", "lock", "ion"]}}
{"project": "FFmpeg", "commit_id": "42f9132218ca11a8e9a3c82a175b46bca092113e", "target": 0, "func": "static int mxf_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)\n\n{\n\n    AVStream *st = s->streams[stream_index];\n\n    int64_t seconds;\n\n    MXFContext* mxf = s->priv_data;\n\n    int64_t seekpos;\n\n    int ret;\n\n    MXFIndexTable *t;\n\n\n\n    if (mxf->nb_index_tables <= 0) {\n\n    if (!s->bit_rate)\n\n        return AVERROR_INVALIDDATA;\n\n    if (sample_time < 0)\n\n        sample_time = 0;\n\n    seconds = av_rescale(sample_time, st->time_base.num, st->time_base.den);\n\n\n\n    if ((ret = avio_seek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET)) < 0)\n\n        return ret;\n\n    ff_update_cur_dts(s, st, sample_time);\n\n    mxf->current_edit_unit = sample_time;\n\n    } else {\n\n        t = &mxf->index_tables[0];\n\n\n\n        /* clamp above zero, else ff_index_search_timestamp() returns negative\n\n         * this also means we allow seeking before the start */\n\n        sample_time = FFMAX(sample_time, 0);\n\n\n\n        if (t->fake_index) {\n\n            /* behave as if we have a proper index */\n\n            if ((sample_time = ff_index_search_timestamp(t->fake_index, t->nb_ptses, sample_time, flags)) < 0)\n\n                return sample_time;\n\n        } else {\n\n            /* no IndexEntryArray (one or more CBR segments)\n\n             * make sure we don't seek past the end */\n\n            sample_time = FFMIN(sample_time, st->duration - 1);\n\n        }\n\n\n\n        if ((ret = mxf_edit_unit_absolute_offset(mxf, t, sample_time, &sample_time, &seekpos, 1)) << 0)\n\n            return ret;\n\n\n\n        ff_update_cur_dts(s, st, sample_time);\n\n        mxf->current_edit_unit = sample_time;\n\n        avio_seek(s->pb, seekpos, SEEK_SET);\n\n    }\n\n    return 0;\n\n}\n", "idx": 26568, "substitutes": {"s": ["f", "sys", "ch", "ms", "i", "x", "space", "sb", "args", "os", "comm", "erences", "fs", "sports", "v", "rs", "c", "sam", "ds", "hs", "g", "spec", "n", "p", "changes", "sc", "cs", "sts", "set", "aws", "j", "ctx", "vs", "S", "als", "js", "bs", "ss", "settings", "a", "is", "b", "ats", "ns", "ts", "ps", "l", "ims", "acs", "src", "stats", "qs", "south", "es", "its", "gs", "less", "sv", "sp", "h", "ls", "m", "sq", "conf"], "stream_index": ["stream_offset", "streamIdind", "streamIdoffset", "channel_ind", "streamIdinfo", "sample_info", "channel_index", "channel_id", "streamIdindex", "sample_ind", "stream_key", "channel_key", "stream_info", "sample_offset", "sample_index", "stream_ind", "stream_id"], "sample_time": ["sample_state", "sample_weight", "samplevallength", "samplejTime", "samplejtype", "ample_size", "samplettime", "sample_text", "sample_file", "samplevaltime", "sample_post", "sampleTimetime", "sample_length", "samplevaltransform", "samplelogfile", "sample_frequency", "sample00sequence", "sampleTimetext", "samplelogtimes", "transform_text", "sample2Time", "amplelogtime", "sampleTimeruntime", "sample_transform", "sample_when", "springlyTime", "sample68times", "sample_tree", "samplevaltimes", "sample_tag", "sample_hash", "ample_Time", "ample2time", "sampleTimeTime", "Sample_form", "sample_times", "sample00state", "spring_type", "sam_state", "sample2rate", "sampleletime", "sample68Time", "sampleityfrequency", "batchletransform", "samplemingtime", "sample___Time", "sample67post", "batch_transform", "sampleTimetimes", "Sample_Time", " sample_length", "ample_length", "sampleminglength", "sample68form", "samplettree", "samplematTime", "sample_query", "Sample_times", "samplelytime", "sample_Time", "transformTimetext", "ample_transform", " sample_Time", "batchleTime", "ample2size", "sampleTimeTIME", "ample_file", "samplelyTime", "samplelogtime", "sam_time", "sample2time", "samplettimes", "sample2times", "samplemingTime", "transform_Time", "samplevalsequence", "sampleleTime", "ample_post", "sample_total", "batch_time", "sample_size", "samplelytype", "sample68time", "batch_Time", "Sample_hash", "springlytime", "springlyquery", "sample_rate", "amplelogtimes", "batchletimer", "batch_timer", "samplejweight", "ample_tree", "transformTimeruntime", "sample_set", "sampleitytime", "spring_Time", "sample2size", "samplemingtransform", "samplelettransform", "sample_runtime", " sample_set", "sample___time", "amplelogfile", "samplejtime", "ample_rate", "samplevaltree", "sample2TIME", "sample___hash", "sampleityhash", "sampleityTime", " sample_when", "sampleletimer", "sample_sequence", "spring_query", " sample_times", "transformTimeTime", "sample67tag", "sample_timer", "sample00total", "samplematruntime", "sample2type", "sample00length", "spring_time", " sample_weight", "samplemattime", "amplelogtotal", "sam_sequence", "sample00times", "samplelyquery", "Sample_frequency", "sam_length", "sample_type", "batchletime", "springlytype", "sample00file", "sampleletransform", "ample2rate", "samplettransform", "sample___frequency", "samplemattext", "sample_form", " sample_type", "transform_runtime", "ample_total", "ample_times", "samplevalstate", "samplelettimer", "sample2query", "ample2times", "transformTimetime", "Sample_time", "samplelettime", "ample_time", "samplelogtotal", "sample_TIME", " sample_TIME", " sample_rate", "sample00time", "sampleletTime", "transform_time", "ample_tag", "sample67time"], "flags": ["bool", " Flags", "args", "options", "ventions", "fields", "ants", "status", "fs", "lag", "Flag", "nl", "tags", "comments", "details", "Flags", "func", "cmd", "fps", "ents", "cs", "ags", "ints", "bits", "faces", "frames", "settings", "wcs", "ats", "types", "weights", "ensions", "locks", "styles", "mask", "flag", "FLAG", "posts", "features", "properties", "atts", "reports"], "st": ["stack", "ost", "sn", "stream", "rest", "obj", "store", "sta", "se", "status", "std", "stab", "storage", "ste", "tt", "cont", "irst", "sl", "St", "inst", "sc", "state", "sh", "sts", "util", "ut", "sw", "set", "ust", "et", "ctx", "stage", "ast", "th", "ss", "so", "stop", "ct", "ts", "start", "must", "sm", "ST", "src", "stable", "z", "step", "ft", "sp", "sth", "sv", "mt", "ist", "est", "tr", "h", "stat", "end", "str", "pt"], "seconds": ["sections", "flows", "ms", "utes", "sb", "uploads", "values", "users", "uses", "videos", "ages", "sites", "urations", "forms", "erences", "fs", "models", "jobs", "bes", "strings", "anos", "years", "uts", "months", "missions", "times", "ions", "classes", "bytes", "bits", "resources", "amples", "workers", "frames", "ations", "sec", "bs", "vers", "js", "settings", "feet", "steps", "abytes", "reports", "ts", "https", "rets", "states", "terms", "qs", "files", "gs", "sf", "actions", "obs", "second", "timeout", "errors", "games", "days", "utils"], "mxf": [" mfg", " mxe", " mfo", "mxffe", "modulexe", "matxff", "emxff", "matxe", "Mfif", "bmfg", "mwe", "matwe", " mfx", "esmfg", "esmxe", "bmxf", "gxe", " mxd", " mffe", "mxfif", "gmfif", "emwe", "gmxf", "mxd", "modulecf", "Mcf", "gmfo", "emfx", "mcf", " mfif", "nxc", "mxff", " mxff", "mxe", "emxf", "Mxf", "Mxe", "bmxe", "mxfo", "esmxd", "modulexf", " mcf", "mfo", "gxff", "matxf", "nfo", "mfif", "mffe", "emxe", "mfg", "hxf", " mxc", "hfx", "gmffe", "mxxf", "esmxf", " mwe", "modulefif", "nxf", "hfo", "bmxd", "hxc", "gxf", "nfx", "mxc", "mfx", "gfx"], "seekpos": ["ekpos", "walkPos", "scanposition", "selectpos", "referencepos", "ekPos", " seekoffset", "scanpos", "seekposition", "scrollpos", "scanpo", "seekoffset", "walkpos", "selectPOS", "referenceposition", "scrolloffset", "seekpo", "ekoffset", "scrollposition", "scrollPos", "referencePos", "referencepo", "seekPos", "ekposition", "walkPOS", "selectPos", " seekpo", "scanPos", "seekPOS", "walkposition", "selectposition", " seekPos", " seekPOS", " seekposition"], "ret": ["it", "alt", "not", "out", "reset", "ll", "RET", "ref", "re", "pas", "success", "try", "att", "gt", "def", "value", "result", "rev", "after", "cont", "ry", "mem", "nl", "reg", "get", "ral", "ext", "over", "det", "cert", "resp", "pret", "rem", "et", "fail", "nil", "print", "ert", "rt", "back", "nt", "rets", "ft", "val", "net", "mt", "Ret", "tr", "elt", "final", "Return", "res"], "t": ["f", "it", "tree", "type", "i", "x", "tm", "tx", "o", "got", "tu", "temp", "tl", "att", "v", "tf", "ent", "w", "c", "tc", "tt", "at", "lt", "g", "r", "n", "p", "dt", "tab", "mint", "to", "et", "te", "td", "ta", "a", "tg", "b", "ct", "T", "ts", "rt", "nt", "ti", "y", " T", "l", "wt", "txt", "bt", "tp", "tr", "tmp", "table", "m", "ot", "vt", "h", "tap", "pt"]}}
{"project": "qemu", "commit_id": "b248ede2ef2792d364bd305e5e92e24921c924a8", "target": 1, "func": "if_start(Slirp *slirp)\n\n{\n\n    uint64_t now = qemu_get_clock_ns(rt_clock);\n\n    int requeued = 0;\n\n\tstruct mbuf *ifm, *ifqt;\n\n\n\n\tDEBUG_CALL(\"if_start\");\n\n\n\n\tif (slirp->if_queued == 0)\n\n\t   return; /* Nothing to do */\n\n\n\n again:\n\n        /* check if we can really output */\n\n        if (!slirp_can_output(slirp->opaque))\n\n            return;\n\n\n\n\t/*\n\n\t * See which queue to get next packet from\n\n\t * If there's something in the fastq, select it immediately\n\n\t */\n\n\tif (slirp->if_fastq.ifq_next != &slirp->if_fastq) {\n\n\t\tifm = slirp->if_fastq.ifq_next;\n\n\t} else {\n\n\t\t/* Nothing on fastq, see if next_m is valid */\n\n\t\tif (slirp->next_m != &slirp->if_batchq)\n\n\t\t   ifm = slirp->next_m;\n\n\t\telse\n\n\t\t   ifm = slirp->if_batchq.ifq_next;\n\n\n\n\t\t/* Set which packet to send on next iteration */\n\n\t\tslirp->next_m = ifm->ifq_next;\n\n\t}\n\n\t/* Remove it from the queue */\n\n\tifqt = ifm->ifq_prev;\n\n\tremque(ifm);\n\n\tslirp->if_queued--;\n\n\n\n\t/* If there are more packets for this session, re-queue them */\n\n\tif (ifm->ifs_next != /* ifm->ifs_prev != */ ifm) {\n\n\t\tinsque(ifm->ifs_next, ifqt);\n\n\t\tifs_remque(ifm);\n\n\t}\n\n\n\n\t/* Update so_queued */\n\n\tif (ifm->ifq_so) {\n\n\t\tif (--ifm->ifq_so->so_queued == 0)\n\n\t\t   /* If there's no more queued, reset nqueued */\n\n\t\t   ifm->ifq_so->so_nqueued = 0;\n\n\t}\n\n\n\n        if (ifm->expiration_date < now) {\n\n            /* Expired */\n\n            m_free(ifm);\n\n        } else {\n\n            /* Encapsulate the packet for sending */\n\n            if (if_encap(slirp, ifm)) {\n\n                m_free(ifm);\n\n            } else {\n\n                /* re-queue */\n\n                insque(ifm, ifqt);\n\n                requeued++;\n\n            }\n\n        }\n\n\n\n\tif (slirp->if_queued)\n\n\t   goto again;\n\n\n\n        slirp->if_queued = requeued;\n\n}\n", "idx": 26587, "substitutes": {"ifm": ["ibmm", "ifp", "fifk", "ifmc", " ifd", "ifft", "iaml", "nilmc", "iffgm", "ifms", "ifcm", " ifl", "fifmx", "iffmod", "iffy", "acts", "unlessn", " ifcm", "labelm", "icmd", "iffd", "ifs", "unlessm", "imgnm", "ifsm", "actp", "iterl", " ift", "unlessmi", "iffmn", "thenmi", "ifftm", "actm", "ifty", "endifms", "figsm", "labelmi", "ifk", "iffnm", "expmi", "ifq", "ifmod", "actn", "iterm", "ifmx", "ifam", "invm", "iftn", "ifl", "labelms", "iffmd", " ifmm", "ibn", " ifi", "iffm", "imgd", "expmm", "ifd", "ifgm", "fifmc", "ibm", "ifi", "imgmi", "labelmn", "icm", "fiftm", "endifd", "itd", "iffp", "ibgm", "strmi", "strm", "fflem", "icmi", "ifmi", "iffg", "ifmt", "efp", "unlesst", "iamcm", "ivm", "liml", "Ifd", " iftm", "endifn", "fifd", " ifnm", "iffmi", " ifq", "fft", "invn", " ifn", "actnm", "labeln", "limcm", "ifti", "ifmm", "iffr", "ivr", "limm", "itm", "thenmm", "Ifm", "expmx", " ifk", "expm", "ifg", "limmi", "nilm", "ifn", " ifgm", "nilmi", "invmi", "ift", " ifsm", " ifs", "efl", "figm", "ivt", " ifr", "actmt", "actl", "thenm", "labelt", "tifnm", "icmod", "imn", "ify", "strmod", " ifmt", " ifman", "iftm", "ffmn", "iamm", "iftp", "iammi", "iffam", "imgk", "nilmt", "ffm", "iffq", "ifnm", "itermc", "tifg", "imp", "itermi", "Ifms", "figt", "fifmt", "fifm", " iflem", "actg", "ifmn", " ifp", "Ifn", "actman", "invms", "labellem", "iffn", "imi", "fifr", "efm", "tifm", "thenmx", "efmt", "iftd", "fifp", "unlesssm", "ifmd", "actmm", "fifl", "itermt", "unlesss", "ifman", "tifn", "iftmn", "imm", "imgm", " ifam", "strmd", "endifm", "fifmi", "ity", "imgam", "ivq", "actgm", "ifr", " ifms", "unlessman", "fifmm", "figmi", "iflem", "itmn", " ifmn", "imggm", " ifmi"], "ifqt": ["defdt", "efqq", "tifmat", "ifvt", " ifdt", "svqq", "ifqq", "ift", "Ifqa", "tifvt", "ifdt", "efvt", "efqt", "Ifqt", " ifqa", "Ift", "IFqa", "defq", "tifdt", "IFt", "IFq", "tifqt", "tifq", "ffqq", "defqi", "ifqi", " ift", "ifmat", "svqt", "IFqt", "tifqi", "ffqt", "ffqa", "svvt", "Ifq", "tifqq", "tifqa", " ifq", "ifqa", " ifqq", "ifq", "ffq", " ifqi", "svmat", "efmat", "defqt"], "slirp": ["slirmcp", "splarp", "splrirp", "slorm", "sslirping", "slmirpi", "slererping", "slirpin", "plirp", "sllrcp", "slmirjp", "slirps", "slirsp", "slererp", "slrirpid", "slvrpa", "splirg", "slwarpin", "slyrphp", "slrinport", "sldirport", "slorpa", "slibrps", "sllrp", "slirtphp", "slpirpa", "selirv", "slrinpi", "selirp", "glirp", "slirtpi", "slirv", "slirtp", "slirphp", "slirocp", "slwarpa", "slierpid", "slibrp", "splmirpi", "splmirpatch", "slrirpo", "splirmp", "slarl", "slyrpy", "plirpen", "slairport", "slirmp", "slirpatch", "selibrn", "slarpi", "splircp", "slirmv", "slairg", "splrirg", "slwarg", "slirl", "glirpo", "slrirpa", "slirkp", "slibrsp", "splirjp", "islirp", "sliverpi", "slirtjp", "slairpatch", "slarport", "slibrpi", "slpirpi", "sslierping", "slrirpatch", "slrinp", "slrinphp", "slwarphp", "splirpi", "slrirg", "slirlp", "sllrpc", "islairp", "slvrp", "splirtpi", "slererve", "slererpa", "slirjp", "salrirpatch", "slirvp", "slwarm", "slierphp", "slirg", "salirpa", "slircphp", "slyrm", "glpirpa", "sslierp", "selirn", "slierping", "slibrn", "slmirpatch", "splrirpin", "slvrport", "sslirpa", "slirm", "slwarps", "splirphp", "slyrp", "sslierpa", "salirp", "slirpi", "slirping", "slirve", "splirp", "slrirps", "slyrcp", "slierm", "slierpa", "plierpen", "selirsp", "islairbp", "sslierve", "slirlps", "liircp", "plierp", "slwarp", "slirn", "slirmpi", "slmircp", "slrirbp", "liirp", "slirpen", "slirpo", "splirtcp", "slvrpatch", "sslierpid", "slirlpi", "liircphp", "slirop", "slarpy", "islirpid", "slairvp", "glpirport", "splirpa", "slairpin", "sslirp", "plierphp", "splirtp", "slirkvp", "splarphp", "liirl", "selibrsp", "slierpd", "sldirpi", "liircpy", "slirpa", "slirpd", "slircl", "slirmn", "slirpy", "slyrpa", "splirport", "slirmps", "sldirphp", "splirtjp", "slircve", "sslirpid", "slrirpd", "slmirphp", "slpirn", "splirpin", "splrirpa", "slircpo", "spllrpc", "slircpy", "salrirpa", "slierps", "sllrpa", "splmirphp", "splarport", "sslierm", "salrirport", "slircpa", "islairvp", "selibrv", "slarp", "slibrv", "salirpatch", "slirpid", "splmirp", "slpirjp", "splirm", "slyrpc", "splirpc", "slibrcp", "slierpen", "sliverpatch", "splirmps", "slirtcp", "glirpa", "islairpid", "slpirsp", "slyrpid", "splirpatch", "sslierpd", "spllrpa", "slarphp", "islirbp", "slpirport", "spllrp", "selibrp", "slpirp", "sliverp", "slrirp", "plirps", "sslirve", "slrirport", "sliverphp", "slirbp", "slirpc", "slairpid", "glpirp", "slairp", "splirps", "slrirpin", "splirmpi", "slierve", "sliropc", "glirport", "slircport", "salrirp", "splarpi", "liircl", "slyrpd", "sslirm", "slircping", "slrirvp", "plirphp", "slairbp", "slirkpid", "sliropa", "slirmsp", "sldirp", "slierp", "slirtpatch", "salirport", "slmirp", "splirmcp", "spllrcp", "slorp", "plierps", "slpirpo", "slairpa", "slirport", "liirphp", "slrirphp", "slorpin", "slircp", "slpircp", "glpirpo", "slrirm", "islirvp", "slirlcp", "slyrl", "liirpy", "slwarpen", "slpirv", "slrirpen", "slirkbp", "sslirpd"], "if_queued": ["if_queslected", "if_paueless", "if_meued", "if_queuing", "if_paues", "if_fiuer", "if_quesue", "if_Queuer", "if_fiied", "if__queslected", "if_Queied", "if_quesuing", "if_fiuing", "if__quesue", "if_queues", "if_quesumed", "if_execues", "if_execued", "if_queumed", "if_continued", "if_quesueless", "if_queueue", "if_queied", "if_meuated", "if_continue", "if_continuing", "if_continumed", "if_Queued", "if_queueues", "if__quesued", "if_pauated", "if__queued", "if_queueless", "if_meueless", "if__queumed", "if_meues", "if_queue", "if_queuer", "if__quesues", "if__queue", "if_paued", "if__queuing", "if__queues", "if_quesuated", "if_execumed", "if_Queuing", "if_execlected", "if_queueued", "if_queueumed", "if_quesued", "if_fiued", "if_queueuing", "if_quesues", "if_queuelected", "if__quesuing", "if__quelected", "if__quesumed", "if_quelected", "if_queuated"], "ifq_so": ["ifrequ_sel", "iff_since", "ifq_SO", "ifq2so", "ifq__SO", "ifrequ_num", "ifq2SO", "iff_pri", "ifrequ_so", "ifq_since", "ifq_sel", "ifdq_sel", "ifq_pri", "ifrequ_SO", "ifq__sel", "ifq_num", "ifdq_since", "iff_so", "ifdq_pri", "ifq__num", "ifq2since", "ifq2pri", "ifdq_so", "ifq__so", "iff_SO"], "so_queued": ["so_queueued", "so2quesuing", "so2quesued", "so2queuer", "so2quesuer", "so_quesuer", "so_quesued", "so2queuing", "so_queuing", "so_Queuing", "so2queue", "so_queueuer", "so2quesue", "so_quesue", "so_queueuing", "so_queuer", "so_Queued", "so_Queuer", "so_quesuing", "so_Queue", "so2queued", "so_queueue", "so_queue"], "requeued": ["reciressed", "requemented", "Requeanted", "REqueued", "crequeued", "crequemented", "reketuated", "repeanted", "REqueilled", "Requeued", "requerued", "requeueued", "requeanted", "reciuated", "requesressed", "repeuer", "requerue", "crequeressed", "reqmented", "reciued", "requeruated", "reque", "crequesmented", "Requeueued", "crequeuated", "requesmented", "recimented", "requeueue", "REqueueue", "requeressed", "REqueueuated", "requeue", "Requeueue", "Requeueanted", "requesued", "requeueanted", "reketue", "reketued", "requeuer", "requeuated", "Requeue", "requed", "REqueuated", "reketilled", "REqueue", "REqueueued", "requesuated", "requeilled", "Requeuer", "Requeueuer", "crequesressed", "repeued", "requerilled", "requeueilled", "requeueuated", "REqueueilled", "requated", "crequesued", "repeue", "requeueuer", "reqressed", "reqanted", "crequesuated", "requer"]}}
{"project": "qemu", "commit_id": "c9fc50839863f05545caca92bb9fbead8b1c91bd", "target": 0, "func": "static void dump_human_image_check(ImageCheck *check)\n\n{\n\n    if (!(check->corruptions || check->leaks || check->check_errors)) {\n\n        printf(\"No errors were found on the image.\\n\");\n\n    } else {\n\n        if (check->corruptions) {\n\n            printf(\"\\n%\" PRId64 \" errors were found on the image.\\n\"\n\n                \"Data may be corrupted, or further writes to the image \"\n\n                \"may corrupt it.\\n\",\n\n                check->corruptions);\n\n        }\n\n\n\n        if (check->leaks) {\n\n            printf(\"\\n%\" PRId64 \" leaked clusters were found on the image.\\n\"\n\n                \"This means waste of disk space, but no harm to data.\\n\",\n\n                check->leaks);\n\n        }\n\n\n\n        if (check->check_errors) {\n\n            printf(\"\\n%\" PRId64 \" internal errors have occurred during the check.\\n\",\n\n                check->check_errors);\n\n        }\n\n    }\n\n\n\n    if (check->total_clusters != 0 && check->allocated_clusters != 0) {\n\n        printf(\"%\" PRId64 \"/%\" PRId64 \"= %0.2f%% allocated, %0.2f%% fragmented\\n\",\n\n        check->allocated_clusters, check->total_clusters,\n\n        check->allocated_clusters * 100.0 / check->total_clusters,\n\n        check->fragmented_clusters * 100.0 / check->allocated_clusters);\n\n    }\n\n\n\n    if (check->image_end_offset) {\n\n        printf(\"Image end offset: %\" PRId64 \"\\n\", check->image_end_offset);\n\n    }\n\n}\n", "idx": 26595, "substitutes": {"check": ["run", "cmp", "see", "clean", "operation", "make", "status", "valid", "command", "sync", "ctl", "pop", "call", "write", "clear", "complete", "task", "info", "work", "scale", "save", "link", "step", "draw", "exec", "http", "checked", "store", "search", "condition", "config", "entry", "error", "good", "send", "cp", "close", "add", "transform", "fail", "handle", "CHECK", "lock", "warn", "help", "full", "update", "read", "ck", "Check", "get", "comment", "delete", "filter", "view", "form", "show", "com", "process", "print", "test", "stat", "control", "parse", "block", "match", "upload", "ok", "look", "commit", "report", "find", "list", "cache", "set", "image", "scan", "req", "start", "post", "load", "query", "import", "loop"]}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float32 int32_to_float32( int32 a STATUS_PARAM )\n\n{\n\n    flag zSign;\n\n\n\n    if ( a == 0 ) return 0;\n\n    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );\n\n    zSign = ( a < 0 );\n\n    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );\n\n\n\n}\n", "idx": 26599, "substitutes": {"STATUS_PARAM": ["STATUS_ARAM", "STATUS_ARAMS", "STATUS_PM", "STATUS_PAM", "STATUS_ARAR", "STATUS_ARM", "STATUS_PAR", "STATUS_VAM", "STATUS_PARAR", "STATUS_PARAMS", "STATUS_VAMS", "STATUS_VM", "STATUS_PAMS", "STATUS_VAR", "STATUS_PARM"], "zSign": [" zSIGN", "ziForm", "zsign", "zhMod", "zhsign", "izsign", "oSIGN", " zRank", "ZSign", "zhSign", "izSIGN", "zhRank", " zIncre", "zMod", "gzsign", "ziIncre", "ozIncre", "ziSign", "ZMod", "osign", "tsign", "zRank", "ziMask", "gzSign", "ozSign", "zhSIGN", "zMask", " zMask", "izSign", " zMod", "zhMask", "izMask", "ozMask", "ozForm", "gzSIGN", "tSign", " zsign", "zIncre", " zForm", "gzMask", "ZRank", "zForm", "tSIGN", "oSign", "zSIGN"]}}
{"project": "qemu", "commit_id": "58892b447f0ffcd0967bc6f1bcb40df288ebeebc", "target": 1, "func": "static int vfio_start_eventfd_injection(VFIOINTp *intp)\n\n{\n\n    int ret;\n\n\n\n    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\");\n\n    }\n\n    return ret;\n\n}\n", "idx": 26620, "substitutes": {"intp": [" intpt", "acp", " intpc", "inetpt", "intpt", "interpa", "interp", "intpc", "inetpid", "extpa", "extpt", " intpa", "acpc", "interpc", "intpa", "inetpa", "intpid", "acm", " intpid", "extpid", "interm", " intm", "extp", "intm", "inetp", "acpa"], "ret": ["f", "prop", "inter", "alt", "ter", "lit", "red", "bool", "not", "out", "reset", "RET", "rm", "re", "ref", "len", "status", "mb", "try", "__", "gt", "def", "cont", "ry", "reg", "mem", "cat", "det", "backed", "deg", "rem", "j", "et", "print", "leg", "rt", "back", "nt", "rets", "str", " RET", "ft", " Ret", "val", "flag", "mt", "Ret", " alt", "tr", "gc", "t", "elt", "Return", "res"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int bt_hid_in(struct bt_hid_device_s *s)\n\n{\n\n    USBPacket p;\n\n\n\n    p.pid = USB_TOKEN_IN;\n\n    p.devep = 1;\n\n    p.data = s->datain.buffer;\n\n    p.len = sizeof(s->datain.buffer);\n\n    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);\n\n\n\n    return s->datain.len;\n\n}\n", "idx": 26642, "substitutes": {"s": ["ms", "as", "sb", "ops", "ins", "os", "comm", "fs", "v", "rs", "c", "ses", "ds", "hs", "n", "changes", "cs", "sts", "ares", "services", "aws", "sw", "set", "vs", "S", "als", "js", "bs", "ss", "a", "is", "b", "ats", "ns", "ts", "ps", "l", "ies", "stats", "qs", "south", "st", "es", "its", "gs", "less", "sv", "parts", "h", "t", "ls", "m", "sq"], "p": ["ping", "pm", "i", "pre", "perm", "pb", "op", "pc", "d", "pad", "vp", "w", "part", "c", "pp", "at", "g", "r", "pers", "cp", "n", "resp", "j", "ap", "pe", "rep", "np", "up", "a", "b", "l", "php", "ps", "ip", "post", "y", "pa", "wp", "tp", "bp", "sp", "fp", "pkg", "P", "lp", "t", "h", "jp", "m", "v", "q", "tap", "pt", "parse"]}}
{"project": "qemu", "commit_id": "1453e6627d19a8d6d54480c6980f5cef5dfc6833", "target": 0, "func": "void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#else\n\n    nmi_monitor_handle(monitor_get_cpu_index(), errp);\n\n#endif\n\n}\n", "idx": 26653, "substitutes": {"errp": ["rrr", "rrpress", "err", " errP", "errpress", "arrr", "errP", " errr", "errbp", "errr", "arrP", " errbp", "arrp", " erpress", "rrp", " err", "erp", " errpress", "arrbp", " erp", "erP", "erbp"], "cs": ["sys", "css", "ms", "cf", "fs", "pc", "rs", "Cs", "c", "rc", "ds", "hs", "ck", "ks", "ec", "caps", "cp", "sc", "cus", "s", "cks", "sts", "ctx", "ics", "js", "bs", "ss", "wcs", "ats", "ns", "ts", "CS", "ps", "ims", "acs", "cas", "qs", "its", "gs", "ys", "ls", "cc", "ces", "ows"], "cpu": ["kernel", "bench", "chip", "cam", "cu", "nn", "boot", "ork", "pc", "us", "c", "core", "phy", "gpu", "nic", "sky", "clock", "ck", "prof", "cmd", "pixel", "cp", "linux", "cow", "cum", "cache", "hz", "pid", "node", "util", "ctx", "np", "process", "runner", "processor", "lib", "CPU", "px", "pu", "aux", "net", "gc", "pkg", "proc", "socket", "aq", "hw"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,\n\n                            void *l3hdr, size_t l3hdr_len,\n\n                            size_t l3payload_len,\n\n                            size_t frag_offset, bool more_frags)\n\n{\n\n    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {\n\n        uint16_t orig_flags;\n\n        struct ip_header *iphdr = (struct ip_header *) l3hdr;\n\n        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;\n\n        uint16_t new_ip_off;\n\n\n\n        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);\n\n        assert((frag_off_units & ~IP_OFFMASK) == 0);\n\n\n\n        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);\n\n        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);\n\n        iphdr->ip_off = cpu_to_be16(new_ip_off);\n\n        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);\n\n    }\n\n}\n", "idx": 26663, "substitutes": {"l2hdr": ["l1thaddr", "l2hpar", "l3hint", "l3hst", "l2Hst", "l1hpar", "l1haddr", "l2ohdr", "l3hdr", "l2ohint", "l2phdr", "l3phDR", "l1thdr", "l2hsaddr", "l2ohst", "l2phaddr", "l3hDR", "l2hint", "l2phDR", "l2phint", "l1hdr", "l2hst", "l2thpar", "l2Hdr", "l2ohDR", "l3phst", "l1thDR", "l2hsdr", "l2hsDR", "l2hspar", "l2HDR", "l2hDR", "l3phint", "l2thdr", "l3phdr", "l1thpar", "l1hDR", "l2thDR", "l2phst", "l2haddr", "l2phpar", "l2thaddr", "l2Hint"], "orig_flags": ["ipityacts", "origiredflags", "orig_args", "orig00flags", "origlyargs", "orig___flags", "ipityfeatures", "orig_acts", "origiredweights", "cmp_weights", "orig_bits", "cmp_faces", "ip_flags", "orig__features", "origityweights", "cmpiredargs", "orig_offs", "ip_features", " orig_offs", "ip_bits", "cmp_args", "orig__bits", "orig7flag", "orig_flag", "cmpiredflags", "orig00flag", "orig___acts", "origitybits", "orig___bits", "orig__flags", "ip_acts", "origlyweights", "cmpiredweights", "origiredargs", "origityflags", "orig_faces", "origityacts", "origiredfaces", "ipitybits", "cmp_flags", "orig__acts", "origityfaces", "cmpiredfaces", " orig_flag", "origityargs", "origlyflags", "ipityflags", "origityfeatures", "orig7offs", "orig00offs", "orig_features", "orig7flags", "origlyfaces", "orig_weights", "orig___features"], "iphdr": ["ihd", "phyder", "iphd", "ihtr", "phdr", "ihbr", "phydr", "ihstr", "ericder", "ipd", "phstr", "phder", "phbr", "iphstr", "ophdat", "aphdr", "ipder", "ipbr", "aphder", "ihdr", "ericd", "ericdr", "phyd", "iphdat", "phd", "ericdro", "aphtr", "ihdro", "iphbr", "iphdro", "ihder", "ophtr", "ipstr", "iphtr", "aphdat", "ihdat", "ipdr", "phydro", "iphder", "ophder", "ophdr"], "new_ip_off": ["new_ipxon", "new_op_off", "new_ip_pos", "new_op_on", "new_op_offset", "new_ipablefun", "new_ipableon", "new_ip_fun", "new_IP_on", "new_ipxoff", "new_ipableoff", "new_ip_offset", "new_IP_off", "new_ip_on", "new_IP_fun", "new_ipxpos"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)\n\n{\n\n    return float32_sub(a, b, &env->ucf64.fp_status);\n\n}\n", "idx": 26671, "substitutes": {"a": ["i", "as", "sa", "na", "ca", "ata", "ma", "sta", "d", "\u00e0", "ia", "at", "A", "act", "apa", "aa", "ar", "s", "ao", "an", "area", "ap", "au", "up", "ity", "da", "am", "ach", "ac", "ba", "la", "aaa", "ae", "ab", "oa", "aj"], "b": ["f", "bb", "fb", "i", "sb", "br", "nb", "d", "bc", "c", "B", "g", "db", "p", "bis", "s", "ob", "blue", "j", "bar", "bs", "eb", "bi", "ba", "base", "rb", "bp", "by", "ib", "ab", "be", "v"], "env": ["block", "stack", "context", "engine", "server", "tx", "obj", "chart", "ev", "conn", "code", "viron", "vp", "config", "En", "er", "dev", "mem", "conf", "ec", "ah", "db", "cb", "buf", "ctx", "te", "vs", "environment", "shell", "req", "nv", "txt", "worker", "window", "e", "EN", "kw", "en", "sp", "qv", "end", "jp", "manager", "proc", "v", "hw"]}}
{"project": "qemu", "commit_id": "c6a6a5e3bb7120e1eb33eca6364a290229c1e72e", "target": 0, "func": "do_cksum(uint8_t *dp, uint8_t *de)\n\n{\n\n    unsigned int bsum[2] = {0, 0}, i, sum;\n\n\n\n    for (i = 1; dp < de; bsum[i^=1] += *dp++)\n\n        ;\n\n    sum = (bsum[0] << 8) + bsum[1];\n\n    sum = (sum >> 16) + (sum & 0xffff);\n\n    return ~(sum + (sum >> 16));\n\n}\n", "idx": 26673, "substitutes": {"bsum": ["bsub", "bitsumm", " basesrub", "cksumm", "gsul", "bissum", " basesumm", "nsum", "thsub", " basesum", "bitssum", "BSsum", "bisum", "bsam", "pssum", "gsus", "BSumm", "bisumm", "psumm", "gsum", "cksumer", "bsumer", "bpsum", "bsul", "BSum", "bpssum", "bpsumm", "nsub", " basessum", "thsus", "bitsum", "bpsam", "cksam", "bsrub", "bitsam", "thsum", "thsul", "gsub", "ckssum", "BSrub", "bitsumer", "bssum", "nsul", "bisumer", "psum", "nsus", "bsumm", "cksum", "bsus", "psrub"], "i": ["it", "iat", "ic", "x", "ui", "multi", "adr", "d", "pi", "pp", "id", "gi", "I", "n", "p", "phi", "di", "j", "ai", "mi", "ii", "li", "ti", "ind", "php", "attr", "ip", "ij", "bi", "y", "ci", "e", "iter", "by", "xi", "si", "im", "t", "index", "m", "ix"], "sum": ["pack", "sa", "match", "out", "mix", "cal", "cmp", "hash", "uf", "tu", "status", "score", "temp", "v", "us", "sam", "Sum", "result", "zero", "mem", "ul", "mm", "um", "report", "comment", "n", "count", "cum", "cache", "sc", "add", "sh", "new", "vol", "ut", "set", "sim", "go", "sort", "j", "mod", "au", "total", "doc", "acc", "html", "share", "size", "nt", "mean", "st", "num", "un", "su", "trace", "si", "all", "index", "max", "tmp", "aw", "mu", "summary"]}}
{"project": "qemu", "commit_id": "100f738850639a108d6767316ce4dcc1d1ea4ae4", "target": 0, "func": "static void ics_simple_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ICSState *ics = ICS_SIMPLE(dev);\n\n\n\n    if (!ics->nr_irqs) {\n\n        error_setg(errp, \"Number of interrupts needs to be greater 0\");\n\n        return;\n\n    }\n\n    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));\n\n    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);\n\n\n\n    qemu_register_reset(ics_simple_reset, dev);\n\n}\n", "idx": 26680, "substitutes": {"dev": ["sd", "sys", "device", "ad", "Device", "tech", "dis", "cam", " Dev", "ev", "stick", "os", "iv", "d", "pad", "adv", "w", "def", "pi", " device", "disk", "sky", "debug", "ds", "spec", "DEV", "ver", "ve", "go", "devices", "ctx", "vs", "scan", "data", "test", "de", "nt", "dd", "des", "Dev", "serial", "exec", "ptr", " devs", "v", "env", "name", "hw"], "errp": ["usrps", "errps", "usrp", " errpa", "Erpc", "errping", "rrping", " errpc", "usrpa", "Erp", " errping", "rrp", "errpc", "rrps", "errpb", " errpb", "rrpc", "rrpb", "Erpb", "rrpa", " errps", "usrping", "errpa"], "ics": ["ic", "irc", "icons", "css", "ric", "isch", "args", "ik", "ix", "isk", "ick", "ins", "rs", " ic", "icc", "nic", "ds", "mic", "ec", "ks", "iris", "his", "las", "ices", "cus", "ents", "cs", "bits", "isc", "iss", "vs", "nz", "js", "bs", "ICS", "xs", "cons", "is", "ats", "wcs", "ns", "ts", "oc", "ims", "eric", "acs", "rics", "ox", "qs", "stats", "ico", "ps", "px", "its", "IC", "ris", "ires", "ls", "checks", "icks", "pic", "ips"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_flush(VncState *vs)\n\n{\n\n    if (vs->output.offset)\n\n\tvnc_client_write(vs);\n\n}\n", "idx": 26701, "substitutes": {"vs": ["vm", "ms", "ov", "Vs", "values", "eps", "ins", "vd", "fs", "v", "rs", "vp", "us", "ds", "hs", "ks", "s", "cs", "sts", "vr", "iss", "bs", "ss", "VS", "ts", "ns", "vc", "ps", "ims", "vals", "stats", "qs", "es", "its", "gs", "bp", "sv", "obs", "atts", "ls", "vt"]}}
{"project": "qemu", "commit_id": "bab482d7405f9fe3cac9c213d60f9ca9442c047b", "target": 0, "func": "static void do_subchannel_work(SubchDev *sch, ORB *orb)\n\n{\n\n\n\n    SCSW *s = &sch->curr_status.scsw;\n\n\n\n    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {\n\n        sch_handle_clear_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {\n\n        sch_handle_halt_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {\n\n        /* Triggered by both ssch and rsch. */\n\n        sch_handle_start_func(sch, orb);\n\n    } else {\n\n        /* Cannot happen. */\n\n        return;\n\n    }\n\n    css_inject_io_interrupt(sch);\n\n}\n", "idx": 26711, "substitutes": {"sch": ["rys", "sd", "sys", "ch", "igm", "ssh", "css", "sb", "shop", "isch", "chan", "Sch", "chip", "ih", "chid", "sol", "oss", "tk", "chu", "sam", "ech", "rh", "hs", "urus", "sl", "mk", "roth", "wk", "tek", "kh", "sc", "soc", "gr", "sh", "kr", "disc", "shed", "sche", "sw", "osc", "ksh", "sk", "ss", "cfg", "gh", "tg", "cht", "https", "orsche", "cr", "sp", "sg", "ich", "hed", "her", "eng", "ssl"], "orb": ["orf", "ocl", "orm", "rib", "emb", "orp", "urb", "mb", "gob", "arb", "nut", "rob", "orn", "ior", "org", "ob", "bol", "ori", "vor", "osp", "ore", "orbit", "eb", "orget", "erb", "ogg", "usb", "obb", "opl", "om", "bj", "absor", "rab", "obar", "umb", "mol", "etc", "mor"], "s": ["f", "sd", "sys", "sb", " ss", "sis", "os", "comm", "fs", "sol", "sports", "rs", "us", "w", "c", "ex", "sam", "ds", "hs", "sl", "g", "spec", "n", "sc", "sh", "cs", "sts", "sw", "set", "vs", "S", "js", "ss", "so", "is", "ts", "ns", "ps", "y", "stats", "z", "qs", "es", "sp", "gs", "sv", "less", "tp", "ass", "h", "ls", "m", "conf"]}}
{"project": "qemu", "commit_id": "e25cad6921ef78c8e2b7a4f59b03545bd675a9ad", "target": 1, "func": "static int sd_snapshot_delete(BlockDriverState *bs,\n\n                              const char *snapshot_id,\n\n                              const char *name,\n\n                              Error **errp)\n\n{\n\n    unsigned long snap_id = 0;\n\n    char snap_tag[SD_MAX_VDI_TAG_LEN];\n\n    Error *local_err = NULL;\n\n    int fd, ret;\n\n    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    unsigned int wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN, rlen = 0;\n\n    uint32_t vid;\n\n    SheepdogVdiReq hdr = {\n\n        .opcode = SD_OP_DEL_VDI,\n\n        .data_length = wlen,\n\n        .flags = SD_FLAG_CMD_WRITE,\n\n    };\n\n    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;\n\n\n\n    if (!remove_objects(s)) {\n\n        return -1;\n\n    }\n\n\n\n    memset(buf, 0, sizeof(buf));\n\n    memset(snap_tag, 0, sizeof(snap_tag));\n\n    pstrcpy(buf, SD_MAX_VDI_LEN, s->name);\n\n    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);\n\n    if (ret || snap_id > UINT32_MAX) {\n\n        error_setg(errp, \"Invalid snapshot ID: %s\",\n\n                         snapshot_id ? snapshot_id : \"<null>\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (snap_id) {\n\n        hdr.snapid = (uint32_t) snap_id;\n\n    } else {\n\n        pstrcpy(snap_tag, sizeof(snap_tag), snapshot_id);\n\n        pstrcpy(buf + SD_MAX_VDI_LEN, SD_MAX_VDI_TAG_LEN, snap_tag);\n\n    }\n\n\n\n    ret = find_vdi_name(s, s->name, snap_id, snap_tag, &vid, true,\n\n                        &local_err);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    fd = connect_to_sdog(s, &local_err);\n\n    if (fd < 0) {\n\n        error_report_err(local_err);\n\n        return -1;\n\n    }\n\n\n\n    ret = do_req(fd, s->bs, (SheepdogReq *)&hdr,\n\n                 buf, &wlen, &rlen);\n\n    closesocket(fd);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    switch (rsp->result) {\n\n    case SD_RES_NO_VDI:\n\n        error_report(\"%s was already deleted\", s->name);\n\n    case SD_RES_SUCCESS:\n\n        break;\n\n    default:\n\n        error_report(\"%s, %s\", sd_strerror(rsp->result), s->name);\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 26725, "substitutes": {"bs": ["bb", "sb", "pb", "bl", "lbs", "os", "fs", "bc", "rs", "BS", "ds", "hs", "bm", "bos", "bis", "cs", "sts", "bits", "vs", "bg", "js", "ss", "b", "ts", "ns", "ps", "bi", "bd", "bh", "bt", "its", "gs", "bp", "obs", "ls", "blog"], "snapshot_id": ["snapot2ID", "snapsnap_no", "snapshot__id", "snapot_name", "snapshot_no", "snapshot_tag", "snapshot_name", "snapot2id", "snapsnap_info", "snapshot_ref", "snapot2data", "snapshot__name", "snapshot2data", "snapshot2id", "snapshot___name", "snapsnap_tag", "snapsnap_ids", "snapot_id", "snapot_ID", "snapshot___id", "snapshot___data", "snapshot_data", "snapshot_ids", "snapshot2no", "snapshot_info", "snapshot2name", "snapshot2ID", "snapot2name", "snapshot__tag", "snapsnap_name", "snapshot__ref", "snapshot___ID", "snapsnap_id", "snapsnap_data", "snapot_data", "snapshot_ID", "snapsnap_ref"], "name": ["run", "class", "type", "space", "dir", "nm", "zone", "ref", "status", "nam", "named", "w", "part", "value", "id", "word", "error", "title", "mem", "create", "path", "group", "comment", "cmd", "n", "alias", "prefix", "tag", "b", "data", "size", "ename", "NAME", "key", "base", "ame", "version", "snap", "Name", "package", "label", "table", "description", "format", "no", "filename", "names"], "errp": [" errpa", "errps", "cerpc", " errP", "errP", "cerp", " errpc", "errorps", "warnP", "errpc", "erp", "cerps", "errorp", "warnpa", "warnp", "errorpc", "erP", "errorP", "cerP", "erpa", " errps", "errpa"], "snap_tag": ["snapjid", "snapPname", " snap2tag", "aptmmtag", "apt_hash", " snap_cat", "shot_pack", " snap_field", "snapmmtoken", "snaplyhash", "snap_mt", "snaptname", "shot_mt", "shot_name", "snapjtag", "snapptvar", "snapttags", "aptmmhash", "snaplytag", "snapPlog", "snap_name", "snapmmtag", "apt_tag", "snap_tags", "snap2tags", "snapPvar", "snapmmid", "snap_string", "shot_string", "snapjcard", "snapisthash", "snap_id", "snap_card", "shot_tag", "aptmmid", "snapisttag", "snap_token", "snaplytoken", "snap2tag", "shot_card", "snap_hash", "snappttag", " snap2cat", "snap_var", "snap_pack", "snap_field", "apt_id", "shot_var", "snapptlog", " snap_hash", "snap_log", "shot_id", "aptmmtoken", "snapjmt", "shot_log", "snapistname", "apt_token", "snaplyid", "snaptcat", "snapmmhash", " snap_string", "snapthash", "snap_cat", "snapptname", " snap_tags", " snap_name", " snap2tags", "snapPtag", "snap2cat", "snapttag"], "local_err": [" local_bar", "local___arr", "localErusr", "localErerr", "localaxybar", "localaxyerr", "foreign_error", "local_notice", " local___arr", "local____err", "local_usr", "local_msg", "foreignErerror", "foreign_usr", " local___msg", "foreignErnotice", "foreign_err", "local_arr", "local____notice", "local___msg", "local____error", "localErnotice", " local_msg", "local___err", "localaxyres", "local____usr", "localErerror", " local_res", "foreignErusr", "local_error", " local___err", " local_arr", "local_res", "foreign_notice", "foreignErerr", "local_bar"], "fd": ["f", "ld", "af", "dir", "nd", "ff", "fa", " dur", "fee", "fs", "d", " fut", "fr", "cd", "id", "bf", "ds", " ff", " fin", "fin", "fi", "db", "lf", "fn", "dt", "pid", " fid", "df", "td", "gd", "file", "dl", "dd", "dat", "bd", "fc", "ud", "fp", "FD", "fat", " f", " fs"], "ret": ["it", "alt", "ter", "lit", "not", "bool", "out", "err", "reset", "ll", "RET", "rm", "ref", "re", "success", "len", "try", "status", "gt", "def", "done", "id", "result", "rev", "cont", "nl", "mem", "lt", "fin", "fi", "db", "det", "deg", "dt", "cert", "new", "cb", "set", "rem", "j", "failed", "complete", "leg", "rt", "back", "nt", "fun", "nat", "rets", "ft", "tif", "val", "flag", "mt", "Ret", "gc", "tr", " Ret", "elt", "ptr", "final", "t", "vet", "res"], "buf": ["fb", "prop", "cur", "batch", "pb", "tx", "cam", "err", "ref", "queue", "uf", "br", "ff", "box", "vp", "w", "rc", "rev", "dc", "buffer", "mem", "seq", "act", "r", "cmd", "db", "img", "cb", "bytes", "ctx", "bag", "vec", "raw", "doc", "b", "data", "desc", "wb", "ba", "aka", "txt", "window", "bin", "bt", " buffer", "rb", "cap", "Buffer", "buff", "off", "pkg", "gc", "tmp", "v", "cv"], "s": ["sys", "sn", "as", "sa", "sb", "ins", "os", "fs", "rs", "c", "ses", "ds", "hs", "g", "n", "p", "bis", "sc", "state", "cs", "sts", "bits", "vs", "S", "js", "ss", "settings", "a", "is", "b", "ats", "ts", "ns", "ps", "sm", "stats", "st", "es", "its", "sp", "gs", "sv", "h", "t", "ls", "v", "socket", "conf"], "vid": ["wid", " virt", " tx", " pos", "vd", "len", " VID", "v", " rev", "tv", "visible", "id", "rev", "virt", "rid", "var", "uid", "seq", " wid", "wat", "dt", "pid", "vis", " pid", " resid", "vr", "irt", "vs", " av", " rid", " sid", "oid", " tv", "lan", "sid", "vc", "cas", "lang", "val", " tid", " guid", "gc", "vt", "uv", "mid", " vis", "bid", " lid", "VID", " vers"], "rsp": ["RSP", "rcSP", " rsw", "Rtp", "rctp", "rsw", " rtp", "rcsp", "rcsw", "rSP", "rtp", "Rsp", " rSP", "Rsw"]}}
{"project": "qemu", "commit_id": "ebd9fbd7e102c533143c2c8372312b75c2b2678a", "target": 1, "func": "static int block_save_iterate(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n    int64_t last_ftell = qemu_ftell(f);\n\n\n\n    DPRINTF(\"Enter save live iterate submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* control the rate of transfer */\n\n    blk_mig_lock();\n\n    while ((block_mig_state.submitted +\n\n            block_mig_state.read_done) * BLOCK_SIZE <\n\n           qemu_file_get_rate_limit(f)) {\n\n        blk_mig_unlock();\n\n        if (block_mig_state.bulk_completed == 0) {\n\n            /* first finish the bulk phase */\n\n            if (blk_mig_save_bulked_block(f) == 0) {\n\n                /* finished saving bulk on all devices */\n\n                block_mig_state.bulk_completed = 1;\n\n            }\n\n            ret = 0;\n\n        } else {\n\n            /* Always called with iothread lock taken for\n\n             * simplicity, block_save_complete also calls it.\n\n             */\n\n            qemu_mutex_lock_iothread();\n\n            ret = blk_mig_save_dirty_block(f, 1);\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        blk_mig_lock();\n\n        if (ret != 0) {\n\n            /* no more dirty blocks */\n\n            break;\n\n        }\n\n    }\n\n    blk_mig_unlock();\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n    return qemu_ftell(f) - last_ftell;\n\n}\n", "idx": 26726, "substitutes": {"f": ["fx", "fb", "af", "x", "ef", "alf", "cf", "inf", "o", "fw", "uf", "temp", "ff", "fs", "d", "tf", "ent", "w", "c", "fr", "bf", "fi", "g", "fm", "r", "lf", "fn", "p", "s", "fed", "form", "rf", "file", "xf", "b", "l", "fac", "z", "fd", "fc", "e", "fo", "sf", "ft", "u", "fp", "t", "h", "q", "m", "v", "F", "conf"], "opaque": ["opcode", " opz", "opencode", "ipaque", "openz", "opos", "ipcode", "opz", "ipos", "ipz", " opos", "openos", "openaque", " opcode"], "ret": ["run", "alt", "ter", "ll", "jump", "pub", "status", "att", "valid", "cont", "lt", "secure", "r", "arr", "new", "rem", "leg", "rt", "expr", " RET", " Ret", "mt", "Ret", "ptr", "oret", "inter", "rest", "obj", "rm", "re", "code", "try", "plain", "gt", "rev", "cat", "det", "git", "backed", "desc", "fun", "net", "vt", "final", "locked", "sys", "reset", "RET", "def", " fut", "ry", "pret", "print", "back", "dr", "addr", "url", "tr", "elt", "tmp", "vet", "str", "lit", "out", "red", "ref", "len", "success", "ber", "result", "reg", "ext", "cmd", "deg", "cert", "resp", "cb", "usr", "nz", "nt", "rets", "txt", "ft", "aux", "val", "flag", " alt", "t", "jp", "arg", "Return", "res"]}}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)\n\n{\n\n    int i, n, n2;\n\n    float alpha;\n\n\n\n    n  = 1 << ln;\n\n    n2 = n >> 1;\n\n\n\n    FF_ALLOC_OR_GOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fft_alloc_fail);\n\n    FF_ALLOC_OR_GOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fft_alloc_fail);\n\n\n\n    for (i = 0; i < n2; i++) {\n\n        alpha     = 2.0 * M_PI * i / n;\n\n        mdct->costab[i] = FIX15(cos(alpha));\n\n        mdct->sintab[i] = FIX15(sin(alpha));\n\n    }\n\n\n\n    return 0;\n\nfft_alloc_fail:\n\n    mdct_end(mdct);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 26730, "substitutes": {"avctx": [" avctl", "svcontext", "averctx", " avcu", "cvctl", "avctl", "avercontext", "avercu", "cvctx", "vertx", "avcu", "vctl", "avertx", "vercontext", "avconn", "vconn", " avgc", " avconn", "avtx", "avergc", "vcontext", "verctx", " avtx", "vctx", "svconn", "vercu", "averconn", "avgc", "cvconn", "cvcontext", " avcontext", "avcontext", "svgc", "svctx"], "mdct": ["mdcrit", "mpt", "mdt", "mdtt", "mdect", "dmcat", " mdnt", "cmdkt", "mdCT", "mnnt", "mdcat", " mdkt", "cmdt", "cmditt", " mditt", "mnct", "cmdct", "cmdwt", "cmdnt", "mdlt", "mnitt", "mnoc", " mdlt", "mncont", " mdCT", "mntt", "dmct", "cmdect", "cmdcrit", " mdtt", "mpnt", "cmdcont", "mnCT", "mpct", "mnect", "dmcrit", "dmnt", "cmdlt", "cmdtt", "dmCT", "mnt", "mncrit", "mnkt", "mnwt", "mpwt", "mditt", "cmdCT", "mdcont", "mpcont", "mdoc", "cmdcat", "mdkt", "mncat", " mdoc", " mdcont", " mdect", "cmdoc", "mdnt", "dmect", "mdwt", "mplt"], "ln": ["lvl", "sn", " nm", "nn", "lr", "len", "nb", "lag", " ni", "nl", "margin", "ul", "tn", "lf", "fn", "lines", " len", "pn", "lin", "span", "li", "bn", "line", "l", "ns", "weight", "vl", "oln", "dl", "loc", "ind", "wn", " lvl", "mn", "con", "gn", " fn", "label", "kl", "ls", "rn", " l"], "i": ["f", "ji", "it", "ic", "x", "batch", "ui", "multi", "\u0438", "ki", "point", "o", "ik", "status", "ie", "pi", "c", " ii", "ini", "index", "ice", "ri", "um", "fi", "gi", "I", "p", "phi", "series", "di", "zi", "sim", "j", "ai", "span", "mi", "ii", "li", "print", "chain", "is", "ti", "ind", "info", "ip", "bi", "y", "ish", "ij", "ci", "uri", "iu", " I", "xi", "si", "all", "q", "m", "v", "qi", "this", "ei", "ix"], "n": ["f", "sn", "na", "x", "o", "nn", "nm", "network", "len", "nb", "d", "nan", "c", "k", "nl", "g", "p", "fn", "nc", "cn", "j", "an", "nu", "np", "ne", "b", "l", "ns", "size", "nt", "mn", "z", "dn", "N", "num", "gn", "en", "ni", "t", "m", "v"], "n2": [" ntwo", "N2", "an2", "nc256", "n3", "nc1", "dntwo", " n1", "nt02", "N256", "n256", "antwo", "i62", "nt62", "dn2", "nt2", "nttwo", "N1", "an02", "itwo", "n1", " n02", " n3", "l2", "n02", "ntwo", "ltwo", "i02", "N02", "Ntwo", "nc2", "l02", "i2", "an3", "l1", " n62", "n62", "l3", " n256"], "alpha": ["Delta", "xa", "mad", "angle", " gamma", " \u03b1", "al", "power", "aff", "ma", "fa", "ph", "pp", "pi", "asc", "ia", "ppa", "sha", " amp", "igma", "balance", "lambda", "beta", "phi", "upper", "ace", "alias", "p", "Alpha", "prefix", "acl", "ta", "instance", "qa", "acc", " delta", "a", "face", "eta", "hi", "prime", "ac", "weight", "scale", "info", "ati", "la", "HA", "capital", "factor", "iso", "si", "pha", "alph", "ho", "ani"]}}
{"project": "qemu", "commit_id": "ed1dda53d073acdb52889aa30f9d251061b053bd", "target": 1, "func": "static always_inline void gen_intermediate_code_internal (CPUState *env,\n\n                                                          TranslationBlock *tb,\n\n                                                          int search_pc)\n\n{\n\n#if defined ALPHA_DEBUG_DISAS\n\n    static int insn_count;\n\n#endif\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    target_ulong pc_start;\n\n    uint32_t insn;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj = -1;\n\n    int ret;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    ctx.pc = pc_start;\n\n    ctx.amask = env->amask;\n\n#if defined (CONFIG_USER_ONLY)\n\n    ctx.mem_idx = 0;\n\n#else\n\n    ctx.mem_idx = ((env->ps >> 3) & 3);\n\n    ctx.pal_mode = env->ipr[IPR_EXC_ADDR] & 1;\n\n#endif\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_icount_start();\n\n    for (ret = 0; ret == 0;) {\n\n        if (unlikely(!TAILQ_EMPTY(&env->breakpoints))) {\n\n            TAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n                if (bp->pc == ctx.pc) {\n\n                    gen_excp(&ctx, EXCP_DEBUG, 0);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.pc;\n\n                gen_opc_instr_start[lj] = 1;\n\n                gen_opc_icount[lj] = num_insns;\n\n            }\n\n        }\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n#if defined ALPHA_DEBUG_DISAS\n\n        insn_count++;\n\n        LOG_DISAS(\"pc \" TARGET_FMT_lx \" mem_idx %d\\n\",\n\n                  ctx.pc, ctx.mem_idx);\n\n#endif\n\n        insn = ldl_code(ctx.pc);\n\n#if defined ALPHA_DEBUG_DISAS\n\n        insn_count++;\n\n        LOG_DISAS(\"opcode %08x %d\\n\", insn, insn_count);\n\n#endif\n\n        num_insns++;\n\n        ctx.pc += 4;\n\n        ret = translate_one(ctxp, insn);\n\n        if (ret != 0)\n\n            break;\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n            num_insns >= max_insns) {\n\n            break;\n\n        }\n\n\n\n        if (env->singlestep_enabled) {\n\n            gen_excp(&ctx, EXCP_DEBUG, 0);\n\n            break;\n\n\t}\n\n\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ret != 1 && ret != 3) {\n\n        tcg_gen_movi_i64(cpu_pc, ctx.pc);\n\n    }\n\n#if defined (DO_TB_FLUSH)\n\n    gen_helper_tb_flush();\n\n#endif\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    /* Generate the return instruction */\n\n    tcg_gen_exit_tb(0);\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = ctx.pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n#if defined ALPHA_DEBUG_DISAS\n\n    log_cpu_state_mask(CPU_LOG_TB_CPU, env, 0);\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(pc_start, ctx.pc - pc_start, 1);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n}\n", "idx": 26734, "substitutes": {"env": ["here", "hw", "context", "kernel", "esc", "ef", "tx", "store", "ev", "network", "Environment", "conn", "viron", "vp", "config", "def", "erd", "eh", "er", "event", "ew", "dev", "ec", "ah", "db", "cmd", "ten", "ve", "org", "msg", "usr", "set", "sw", "esp", "et", "te", "vs", "environment", "inv", "setup", "cfg", "estate", "req", "nv", "addr", "worker", "window", "e", "kw", "en", "global", "hl", "sv", "param", "eng", "vt", "uv", "v", "exc", "end", "cv", "conf"], "tb": ["mv", " tfb", "ptch", "ttbr", "tsb", " tbt", "ptv", "tsbr", "mb", " tbc", " tp", "tv", " tch", " trb", "trb", "tfb", "tenfb", "ptb", "tenb", "ttch", "itbt", "tsp", "tenbc", "tch", "ttbt", "tbr", "tbt", "ttb", "ttrb", "mbc", " tv", "itb", "ptp", "itv", "tp", "ttv", "mfb", "itrb", "ptbr", "tenv", "tsv", "ttp", "tbc"], "search_pc": [" searchingpc", " searchingPC", " search_PC", "searchablepb", "search_PC", " search_pb", "match_PC", " search_proc", "search_pb", "searchingpc", "searchingpb", "searchingproc", "match_pc", " searchingproc", " searchingpb", "searchableproc", "searchablepc", "search_p", "searchablep", "match_proc", "match_p", "searchingPC", "searchablePC", "searchingp", "search_proc"], "insn_count": ["insns_size", "insns_count", "insns_c", "insns_cache", "insn_size", "insn_cache", "insn_c"], "ctx": ["cmp", "cu", "ca", "fw", "tc", "ctr", "crit", "p", "kh", "pg", "prefix", "proc", " k", "xs", "rt", "ct", "ns", "loc", "scope", "gc", "pkg", "max", "tx", "cf", "obj", "xy", "Context", "conn", "config", "gt", "tz", "ctrl", "func", "cp", "sc", "msg", "co", "handle", "timeout", "conv", "hw", "sys", " cx", "context", "x", "esc", "jac", "kt", "abc", "wd", "act", "kj", " cla", "acl", "cfg", "addr", "alloc", "kw", "xp", "tmp", "cc", "wx", "lc", "cv", "tk", " sc", " cc", "rc", "local", "ww", "cmd", "resp", "util", "cb", "np", "req", "xc", "ac", " context", "nt", "unc", "txt", "aux", "hl", "t", "jp", "index", "utils", "conf"], "ctxp": ["ktxp", "ectxt", "CTxp", "ctxy", "ktxt", "ctfp", "CTxy", "ctxt", "ectxy", "ectfp", "CTfp", "ktfp", "ktxy", "ectxp", "CTxt"], "pc_start": ["p_start", "PC_begin", "proc_begin", "pc2start", "PC_end", "pc_end", "pc_offset", "proc_start", "pc__begin", "PC_start", "pc__end", "proc_next", "pc_int", "p_end", "pc2int", "pc__offset", "proc_end", "pc2begin", "pc_begin", "pc2end", "pc__start", "pc_next", "PC_offset", "pc2offset", "pc2next", "p_int"], "insn": ["insc", "ainsns", "inn", "ingn", "ainsc", "psns", "ainsgn", "insns", "psgn", "inns", "inc", "ainsn", "psc", "insgn", "psn"], "gen_opc_end": ["gen_opr_ptr", "gen_opn_ptr", "gen_opc_ptr", "gen_opr_end", "gen_opr_buf", "gen_opc_buf", "gen_opc_start", "gen_opn_end", "gen_opn_start", "gen_opn_buf"], "bp": ["bb", "fb", "sb", "pb", "bl", "lbs", "bc", "nb", "hit", "vp", "tk", "bf", "bsp", "hp", "cmd", "cp", "p", "bis", "cb", "esp", "gp", "kb", "np", "bs", "bg", "b", "vc", "ps", "bi", "bj", "pa", "wp", "BP", "bh", "bt", "tp", "rb", "sp", "xp", "fp", "lp", "jp", "proc", "lb", "tap"], "j": ["ji", "f", "it", "my", "ch", "i", "x", "o", "obj", "ja", "jump", "br", "ju", "d", "v", "uj", " jump", "dj", "k", "g", "r", "n", "p", "jo", "kj", "gov", "J", "js", "ot", "next", "jc", "prime", "init", "l", "ij", "z", "json", "step", "str", "adj", "tr", "h", "jp", "q", "t", "index", "jj", "jl", "no", "aj"], "ret": ["alt", "out", "err", "reset", "ll", "RET", "ref", "re", "len", "try", "tf", "gt", "xt", "def", "ctr", "rev", "cont", "ry", "result", "true", "tn", "r", "ext", "cmd", "resp", "usr", "rem", "nz", "ert", "rt", "back", "nt", "fun", "rets", "ft", " Ret", "val", "mt", "biz", "Ret", "tr", "arg", "Return", "res"], "num_insns": ["num_inscs", "num_psn", "num_lsns", "num_nsxs", "num_synn", "num_insxs", "num_INScs", "num_inssts", "num_psns", "num_incs", "num_intersni", "num_synns", "num_insls", "num_nsn", "num_insn", "num_inn", "num_itscs", "num_INSns", "num_lssts", "num_inns", "num_itsns", "num_nsns", "num_synxs", "num_INSn", "num_insni", "num_intersn", "num_INSni", "num_lscs", "num_inls", "num_pscs", "num_insts", "num_itsn", "num_interscs", "num_lsn", "num_intersns", "num_pssts", "num_inxs", "num_inni", "num_itsls"], "max_insns": ["max_insxs", "max_ings", "max_incs", "max_alsans", "max_consans", "maxWinsgs", "max_linscs", "max_insons", "maxWconsns", "max_consgs", "max_inn", "max_ainscs", "max_isinns", "max_inons", "max_ainsls", "maxWconsn", "max_vsgs", "max_consns", "max_ainsports", "max_alsn", "max_nsns", "max_inxs", "max_isinxs", "max_nsqs", "max_linsls", "max_inls", "max_vsns", "max_insports", "maxWinsans", "maxWconsgs", "max_insls", "max_linsons", "max_alsgs", "max_inqs", "max_isings", "max_inports", "max_alsns", "max_isinn", "max_nscs", "maxWinsns", "max_ainsns", "max_inans", "max_ainsn", "max_consn", "max_insn", "max_vsxs", "maxWconsans", "max_ainsons", "max_insgs", "max_inscs", "max_linsqs", "maxWinsn", "max_linsns", "max_insqs", "max_inns", "max_nsn", "max_linsports", "max_insans", "max_linsn", "max_vsn"], "lj": ["lcbj", "lldj", "eljs", "slJ", "llkj", "lluj", "leftaj", "ldj", "lgh", "lbbj", "lijs", "leftuj", "lbj", "llgh", "laj", "lijl", "lajl", "lji", "elv", "sldj", "lJ", "eluj", "slth", "liuj", "lbgh", " lv", "elJ", " lbj", "slj", " luj", "lafr", "lfr", " lJ", "lth", "leftjs", "liji", "lv", "lcng", "llaj", "sluj", "slz", "lbkj", "lng", "lcjs", "lbjs", "elj", "liv", "sljs", "ludj", "luth", "likj", "llth", "llz", "ljl", "liz", " lng", " laj", "lbji", "lljs", "lbng", "llji", "lkj", " ljs", "llj", "lz", "ljs", "lifr", "eljl", "luj", "lij", "leftj", "ligh", "liJ", "elfr", "lcj", "elz", "llv", "laJ", "lujs"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "VncJob *vnc_job_new(VncState *vs)\n\n{\n\n    VncJob *job = g_malloc0(sizeof(VncJob));\n\n\n\n    job->vs = vs;\n\n    vnc_lock_queue(queue);\n\n    QLIST_INIT(&job->rectangles);\n\n    vnc_unlock_queue(queue);\n\n    return job;\n\n}\n", "idx": 26738, "substitutes": {"vs": ["sys", "ms", "Vs", "sb", "ops", " ss", "vd", "fs", "vp", "rs", "ds", "params", "ks", "s", "ves", "cs", "vr", "bs", "js", "vers", "ss", "is", "VS", "ns", "ts", "ps", "ims", "vals", "stats", "qs", "es", "gs", "sv", "obs", "ls", "vt", "uv", "ams", "v"], "job": ["run", "block", "photo", "batch", "out", "queue", "item", "some", "cell", "jobs", "entry", "cor", "journal", "sub", "result", "common", "command", "row", "cmd", "build", "db", "library", "state", "new", "ob", "node", "set", "j", "module", "order", "J", "bar", "Job", "coord", "up", "bug", "tag", "next", "process", "task", "image", "b", "py", "runner", "work", "worker", "vision", "bot", "pro", "figure", "package", "obs", " jobs", "jp", "sum", "m", "program"]}}
{"project": "qemu", "commit_id": "0c9390d978cbf61e8f16c9f580fa96b305c43568", "target": 1, "func": "static void nbd_client_closed(NBDClient *client)\n\n{\n\n    nb_fds--;\n\n    if (nb_fds == 0 && !persistent && state == RUNNING) {\n\n        state = TERMINATE;\n\n    }\n\n    nbd_update_server_watch();\n\n    nbd_client_put(client);\n\n}\n", "idx": 26745, "substitutes": {"client": ["block", "cl", "contact", "ch", "batch", "active", "server", "conn", "service", "pc", "cell", "child", "entry", "c", "core", "proxy", "buffer", "local", "cache", "remote", "open", "quick", "session", "cod", "connection", "project", "co", "Client", "public", "window", "stable", "con", "channel", "t", "hello", "cli"], "nb_fds": ["nb_cds", "nb_frs", "nb_fdcs", "nb_fdeds", "nb_cns", "nb_mks", "nb_tfeds", "nb_tfcs", "nb_fdrs", "nb_tfrs", "nb_cd", "nb_fks", "nb_fns", "nb_fd", "nb_mns", "nb_dns", "nb_fcs", "nb_dks", "nb_tfds", "nb_feds", "nb_fdds", "nb_md", "nb_cks", "nb_dds", "nb_mds", "nb_dd"]}}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)\n\n{\n\n    NvmeSQueue *sq;\n\n    NvmeCreateSq *c = (NvmeCreateSq *)cmd;\n\n\n\n    uint16_t cqid = le16_to_cpu(c->cqid);\n\n    uint16_t sqid = le16_to_cpu(c->sqid);\n\n    uint16_t qsize = le16_to_cpu(c->qsize);\n\n    uint16_t qflags = le16_to_cpu(c->sq_flags);\n\n    uint64_t prp1 = le64_to_cpu(c->prp1);\n\n\n\n    if (!cqid || nvme_check_cqid(n, cqid)) {\n\n        return NVME_INVALID_CQID | NVME_DNR;\n\n    }\n\n    if (!sqid || !nvme_check_sqid(n, sqid)) {\n\n        return NVME_INVALID_QID | NVME_DNR;\n\n    }\n\n    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {\n\n        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;\n\n    }\n\n    if (!prp1 || prp1 & (n->page_size - 1)) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    if (!(NVME_SQ_FLAGS_PC(qflags))) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    sq = g_malloc0(sizeof(*sq));\n\n    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);\n\n    return NVME_SUCCESS;\n\n}\n", "idx": 26749, "substitutes": {"n": ["sn", "i", "na", "on", "o", "nn", "nm", "conn", "nb", "d", "w", "nl", "ng", "g", "r", "p", "fn", "nc", "cn", "new", "node", "an", "nw", "ctx", "nu", "j", "np", "ne", "a", "b", "nv", "ns", "l", "nt", "y", "nor", "N", "num", "gn", "net", "en", "t", "rn", "m", "v", "no"], "cmd": ["cl", "ch", "quit", "cmp", "batch", "cf", "dq", "conn", "comm", "cell", "cd", "ctr", "cont", "crit", "command", "mk", "md", "ctl", "cp", "send", "sc", "msg", "cb", "cm", "call", "ctx", "np", "cfg", "req", "ct", "oc", "cr", "Cmd", "q", "cc", "m"], "sq": ["Q", "pack", "sa", "sb", "cur", "cf", "dq", "conn", "SU", "tk", "qt", "sub", "squ", "scl", "seq", "tn", "sync", "g", "qu", "ctrl", "ack", "supp", "p", "sc", "s", "ship", "qq", "sh", "square", "cs", "cb", "aws", "buf", "ctx", "rf", "np", "iq", "qa", "ksh", "ct", "query", "qs", " q", "sing", "gs", "sf", "sv", "eq", "pkg", "zz", "h", "q", "t", "rn", "cc", "qi", "aq", "parse"], "c": ["f", "cl", "ch", "cur", "cf", "ce", "cu", "ca", "comm", "pc", "config", "cor", "tc", "rc", "cd", "cont", "dc", "cp", "p", "cache", "cs", "cb", "cm", "call", "ctx", "enc", "co", "comp", "ct", "xc", "ac", "unc", "oc", "l", "cr", "ci", "con", "fc", "etc", "gc", "t", "cc", "C", "v", "lc", "conf"]}}
{"project": "FFmpeg", "commit_id": "72a6244b5d554d7fdfdeb04c174750c7a2c52f83", "target": 0, "func": "void ff_ac3_bit_alloc_calc_mask(AC3BitAllocParameters *s, int16_t *band_psd,\n\n                                int start, int end, int fast_gain, int is_lfe,\n\n                                int dba_mode, int dba_nsegs, uint8_t *dba_offsets,\n\n                                uint8_t *dba_lengths, uint8_t *dba_values,\n\n                                int16_t *mask)\n\n{\n\n    int16_t excite[50]; /* excitation */\n\n    int bin, k;\n\n    int bndstrt, bndend, begin, end1, tmp;\n\n    int lowcomp, fastleak, slowleak;\n\n\n\n    /* excitation function */\n\n    bndstrt = bin_to_band_tab[start];\n\n    bndend = bin_to_band_tab[end-1] + 1;\n\n\n\n    if (bndstrt == 0) {\n\n        lowcomp = 0;\n\n        lowcomp = calc_lowcomp1(lowcomp, band_psd[0], band_psd[1], 384);\n\n        excite[0] = band_psd[0] - fast_gain - lowcomp;\n\n        lowcomp = calc_lowcomp1(lowcomp, band_psd[1], band_psd[2], 384);\n\n        excite[1] = band_psd[1] - fast_gain - lowcomp;\n\n        begin = 7;\n\n        for (bin = 2; bin < 7; bin++) {\n\n            if (!(is_lfe && bin == 6))\n\n                lowcomp = calc_lowcomp1(lowcomp, band_psd[bin], band_psd[bin+1], 384);\n\n            fastleak = band_psd[bin] - fast_gain;\n\n            slowleak = band_psd[bin] - s->slow_gain;\n\n            excite[bin] = fastleak - lowcomp;\n\n            if (!(is_lfe && bin == 6)) {\n\n                if (band_psd[bin] <= band_psd[bin+1]) {\n\n                    begin = bin + 1;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        end1=bndend;\n\n        if (end1 > 22) end1=22;\n\n\n\n        for (bin = begin; bin < end1; bin++) {\n\n            if (!(is_lfe && bin == 6))\n\n                lowcomp = calc_lowcomp(lowcomp, band_psd[bin], band_psd[bin+1], bin);\n\n\n\n            fastleak = FFMAX(fastleak - s->fast_decay, band_psd[bin] - fast_gain);\n\n            slowleak = FFMAX(slowleak - s->slow_decay, band_psd[bin] - s->slow_gain);\n\n            excite[bin] = FFMAX(fastleak - lowcomp, slowleak);\n\n        }\n\n        begin = 22;\n\n    } else {\n\n        /* coupling channel */\n\n        begin = bndstrt;\n\n\n\n        fastleak = (s->cpl_fast_leak << 8) + 768;\n\n        slowleak = (s->cpl_slow_leak << 8) + 768;\n\n    }\n\n\n\n    for (bin = begin; bin < bndend; bin++) {\n\n        fastleak = FFMAX(fastleak - s->fast_decay, band_psd[bin] - fast_gain);\n\n        slowleak = FFMAX(slowleak - s->slow_decay, band_psd[bin] - s->slow_gain);\n\n        excite[bin] = FFMAX(fastleak, slowleak);\n\n    }\n\n\n\n    /* compute masking curve */\n\n\n\n    for (bin = bndstrt; bin < bndend; bin++) {\n\n        tmp = s->db_per_bit - band_psd[bin];\n\n        if (tmp > 0) {\n\n            excite[bin] += tmp >> 2;\n\n        }\n\n        mask[bin] = FFMAX(ff_ac3_hearing_threshold_tab[bin >> s->sr_shift][s->sr_code], excite[bin]);\n\n    }\n\n\n\n    /* delta bit allocation */\n\n\n\n    if (dba_mode == DBA_REUSE || dba_mode == DBA_NEW) {\n\n        int band, seg, delta;\n\n        band = 0;\n\n        for (seg = 0; seg < FFMIN(8, dba_nsegs); seg++) {\n\n            band = FFMIN(49, band + dba_offsets[seg]);\n\n            if (dba_values[seg] >= 4) {\n\n                delta = (dba_values[seg] - 3) << 7;\n\n            } else {\n\n                delta = (dba_values[seg] - 4) << 7;\n\n            }\n\n            for (k = 0; k < dba_lengths[seg]; k++) {\n\n                mask[band] += delta;\n\n                band++;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 26774, "substitutes": {"s": ["i", "x", "sa", "sb", "o", "fs", "d", "w", "c", "ds", "params", "g", "r", "spec", "n", "p", "state", "j", "S", "ss", "settings", "a", "b", "ps", "stats", "z", "es", "e", "gs", "sv", "u", "self", "h", "t", "m", "v", "sq"], "band_psd": ["band_resds", "band_pseds", "band_psed", "band2prsd", "band_postdk", "band_prd", "band_pru", "band2asrd", "band2prdict", "band_portsd", "band_dsda", "bandMemlasdd", "band2pssd", "band_psdd", "band_insdd", "band2psds", "band_postds", "band_pu", "band_PSdd", "band_sssd", "band_capsd", "band_psdict", "band_psdt", "bandMempsdd", "band_alsds", "band2psdu", "band_PSsd", "band_pxd", "band_portsdt", "band_rasd", "band_PSds", "band_lasds", "band_resdt", "band_lasdd", "band_perdo", "band2prd", "band_asrd", "band_pds", "band_PSdt", "band0epssd", "band_persl", "band_psdf", "band__pssd", "band_prD", "band2asd", "bandetpsds", "band_PSda", "band2asdd", "band_capspd", "band_portsds", "band_persd", "band_PSdu", "band2prds", "band_pri", "band0psd", "bandetpsdk", "band_perspd", "band_prdt", "band_epsd", "band_portsdf", "bandetpsda", "bandMemlasds", "band_dssd", "band_inssd", "band_prds", "band2prdu", "band_epssd", "band_psei", "band_insd", "band_ssdd", "band_psdu", "band_resdf", "band_emsdc", "band__pu", "band_possd", "band_psrd", "band_raspd", "band_PSd", "band_posda", "band_capsdc", "band_psl", "band_asd", "band_psdat", "band_epsdat", "band__psd", "bandetpostds", "band_postd", "bandDpsdt", "band_pxu", "bandMemlasd", "bandetpsd", "band_prdc", "band2psdo", "band_emsd", "band_csrd", "band_emspd", "band_psda", "band_postda", "bandMempsd", "band_epsds", "band_asdd", "band_persdict", "band_alssd", "band_prdu", "band_pi", "band__pd", "band_csd", "band_psu", "bandetpostda", "band_pxsd", "band_csdo", "band0epsdd", "band0pssd", "band2psdd", "band_perdd", "band_rasdict", "band_pseD", "band_psds", "band2psdict", "band_posd", "band_perrd", "band_epsdt", "band_alsd", "band_ssd", "band2psl", "band_pd", "band_epsdd", "band_rasl", "band2psrd", "bandetpostdk", "bandDpsds", "band2prpd", "band_psD", "band_resd", "band_psdo", "bandDepsds", "band__psu", "band_pD", "band_lasd", "band_prsd", "band2prl", "bandetpostd", "band_PSdk", "band2pspd", "band_dsd", "band_prdict", "band_pspd", "band_asdo", "band_capsds", "band_prpd", "bandDepsdt", "bandMempsds", "band2psd", "band0psdd", "band_psdc", "band_perd", "band_PSdat", "band_emsds", "band_dsds", "band_csdd", "bandDpsd", "bandDepssd", "band_prl", "band_prdd", "band_pssd", "band_prdf", "band_dsdk", "band_dsdt", "band_alsdu", "bandDpssd", "bandDepsd", "band_epsda", "band0epsd", "band2asdo", "band_psdk", "band_psi"], "start": ["f", "range", "it", "i", "x", "rest", "len", "try", "from", "first", "id", "index", "row", "get", "in", "r", "top", "p", "set", "j", "pos", "art", "next", "last", "stop", "l", "size", "shift", "key", "seek", "wind", "st", "step", "e", "time", "Start", "offset", "head", "m", "init"], "end": ["until", "length", "END", "ort", "rest", "append", "nd", "ension", "len", "after", "fin", "ext", "End", "send", "close", "add", "dest", "set", "ended", "last", "stop", "ending", "size", "e", "win", "en", "est", "max", "eng", "h", "all", "v", "env", "mid"], "fast_gain": ["fastacacc", "fastlygain", "slow_adj", "fast_weight", "fastnessgain", "fast_align", "fast_adj", "softlyalign", "fastnessstrength", " fast_wave", "fast_wave", "soft_loss", "fastlyloss", "fastJweight", "fast_quality", "fastityacc", "fastacgain", "slow_strength", "fast_correct", "fastlycorrect", "fastlyalign", "soft_align", "fastaccharge", " fast_charge", " fast_acc", "fast_acc", "softlygain", "soft_gain", "fastJgain", "fastitygain", "fastitycharge", "fast_charge", "fastJquality", "soft_correct", "fastnessadj", "softlycorrect", "fastityalign", "fastitycorrect", " fast_quality", "fast_strength", "fast_loss", "softlyloss", "fastJwave", "fastityloss", "slow_gain", " fast_weight"], "is_lfe": ["is_lifec", "is_ffe", "is_lame", "is_ltpe", "is_lfpe", "is_lto", "is_lfed", "is_luel", "is_flet", "is_flec", "is_lfec", "is_lamo", "is_olfe", "is_life", "isHlfed", "is_ldel", "isHlampe", "is_lfd", "is_lued", "is_lampe", "isHlame", "is_lamed", "is_lifo", "is_ldee", "is_lfo", "is_fife", "is_ffee", "is_ffel", "is_ffd", "is_olfed", "is_lifet", "isHlamo", "is_lded", "is_lte", "is_fifed", "is_lfel", "is_lted", "isHlfo", "is_fifet", "is_lde", "is_lfet", "is_lifpe", "is_flee", "is_lue", "isHlfpe", "is_fifd", "is_elfet", "is_fle", "is_elfee", "isHlamed", "is_elfec", "is_luee", "isHlfe", "is_ffet", "is_olfd", "is_lifee", "is_olfet", "is_lifed", "is_lfee", "is_elfe", "is_ffed"], "dba_mode": ["dba2rate", "dfa_rate", "dfa_mode", "dba2type", "dba_type", "dba2mode", "dfa_type", "dba2opt", "dba_rate", "dfa_opt", "dba_opt"], "dba_nsegs": ["dba_nbeps", "dba_nbeg", "dba_nsegments", "dba_nperseg", "dba_nseg", "dba_nmsgments", "dba_msegs", "dba_npersegs", "dba_nbegments", "dba_nmsgs", "dba_mbeps", "dba_nperseps", "dba_npersegments", "dba_mbegs", "dba_nmsg", "dba_mseps", "dba_mbegments", "dba_nmsps", "dba_mbeg", "dba_nbegs", "dba_msegments", "dba_mseg", "dba_nseps"], "dba_offsets": ["dba_offsizes", "dba__locets", "dba__offssets", "dba__offses", "dba_mses", "dba_locizes", "dba_offssets", "dba_poses", "dba_posets", "dba__offsets", "dba_locets", "dba_posizes", "dba_msets", "dba_msizes", "dba__locizes", "dba_offses", "dba__offsizes", "dba_mssets", "dba__loces", "dba__locsets", "dba_possets", "dba_loces", "dba_locsets"], "dba_lengths": ["dba_otherens", "dba__lengthths", "dba_lengthths", "dba__lengths", "dba_seqls", "dba__lengthls", "dba_lengthls", "dba_pathens", "dba_pathls", "dba__seqls", "dba_otherths", "dba__lengthens", "dba_paths", "dba__seqens", "dba_seqens", "dba_seqs", "dba_pathths", "dba_others", "dba__seqs", "dba_seqths", "dba_otherls", "dba_lengthens", "dba__seqths"], "dba_values": ["dfa_vals", "dfa_maps", "dfa_values", "dba_states", "dba__maps", "dba_vals", "dba__values", "dba__states", "dba__vals", "dfa_states", "dba_maps"], "mask": ["pack", "batch", "match", "clean", "box", "bit", "config", "map", "id", "buffer", "pixel", "list", "cache", "mode", "filter", "tag", "shape", "sk", "scan", "ak", " masks", "key", "window", "flag", "offset", "ask", "lock", "conf"], "excite": ["excITE", "Excge", "Excite", " excITE", "equite", "recite", "recites", "resprite", "ExcITE", "Excit", "equit", "occge", "respit", "Excrite", " excit", "occrite", "equrite", "excit", "respitation", "occit", "excge", "Excites", "respite", " excites", "excites", " excge", "equites", "excrite", "recITE", "excitation", " excrite", "recit", "occites", "occite", " excitation", "Excitation"], "bin": ["bed", "gen", "spin", "id", "sam", "mem", "comb", "in", "pid", "obin", "proc", "pos", "bg", "rin", "size", "png", "snap", "butt", "gn", "kin", "pack", "i", "bool", "brain", "bridge", "byte", "conn", "nb", "bank", "sun", "bat", "ang", "hang", "db", "ben", "pixel", "n", "sort", "ran", "session", "binary", "tag", "inner", "ind", "fun", "inn", "lib", "bot", "con", "buck", "gem", "win", "cgi", "slot", "buff", "ix", "device", "batch", "skin", "dir", "nn", "min", "box", "bound", "ruby", "ln", "body", "bis", "bind", "go", "mi", "kit", "back", "b", "don", "bi", "rb", "mix", "slice", "bit", "ann", "umi", "local", "ebin", "gin", "cmd", "pal", "pin", "cache", "border", "cb", "hook", "span", "bn", "scan", "abin", "num", "by", "un", "loop", "index", "bid", "init"], "k": ["f", "x", "ki", "kk", "ok", "ik", "km", "w", "conf", "mk", "ck", "g", "spec", "n", "p", "K", "j", "sk", "ak", "b", "ac", "kid", "key", "seek", "kw", "kind", "m", "ek"], "bndstrt": ["bondstringt", "bndstrty", "bondstringp", "bndbreaktp", "bndbrty", "bndStrl", "bndStrT", "bNDbrt", "bndStrt", "bndseqts", "bndstrts", "bndstrmt", "bondstringmt", "bndrp", "bondstrp", "bndnamen", "bNDstrl", "bndbrl", "bNDstrty", "bndbrT", "bNDbrT", "bndseql", "bndrmt", "bndstrT", "bNDbrty", "bndseqty", "bndnamep", "bndstringp", "bndbrt", "bNDbrts", "bNDstrT", "bondstrmt", "bNDstrtp", "bondstrt", "bndstrp", "bndbreakt", "bndnamemt", "bndseqT", "bndbreakts", "bondstrn", "bndrt", "bndbreakT", "bndstrl", "bNDstrts", "bndstrn", "bndnamet", "bndstrtp", "bndbrts", "bondstringn", "bndseqt", "bndStrty", "bndbrtp", "bndseqtp", "bNDstrt", "bNDbrl", "bndstringt", "bNDbrtp", "bndrn", "bndstringn", "bndstringmt"], "bndend": ["brordEnd", "bendnet", "bord1", "brnd1", "brndEnd", "bmdEnd", "bendend", "bndstart", "brendend", "fndnet", "bintstart", "fndstart", "brngEnd", "bintend", "bmdstart", "bmdend", "bondstart", "brngend", "bondend", "brendstart", "fendnet", "bnd1", "bndnet", "brndend", "fendend", "bfindend", "bint1", "brndstart", "borden", "bngended", "benden", "bfindstart", "brordend", "bordend", "brngstart", "fendstart", "brenden", "bndended", "bordstart", "fndend", "bmd1", "brendnet", "bordEnd", "bondEnd", "brndended", "bfindEnd", "bendstart", "bordnet", "fnden", "bfindended", "brord1", "brordstart", "bngEnd", "bndEnd", "fenden", "bintEnd", "bngend", "bngstart", "bnden", "brngended", "bondended"], "begin": ["run", "range", "kin", "paren", "Begin", "batch", "pre", "bind", "min", "bridge", "gain", "may", "make", "bound", "update", "pend", "commit", "bor", "create", "local", "late", "pen", "pause", "consider", "add", "set", "go", "termin", "hide", "month", "mis", "can", "pair", "goal", "center", "span", "ran", "minimum", "don", "mark", "save", "EGIN", "gan", "snap", "num", "con", "rb", "half", "un", "head", "mid", "be", "mount", "bid", "init", "bottom"], "end1": ["End1", "nd3", "start2", "ended1", "end8", "END1", "end6", "nd2", "End2", "end3", "nd0", " end3", " end2", "ended2", " end01", "ENDOne", "nd1", "END01", "End3", " end6", "END6", " end0", "end01", " end7", "END2", "start0", "nd8", "end0", "End8", "end7", "start1", "END0", "End7", " end8", "ended0", "END7", "ended6", "end2", "startOne", "nd01", "End0", "EndOne", "End01", "endOne"], "tmp": ["batch", "cmp", "other", "perm", "temp", "unit", "mp", "mut", "tc", "common", "params", "cmd", "img", "prefix", "extra", "pos", "np", "tag", "acc", "test", "ind", "ip", "src", "snap", "etc", "timeout", "jp", "lock"], "lowcomp": ["condComp", " lowcond", "longcomp", "condcp", "highComp", "flowcomp", "highcond", "levelcomp", "smallcom", "ownop", " lowcp", "longcmp", "longcom", " lowcrit", "slowcomponent", "condcomp", "quickcomp", "lowcond", "locomp", "highcmp", "Lowcp", "longcp", " lowcmp", "slowprop", "slowcomm", " lowcomponent", " lowcom", "oldcomp", "quickprop", "levelcomponent", "lowcomm", "oldcom", "lowcomponent", "fullfac", "smallcomp", " lowfac", "owncom", "condcom", "LowComp", "slowComp", "lowcmp", "quickcomponent", "highcomp", "flowcom", "littlecomp", "quickproc", "fullcomp", "fullcom", "slowcond", " lowprop", "oldcomponent", "Lowcond", " lowComp", "lowcp", "slowcom", "littlefac", "slowop", "lowcrit", " lowproc", "quickcom", "Lowcomp", "lowprop", "Lowcmp", "locmp", "lowop", "slowcp", "locom", " lowcomm", "levelcmp", "fullcond", "flowcmp", "Lowcrit", "owncomponent", "owncomp", "slowproc", "lowcom", "smallprop", "lowComp", "slowcomp", "oldcmp", "slowcmp", "Lowcom", "littlecond", "lowfac", "flowcp", "littlecom", "smallcmp", "levelcomm", "lowproc", "locrit", "owncmp", "loop", "quickcmp"], "fastleak": ["fastleaked", "fastoleaker", "slowleake", "slowoleak", "fastsleake", "slowolease", "fastoleak", "fastplease", "slowoleaker", "fastoleake", "lowbleaky", "lowbleake", "fastlaky", "slowleaker", "fastleake", "fastlak", "fastsleaked", "fastpleake", "fastbleaked", "fastleaker", "lowleak", "fastbleaker", "fastbleake", "fastchake", "fastsleaky", "fastpleaker", "fastlake", "fastchaked", "fastbleak", "slowbleak", "fastcleak", "fastlease", "lowbleaked", "fastcleaker", "fastblease", "fastolease", "fastlaker", "slowoleake", "slowbleake", "fastcleaky", "fastpleak", "slowlease", "lowleaked", "lowleake", "slowbleaky", "slowbleaker", "fastleaky", "fastsleak", "fastchaky", "lowleaky", "slowleaky", "fastchak", "fastbleaky", "fastcleake", "lowbleak"], "slowleak": ["deepleaking", "slowleake", " slowsleek", "deepbleake", "slowcleake", "slowleaking", "slowbleaking", "slowseak", "slowseap", " slowsleak", "slowbleek", " slowsleap", "slowcleek", "deepleake", "deepleek", "deepbleek", "slowbleap", "deepleak", "slowleek", "deepbleak", "slowsleap", " slowsleake", "slowbleak", " slowleake", "slowseake", "slowleap", "slowcleaking", "slowbleake", " slowleap", "slowseaking", "slowcleak", "slowsleake", "deepbleaking", "slowseek", "slowsleak", " slowleek", "slowsleek"]}}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,\n\n                int x, int y, int w, int h)\n\n{\n\n    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];\n\n    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;\n\n    rect->x = x;\n\n    rect->y = y;\n\n    rect->w = w;\n\n    rect->h = h;\n\n}\n", "idx": 26776, "substitutes": {"s": ["sys", "ms", "space", "as", "sb", "store", "service", "os", "se", "comm", "d", "sol", "rs", "sam", "ses", "ds", "hs", "sl", "sync", "g", "r", "spec", "n", "sh", "sts", "asm", "set", "aws", "sw", "secondary", "S", "span", "als", "js", "bs", "ss", "so", "a", "is", "ats", "ts", "ns", "ps", "ims", "acs", "stats", "qs", "south", "st", "sp", "gs", "less", "serv", "sv", "source", "ls", "sq"], "x": ["f", "fx", " cx", "i", "ux", "tx", "xy", "d", "xt", "ex", "c", "ry", "at", "dx", "rx", "p", "ax", "X", "coord", "xs", "a", "l", "ox", "z", "px", "position", "xp", "xi", "t", "m", "v", "wx", "ix"], "y": ["my", "asia", "i", "gy", "o", "xy", "dy", "hot", "ay", "yt", "v", "sky", "ry", "icy", "yy", "uy", "iley", "iy", "yer", "iny", "top", "axy", "p", "ny", "ery", "ym", "ye", "cy", "any", "vy", "a", "hy", "b", "py", "ies", "very", "ey", "ya", "ys", "oy", "t", "Y", "sy", "asy", "m", "hey"], "w": ["f", "wid", "W", "rew", "fw", "iw", "wh", "v", "d", "ow", "ex", "ew", "wall", "wd", "ww", "wr", "wl", "r", "n", "p", "we", "sw", "nw", "wa", "a", "l", "weight", "wb", "wp", "wt", "wn", "window", "z", "wind", "rw", "win", "wal", "kw", "wen", "t", "m", "wx", "aw", "pt", "hw"], "h": ["f", "it", "hd", "ch", "i", "err", "ih", "hash", "ph", "dh", "wh", "d", "c", "eh", "rh", "high", "height", "ah", "r", "p", "phi", "kh", "hz", "oh", "ht", "hei", "depth", "html", "hi", "gh", "a", "b", "l", "ish", "uh", "bh", "ha", "H", "e", "hh", "u", "q", "t", "m", "v", "ho", "hw"], "rect": ["tar", "region", "opt", "unt", "red", "client", "dial", "rest", "err", "dir", "store", "rm", "Rect", "RECT", "nav", "vp", "def", "cont", "pr", "ren", "r", "round", "cmd", "spec", "list", "remote", "mat", "rel", "prefix", "vr", "area", "lat", "rent", "form", "vec", "project", "print", "complete", "rt", "req", "ind", "desc", "feat", "dr", "port", "expr", "addr", "txt", "json", "butt", "select", "der", "tr", "ptr", "vt", "assert", "dict", "pt", "res"], "redraw_fifo_last": ["redraw_fifo_scope", "redraw_fifo__scope", "redraw_fifo_count", "redraw_fifpo_scope", "redraw_fifO_last", "redraw_fifo__last", "redraw_fifO_next", "redraw_fifpo_count", "redraw_fifO_max", "redraw_fifo__count", "redraw_fifpo_last", "redraw_fifo_max", "redraw_fifo_next"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)\n\n{\n\n\tif (dc->flagx_known) {\n\n\t\tif (dc->flags_x) {\n\n\t\t\tTCGv c;\n\n            \n\n\t\t\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\tt_gen_mov_TN_preg(c, PR_CCS);\n\n\t\t\t/* C flag is already at bit 0.  */\n\n\t\t\ttcg_gen_andi_tl(c, c, C_FLAG);\n\n\t\t\ttcg_gen_add_tl(d, d, c);\n\n\t\t\ttcg_temp_free(c);\n\n\t\t}\n\n\t} else {\n\n\t\tTCGv x, c;\n\n\n\n\t\tx = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tt_gen_mov_TN_preg(x, PR_CCS);\n\n\t\ttcg_gen_mov_tl(c, x);\n\n\n\n\t\t/* Propagate carry into d if X is set. Branch free.  */\n\n\t\ttcg_gen_andi_tl(c, c, C_FLAG);\n\n\t\ttcg_gen_andi_tl(x, x, X_FLAG);\n\n\t\ttcg_gen_shri_tl(x, x, 4);\n\n\n\n\t\ttcg_gen_and_tl(x, x, c);\n\n\t\ttcg_gen_add_tl(d, d, x);        \n\n\t\ttcg_temp_free(x);\n\n\t\ttcg_temp_free(c);\n\n\t}\n\n}\n", "idx": 26777, "substitutes": {"dc": ["sys", "ic", "pc", "bc", "tc", "rc", "cd", "ds", "ec", "ctl", "sc", "dt", "nc", "dm", "di", "cs", "disc", "cm", "ctx", "df", "td", "doc", "da", "ct", "dp", "vc", "oc", "dr", "dd", "desc", "ci", "mc", "fc", "kw", "DC", "cc", "lc"], "d": ["sd", "pd", "i", "ad", "ld", "dir", "nd", "dh", "w", "cd", "D", "ds", "dx", "wd", "g", "r", "db", "ed", "n", "p", "dt", "s", "dm", "di", "td", "gd", "da", "b", "data", "tg", "dl", "de", "dr", "dd", "dat", "l", "y", "bd", "z", "fd", "e", "h", "t", "m", "v"], "c": ["f", "ic", "uc", "ch", "i", "cur", "cf", "ce", "cu", "ca", "col", "bc", "pc", "cor", "tc", "rc", "k", "ec", "g", "cat", "r", "cp", "n", "cache", "p", "sc", "nc", "cn", "s", "cs", "cm", "com", "cy", "co", "a", "b", "ct", "xc", "l", "ac", "vc", "cr", "y", "ci", "mc", "con", "fc", "e", "u", "gc", "t", "cc", "C", "v", "lc", "m", "cv"], "x": ["xa", "ic", "i", "ux", "tx", "on", "o", "xy", "xd", "xml", "w", "xt", "ex", "k", "at", "dx", "nex", "mx", "rx", "g", "r", "n", "p", "s", "ax", "X", "xx", "ctx", "co", "xs", "a", "xf", "b", "l", "xc", "y", "ox", "z", "px", "con", "e", "xe", "u", "xp", "xi", "h", "t", "m", "v", "wx", "ix"]}}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_start_cpu(sPAPREnvironment *spapr,\n\n                           uint32_t token, uint32_t nargs,\n\n                           target_ulong args,\n\n                           uint32_t nret, target_ulong rets)\n\n{\n\n    target_ulong id, start, r3;\n\n    CPUState *cs;\n\n\n\n    if (nargs != 3 || nret != 1) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    id = rtas_ld(args, 0);\n\n    start = rtas_ld(args, 1);\n\n    r3 = rtas_ld(args, 2);\n\n\n\n    cs = qemu_get_cpu(id);\n\n    if (cs != NULL) {\n\n        PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n        CPUPPCState *env = &cpu->env;\n\n\n\n        if (!cs->halted) {\n\n            rtas_st(rets, 0, -1);\n\n            return;\n\n        }\n\n\n\n        /* This will make sure qemu state is up to date with kvm, and\n\n         * mark it dirty so our changes get flushed back before the\n\n         * new cpu enters */\n\n        kvm_cpu_synchronize_state(cs);\n\n\n\n        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);\n\n        env->nip = start;\n\n        env->gpr[3] = r3;\n\n        cs->halted = 0;\n\n\n\n        qemu_cpu_kick(cs);\n\n\n\n        rtas_st(rets, 0, 0);\n\n        return;\n\n    }\n\n\n\n    /* Didn't find a matching cpu */\n\n    rtas_st(rets, 0, -3);\n\n}\n", "idx": 26780, "substitutes": {"spapr": [" spipr", " spapar", "spopr", "spopre", " spapre", " spipR", " spipar", " spapR", "spAPr", "spAPre", "spipre", "spAPR", " spipre", "spipr", "spipR", "spopar", "spapR", "spipar", "spopR", "spAPar", "spapar", "spapre"], "token": ["secret", "wid", "ident", "urn", "Token", "ails", "os", "from", "kt", "oken", "root", "aws", "ens", "session", "doc", "ti", "ts", "sid", "kid", "Id", "wt", "worker", "fd", "ires", "init", "ix"], "nargs": ["tparams", "ngs", "nbparams", "tArgs", "nbargs", "targs", "tgs", "nsgs", "targ", "nbarg", " ngs", " nArgs", "narg", "nArgs", "nbgs", "nsarg", " nparams", "nsArgs", "nsargs", " narg", "nparams"], "args": ["ms", "limits", "values", "ins", "fields", "gets", "ants", "ties", "fs", "rs", "ds", "flags", "params", "spec", "ids", "keys", "s", "arr", "GS", "ags", "arms", "aws", "Args", "ens", "rows", "words", "pos", "frames", "als", "els", "js", "uments", "arn", "xs", "init", "data", "ns", "types", "info", "ts", "ims", "vals", "uns", "qs", "facts", "terms", "its", "gs", "aux", "actions", "ret", "ptr", "ires", "parts", "ls", "orders", "atts", "arg", "names", "dates", "res"], "nret": ["nnreturn", " nRet", "nnrets", "Nret", " nreturn", "Nreturn", "nRet", "nrets", "Nrets", " nrets", "NRet", "norRet", "norret", "norreturn", "norrets", "nnRet", "nreturn", "nnret"], "rets": ["secret", "urs", "tails", "utes", "finals", "values", "ails", "reset", "RET", "ants", "fs", "rs", "def", "lists", "ds", "uts", "flags", "results", "details", "uds", "ids", "ents", "sts", "ints", "aws", "ens", "rows", " secrets", "windows", "els", "als", "outs", "js", "uments", "ets", "ns", "ts", "states", "vals", "qs", "cas", "tes", "des", "fts", "aults", "its", "gs", "ads", "ret", "der", "ptr", "ires", "ates", "ls", "ces", "events", "res"], "id": ["f", "it", "type", "ident", "i", "ad", "tx", "ref", "os", "d", "from", "rev", "er", "rid", "uid", "in", "ed", "ids", "pid", " fid", "iden", " ID", "oid", "a", "ts", "sid", "info", "kid", "ip", "key", "vid", "des", "base", "fd", "ID", " tid", "en", "ret", "h", "end", "mid", "m", "bid", "Id", "name"], "start": ["it", "pre", "i", "trans", "rest", "reset", "len", "try", "begin", "d", "from", "pad", "first", "date", "find", "get", "started", "r", "in", "now", "n", "p", "set", "j", "origin", "pos", "art", "stop", "ts", "shift", "size", "seek", "wind", "st", "step", "base", "iter", "time", "Start", "offset", "end", "t", "q", "init"], "r3": ["r2", "rThree", "vr1", "rcthree", " r03", "rc03", "rc5", "rcThree", " r7", " rThree", "r7", "r03", "r5", " r2", "rc7", "R3", "rc3", "vrThree", "R7", " r1", "rthree", " rthree", "rc2", "RThree", "rc1", "R5", "vr3", " r5", "R2", "R03", "r1", "vrthree"], "cs": ["css", "ms", "cf", "cer", "ins", "csv", "fs", "pc", "rs", "Cs", "c", "rc", "ctr", "tc", "ds", "ec", "ck", "ks", "caps", "cmd", "acts", "cp", "sc", "cus", "nc", "cn", "cks", "sts", "ars", "vs", "ctx", "ics", "bs", "js", "cons", "wcs", "ct", "ts", "CS", "ac", "ps", "ns", "acs", "cas", "stats", "qs", "fc", "its", "gs", "gc", "cms", "ls", "cc", "ces", "checks", "cv"], "cpu": ["vm", "efficiency", "bench", "cam", "cu", "score", "ka", "pc", "none", "c", "core", "gpu", "nic", "common", "clock", "ck", "CP", "cp", "linux", "cow", "ace", "cn", "uart", "util", "node", "loader", "gp", "ctx", "nu", "aco", "process", "runner", "onet", "processor", "bean", "CPU", "pu", "tp", "gc", "stat", "proc", "socket"], "env": ["priv", "here", "ee", "context", "engine", "ef", "esc", "eu", "cer", "obj", "ce", "eps", "ev", "conn", "viron", "ie", "ent", "entry", "agent", "eh", "er", "ew", "dev", "ec", "owner", "ah", "cmd", "db", "ve", "el", "oe", "esp", "cb", "gear", "buf", "esm", "et", "te", "vs", "ctx", "environment", "enc", "shell", "js", "next", "eas", "desc", "ts", "equ", "window", "cookie", "ote", "e", "en", "sv", "scope", "ue", "der", "era", "end", "vt", "exc", "proc", "v", "cv", "ei"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int i2c_start_transfer(i2c_bus *bus, int address, int recv)\n\n{\n\n    DeviceState *qdev;\n\n    i2c_slave *slave = NULL;\n\n\n\n    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {\n\n        slave = I2C_SLAVE_FROM_QDEV(qdev);\n\n        if (slave->address == address)\n\n            break;\n\n    }\n\n\n\n    if (!slave)\n\n        return 1;\n\n\n\n    /* If the bus is already busy, assume this is a repeated\n\n       start condition.  */\n\n    bus->current_dev = slave;\n\n    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);\n\n    return 0;\n\n}\n", "idx": 26792, "substitutes": {"bus": ["block", "Bus", "sys", "board", "device", "hand", "gen", "uses", "bridge", "boot", "box", "conn", "os", "host", "bc", "us", "def", "mount", "proxy", "master", "dev", "local", "sync", "book", "cast", "db", "build", "cache", "BUS", "state", "util", "hub", "buf", "ctx", "bar", "phys", "bs", "connection", "chain", "back", "usb", "way", "lib", "bur", "base", "http", "driver", "boss", "loop", "controller", "lock"], "address": ["range", "device", "attribute", "action", "type", "i", "reference", "network", "ay", "operation", "service", "condition", "index", "request", "master", "command", "path", "resource", "ace", "alias", "route", "dest", "set", "order", "message", "sequence", "controller", "shape", "capacity", "private", "lease", "location", "execute", "port", "addr", "interface", "link", "Address", "directory", "position", "handle", "number", "trace", "offset", "description", "age", "property", "ress", "name"], "recv": ["Recc", "RECvs", "recvert", "RecvP", "Recvert", "RECc", "Reccv", "RECvP", "preq", " recq", " recvP", "Recvs", " recvs", " recc", "recvP", "reccv", "Recq", "RECv", "recc", "precv", "Recv", "recvs", "prev", "recq", " reccv", "prevert", " recvert"], "qdev": ["qqdev", "QDev", "qev", " qd", "qvar", "qqmem", "qumem", " qDev", "qud", "qudevice", "Qev", "qudev", "qqdevice", "qqDev", "qd", "qmem", "dqdevice", " qdevice", " qvar", "qqvar", "dqev", "Qdevice", "dqvar", "qDev", " qmem", "dqdev", "qdevice", "qqev", "qqd", "dqDev", "Qdev"], "slave": ["device", "handler", "attribute", "ssh", "engine", "sa", "sb", "sama", "ale", "server", "peer", "pipe", "store", "bridge", " slaves", "disable", "se", "station", "unit", "sub", "binding", "result", "proxy", "master", "dev", "gate", "sl", "command", "owner", "ve", "pause", "alias", "ser", "thread", "sh", "node", "dest", "seat", "ave", "pe", "session", "mi", "instance", "task", "lease", "test", "sudo", "tie", "shift", "save", "volume", "port", "data", "query", "worker", "stable", "link", "info", "sp", "copy", "seed", "tle", "source", "si", "join", "tmp", "index", "aw", "role", "ssl"]}}
{"project": "FFmpeg", "commit_id": "8a57ca5c6a1c0ad28afa7ea6f824981e6761cce1", "target": 0, "func": "static int aasc_decode_frame(AVCodecContext *avctx,\n\n                              void *data, int *data_size,\n\n                              AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    AascContext *s = avctx->priv_data;\n\n    int compr, i, stride;\n\n\n\n    s->frame.reference = 3;\n\n    s->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;\n\n    if (avctx->reget_buffer(avctx, &s->frame)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    compr = AV_RL32(buf);\n\n    buf += 4;\n\n    buf_size -= 4;\n\n    switch (avctx->codec_tag) {\n\n    case MKTAG('A', 'A', 'S', '4'):\n\n        bytestream2_init(&s->gb, buf - 4, buf_size + 4);\n\n        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);\n\n        break;\n\n    case MKTAG('A', 'A', 'S', 'C'):\n\n    switch(compr){\n\n    case 0:\n\n        stride = (avctx->width * 3 + 3) & ~3;\n\n        for(i = avctx->height - 1; i >= 0; i--){\n\n            if(avctx->width*3 > buf_size){\n\n                av_log(avctx, AV_LOG_ERROR, \"Next line is beyond buffer bounds\\n\");\n\n                break;\n\n            }\n\n            memcpy(s->frame.data[0] + i*s->frame.linesize[0], buf, avctx->width*3);\n\n            buf += stride;\n\n            buf_size -= stride;\n\n        }\n\n        break;\n\n    case 1:\n\n        bytestream2_init(&s->gb, buf, buf_size);\n\n        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown compression type %d\\n\", compr);\n\n        return -1;\n\n    }\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown FourCC: %X\\n\", avctx->codec_tag);\n\n        return -1;\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n\n\n    /* report that the buffer was completely consumed */\n\n    return buf_size;\n\n}\n", "idx": 26819, "substitutes": {"avctx": ["vrcu", "averctx", "aftx", "wavtx", "ahctx", "awtx", "vrcontext", "avercp", "avwcs", " avgc", "ajcfg", "ajcontext", "vrctx", "verctx", "wavcmp", "wavjac", "awctx", "avcfg", "avpkg", "averpkg", "ajconn", "ajgc", "avcmp", "wavconn", "wavmom", "aveca", "verjac", "wavcontext", "avmom", "avca", "AVconn", "avercf", "wavtxt", "Avconn", "avcf", "averwcs", "wavcf", "wavca", "abjp", "Avcontext", "afwcs", "avercontext", "wavcfg", "avcu", "navtx", "ahconn", "navcontext", "vercontext", " avjac", " avconn", "awjp", "afcu", "avecu", "afcontext", " avpkg", "afjp", "navcu", "averconn", "afpkg", "avgc", " avcontext", "avecf", "avercmp", "wavcu", "avecontext", "ajctx", "Avtx", "Avctx", "avecmp", "ahpkg", "AVctx", "avectx", "afctx", "avtxt", "abtx", "avtx", "abctx", "navctx", " avcfg", "avecfg", "avertxt", "ajwcs", "averca", "avecp", "vercu", "avetx", "aveconn", "avepkg", "avcontext", "averjac", " avcmp", " avcu", "avcp", "avercu", " avcp", "avercfg", "avejp", "wavctx", "avjac", "averjp", "ajjp", "avertx", "avconn", "avjp", " avtxt", "awcmp", "ahmom", "avergc", " avtx", "AVcontext", "AVtx", "avejac", "abpkg", "ajmom", " avjp", "ajpkg", "wavpkg", "vrtx"], "data": ["f", "block", "padding", "type", "batch", "length", "stream", "o", "values", "options", "ref", "ata", "d", "pad", "w", "def", "value", "done", "id", "read", "buffer", "flags", "empty", "p", "cache", "memory", "lines", "feed", "bytes", "bits", "area", "extra", "input", "message", "frame", "next", "Data", "sequence", "a", "size", "start", "load", "text", "window", "history", "bin", "package", "actions", "DATA", "offset", "t", "content", "m", "sample", "str", "mu"], "data_size": ["buf_length", "buf_len", "data_len", "buf_size", "data_length", "data_Size", "buf_Size"], "avpkt": ["afcpmit", "avcpkt", "avvpmit", "avPkt", "afpgt", "avpsth", "avpbkt", "avcpsth", "avPdu", "avcpunt", "avcpgt", "avpodacket", "afcpgt", "avepct", "avpbgt", "avfkt", "afpkt", "avpaunt", "avPkg", "avpmit", "avpbsth", "avcpmit", "afpmit", "afpacket", "avpodgt", "avpackdu", "afpunt", "avpacket", "afcpkt", "avvpacket", "afpsth", "afcpacket", "avepdu", "avefkt", "avfdu", "avpackct", "avfkg", "avefkg", "avvpkt", "avcpacket", "avpct", "avpkg", "avpunt", "afcpunt", "avpodsth", "avvpunt", "avefdu", "avPct", "avfct", "avpackkt", "avpaacket", "avpgt", "avefct", "afcpsth", "avepkg", "avpbacket", "avpakt", "avpdu", "avpamit", "avpodkt", "avepkt", "avpackkg"], "buf": ["block", "fb", "prop", "cur", "batch", "capt", "err", "ref", "queue", "uf", "bl", "box", "br", "len", "bc", "ff", "norm", "result", "ctr", "buffer", "mem", "var", "seq", "late", "db", "cmd", "pool", "cp", "p", "Buff", "keep", "arr", "img", "msg", "cb", "bytes", "ctx", "pos", "vec", "raw", "orig", "b", "shift", "port", "fac", "wb", "aka", "loc", "txt", "window", "lim", "alloc", "addr", "bin", "pro", "limit", "rb", "bp", "cap", "Buffer", "buff", "ptr", "off", "h", "tmp", "xff", "BU", "end", "cv", "mu", "broad"], "s": ["f", "sys", "as", "ops", "tx", "ins", "sis", "gets", "os", "ants", "fs", "sports", "rs", "c", "ses", "ds", "hs", "sl", "details", "g", "n", "p", "bis", "changes", "cs", "sts", "ares", "ains", "sw", "aws", "j", "ctx", "vs", "S", "als", "js", "bs", "ss", "is", "b", "ats", "ts", "ns", "ps", "ims", "ies", "y", "l", "acs", "stats", "qs", "tes", "es", "its", "gs", "less", "sv", "sg", "self", "parts", "h", "ls", "m", "v", "sq", "ess"], "compr": [" comPr", "cmp", "COMpr", " comexpr", "corpl", "COMpl", "Comper", "corPr", " comPR", "compol", "cePR", "Comexpr", "def", "_", "comppol", " compl", "comper", "func", "comPr", "corpol", "compl", "cep", "call", " comper", "comexpr", "romPr", "Compl", "comppl", "raw", "comp", "rompr", "romp", "COMpol", "comppr", "cePr", "Compr", "comPR", " comp", "compexpr", "romPR", "corpr", "compPr", "compper", "COMPr", "v", "cepr"], "i": ["iri", "it", "ic", "x", "ui", "multi", "\u0438", "ki", "o", "d", "pi", "ini", "id", "c", "ri", "gi", "I", "n", "p", "phi", "io", "oi", "di", "zi", "sim", "j", "ai", "mi", "ii", "li", "hi", "b", "ind", "ti", "l", "ip", "ij", "bi", "ims", "y", "ci", "z", "mc", "e", "ir", "u", "iu", "ni", "xi", "si", "index", "v", "cli", "m", "qi", "mu", "ix"], "stride": [" strine", "strate", "charice", " strate", "stringick", "stice", " strIDE", "stIDE", "stick", "Strine", "stringide", "divue", " strride", "slick", "strider", "charide", "stringIDE", "true", "strid", "strice", "strenge", "divride", "stide", "strine", "rIDE", "rate", " strenge", "divide", "ride", "charid", "strride", " strue", "trride", "stid", "charenge", "strick", "slider", "StrIDE", "stider", "divider", "rine", "strue", "stenge", "trider", "Stride", "stringider", "strIDE", "slIDE", " strider", "tride", " strice", "slide", " strid", "Strate"]}}
{"project": "FFmpeg", "commit_id": "de6df46120367b7d49d9d7c0971cbe36368b840a", "target": 1, "func": "int ff_h264_field_end(H264Context *h, int in_setup)\n{\n    AVCodecContext *const avctx = h->avctx;\n    int err = 0;\n    h->mb_y = 0;\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_set_reference_frames(h);\n    if (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (!h->droppable) {\n            err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n            h->prev_poc_msb = h->poc_msb;\n            h->prev_poc_lsb = h->poc_lsb;\n        }\n        h->prev_frame_num_offset = h->frame_num_offset;\n        h->prev_frame_num        = h->frame_num;\n        h->outputed_poc          = h->next_outputed_poc;\n    }\n    if (avctx->hwaccel) {\n        if (avctx->hwaccel->end_frame(avctx) < 0)\n            av_log(avctx, AV_LOG_ERROR,\n                   \"hardware accelerator failed to decode picture\\n\");\n    }\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_picture_complete(h);\n#if CONFIG_ERROR_RESILIENCE\n    /*\n     * FIXME: Error handling code does not seem to support interlaced\n     * when slices span multiple rows\n     * The ff_er_add_slice calls don't work right for bottom\n     * fields; they cause massive erroneous error concealing\n     * Error marking covers both fields (top and bottom).\n     * This causes a mismatched s->error_count\n     * and a bad error table. Further, the error count goes to\n     * INT_MAX when called for bottom field, because mb_y is\n     * past end by one (callers fault) and resync_mb_y != 0\n     * causes problems for the first MB line, too.\n     */\n    if (!FIELD_PICTURE(h) && h->current_slice && !h->sps.new) {\n        ff_h264_set_erpic(&h->er.cur_pic, h->cur_pic_ptr);\n        ff_er_frame_end(&h->er);\n    }\n#endif /* CONFIG_ERROR_RESILIENCE */\n    if (!in_setup && !h->droppable)\n        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                  h->picture_structure == PICT_BOTTOM_FIELD);\n    emms_c();\n    h->current_slice = 0;\n    return err;\n}", "idx": 26836, "substitutes": {"h": ["help", "here", "it", "hd", "ch", "f", "x", "ih", "hash", "ph", "comm", "host", "each", "he", "dh", "wh", "w", "hr", "d", "c", "eh", "pp", "k", "rh", "hs", "zh", "dev", "hm", "his", "g", "ah", "hp", "header", "p", "has", "kh", "cache", "hz", "sh", "hal", "sw", "rem", "go", "j", "oh", "ctx", "ht", "th", "html", "hi", "gh", "b", "l", "info", "dr", "history", "uh", "bh", "z", "handle", "window", "ha", "H", "hh", "hl", "http", "q", "m", "v", "ho", "hw"], "in_setup": ["inPostpush", "inPostrun", "in_run", "inflightsetup", "inflightstart", "in_boot", "in_control", "inflightSetup", "inPostsetup", "inflightpush", " in_boot", "inflightrun", "inPrecontrol", " in_start", "in_start", " in_control", " in_push", "in_push", "inflightcontrol", "inPreSetup", "inPrestart", "inPostSetup", " in_test", " in_Setup", "in_Setup", " in_run", "in_test", "inPresetup"], "avctx": ["averctx", "svtx", "wavtx", "ahctx", "awtc", "savjac", "evconn", "vrnp", "evtx", "avetc", "vrctx", "wavcmp", "svjp", "wavjac", "awctx", "ahcmd", "avcfg", "avcmp", "wavconn", "ahcmp", "wavjp", "svgc", "AVjac", "wavcontext", "AVconn", "avloc", "avecmd", "savjp", "avercontext", "awcontext", "savcontext", "avcu", " avcmd", " avjac", " avconn", "evcontext", "averloc", "savgc", "avgc", " avcontext", "avercmp", "vrgc", "avecontext", "avenp", "evctx", "avtc", "savctx", "AVctx", "avectx", "awcfg", "avtx", " avcfg", " avtc", "wavcmd", "savtx", "avcmd", "avecfg", "avecb", "wavloc", "avetx", "avnp", "avcb", "vrcmd", "aveconn", "savcb", "avcontext", "svctx", "wavgc", "averjac", " avcu", "avercu", "wavctx", "avjac", "avercmd", "avconn", "avjp", "wavcb", "avergc", " avtx", "ahloc", "avegc", "AVcontext", "avernp", "AVtx", "avejac", "AVcu"]}}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                sdhci_write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 26841, "substitutes": {"s": ["ops", "eps", "status", "comm", "d", "sports", "c", "comments", "sync", "r", "pers", "p", "changes", "asm", "bits", "vs", "S", "ns", "states", "less", "http", "h", "sq", "sb", "rest", "store", "search", "syn", "os", "rs", "sl", "spec", "n", "state", "cs", "services", "als", "so", "ats", "ts", "ims", "acs", "its", "parts", "m", "sys", "gets", "ses", "bis", "sts", "sw", "bs", "cons", "is", "ps", "stats", "st", "gs", "serv", "ls", "stat", "ssl", "ports", "se", "fs", "ds", "hs", "details", "sh", "set", "js", "ss", "settings", "qs", "es", "sv", "self", "t"], "value": ["block", "padding", "type", "attribute", "length", "x", "expression", "field", "values", " input", " Value", "byte", "address", "feature", "code", "unit", "operator", "index", " message", " quantity", "buffer", "Value", " amount", "cache", " measurement", "VALUE", "memory", " v", "message", "total", "image", " data", "V", "data", "weight", "key", "window", "position", "val", " instance", "vector", "number", "ue", "max", "variable", "property", "hello", "v", "sum"], "size": ["length", "space", "needed", "see", "zone", "len", "fee", "id", "body", "zero", "height", "empty", "n", "send", "count", "ize", "small", "set", "equal", "message", "used", "shape", "capacity", "is", "start", "scale", "SIZE", "window", "z", "position", "num", "e", "Size", "number", "offset", "si", "sum", "index", "name"], "i": ["it", "ic", "x", "batch", "ui", " j", "multi", "ie", "us", "pi", "c", " ii", "ini", "id", "index", "at", " n", " count", "g", "gu", "fi", "gi", "I", "n", "p", "phi", " bi", "di", "zi", "sim", "j", "ai", "mi", "li", "ii", "init", "ti", "l", "ind", "is", " ti", "ip", "y", "bi", "ci", "iter", "u", "iu", " I", " m", " t", "im", "xi", "si", "m", "v", " index", "ix"], "data_count": ["data_start", "data_max", "DATA_length", " data_Count", "total_count", "data_counter", " data_length", "total_size", "length_limit", "data_cache", "dataOBcount", " data_counter", "data_id", "length_buf", "data_buf", "dataOBcounter", "dataOBid", " data_cache", " data_code", "DATA_start", "data_current", " data_id", "data_code", "length_count", "DATA_max", "DATA_count", "total_length", "data_size", "length_current", "data_limit", "data_length", "total_max", "dataOBCount", "data_Count"]}}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)\n\n{\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n", "idx": 26848, "substitutes": {"opts": ["opteds", "optr", "opttto", "iopts", " opls", " opttto", "iopcs", "opercs", "opertr", "optes", "optto", "opeds", "ioptes", "opls", "opertes", "operts", "ioptr", "opttr", "optls", " opeds", " optto", " optls", " opteds", "opttes", "opcs", "optcs", " optts", "optts"], "filename": ["f", "length", "kan", "o", "nm", "fs", "v", "which", "Filename", "til", "path", "FN", "family", "ames", "n", "fn", "p", "prefix", "nil", "file", "ename", "username", "txt", "fil", "files", "directory", "ame", "fd", "json", "ername", "source", "fp", "name"], "chr": ["chtr", "chtrn", "cherrn", "chrt", "clr", "achr", "cherresult", "echresult", "chero", "chtresult", " chrc", "ochrt", "echrn", "echrt", "ichrt", "chrs", "Chrt", "echrb", "cherc", " chl", "chear", " cht", "ichrs", "chtrb", "echt", "echrc", " chdr", "cherrb", "ochar", " chusr", "ochrc", "chdr", "echr", "chusr", "cherr", "echar", "cherb", "chro", " chrb", "ichr", "icht", "clar", "echro", "chers", "chel", "chert", "achdr", "cher", "achrc", "cht", "achl", "cherusr", "clrc", "chl", "Char", "echrs", " chro", "chet", "echdr", " chrt", "Chrc", "achusr", "clrt", "Chr", "chrb", "cherl", "chresult", "ochr", "echl", "chrc", "chrn", "achrb"], "s": ["f", "sys", "i", "sb", "ports", "o", "ins", "csv", "os", "fs", "v", "rs", "w", "c", "storage", "sam", "ses", "ds", "g", "r", "spec", "n", "p", "bis", "sc", "cs", "sts", "j", "session", "S", "js", "bs", "ss", "a", "is", "ats", "b", "ns", "ts", "ps", "stats", "qs", "es", "gs", "less", "sv", "u", "source", "si", "h", "m", "sq", "socket", "ssl"]}}
{"project": "FFmpeg", "commit_id": "a91d82b5cc7d828ea9779aae1595f60e7e257d29", "target": 1, "func": "static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)\n\n{\n\n    int i, k, sb = 0;\n\n    int msb = sbr->k[0];\n\n    int usb = sbr->kx[1];\n\n    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;\n\n\n\n    sbr->num_patches = 0;\n\n\n\n    if (goal_sb < sbr->kx[1] + sbr->m[1]) {\n\n        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;\n\n    } else\n\n        k = sbr->n_master;\n\n\n\n    do {\n\n        int odd = 0;\n\n        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {\n\n            sb = sbr->f_master[i];\n\n            odd = (sb + sbr->k[0]) & 1;\n\n        }\n\n\n\n        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);\n\n        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];\n\n\n\n        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {\n\n            usb = sb;\n\n            msb = sb;\n\n            sbr->num_patches++;\n\n        } else\n\n            msb = sbr->kx[1];\n\n\n\n        if (sbr->f_master[k] - sb < 3)\n\n            k = sbr->n_master;\n\n    } while (sb != sbr->kx[1] + sbr->m[1]);\n\n\n\n    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)\n\n        sbr->num_patches--;\n\n\n\n    // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5\n\n    // However the Coding Technologies decoder check uses 6 patches\n\n    if (sbr->num_patches > 6) {\n\n        av_log(ac->avccontext, AV_LOG_ERROR, \"Too many patches: %d\\n\", sbr->num_patches);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26862, "substitutes": {"ac": ["aic", "ic", "mac", "ad", "jac", "ca", "acer", "pc", "AC", "c", "ia", "pac", "ica", "mic", "ec", "act", "ack", "ace", "sac", "an", "ap", "enc", "acc", "iac", "a", "ach", "am", "ak", "anc", "oc", "fac", "acs", "mc", " cac", "fc", "coll", " lac", "Ac", "cc"], "sbr": ["spre", "sbn", "unsbre", "arbro", "psbn", "scr", "psbre", "isbl", "fsbr", "Spre", "portsbn", "wbr", "sberry", "sreport", "wsbr", "sbt", "statsberry", "jsgr", "qsgr", "asBR", "sbm", "hsbl", "isdb", "nshr", "jsdb", "arhr", "gsarr", "shr", "changesbre", "tbr", "srid", "iesberry", "jsbr", "arbre", "portsfr", "fsfr", "lessber", "isfr", "vesbm", "spr", "insbr", "eshr", "jsbre", "esbre", "esvr", "msbr", "Sbuf", "lessbre", "msbro", "isbn", "isbro", "geshr", "sarr", "jsron", "ishr", "cspr", "isbor", "psbro", "sber", "unsbr", " sber", " sron", "asbr", "tshr", "socr", "portsocr", " scr", "lessbr", "sfr", "tsbr", "wbre", "tsber", "jsfr", "instr", "changesref", " sfr", "itsarr", "fsbre", "msbp", "asber", "portsbre", "unsfr", "whr", "sgr", "qsberry", "insron", "sbp", "wslr", "alsbre", "isbre", "isbd", "isbt", "statsbr", "psbr", "wsron", "owsbre", "jsbor", "sbre", "nsBR", "asbl", "jsrid", "portshr", "nsdr", "Sreg", "iesgr", "owsbr", "jsbl", "tbuf", "gesbre", "mbr", "isbm", "sadr", "csvr", "SBR", "sron", "jsbt", "arbr", "qsbre", "hsbr", "msreg", "alsbr", "ispre", "itsbre", "gsbre", "Shr", "statsvr", "wber", "tsbre", "tBR", "jshr", "isarr", "hsBR", " str", "psocr", "isctr", "stsbr", "unsbro", "isbuf", "iesbt", "jslr", "asbro", "nsbre", "sbor", " sbre", "mstr", "lsbre", "fsbor", " shr", "itsbr", "tbre", "gsstr", " sbl", " svr", "changeshr", "asadr", "sprot", "jsreg", "qsprot", "qsarr", "esreg", "sdb", "lshr", "jsvr", "tsbro", "qsrid", "nsvr", "unsstr", "sbl", " sdr", "sbuf", "sreg", "alsctr", "nsbr", "isstr", "statsbre", "pshr", "jspr", "isron", "sctr", "vesocr", "csbr", "owsber", "jsberry", "gsbr", "isBR", "str", "fsber", "esfr", "sBR", "asbre", "lesshr", "csbor", " sBR", "changesbr", "mbre", "gespre", "isocr", "esbr", "jsBR", "iesreport", "msbre", " sadr", "portsbr", "wsdb", "sbd", "slr", "stsfr", "iesbre", "iesrid", "qspre", "unsbp", " sbro", "lsbr", "sform", "esbor", "wsBR", "fshr", "msvr", "itsprot", "qsbr", "lsron", "stsadr", "isber", "owshr", "islr", "ispr", "sdr", "hsbre", "sstr", "hshr", "msstr", "isberry", "vesbr", "qsbro", "iesbr", "hsbd", "esBR", "isform", "lsBR", "isbr", "inscr", "isadr", "gesbr", "wshr", "stsbre", "isvr", "marr", "sbro", "Sbre", "portsber", "vesber", "alsform", "svr", "sref", "esbp", "jsreport", "Sbr", "isreg", "esref", " sbd", "esbt"], "i": ["ji", "it", "ic", "x", "ui", "ki", "multi", "\u0438", "ik", "ie", "pi", "ini", "id", "index", "ri", "fi", "in", "gi", "I", "n", "p", "phi", "di", "zi", "j", "ai", "mi", "ii", "li", "hi", "b", "ind", "ti", "info", "ip", "ij", "y", "bi", "key", "ish", "ci", "iter", "e", "ir", "u", "iu", "xi", "si", "m", "qi", "ei", "ix"], "k": ["f", "it", "ch", "ku", "out", "ki", "kk", "o", "kan", "ok", "ik", "isk", "kn", "ka", "km", "ski", "ko", "kar", "ke", "tk", "c", "kt", "unk", "ck", "ks", "wk", "mk", "g", "jj", "n", "cp", "p", "kh", "kr", "K", "ikk", "kj", "j", "kb", "sk", "kit", "kick", "uk", "ak", "ind", "b", "kid", "work", "key", "seek", "mc", "num", "dk", "kw", "kind", "usk", "mask", "h", "q", "ask", "kl", "m", "cc", "max", "ijk", "ek"], "num_patches": ["num_motters", "num_patments", "num_mutches", "num_funters", "num_matcs", "num_watchches", "num_aptters", "num_matters", "num_padches", "num_pats", "num_batches", "num_winters", "num_batters", "num_pathes", "num_matches", "num_plotters", "num_mutatches", "num_potcher", "num_aptches", "num_winched", "num_Pathes", "num_patchers", "num_plotists", "num_funches", "num_plotches", "num_mutched", "num_aptched", "num__matched", "num_matched", "num__patatches", "num_potters", "num_patchs", "num_motches", "num_funched", "num_patchcher", "num_motchers", "num__matatches", "num_patatches", "num_wincs", "num_matchers", "num_Patched", "num_patternments", "num_batps", "num_bats", "num_winches", "num_patternches", "num_patchps", "num_patchists", "num_patchched", "num_mathes", "num_batched", "num_batchers", "num_padched", "num_patterns", "num_funatches", "num_patchatches", "num_motcs", "num_patternters", "num_patists", "num_padters", "num_patternchers", "num_patchhes", "num_batcs", "num_aptps", "num_batments", "num_patched", "num_matcher", "num_patcher", "num_watchists", "num__patched", "num__patches", "num_patps", "num_patcs", "num_patchcs", "num_potched", "num_Patches", "num_patchches", "num_patchters", "num_padatches", "num_patters", "num__matches", "num_matatches", "num_patternched", "num_patchchers", "num_potches", "num_patchments", "num_watchters"]}}
{"project": "qemu", "commit_id": "977ec47de06bdcb24f01c93bc125b7c6c221a1c5", "target": 0, "func": "static void *thread_func(void *p)\n\n{\n\n    struct thread_info *info = p;\n\n\n\n    rcu_register_thread();\n\n\n\n    atomic_inc(&n_ready_threads);\n\n    while (!atomic_mb_read(&test_start)) {\n\n        cpu_relax();\n\n    }\n\n\n\n    rcu_read_lock();\n\n    while (!atomic_read(&test_stop)) {\n\n        info->r = xorshift64star(info->r);\n\n        info->func(info);\n\n    }\n\n    rcu_read_unlock();\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n", "idx": 26873, "substitutes": {"p": ["f", "i", "pb", "o", "op", "pc", "d", "vp", "w", "c", "pi", "pp", "g", "r", "n", "cp", "par", "j", "pl", "np", "a", "b", "ps", "y", "pa", "sp", "fp", "pkg", "P", "h", "t", "jp", "q", "m", "v", "param"], "info": ["f", "it", "type", "i", "where", "inf", "o", "success", "status", "try", "op", "update", "os", "bit", "config", "entry", "def", "parse", "id", "result", "error", "local", "report", "now", "fi", "row", "in", "r", "comment", "list", "count", "state", "add", "j", "order", "bar", "ion", "mi", "information", "INFO", "inner", "is", "data", "py", "ip", " inf", "text", "history", "link", "progress", "z", "user", "num", "Info", "iter", "fo", "http", "check", "time", "ist", "t", "stat", "about", "index", "sum", "init", "ready", "conf"]}}
{"project": "FFmpeg", "commit_id": "0de1319ee0109facefe9804ffe0f0d0df36b27ad", "target": 0, "func": "static int http_start_receive_data(HTTPContext *c)\n\n{\n\n    int fd;\n\n\n\n    if (c->stream->feed_opened)\n\n        return -1;\n\n\n\n    /* Don't permit writing to this one */\n\n    if (c->stream->readonly)\n\n        return -1;\n\n\n\n    /* open feed */\n\n    fd = open(c->stream->feed_filename, O_RDWR);\n\n    if (fd < 0) {\n\n        http_log(\"Error opening feeder file: %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    c->feed_fd = fd;\n\n\n\n    if (c->stream->truncate) {\n\n        /* truncate feed file */\n\n        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);\n\n        ftruncate(c->feed_fd, FFM_PACKET_SIZE);\n\n        http_log(\"Truncating feed file '%s'\\n\", c->stream->feed_filename);\n\n    } else {\n\n        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {\n\n            http_log(\"Error reading write index from feed file: %s\\n\", strerror(errno));\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n\n    c->stream->feed_size = lseek(fd, 0, SEEK_END);\n\n    lseek(fd, 0, SEEK_SET);\n\n\n\n    /* init buffer input */\n\n    c->buffer_ptr = c->buffer;\n\n    c->buffer_end = c->buffer + FFM_PACKET_SIZE;\n\n    c->stream->feed_opened = 1;\n\n    c->chunked_encoding = !!av_stristr(c->buffer, \"Transfer-Encoding: chunked\");\n\n    return 0;\n\n}\n", "idx": 26880, "substitutes": {"c": ["f", "cl", "ic", "ch", "cf", "cam", "ce", "cu", "ca", "bc", "d", "pc", "rc", "abc", "tc", "dc", "cont", "cd", "at", "ec", "ctrl", "r", "cp", "p", "n", "cache", "sc", "nc", "cn", "cs", "cb", "cm", "call", "can", "enc", "cod", "com", "co", "chain", "b", "ct", "xc", "ac", "oc", "anc", "vc", "cr", "unc", "ci", "z", "mc", "con", "fc", "coll", "etc", "gc", "cc", "C", "v", "lc", "cv", "conf"], "fd": ["f", "sd", "pd", "fb", "hd", "ld", "aft", "stream", "cf", "dir", "flo", "nd", " df", "ff", "fa", "uf", "fee", "fs", "d", "std", "ln", "ini", "fr", "bf", "ds", " ff", " fin", "fin", "fl", " td", "gz", "fi", "fm", "func", "db", "lf", "fn", "cond", "dt", "io", "pid", "cb", " fid", "fed", "ctx", "form", "df", "td", "gd", "file", "ind", "dl", "dd", "dat", "bd", "dra", "fe", "handle", "fc", "wind", "ud", "fp", "FD", "ptr", " f", "elt"]}}
{"project": "qemu", "commit_id": "0c402e5abb8c2755390eee864b43a98280fc2453", "target": 0, "func": "static int usb_host_scan_dev(void *opaque, USBScanFunc *func)\n\n{\n\n    FILE *f = NULL;\n\n    char line[1024];\n\n    char buf[1024];\n\n    int bus_num, addr, speed, device_count, class_id, product_id, vendor_id;\n\n    char product_name[512];\n\n    int ret = 0;\n\n\n\n    if (!usb_host_device_path) {\n\n        perror(\"husb: USB Host Device Path not set\");\n\n        goto the_end;\n\n    }\n\n    snprintf(line, sizeof(line), \"%s/devices\", usb_host_device_path);\n\n    f = fopen(line, \"r\");\n\n    if (!f) {\n\n        perror(\"husb: cannot open devices file\");\n\n        goto the_end;\n\n    }\n\n\n\n    device_count = 0;\n\n    bus_num = addr = class_id = product_id = vendor_id = 0;\n\n    speed = -1; /* Can't get the speed from /[proc|dev]/bus/usb/devices */\n\n    for(;;) {\n\n        if (fgets(line, sizeof(line), f) == NULL) {\n\n            break;\n\n        }\n\n        if (strlen(line) > 0) {\n\n            line[strlen(line) - 1] = '\\0';\n\n        }\n\n        if (line[0] == 'T' && line[1] == ':') {\n\n            if (device_count && (vendor_id || product_id)) {\n\n                /* New device.  Add the previously discovered device.  */\n\n                ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                           product_id, product_name, speed);\n\n                if (ret) {\n\n                    goto the_end;\n\n                }\n\n            }\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Bus=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            bus_num = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Dev#=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            addr = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Spd=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            if (!strcmp(buf, \"5000\")) {\n\n                speed = USB_SPEED_SUPER;\n\n            } else if (!strcmp(buf, \"480\")) {\n\n                speed = USB_SPEED_HIGH;\n\n            } else if (!strcmp(buf, \"1.5\")) {\n\n                speed = USB_SPEED_LOW;\n\n            } else {\n\n                speed = USB_SPEED_FULL;\n\n            }\n\n            product_name[0] = '\\0';\n\n            class_id = 0xff;\n\n            device_count++;\n\n            product_id = 0;\n\n            vendor_id = 0;\n\n        } else if (line[0] == 'P' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Vendor=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            vendor_id = strtoul(buf, NULL, 16);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"ProdID=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            product_id = strtoul(buf, NULL, 16);\n\n        } else if (line[0] == 'S' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Product=\", \"\") < 0) {\n\n                goto fail;\n\n            }\n\n            pstrcpy(product_name, sizeof(product_name), buf);\n\n        } else if (line[0] == 'D' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Cls=\", \" (\") < 0) {\n\n                goto fail;\n\n            }\n\n            class_id = strtoul(buf, NULL, 16);\n\n        }\n\n    fail: ;\n\n    }\n\n    if (device_count && (vendor_id || product_id)) {\n\n        /* Add the last device.  */\n\n        ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                   product_id, product_name, speed);\n\n    }\n\n the_end:\n\n    if (f) {\n\n        fclose(f);\n\n    }\n\n    return ret;\n\n}\n", "idx": 26884, "substitutes": {"opaque": ["OPaque", "obque", "OPaques", "Opaques", "catque", "cataques", "opque", " opaques", "obaque", "Opaque", "opaques", "cataque", "OPque", "obaques", " opque", "Opque"], "func": ["job", "cf", "obj", "cu", "apply", "fw", "ff", "cand", "c", "tc", "wrapper", "act", "wrap", "cmd", "cast", "FC", "fn", "Function", "nc", "util", "cb", "ctx", "function", "coord", "unc", "fun", "fac", "fd", "con", "fc", "imp", "kw", "cc", "proc", "conv", "callback", "closure"], "f": ["fb", "i", "out", "cf", "o", "fw", "ff", "uf", "conn", "fs", "d", "w", "c", "fr", "bf", "fl", "buffer", "fi", "fm", "g", "r", "n", "p", "fn", "open", "file", "b", "l", "fac", "fd", "fc", "e", "fo", "u", "fp", "h", "t", "proc", "v", "F"], "line": ["range", "queue", "cell", "valid", "word", "buffer", "path", "in", "pe", "frame", "page", "link", "base", "stay", "detail", "note", "force", "store", "code", "try", "lane", "entry", "header", "cat", "tab", "msg", "le", "chain", "data", "key", "handle", "iter", "net", "lock", "device", "lo", "normal", "ln", "part", "def", "body", "nl", "ine", "comment", "lf", "eline", "lines", "lin", "print", "file", "Line", "l", "text", "limit", "no", "online", "str", "parse", "block", "stack", "out", "pipe", "look", "len", "se", "profile", "row", "cmd", "list", "message", "sequence", "LINE", "port", "query", "val", "flag", "mid", "cli", "name"], "buf": ["cur", "pb", "queue", "map", "buffer", "mem", "path", "pool", "que", "ctx", "raw", "orig", "rt", "wb", "history", "pkg", "obj", "br", "temp", "nb", "rev", "cat", "good", "db", "Buff", "tab", "msg", "bar", "bag", "data", "desc", "aka", "window", "bin", "iter", "bp", "Buffer", "buff", "fb", "batch", "box", "pad", "read", "seq", "lf", "lines", "bytes", "vec", "doc", "cfg", "file", "b", "rb", "tmp", "str", "cv", "block", "prop", "err", "uf", "row", "cmd", "img", "cb", "req", "port", "load", "ba", "txt", "val", "cap", "ret", "etc", "conv"], "bus_num": ["bus_nr", " bus_Num", "bus64num", " bus_no", "device_sum", " bus_mon", "bus64no", "bus64sum", "bus_no", " bus_NUM", " bus_number", "bus_Num", "device_num", "bus8Num", "device_nr", "bus8no", "busityno", "device_no", "bus_NUM", "bus_mon", "bus8num", "busitynum", "bus64nr", "bus_number", "bus8mon", "busityNUM", "bus_sum"], "addr": ["oad", "mac", "ad", "alt", "obj", "adr", "address", "arp", "ref", "home", "host", "pad", "rs", "id", "rc", "rev", "nl", "wd", "act", "cmd", "ack", "ar", "ace", "alias", "arr", "ord", "add", "rel", "prefix", "usr", "cb", "coord", "pos", "np", "align", "eth", "attr", "ac", "ag", "ip", "dr", "src", "loc", "url", "seek", "Address", "iter", "ret", "ptr", "offset", "pkg"], "speed": ["sys", "pretty", "device", "type", "peed", "length", "efficiency", "engine", "sn", "power", "sex", "score", "service", "status", "stick", "drive", "Speed", "spin", "error", "command", "secure", "sync", "loss", "powered", "spec", "species", "rate", "send", "count", "state", "sw", "performance", "sort", "policy", "kick", "scan", "priority", "rank", "size", "weight", "port", "scale", "slow", "reason", "delay", "interface", "version", "limit", "serial", "sp", "style", "kind", "driver", "timeout", "description", "offset", "ssl"], "device_count": ["devicePcode", "device_id", "device_cache", "device_counter", "serial_num", "device_only", "devicePonly", "device_code", "bus_only", "bus_id", "busPonly", "device_num", "busPcode", "busPcounter", "bus_counter", "devicePcount", "busPcount", "bus_count", "bus_code", "serial_cache", "devicePcounter", "serial_count"], "class_id": ["class_info", "classes_id", "class_name", "product_ids", "product_kind", "class_ident", "classitykind", "classityids", "classitytype", "classesityid", "classes_type", "classes_name", "classesityname", "classityident", "classityid", "classes_ident", "class_ids", "class_kind", "classityinfo", "classesityident", "classityname", "class_type", "classesitytype", "product_info"], "product_id": ["productTypeid", " product2id", "device_ide", " product_info", "product___ID", "product5info", "productOinterface", "product___name", "product_interface", " product_index", "product5id", " product_type", " product_ID", "device_interface", "product8name", "product_comment", "device_id", "product8interface", "productTypecomment", "product2id", " product_comment", "productWname", "product_type", "productTypename", " product2type", "productTypeonly", "device_name", "product8ide", " product_num", " product2info", "productOname", "product2info", "product___id", "product2type", " product2index", "product_index", "product5index", "product8id", "product_info", "product___num", " product_only", "product2index", "product_ide", "productOid", "productWcomment", "productWid", "product_ID", "productOide", "product_only", "product5type", "product_num", "productWonly"], "vendor_id": ["vendor5rank", "vince_name", "vender_name", "vender_ident", "vendor_num", "vendor_ident", "vendor5num", "vistor_oid", "vendor_name", "vender_num", "vince_id", "vendor5name", "vender_rank", "vistor_num", "vendor5id", "vistor_id", "vender_id", "vendor_rank", "vender_info", "vendor_path", "vince_type", "vendor_info", "vince_path", "vendor_oid", "vendor_type", "vistor_name"], "product_name": ["productnamenamed", "productnamename", "component_type", "component_Name", " product_path", "product_named", " product_named", "product_type", "component_info", " product_type", "productnametype", "component_name", "productnamepath", "product_Name", "product_info", "product_path"]}}
{"project": "qemu", "commit_id": "03ae4133ab8675d4c67e6fdc8032de7c53a89514", "target": 0, "func": "static void ppc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    pcc->parent_realize = dc->realize;\n\n    pcc->pvr = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->pvr_mask = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_always;\n\n    dc->realize = ppc_cpu_realizefn;\n\n    dc->unrealize = ppc_cpu_unrealizefn;\n\n\n\n    pcc->parent_reset = cc->reset;\n\n    cc->reset = ppc_cpu_reset;\n\n\n\n    cc->class_by_name = ppc_cpu_class_by_name;\n\n    cc->has_work = ppc_cpu_has_work;\n\n    cc->do_interrupt = ppc_cpu_do_interrupt;\n\n    cc->dump_state = ppc_cpu_dump_state;\n\n    cc->dump_statistics = ppc_cpu_dump_statistics;\n\n    cc->set_pc = ppc_cpu_set_pc;\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = ppc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = ppc_cpu_get_phys_page_debug;\n\n    cc->vmsd = &vmstate_ppc_cpu;\n\n#if defined(TARGET_PPC64)\n\n    cc->write_elf64_note = ppc64_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = ppc64_cpu_write_elf64_qemunote;\n\n#endif\n\n#endif\n\n\n\n    cc->gdb_num_core_regs = 71;\n\n\n\n#ifdef USE_APPLE_GDB\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register_apple;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register_apple;\n\n    cc->gdb_num_core_regs = 71 + 32;\n\n#endif\n\n\n\n#if defined(TARGET_PPC64)\n\n    cc->gdb_core_xml_file = \"power64-core.xml\";\n\n#else\n\n    cc->gdb_core_xml_file = \"power-core.xml\";\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->virtio_is_big_endian = ppc_cpu_is_big_endian;\n\n#endif\n\n\n\n    dc->fw_name = \"PowerPC,UNKNOWN\";\n\n}\n", "idx": 26886, "substitutes": {"oc": ["ocon", "oad", "uc", "ost", "ic", "toc", "o", "ok", "orp", "bc", "pc", "roc", "asc", "nic", "og", "oci", "ec", "cp", "ocation", "soc", "nc", "org", "ob", "arc", "mot", "aco", "osc", "voc", "OC", "co", "oid", "ogg", "vc", "unc", "ocr", "ac", "loc", "alloc", "mc", "oco", "ot"], "data": ["out", "ata", "boot", "dll", "d", "config", "def", "result", "output", "reg", "ds", "dev", "func", "cache", "rec", "di", "Data", "raw", "info", "dd", "dat", "bin", "DATA", "init", "name", "res"], "pcc": ["apcc", "pcfc", "pecca", " pbb", "precca", "pebb", "prouc", "pcCC", "cpcca", "Pcc", "ppbb", " pct", "pfc", "pcca", " pck", "procc", "cpce", "pcct", " pce", "pac", "apacc", "ppcc", "pbb", "pck", "procca", "peck", "preuc", "cpct", "ppct", "pct", "PCC", "prect", "Pac", " pfc", " pacc", "ppck", "pccc", "puc", " pCC", "Pct", "precc", "ppce", "apCC", " puc", "cpcc", "ppcca", " pac", "Pacc", "Pfc", "apac", "pce", "pacc", "pecc", " pcca", "pCC", "proct"], "cc": ["uc", "cmp", "kk", "ca", "ll", "cu", "cell", "c", "pp", "tc", "cont", "sync", "ctl", "soc", "isc", "ctx", "cy", "ct", "ci", "fc", "coll", "gc", "cf", "ce", "CCC", "conn", "code", "bc", "pc", "config", "ec", "ctrl", "func", "cast", "cp", "sc", "cs", "enc", "LC", "co", "vc", "lib", "mc", "con", "cl", "CC", "BC", "inc", "ucc", "cd", "cca", "icc", "ck", "lf", "nc", "disc", "cm", "go", "xx", "control", "lc", "cv", "ssl", "rc", "cmd", "erc", "cache", "bec", "cn", "craft", "acc", "xc", "ac", "unc", "cci", "city"], "dc": ["uc", "mac", "cmp", "cam", "ca", "pc", "bc", "d", "c", "rc", "cd", "tc", "cca", "ds", "ec", "ctl", "cp", "rec", "nc", "dt", "disc", "di", "cs", "ctx", "df", "co", "iac", "da", "dp", "ac", "vc", "de", "dd", "unc", "dr", "mc", "fc", "gc", "DC", "lc"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)\n\n{\n\n    VLANClientState *vc;\n\n\n\n    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {\n\n        if (vc != sender && !vc->link_down) {\n\n            vc->receive(vc->opaque, buf, size);\n\n        }\n\n    }\n\n}\n", "idx": 26904, "substitutes": {"vc": ["cmp", "cu", "ll", "rl", "fw", "att", "vp", "c", "pp", "tc", "dc", "cont", "vv", "isc", "ctx", "voc", "dl", "vl", "ci", "fc", "ich", "pkg", "v", "aq", "vm", "cil", "ch", "cf", "obj", "dq", "ev", "pc", "bc", "mk", "ctrl", "cp", "ship", "cs", "vr", "inv", "ht", "ach", "wcs", "ib", "vt", "vin", "lv", "hw", "sys", "bb", "iv", "kt", "lic", "nc", "cm", "form", "gm", "oc", "serv", "xp", "lp", "ls", "cc", "wx", "lc", "cv", "ic", "ow", "cmd", "cn", "irm", "WC", "cb", "gp", "craft", "VC", "xc", "ac", "nt", "cci", "sv", "hl", "jp", "uv", "ek"]}}
{"project": "qemu", "commit_id": "7b62a955047934bab158e84ecb63cb432c193ace", "target": 1, "func": "void ppc970_irq_init (CPUState *env)\n\n{\n\n    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);\n\n}\n", "idx": 26935, "substitutes": {"env": ["context", "engine", "esc", "sb", "server", "obj", "ev", "Environment", "conn", "code", "bc", "viron", "vp", "entry", "qt", "config", "pp", "ew", "dev", "buffer", "ec", "m", "ah", "sc", "state", "gov", "proc", "gear", "buf", "cb", "ctx", "vs", "policy", "environment", "shell", "js", " environment", "next", "desc", "port", "worker", "window", "e", "en", "sv", "self", "ptr", "h", "end", "eng", "vt", "uv", "v", "manager", "init", "this"]}}
{"project": "qemu", "commit_id": "1110bfe6f5600017258fa6578f9c17ec25b32277", "target": 0, "func": "static void do_interrupt_protected(CPUX86State *env, int intno, int is_int,\n\n                                   int error_code, unsigned int next_eip,\n\n                                   int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr, ssp;\n\n    int type, dpl, selector, ss_dpl, cpl;\n\n    int has_error_code, new_stack, shift;\n\n    uint32_t e1, e2, offset, ss = 0, esp, ss_e1 = 0, ss_e2 = 0;\n\n    uint32_t old_eip, sp_mask;\n\n    int vm86 = env->eflags & VM_MASK;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 8 + 7 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    ptr = dt->base + intno * 8;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 5: /* task gate */\n\n        /* must do that check here to return the correct error code */\n\n        if (!(e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n        }\n\n        switch_tss(env, intno * 8, e1, e2, SWITCH_TSS_CALL, old_eip);\n\n        if (has_error_code) {\n\n            int type;\n\n            uint32_t mask;\n\n\n\n            /* push the error code */\n\n            type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;\n\n            shift = type >> 3;\n\n            if (env->segs[R_SS].flags & DESC_B_MASK) {\n\n                mask = 0xffffffff;\n\n            } else {\n\n                mask = 0xffff;\n\n            }\n\n            esp = (env->regs[R_ESP] - (2 << shift)) & mask;\n\n            ssp = env->segs[R_SS].base + esp;\n\n            if (shift) {\n\n                cpu_stl_kernel(env, ssp, error_code);\n\n            } else {\n\n                cpu_stw_kernel(env, ssp, error_code);\n\n            }\n\n            SET_ESP(esp, mask);\n\n        }\n\n        return;\n\n    case 6: /* 286 interrupt gate */\n\n    case 7: /* 286 trap gate */\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_C_MASK) && dpl < cpl) {\n\n        /* to inner privilege */\n\n        get_ss_esp_from_tss(env, &ss, &esp, dpl, 0);\n\n        if ((ss & 0xfffc) == 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if ((ss & 3) != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (load_segment(env, &ss_e1, &ss_e2, ss) != 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        ss_dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;\n\n        if (ss_dpl != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_S_MASK) ||\n\n            (ss_e2 & DESC_CS_MASK) ||\n\n            !(ss_e2 & DESC_W_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        new_stack = 1;\n\n        sp_mask = get_sp_mask(ss_e2);\n\n        ssp = get_seg_base(ss_e1, ss_e2);\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (vm86) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        sp_mask = get_sp_mask(env->segs[R_SS].flags);\n\n        ssp = env->segs[R_SS].base;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        sp_mask = 0; /* avoid warning */\n\n        ssp = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n\n\n    shift = type >> 3;\n\n\n\n#if 0\n\n    /* XXX: check that enough room is available */\n\n    push_size = 6 + (new_stack << 2) + (has_error_code << 1);\n\n    if (vm86) {\n\n        push_size += 8;\n\n    }\n\n    push_size <<= shift;\n\n#endif\n\n    if (shift == 1) {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHL(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHL(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHL(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHL(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHL(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHL(ssp, esp, sp_mask, error_code);\n\n        }\n\n    } else {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHW(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHW(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHW(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHW(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHW(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHW(ssp, esp, sp_mask, error_code);\n\n        }\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        if (vm86) {\n\n            cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0, 0);\n\n        }\n\n        ss = (ss & ~3) | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss,\n\n                               ssp, get_seg_limit(ss_e1, ss_e2), ss_e2);\n\n    }\n\n    SET_ESP(esp, sp_mask);\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 26941, "substitutes": {"env": ["dh", "vp", "qt", "disk", "ect", "er", "dev", "pg", "et", "ctx", "vs", "environment", "attr", "dn", "pkg", "era", "h", "param", "v", "enter", "ei", "vm", "tm", "obj", "store", "ev", "conn", "code", "config", "erd", "eh", "ec", "ut", "inv", "desc", "window", "global", "en", "net", "vt", "Environment", "hw", "context", "esc", "ef", "network", "ah", "shell", "nv", "addr", "worker", "rb", "manager", "cv", "server", "ner", "ka", "vert", "tk", "commit", "rc", "ew", "cmd", "org", "cb", "esm", "nw", "np", "erb", "req", "e", "hl", "end", "eng", "uv"], "intno": ["internumber", "internum", "INTNo", "Intnumber", " intnum", "pointeno", "interNo", "intnos", "interdo", "Intno", "inno", "INTnumber", "intco", "altNO", "altdo", "innernos", "inteno", "intdo", " intna", "intNo", "intn", "actco", "pointdo", "altno", "INTnum", "pointco", "indo", "intnumber", "INTNO", " intdo", "intereno", " intnumber", "interno", "pointnum", "actdo", "interNO", "idNO", "altn", "indnum", "indno", "indna", "inna", "innerNO", "innerno", "intna", "pointna", "pointNo", "pointno", "iterdo", "idn", "IntNO", "actNo", "innerNo", "innum", "intNO", "iterno", "internos", "actno", "pointnos", "indnumber", "iternum", "iddo", " intn", "INTno", " intnos", " intNo", "iterna", " intNO", "intnum", "Intnum", "idno", " inteno", "interco", "INTnos", "pointnumber"], "is_int": ["isUinter", "is_str", "isOnei", " is_uint", "is_intel", "is_inter", "isUstr", " is_i", "is_internal", "is_win", "ishstr", " is_intel", "isUint", " is_internal", "ishintel", "isOneuint", "is_uint", "is_i", "ishint", " is_str", "ishwin", "isUinternal", "isOneint", "isOnestr", " is_inter", " is_win"], "error_code": ["ror_msg", "ror_code", "error___code", "error_mode", "error_msg", "error___msg", "error_codes", "error___mode", "ror_mode", "ror_codes", "error___codes"], "next_eip": ["next_eiph", "next_seip", "next_uip", "next2sei", "next___eip", "next2ei", "next___uid", "next_egiph", "next_gip", "next_uiph", "next2eIP", "next___uipp", "next___eipp", "next_egid", "next___eid", "next_seips", "next2eip", "next___eiph", "next2eips", "next_eeIP", "next_eipp", "next_eriph", "next_ei", "next2seip", "next___uiph", "next_uid", "next_egip", "next_sei", "next_eIP", "next_gIP", "next_eips", "next_eei", "next2seips", "next_erip", "next_eeips", "next_seIP", "next_eripp", "next_egipp", "next2seIP", "next_gips", "next___uip", "next_eid", "next_eeip", "next_uipp", "next_erid", "next_gi"], "is_hw": ["is_pkg", " is_cpu", " is_iw", "is_ht", "is_aux", " is_pkg", " is_hop", "is_iw", " is_ht", "is_hop", " is_aux", "is_cpu"], "dt": ["iat", "tm", "pb", "dq", "dh", "d", "tk", "qt", "kt", "ect", "tc", "dc", "tt", "ds", "tz", "tn", "db", "ctl", "dm", "et", "ctx", "td", "ta", "rt", "ct", "dp", "dl", "DT", "dd", "dat", "txt", "dn", "bt", "tif", "tp", "mt", "lp", "t", "elt"], "ptr": ["ep", "cur", "inter", "err", "obj", "adr", "ref", "address", "br", "pc", "Ptr", "pad", "rc", "ctr", "mem", "pr", "buffer", " pointer", "inst", "p", "tip", "pointers", "deg", "arr", "pointer", "rel", "rect", " ref", " sp", "ctx", "coord", "pos", " addr", " address", "np", "next", "eth", "prime", "req", "ind", "attr", "ts", "ip", "dr", "expr", "loc", "addr", "src", "handle", "sp", "tp", "bp", "mt", "off", "tr", "jp", "dep", "index", "pt"], "ssp": ["ssd", "ssb", "tsd", "sexd", "snl", "snd", "tsl", "tsb", "sexb", "ssl", "sexp", "tsp", "snb", "sexl", "snp"], "type": ["range", "class", "block", "ping", "option", "length", "action", "pack", "typ", "field", "address", "slice", "code", "status", "map", "value", "id", "change", "ty", "error", "ype", "what", "ver", "p", "count", "state", "set", "sort", "pe", " error", "tag", "rule", "otype", " typ", "test", "types", "size", "start", "port", "weight", "ip", "key", "Type", "link", "version", "TYPE", "tp", "e", "style", "kind", "time", "flag", "sp", "table", "t", "index", "lock", "name", "role"], "dpl": ["lfl", "lPL", "dPL", " dfl", "dpr", "ffl", "fpl", "fPL", " dPL", " dpr", "lpl", "fpr", "lpr", "dfl"], "selector": ["selective", "electors", "elector", "elective", "electori", "connectors", "connectori", "selectors", "rective", "rectori", "connector", "rectors", "connective", "rector", "selectori"], "ss_dpl": ["ss_dbl", "ss_spl", "ss_scl", "ss_lbl", "ss_dcl", "ss_sbl", "ss_dsl", "ss_lpl", "ss_fsl", "ss_lcl", "ss_lsl", "ss_fbl", "ss_fcl", "ss_fpl", "ss_ssl"], "cpl": ["cpp", "mpl", "mpp", "dpp", "mpt", "dPL", "dcpl", "cpt", "dcPL", "dpt", "dcpt", "mPL", "dcpp", "cPL"], "has_error_code": ["has_success_error", "has_error__codes", "has_success_code", "has_err_codes", "has_error_error", "has_error_codes", "has_error__error", "has_error__code", "has_error_time", "has_err_Code", "has_error_Code", "has_success_codes", "has_err_code", "has_success_Code", "has_error__time", "has_success_time"], "new_stack": ["raw_struct", "raw_st", "new_st", "raw_scope", "new_scope", "new_struct", "raw_stack"], "shift": ["range", "block", "hold", "hash", "Shift", "map", "skip", "push", "change", "id", "sup", "send", "shr", "sh", "set", "sort", "transform", "pos", "depth", "align", "rank", "share", "start", "scale", "delay", "seek", "window", "flag", "diff", "index", "sum", "hift", "init"], "e1": ["ee0", "e7", "te2", "xeOne", "ee3", "te1", "e3", "eone", "te0", "e5", "xeone", "ee1", "ee2", "xe1", "te3", " e5", "e0", " e0", "ee5", "ae2", " eOne", "xe2", " eone", "ee7", "te5", "te7", "aeone", " e7", "eOne", "ae1", " e3", "aeOne"], "e2": ["element2", "metwo", "ee0", "e7", "e02", "er5", "ee3", "me2", "e3", "ei3", "element1", "E7", "ee4", "e5", "E3", "me7", "E1", "ei1", "er4", " e02", "ee1", "er0", "ee2", "E4", " eTwo", "er02", "er1", " etwo", "e0", " e5", " e0", "ei4", "me3", "ee5", "ee02", "er3", " e4", "eTwo", "Etwo", "e4", "etwo", "E2", " e7", "ei2", "elementTwo", " e3", "element4", "er2", "eeTwo"], "offset": ["alt", "address", "ff", "slice", "op", "skip", "error", "transfer", "pointer", "extra", "sort", "origin", "pos", "start", "ip", "seek", "limit", "flag", "scroll", "mt", "off", "end", "index", "lock"], "esp": ["ep", "ef", "sb", "xy", "eps", "reset", "exe", "cp", "p", "esi", "resp", "isp", "yp", "et", "ap", "eb", "ns", "ps", "ip", "expr", "rss", "addr", "es", "imp", "sp", "tp", "bp", "exec", "xp", "fp", "lp", "rap", "asp"], "old_eip": ["old_seip", "old_meip", "old_eiph", "old_eep", "old_eeisp", "old_seib", "old_seips", "old_sei", "old_aeipt", "old_meib", "old_ceip", "old_dIP", "old_meipt", "old_eeib", "old_seiph", "old_seIP", "old_eeep", "old_nisp", "old___eeips", "old_ceIP", "old_aeIP", "old_ceiph", "old_dip", "old_eei", "old_dep", "old_eIP", "old___eeisp", "old_nips", "old___eips", "old_ei", "old___ei", "old_mei", "old_eeip", "old_meIP", "old___eisp", "old___eeip", "old_seep", "old_esips", "old_aeip", "old_meep", "old_eipt", "old_esiph", "old_ni", "old_seisp", "old_eisp", "old___eip", "old_ceips", "old_esIP", "old_esip", "old___eei", "old_eeips", "old_nip", "old_eips", "old_eib", "old_dipt", "old_aeep"], "sp_mask": ["p_mask", "sp_lock", "p_match", "p_lock", "p_ms", "sp_ms", "sp_match"], "mask": ["Mask", "pack", "ms", "batch", "hold", "ape", "hash", "code", "mb", "map", "skip", "id", "result", "zero", "master", "miss", "flags", "mx", "mk", "count", "mode", "arr", "filter", "set", "bits", "sort", "transform", "clear", "sk", "tag", "mark", "weight", "scale", "types", "key", "window", "limit", "flag", "mt", "max", "ask", "sum", "m", "lock", "sign"]}}
{"project": "qemu", "commit_id": "7e97cd88148876bad36ee7c66d526dcaed328d0d", "target": 0, "func": "static void kvm_start_vcpu(CPUState *env)\n\n{\n\n    env->thread = qemu_mallocz(sizeof(QemuThread));\n\n    env->halt_cond = qemu_mallocz(sizeof(QemuCond));\n\n    qemu_cond_init(env->halt_cond);\n\n    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);\n\n    while (env->created == 0)\n\n        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);\n\n}\n", "idx": 26945, "substitutes": {"env": ["dh", "vp", "ent", "disk", "er", "dev", "vv", "forge", "et", "ctx", "vs", "environment", "info", "equ", "era", "h", "v", "ee", "enter", "vm", "here", "obj", "ev", "code", "entry", "erd", "config", "eh", "ec", "db", "msg", "gear", "stage", "enc", "desc", "data", "window", "global", "en", "vt", "hw", "context", "ef", "network", "ah", "policy", "doc", "nv", "worker", "rb", "manager", "cv", "stack", "ov", "server", "err", "fee", "viron", "w", "event", "ew", "ext", "cmd", "ve", "org", "cb", "esm", "order", "up", "txt", "eve", "e", "sv", "etc", "self", "end", "eng", "uv", "proc", "em", "conf"]}}
{"project": "qemu", "commit_id": "c18ad9a54b75495ce61e8b28d353f8eec51768fc", "target": 0, "func": "static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,\n\n                                     bool secondary, target_ulong ptem,\n\n                                     ppc_hash_pte64_t *pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n    uint64_t token;\n\n    target_ulong pte0, pte1;\n\n    target_ulong pte_index;\n\n\n\n    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;\n\n    token = ppc_hash64_start_access(cpu, pte_index);\n\n    if (!token) {\n\n        return -1;\n\n    }\n\n    for (i = 0; i < HPTES_PER_GROUP; i++) {\n\n        pte0 = ppc_hash64_load_hpte0(cpu, token, i);\n\n        pte1 = ppc_hash64_load_hpte1(cpu, token, i);\n\n\n\n        if ((pte0 & HPTE64_V_VALID)\n\n            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))\n\n            && HPTE64_V_COMPARE(pte0, ptem)) {\n\n            pte->pte0 = pte0;\n\n            pte->pte1 = pte1;\n\n            ppc_hash64_stop_access(token);\n\n            return (pte_index + i) * HASH_PTE_SIZE_64;\n\n        }\n\n    }\n\n    ppc_hash64_stop_access(token);\n\n    /*\n\n     * We didn't find a valid entry.\n\n     */\n\n    return -1;\n\n}\n", "idx": 26946, "substitutes": {"cpu": ["vm", "sys", "device", "mac", "kernel", "bench", "chip", " pc", "cu", "boot", "conn", "ork", "pc", "ruby", "crypt", "c", "ilo", "core", "gpu", "mem", "buffer", "upt", "clock", "mx", "sync", "prof", "cmd", "pool", "cp", " proc", "linux", "memory", "apache", "node", " CPU", "ctx", "aco", "phys", " cp", "process", "hog", "processor", "CPU", "hap", "window", "handle", "pu", "java", "tp", "net", "gnu", "gc", "jp", "cc", "proc", "socket", "hw"], "hash": ["ping", "hw", "ch", "chip", "ih", "ref", "dh", "array", "map", "crypt", "profile", "rh", "sha", "password", "ho", "height", "header", "has", "cache", "kh", "sh", "node", "total", "tag", "primary", "data", "attr", "size", "key", "addr", "Hash", "ash", "handle", "ha", "version", "check", "ptr", "h", "t", "sum", "index", "name", "conf"], "secondary": ["secret", "sys", "iary", "external", "sensitive", "negative", " supplementary", "screen", "security", "master", "secure", "chron", "remote", "small", " external", "foreign", "binary", "sec", " primary", "primary", "ssl", "exclusive", "shared", "special", "physical", "SI", "missing", "global", "sharp", "shadow", "second", "unknown", "si", "single", "final", "ary", "weak", "multiple", "critical", "specific"], "ptem": ["aptee", "aptev", "pastem", "iptee", "iptev", "ptemi", "pasteem", "ptee", "apteme", " ptev", "aptemi", " pteme", "montemi", "apteem", "monteem", "pasteme", "ptev", "pastemi", " ptee", "aptem", "montem", "pteem", "monteme", "iptem", "ipteme", "pteme"], "pte": ["ppem", "ppe", "aptee", "ploadea", "artem", "ptel", "ploadet", "artel", "cto", "aptet", "apte", "portec", "ptye", "portem", "ppel", "portee", "ptee", "ptyet", "ptyea", "ptet", "ploade", "ctec", "porte", "arto", "arte", "ptec", "ptea", "ctee", "artec", "ploadee", "portel", "porto", "cte", "ptyee", "aptea", "pto", "artee", "ppee"], "env": ["priv", "vm", "context", "engine", "den", "ev", "conn", "code", "viron", "config", "entry", "map", "eh", "eni", "er", "ds", "dev", "mem", "ew", "ec", "pen", "ah", "ext", "cmd", "db", "ve", "org", "state", "node", "buf", "et", "ctx", "vs", "pe", "environment", "enc", "next", "doc", "cfg", "nv", "worker", "window", "con", "e", "net", "en", "cap", "serv", "ptr", "head", "her", "eng", "end", "proc", "v", "conf"], "i": ["ui", " j", " di", "o", " multi", "ini", "id", " iter", "in", "I", "p", " bi", "s", "sim", "ai", "li", "ip", "y", " mi", "ci", " si", "iu", " I", "si", "v", "ei", "ji", "\u0438", " ni", " ii", "n", "j", "init", "ind", "m", "qi", "ix", "x", "multi", "ri", "phi", "di", "zi", "mi", "ii", "is", "l", " ti", " pi", "bi", " index", " m", "xi", "im", "it", "ic", "pi", "ex", "g", "me", "gi", " my", "span", "hi", "ti", "e", "by", "u", "t", "index", "cli"], "token": ["statement", "field", "status", "KEY", "output", "word", "buffer", "p", "timer", "pointer", "prefix", "processor", "wt", "vector", "scope", "table", "variable", "tar", "note", "prototype", "value", "KEN", "tool", "header", "n", "state", "TO", "tty", "session", "created", "setup", "data", "key", "window", "label", "trigger", "joined", "TN", "lock", "callback", "tree", "device", "Token", "needed", "reset", "normal", "oken", "node", "rule", "template", "number", "single", "WT", "attribute", "match", "typ", "ok", "null", "kn", "tk", "result", "zero", "local", "password", "list", "record", "identified", "span", "message", "scan", "found", "present", "response", "txt", "json", "recorded", "channel", "seed", "t", "index", "socket"], "pte0": ["aptee8", "apteeNo", "pteleId", "ptee8", "ptoId", "ptelement1", "ptele0", "ptee255", "ptome050", "ptea01", "pte6", "ptoe2", "aptee0", "porteZero", "ptem1", "ptem00", "apte0", "portee6", "ptye01", "ptelement0", "pteeNo", "ptmezero", "ptme0", "ptee6", "ptee1", "ptea255", "apte255", "pte050", "ptee00", "ptE0", "porte0", "porte6", "pte2", "pteeId", "pteId", "ptoe255", "ptoNo", "ptyeZero", "portee8", "ptoe8", "ptea0", "pte255", "aptezero", "ptea1", "pte8", "ptme1", "ptoe1", "ptme00", "pto1", "ptee2", "portee01", "ptea8", "pteezero", "apteeId", "ptome0", "pteNo", "ptemzero", "ptee050", "ptelement6", "porte1", "apteId", "ptE8", "portee0", "pte00", "porteeZero", "ptee0", "aptee00", "ptye0", "ptye1", "pteleZero", "porte8", "ptelement050", "apte8", "apteezero", "ptoe0", "porte01", "apte1", "porte2", "pteZero", "portee2", "ptele1", "apte00", "apteNo", "portee050", "pteeZero", "portee1", "porte050", "pteaZero", "ptE1", "ptee01", "ptome6", "pteleNo", "aptee1", "ptem0", "ptome1", "pte01", "aptee255", "ptezero", "pto0", "ptE2"], "pte1": ["ptende1", "ptei0", "ptoe3", "ptee3", "pter0", "pointe0", "pteOne", "pointee2", "ptte91", "pterOne", "porte0", "ptei1", "pte2", "porte1", "pointe2", "pointe1", "ptree1", "pter1", "ptei3", "pointe3", "pte91", "ptte2", "pointee6", "ptee91", "portee0", "pointee3", "portee3", "portee1", "pointeeOne", "ptee0", "pointeOne", "pointe91", "ptoeOne", "pteeOne", "ptoe6", "pte6", "ptoe2", "pte3", "pointee91", "ptree0", "ptende2", "porte3", "porteOne", "porteeOne", "ptende0", "pointee0", "ptoe0", "ptoe1", "pter2", "ptreeOne", "ptree3", "pointe6", "ptei6", "ptee2", "ptee6", "ptee1", "ptte1", "ptende91", "pointee1", "ptte0"], "pte_index": ["pte2Index", "pte_path", "pte_no", "pte8index", "pte8Index", "pte_key", "ptee_block", "ptee_head", "ptee_path", "pte_block", "ptee_type", "pte_head", "ptoe_key", "pte2size", "pte12block", "pte12index", "ptoe_Index", "ptee_index", "ptee_no", "pte2key", "pte8find", "pte_type", "ptoe_size", "pte__num", "pte_size", "pte__index", "pte__no", "pte_find", "pte12path", "pte8head", "pte12Index", "pte_Index", "pte2index", "ptee_find", "ptoe_index", "ptee_Index", "pte_num", "ptee_num", "pte__type"]}}
{"project": "FFmpeg", "commit_id": "39f7620d76c7a133535ed7a535f7a74fefa6e435", "target": 0, "func": "static av_cold int dcadec_init(AVCodecContext *avctx)\n\n{\n\n    DCAContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    s->core.avctx = avctx;\n\n    s->exss.avctx = avctx;\n\n    s->xll.avctx = avctx;\n\n    s->lbr.avctx = avctx;\n\n\n\n    ff_dca_init_vlcs();\n\n\n\n    if (ff_dca_core_init(&s->core) < 0)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (ff_dca_lbr_init(&s->lbr) < 0)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ff_dcadsp_init(&s->dcadsp);\n\n    s->core.dcadsp = &s->dcadsp;\n\n    s->xll.dcadsp = &s->dcadsp;\n\n    s->lbr.dcadsp = &s->dcadsp;\n\n\n\n    s->crctab = av_crc_get_table(AV_CRC_16_CCITT);\n\n\n\n    switch (avctx->request_channel_layout & ~AV_CH_LAYOUT_NATIVE) {\n\n    case 0:\n\n        s->request_channel_layout = 0;\n\n        break;\n\n    case AV_CH_LAYOUT_STEREO:\n\n    case AV_CH_LAYOUT_STEREO_DOWNMIX:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_STEREO;\n\n        break;\n\n    case AV_CH_LAYOUT_5POINT0:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT0;\n\n        break;\n\n    case AV_CH_LAYOUT_5POINT1:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT1;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_WARNING, \"Invalid request_channel_layout\\n\");\n\n        break;\n\n    }\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S32P;\n\n    avctx->bits_per_raw_sample = 24;\n\n\n\n    return 0;\n\n}\n", "idx": 26947, "substitutes": {"avctx": ["vrconfig", "vanjp", "averctx", "aftx", "wavtx", "averval", "AVpkg", "verconn", "awtx", "vantx", "vrcontext", "avercp", "vrctx", "verctx", "wavjac", "awctx", "ajcu", "avcfg", "avpkg", "averpkg", "avcmp", " avqt", "vartx", "avetimeout", "AVjac", "wavcontext", "avval", "vanctx", "avecmd", "ajtx", "vrcmp", "avcpu", " avpa", "afobj", "avpa", "avercontext", " avcpu", "savcontext", " avobj", "vertx", "savcu", "avcu", "avecpu", "navtx", "vercontext", "navcontext", " avcmd", " avjac", " avconn", "avcam", "savcp", "afcontext", "varnp", " avpkg", "afjp", "ajcam", " avcontext", "vrjac", "wavcu", "avercam", "avecontext", "AVobj", "ajctx", " avconfig", "vanpa", "avtimeout", "wavcam", " avnp", "awcp", "navjp", "savctx", "avertimeout", "avqt", "AVctx", "avectx", "afctx", "awcfg", "avtxt", "abtx", "avtx", "vcmp", "abctx", "navctx", "varqt", " avcfg", " avval", "varctx", "avcmd", "vcmd", "avertxt", "averqt", "avercpu", "avetx", "avnp", "vrcmd", "vrtxt", "avcontext", " avtimeout", "abcontext", "averjac", " avcmp", "avobj", " avcu", "avcp", "averpa", "avercu", " avcp", "avercfg", "aveconfig", "wavctx", "avjac", "AVcfg", "averjp", "avertx", "avconn", "abconn", "avjp", " avtxt", "vcontext", " avtx", "AVcontext", "avernp", "vctx", "AVtx", "avconfig", " avjp", "wavval", "vrtx", "vrjp"], "s": ["ops", "comm", "sports", "c", "sam", "er", "comments", "pers", "changes", "aws", "vs", "S", "ns", "save", "y", "states", "less", "v", "sq", "ess", "i", "sb", "uploads", "args", "obj", "store", "os", "erences", "rs", "rates", "sl", "spec", "state", "cs", "services", "j", "als", "so", "ats", "ts", "ims", "acs", "des", "tes", "its", "conv", "ms", "as", "full", "ins", "gets", "ants", "ses", "has", "bis", "sts", "sw", "bs", "is", "b", "ps", "stats", "gs", "serv", "ls", "all", "f", "ports", "se", "fs", "w", "bes", "ds", "hs", "params", "details", "g", "set", "js", "ss", "settings", "qs", "south", "es", "sv", "self", "source", "t", "conf"]}}
{"project": "FFmpeg", "commit_id": "90901860c21468d6e9ae437c2bacb099c7bd3acf", "target": 0, "func": "static int vorbis_parse_setup_hdr_mappings(vorbis_context *vc) {\n\n    GetBitContext *gb=&vc->gb;\n\n    uint_fast8_t i, j;\n\n\n\n    vc->mapping_count=get_bits(gb, 6)+1;\n\n    vc->mappings=(vorbis_mapping *)av_mallocz(vc->mapping_count * sizeof(vorbis_mapping));\n\n\n\n    AV_DEBUG(\" There are %d mappings. \\n\", vc->mapping_count);\n\n\n\n    for(i=0;i<vc->mapping_count;++i) {\n\n        vorbis_mapping *mapping_setup=&vc->mappings[i];\n\n\n\n        if (get_bits(gb, 16)) {\n\n            av_log(vc->avccontext, AV_LOG_ERROR, \"Other mappings than type 0 are not compliant with the Vorbis I specification. \\n\");\n\n            return 1;\n\n        }\n\n        if (get_bits1(gb)) {\n\n            mapping_setup->submaps=get_bits(gb, 4)+1;\n\n        } else {\n\n            mapping_setup->submaps=1;\n\n        }\n\n\n\n        if (get_bits1(gb)) {\n\n            mapping_setup->coupling_steps=get_bits(gb, 8)+1;\n\n            mapping_setup->magnitude=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));\n\n            mapping_setup->angle=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));\n\n            for(j=0;j<mapping_setup->coupling_steps;++j) {\n\n                mapping_setup->magnitude[j]=get_bits(gb, ilog(vc->audio_channels-1));\n\n                mapping_setup->angle[j]=get_bits(gb, ilog(vc->audio_channels-1));\n\n                // FIXME: sanity checks\n\n            }\n\n        } else {\n\n            mapping_setup->coupling_steps=0;\n\n        }\n\n\n\n        AV_DEBUG(\"   %d mapping coupling steps: %d \\n\", i, mapping_setup->coupling_steps);\n\n\n\n        if(get_bits(gb, 2)) {\n\n            av_log(vc->avccontext, AV_LOG_ERROR, \"%d. mapping setup data invalid. \\n\", i);\n\n            return 1; // following spec.\n\n        }\n\n\n\n        if (mapping_setup->submaps>1) {\n\n            mapping_setup->mux=(uint_fast8_t *)av_mallocz(vc->audio_channels * sizeof(uint_fast8_t));\n\n            for(j=0;j<vc->audio_channels;++j) {\n\n                mapping_setup->mux[j]=get_bits(gb, 4);\n\n            }\n\n        }\n\n\n\n        for(j=0;j<mapping_setup->submaps;++j) {\n\n            skip_bits(gb, 8); // FIXME check?\n\n            mapping_setup->submap_floor[j]=get_bits(gb, 8);\n\n            mapping_setup->submap_residue[j]=get_bits(gb, 8);\n\n\n\n            AV_DEBUG(\"   %d mapping %d submap : floor %d, residue %d \\n\", i, j, mapping_setup->submap_floor[j], mapping_setup->submap_residue[j]);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 26971, "substitutes": {"vc": ["vm", "ic", "fax", "conv", "vd", "ev", "lv", "voice", "csv", "pc", "bc", "vert", "vp", "ow", "gt", "tv", "c", "pp", "vine", "veh", "sky", "dc", "wx", "vv", "wd", "iv", "mk", "dev", "wr", "cmd", "ve", "cs", "irm", "WC", "vol", "vr", "inv", "vg", "ht", "vs", "vin", "voc", "VC", "vo", "av", "form", "vy", "craft", "wcs", "nv", "xc", "nt", "vl", "ant", "px", "fc", "coll", "course", "serv", "sv", "xp", "etc", "ib", "vi", "vt", "cc", "uv", "v", "vet", "lc", "cv", "hw"], "gb": ["vm", "sys", "bb", "fb", "sb", "gy", "pb", "gam", "Gb", "bridge", "vd", "csv", "mb", "nb", "ruby", "wm", "gt", "pi", "storage", "gif", "arb", "goo", "bf", "GB", "gpu", "phy", "gz", "bm", "g", "db", "fps", "pg", "img", "rect", "cb", "bytes", "cm", "gg", "hub", "gp", "ctx", "vg", "eg", "kb", "binary", "bits", "bs", "bg", "eb", "gd", "html", "cfg", "gm", "tg", "hog", "raw", "py", "gh", "attr", "abi", "wb", "lib", "ub", "bt", "gs", "rb", "aaa", "gnu", "ib", "gc", "buff", "vt", "uv", "rg", "cv"], "i": ["ji", "f", "it", "my", "ic", "x", "batch", "ui", "multi", "\u0438", "o", "point", "ie", "ami", "pi", "c", " ii", "k", "id", "ini", "index", "ia", "ri", "fi", "g", "in", "me", "gi", "I", "n", "p", "phi", "s", "di", "zi", "sim", "go", "ai", "asi", "mi", "ii", "li", "kit", "instance", "any", "ti", "b", "l", "ind", "info", "bi", "ij", "y", "ims", "ip", "key", "ci", "ish", "e", "iu", "iso", "xi", "si", "t", "im", "m", "v", "qi", "ei", "ix"], "j": ["ji", "it", "je", "ch", "x", "job", "prop", "other", "obj", "jac", "ja", "jump", "br", "ev", "ju", "att", "v", "ie", "uj", "us", "c", "dj", "index", "k", "fr", "yy", "ng", "g", "n", "p", "kh", "jo", "kj", "sim", "J", "ii", "js", "jc", "jas", "b", "ind", "bi", "ij", "y", "bj", "key", "kid", "z", "json", "oj", "str", "jp", "t", "q", "m", "jj", "jl", "aj", "ix"], "mapping_setup": ["mitation_des", "mappingptsetup", "mapping1prefix", "mapper_check", "mapping_success", "mapping_prep", "matching_setup", "mapping___sequence", "mitation8status", "mappingptsummary", "mangling_site", "mapping___prefix", "mappingingsetup", "mapping67check", "manting_summary", "matching_prefix", "maming_response", "mappingpttrack", "mappinglistcreate", "mapping_config", "mapping1des", "mapping67data", "mappingptSetup", "mappingacsite", "mappingacsetup", "mappinglisttool", "mapping_test", "mapping_update", "mording_success", "mapping___Setup", "mapping_share", "mapping_request", "mapping67setup", "mapping_track", "mangling_setup", "mapping_runner", "mapping2setup", "mantingingSetup", "mappinglistrunner", "matching_prep", "mappinglistsetup", "matching_track", "mapping___request", "mapping___des", "mapping8site", "mapping_sequence", "mantingingshare", "mitation_setup", "mapping1join", "mapping8des", "mapping___create", "mapping___store", "mapper_prep", "mappingertest", "mappingptdes", "mapping___success", "mapping_create", "matching___track", "mapping67Setup", "mutationersetup", "matching_sequence", "mitation8response", "mappingptsequence", "mording_tool", "mapping1Setup", "mapper_Setup", "matchingersite", "mappinglisttest", "mapping2track", "mitation8setup", "mappingptshare", "mapping_status", "mutation_setup", "matching_site", "mappingingsummary", "matching___store", "mapper_data", "mapping___track", "mappingingshare", "mapping8summary", "matching_Setup", "matching_des", "mutation_test", "mapping_des", "mantingingsummary", "mording_create", "manglingacsite", "maming_success", "mapping8status", "mording___tool", "mapper_request", "mapping_tool", "mapping1setup", "mapping___setup", "mapping___site", "mappingacprep", "matching_store", "mapping_store", "mapping8response", "matching_join", "mappingersite", "mappinglistupdate", "mapping_site", "mapping2store", "mapping_summary", "matching___setup", "mording_setup", "mappingptstore", "maming_Setup", "mappingerrunner", "matching___sequence", "mapping_data", "matching_summary", "mording___setup", "manglingacSetup", "mapping1site", "mappingerupdate", "mappingersetup", "mutationerupdate", "mutationerrunner", "mitation_response", "mapping_check", "manting_setup", "mapping2sequence", "mapping_response", "mangling_prep", "mapping_join", "maming_setup", "mitation8des", "mapper_setup", "mitation_status", "mappingptstatus", "mantingingsetup", "mapping___prep", "manglingacprep", "mutationertest", "mapping_prefix", "mapping___tool", "mangling_Setup", "mapping_Setup", "mutation_update", "mapping8setup", "mapping1prep", "mappingacSetup", "manting_Setup", "manting_share", "mappingersummary", "mutation_runner", "matchingersummary", "matchingersetup", "mappingingSetup", "mappingptresponse", "mording___success", "mappinglistsuccess", "mording___create", "manglingacsetup"]}}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)\n\n{\n\n    val = tswap64(val);\n\n    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));\n\n}\n", "idx": 26987, "substitutes": {"dev": ["device", "ch", "ad", "cam", "obj", "home", "ref", "ev", "conn", "iv", "wh", "d", "pad", "w", "def", "att", "adv", "sky", "mem", "md", "DEV", "p", "od", "ach", "nt", "de", "addr", "dem", "Dev", "pro", "serv", "ptr", "h", "proc", "v", "hw"], "taddr": [" tptr", " tmap", "vmap", "vaddress", "tadd", "vaddr", "paddress", " taro", "vtaddress", "vtaddr", "tptr", " tadd", " taddress", "taddress", "paro", "vtaro", "vtadd", "vptr", "padd", "paddr", "pmap", "taro", "tmap", "pptr"], "val": ["f", "pol", "it", "x", "alt", "lit", "tx", "cal", "rol", "err", "al", "ref", "aval", "bl", "len", "fee", "sol", "bit", "value", "valid", "reg", "mem", "pr", "var", "seq", "m", "fl", "sel", "sl", "p", "arr", "vol", "resp", "msg", "buf", "ctx", "pl", "vec", "doc", "b", "data", "Val", "test", "ac", "VAL", "l", "vals", "ival", "eval", "num", "serv", "ret", "all", "vt", "t", "arg", "v", "elt", "pt", "res"]}}
{"project": "FFmpeg", "commit_id": "066fff755a5d8edc660c010ddb08474d208eeade", "target": 0, "func": "static void vp6_parse_coeff_models(VP56Context *s)\n\n{\n\n    VP56RangeCoder *c = &s->c;\n\n    VP56Model *model = s->modelp;\n\n    int def_prob[11];\n\n    int node, cg, ctx, pos;\n\n    int ct;    /* code type */\n\n    int pt;    /* plane type (0 for Y, 1 for U or V) */\n\n\n\n    memset(def_prob, 0x80, sizeof(def_prob));\n\n\n\n    for (pt=0; pt<2; pt++)\n\n        for (node=0; node<11; node++)\n\n            if (vp56_rac_get_prob(c, vp6_dccv_pct[pt][node])) {\n\n                def_prob[node] = vp56_rac_gets_nn(c, 7);\n\n                model->coeff_dccv[pt][node] = def_prob[node];\n\n            } else if (s->framep[VP56_FRAME_CURRENT]->key_frame) {\n\n                model->coeff_dccv[pt][node] = def_prob[node];\n\n            }\n\n\n\n    if (vp56_rac_get(c)) {\n\n        for (pos=1; pos<64; pos++)\n\n            if (vp56_rac_get_prob(c, vp6_coeff_reorder_pct[pos]))\n\n                model->coeff_reorder[pos] = vp56_rac_gets(c, 4);\n\n        vp6_coeff_order_table_init(s);\n\n    }\n\n\n\n    for (cg=0; cg<2; cg++)\n\n        for (node=0; node<14; node++)\n\n            if (vp56_rac_get_prob(c, vp6_runv_pct[cg][node]))\n\n                model->coeff_runv[cg][node] = vp56_rac_gets_nn(c, 7);\n\n\n\n    for (ct=0; ct<3; ct++)\n\n        for (pt=0; pt<2; pt++)\n\n            for (cg=0; cg<6; cg++)\n\n                for (node=0; node<11; node++)\n\n                    if (vp56_rac_get_prob(c, vp6_ract_pct[ct][pt][cg][node])) {\n\n                        def_prob[node] = vp56_rac_gets_nn(c, 7);\n\n                        model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n\n                    } else if (s->framep[VP56_FRAME_CURRENT]->key_frame) {\n\n                        model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n\n                    }\n\n\n\n    if (s->use_huffman) {\n\n        for (pt=0; pt<2; pt++) {\n\n            vp6_build_huff_tree(s, model->coeff_dccv[pt],\n\n                                vp6_huff_coeff_map, 12, &s->dccv_vlc[pt]);\n\n            vp6_build_huff_tree(s, model->coeff_runv[pt],\n\n                                vp6_huff_run_map, 9, &s->runv_vlc[pt]);\n\n            for (ct=0; ct<3; ct++)\n\n                for (cg = 0; cg < 6; cg++)\n\n                    vp6_build_huff_tree(s, model->coeff_ract[pt][ct][cg],\n\n                                        vp6_huff_coeff_map, 12,\n\n                                        &s->ract_vlc[pt][ct][cg]);\n\n        }\n\n        memset(s->nb_null, 0, sizeof(s->nb_null));\n\n    } else {\n\n    /* coeff_dcct is a linear combination of coeff_dccv */\n\n    for (pt=0; pt<2; pt++)\n\n        for (ctx=0; ctx<3; ctx++)\n\n            for (node=0; node<5; node++)\n\n                model->coeff_dcct[pt][ctx][node] = av_clip(((model->coeff_dccv[pt][node] * vp6_dccv_lc[ctx][node][0] + 128) >> 8) + vp6_dccv_lc[ctx][node][1], 1, 255);\n\n    }\n\n}\n", "idx": 26988, "substitutes": {"s": ["f", "sys", "i", "sb", "o", "ins", "os", "se", "fs", "rs", "w", "ses", "ds", "hs", "g", "r", "spec", "times", "n", "p", "sc", "sets", "cs", "sts", "aws", "S", "js", "bs", "ss", "settings", "a", "is", "b", "ts", "ns", "ps", "ats", "qs", "stats", "es", "e", "less", "sv", "gs", "h", "t", "ls", "m", "v", "sq"], "c": ["f", "cl", "ic", "ch", "context", "uc", "as", "cf", "ce", "cu", "ca", "jac", "bc", "pc", "tc", "rc", "abc", "dc", "cont", "ec", "g", "r", "cp", "p", "n", "cache", "cus", "sc", "cn", "nc", "cs", "cm", "com", "co", "chain", "a", "b", "xc", "l", "ac", "unc", "vc", "mc", "con", "fc", "e", "u", "gc", "h", "t", "cc", "C", "v", "lc", "m", "cv"], "model": ["vm", "handler", "server", "ll", "rm", "man", "network", "address", "mb", "app", "models", "config", "map", "Model", "mem", "mm", "bm", "member", "dev", "command", "db", "p", "el", "mail", "remote", "mode", "filter", "leader", "mod", "sim", "module", "policy", "transform", "form", "message", "mi", "controller", "frame", "rule", "project", "response", "l", "sm", "link", "base", "relation", "table", "ml", "manager", "m", "v"], "def_prob": ["def_probe", "def_Prob", "def_prox", "def_predx", "def_purba", "def_proba", "def_prx", "def_prep", "defingcacheb", "def_coc", "def_funb", "def_prc", "def_func", "def_Proba", "def_predb", "def_profB", "def_cobe", "def_cachebf", "def_predp", "def_prof", "def_funbe", "def_profbf", "defingprobf", "def_cob", "def_Proc", "def_proob", "def_comc", "def_cacheb", "def_cacheB", "def_profba", "def_prex", "def_cacheba", "def_purb", "def_prba", "def_comf", "def_prif", "def_probf", "defingprob", "def_purx", "def_prop", "def_Prof", "defingcacheB", "def_Prop", "def_Proob", "def_fung", "def_pric", "def_proc", "def_purbe", "defingcachebf", "def_prg", "def_prib", "def_Probe", "def_prb", "defingproB", "def_predob", "def_preb", "def_prip", "def_prbe", "def_prog", "def_preob", "defingcacheba", "def_profb", "def_coba", "def_Prog", "def_comp", "def_Prox", "def_comb", "defingproba", "def_proB"], "node": ["hop", "nd", "son", "station", "host", "child", "cell", "ent", "unit", "id", "nut", "Node", "non", "stone", "day", "pe", "and", "token", "kid", "snap", "gc", "ptr", "onet", "note", "parent", "kan", "obj", "edge", "conn", "pc", "generation", "value", "n", "remote", "msg", "function", "session", "inner", "ind", "nce", "net", "en", "slot", "point", "card", "tree", "device", "type", "our", "x", "peer", "ano", "nn", "box", "entity", "col", "part", "cd", "kt", "member", "now", "nc", "pn", "go", "cod", "td", "depth", "ne", "process", "back", "cookie", "tp", "tmp", "no", "stroke", "od", "client", "server", "component", "yn", "bo", "zero", "event", "local", "ng", "wo", "row", "cmd", "holder", "nw", "nu", "nie", "np", "connection", "degree", "ode", "nt", "post", "port", "annot", "wn", "num", "seed", "leaf", "t", "mid", "index", "name"], "cg": ["cw", "ccgu", "cctg", "cacheog", "acsg", "ucgt", "cogu", " cyg", "cfgi", "cachegm", "cmg", "congm", "casegu", "acgi", "vcg", " cgd", "cgm", " cw", " cgu", "ecge", "cong", "lcg", "cdbg", "congi", "cachegp", "dcg", "cgr", "lcged", "cmsg", "xcmsg", "conmsg", "casege", "ctg", " ctg", " cgi", "cgt", "cacheyg", "lcgm", "cbg", "vcgi", "cgp", "vcgd", " cgr", "cged", " cgm", "acgd", "ccg", "congr", "acgr", "xcgm", " cog", "ecmg", " cgg", "cachegu", "cgi", "caseg", "lcmsg", "ccmg", "cgs", "ccgp", "acgm", "congg", "cachegg", "cfgo", "dcgs", "cachetg", "ucog", " cged", "ecgu", "casemg", "cdmsg", "cgd", " cgs", "conbg", "cgg", "dcgo", "cdgi", "cogm", "cfg", " cgp", "ecg", "cgu", "acg", "conyg", " cgo", "cachegt", "cfgr", "acmsg", "xcged", "cogr", "csg", "cfgs", "cfgm", "ucgu", "ccw", "cachew", "ccgr", "consg", "ccgm", "vcgm", " cmsg", "cgo", "xcg", "cfgu", "cyg", "cge", "cacheg", " cgt", "ccge", "ucg", "cdg", "dcgi", "cog", " csg", " cbg"], "ctx": ["context", "cmp", "tx", "cf", "obj", "jac", "col", "gt", "pot", "kt", "tc", "cd", "ctr", "act", "cmd", "cp", "cb", "np", "co", "xs", "ac", "nt", "ant", "loc", "txt", "tmp", "cc", "ot"], "pos": ["prop", "parent", "out", "client", "tx", "trans", "pose", "po", "len", "os", "col", "Pos", "pc", "pad", "part", "def", "pi", "pot", "at", "pr", "act", "row", "neg", "spec", "n", "p", "cond", "POS", "pid", "kat", "add", "resp", "pl", "ot", "pass", "doc", "ind", "nt", "port", "ps", "post", "loc", "key", "px", "position", "num", "pro", "sp", "val", "pres", "apo", "rot", "offset", "slot", "pat", "no", "index", "point", "res"], "ct": ["opt", "unt", "capt", "cf", "gen", "obj", "cent", "percent", "col", "sit", "ent", "sat", "pot", "cd", "kt", "ect", "fact", "tt", "crit", "ctr", "cont", "cats", "nut", "apt", "act", "Ct", "cmd", "cat", "ctl", "cond", "cp", "count", "dt", "nc", "cn", "mat", "lat", "ppa", "et", "ht", "cod", "rt", "CT", "cart", "nt", "ant", "cot", "bt", "ft", "tp", "net", "cap", "ptr", "tc", "pat", "t", "vt", "stat", "tmp", "ot", "vet", "pent", "cv", "sect"], "pt": ["pd", "pton", "typ", "tx", "pan", "point", "po", "conn", "ipt", "pty", "pc", "col", "part", "qt", "bo", "gt", "pp", "kt", "ppa", "pot", "ds", "pr", "tz", "apt", "chron", "act", "cmd", "pool", "PT", "n", "p", "cp", "points", "pg", "pid", "dt", "pn", "set", "plot", "lat", "et", "ht", "j", "pl", "td", "pit", "rt", "py", "ts", "ps", "port", "nt", "pa", "ept", "txt", "wt", "px", "tp", " pts", "sp", "mt", "slot", "ptr", "pkg", "pat", "t", "ot", "vet", "mont"]}}
{"project": "qemu", "commit_id": "21f88d021d0d2b4ecee8f6cd6ca63a943a3ce71d", "target": 1, "func": "test_opts_dict_unvisited(void)\n\n{\n\n    QemuOpts *opts;\n\n    Visitor *v;\n\n    UserDefOptions *userdef;\n\n\n\n    opts = qemu_opts_parse(qemu_find_opts(\"userdef\"), \"i64x=0,bogus=1\", false,\n\n                           &error_abort);\n\n\n\n    v = opts_visitor_new(opts);\n\n    /* BUG: bogus should be diagnosed */\n\n    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);\n\n    visit_free(v);\n\n    qemu_opts_del(opts);\n\n    qapi_free_UserDefOptions(userdef);\n\n}\n", "idx": 26993, "substitutes": {"opts": ["oppt", "opals", "opt", "OPals", "iopts", "ops", "props", "propt", "popals", "iopt", "pops", "opTS", "optfs", "opopt", "optals", " oppt", "iopps", " ops", "OPTS", "optopt", "OPs", "popcs", "cops", "copTS", " opopt", "OPopt", "OPcs", "optTS", "copts", "prot", "OPts", "OPt", "opcs", "optcs", "ioppt", "copfs", " opps", "prots", "opfs", "opps", " opt", "optt", "popts", "optts", "OPfs"], "v": ["vm", "f", "it", "vu", "ov", "i", "o", "conv", "ev", "iv", "vp", "tv", "w", "c", "pr", "var", "g", "ver", "ve", "p", "s", "gener", "vr", "j", "vs", "inv", "vo", "av", "V", "vy", "b", "nv", "l", "vc", "sv", "u", "qv", "vi", "h", "q", "vt", "uv", "m", "t", "cv"], "userdef": ["Userdef", "Userdefined", "Userdefinition", "usrdf", "UserDef", "usrdef", "Useref", " useref", "useDef", " userDef", " userdf", "mapdefined", "useref", "usrdefined", "mapdefinition", "usrDef", "userdefinition", "usref", "userdf", "usedf", "mapDef", " userdefinition", "userdefined", " userdefined", "userDef", "mapdef", "usedef"]}}
{"project": "qemu", "commit_id": "67a0fd2a9bca204d2b39f910a97c7137636a0715", "target": 0, "func": "static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *pnum)\n\n{\n\n    BDRVParallelsState *s = bs->opaque;\n\n    int64_t offset;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    offset = block_status(s, sector_num, nb_sectors, pnum);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (offset < 0) {\n\n        return 0;\n\n    }\n\n\n\n    return (offset << BDRV_SECTOR_BITS) |\n\n        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;\n\n}\n", "idx": 27000, "substitutes": {"bs": ["sb", "bas", "bl", "lbs", "bles", "fs", "bc", "rs", "bes", "BS", "bf", "ubs", "ds", "hs", "bm", "aos", "bos", "bis", "fps", "cs", "bits", "iss", "js", "ss", "b", "ns", "ts", "ps", "bi", "aus", "bh", "its", "gs", "bp", "obs", "ys", "ls", "blog"], "sector_num": ["sector_mult", " sector_mult", "sectorIdnum", "sector2number", "sector2mult", "sector_number", " sector_coord", "sectorIdnumber", "sectorIdmult", "sectorIdmon", "sector_no", " sector_number", " sector_no", "sector_coord", "sector2mon", "sector_mon", " sector_mon", "sector2num"], "nb_sectors": ["nb_pectors", "nb_peors", "nb_perseors", "nb_persegments", "nb_peivers", "nb_seivers", "nb_speivers", "nb_segments", "nb_veivers", "nb_vegments", "nb_psectors", "nb_pseors", "nb_persectors", "nb_perseicators", "nb_vectors", "nb_seors", "nb_veicators", "nb_veors", "nb_vecs", "nb_secs", "nb_spectors", "nb_specs", "nb_pecs", "nb_psegments", "nb_pseicators", "nb_seicators", "nb_speors"], "pnum": ["pngnum", "pnumer", "pnnum", "penumer", "gnnum", "pnUM", "pennum", "PNumer", "pnumeric", "PNUM", "panum", "panumer", "penum", "PNnum", "pngumer", "gnum", "gnumer", "pngumeric", "pngum", "panUM", "gnumeric", "PNum", "penUM", "penumeric", "pannum"], "s": ["sys", "sn", "ms", "space", "sb", " ss", "store", "sis", "service", "os", "fs", "sol", "rs", "c", "sam", "ses", "ds", "hs", "sl", "g", "spec", "p", "state", "cs", "sts", "j", "S", "als", "js", "ss", "a", "ats", "b", "ns", "ts", "ps", "stats", "qs", "south", "es", "its", "gs", "serv", "less", "sp", "ys", "source", "self", "h", "ls", "q", "t", "m", "v", "sq", "ess", "conf"], "offset": ["f", "block", "padding", "range", "attribute", "length", "field", "peer", "o", "OFF", "ref", "address", "len", "bound", "pad", "entry", "result", "output", "zero", "error", "buffer", "balance", "row", "metadata", "p", "esi", "pointer", "ut", "set", "to", "et", "origin", "pos", "ta", "tile", "layout", "response", "data", "location", "shift", "size", "port", "start", "attr", "window", "seek", "position", "limit", "sp", "style", "offer", "slot", "off", "timeout", "trace", "t", "fp", "usage", "index", "point", "Offset"]}}
{"project": "qemu", "commit_id": "c5b9729ae918b890905e00870ffc08c9b56e6d17", "target": 0, "func": "void helper_4xx_tlbwe_hi (target_ulong entry, target_ulong val)\n\n{\n\n    ppcemb_tlb_t *tlb;\n\n    target_ulong page, end;\n\n\n\n    LOG_SWTLB(\"%s entry %d val \" TARGET_FMT_lx \"\\n\", __func__, (int)entry,\n\n              val);\n\n    entry &= 0x3F;\n\n    tlb = &env->tlb[entry].tlbe;\n\n    /* Invalidate previous TLB (if it's valid) */\n\n    if (tlb->prot & PAGE_VALID) {\n\n        end = tlb->EPN + tlb->size;\n\n        LOG_SWTLB(\"%s: invalidate old TLB %d start \" TARGET_FMT_lx \" end \"\n\n                  TARGET_FMT_lx \"\\n\", __func__, (int)entry, tlb->EPN, end);\n\n        for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE)\n\n            tlb_flush_page(env, page);\n\n    }\n\n    tlb->size = booke_tlb_to_page_size((val >> 7) & 0x7);\n\n    /* We cannot handle TLB size < TARGET_PAGE_SIZE.\n\n     * If this ever occurs, one should use the ppcemb target instead\n\n     * of the ppc or ppc64 one\n\n     */\n\n    if ((val & 0x40) && tlb->size < TARGET_PAGE_SIZE) {\n\n        cpu_abort(env, \"TLB size \" TARGET_FMT_lu \" < %u \"\n\n                  \"are not supported (%d)\\n\",\n\n                  tlb->size, TARGET_PAGE_SIZE, (int)((val >> 7) & 0x7));\n\n    }\n\n    tlb->EPN = val & ~(tlb->size - 1);\n\n    if (val & 0x40)\n\n        tlb->prot |= PAGE_VALID;\n\n    else\n\n        tlb->prot &= ~PAGE_VALID;\n\n    if (val & 0x20) {\n\n        /* XXX: TO BE FIXED */\n\n        cpu_abort(env, \"Little-endian TLB entries are not supported by now\\n\");\n\n    }\n\n    tlb->PID = env->spr[SPR_40x_PID]; /* PID */\n\n    LOG_SWTLB(\"%s: set up TLB %d RPN \" TARGET_FMT_plx \" EPN \" TARGET_FMT_lx\n\n              \" size \" TARGET_FMT_lx \" prot %c%c%c%c PID %d\\n\", __func__,\n\n              (int)entry, tlb->RPN, tlb->EPN, tlb->size,\n\n              tlb->prot & PAGE_READ ? 'r' : '-',\n\n              tlb->prot & PAGE_WRITE ? 'w' : '-',\n\n              tlb->prot & PAGE_EXEC ? 'x' : '-',\n\n              tlb->prot & PAGE_VALID ? 'v' : '-', (int)tlb->PID);\n\n    /* Invalidate new TLB (if valid) */\n\n    if (tlb->prot & PAGE_VALID) {\n\n        end = tlb->EPN + tlb->size;\n\n        LOG_SWTLB(\"%s: invalidate TLB %d start \" TARGET_FMT_lx \" end \"\n\n                  TARGET_FMT_lx \"\\n\", __func__, (int)entry, tlb->EPN, end);\n\n        for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE)\n\n            tlb_flush_page(env, page);\n\n    }\n\n}\n", "idx": 27007, "substitutes": {"entry": ["Entry", "it", "inter", "ident", "x", "cur", "field", "match", "lo", "byte", "ref", "search", "item", "ries", "se", "address", "try", "cell", "ie", "ent", "def", "value", "insert", "id", "ENT", "zero", "ry", "event", "escape", "or", "path", "row", "comment", "pixel", "p", "existent", "record", "pointer", "deep", "instance", "print", "line", "element", "start", "nt", "query", "key", "RY", "window", "link", "ient", "e", "import", "ptr", "table", "q", "index", "point", "enter"], "val": ["range", "status", "valid", "crit", "mem", "dev", "var", "p", "rec", "vol", "ctx", "pl", "ptr", "v", "role", "pt", "pol", "inter", "tx", "byte", "ev", "item", "try", "value", "pr", "db", "el", "state", "msg", "buf", "bal", "fail", "data", "Val", "ind", "key", "eval", "slot", "vt", "x", "lo", "col", "update", "def", "ry", "sel", "doc", "test", "serv", "elt", "it", "prop", "err", "al", "ref", "event", "reg", "local", "cho", "row", "mail", "resp", "line", "VAL", "vals", "ival", "num", "check", "ret", "index", "res"], "tlb": ["tslp", "itlb", "Tlp", "wtlab", "llab", "atlbs", "tylab", " tlr", "atlp", "antbh", "itlp", "antben", "otlad", "attbh", "antkb", "tylb", "timelb", "Tlbs", "ktlb", "tomb", "fbl", "ylbs", "tmerb", "aretlab", "otlab", "llp", "attlbs", "tszb", "netlb", "otlb", "tslb", "ptbl", "aretsb", "latlp", "wtlp", " tlab", "attlp", "otbl", "plp", " tsb", "tbl", "tlam", "otlr", "tterb", "nlr", " tlp", "latlr", "tlad", "ntlb", "temlb", "antlr", " tblog", "ktlbs", "tlab", "netlad", "ptlbs", "tmlb", " tzb", "temerb", "stlp", "temlp", "terlb", "tmbl", "antlb", "latlab", "tslbs", "antzb", "Tlam", "antlam", "ptlr", "tbh", "terblog", "wtlbs", "atbl", " tlad", "tlamm", "ptlb", "netlab", "tkb", "stlb", "terlab", " tdl", "tsomb", "atlamm", "ttben", "Tlb", "nlp", "pbl", "netlbs", "latlbs", "timelamm", " terb", "tsb", " tomb", "terlbs", "tlp", "tylbs", "ktzb", " tkb", "wtlb", "ttlam", " tlam", "terb", "ttbl", "fsb", "llbs", "ntlbs", "stbl", "tyblog", "flb", "aretlp", "ylb", "itlbs", "temlbs", "atlb", "nlb", "itlab", "attlad", "antlab", " tlbs", "plbs", "latlb", "tlbs", "tlr", "llb", "tzb", "ttlab", "tslr", "aretlb", "ttlbs", "ktomb", "timelp", "Tlad", "otlp", "timelbs", "tblog", "wtbl", "ttkb", "ylab", "tben", "antlbs", "ttlp", "Tben", "plb", "ntlp", "Tlab", "attzb", "atlab", " tlamm", "lbl", "tdl", "ptlp", "ttlb", "ylp", "flp", "wtdl", "ntbl", " tbl", "stlbs", "Tlr", "tmlbs", "otlbs", " tbh", "ylad", "flab", "latdl", "attlb"], "page": ["out", "server", "site", "see", "ref", "address", "item", "code", "pc", "update", "pp", "c", "index", "result", "request", "ew", "ice", "row", "PA", "pages", "me", "g", " PAGE", "list", "p", "count", "Page", "rec", "phrase", "pg", "pid", "pointer", "record", "counter", "node", "go", "j", "order", "pe", "message", "pl", "next", " Page", "line", "start", "size", "port", "ip", "post", "key", "window", "link", "step", "url", "fe", "sp", "e", "net", "number", "ptr", "table", "max", "age", "m", "point", "pt"], "end": ["ep", "until", "length", "END", "rest", "append", "nd", "len", "conn", "begin", "ent", "pend", "id", "wall", "fin", "End", "send", "p", "close", "add", "dest", "order", "ended", "hend", "next", "last", "stop", "ending", "size", "start", "port", "wind", "st", "num", "limit", "e", "win", "en", " End", "est", "ue", "offset", "max", "h", "eng", "index", "ender"]}}
{"project": "qemu", "commit_id": "fd563564222f308e1d86847efdec8555fb472536", "target": 1, "func": "static void kvm_update_msi_routes_all(void *private, bool global,\n\n                                      uint32_t index, uint32_t mask)\n\n{\n\n    int cnt = 0;\n\n    MSIRouteEntry *entry;\n\n    MSIMessage msg;\n\n    /* TODO: explicit route update */\n\n    QLIST_FOREACH(entry, &msi_route_list, list) {\n\n        cnt++;\n\n        msg = pci_get_msi_message(entry->dev, entry->vector);\n\n        kvm_irqchip_update_msi_route(kvm_state, entry->virq,\n\n                                     msg, entry->dev);\n\n    }\n\n    kvm_irqchip_commit_routes(kvm_state);\n\n    trace_kvm_x86_update_msi_routes(cnt);\n\n}\n", "idx": 27021, "substitutes": {"private": ["priv", "secret", "sys", " priv", " self", "protected", "Private", " shared", "local", "password", "pid", "slave", " unused", " data", " pub", "inner", "primary", "public", "base", "uri", "tmp", "shared"], "global": [" shadow", "parent", " Global", " glob", " scope", " g", " binary", " shared", " final", " unique", "local", " result", " last", " group", " atomic", " size", " transient", " fatal", " local", " tf", " generic", " module", " globally", " gl", "Global", "final", " remote", " foreign"], "index": ["block", "batch", "match", "address", "hash", "id", "row", "filter", "order", "Index", "level", "pos", "oid", "scan", "ind", "info", "port", "page", "weight", "key", "window", "base", "position", "version", "num", "flag", "lock"], "mask": ["block", "pack", "match", "field", "address", "hash", "bit", "config", "map", "flags", "target", "mode", "filter", "prefix", "set", "bits", "module", "tag", "shape", "scan", "weight", "key", "flag", "domain", "offset", "ask", "lock", "Mask"], "entry": ["Entry", "inter", "job", "attribute", "match", "see", "search", "address", "item", "se", "term", "try", "component", "ie", "cell", "ent", "def", "word", "ry", "escape", "common", "error", "command", "member", "event", "row", "comment", "cmd", "list", "delete", "alias", "existent", "record", "add", "this", "low", "set", "view", "input", "pair", "instance", "connection", "image", "inner", "line", "element", "nt", "info", "query", "key", "RY", "interface", "link", "e", "check", "import", "q", "parse"], "msg": ["ms", "out", "err", "obj", "pub", "mb", "comm", "mp", "body", " message", "mem", "og", "mg", "mk", "gz", "g", "md", "cmd", "list", "send", "ge", "mail", "sent", "gr", "med", "resp", "cm", "rem", "mess", "j", "gp", " MSG", "go", "sim", "message", "doc", "cfg", "gm", "data", "nt", "reason", "txt", "mn", "gs", "Msg", "mt", "sg", "pkg", " m", "tmp", "m", "str"], "cnt": ["countOUNT", "ctount", "cpt", "ccount", "uccount", "countnt", " cct", "countcount", " cNT", "uncnt", "cuct", "cund", " count", " cnd", "CNT", "ucNT", "count", "cnd", "ctnt", " cnc", "COUNT", "countNT", "Cpt", "ucnt", "uncNT", "Cnc", "Count", "Cnt", " cpt", "cnc", "ctpt", "uncct", "cNT", "cOUNT", "ucOUNT", "Ccount", "cunt", "ctnc", "uncnd", "cuNT", "cct"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_601_ubatu (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 27045, "substitutes": {"opaque": ["spaques", "Opaques", "spaque", "spque", "appaque", "opque", "opacity", "popaque", "Opaque", "ipatile", "opaques", "popacity", "popque", "opatile", "appatile", "ipque", "popatile", "ipaque", "ipacity", "ipaques", "spatile", "Opatile", "appque", "appacity", "Opque"], "sprn": ["prnm", " sprnr", "prnc", "srnn", " scrne", "shrnc", "sprN", "sprne", "sprnc", "polnc", "srne", " scrnr", " sprne", "polnm", "srnr", "shrn", "shrN", "prN", "poln", "prn", "sprnn", "polN", "srn", " scrnn", "sprnm", " sprnn", "sprnr", " scrn", "shrnm"], "ctx": ["fx", "iat", " cx", "context", "cur", "batch", "tx", "cf", "obj", "jac", "ca", "gas", "care", "conn", "bc", " temporarily", "tk", "c", "aos", "ctrl", "sc", "nc", "gr", "cb", "j", "voc", "qa", "co", "req", "ct", "xc", " context", "urg", "ind", "ij", "ac", "unc", " gorilla", "loc", "alloc", "kw", "gc", "pkg", "ptr", "tmp", "jp", "cc", "proc", "cv"]}}
{"project": "qemu", "commit_id": "e774a278d82c9391c9fb6c9af42cd08bb9364b9f", "target": 0, "func": "static void ide_sector_write(IDEState *s)\n\n{\n\n    int64_t sector_num;\n\n    int ret, n, n1;\n\n\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    sector_num = ide_get_sector(s);\n\n#if defined(DEBUG_IDE)\n\n    printf(\"write sector=%Ld\\n\", sector_num);\n\n#endif\n\n    n = s->nsector;\n\n    if (n > s->req_nb_sectors)\n\n        n = s->req_nb_sectors;\n\n    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);\n\n    s->nsector -= n;\n\n    if (s->nsector == 0) {\n\n        /* no more sector to write */\n\n        ide_transfer_stop(s);\n\n    } else {\n\n        n1 = s->nsector;\n\n        if (n1 > s->req_nb_sectors)\n\n            n1 = s->req_nb_sectors;\n\n        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);\n\n    }\n\n    ide_set_sector(s, sector_num + n);\n\n    \n\n#ifdef TARGET_I386\n\n    if (win2k_install_hack) {\n\n        /* It seems there is a bug in the Windows 2000 installer HDD\n\n           IDE driver which fills the disk with empty logs when the\n\n           IDE write IRQ comes too early. This hack tries to correct\n\n           that at the expense of slower write performances. Use this\n\n           option _only_ to install Windows 2000. You must disable it\n\n           for normal use. */\n\n        qemu_mod_timer(s->sector_write_timer, \n\n                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));\n\n    } else \n\n#endif\n\n    {\n\n        ide_set_irq(s);\n\n    }\n\n}\n", "idx": 27046, "substitutes": {"s": ["sis", "comm", "sports", "d", "c", "er", "r", "p", "changes", "asm", "aws", "sie", "vs", "S", "ns", "save", "sm", "y", "states", "ies", "less", "http", "h", "sq", "sd", "i", "sb", "store", "os", "rs", "sl", "spec", "cs", "services", "als", "so", "ats", "ts", "ims", "its", "m", "summary", "sys", "ms", "as", "ins", "ses", "results", "bis", "sts", "sw", "bs", "is", "b", "l", "ps", "stats", "st", "gs", "serv", "ls", "ssl", "se", "fs", "w", "ds", "hs", "details", "g", "sets", "set", "js", "ss", "qs", "es", "sv", "sg", "source", "self", "t", "conf"], "sector_num": ["sector_nm", "ector_num", "sector__num", "section_num", "sector1number", "sector_Num", "sector_mon", "sector_n", " sector_nom", "sector_den", "ser_den", "section_number", "ector_mon", "sector___num", " sector_n", "ector2Num", "sector__n", "sector1num", "sector_nom", "ector2mon", "sector_nam", "sector2number", "sector__mon", " sector_Num", "ser_num", "ser_number", " sector_mon", " sector_nm", "sector__nm", "ector_number", "sector2n", "sector_number", "section_n", "sector___number", " sector_nam", "sector2Num", "ector_Num", "ector2number", "section_mon", "ector2num", "sector2mon", "sector___den", "sector2num", "sector1den"], "ret": ["f", "sys", "it", "alt", "lit", "out", "ter", "ll", "RET", "re", "len", "status", "try", "att", "gt", "result", "cont", "get", "ext", "r", "usr", "set", "nil", "rt", "l", "ts", "nt", "nat", "rets", " RET", "ft", " Ret", "net", "mt", "Ret", "tr", "elt", "t", "v", "res"], "n": ["note", "sn", "it", "names", "i", "na", "out", "on", "nn", "nm", "nd", "len", "nb", "nan", "d", "ln", "w", "none", "v", "c", "nr", "k", "nl", "ren", "ng", "g", "fn", "p", "nc", "cn", "new", "j", "nw", "nu", "np", " N", "ne", "b", "l", "ns", "nat", "nt", "y", "nor", "mn", "z", "dn", "N", "num", "gn", "net", "en", "number", "u", "un", "t", "rn", "m", "no"], "n1": ["sn9", " nOne", "n9", "gn1", "sn1", "snONE", " nPart", "n01", "gnary", "nary", "gnPart", "ne9", "nOne", "ne0", " n9", "nn01", "nONE", "nn2", "n2", "nan61", " n2", "gnONE", " N01", "nn61", " n0", "en61", " n61", "sn0", "snOne", "nn1", "gnpart", " nary", "snons", "nan1", "en1", "gnons", " nons", "snary", "nanONE", " N1", " N2", "gn0", "neOne", "sn61", " n01", " N61", "n61", "nPart", "gn61", "en0", "nanpart", "ne1", "n0", "snpart", "npart", "nons", "enPart"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "AioContext *iohandler_get_aio_context(void)\n\n{\n\n    iohandler_init();\n\n    return iohandler_ctx;\n\n}\n", "idx": 27048, "substitutes": {}}
{"project": "qemu", "commit_id": "6049f4f831c6f409031dfa09282b38d0cbaecad8", "target": 0, "func": "abi_long do_syscall(void *cpu_env, int num, abi_long arg1,\n\n                    abi_long arg2, abi_long arg3, abi_long arg4,\n\n                    abi_long arg5, abi_long arg6)\n\n{\n\n    abi_long ret;\n\n    struct stat st;\n\n    struct statfs stfs;\n\n    void *p;\n\n\n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\", num);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall(num, arg1, arg2, arg3, arg4, arg5, arg6);\n\n\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n#ifdef CONFIG_USE_NPTL\n\n      /* In old applications this may be used to implement _exit(2).\n\n         However in threaded applictions it is used for thread termination,\n\n         and _exit_group is used for application termination.\n\n         Do thread termination if we have more then one thread.  */\n\n      /* FIXME: This probably breaks if a signal arrives.  We should probably\n\n         be disabling signals.  */\n\n      if (first_cpu->next_cpu) {\n\n          TaskState *ts;\n\n          CPUState **lastp;\n\n          CPUState *p;\n\n\n\n          cpu_list_lock();\n\n          lastp = &first_cpu;\n\n          p = first_cpu;\n\n          while (p && p != (CPUState *)cpu_env) {\n\n              lastp = &p->next_cpu;\n\n              p = p->next_cpu;\n\n          }\n\n          /* If we didn't find the CPU for this thread then something is\n\n             horribly wrong.  */\n\n          if (!p)\n\n              abort();\n\n          /* Remove the CPU from the list.  */\n\n          *lastp = p->next_cpu;\n\n          cpu_list_unlock();\n\n          ts = ((CPUState *)cpu_env)->opaque;\n\n          if (ts->child_tidptr) {\n\n              put_user_u32(0, ts->child_tidptr);\n\n              sys_futex(g2h(ts->child_tidptr), FUTEX_WAKE, INT_MAX,\n\n                        NULL, NULL, 0);\n\n          }\n\n          /* TODO: Free CPU state.  */\n\n          pthread_exit(NULL);\n\n      }\n\n#endif\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        if (arg3 == 0)\n\n            ret = 0;\n\n        else {\n\n            if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n                goto efault;\n\n            ret = get_errno(read(arg1, p, arg3));\n\n            unlock_user(p, arg2, ret);\n\n        }\n\n        break;\n\n    case TARGET_NR_write:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(write(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n    case TARGET_NR_open:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(open(path(p),\n\n                             target_to_host_bitmask(arg2, fcntl_flags_tbl),\n\n                             arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_openat) && defined(__NR_openat)\n\n    case TARGET_NR_openat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_openat(arg1,\n\n                                   path(p),\n\n                                   target_to_host_bitmask(arg3, fcntl_flags_tbl),\n\n                                   arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk(arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(do_fork(cpu_env, SIGCHLD, 0, 0, 0, 0));\n\n        break;\n\n#ifdef TARGET_NR_waitpid\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int status;\n\n            ret = get_errno(waitpid(arg1, &status, arg3));\n\n            if (!is_error(ret) && arg2\n\n                && put_user_s32(host_to_target_waitstatus(status), arg2))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_waitid\n\n    case TARGET_NR_waitid:\n\n        {\n\n            siginfo_t info;\n\n            info.si_pid = 0;\n\n            ret = get_errno(waitid(arg1, arg2, &info, arg4));\n\n            if (!is_error(ret) && arg3 && info.si_pid != 0) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &info);\n\n                unlock_user(p, arg3, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_creat /* not on alpha */\n\n    case TARGET_NR_creat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(creat(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_link:\n\n        {\n\n            void * p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(link(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_linkat) && defined(__NR_linkat)\n\n    case TARGET_NR_linkat:\n\n        {\n\n            void * p2 = NULL;\n\n            if (!arg2 || !arg4)\n\n                goto efault;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_linkat(arg1, p, arg3, p2, arg5));\n\n            unlock_user(p, arg2, 0);\n\n            unlock_user(p2, arg4, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_unlink:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(unlink(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_unlinkat) && defined(__NR_unlinkat)\n\n    case TARGET_NR_unlinkat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_unlinkat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_execve:\n\n        {\n\n            char **argp, **envp;\n\n            int argc, envc;\n\n            abi_ulong gp;\n\n            abi_ulong guest_argp;\n\n            abi_ulong guest_envp;\n\n            abi_ulong addr;\n\n            char **q;\n\n\n\n            argc = 0;\n\n            guest_argp = arg2;\n\n            for (gp = guest_argp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                argc++;\n\n            }\n\n            envc = 0;\n\n            guest_envp = arg3;\n\n            for (gp = guest_envp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                envc++;\n\n            }\n\n\n\n            argp = alloca((argc + 1) * sizeof(void *));\n\n            envp = alloca((envc + 1) * sizeof(void *));\n\n\n\n            for (gp = guest_argp, q = argp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n            }\n\n            *q = NULL;\n\n\n\n            for (gp = guest_envp, q = envp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n            }\n\n            *q = NULL;\n\n\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto execve_efault;\n\n            ret = get_errno(execve(p, argp, envp));\n\n            unlock_user(p, arg1, 0);\n\n\n\n            goto execve_end;\n\n\n\n        execve_efault:\n\n            ret = -TARGET_EFAULT;\n\n\n\n        execve_end:\n\n            for (gp = guest_argp, q = argp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n            for (gp = guest_envp, q = envp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_time\n\n    case TARGET_NR_time:\n\n        {\n\n            time_t host_time;\n\n            ret = get_errno(time(&host_time));\n\n            if (!is_error(ret)\n\n                && arg1\n\n                && put_user_sal(host_time, arg1))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mknod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mknod(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mknodat) && defined(__NR_mknodat)\n\n    case TARGET_NR_mknodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_mknodat(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_chmod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chmod(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_break\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldstat\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_getxpid\n\n    case TARGET_NR_getxpid:\n\n#else\n\n    case TARGET_NR_getpid:\n\n#endif\n\n        ret = get_errno(getpid());\n\n        break;\n\n    case TARGET_NR_mount:\n\n\t\t{\n\n\t\t\t/* need to look at the data field */\n\n\t\t\tvoid *p2, *p3;\n\n\t\t\tp = lock_user_string(arg1);\n\n\t\t\tp2 = lock_user_string(arg2);\n\n\t\t\tp3 = lock_user_string(arg3);\n\n                        if (!p || !p2 || !p3)\n\n                            ret = -TARGET_EFAULT;\n\n                        else {\n\n                            /* FIXME - arg5 should be locked, but it isn't clear how to\n\n                             * do that since it's not guaranteed to be a NULL-terminated\n\n                             * string.\n\n                             */\n\n                            if ( ! arg5 )\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, NULL));\n\n                            else\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, g2h(arg5)));\n\n                        }\n\n                        unlock_user(p, arg1, 0);\n\n                        unlock_user(p2, arg2, 0);\n\n                        unlock_user(p3, arg3, 0);\n\n\t\t\tbreak;\n\n\t\t}\n\n#ifdef TARGET_NR_umount\n\n    case TARGET_NR_umount:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stime /* not on alpha */\n\n    case TARGET_NR_stime:\n\n        {\n\n            time_t host_time;\n\n            if (get_user_sal(host_time, arg1))\n\n                goto efault;\n\n            ret = get_errno(stime(&host_time));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_alarm /* not on alpha */\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldfstat\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_pause /* not on alpha */\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_utime\n\n    case TARGET_NR_utime:\n\n        {\n\n            struct utimbuf tbuf, *host_tbuf;\n\n            struct target_utimbuf *target_tbuf;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, target_tbuf, arg2, 1))\n\n                    goto efault;\n\n                tbuf.actime = tswapl(target_tbuf->actime);\n\n                tbuf.modtime = tswapl(target_tbuf->modtime);\n\n                unlock_user_struct(target_tbuf, arg2, 0);\n\n                host_tbuf = &tbuf;\n\n            } else {\n\n                host_tbuf = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utime(p, host_tbuf));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_utimes:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg2) {\n\n                if (copy_from_user_timeval(&tv[0], arg2)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utimes(p, tvp));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_futimesat) && defined(__NR_futimesat)\n\n    case TARGET_NR_futimesat:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg3) {\n\n                if (copy_from_user_timeval(&tv[0], arg3)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg3 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg2)))\n\n                goto efault;\n\n            ret = get_errno(sys_futimesat(arg1, path(p), tvp));\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stty\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_gtty\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_access:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(access(path(p), arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_faccessat) && defined(__NR_faccessat)\n\n    case TARGET_NR_faccessat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_faccessat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_nice /* not on alpha */\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ftime\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sync:\n\n        sync();\n\n        ret = 0;\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, target_to_host_signal(arg2)));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(rename(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_renameat) && defined(__NR_renameat)\n\n    case TARGET_NR_renameat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_renameat(arg1, p, arg3, p2));\n\n            unlock_user(p2, arg4, 0);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mkdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mkdir(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mkdirat) && defined(__NR_mkdirat)\n\n    case TARGET_NR_mkdirat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_mkdirat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rmdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(rmdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        ret = do_pipe(cpu_env, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_pipe2\n\n    case TARGET_NR_pipe2:\n\n        ret = do_pipe(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n    case TARGET_NR_times:\n\n        {\n\n            struct target_tms *tmsp;\n\n            struct tms tms;\n\n            ret = get_errno(times(&tms));\n\n            if (arg1) {\n\n                tmsp = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_tms), 0);\n\n                if (!tmsp)\n\n                    goto efault;\n\n                tmsp->tms_utime = tswapl(host_to_target_clock_t(tms.tms_utime));\n\n                tmsp->tms_stime = tswapl(host_to_target_clock_t(tms.tms_stime));\n\n                tmsp->tms_cutime = tswapl(host_to_target_clock_t(tms.tms_cutime));\n\n                tmsp->tms_cstime = tswapl(host_to_target_clock_t(tms.tms_cstime));\n\n            }\n\n            if (!is_error(ret))\n\n                ret = host_to_target_clock_t(ret);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_prof\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_signal\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_acct:\n\n        if (arg1 == 0) {\n\n            ret = get_errno(acct(NULL));\n\n        } else {\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(acct(path(p)));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_umount2 /* not on alpha */\n\n    case TARGET_NR_umount2:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount2(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lock\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        ret = do_fcntl(arg1, arg2, arg3);\n\n        break;\n\n#ifdef TARGET_NR_mpx\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n#ifdef TARGET_NR_ulimit\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldolduname\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chroot(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n#if defined(CONFIG_DUP3) && defined(TARGET_NR_dup3)\n\n    case TARGET_NR_dup3:\n\n        ret = get_errno(dup3(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getppid /* not on alpha */\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n#ifdef TARGET_NR_sigaction\n\n    case TARGET_NR_sigaction:\n\n        {\n\n#if !defined(TARGET_MIPS)\n\n            struct target_old_sigaction *old_act;\n\n            struct target_sigaction act, oact, *pact;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n                act._sa_handler = old_act->_sa_handler;\n\n                target_siginitset(&act.sa_mask, old_act->sa_mask);\n\n                act.sa_flags = old_act->sa_flags;\n\n                act.sa_restorer = old_act->sa_restorer;\n\n                unlock_user_struct(old_act, arg2, 0);\n\n                pact = &act;\n\n            } else {\n\n                pact = NULL;\n\n            }\n\n            ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n                old_act->_sa_handler = oact._sa_handler;\n\n                old_act->sa_mask = oact.sa_mask.sig[0];\n\n                old_act->sa_flags = oact.sa_flags;\n\n                old_act->sa_restorer = oact.sa_restorer;\n\n                unlock_user_struct(old_act, arg3, 1);\n\n            }\n\n#else\n\n\t    struct target_sigaction act, oact, *pact, *old_act;\n\n\n\n\t    if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n\t\tact._sa_handler = old_act->_sa_handler;\n\n\t\ttarget_siginitset(&act.sa_mask, old_act->sa_mask.sig[0]);\n\n\t\tact.sa_flags = old_act->sa_flags;\n\n\t\tunlock_user_struct(old_act, arg2, 0);\n\n\t\tpact = &act;\n\n\t    } else {\n\n\t\tpact = NULL;\n\n\t    }\n\n\n\n\t    ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n\n\n\t    if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n\t\told_act->_sa_handler = oact._sa_handler;\n\n\t\told_act->sa_flags = oact.sa_flags;\n\n\t\told_act->sa_mask.sig[0] = oact.sa_mask.sig[0];\n\n\t\told_act->sa_mask.sig[1] = 0;\n\n\t\told_act->sa_mask.sig[2] = 0;\n\n\t\told_act->sa_mask.sig[3] = 0;\n\n\t\tunlock_user_struct(old_act, arg3, 1);\n\n\t    }\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigaction:\n\n        {\n\n            struct target_sigaction *act;\n\n            struct target_sigaction *oact;\n\n\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, act, arg2, 1))\n\n                    goto efault;\n\n            } else\n\n                act = NULL;\n\n            if (arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, oact, arg3, 0)) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto rt_sigaction_fail;\n\n                }\n\n            } else\n\n                oact = NULL;\n\n            ret = get_errno(do_sigaction(arg1, act, oact));\n\n\trt_sigaction_fail:\n\n            if (act)\n\n                unlock_user_struct(act, arg2, 0);\n\n            if (oact)\n\n                unlock_user_struct(oact, arg3, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sgetmask /* not on alpha */\n\n    case TARGET_NR_sgetmask:\n\n        {\n\n            sigset_t cur_set;\n\n            abi_ulong target_set;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            host_to_target_old_sigset(&target_set, &cur_set);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ssetmask /* not on alpha */\n\n    case TARGET_NR_ssetmask:\n\n        {\n\n            sigset_t set, oset, cur_set;\n\n            abi_ulong target_set = arg1;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            target_to_host_old_sigset(&set, &target_set);\n\n            sigorset(&set, &set, &cur_set);\n\n            sigprocmask(SIG_SETMASK, &set, &oset);\n\n            host_to_target_old_sigset(&target_set, &oset);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sigprocmask\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n\n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_old_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(arg1, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n\n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(how, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigpending\n\n    case TARGET_NR_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigsuspend\n\n    case TARGET_NR_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_old_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigtimedwait:\n\n        {\n\n            sigset_t set;\n\n            struct timespec uts, *puts;\n\n            siginfo_t uinfo;\n\n\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            if (arg3) {\n\n                puts = &uts;\n\n                target_to_host_timespec(puts, arg3);\n\n            } else {\n\n                puts = NULL;\n\n            }\n\n            ret = get_errno(sigtimedwait(&set, &uinfo, puts));\n\n            if (!is_error(ret) && arg2) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg2, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &uinfo);\n\n                unlock_user(p, arg2, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n        {\n\n            siginfo_t uinfo;\n\n            if (!(p = lock_user(VERIFY_READ, arg3, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_siginfo(&uinfo, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sys_rt_sigqueueinfo(arg1, arg2, &uinfo));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigreturn\n\n    case TARGET_NR_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_sigreturn(cpu_env);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_rt_sigreturn(cpu_env);\n\n        break;\n\n    case TARGET_NR_sethostname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(sethostname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        {\n\n            /* XXX: convert resource ? */\n\n            int resource = arg1;\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n            if (!lock_user_struct(VERIFY_READ, target_rlim, arg2, 1))\n\n                goto efault;\n\n            rlim.rlim_cur = tswapl(target_rlim->rlim_cur);\n\n            rlim.rlim_max = tswapl(target_rlim->rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 0);\n\n            ret = get_errno(setrlimit(resource, &rlim));\n\n        }\n\n        break;\n\n    case TARGET_NR_getrlimit:\n\n        {\n\n            /* XXX: convert resource ? */\n\n            int resource = arg1;\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n\n\n            ret = get_errno(getrlimit(resource, &rlim));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                    goto efault;\n\n                target_rlim->rlim_cur = tswapl(rlim.rlim_cur);\n\n                target_rlim->rlim_max = tswapl(rlim.rlim_max);\n\n                unlock_user_struct(target_rlim, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getrusage:\n\n        {\n\n            struct rusage rusage;\n\n            ret = get_errno(getrusage(arg1, &rusage));\n\n            if (!is_error(ret)) {\n\n                host_to_target_rusage(arg2, &rusage);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                if (copy_to_user_timeval(arg1, &tv))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct timeval tv;\n\n            if (copy_from_user_timeval(&tv, arg1))\n\n                goto efault;\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_select\n\n    case TARGET_NR_select:\n\n        {\n\n            struct target_sel_arg_struct *sel;\n\n            abi_ulong inp, outp, exp, tvp;\n\n            long nsel;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, sel, arg1, 1))\n\n                goto efault;\n\n            nsel = tswapl(sel->n);\n\n            inp = tswapl(sel->inp);\n\n            outp = tswapl(sel->outp);\n\n            exp = tswapl(sel->exp);\n\n            tvp = tswapl(sel->tvp);\n\n            unlock_user_struct(sel, arg1, 0);\n\n            ret = do_select(nsel, inp, outp, exp, tvp);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_symlink:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(symlink(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_symlinkat) && defined(__NR_symlinkat)\n\n    case TARGET_NR_symlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg3);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_symlinkat(p, arg2, p2));\n\n            unlock_user(p2, arg3, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldlstat\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_readlink:\n\n        {\n\n            void *p2, *temp;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else {\n\n                if (strncmp((const char *)p, \"/proc/self/exe\", 14) == 0) {\n\n                    char real[PATH_MAX];\n\n                    temp = realpath(exec_path,real);\n\n                    ret = (temp==NULL) ? get_errno(-1) : strlen(real) ;\n\n                    snprintf((char *)p2, arg3, \"%s\", real);\n\n                    }\n\n                else\n\n                    ret = get_errno(readlink(path(p), p2, arg3));\n\n            }\n\n            unlock_user(p2, arg2, ret);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_readlinkat) && defined(__NR_readlinkat)\n\n    case TARGET_NR_readlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n\n            if (!p || !p2)\n\n        \tret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_readlinkat(arg1, path(p), p2, arg4));\n\n            unlock_user(p2, arg3, ret);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_uselib\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_swapon\n\n    case TARGET_NR_swapon:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapon(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_reboot:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_readdir\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_mmap\n\n    case TARGET_NR_mmap:\n\n#if (defined(TARGET_I386) && defined(TARGET_ABI32)) || defined(TARGET_ARM) || defined(TARGET_M68K) || defined(TARGET_CRIS) || defined(TARGET_MICROBLAZE)\n\n        {\n\n            abi_ulong *v;\n\n            abi_ulong v1, v2, v3, v4, v5, v6;\n\n            if (!(v = lock_user(VERIFY_READ, arg1, 6 * sizeof(abi_ulong), 1)))\n\n                goto efault;\n\n            v1 = tswapl(v[0]);\n\n            v2 = tswapl(v[1]);\n\n            v3 = tswapl(v[2]);\n\n            v4 = tswapl(v[3]);\n\n            v5 = tswapl(v[4]);\n\n            v6 = tswapl(v[5]);\n\n            unlock_user(v, arg1, 0);\n\n            ret = get_errno(target_mmap(v1, v2, v3,\n\n                                        target_to_host_bitmask(v4, mmap_flags_tbl),\n\n                                        v5, v6));\n\n        }\n\n#else\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mmap2\n\n    case TARGET_NR_mmap2:\n\n#ifndef MMAP_SHIFT\n\n#define MMAP_SHIFT 12\n\n#endif\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6 << MMAP_SHIFT));\n\n        break;\n\n#endif\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(target_munmap(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mprotect:\n\n        ret = get_errno(target_mprotect(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_mremap\n\n    case TARGET_NR_mremap:\n\n        ret = get_errno(target_mremap(arg1, arg2, arg3, arg4, arg5));\n\n        break;\n\n#endif\n\n        /* ??? msync/mlock/munlock are broken for softmmu.  */\n\n#ifdef TARGET_NR_msync\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync(g2h(arg1), arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlock\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlock\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlockall\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlockall\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n#endif\n\n    case TARGET_NR_truncate:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(truncate(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n#if defined(TARGET_NR_fchmodat) && defined(__NR_fchmodat)\n\n    case TARGET_NR_fchmodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_fchmodat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpriority:\n\n        /* libc does special remapping of the return value of\n\n         * sys_getpriority() so it's just easiest to call\n\n         * sys_getpriority() directly rather than through libc. */\n\n        ret = get_errno(sys_getpriority(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_profil\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_statfs:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg2, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            unlock_user_struct(target_stfs, arg2, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs;\n\n#ifdef TARGET_NR_statfs64\n\n    case TARGET_NR_statfs64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs64:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs64 *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg3, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            unlock_user_struct(target_stfs, arg3, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs64:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs64;\n\n#endif\n\n#ifdef TARGET_NR_ioperm\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_socketcall\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, arg2);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_accept\n\n    case TARGET_NR_accept:\n\n        ret = do_accept(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_bind\n\n    case TARGET_NR_bind:\n\n        ret = do_bind(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_connect\n\n    case TARGET_NR_connect:\n\n        ret = do_connect(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getpeername\n\n    case TARGET_NR_getpeername:\n\n        ret = do_getpeername(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockname\n\n    case TARGET_NR_getsockname:\n\n        ret = do_getsockname(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockopt\n\n    case TARGET_NR_getsockopt:\n\n        ret = do_getsockopt(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_listen\n\n    case TARGET_NR_listen:\n\n        ret = get_errno(listen(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recv\n\n    case TARGET_NR_recv:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvfrom\n\n    case TARGET_NR_recvfrom:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvmsg\n\n    case TARGET_NR_recvmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_send\n\n    case TARGET_NR_send:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendmsg\n\n    case TARGET_NR_sendmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendto\n\n    case TARGET_NR_sendto:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shutdown\n\n    case TARGET_NR_shutdown:\n\n        ret = get_errno(shutdown(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socket\n\n    case TARGET_NR_socket:\n\n        ret = do_socket(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socketpair\n\n    case TARGET_NR_socketpair:\n\n        ret = do_socketpair(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setsockopt\n\n    case TARGET_NR_setsockopt:\n\n        ret = do_setsockopt(arg1, arg2, arg3, arg4, (socklen_t) arg5);\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_syslog:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_syslog((int)arg1, p, (int)arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n\n\n    case TARGET_NR_setitimer:\n\n        {\n\n            struct itimerval value, ovalue, *pvalue;\n\n\n\n            if (arg2) {\n\n                pvalue = &value;\n\n                if (copy_from_user_timeval(&pvalue->it_interval, arg2)\n\n                    || copy_from_user_timeval(&pvalue->it_value,\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n            } else {\n\n                pvalue = NULL;\n\n            }\n\n            ret = get_errno(setitimer(arg1, pvalue, &ovalue));\n\n            if (!is_error(ret) && arg3) {\n\n                if (copy_to_user_timeval(arg3,\n\n                                         &ovalue.it_interval)\n\n                    || copy_to_user_timeval(arg3 + sizeof(struct target_timeval),\n\n                                            &ovalue.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getitimer:\n\n        {\n\n            struct itimerval value;\n\n\n\n            ret = get_errno(getitimer(arg1, &value));\n\n            if (!is_error(ret) && arg2) {\n\n                if (copy_to_user_timeval(arg2,\n\n                                         &value.it_interval)\n\n                    || copy_to_user_timeval(arg2 + sizeof(struct target_timeval),\n\n                                            &value.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_stat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st;\n\n\n\n                if (!lock_user_struct(VERIFY_WRITE, target_st, arg2, 0))\n\n                    goto efault;\n\n                memset(target_st, 0, sizeof(*target_st));\n\n                __put_user(st.st_dev, &target_st->st_dev);\n\n                __put_user(st.st_ino, &target_st->st_ino);\n\n                __put_user(st.st_mode, &target_st->st_mode);\n\n                __put_user(st.st_uid, &target_st->st_uid);\n\n                __put_user(st.st_gid, &target_st->st_gid);\n\n                __put_user(st.st_nlink, &target_st->st_nlink);\n\n                __put_user(st.st_rdev, &target_st->st_rdev);\n\n                __put_user(st.st_size, &target_st->st_size);\n\n                __put_user(st.st_blksize, &target_st->st_blksize);\n\n                __put_user(st.st_blocks, &target_st->st_blocks);\n\n                __put_user(st.st_atime, &target_st->target_st_atime);\n\n                __put_user(st.st_mtime, &target_st->target_st_mtime);\n\n                __put_user(st.st_ctime, &target_st->target_st_ctime);\n\n                unlock_user_struct(target_st, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_olduname\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_iopl\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n#ifdef TARGET_NR_idle\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_syscall\n\n    case TARGET_NR_syscall:\n\n    \tret = do_syscall(cpu_env,arg1 & 0xffff,arg2,arg3,arg4,arg5,arg6,0);\n\n    \tbreak;\n\n#endif\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            abi_long status_ptr = arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            abi_ulong target_rusage = arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr) {\n\n                    status = host_to_target_waitstatus(status);\n\n                    if (put_user_s32(status, status_ptr))\n\n                        goto efault;\n\n                }\n\n                if (target_rusage)\n\n                    host_to_target_rusage(target_rusage, &rusage);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_swapoff\n\n    case TARGET_NR_swapoff:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapoff(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_sysinfo:\n\n        {\n\n            struct target_sysinfo *target_value;\n\n            struct sysinfo value;\n\n            ret = get_errno(sysinfo(&value));\n\n            if (!is_error(ret) && arg1)\n\n            {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_value, arg1, 0))\n\n                    goto efault;\n\n                __put_user(value.uptime, &target_value->uptime);\n\n                __put_user(value.loads[0], &target_value->loads[0]);\n\n                __put_user(value.loads[1], &target_value->loads[1]);\n\n                __put_user(value.loads[2], &target_value->loads[2]);\n\n                __put_user(value.totalram, &target_value->totalram);\n\n                __put_user(value.freeram, &target_value->freeram);\n\n                __put_user(value.sharedram, &target_value->sharedram);\n\n                __put_user(value.bufferram, &target_value->bufferram);\n\n                __put_user(value.totalswap, &target_value->totalswap);\n\n                __put_user(value.freeswap, &target_value->freeswap);\n\n                __put_user(value.procs, &target_value->procs);\n\n                __put_user(value.totalhigh, &target_value->totalhigh);\n\n                __put_user(value.freehigh, &target_value->freehigh);\n\n                __put_user(value.mem_unit, &target_value->mem_unit);\n\n                unlock_user_struct(target_value, arg1, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_ipc\n\n    case TARGET_NR_ipc:\n\n\tret = do_ipc(arg1, arg2, arg3, arg4, arg5, arg6);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_semget\n\n    case TARGET_NR_semget:\n\n        ret = get_errno(semget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semop\n\n    case TARGET_NR_semop:\n\n        ret = get_errno(do_semop(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semctl\n\n    case TARGET_NR_semctl:\n\n        ret = do_semctl(arg1, arg2, arg3, (union target_semun)(abi_ulong)arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgctl\n\n    case TARGET_NR_msgctl:\n\n        ret = do_msgctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgget\n\n    case TARGET_NR_msgget:\n\n        ret = get_errno(msgget(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgrcv\n\n    case TARGET_NR_msgrcv:\n\n        ret = do_msgrcv(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgsnd\n\n    case TARGET_NR_msgsnd:\n\n        ret = do_msgsnd(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmget\n\n    case TARGET_NR_shmget:\n\n        ret = get_errno(shmget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmctl\n\n    case TARGET_NR_shmctl:\n\n        ret = do_shmctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmat\n\n    case TARGET_NR_shmat:\n\n        ret = do_shmat(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmdt\n\n    case TARGET_NR_shmdt:\n\n        ret = do_shmdt(arg1);\n\n        break;\n\n#endif\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_clone:\n\n#if defined(TARGET_SH4)\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg5, arg4));\n\n#elif defined(TARGET_CRIS)\n\n        ret = get_errno(do_fork(cpu_env, arg2, arg1, arg3, arg4, arg5));\n\n#else\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg4, arg5));\n\n#endif\n\n        break;\n\n#ifdef __NR_exit_group\n\n        /* new thread calls */\n\n    case TARGET_NR_exit_group:\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        ret = get_errno(exit_group(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR_setdomainname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(setdomainname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        {\n\n            struct new_utsname * buf;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, buf, arg1, 0))\n\n                goto efault;\n\n            ret = get_errno(sys_uname(buf));\n\n            if (!is_error(ret)) {\n\n                /* Overrite the native machine name with whatever is being\n\n                   emulated. */\n\n                strcpy (buf->machine, cpu_to_uname_machine(cpu_env));\n\n                /* Allow the user to override the reported release.  */\n\n                if (qemu_uname_release && *qemu_uname_release)\n\n                  strcpy (buf->release, qemu_uname_release);\n\n            }\n\n            unlock_user_struct(buf, arg1, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = do_modify_ldt(cpu_env, arg1, arg2, arg3);\n\n        break;\n\n#if !defined(TARGET_X86_64)\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86:\n\n        ret = do_vm86(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_create_module\n\n    case TARGET_NR_create_module:\n\n#endif\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n#ifdef TARGET_NR_get_kernel_syms\n\n    case TARGET_NR_get_kernel_syms:\n\n#endif\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n#ifdef TARGET_NR_bdflush /* not on x86_64 */\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_sysfs\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(personality(arg1));\n\n        break;\n\n#ifdef TARGET_NR_afs_syscall\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR__llseek /* Not on alpha */\n\n    case TARGET_NR__llseek:\n\n        {\n\n#if defined (__x86_64__)\n\n            ret = get_errno(lseek(arg1, ((uint64_t )arg2 << 32) | arg3, arg5));\n\n            if (put_user_s64(ret, arg4))\n\n                goto efault;\n\n#else\n\n            int64_t res;\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n            if (put_user_s64(res, arg4))\n\n                goto efault;\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_getdents:\n\n#if TARGET_ABI_BITS == 32 && HOST_LONG_BITS == 64\n\n        {\n\n            struct target_dirent *target_dirp;\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n\t    dirp = malloc(count);\n\n\t    if (!dirp) {\n\n                ret = -TARGET_ENOMEM;\n\n                goto fail;\n\n            }\n\n\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n\t\tstruct target_dirent *tde;\n\n                int len = ret;\n\n                int reclen, treclen;\n\n\t\tint count1, tnamelen;\n\n\n\n\t\tcount1 = 0;\n\n                de = dirp;\n\n                if (!(target_dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                    goto efault;\n\n\t\ttde = target_dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n\t\t    treclen = reclen - (2 * (sizeof(long) - sizeof(abi_long)));\n\n                    tde->d_reclen = tswap16(treclen);\n\n                    tde->d_ino = tswapl(de->d_ino);\n\n                    tde->d_off = tswapl(de->d_off);\n\n\t\t    tnamelen = treclen - (2 * sizeof(abi_long) + 2);\n\n\t\t    if (tnamelen > 256)\n\n                        tnamelen = 256;\n\n                    /* XXX: may not be correct */\n\n                    pstrcpy(tde->d_name, tnamelen, de->d_name);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                    tde = (struct target_dirent *)((char *)tde + treclen);\n\n\t\t    count1 += treclen;\n\n                }\n\n\t\tret = count1;\n\n                unlock_user(target_dirp, arg2, ret);\n\n            }\n\n\t    free(dirp);\n\n        }\n\n#else\n\n        {\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n#endif\n\n        break;\n\n#if defined(TARGET_NR_getdents64) && defined(__NR_getdents64)\n\n    case TARGET_NR_getdents64:\n\n        {\n\n            struct linux_dirent64 *dirp;\n\n            abi_long count = arg3;\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents64(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent64 *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswap64s((uint64_t *)&de->d_ino);\n\n                    tswap64s((uint64_t *)&de->d_off);\n\n                    de = (struct linux_dirent64 *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n        break;\n\n#endif /* TARGET_NR_getdents64 */\n\n#ifdef TARGET_NR__newselect\n\n    case TARGET_NR__newselect:\n\n        ret = do_select(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_poll\n\n    case TARGET_NR_poll:\n\n        {\n\n            struct target_pollfd *target_pfd;\n\n            unsigned int nfds = arg2;\n\n            int timeout = arg3;\n\n            struct pollfd *pfd;\n\n            unsigned int i;\n\n\n\n            target_pfd = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_pollfd) * nfds, 1);\n\n            if (!target_pfd)\n\n                goto efault;\n\n            pfd = alloca(sizeof(struct pollfd) * nfds);\n\n            for(i = 0; i < nfds; i++) {\n\n                pfd[i].fd = tswap32(target_pfd[i].fd);\n\n                pfd[i].events = tswap16(target_pfd[i].events);\n\n            }\n\n            ret = get_errno(poll(pfd, nfds, timeout));\n\n            if (!is_error(ret)) {\n\n                for(i = 0; i < nfds; i++) {\n\n                    target_pfd[i].revents = tswap16(pfd[i].revents);\n\n                }\n\n                ret += nfds * (sizeof(struct target_pollfd)\n\n                               - sizeof(struct pollfd));\n\n            }\n\n            unlock_user(target_pfd, arg1, ret);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_flock:\n\n        /* NOTE: the flock constant seems to be the same for every\n\n           Linux platform */\n\n        ret = get_errno(flock(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_WRITE, vec, arg2, count, 0) < 0)\n\n                goto efault;\n\n            ret = get_errno(readv(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(writev(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n#if defined(TARGET_NR_fdatasync) /* Not on alpha (osf_datasync ?) */\n\n    case TARGET_NR_fdatasync:\n\n        ret = get_errno(fdatasync(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR__sysctl:\n\n        /* We don't implement this, but ENOTDIR is always a safe\n\n           return value. */\n\n        ret = -TARGET_ENOTDIR;\n\n        break;\n\n    case TARGET_NR_sched_setparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg2, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg2, 0);\n\n            ret = get_errno(sched_setparam(arg1, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            ret = get_errno(sched_getparam(arg1, &schp));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_schp, arg2, 0))\n\n                    goto efault;\n\n                target_schp->sched_priority = tswap32(schp.sched_priority);\n\n                unlock_user_struct(target_schp, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_setscheduler:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg3, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg3, 0);\n\n            ret = get_errno(sched_setscheduler(arg1, arg2, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getscheduler:\n\n        ret = get_errno(sched_getscheduler(arg1));\n\n        break;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n        ret = get_errno(sched_get_priority_max(arg1));\n\n        break;\n\n    case TARGET_NR_sched_get_priority_min:\n\n        ret = get_errno(sched_get_priority_min(arg1));\n\n        break;\n\n    case TARGET_NR_sched_rr_get_interval:\n\n        {\n\n            struct timespec ts;\n\n            ret = get_errno(sched_rr_get_interval(arg1, &ts));\n\n            if (!is_error(ret)) {\n\n                host_to_target_timespec(arg2, &ts);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_nanosleep:\n\n        {\n\n            struct timespec req, rem;\n\n            target_to_host_timespec(&req, arg1);\n\n            ret = get_errno(nanosleep(&req, &rem));\n\n            if (is_error(ret) && arg2) {\n\n                host_to_target_timespec(arg2, &rem);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_query_module\n\n    case TARGET_NR_query_module:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_nfsservctl\n\n    case TARGET_NR_nfsservctl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_prctl:\n\n        switch (arg1)\n\n            {\n\n            case PR_GET_PDEATHSIG:\n\n                {\n\n                    int deathsig;\n\n                    ret = get_errno(prctl(arg1, &deathsig, arg3, arg4, arg5));\n\n                    if (!is_error(ret) && arg2\n\n                        && put_user_ual(deathsig, arg2))\n\n                        goto efault;\n\n                }\n\n                break;\n\n            default:\n\n                ret = get_errno(prctl(arg1, arg2, arg3, arg4, arg5));\n\n                break;\n\n            }\n\n        break;\n\n#ifdef TARGET_NR_arch_prctl\n\n    case TARGET_NR_arch_prctl:\n\n#if defined(TARGET_I386) && !defined(TARGET_ABI32)\n\n        ret = do_arch_prctl(cpu_env, arg1, arg2);\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_pread\n\n    case TARGET_NR_pread:\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n            arg4 = arg5;\n\n#endif\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite:\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n            arg4 = arg5;\n\n#endif\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_pread64\n\n    case TARGET_NR_pread64:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite64:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getcwd:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg1, arg2, 0)))\n\n            goto efault;\n\n        ret = get_errno(sys_getcwd1(p, arg2));\n\n        unlock_user(p, arg1, ret);\n\n        break;\n\n    case TARGET_NR_capget:\n\n        goto unimplemented;\n\n    case TARGET_NR_capset:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigaltstack:\n\n#if defined(TARGET_I386) || defined(TARGET_ARM) || defined(TARGET_MIPS) || \\\n\n    defined(TARGET_SPARC) || defined(TARGET_PPC) || defined(TARGET_ALPHA) || \\\n\n    defined(TARGET_M68K)\n\n        ret = do_sigaltstack(arg1, arg2, get_sp_from_cpustate((CPUState *)cpu_env));\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sendfile:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_getpmsg\n\n    case TARGET_NR_getpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_putpmsg\n\n    case TARGET_NR_putpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_vfork\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(do_fork(cpu_env, CLONE_VFORK | CLONE_VM | SIGCHLD,\n\n                        0, 0, 0, 0));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ugetrlimit\n\n    case TARGET_NR_ugetrlimit:\n\n    {\n\n\tstruct rlimit rlim;\n\n\tret = get_errno(getrlimit(arg1, &rlim));\n\n\tif (!is_error(ret)) {\n\n\t    struct target_rlimit *target_rlim;\n\n            if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                goto efault;\n\n\t    target_rlim->rlim_cur = tswapl(rlim.rlim_cur);\n\n\t    target_rlim->rlim_max = tswapl(rlim.rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 1);\n\n\t}\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_truncate64\n\n    case TARGET_NR_truncate64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n\tret = target_truncate64(cpu_env, p, arg2, arg3, arg4);\n\n        unlock_user(p, arg1, 0);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_ftruncate64\n\n    case TARGET_NR_ftruncate64:\n\n\tret = target_ftruncate64(cpu_env, arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_stat64\n\n    case TARGET_NR_stat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lstat64\n\n    case TARGET_NR_lstat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fstat64\n\n    case TARGET_NR_fstat64:\n\n        ret = get_errno(fstat(arg1, &st));\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#if (defined(TARGET_NR_fstatat64) || defined(TARGET_NR_newfstatat)) && \\\n\n        (defined(__NR_fstatat64) || defined(__NR_newfstatat))\n\n#ifdef TARGET_NR_fstatat64\n\n    case TARGET_NR_fstatat64:\n\n#endif\n\n#ifdef TARGET_NR_newfstatat\n\n    case TARGET_NR_newfstatat:\n\n#endif\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n#ifdef __NR_fstatat64\n\n        ret = get_errno(sys_fstatat64(arg1, path(p), &st, arg4));\n\n#else\n\n        ret = get_errno(sys_newfstatat(arg1, path(p), &st, arg4));\n\n#endif\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg3, &st);\n\n        break;\n\n#endif\n\n#ifdef USE_UID16\n\n    case TARGET_NR_lchown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(high2lowuid(getuid()));\n\n        break;\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(high2lowgid(getgid()));\n\n        break;\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(high2lowuid(geteuid()));\n\n        break;\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(high2lowgid(getegid()));\n\n        break;\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(low2highuid(arg1), low2highuid(arg2)));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(low2highgid(arg1), low2highgid(arg2)));\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint16_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 2, 0);\n\n                if (!target_grouplist)\n\n                    goto efault;\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswap16(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 2);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_setgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint16_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 2, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap16(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, low2highuid(arg2), low2highgid(arg3)));\n\n        break;\n\n#if defined(TARGET_NR_fchownat) && defined(__NR_fchownat)\n\n    case TARGET_NR_fchownat:\n\n        if (!(p = lock_user_string(arg2))) \n\n            goto efault;\n\n        ret = get_errno(sys_fchownat(arg1, p, low2highuid(arg3), low2highgid(arg4), arg5));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid\n\n    case TARGET_NR_setresuid:\n\n        ret = get_errno(setresuid(low2highuid(arg1),\n\n                                  low2highuid(arg2),\n\n                                  low2highuid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid\n\n    case TARGET_NR_getresuid:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u16(high2lowuid(ruid), arg1)\n\n                    || put_user_u16(high2lowuid(euid), arg2)\n\n                    || put_user_u16(high2lowuid(suid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_setresgid:\n\n        ret = get_errno(setresgid(low2highgid(arg1),\n\n                                  low2highgid(arg2),\n\n                                  low2highgid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_getresgid:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u16(high2lowgid(rgid), arg1)\n\n                    || put_user_u16(high2lowgid(egid), arg2)\n\n                    || put_user_u16(high2lowgid(sgid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_chown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(low2highuid(arg1)));\n\n        break;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(low2highgid(arg1)));\n\n        break;\n\n    case TARGET_NR_setfsuid:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n    case TARGET_NR_setfsgid:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif /* USE_UID16 */\n\n\n\n#ifdef TARGET_NR_lchown32\n\n    case TARGET_NR_lchown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getuid32\n\n    case TARGET_NR_getuid32:\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_getxuid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxuid:\n\n         {\n\n            uid_t euid;\n\n            euid=geteuid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=euid;\n\n         }\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_getxgid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxgid:\n\n         {\n\n            uid_t egid;\n\n            egid=getegid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=egid;\n\n         }\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_getsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_getsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_GSI_IEEE_FP_CONTROL:\n\n            {\n\n                uint64_t swcr, fpcr = cpu_alpha_load_fpcr (cpu_env);\n\n\n\n                /* Copied from linux ieee_fpcr_to_swcr.  */\n\n                swcr = (fpcr >> 35) & SWCR_STATUS_MASK;\n\n                swcr |= (fpcr >> 36) & SWCR_MAP_DMZ;\n\n                swcr |= (~fpcr >> 48) & (SWCR_TRAP_ENABLE_INV\n\n                                        | SWCR_TRAP_ENABLE_DZE\n\n                                        | SWCR_TRAP_ENABLE_OVF);\n\n                swcr |= (~fpcr >> 57) & (SWCR_TRAP_ENABLE_UNF\n\n                                        | SWCR_TRAP_ENABLE_INE);\n\n                swcr |= (fpcr >> 47) & SWCR_MAP_UMZ;\n\n                swcr |= (~fpcr >> 41) & SWCR_TRAP_ENABLE_DNO;\n\n\n\n                if (put_user_u64 (swcr, arg2))\n\n                        goto efault;\n\n                ret = 0;\n\n            }\n\n            break;\n\n\n\n          /* case GSI_IEEE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel.\n\n             case GSI_UACPROC:\n\n             -- Retrieves current unaligned access state; not much used.\n\n             case GSI_PROC_TYPE:\n\n             -- Retrieves implver information; surely not used.\n\n             case GSI_GET_HWRPB:\n\n             -- Grabs a copy of the HWRPB; surely not used.\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_setsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_setsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_SSI_IEEE_FP_CONTROL:\n\n          case TARGET_SSI_IEEE_RAISE_EXCEPTION:\n\n            {\n\n                uint64_t swcr, fpcr, orig_fpcr;\n\n\n\n                if (get_user_u64 (swcr, arg2))\n\n                    goto efault;\n\n                orig_fpcr = cpu_alpha_load_fpcr (cpu_env);\n\n                fpcr = orig_fpcr & FPCR_DYN_MASK;\n\n\n\n                /* Copied from linux ieee_swcr_to_fpcr.  */\n\n                fpcr |= (swcr & SWCR_STATUS_MASK) << 35;\n\n                fpcr |= (swcr & SWCR_MAP_DMZ) << 36;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_INV\n\n                                  | SWCR_TRAP_ENABLE_DZE\n\n                                  | SWCR_TRAP_ENABLE_OVF)) << 48;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_UNF\n\n                                  | SWCR_TRAP_ENABLE_INE)) << 57;\n\n                fpcr |= (swcr & SWCR_MAP_UMZ ? FPCR_UNDZ | FPCR_UNFD : 0);\n\n                fpcr |= (~swcr & SWCR_TRAP_ENABLE_DNO) << 41;\n\n\n\n                cpu_alpha_store_fpcr (cpu_env, fpcr);\n\n                ret = 0;\n\n\n\n                if (arg1 == TARGET_SSI_IEEE_RAISE_EXCEPTION) {\n\n                    /* Old exceptions are not signaled.  */\n\n                    fpcr &= ~(orig_fpcr & FPCR_STATUS_MASK);\n\n\n\n                    /* If any exceptions set by this call, and are unmasked,\n\n                       send a signal.  */\n\n                    /* ??? FIXME */\n\n                }\n\n            }\n\n            break;\n\n\n\n          /* case SSI_NVPAIRS:\n\n             -- Used with SSIN_UACPROC to enable unaligned accesses.\n\n             case SSI_IEEE_STATE_AT_SIGNAL:\n\n             case SSI_IEEE_IGNORE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_osf_sigprocmask\n\n    /* Alpha specific.  */\n\n    case TARGET_NR_osf_sigprocmask:\n\n        {\n\n            abi_ulong mask;\n\n            int how = arg1;\n\n            sigset_t set, oldset;\n\n\n\n            switch(arg1) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -TARGET_EINVAL;\n\n                goto fail;\n\n            }\n\n            mask = arg2;\n\n            target_to_host_old_sigset(&set, &mask);\n\n            sigprocmask(arg1, &set, &oldset);\n\n            host_to_target_old_sigset(&mask, &oldset);\n\n            ret = mask;\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef TARGET_NR_getgid32\n\n    case TARGET_NR_getgid32:\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_geteuid32\n\n    case TARGET_NR_geteuid32:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getegid32\n\n    case TARGET_NR_getegid32:\n\n        ret = get_errno(getegid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setreuid32\n\n    case TARGET_NR_setreuid32:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setregid32\n\n    case TARGET_NR_setregid32:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getgroups32\n\n    case TARGET_NR_getgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 4, 0);\n\n                if (!target_grouplist) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswap32(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 4);\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgroups32\n\n    case TARGET_NR_setgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 4, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap32(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fchown32\n\n    case TARGET_NR_fchown32:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid32\n\n    case TARGET_NR_setresuid32:\n\n        ret = get_errno(setresuid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid32\n\n    case TARGET_NR_getresuid32:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(ruid, arg1)\n\n                    || put_user_u32(euid, arg2)\n\n                    || put_user_u32(suid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresgid32\n\n    case TARGET_NR_setresgid32:\n\n        ret = get_errno(setresgid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid32\n\n    case TARGET_NR_getresgid32:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(rgid, arg1)\n\n                    || put_user_u32(egid, arg2)\n\n                    || put_user_u32(sgid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_chown32\n\n    case TARGET_NR_chown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setuid32\n\n    case TARGET_NR_setuid32:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgid32\n\n    case TARGET_NR_setgid32:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsuid32\n\n    case TARGET_NR_setfsuid32:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsgid32\n\n    case TARGET_NR_setfsgid32:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_pivot_root:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_mincore\n\n    case TARGET_NR_mincore:\n\n        {\n\n            void *a;\n\n            ret = -TARGET_EFAULT;\n\n            if (!(a = lock_user(VERIFY_READ, arg1,arg2, 0)))\n\n                goto efault;\n\n            if (!(p = lock_user_string(arg3)))\n\n                goto mincore_fail;\n\n            ret = get_errno(mincore(a, arg2, p));\n\n            unlock_user(p, arg3, ret);\n\n            mincore_fail:\n\n            unlock_user(a, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_arm_fadvise64_64\n\n    case TARGET_NR_arm_fadvise64_64:\n\n\t{\n\n\t\t/*\n\n\t\t * arm_fadvise64_64 looks like fadvise64_64 but\n\n\t\t * with different argument order\n\n\t\t */\n\n\t\tabi_long temp;\n\n\t\ttemp = arg3;\n\n\t\targ3 = arg4;\n\n\t\targ4 = temp;\n\n\t}\n\n#endif\n\n#if defined(TARGET_NR_fadvise64_64) || defined(TARGET_NR_arm_fadvise64_64) || defined(TARGET_NR_fadvise64)\n\n#ifdef TARGET_NR_fadvise64_64\n\n    case TARGET_NR_fadvise64_64:\n\n#endif\n\n#ifdef TARGET_NR_fadvise64\n\n    case TARGET_NR_fadvise64:\n\n#endif\n\n#ifdef TARGET_S390X\n\n        switch (arg4) {\n\n        case 4: arg4 = POSIX_FADV_NOREUSE + 1; break; /* make sure it's an invalid value */\n\n        case 5: arg4 = POSIX_FADV_NOREUSE + 2; break; /* ditto */\n\n        case 6: arg4 = POSIX_FADV_DONTNEED; break;\n\n        case 7: arg4 = POSIX_FADV_NOREUSE; break;\n\n        default: break;\n\n        }\n\n#endif\n\n        ret = -posix_fadvise(arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_madvise\n\n    case TARGET_NR_madvise:\n\n        /* A straight passthrough may not be safe because qemu sometimes\n\n           turns private flie-backed mappings into anonymous mappings.\n\n           This will break MADV_DONTNEED.\n\n           This is a hint, so ignoring and returning success is ok.  */\n\n        ret = get_errno(0);\n\n        break;\n\n#endif\n\n#if TARGET_ABI_BITS == 32\n\n    case TARGET_NR_fcntl64:\n\n    {\n\n\tint cmd;\n\n\tstruct flock64 fl;\n\n\tstruct target_flock64 *target_fl;\n\n#ifdef TARGET_ARM\n\n\tstruct target_eabi_flock64 *target_efl;\n\n#endif\n\n\n\n\tcmd = target_to_host_fcntl_cmd(arg2);\n\n\tif (cmd == -TARGET_EINVAL)\n\n\t\treturn cmd;\n\n\n\n        switch(arg2) {\n\n        case TARGET_F_GETLK64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    if (ret == 0) {\n\n#ifdef TARGET_ARM\n\n                if (((CPUARMState *)cpu_env)->eabi) {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_efl, arg3, 0)) \n\n                        goto efault;\n\n                    target_efl->l_type = tswap16(fl.l_type);\n\n                    target_efl->l_whence = tswap16(fl.l_whence);\n\n                    target_efl->l_start = tswap64(fl.l_start);\n\n                    target_efl->l_len = tswap64(fl.l_len);\n\n                    target_efl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_efl, arg3, 1);\n\n                } else\n\n#endif\n\n                {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_fl, arg3, 0)) \n\n                        goto efault;\n\n                    target_fl->l_type = tswap16(fl.l_type);\n\n                    target_fl->l_whence = tswap16(fl.l_whence);\n\n                    target_fl->l_start = tswap64(fl.l_start);\n\n                    target_fl->l_len = tswap64(fl.l_len);\n\n                    target_fl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_fl, arg3, 1);\n\n                }\n\n\t    }\n\n\t    break;\n\n\n\n        case TARGET_F_SETLK64:\n\n        case TARGET_F_SETLKW64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    break;\n\n        default:\n\n            ret = do_fcntl(arg1, arg2, arg3);\n\n            break;\n\n        }\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_cacheflush\n\n    case TARGET_NR_cacheflush:\n\n        /* self-modifying code is handled automatically, so nothing needed */\n\n        ret = 0;\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_security\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_getpagesize\n\n    case TARGET_NR_getpagesize:\n\n        ret = TARGET_PAGE_SIZE;\n\n        break;\n\n#endif\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n#ifdef TARGET_NR_readahead\n\n    case TARGET_NR_readahead:\n\n#if TARGET_ABI_BITS == 32\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n        {\n\n            arg2 = arg3;\n\n            arg3 = arg4;\n\n            arg4 = arg5;\n\n        }\n\n#endif\n\n        ret = get_errno(readahead(arg1, ((off64_t)arg3 << 32) | arg2, arg4));\n\n#else\n\n        ret = get_errno(readahead(arg1, arg2, arg3));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setxattr\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n    case TARGET_NR_fsetxattr:\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n    case TARGET_NR_fgetxattr:\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    case TARGET_NR_flistxattr:\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n    case TARGET_NR_fremovexattr:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_set_thread_area\n\n    case TARGET_NR_set_thread_area:\n\n#if defined(TARGET_MIPS)\n\n      ((CPUMIPSState *) cpu_env)->tls_value = arg1;\n\n      ret = 0;\n\n      break;\n\n#elif defined(TARGET_CRIS)\n\n      if (arg1 & 0xff)\n\n          ret = -TARGET_EINVAL;\n\n      else {\n\n          ((CPUCRISState *) cpu_env)->pregs[PR_PID] = arg1;\n\n          ret = 0;\n\n      }\n\n      break;\n\n#elif defined(TARGET_I386) && defined(TARGET_ABI32)\n\n      ret = do_set_thread_area(cpu_env, arg1);\n\n      break;\n\n#else\n\n      goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_get_thread_area\n\n    case TARGET_NR_get_thread_area:\n\n#if defined(TARGET_I386) && defined(TARGET_ABI32)\n\n        ret = do_get_thread_area(cpu_env, arg1);\n\n#else\n\n        goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_getdomainname\n\n    case TARGET_NR_getdomainname:\n\n        goto unimplemented_nowarn;\n\n#endif\n\n\n\n#ifdef TARGET_NR_clock_gettime\n\n    case TARGET_NR_clock_gettime:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_gettime(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_getres\n\n    case TARGET_NR_clock_getres:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_getres(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_nanosleep\n\n    case TARGET_NR_clock_nanosleep:\n\n    {\n\n        struct timespec ts;\n\n        target_to_host_timespec(&ts, arg3);\n\n        ret = get_errno(clock_nanosleep(arg1, arg2, &ts, arg4 ? &ts : NULL));\n\n        if (arg4)\n\n            host_to_target_timespec(arg4, &ts);\n\n        break;\n\n    }\n\n#endif\n\n\n\n#if defined(TARGET_NR_set_tid_address) && defined(__NR_set_tid_address)\n\n    case TARGET_NR_set_tid_address:\n\n        ret = get_errno(set_tid_address((int *)g2h(arg1)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tkill) && defined(__NR_tkill)\n\n    case TARGET_NR_tkill:\n\n        ret = get_errno(sys_tkill((int)arg1, target_to_host_signal(arg2)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tgkill) && defined(__NR_tgkill)\n\n    case TARGET_NR_tgkill:\n\n\tret = get_errno(sys_tgkill((int)arg1, (int)arg2,\n\n                        target_to_host_signal(arg3)));\n\n\tbreak;\n\n#endif\n\n\n\n#ifdef TARGET_NR_set_robust_list\n\n    case TARGET_NR_set_robust_list:\n\n\tgoto unimplemented_nowarn;\n\n#endif\n\n\n\n#if defined(TARGET_NR_utimensat) && defined(__NR_utimensat)\n\n    case TARGET_NR_utimensat:\n\n        {\n\n            struct timespec *tsp, ts[2];\n\n            if (!arg3) {\n\n                tsp = NULL;\n\n            } else {\n\n                target_to_host_timespec(ts, arg3);\n\n                target_to_host_timespec(ts+1, arg3+sizeof(struct target_timespec));\n\n                tsp = ts;\n\n            }\n\n            if (!arg2)\n\n                ret = get_errno(sys_utimensat(arg1, NULL, tsp, arg4));\n\n            else {\n\n                if (!(p = lock_user_string(arg2))) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                ret = get_errno(sys_utimensat(arg1, path(p), tsp, arg4));\n\n                unlock_user(p, arg2, 0);\n\n            }\n\n        }\n\n\tbreak;\n\n#endif\n\n#if defined(CONFIG_USE_NPTL)\n\n    case TARGET_NR_futex:\n\n        ret = do_futex(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\n    case TARGET_NR_inotify_init:\n\n        ret = get_errno(sys_inotify_init());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_add_watch) && defined(__NR_inotify_add_watch)\n\n    case TARGET_NR_inotify_add_watch:\n\n        p = lock_user_string(arg2);\n\n        ret = get_errno(sys_inotify_add_watch(arg1, path(p), arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_rm_watch) && defined(__NR_inotify_rm_watch)\n\n    case TARGET_NR_inotify_rm_watch:\n\n        ret = get_errno(sys_inotify_rm_watch(arg1, arg2));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_mq_open) && defined(__NR_mq_open)\n\n    case TARGET_NR_mq_open:\n\n        {\n\n            struct mq_attr posix_mq_attr;\n\n\n\n            p = lock_user_string(arg1 - 1);\n\n            if (arg4 != 0)\n\n                copy_from_user_mq_attr (&posix_mq_attr, arg4);\n\n            ret = get_errno(mq_open(p, arg2, arg3, &posix_mq_attr));\n\n            unlock_user (p, arg1, 0);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_unlink:\n\n        p = lock_user_string(arg1 - 1);\n\n        ret = get_errno(mq_unlink(p));\n\n        unlock_user (p, arg1, 0);\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedsend:\n\n        {\n\n            struct timespec ts;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedsend(arg1, p, arg3, arg4, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_send(arg1, p, arg3, arg4));\n\n            unlock_user (p, arg2, arg3);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedreceive:\n\n        {\n\n            struct timespec ts;\n\n            unsigned int prio;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedreceive(arg1, p, arg3, &prio, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_receive(arg1, p, arg3, &prio));\n\n            unlock_user (p, arg2, arg3);\n\n            if (arg4 != 0)\n\n                put_user_u32(prio, arg4);\n\n        }\n\n        break;\n\n\n\n    /* Not implemented for now... */\n\n/*     case TARGET_NR_mq_notify: */\n\n/*         break; */\n\n\n\n    case TARGET_NR_mq_getsetattr:\n\n        {\n\n            struct mq_attr posix_mq_attr_in, posix_mq_attr_out;\n\n            ret = 0;\n\n            if (arg3 != 0) {\n\n                ret = mq_getattr(arg1, &posix_mq_attr_out);\n\n                copy_to_user_mq_attr(arg3, &posix_mq_attr_out);\n\n            }\n\n            if (arg2 != 0) {\n\n                copy_from_user_mq_attr(&posix_mq_attr_in, arg2);\n\n                ret |= mq_setattr(arg1, &posix_mq_attr_in, &posix_mq_attr_out);\n\n            }\n\n\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef CONFIG_SPLICE\n\n#ifdef TARGET_NR_tee\n\n    case TARGET_NR_tee:\n\n        {\n\n            ret = get_errno(tee(arg1,arg2,arg3,arg4));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_splice\n\n    case TARGET_NR_splice:\n\n        {\n\n            loff_t loff_in, loff_out;\n\n            loff_t *ploff_in = NULL, *ploff_out = NULL;\n\n            if(arg2) {\n\n                get_user_u64(loff_in, arg2);\n\n                ploff_in = &loff_in;\n\n            }\n\n            if(arg4) {\n\n                get_user_u64(loff_out, arg2);\n\n                ploff_out = &loff_out;\n\n            }\n\n            ret = get_errno(splice(arg1, ploff_in, arg3, ploff_out, arg5, arg6));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_vmsplice\n\n\tcase TARGET_NR_vmsplice:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(vmsplice(arg1, vec, count, arg4));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n#endif\n\n#endif /* CONFIG_SPLICE */\n\n#ifdef CONFIG_EVENTFD\n\n#if defined(TARGET_NR_eventfd)\n\n    case TARGET_NR_eventfd:\n\n        ret = get_errno(eventfd(arg1, 0));\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_eventfd2)\n\n    case TARGET_NR_eventfd2:\n\n        ret = get_errno(eventfd(arg1, arg2));\n\n        break;\n\n#endif\n\n#endif /* CONFIG_EVENTFD  */\n\n#if defined(CONFIG_FALLOCATE) && defined(TARGET_NR_fallocate)\n\n    case TARGET_NR_fallocate:\n\n        ret = get_errno(fallocate(arg1, arg2, arg3, arg4));\n\n        break;\n\n#endif\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"qemu: Unsupported syscall: %d\\n\", num);\n\n#if defined(TARGET_NR_setxattr) || defined(TARGET_NR_get_thread_area) || defined(TARGET_NR_getdomainname) || defined(TARGET_NR_set_robust_list)\n\n    unimplemented_nowarn:\n\n#endif\n\n        ret = -TARGET_ENOSYS;\n\n        break;\n\n    }\n\nfail:\n\n#ifdef DEBUG\n\n    gemu_log(\" = \" TARGET_ABI_FMT_ld \"\\n\", ret);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall_ret(num, ret);\n\n    return ret;\n\nefault:\n\n    ret = -TARGET_EFAULT;\n\n    goto fail;\n\n}\n", "idx": 27056, "substitutes": {"cpu_env": ["cpueryen", "cpu__environment", "pu_den", "cpu__en", "pu_env", "cpueryenv", "cpu___environment", "cpu___en", "cpu_priv", "pu_conn", "cpu__env", "cpu___era", "cpu_conn", "cpu_den", "cpu__window", "cpu_en", "cpueryconn", "cpu___env", "pu_priv", "cpu_window", "pu_window", "cpueryenvironment", "pu_en", "cpu__den", "cpu__priv", "cpu_environment", "cpu_era", "pu_era", "pu_environment"], "num": ["note", "f", "NUM", "x", "na", "nm", "nom", "nam", "nb", "unit", "valid", "id", "index", "result", "zero", "um", "mon", "Num", "n", "fn", "new", "ctx", "nu", "tim", "np", "th", "mn", "con", "val", "en", "number", "off", "un", "t", "sum", "m", "final", "no", "name", "conf"], "arg1": ["doc1", "arg0", "args4", " arg01", "doc01", "args2", "doc0", "argument3", " arg0", "par1", "argument4", "par2", "param3", "doc3", "param0", "argument1", "param01", "argument2", "argument0", "args1", "param1", "par3", "par0", "args0", "args3", "arg01"], "arg2": ["tag3", "args4", "Arg5", "args2", "argument3", "args02", "args5", "arg02", "argument5", "Arg2", "tag4", "tag1", "argument1", "Arg3", "argument2", " arg02", "tag2", "args1", "tag02", "Arg02", "args3", "tag5"], "arg3": ["Arg4", "date03", "doc1", "args4", "Arg5", "args2", "doc03", "argument3", "argument03", "val2", "arg03", "Arg03", "date5", " arg03", "date3", "val5", "Arg1", "args5", "argument5", "doc3", "Arg2", "doc2", "argument1", "Arg3", "doc5", "date4", "args1", "val3", "val1", "args3", "argument4"], "arg4": ["prop434", "long434", "propfour", "long3", "args4", "argfour", "prop4", "agg6", "args44", "longfour", " arg434", "agg4", " argfour", "arg434", "agg44", "arg44", "args6", " arg44", "prop3", "args3", "long4", "agg3"], "arg5": ["level05", "tag45", " arg25", "ag5", "argument05", "ag05", "ag25", "ag4", "tag55", "level5", "doc05", "argument25", "argument5", "arg25", "arg55", "arg45", "doc5", " arg05", "level45", "doc45", "doc55", "level55", "arg05", "tag5", "argument4", "tag05"], "arg6": ["flag16", "argument16", "arg16", "Arg9", "ig9", "Arg8", "doc8", "arg8", "argument8", " arg8", "flag2", "arg9", "arg7", "argument6", "argument2", " arg16", "ig7", "Arg7", "doc6", "Arg6", "ig6", "ig8", "doc7", "flag6", "flag8", "doc9"], "ret": ["f", "class", "alt", "ter", "out", "red", "err", "pas", "reset", "RET", "ref", "re", "len", "mb", "try", "success", "gt", "def", "xt", "result", "read", "nl", "ry", "mem", "g", "ext", "reply", "r", "arr", "resp", "j", "nz", "print", "rt", "back", "nt", "fun", "z", "ft", " Ret", "val", "flag", "net", "mt", "Ret", "str", "tr", "gc", "jp", "t", "no", "arg", "offset", "Return", "name"], "st": ["stack", "ost", "ld", "rest", "store", "sty", "se", "std", "ste", "St", "sc", "sts", "ut", "sw", "ust", "ss", "ct", "nt", "ST", "ft", "sp", "mt", "est", "ist", "str"], "stfs": ["STfs", " stfc", " stf", "STf", "STps", "STfc", "stackps", "stackf", "stf", "stps", "stfc", "stackfs", "stackfc", " stps"], "p": ["f", "ping", "pd", "pm", "patch", "pre", "perm", "it", "pb", "o", "point", "op", "pc", "mp", "d", "vp", "part", "w", "pp", "c", "pi", "pr", "g", "r", "pers", "cp", "n", "pg", "pid", "par", "pn", "j", "ap", "pe", "rep", "np", "pl", "per", "b", "l", "php", "ps", "port", "page", "post", "pa", "wp", "y", "ip", "pro", "sp", "tp", "pod", "bp", "fp", "pkg", "P", "h", "t", "jp", "lp", "proc", "pat", "m", "pt"], "ts": ["ols", "ms", "TS", "tm", "ops", "tx", "ports", "ots", "pas", "ins", "tl", "rs", "tc", "tips", "tt", "ds", "lt", "tz", "hs", "tn", "ks", "tis", "times", "GS", "cs", "sts", "vs", "als", "ics", "bs", "js", "ss", "ets", "pins", "ats", "wcs", "ns", "ps", "ims", "vals", "tes", "wt", "stats", "qs", "aps", "its", "tp", "gs", "mt", "ys", "tr", "t", "ls", "Ts", "pt"], "lastp": ["nextP", "nextpid", "firstwp", "firstpa", "basec", "Lastm", " lastP", "nextp", "oldwp", "defaultP", "LastP", " lastr", "nextr", "firstc", "lastr", "firstps", " lastm", "basepa", " lastps", "firstpid", "basecp", " lastpa", "oldps", "firstP", "lastpid", "oldP", "lastP", "firstp", "lastpa", "defaultpa", "defaultp", "firstr", "oldp", "lastc", " lastpid", " lastcp", "basep", "lastwp", "Lastp", " lastwp", "lastm", " lastc", "lastps", "firstcp", "lastcp", "defaultm", "Lastpa"]}}
{"project": "qemu", "commit_id": "4058fd98fd7e9c476774717adbd49698dd273166", "target": 0, "func": "cpu_x86_dump_seg_cache(CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n                       const char *name, struct SegmentCache *sc)\n\n{\n\n#ifdef TARGET_X86_64\n\n    if (env->hflags & HF_CS64_MASK) {\n\n        cpu_fprintf(f, \"%-3s=%04x %016\" PRIx64 \" %08x %08x\", name,\n\n                    sc->selector, sc->base, sc->limit, sc->flags);\n\n    } else\n\n#endif\n\n    {\n\n        cpu_fprintf(f, \"%-3s=%04x %08x %08x %08x\", name, sc->selector,\n\n                    (uint32_t)sc->base, sc->limit, sc->flags);\n\n    }\n\n\n\n    if (!(env->hflags & HF_PE_MASK) || !(sc->flags & DESC_P_MASK))\n\n        goto done;\n\n\n\n    cpu_fprintf(f, \" DPL=%d \", (sc->flags & DESC_DPL_MASK) >> DESC_DPL_SHIFT);\n\n    if (sc->flags & DESC_S_MASK) {\n\n        if (sc->flags & DESC_CS_MASK) {\n\n            cpu_fprintf(f, (sc->flags & DESC_L_MASK) ? \"CS64\" :\n\n                           ((sc->flags & DESC_B_MASK) ? \"CS32\" : \"CS16\"));\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_C_MASK) ? 'C' : '-',\n\n                        (sc->flags & DESC_R_MASK) ? 'R' : '-');\n\n        } else {\n\n            cpu_fprintf(f, (sc->flags & DESC_B_MASK) ? \"DS  \" : \"DS16\");\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_E_MASK) ? 'E' : '-',\n\n                        (sc->flags & DESC_W_MASK) ? 'W' : '-');\n\n        }\n\n        cpu_fprintf(f, \"%c]\", (sc->flags & DESC_A_MASK) ? 'A' : '-');\n\n    } else {\n\n        static const char *sys_type_name[2][16] = {\n\n            { /* 32 bit mode */\n\n                \"Reserved\", \"TSS16-avl\", \"LDT\", \"TSS16-busy\",\n\n                \"CallGate16\", \"TaskGate\", \"IntGate16\", \"TrapGate16\",\n\n                \"Reserved\", \"TSS32-avl\", \"Reserved\", \"TSS32-busy\",\n\n                \"CallGate32\", \"Reserved\", \"IntGate32\", \"TrapGate32\"\n\n            },\n\n            { /* 64 bit mode */\n\n                \"<hiword>\", \"Reserved\", \"LDT\", \"Reserved\", \"Reserved\",\n\n                \"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\",\n\n                \"TSS64-avl\", \"Reserved\", \"TSS64-busy\", \"CallGate64\",\n\n                \"Reserved\", \"IntGate64\", \"TrapGate64\"\n\n            }\n\n        };\n\n        cpu_fprintf(f, \"%s\",\n\n                    sys_type_name[(env->hflags & HF_LMA_MASK) ? 1 : 0]\n\n                                 [(sc->flags & DESC_TYPE_MASK)\n\n                                  >> DESC_TYPE_SHIFT]);\n\n    }\n\ndone:\n\n    cpu_fprintf(f, \"\\n\");\n\n}\n", "idx": 27058, "substitutes": {"sys_type_name": ["sys_type2str", "sys_type_code", "sys_name_info", "sys_name2name", "sys_name_name", "sys_type_str", "sys_name_str", "sys_type2name", "sys_type_info", "sys_type2info", "sys_name2code", "sys_name2info", "sys_name_code", "sys_name2str", "sys_type2code"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void FUNCC(ff_h264_idct_add)(uint8_t *_dst, DCTELEM *_block, int stride)\n\n{\n\n    int i;\n\n    INIT_CLIP\n\n    pixel *dst = (pixel*)_dst;\n\n    dctcoef *block = (dctcoef*)_block;\n\n    stride /= sizeof(pixel);\n\n\n\n    block[0] += 1 << 5;\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[i + 4*0]     +  block[i + 4*2];\n\n        const int z1=  block[i + 4*0]     -  block[i + 4*2];\n\n        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];\n\n        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);\n\n\n\n        block[i + 4*0]= z0 + z3;\n\n        block[i + 4*1]= z1 + z2;\n\n        block[i + 4*2]= z1 - z2;\n\n        block[i + 4*3]= z0 - z3;\n\n    }\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];\n\n        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];\n\n        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];\n\n        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);\n\n\n\n        dst[i + 0*stride]= CLIP(dst[i + 0*stride] + ((z0 + z3) >> 6));\n\n        dst[i + 1*stride]= CLIP(dst[i + 1*stride] + ((z1 + z2) >> 6));\n\n        dst[i + 2*stride]= CLIP(dst[i + 2*stride] + ((z1 - z2) >> 6));\n\n        dst[i + 3*stride]= CLIP(dst[i + 3*stride] + ((z0 - z3) >> 6));\n\n    }\n\n}\n", "idx": 27081, "substitutes": {"_dst": ["_DST", "devtsrc", "_doost", "_dsrc", "_Dost", "_dST", " _dost", " _Dost", "devdsrc", "devdpt", "_tst", "_dost", "_ssrc", "_Dsrc", "devtpt", "_dpt", "_dsST", "devdst", " _Dest", " _dest", "_Dist", "_dsest", " _dST", "_spt", "_dist", "_Dst", "devdist", "_dsst", "_doST", "_dest", "_tpt", "_tist", "_dsost", "_doest", "_Dpt", "_sist", "_sst", " _DST", "_Dest", " _Dst", "devtist", "devtst", "_tsrc"], "_block": [" _bl", "__lock", "_box", "_bl", "__type", "__box", "_lock", "__bl", "_type", "__block", " _type", " _box", " _lock"], "stride": [" strine", "styleride", "strerve", "stIDE", "volride", " strride", "volide", "STRope", "priverve", "slome", "Strided", "spade", "styleIDE", "STRerve", "STRine", "strome", " strope", "privine", "volade", "spider", "relIDE", "STRided", "STRider", "STRome", "stice", "volider", " strIDE", "suspride", "Strine", "spide", "slride", "strice", "privide", "strine", "STRIDE", "stider", "STRride", "relide", " strided", "stade", "relice", "STRitud", "relride", "stipe", "STRice", "Strope", "strise", "strride", "styleade", "slipe", "strided", "privride", "STRipe", "stitud", "Stride", "stine", "strope", "STRade", "STRide", "spise", "slerve", "privipe", "voline", "volise", "styleide", "slice", "stome", "stritud", "strider", "stide", "suspitud", "suspine", "strade", " strade", "stise", "strIDE", "slide", "suspide", "stripe"], "i": ["ui", " j", " multi", "status", "ini", "id", "er", "in", "I", "p", " bi", "sim", "ai", " li", "li", "info", "ip", "ij", "y", " mi", "ish", "ci", " si", "iu", " I", "il", "si", "v", "ei", "series", "ji", "ki", "\u0438", "item", "try", " ni", " ii", "io", "j", "ind", "ims", "uri", "m", "point", "qi", "ix", "iii", "batch", "x", "multi", "ami", "ri", "phi", "di", "oi", "ite", "zi", "go", "mi", "ii", "depth", "print", "is", " ti", " pi", "bi", "dr", " index", "version", "ir", " m", "xi", "im", "q", "this", "f", "iri", "it", "ic", "err", "pi", "ia", "fi", "g", "me", "gi", "list", "upper", "iq", "hi", "ti", "port", "e", "u", "index", "cli", "init", "name"], "dst": ["Dstore", "adbsp", "tst", "dpret", "redst", "Dist", "Dst", " dist", "Dpret", "Ddest", "redgest", "Dct", "donepret", " dest", "dstore", "deadstore", "dddest", "Dstart", "debugstart", "sdstore", "dbsp", "ddst", "dstart", "deadst", "debugst", "dbt", "duest", "ddost", "donestart", "Dost", "tdest", "deadbt", "deadstart", " dsts", " dct", "debugpret", "ddstart", "duist", " dgest", "deadpret", "dsts", "ddgest", "redist", "ldst", "sdpret", "sdst", "Dbt", "redsts", "tct", "deadost", "dgest", "test", "debugbsp", " ddest", "dusts", "ddbt", "adpret", "ldist", "donest", "dct", "ldgest", "redest", "adstart", "dost", "Dsts", "donebsp", "dest", "sdost", "dist", "adst", "Dest", "Dgest", "dust", "ddest"], "block": ["other", "field", "bl", "unit", "map", "disk", "word", "mem", "buffer", "sync", "p", "use", "new", "open", "frame", "ip", "loc", "link", "base", "snap", "user", "bus", "pack", "byte", "zone", "condition", "Block", "piece", "config", "blocking", "spec", "pixel", "total", "chain", "data", "lib", "window", "bin", "label", "model", "point", "lock", "method", "cl", "type", "network", "box", "part", "def", "k", "BL", "library", "filter", "view", "rule", "blocks", "file", "version", "mask", "number", "all", "no", "control", "join", "out", "client", "hash", "bit", "bo", "profile", "zero", "event", "wall", "object", "local", "group", "row", "list", "cache", "layer", "record", "set", "module", "image", "line", "load", "check", "loop", "proc", "plugin"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_fp_ccomp(DisasContext *s, uint32_t insn)\n\n{\n\n    unsigned int mos, type, rm, cond, rn, op, nzcv;\n\n    TCGv_i64 tcg_flags;\n\n    int label_continue = -1;\n\n\n\n    mos = extract32(insn, 29, 3);\n\n    type = extract32(insn, 22, 2); /* 0 = single, 1 = double */\n\n    rm = extract32(insn, 16, 5);\n\n    cond = extract32(insn, 12, 4);\n\n    rn = extract32(insn, 5, 5);\n\n    op = extract32(insn, 4, 1);\n\n    nzcv = extract32(insn, 0, 4);\n\n\n\n    if (mos || type > 1) {\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    if (!fp_access_check(s)) {\n\n        return;\n\n    }\n\n\n\n    if (cond < 0x0e) { /* not always */\n\n        int label_match = gen_new_label();\n\n        label_continue = gen_new_label();\n\n        arm_gen_test_cc(cond, label_match);\n\n        /* nomatch: */\n\n        tcg_flags = tcg_const_i64(nzcv << 28);\n\n        gen_set_nzcv(tcg_flags);\n\n        tcg_temp_free_i64(tcg_flags);\n\n        tcg_gen_br(label_continue);\n\n        gen_set_label(label_match);\n\n    }\n\n\n\n    handle_fp_compare(s, type, rn, rm, false, op);\n\n\n\n    if (cond < 0x0e) {\n\n        gen_set_label(label_continue);\n\n    }\n\n}\n", "idx": 27083, "substitutes": {"s": ["sys", "ms", "i", "sb", "ins", "os", "rs", "w", "c", "ses", "ds", "g", "r", "n", "p", "sc", "cs", "sts", "j", "ctx", "S", "js", "ss", "is", "b", "ats", "ns", "ts", "ps", "sm", "es", "its", "gs", "e", "sv", "sg", "self", "h", "t", "m", "v"], "insn": ["yssn", "ysn", "outsgn", "istsn", "stssn", " inssn", " insoln", "rsgn", "timespn", "rsns", "istsns", "alsns", "insnin", "retsnin", "ysne", "rssn", "inson", "rsnin", "pssn", "timesn", "outn", "kinsn", "pinsgn", "insns", "timesne", "istssn", "linssn", "ainspn", "outsn", "stsnin", "inssn", " insns", " pinsn", "outssn", " insgn", "kinssn", "outsns", "pinsns", "stsn", "pson", "yspn", "rsn", "psn", "inspn", "alsgn", "alsn", "istsgn", "ainsoln", "retssn", "ainsn", "outne", " pinssn", "linsgn", "kinson", "pinsn", "retsns", "stsns", "linsn", "ainsns", "pspn", "insne", " pinsoln", "ainson", "stsgn", "ainssn", " pinsns", "kinspn", "outpn", "pinssn", "insoln", "alssn", "timessn", "retsn", "insgn"], "mos": ["sys", "mys", "ms", "osa", "asis", "os", "mus", "phis", "oses", "rs", "los", " mus", "mm", "mx", "mic", "mon", "mph", "las", " Mos", "mas", "mes", "omo", "doi", "mo", "mot", "OS", "mis", "rans", "mi", "bs", "ros", "mr", "mn", "mc", "px", "osi", " nos", "mol", "mt", "tor", "mor", "ls", "mid", "dos", "Mos"], "type": ["ping", "typ", "where", "o", "ror", "col", "like", "_", "change", "ty", "phy", "error", "ype", "tool", "r", "cmd", "spec", "ver", "p", "dt", "day", "state", "pe", "form", "tag", "otype", "co", "file", "ime", " typ", "test", "py", "types", "info", "y", "key", "ox", "Type", "ico", "con", "TYPE", "tp", "time", "kind", "mt", "t", "stat", "m", "name", "role"], "rm": ["raf", "orm", "typ", "nm", "lr", "rl", "ror", "re", "ref", "ru", "nb", "rs", "rc", "reg", "rr", "mem", "bm", "rob", "rx", "arm", "r", "cmd", "ro", "remote", "rom", "irm", "mo", "rem", "RM", "rf", "rt", "mr", "mn", "rb", "mt", "ram", "m", "rpm", "drm", "res"], "cond": ["Cond", "cmp", "bool", "red", "tx", "cf", "CON", "ref", "condition", "code", "col", "then", "bc", "none", "def", "rc", "cd", "cont", "reg", "rob", "fl", "pr", "act", "func", "cmd", "ond", "cp", "n", "p", "close", "res", "resp", "cb", "pred", "bind", "mod", "ctx", "pos", "cod", "cut", "co", "cons", "comp", "test", "ind", "ct", "xc", "fun", "loc", "con", "when", "check", "lock", "cc", "control", "conf"], "rn": ["cmp", "inc", "nm", "lr", "rl", "nn", "norm", "nb", "ln", "nr", "roc", "rc", "RN", "nl", "unn", "rr", "rob", "oren", "rx", "arm", "r", "cmd", "n", "fn", "cp", "nc", "cn", "rom", "rar", "cb", "pn", "rem", "RM", "rf", "ibr", "arn", "bn", "rt", "rin", "mr", "loc", "mn", "dn", "rb", "ptr", "rpm", "ro"], "op": ["it", "opt", "prop", "cmp", "Op", "typ", "ort", "ops", "hop", "ep", "o", "ok", "opp", "rop", "cop", "bit", "oss", "operator", "at", "rob", "false", "pr", "oop", "cmd", "cp", "p", "ver", "pop", "OP", "ob", "pred", "pos", "co", "oper", "comp", "attr", "ac", "oc", "ip", "loc", "ox", "rot", "jp", "ot"], "nzcv": ["deepCV", "tzCV", "zzfc", "zzCV", "gzcv", "nznv", "tzcv", "zznv", "gzCV", "nzuv", "gzuv", "nzvr", "Nazuv", "zzvr", "gznv", "Nazcv", "rsscv", "zvr", "zzcv", "zzvc", "Naznv", "zfc", "tzvr", "nzfc", "zCV", "rssvc", "tzfc", "znv", "rssnv", "nzvc", "deepnv", "deepcv", "zzuv", "nzCV", "rssuv", "zcv", "deepuv", "zuv", "Nazvc"], "tcg_flags": ["tcg_flag", "tcgc_bits", "tcgi_args", "tcg8fs", "tcg__fs", "tcgi_flags", "tcg__flags", "tcg___actions", "tcg__bugs", "tcgi_options", "tcg___bits", "tcv_bugs", "tcg___flags", "tcg8bugs", "tcgc_flags", "tcg_actions", "tcg_bits", "tcg8flags", "tcg_fs", "tcg_args", "tcv_flags", "tcg_mask", "tcg__mask", "tcg_bugs", "tcv_fs", "tcg8mask", "tcg__options", "tcg__bits", "tcgi_bits", "tcgc_actions", "tcgi_flag", "tcv_mask", "tcg_options", "tcg__args", "tcg__flag"]}}
{"project": "qemu", "commit_id": "ea6c5f8ffe6de12e04e63acbb9937683b30216e2", "target": 0, "func": "static inline int test_bit(unsigned int bit, const unsigned long *map)\n\n{\n\n    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));\n\n}\n", "idx": 27088, "substitutes": {"bit": ["block", "it", "type", "i", "x", "lit", "field", "out", "byte", "status", "col", "hit", "bo", "id", "word", "lt", "mon", "g", "top", "git", "pin", "bits", "lat", "ong", "tag", "Bit", "bug", "task", "b", "ct", "ac", "ip", "bi", "port", "base", "bot", "bin", "bt", "limit", "flag", "slot", "rot", "t", "BIT", "lock"], "map": ["block", "tree", "pack", "batch", "store", "hash", "code", "mb", "app", "mp", "index", "maps", "mem", "buffer", "mg", "late", "list", "cache", "use", "msg", "node", "set", "module", "view", "Map", "ap", "image", "shape", "share", "safe", "MAP", "load", "window", "link", "allow", "mask", "cap", "table", "age", "dict", "m", "lock"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_ns);\n\n\n\n        if (max_ns) {\n\n            poll_set_started(ctx, true);\n\n\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    poll_set_started(ctx, false);\n\n\n\n    /* Even if we don't run busy polling, try polling once in case it can make\n\n     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).\n\n     */\n\n    return run_poll_handlers_once(ctx);\n\n}\n", "idx": 27100, "substitutes": {"ctx": ["sys", "cl", "context", "cur", "cmp", "tm", "tx", "cf", "obj", "ok", "ca", "jac", "Context", "conn", "comm", "bc", "pc", "c", "that", "tc", "kt", "ctr", "crit", "tz", "wd", "ck", "mk", "act", "ctrl", "cmd", "pool", "ctl", "cp", "p", "today", "sc", "nc", "resp", "kj", "cb", "cm", "np", "co", "xs", "cfg", "wcs", "ct", "xc", "req", "anc", "nt", "work", "dl", "addr", "txt", "history", "window", "mc", "aux", "kw", "mt", "xp", "gc", "pkg", "kl", "jp", "cc", "tmp", "wx", "cv", "hw"], "blocking": ["using", "block", "available", "locking", "cl", "bool", "full", "latest", "status", "majority", "learning", "starting", "being", "friendly", "leasing", "joining", "loading", "enabled", "always", "speaking", "restricted", "policy", "sharing", "limited", "fully", "confirmed", "checking", "blocks", "ssl", "advertising", "exclusive", "ocking", "including", "poll", "quiet", "excluding", "optional", "checked", "partial", "forcing", "timeout", "running", "lock", "locked", "broad"]}}
{"project": "qemu", "commit_id": "563890c7c7e977842e2a35afe7a24d06d2103242", "target": 1, "func": "static int qmp_tmp105_get_temperature(const char *id)\n\n{\n\n    QDict *response;\n\n    int ret;\n\n\n\n    response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \"\n\n                   \"'property': 'temperature' } }\", id);\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    ret = qdict_get_int(response, \"return\");\n\n    QDECREF(response);\n\n    return ret;\n\n}\n", "idx": 27107, "substitutes": {"id": ["f", "type", "ident", "ad", "hid", "ref", "hash", "code", "d", "c", "event", "rid", "uid", "aid", "db", "p", "ids", "pid", " fid", "and", "tag", " ID", "oid", "vid", "info", "kid", "url", "link", "ID", "time", " tid", "q", "t", "ide", "mid", "Id", "name"], "response": ["block", "tree", "parent", "onse", "server", "reference", "reset", "search", "api", "hash", "definition", "service", "os", "success", "xml", "entry", "array", "config", "def", "valid", "question", "result", "output", "request", "object", "now", "translation", "relative", "reply", "list", "ve", "memory", "resp", "view", "pos", "message", "sequence", "next", "image", "connection", "doc", "detail", "example", "line", "data", "yes", "page", "document", "volume", "query", "Response", "window", "json", "es", "position", "relation", "version", "vector", "description", "q", "all", "v", "init", "answer", "res"], "ret": ["f", "it", "inter", "alt", "pet", "out", "ter", "lit", "reset", "ll", "RET", "rm", "re", "ref", "att", "gt", "def", "xt", "result", "read", "cont", "at", "lt", "rat", "r", "cat", "det", "cert", "pret", "rem", "j", "et", "ert", "rt", "nt", "rets", "des", "ft", "val", "flag", "mt", "en", "Ret", "tr", "t", "elt", "v", "pt", "res"]}}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_sys_interrupts(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    uint32_t op2;\n\n    uint32_t r1;\n\n    TCGLabel *l1;\n\n    TCGv tmp;\n\n\n\n    op2 = MASK_OP_SYS_OP2(ctx->opcode);\n\n    r1  = MASK_OP_SYS_S1D(ctx->opcode);\n\n\n\n    switch (op2) {\n\n    case OPC2_32_SYS_DEBUG:\n\n        /* raise EXCP_DEBUG */\n\n        break;\n\n    case OPC2_32_SYS_DISABLE:\n\n        tcg_gen_andi_tl(cpu_ICR, cpu_ICR, ~MASK_ICR_IE);\n\n        break;\n\n    case OPC2_32_SYS_DSYNC:\n\n        break;\n\n    case OPC2_32_SYS_ENABLE:\n\n        tcg_gen_ori_tl(cpu_ICR, cpu_ICR, MASK_ICR_IE);\n\n        break;\n\n    case OPC2_32_SYS_ISYNC:\n\n        break;\n\n    case OPC2_32_SYS_NOP:\n\n        break;\n\n    case OPC2_32_SYS_RET:\n\n        gen_compute_branch(ctx, op2, 0, 0, 0, 0);\n\n        break;\n\n    case OPC2_32_SYS_FRET:\n\n        gen_fret(ctx);\n\n        break;\n\n    case OPC2_32_SYS_RFE:\n\n        gen_helper_rfe(cpu_env);\n\n        tcg_gen_exit_tb(0);\n\n        ctx->bstate = BS_BRANCH;\n\n        break;\n\n    case OPC2_32_SYS_RFM:\n\n        if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM) {\n\n            tmp = tcg_temp_new();\n\n            l1 = gen_new_label();\n\n\n\n            tcg_gen_ld32u_tl(tmp, cpu_env, offsetof(CPUTriCoreState, DBGSR));\n\n            tcg_gen_andi_tl(tmp, tmp, MASK_DBGSR_DE);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, tmp, 1, l1);\n\n            gen_helper_rfm(cpu_env);\n\n            gen_set_label(l1);\n\n            tcg_gen_exit_tb(0);\n\n            ctx->bstate = BS_BRANCH;\n\n            tcg_temp_free(tmp);\n\n        } else {\n\n            /* generate privilege trap */\n\n        }\n\n        break;\n\n    case OPC2_32_SYS_RSLCX:\n\n        gen_helper_rslcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_SVLCX:\n\n        gen_helper_svlcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_RESTORE:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM ||\n\n                (ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_UM1) {\n\n                tcg_gen_deposit_tl(cpu_ICR, cpu_ICR, cpu_gpr_d[r1], 8, 1);\n\n            } /* else raise privilege trap */\n\n        } /* else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_SYS_TRAPSV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_SV, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_SOVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    case OPC2_32_SYS_TRAPV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_V, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_OVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    }\n\n}\n", "idx": 27129, "substitutes": {"env": ["context", "tx", "ev", "conn", "viron", "map", "dev", "ec", "node", "cb", "buf", "et", "vs", "environment", "cfg", "nv", "window", "gn", "e", "kw", "en", "eng", "vt", "proc", "v", "conf"], "ctx": ["cmp", "ca", "cu", "qt", "c", "tc", "dc", "ctl", "asm", "xs", "ct", "loc", "history", "ci", "exec", "gc", "pkg", "tm", "tx", "cf", "obj", "Context", "conn", "bc", "config", "ctrl", "cp", "sc", "msg", "ksh", "setup", "mom", "wcs", "ind", "window", "handle", "hw", "sys", "context", "except", "jac", "kt", "ck", "act", "nc", "cm", "cfg", "cas", "kw", "xp", "cc", "wx", "cv", "this", "tk", "ann", "rc", "cpu", "cmd", "resp", "cb", "np", "js", "req", "xc", "nt", "txt", "aux", "jp", "index", "conv", "init", "conf"], "op2": ["op256", "OP02", "ops2", "cop4", "Opcome", "Op1", "copTwo", "ops256", " op02", "OPTwo", " op256", "OP3", "oper4", "oper2", "op4", "OP32", "ops02", " op4", "cop32", "op02", "Op2", "oop2", "ropTwo", "ops3", "rop4", "op3", "oop1", "rop32", "op1", "opcome", "rop2", "OP4", "oper02", "OP2", "OPcome", "cop2", "oper256", "OP1", "oopcome", "op32", "opTwo", " op3", "ops4"], "r1": ["r2", "R0", "cr2", "r0", "r61", " r0", "cr61", "l61", "cr1", " r61", " r2", "R1", "l0", "l2", "R2"], "l1": ["r2", "L2", "r0", "el1", "r4", "lasso", "sl1", " l4", "l4", "slasso", "sl4", "L1", " l2", "sl0", "l0", " lasso", "L0", "l2", "el0", " l0", "rasso", "el2"], "tmp": ["cur", "cmp", "stuff", "tc", "sam", "tt", "var", "tem", "p", "new", "mint", "orig", "tg", "attr", "src", "front", "base", "snap", "pkg", "v", "tar", "tm", "angle", "obj", "temp", "pty", "term", "yy", "mk", "cp", "tab", "qq", "msg", "buf", "data", "py", "ind", "MP", "aaa", "buff", "vt", "perm", "mp", "td", "gm", "test", "gb", "emp", "wx", "cv", "this", "out", "appy", "err", "result", "empty", "top", "cmd", "cache", "img", "resp", "up", "np", "html", "nt", "txt", "tif", "sp", "aux", "etc", "t", "uv", "proc"]}}
{"project": "qemu", "commit_id": "80e1eea37a25a7696137e680285e36d0bfdc9f34", "target": 1, "func": "static void pci_hotplug(void)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QOSState *qs;\n\n    const char *arch = qtest_get_arch();\n\n\n\n    qs = pci_test_start();\n\n\n\n    /* plug secondary disk */\n\n    qpci_plug_device_test(\"virtio-blk-pci\", \"drv1\", PCI_SLOT_HP,\n\n                          \"'drive': 'drive1'\");\n\n\n\n    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);\n\n    g_assert(dev);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n\n\n    /* unplug secondary disk */\n\n    if (strcmp(arch, \"i386\") == 0 || strcmp(arch, \"x86_64\") == 0) {\n\n        qpci_unplug_acpi_device_test(\"drv1\", PCI_SLOT_HP);\n\n    }\n\n    qtest_shutdown(qs);\n\n}\n", "idx": 27148, "substitutes": {"dev": ["priv", "sd", "block", "device", "hw", "ad", "Device", "out", "tech", "cam", "obj", " Dev", "ev", "conn", "cand", "iv", "d", "pad", "adv", "w", "def", " device", "pi", "disk", "mem", "var", "cho", "gu", "md", "db", "DEV", "det", "ver", "p", "ve", "kh", "res", "sh", "develop", "di", "devices", "av", "ach", "data", "usb", "de", "nt", "dd", "des", "dem", "Dev", "serial", "val", "ptr", "v", "od"], "qs": ["ms", "irs", "ues", "dq", "ins", "reads", "gets", "fs", "rs", "qt", "ds", "hs", "ks", "details", "ques", "qu", "uds", " queries", "qq", "cs", "sts", "cks", "aws", "ctx", "vs", "als", "ksh", "iq", "qa", "bs", "qus", "gm", "ats", "ns", "ts", "ps", "ims", "query", "vals", "eks", "fts", "gs", "ys", "ires", "q", "ls", "ows", "sq", "ips"], "arch": ["ch", "mac", "archs", "brand", "installed", "ev", "os", "comm", "Arch", "app", "bit", "och", "alg", "eh", "rc", "pp", "platform", "cpu", "reg", "ARCH", "var", "auth", "act", "ec", "arm", "ext", "cmd", "ar", "ver", "arr", "img", "arc", "mot", "ra", "form", "art", "ach", "old", "ag", "prot", "iph", "imp", "exec", "ir", "h", "eng", "proc", "str", "alph"]}}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static unsigned long iv_decode_frame(Indeo3DecodeContext *s, \n                                     unsigned char *buf, int buf_size) \n{\n  unsigned int hdr_width, hdr_height,\n    chroma_width, chroma_height;\n  unsigned long fflags1, fflags2, fflags3, offs1, offs2, offs3, offs;\n  unsigned char *hdr_pos, *buf_pos;\n  buf_pos = buf;\n  buf_pos += 18;\n  fflags1 = le2me_16(*(uint16_t *)buf_pos);\n  buf_pos += 2;\n  fflags3 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  fflags2 = *buf_pos++;\n  buf_pos += 3;\n  hdr_height = le2me_16(*(uint16_t *)buf_pos);\n  buf_pos += 2;\n  hdr_width = le2me_16(*(uint16_t *)buf_pos);\n  buf_pos += 2;\n  chroma_height = ((hdr_height >> 2) + 3) & 0x7ffc;\n  chroma_width = ((hdr_width >> 2) + 3) & 0x7ffc;\n  offs1 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  offs2 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  offs3 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 8;\n  hdr_pos = buf_pos;\n  if(fflags3 == 0x80) return 4;\n  if(fflags1 & 0x200) {\n    s->cur_frame = s->iv_frame + 1;\n    s->ref_frame = s->iv_frame;\n  } else {\n    s->cur_frame = s->iv_frame;\n    s->ref_frame = s->iv_frame + 1;\n  }\n  buf_pos = buf + 16 + offs1;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Ybuf, s->ref_frame->Ybuf, hdr_width, \n    hdr_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(hdr_width, 160));\n  if (!(s->avctx->flags & CODEC_FLAG_GRAY))\n  {\n  buf_pos = buf + 16 + offs2;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Vbuf, s->ref_frame->Vbuf, chroma_width, \n    chroma_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(chroma_width, 40));\n  buf_pos = buf + 16 + offs3;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Ubuf, s->ref_frame->Ubuf, chroma_width, \n    chroma_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(chroma_width, 40));\n  }\n  return 8;\n}", "idx": 27151, "substitutes": {"s": ["sys", "sn", "ms", "x", "sb", "ports", "ops", "eps", "ins", "sis", "os", "comm", "se", "v", "rs", "c", "ex", "ses", "ds", "hs", "comments", "details", "spec", "n", "p", "changes", "bis", "cs", "sts", "set", "aws", "S", "als", "bs", "js", "ss", "is", "b", "l", "ns", "ts", "ps", "ims", "https", "y", "qs", "stats", "south", "es", "its", "e", "gs", "sv", "less", "sg", "h", "t", "ls", "sq", "conf"], "buf": ["block", "cur", "batch", "sb", "pb", "err", "ref", "queue", "uf", "br", "ff", "begin", "ctr", "buffer", "mem", "seq", "cmd", "db", "Buff", "p", "img", "msg", "cb", "bytes", "ctx", "bar", "pos", "paste", "vec", "next", "raw", "orig", "b", "data", "wb", "src", "loc", "text", "bin", "rb", "bp", "cap", "Buffer", "buff", "off", "xff", "end", "tmp", "str", "cv"], "buf_size": [" buf_ize", " buf_len", "buf_len", "buf_ize"], "hdr_width": ["hDR_content", "hdrptbody", "holder_mag", "hr_len", "hdr_length", "hdrptwidth", "holderptbody", "hdr10width", "hdrptposition", "hdr_len", "holderptmag", "hr_size", "hr_length", "hdr___width", "hdr_position", "hdr_weight", "hdr___body", "holder_position", "hdr10body", "hdrptmag", "hdr_body", "holder_body", "holder_width", "hdr___mag", "hdr_content", "hDR_width", "hDR_length", "hdr_mag", "hdr10mag", "hdr_size", "hr_width", "holderptwidth", "holderptposition", "hdr___position", "hDR_weight", "hdr10position"], "hdr_height": ["hdr5depth", "hDR_height", "hdr5width", "hdr_padding", "hdr_arch", "hdr5height", "hDR_power", "hdr2height", "hDR_arch", "hdr2width", "hdr1height", "hdr1width", "hDR_depth", "hdr_depth", "hDR_size", "hdr1padding", "hdr5power", "hdr1depth", "hdr_power", "hDR_width", "hdr2depth", "hdr2power", "hdr_size", "hDR_padding"], "chroma_width": ["chroma2weight", "chromA_weight", "chromA_width", "chroma_weight", "chroma_widget", "chroma_size", "chroma_length", "chroma2width", "chromia_length", "chromia_height", "chromia_widget", "chroma2size", "chromA_size", "chromia_width"], "chroma_height": ["chromao____html", "chromo_size", "chroma_read", "chromao_html", "chromo_length", "chroma____height", "chroma_history", "chroma_size", "chroma____length", "chroma_length", "chromao____read", "chromao____height", "chromao_height", "chromao_length", "chromao_read", "chroma____read", "chromo_history", "chromao____length", "chromo_height", "chroma____html", "chroma_html"], "fflags1": ["ffvlags1", "ffvlagsOne", "fflages1", "ffligs01", "fflugs1", "fflags6", "ffvlages0", "ffolag01", "fflags01", "ffvlages1", "fflaps1", "fflages0", "ffligs7", "ffligs2", "fflages2", "fflag01", "fflaps7", "fflaps6", "ffvlugs2", "ffolag2", "fflaps01", "ffolag1", "fflagsOne", "fflaps2", "fflagOne", "fflugs2", "fflag6", "ffolags2", "fflages01", "ffvlags2", "ffligsOne", "ffolag6", "fflags0", "fflages6", "fflags7", "ffvlags01", "ffolags01", "ffvlages01", "fflag1", "ffolags6", "ffvlags7", "ffvlugs7", "fflag2", "ffvlugs1", "fflugs7", "ffolags1", "ffligs0", "ffvlagesOne", "ffvlags0", "fflag0", "fflagesOne", "ffligs1"], "fflags2": ["fflags4", "fflatts2", "fflags01", "fflatts01", "fflags32", "ffslages12", "fflages2", "fflugs32", "fflatts4", "fflumps3", "fflides1", "fflatts1", "fflages12", "ffslags2", "fflides4", "fflugs2", "ffslags12", "fflags12", "ffslags32", "fflugs3", "fflumps2", "ffslages3", "ffflags4", "fflats4", "ffflags01", "fflides01", "ffslages2", "ffflatts2", "fflats1", "ffslages32", "ffflatts4", "fflides2", "ffflags1", "fflages32", "ffflatts01", "ffslags3", "fflats01", "ffflatts1", "fflumps32", "fflats2", "fflumps12", "fflages3", "fflugs12", "ffflags2"], "fflags3": ["fflags4", "fflacks23", "fflinks3", "ffklags21", "ffklags0", "ffklages8", "fflages0", "ffllags3", "fflacks2", "ffllagsThree", "fflagsThree", "ffslacks4", "ffllag2", "ffllagThree", "fflugs21", "fflges3", "fflges21", "ffklags3", "fflaps2", "fflugs0", "ffklags8", "fflacks3", "fflatsThree", "ffklages3", "fflats3", "ffslags2", "fflags8", "ffslacks2", "fflugs3", "fflags21", "fflags0", "fflges0", "fflacks4", "ffslags4", "ffllag3", "ffslags23", "fflag23", "fflinks4", "fflags23", "fflagThree", "fflapsThree", "fflages8", "fflag4", "fflages21", "ffklages0", "ffslacks3", "ffllags2", "ffslags3", "fflinks23", "fflges8", "fflages3", "fflats2", "ffslacks23", "fflaps3", "fflag3", "fflugs8", "fflinks2", "ffklages21", "fflag2"], "offs1": ["piecesOne", "pointers001", "outs001", "outs1", "topsone", "vals0", "offsOne", "hands0", "offs0", "outs0", "vals001", "valsone", "times001", "outsone", "vals1", "times1", "timesOne", "outs2", "hands2", "vals2", "tops001", "offsone", "pieces001", "tops2", "pointers1", "pieces1", "pointersOne", "hands1", "tops1", "offs001"], "offs2": ["uts1", "outs1", "ops2", "pointersTwo", "uts02", "ods2", "pointers12", "outs02", "pointers02", "ops12", "uts2", "ops02", "odsTwo", "outsTwo", "ods12", "offs12", "opsTwo", "outs2", "ods02", "ops1", "utsTwo", "offs02", "offsTwo", "pointers2"], "offs3": ["uts5", "outsThree", "outs1", "uts1", "outs3", "stocksthree", "ods3", "uts3", "stocks3", "ods15", "uts2", "offsThree", "ods5", "stocks5", "outs2", "offs5", "utsthree", "utsThree", "uts15", "odsthree", "tops2", "stocks15", "tops3", "offs15", "topsThree", "tops1", "offsthree"], "offs": ["finals", "ops", "limits", "pieces", "boxes", "utters", "bps", " offsets", "tips", "uts", "amps", "caps", "helps", "assets", "keys", "sets", "cells", "ints", "nos", "hands", "ups", "outs", "bs", "blocks", "tops", "stones", "ts", "nes", "ims", "vals", "uns", "locks", "styles", "aps", "cuts", "pres", "actions", "off", "orders", "heads", "pointers"], "hdr_pos": ["hbr_pos", "hdr_mon", "hbr_po", "hdr_position", "hdr2val", "hDR_val", "hDR_pos", "hbr_position", "hDR_loc", "hdr2loc", "hdr_val", "hDR_position", "hdr_loc", "hdr2pos", "hbr_mon", "hdr2position", "hdr_po"], "buf_pos": [" buf_pose", "cache_pres", "buftpos", " buf_pro", "cbtcos", "bufxpos", "buf2pres", "bufxgo", "cache_cos", "pool_pos", "bufgrpo", "buffer_pos", "queue_loc", " buf_p", "bufgrpos", "uf_loc", "uf_Pos", "buf64po", "buffer_po", "bufgrloc", "queue_pres", "buf_loc", "uf_neg", "bufptpost", "buf_go", "cache___pid", "buf2po", "bufgrpath", "buf_pid", "buf___pres", "buf_ps", " buf_pointer", "bufgrpres", "buf__position", "bufmmpres", "bufmmcos", "uf_ps", "buf2pos", "buf___pid", "buftpointer", "bufmmpid", "poolptos", "bufptos", "buf_position", "buf5prop", "block_po", "buf2os", "buf__pid", "buffer_position", "bufmmpos", "block_position", "uf2pos", "buf12po", "buf__neg", "buftpo", "buf0po", "cb_po", "cache___pres", "buf_pose", "cache___cos", "cache_pos", "uf_pose", "bufencache", "buftxcos", "uf_prop", "buf___pos", "buf___len", "buf_neg", "pool_os", "uf_po", "cbtpos", "buf2p", "uf_os", "queue_neg", "bufldpointer", "batch_go", "buf5pos", "buftxpos", "buf64cache", "buf___neg", "queue_p", "buf_prop", "buf0pid", "buf_post", "buf___po", "buf12pointer", "uf_position", "uf_pos", "bufenpose", "buf2cos", "buf___loc", "poolptpost", " buf_top", "cb_post", "bufenpos", "cache_pid", "uf2po", "bufptpos", "queue_path", "buf_pres", "buf__loc", "cbtpo", "buf__po", "buftpost", "buf2position", "buf5po", "buffer_len", "batch__len", "buf12sum", "buf_top", "bufttop", " buf_po", "buf_pointer", " buf_sum", "buf_path", "uf_p", "buf__pos", "batch_pos", "buf__p", "uf2mon", "uf2os", "buf__len", "buf_pro", "poolptpos", "buf___cos", "buf_cache", "batch__po", "batch_position", "block_pid", " buf_ps", "cb_cos", "buf0pos", "block_pos", "bufldpos", "bufgrsum", "buf2pid", "buftxpost", "buf2loc", "cb_pos", "buf_po", "uf_cache", "buf12pos", "batch_po", "pool_post", "buf2mon", "buf_os", "buf___position", "queue_pos", "batch__pos", "buf___p", "buf_p", "buf_sum", "cbtpost", "bufgrpointer", "buf64pos", "bufldtop", "buf_mon", "buf__mon", "buf_len", "uf_mon", "buf5ps", "bufenpo", "bufxposition", "buftxpo", "buf__os", "cache___pos", "batch__position", "buf0neg", "buf2len", "buf_Pos", "buftcos", "buf_cos", "buf64pose", "batch_len", "uf_pid"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "int gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb,\n\n                                    int search_pc)\n\n{\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    opc_handler_t **table, *handler;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    int j, lj = -1;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_ptr = gen_opc_buf;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    gen_opparam_ptr = gen_opparam_buf;\n\n    nb_gen_labels = 0;\n\n    ctx.nip = pc_start;\n\n    ctx.tb = tb;\n\n    ctx.exception = EXCP_NONE;\n\n    ctx.spr_cb = env->spr_cb;\n\n#if defined(CONFIG_USER_ONLY)\n\n    ctx.mem_idx = msr_le;\n\n#else\n\n    ctx.supervisor = 1 - msr_pr;\n\n    ctx.mem_idx = ((1 - msr_pr) << 1) | msr_le;\n\n#endif\n\n    ctx.fpu_enabled = msr_fp;\n\n    ctx.singlestep_enabled = env->singlestep_enabled;\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr_se = 1;\n\n#endif\n\n    /* Set env in case of segfault during code fetch */\n\n    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {\n\n        if (unlikely(env->nb_breakpoints > 0)) {\n\n            for (j = 0; j < env->nb_breakpoints; j++) {\n\n                if (env->breakpoints[j] == ctx.nip) {\n\n                    gen_op_update_nip(ctx.nip); \n\n                    gen_op_debug();\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (unlikely(search_pc)) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.nip;\n\n                gen_opc_instr_start[lj] = 1;\n\n            }\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"----------------\\n\");\n\n            fprintf(logfile, \"nip=%08x super=%d ir=%d\\n\",\n\n                    ctx.nip, 1 - msr_pr, msr_ir);\n\n        }\n\n#endif\n\n        ctx.opcode = ldl_code(ctx.nip);\n\n        if (msr_le) {\n\n            ctx.opcode = ((ctx.opcode & 0xFF000000) >> 24) |\n\n                ((ctx.opcode & 0x00FF0000) >> 8) |\n\n                ((ctx.opcode & 0x0000FF00) << 8) |\n\n                ((ctx.opcode & 0x000000FF) << 24);\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"translate opcode %08x (%02x %02x %02x) (%s)\\n\",\n\n                    ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode),\n\n                    opc3(ctx.opcode), msr_le ? \"little\" : \"big\");\n\n        }\n\n#endif\n\n        ctx.nip += 4;\n\n        table = env->opcodes;\n\n        handler = table[opc1(ctx.opcode)];\n\n        if (is_indirect_opcode(handler)) {\n\n            table = ind_table(handler);\n\n            handler = table[opc2(ctx.opcode)];\n\n            if (is_indirect_opcode(handler)) {\n\n                table = ind_table(handler);\n\n                handler = table[opc3(ctx.opcode)];\n\n            }\n\n        }\n\n        /* Is opcode *REALLY* valid ? */\n\n        if (unlikely(handler->handler == &gen_invalid)) {\n\n            if (loglevel > 0) {\n\n                fprintf(logfile, \"invalid/unsupported opcode: \"\n\n                        \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                        opc1(ctx.opcode), opc2(ctx.opcode),\n\n                        opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            } else {\n\n                printf(\"invalid/unsupported opcode: \"\n\n                       \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                       opc1(ctx.opcode), opc2(ctx.opcode),\n\n                       opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            }\n\n        } else {\n\n            if (unlikely((ctx.opcode & handler->inval) != 0)) {\n\n                if (loglevel > 0) {\n\n                    fprintf(logfile, \"invalid bits: %08x for opcode: \"\n\n                            \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                            ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                            opc2(ctx.opcode), opc3(ctx.opcode),\n\n                            ctx.opcode, ctx.nip - 4);\n\n                } else {\n\n                    printf(\"invalid bits: %08x for opcode: \"\n\n                           \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                           ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                           opc2(ctx.opcode), opc3(ctx.opcode),\n\n                           ctx.opcode, ctx.nip - 4);\n\n                }\n\n                RET_INVAL(ctxp);\n\n                break;\n\n            }\n\n        }\n\n        (*(handler->handler))(&ctx);\n\n#if defined(DO_PPC_STATISTICS)\n\n        handler->count++;\n\n#endif\n\n        /* Check trace mode exceptions */\n\n        if (unlikely((msr_be && ctx.exception == EXCP_BRANCH) ||\n\n                     /* Check in single step trace mode\n\n                      * we need to stop except if:\n\n                      * - rfi, trap or syscall\n\n                      * - first instruction of an exception handler\n\n                      */\n\n                     (msr_se && (ctx.nip < 0x100 ||\n\n                                 ctx.nip > 0xF00 ||\n\n                                 (ctx.nip & 0xFC) != 0x04) &&\n\n                      ctx.exception != EXCP_SYSCALL &&\n\n                      ctx.exception != EXCP_SYSCALL_USER &&\n\n                      ctx.exception != EXCP_TRAP))) {\n\n            RET_EXCP(ctxp, EXCP_TRACE, 0);\n\n        }\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n                     (env->singlestep_enabled))) {\n\n            break;\n\n        }\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ctx.exception == EXCP_NONE) {\n\n        gen_goto_tb(&ctx, 0, ctx.nip);\n\n    } else if (ctx.exception != EXCP_BRANCH) {\n\n        gen_op_reset_T0();\n\n        /* Generate the return instruction */\n\n        gen_op_exit_tb();\n\n    }\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (unlikely(search_pc)) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n        tb->size = 0;\n\n    } else {\n\n        tb->size = ctx.nip - pc_start;\n\n    }\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_CPU) {\n\n        fprintf(logfile, \"---------------- excp: %04x\\n\", ctx.exception);\n\n        cpu_dump_state(env, logfile, fprintf, 0);\n\n    }\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        int flags;\n\n        flags = msr_le;\n\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n        target_disas(logfile, pc_start, ctx.nip - pc_start, flags);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n    if (loglevel & CPU_LOG_TB_OP) {\n\n        fprintf(logfile, \"OP:\\n\");\n\n        dump_ops(gen_opc_buf, gen_opparam_buf);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 27169, "substitutes": {"env": ["vm", "here", "hw", "esc", "ter", "tx", "server", "ner", "ev", "network", "Environment", "conn", "viron", "vp", "erd", "entry", "config", "eh", "er", "dev", "ew", "gate", "ec", "act", "ah", "db", "cmd", "ten", "ve", "org", "msg", "gov", "sw", "buf", "te", "pe", "environment", "vs", "inv", "enc", "actor", "policy", "setup", "eas", "nv", "addr", "worker", "window", "e", "tp", "net", "en", "sv", "era", "h", "her", "eng", "vt", "manager", "v", "exc", "uv", "cv", "conf"], "tb": ["tsbl", " tfb", "tbf", "pb", "tsb", "portbl", "ptv", "ptbe", "tsbr", "tsbf", "nb", "tv", "tbe", " trb", "trb", "pB", " tB", "tfb", "ttfb", "ptb", "ttbl", "nbf", "portfb", "tbr", "ttb", "ptrb", " tbe", " tbr", "ptbl", "ptbf", "portb", " tv", " tbl", "pbr", "tsbe", "nbr", "ptbr", "ptB", "nbl", "tsv", "tB", "tbl", "prb"], "search_pc": ["Search_PC", "search_PC", " search_pb", "search_pr", " search_proc", "search_pb", "search__pr", "searchingpc", "searchingpb", "searchingproc", "Search_pr", "search__PC", "search__fc", "Search_fc", "search__pc", "Search_pc", "searchingPC", "search_fc", "search_proc", " search_PC"], "ctx": [" gp", "cmp", "kk", "ca", "cu", "fw", "tnc", "std", "that", "tc", "ctr", "dc", "crit", "ctl", "xs", "ct", "ns", "info", "loc", "fc", " kb", "scope", "gc", "pkg", "ptr", "here", " cpu", "tx", "cf", "obj", "xy", "conn", "gt", "tz", "mk", "ctrl", "func", "cp", "sc", " tc", "tab", "msg", "HK", "co", " tcp", "hw", " cx", "context", "x", "jac", "def", "kt", "wd", "ck", "act", "cond", "fn", "cm", "acl", "qa", " cp", "cfg", "addr", "kw", "tmp", "cc", "wx", "lc", "cv", " tx", " cmd", " c", " mc", "ref", "ka", "tk", " sc", " cc", "rc", "cmd", "resp", "cb", "set", "module", "nz", "np", "instance", "req", "yes", "xc", " context", "nt", "txt", "city", " cm", "aux", "etc", "jp", "index", "utils", "conf"], "ctxp": ["ptxt", "ttxt", "ttyp", "ttfx", "ttxp", "ptyp", "CTxp", "ctyp", "CTyp", "ctxt", "CTfx", "ctfx", "ptxp", "CTxt", "ptfx"], "table": ["block", "type", "ch", "batch", "address", "code", "try", "tf", "map", "master", "buffer", "header", "db", "tab", "transform", "atable", "rule", "chain", "inner", "bean", "stable", "able", "scope", "Table", "tr", "t", "index", "TABLE"], "handler": ["context", "hand", "server", "tx", "event", "er", "buffer", "command", "header", "holder", "filter", "Handler", "hook", "policy", "message", "parser", "rule", "test", "processor", "worker", "handle", "handled", "reader", "h", "manager", "proc", "callback"], "pc_start": ["proc_first", "pc2addr", "PC_step", "pc2start", "PC_end", "pc_end", "pc_offset", "pc00step", "proc_start", "PC_space", "pc_space", "PC_start", "pc__end", " pc_offset", "pc00end", "pc00space", "pc_addr", "proc_end", " pc_addr", "pc2end", "pc__start", "pc_first", "pc2offset", "pc__first", "pc00start", "pc_step", " pc_end"], "gen_opc_end": ["gen_opcs_end", "gen_opc__end", "gen_opc2end", "gen_opcs_start", "gen_opc2max", "gen_opcs_max", "gen_opc_max", "gen_opc__start", "gen_opc2start", "gen_opc__max", "gen_opcs_ends", "gen_opc_buf", "gen_opcs_END", "gen_opc_start", "gen_opcs_buf", "gen_opc_End", "gen_opcs_End", "gen_opc__buf", "gen_opc_END", "gen_opc2buf", "gen_opc_ends"], "j": ["ji", "it", " J", "job", "i", "x", "obj", "ja", "jump", "br", "ev", "try", "att", "d", "v", "uj", " i", "bo", " jump", "dj", " ii", "k", "fr", " n", "pr", "ng", "g", "Ja", " dj", "n", "p", "jo", "kj", "gov", "jit", "J", " maj", "js", "next", "jc", "jas", "l", "ind", "ij", "bj", "y", "key", "z", "oj", "json", "step", "str", "adj", "off", "tr", "h", "jp", "q", "jj", "jl", "aj", " l", "pt", "ix"], "lj": ["lja", "eljs", "llkj", "lejs", "olJ", "lijump", "ldj", "ljp", "eljp", "lijs", " lja", "ylng", "leja", "oljs", "ledj", " lji", "klja", "laj", "ljo", "llja", "liconn", "olconn", " ljp", "litji", "litJ", " lconn", "lji", "ulng", "lJ", "litj", "lconn", "elJ", "olaj", "ylja", "slj", "olj", "lljump", " lJ", "kljs", "slji", "liji", "kldj", "lng", "ulj", "olji", "elj", "sljs", "likj", "lijo", " laj", "ylj", "klj", "lljs", "lkj", "lej", " ljs", "llj", "litjs", "ljs", "litkj", "uljump", " ldj", "ljump", " ljo", "oljo", "ulkj", " lkj", "slaj", "ling", "lij", "litja", "llng", "liJ", "yljs", "litng", "lijp"]}}
{"project": "qemu", "commit_id": "2c8f86961b6eaac705be21bc98299f5517eb0b6b", "target": 1, "func": "static void test_ide_drive_cd_0(void)\n\n{\n\n    char *argv[256];\n\n    int argc, ide_idx;\n\n    Backend i;\n\n\n\n    argc = setup_common(argv, ARRAY_SIZE(argv));\n\n    for (i = 0; i <= backend_empty; i++) {\n\n        ide_idx = backend_empty - i;\n\n        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];\n\n        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),\n\n                         ide_idx, NULL, i, mbr_blank, \"\");\n\n    }\n\n    qtest_start(g_strjoinv(\" \", argv));\n\n    test_cmos();\n\n    qtest_end();\n\n}\n", "idx": 27171, "substitutes": {"argv": ["agv", "argx", "argumentv", "argumentc", "argf", "Argc", " argx", "Argf", "argsc", "argsp", "Argb", "Argp", "Argl", "argb", " argvs", "argumentl", "argumentf", "argsx", "argvs", "argp", "Argv", "callm", "callv", "argsl", "argsv", "argm", "argumentm", " argm", "argsvs", "argumentx", "agvs", "argumentp", "argsb", " argl", "agc", "argsm", "callx", "argumentb", "callc", "agx", " argf", "argl", "argsf"], "argc": ["agv", "Argcs", "argC", "argumentc", "argf", "Argc", "argce", "Argf", "argcache", "argsc", "Argl", " argce", "opv", "argumentl", " argca", "argumentC", "Argce", " argcs", "opce", "agl", "Argv", "argumentca", "argsl", "argt", "argsca", " argC", "Argct", "ArgC", "argct", " argcache", "agcs", " argct", " argt", "argca", "opc", " argl", "agc", "opf", "argumentt", "argst", "argumentcache", "argcs", " argf", "argl", "Argcache", "argumentct"], "ide_idx": ["ide_indxs", "ide_ideg", "ide_indg", "ide___idexi", "ide_Idz", "ide_Idxs", "ide_idex", "ide_ideex", "ide___idex", "ide_idz", "ide_ideno", "ide_idg", "ide_Idy", "ide___idxi", "ide_idxs", "ide_idno", "ide_basedno", "ide___idec", "ide_basedxs", "ide_idexi", "ide_idc", "ide_latxi", "ide_idxc", "ide_Idno", "ide_Idxc", "ide_latx", "ide_indx", "ide___idc", "ide_idexc", "ide___idx", "ide_Idx", "ide_idxi", "ide_latex", "ide_idexs", "ide_idec", "ide_idez", "ide___ideex", "ide_basedx", "ide_idey", "ide_latc", "ide_indz", "ide_idy", "ide_basedxc"], "i": ["f", "it", "ic", "x", "ui", " j", "ki", "multi", "\u0438", "pi", "c", "id", "ini", "index", "ri", "in", " Ai", "gi", "I", "n", "p", "phi", " bi", "di", "oi", "zi", "sim", "j", "go", "ai", "to", "asi", "Ti", "li", "mi", "ii", "hi", "is", "ti", "l", "ind", "bi", " pi", "y", "ims", "ip", "ij", "z", "ci", "adi", "Xi", "e", "u", "iu", " I", "xi", "si", "im", "h", "t", "m", "v", "cli", "qi", "ix"]}}
{"project": "FFmpeg", "commit_id": "e13f860ac8a5a7d803059d1553773cf2a446d3f2", "target": 0, "func": "static int decode_vol_header(MpegEncContext *s, GetBitContext *gb){\n\n    int width, height, vo_ver_id;\n\n\n\n    /* vol header */\n\n    skip_bits(gb, 1); /* random access */\n\n    s->vo_type= get_bits(gb, 8);\n\n    if (get_bits1(gb) != 0) { /* is_ol_id */\n\n        vo_ver_id = get_bits(gb, 4); /* vo_ver_id */\n\n        skip_bits(gb, 3); /* vo_priority */\n\n    } else {\n\n        vo_ver_id = 1;\n\n    }\n\n//printf(\"vo type:%d\\n\",s->vo_type);\n\n    s->aspect_ratio_info= get_bits(gb, 4);\n\n    if(s->aspect_ratio_info == FF_ASPECT_EXTENDED){\t    \n\n        s->aspected_width = get_bits(gb, 8); // par_width\n\n        s->aspected_height = get_bits(gb, 8); // par_height\n\n    }else{\n\n        s->aspected_width = pixel_aspect[s->aspect_ratio_info][0];\n\n        s->aspected_height= pixel_aspect[s->aspect_ratio_info][1];\n\n    }\n\n\n\n    if ((s->vol_control_parameters=get_bits1(gb))) { /* vol control parameter */\n\n        int chroma_format= get_bits(gb, 2);\n\n        if(chroma_format!=1){\n\n            printf(\"illegal chroma format\\n\");\n\n        }\n\n        s->low_delay= get_bits1(gb);\n\n        if(get_bits1(gb)){ /* vbv parameters */\n\n            get_bits(gb, 15);\t/* first_half_bitrate */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 15);\t/* latter_half_bitrate */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 15);\t/* first_half_vbv_buffer_size */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 3);\t/* latter_half_vbv_buffer_size */\n\n            get_bits(gb, 11);\t/* first_half_vbv_occupancy */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 15);\t/* latter_half_vbv_occupancy */\n\n            skip_bits1(gb);\t/* marker */               \n\n        }\n\n    }else{\n\n        // set low delay flag only once so the smart? low delay detection wont be overriden\n\n        if(s->picture_number==0)\n\n            s->low_delay=0;\n\n    }\n\n\n\n    s->shape = get_bits(gb, 2); /* vol shape */\n\n    if(s->shape != RECT_SHAPE) printf(\"only rectangular vol supported\\n\");\n\n    if(s->shape == GRAY_SHAPE && vo_ver_id != 1){\n\n        printf(\"Gray shape not supported\\n\");\n\n        skip_bits(gb, 4);  //video_object_layer_shape_extension\n\n    }\n\n\n\n    skip_bits1(gb);   /* marker */\n\n    \n\n    s->time_increment_resolution = get_bits(gb, 16);\n\n    \n\n    s->time_increment_bits = av_log2(s->time_increment_resolution - 1) + 1;\n\n    if (s->time_increment_bits < 1)\n\n        s->time_increment_bits = 1;\n\n    skip_bits1(gb);   /* marker */\n\n\n\n    if (get_bits1(gb) != 0) {   /* fixed_vop_rate  */\n\n        skip_bits(gb, s->time_increment_bits);\n\n    }\n\n\n\n    if (s->shape != BIN_ONLY_SHAPE) {\n\n        if (s->shape == RECT_SHAPE) {\n\n            skip_bits1(gb);   /* marker */\n\n            width = get_bits(gb, 13);\n\n            skip_bits1(gb);   /* marker */\n\n            height = get_bits(gb, 13);\n\n            skip_bits1(gb);   /* marker */\n\n            if(width && height){ /* they should be non zero but who knows ... */\n\n                s->width = width;\n\n                s->height = height;\n\n//                printf(\"width/height: %d %d\\n\", width, height);\n\n            }\n\n        }\n\n        \n\n        s->progressive_sequence= get_bits1(gb)^1;\n\n        if(!get_bits1(gb)) printf(\"OBMC not supported (very likely buggy encoder)\\n\");   /* OBMC Disable */\n\n        if (vo_ver_id == 1) {\n\n            s->vol_sprite_usage = get_bits1(gb); /* vol_sprite_usage */\n\n        } else {\n\n            s->vol_sprite_usage = get_bits(gb, 2); /* vol_sprite_usage */\n\n        }\n\n        if(s->vol_sprite_usage==STATIC_SPRITE) printf(\"Static Sprites not supported\\n\");\n\n        if(s->vol_sprite_usage==STATIC_SPRITE || s->vol_sprite_usage==GMC_SPRITE){\n\n            if(s->vol_sprite_usage==STATIC_SPRITE){\n\n                s->sprite_width = get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n                s->sprite_height= get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n                s->sprite_left  = get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n                s->sprite_top   = get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n            }\n\n            s->num_sprite_warping_points= get_bits(gb, 6);\n\n            s->sprite_warping_accuracy = get_bits(gb, 2);\n\n            s->sprite_brightness_change= get_bits1(gb);\n\n            if(s->vol_sprite_usage==STATIC_SPRITE)\n\n                s->low_latency_sprite= get_bits1(gb);            \n\n        }\n\n        // FIXME sadct disable bit if verid!=1 && shape not rect\n\n        \n\n        if (get_bits1(gb) == 1) {   /* not_8_bit */\n\n            s->quant_precision = get_bits(gb, 4); /* quant_precision */\n\n            if(get_bits(gb, 4)!=8) printf(\"N-bit not supported\\n\"); /* bits_per_pixel */\n\n            if(s->quant_precision!=5) printf(\"quant precission %d\\n\", s->quant_precision);\n\n        } else {\n\n            s->quant_precision = 5;\n\n        }\n\n        \n\n        // FIXME a bunch of grayscale shape things\n\n\n\n        if((s->mpeg_quant=get_bits1(gb))){ /* vol_quant_type */\n\n            int i, v;\n\n            \n\n            /* load default matrixes */\n\n            for(i=0; i<64; i++){\n\n                int j= s->dsp.idct_permutation[i];\n\n                v= ff_mpeg4_default_intra_matrix[i];\n\n                s->intra_matrix[j]= v;\n\n                s->chroma_intra_matrix[j]= v;\n\n                \n\n                v= ff_mpeg4_default_non_intra_matrix[i];\n\n                s->inter_matrix[j]= v;\n\n                s->chroma_inter_matrix[j]= v;\n\n            }\n\n\n\n            /* load custom intra matrix */\n\n            if(get_bits1(gb)){\n\n                int last=0;\n\n\t\tfor(i=0; i<64; i++){\n\n                    int j;\n\n                    v= get_bits(gb, 8);\n\n                    if(v==0) break;\n\n                    \n\n                    last= v;\n\n                    j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->intra_matrix[j]= v;\n\n                    s->chroma_intra_matrix[j]= v;\n\n                }\n\n\n\n                /* replicate last value */\n\n                for(; i<64; i++){\n\n\t\t    int j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->intra_matrix[j]= v;\n\n                    s->chroma_intra_matrix[j]= v;\n\n                }\n\n            }\n\n\n\n            /* load custom non intra matrix */\n\n            if(get_bits1(gb)){\n\n                int last=0;\n\n\t\tfor(i=0; i<64; i++){\n\n                    int j;\n\n                    v= get_bits(gb, 8);\n\n                    if(v==0) break;\n\n\n\n                    last= v;\n\n                    j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->inter_matrix[j]= v;\n\n                    s->chroma_inter_matrix[j]= v;\n\n                }\n\n\n\n                /* replicate last value */\n\n                for(; i<64; i++){\n\n\t\t    int j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->inter_matrix[j]= last;\n\n                    s->chroma_inter_matrix[j]= last;\n\n                }\n\n            }\n\n\n\n            // FIXME a bunch of grayscale shape things\n\n        }\n\n\n\n        if(vo_ver_id != 1)\n\n             s->quarter_sample= get_bits1(gb);\n\n        else s->quarter_sample=0;\n\n\n\n        if(!get_bits1(gb)) printf(\"Complexity estimation not supported\\n\");\n\n\n\n        s->resync_marker= !get_bits1(gb); /* resync_marker_disabled */\n\n\n\n        s->data_partitioning= get_bits1(gb);\n\n        if(s->data_partitioning){\n\n            s->rvlc= get_bits1(gb);\n\n            if(s->rvlc){\n\n                printf(\"reversible vlc not supported\\n\");\n\n            }\n\n        }\n\n        \n\n        if(vo_ver_id != 1) {\n\n            s->new_pred= get_bits1(gb);\n\n            if(s->new_pred){\n\n                printf(\"new pred not supported\\n\");\n\n                skip_bits(gb, 2); /* requested upstream message type */\n\n                skip_bits1(gb); /* newpred segment type */\n\n            }\n\n            s->reduced_res_vop= get_bits1(gb);\n\n            if(s->reduced_res_vop) printf(\"reduced resolution VOP not supported\\n\");\n\n        }\n\n        else{\n\n            s->new_pred=0;\n\n            s->reduced_res_vop= 0;\n\n        }\n\n\n\n        s->scalability= get_bits1(gb);\n\n\n\n        if (s->scalability) {\n\n            GetBitContext bak= *gb;\n\n            int ref_layer_id;\n\n            int ref_layer_sampling_dir;\n\n            int h_sampling_factor_n;\n\n            int h_sampling_factor_m;\n\n            int v_sampling_factor_n;\n\n            int v_sampling_factor_m;\n\n            \n\n            s->hierachy_type= get_bits1(gb);\n\n            ref_layer_id= get_bits(gb, 4);\n\n            ref_layer_sampling_dir= get_bits1(gb);\n\n            h_sampling_factor_n= get_bits(gb, 5);\n\n            h_sampling_factor_m= get_bits(gb, 5);\n\n            v_sampling_factor_n= get_bits(gb, 5);\n\n            v_sampling_factor_m= get_bits(gb, 5);\n\n            s->enhancement_type= get_bits1(gb);\n\n            \n\n            if(   h_sampling_factor_n==0 || h_sampling_factor_m==0 \n\n               || v_sampling_factor_n==0 || v_sampling_factor_m==0){\n\n               \n\n//                fprintf(stderr, \"illegal scalability header (VERY broken encoder), trying to workaround\\n\");\n\n                s->scalability=0;\n\n               \n\n                *gb= bak;\n\n            }else\n\n                printf(\"scalability not supported\\n\");\n\n            \n\n            // bin shape stuff FIXME\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 27201, "substitutes": {"s": ["ops", "eps", "comm", "sports", "c", "comments", "tests", "pers", "mods", "p", "changes", "aws", "vs", "S", "ns", "ies", "states", "less", "h", "orders", "sq", "views", "sb", "uploads", "store", "os", "rs", "rates", "spec", "n", "cs", "services", "als", "ats", "ts", "ims", "tes", "styles", "its", "eds", "parts", "m", "sys", "ms", "ins", "ants", "ses", "scripts", "results", "ids", "bis", "lines", "sts", "sw", "bs", "is", "ps", "stats", "gs", "ls", "ears", "ports", "se", "fs", "ds", "hs", "details", "js", "ss", "settings", "steps", "qs", "es", "sv", "sg", "t"], "gb": ["range", "pb", "got", "vd", "storage", "gpu", "GB", "buffer", "gz", "um", "mg", "pg", "hub", "gg", "bits", "vg", "eg", "bg", "raw", "gh", "tg", "wb", "bt", "gc", "vm", "sb", "tm", "args", "xy", "bc", "pc", "nb", "gt", "bf", "phy", "db", "git", "google", "py", "lib", "gem", "gnu", "buff", "sys", "bb", "fb", "Gb", "mb", "ruby", "cd", " rgb", "rect", "bytes", "kb", "td", "bs", "cfg", "gm", "gs", "rb", "cv", "csv", "gif", "goo", "gin", "g", "cache", "img", "cb", "gd", "eb", "html", "dd", "json", "sg", "rg"], "height": ["padding", "dim", "length", "angle", "ih", "hash", "pi", "grow", "high", "build", "inches", "total", "depth", "shape", "quality", "image", "rank", "size", "info", "scale", "volume", "history", "version", "resolution", "h", "Height", "density"], "vo_ver_id": ["vo_ver_name", "vo_ver_ids", "vo_version_id", "vo_version_ids", "vo_version_info", "vo_version_index", "vo_version_code", "vo_ver_type", "vo_ver_flag", "vo_ver_code", "vo_version_name", "vo_ver____index", "vo_ver____id", "vo_ver_info", "vo_ver_index", "vo_version_type", "vo_ver____info", "vo_version_flag", "vo_ver____ids"]}}
{"project": "FFmpeg", "commit_id": "155ec6edf82692bcf3a5f87d2bc697404f4e5aaf", "target": 0, "func": "void ff_init_me(MpegEncContext *s){\n\n    MotionEstContext * const c= &s->me;\n\n    c->avctx= s->avctx;\n\n\n\n    ff_set_cmp(&s->dsp, s->dsp.me_pre_cmp, c->avctx->me_pre_cmp);\n\n    ff_set_cmp(&s->dsp, s->dsp.me_cmp, c->avctx->me_cmp);\n\n    ff_set_cmp(&s->dsp, s->dsp.me_sub_cmp, c->avctx->me_sub_cmp);\n\n    ff_set_cmp(&s->dsp, s->dsp.mb_cmp, c->avctx->mb_cmp);\n\n    \n\n    c->flags    = get_flags(c, 0, c->avctx->me_cmp    &FF_CMP_CHROMA);\n\n    c->sub_flags= get_flags(c, 0, c->avctx->me_sub_cmp&FF_CMP_CHROMA);\n\n    c->mb_flags = get_flags(c, 0, c->avctx->mb_cmp    &FF_CMP_CHROMA);\n\n\n\n/*FIXME s->no_rounding b_type*/\n\n    if(s->flags&CODEC_FLAG_QPEL){\n\n        c->sub_motion_search= qpel_motion_search;\n\n        c->qpel_avg= s->dsp.avg_qpel_pixels_tab;\n\n        if(s->no_rounding) c->qpel_put= s->dsp.put_no_rnd_qpel_pixels_tab;\n\n        else               c->qpel_put= s->dsp.put_qpel_pixels_tab;\n\n    }else{\n\n        if(c->avctx->me_sub_cmp&FF_CMP_CHROMA)\n\n            c->sub_motion_search= hpel_motion_search;\n\n        else if(   c->avctx->me_sub_cmp == FF_CMP_SAD \n\n                && c->avctx->    me_cmp == FF_CMP_SAD \n\n                && c->avctx->    mb_cmp == FF_CMP_SAD)\n\n            c->sub_motion_search= sad_hpel_motion_search; // 2050 vs. 2450 cycles\n\n        else\n\n            c->sub_motion_search= hpel_motion_search;\n\n    }\n\n    c->hpel_avg= s->dsp.avg_pixels_tab;\n\n    if(s->no_rounding) c->hpel_put= s->dsp.put_no_rnd_pixels_tab;\n\n    else               c->hpel_put= s->dsp.put_pixels_tab;\n\n\n\n    if(s->linesize){\n\n        c->stride  = s->linesize; \n\n        c->uvstride= s->uvlinesize;\n\n    }else{\n\n        c->stride  = 16*s->mb_width + 32;\n\n        c->uvstride=  8*s->mb_width + 16;\n\n    }\n\n\n\n    // 8x8 fullpel search would need a 4x4 chroma compare, which we dont have yet, and even if we had the motion estimation code doesnt expect it\n\n    if((c->avctx->me_cmp&FF_CMP_CHROMA) && !s->dsp.me_cmp[2]){\n\n        s->dsp.me_cmp[2]= zero_cmp;\n\n    }\n\n    if((c->avctx->me_sub_cmp&FF_CMP_CHROMA) && !s->dsp.me_sub_cmp[2]){\n\n        s->dsp.me_sub_cmp[2]= zero_cmp;\n\n    }\n\n    c->hpel_put[2][0]= c->hpel_put[2][1]=\n\n    c->hpel_put[2][2]= c->hpel_put[2][3]= zero_hpel;\n\n\n\n    c->temp= c->scratchpad;\n\n}\n", "idx": 27203, "substitutes": {"s": ["sys", "your", "ms", "as", "sb", "ops", "args", "o", "rest", "ins", "gets", "os", "ties", "erences", "fs", "app", "sports", "rs", "w", "bes", "ses", "aunts", "ds", "hs", "details", "times", "has", "changes", "bis", "sets", "cs", "sts", "set", "aws", "bits", "sw", "ches", "vs", "S", "js", "bs", "ss", "is", "ats", "b", "ts", "ns", "ps", "ims", "ies", "acs", "y", "qs", "stats", "south", "es", "its", "gs", "e", "sv", "less", "http", "eds", "source", "parts", "h", "ls", "m", "sq"], "c": ["cl", "ic", "uc", "cur", "cf", "cam", "ce", "ca", "cu", "err", "cal", "csv", "bc", "pc", "tc", "rc", "abc", "dc", "cont", "cd", "ec", "comments", "g", "ar", "cp", "p", "cache", "sc", "nc", "cn", "cs", "arc", "cb", "cm", "call", "can", "ctx", "enc", "cod", "com", "co", "chain", "comp", "ct", "xc", "ac", "anc", "l", "vc", "cr", "unc", "ci", "mc", "con", "fc", "coll", "u", "etc", "gc", "content", "cc", "C", "conv", "lc", "m", "cv", "conf"]}}
{"project": "FFmpeg", "commit_id": "afa982fdae1b49a8aee00a27da876bba10ba1073", "target": 1, "func": "static void filter(MpegAudioContext *s, int ch, short *samples, int incr)\n\n{\n\n    short *p, *q;\n\n    int sum, offset, i, j, norm, n;\n\n    short tmp[64];\n\n    int tmp1[32];\n\n    int *out;\n\n\n\n    //    print_pow1(samples, 1152);\n\n\n\n    offset = s->samples_offset[ch];\n\n    out = &s->sb_samples[ch][0][0][0];\n\n    for(j=0;j<36;j++) {\n\n        /* 32 samples at once */\n\n        for(i=0;i<32;i++) {\n\n            s->samples_buf[ch][offset + (31 - i)] = samples[0];\n\n            samples += incr;\n\n        }\n\n\n\n        /* filter */\n\n        p = s->samples_buf[ch] + offset;\n\n        q = filter_bank;\n\n        /* maxsum = 23169 */\n\n        for(i=0;i<64;i++) {\n\n            sum = p[0*64] * q[0*64];\n\n            sum += p[1*64] * q[1*64];\n\n            sum += p[2*64] * q[2*64];\n\n            sum += p[3*64] * q[3*64];\n\n            sum += p[4*64] * q[4*64];\n\n            sum += p[5*64] * q[5*64];\n\n            sum += p[6*64] * q[6*64];\n\n            sum += p[7*64] * q[7*64];\n\n            tmp[i] = sum >> 14;\n\n            p++;\n\n            q++;\n\n        }\n\n        tmp1[0] = tmp[16];\n\n        for( i=1; i<=16; i++ ) tmp1[i] = tmp[i+16]+tmp[16-i];\n\n        for( i=17; i<=31; i++ ) tmp1[i] = tmp[i+16]-tmp[80-i];\n\n\n\n        /* integer IDCT 32 with normalization. XXX: There may be some\n\n           overflow left */\n\n        norm = 0;\n\n        for(i=0;i<32;i++) {\n\n            norm |= abs(tmp1[i]);\n\n        }\n\n        n = av_log2(norm) - 12;\n\n        if (n > 0) {\n\n            for(i=0;i<32;i++) \n\n                tmp1[i] >>= n;\n\n        } else {\n\n            n = 0;\n\n        }\n\n\n\n        idct32(out, tmp1, s->sblimit, n);\n\n\n\n        /* advance of 32 samples */\n\n        offset -= 32;\n\n        out += 32;\n\n        /* handle the wrap around */\n\n        if (offset < 0) {\n\n            memmove(s->samples_buf[ch] + SAMPLES_BUF_SIZE - (512 - 32), \n\n                    s->samples_buf[ch], (512 - 32) * 2);\n\n            offset = SAMPLES_BUF_SIZE - 512;\n\n        }\n\n    }\n\n    s->samples_offset[ch] = offset;\n\n\n\n    //    print_pow(s->sb_samples, 1152);\n\n}\n", "idx": 27237, "substitutes": {"s": ["sys", "ms", "sb", "o", "os", "comm", "se", "fs", "v", "rs", "c", "ex", "ses", "ds", "hs", "conf", "g", "spec", "bis", "sc", "cs", "sts", "sw", "set", "S", "js", "bs", "ss", "so", "a", "is", "b", "ts", "ns", "ps", "stats", "gs", "less", "http", "sv", "sg", "source", "parts", "h", "t", "ls", "m", "sq", "ssl"], "ch": ["cl", "chn", "x", "chan", "CH", "batch", "chip", "chrom", "chart", "ih", "ched", "code", "cor", " y", "och", "c", "ech", "sky", "zh", "cho", "chron", " cs", "cp", "count", "kh", "sch", "Ch", "sh", "cs", "cb", "et", "ctx", " chunk", "ht", "cha", "chain", "ach", "b", "cht", "y", "z", "history", "channel", "ich", "h", " h", "v", "pt"], "samples": ["mores", " sources", "ssizes", "nsources", "tamps", "sents", "ssources", " sounds", "tources", "nsamps", "Samples", "Samps", "mounds", "mamps", " sores", "sizes", "Sores", "tizes", "tamples", " samps", "ssamps", "sources", "sounds", "nsents", "ssamples", "Sounds", "insamples", "insamps", "insources", " sents", "insents", "mamples", "nsamples", " sizes", "samps", "sores"], "incr": ["incrs", "incrat", "incur", "isecrs", "INCrn", "isecr", "isecerr", "integrn", "ignrn", " Incur", "INCrr", "incrn", "integrat", " Incrs", "INCr", " incur", "isecur", "ignr", " incerr", "INCrat", " Incr", "incerr", "integr", "incrr", " incrs", "ignrr", "integrr", " Incerr", "ignrat"], "p": ["f", "pm", "pre", "x", "perm", "pb", "point", "op", "mp", "pc", "app", "vp", "pi", "c", "pp", "er", "pr", "ar", "cp", "pg", "proc", "par", "ap", "pe", "up", "np", "per", "a", "b", "php", "ps", "ip", "post", "y", "pa", "wp", "pro", "tp", "sp", "u", "pkg", "P", "lp", "t", "jp", "m", "v", "pat", "pt"], "q": ["f", "Q", "x", "pm", "quant", "cf", "quest", "dq", "queue", "comm", "mp", "w", "qt", "question", "c", "pp", "ur", "k", "requ", "g", "qu", "cp", "count", "ve", "cache", "qq", "sh", "view", "pe", "form", "iq", "qa", "qual", "b", "req", "quote", "l", "ip", "query", "qs", "z", "window", "quad", "cap", "u", "eq", "ue", "pkg", "check", "t", "qi", "v", "sq", "m", "cv", "aq"], "sum": ["dim", "sa", "ount", "tex", "cal", "match", "ui", "gam", "see", "hash", "ma", "tu", "score", "status", "us", "c", "sam", "Sum", "hum", "zero", "mem", "ul", "mm", "result", "um", "g", "comment", "cast", "rup", "count", "cum", "cache", "sc", "use", "add", "vol", "usr", "set", "sim", "sym", "tim", "total", "acc", "doc", "process", "ind", "size", "ac", "weight", "mean", "fac", "volume", "SI", "base", "st", "num", "u", "un", " SUM", "si", "t", "stat", "index", "v", "m", "summary"], "offset": ["iat", "padding", "batch", "length", "ui", "angle", "o", "address", "ref", "bound", "pad", "entry", "error", "buffer", "offs", "pixel", "pointer", "ut", "set", "et", "origin", "order", "pos", "tile", "location", "l", "size", "shift", "ip", "start", "loc", "seek", "base", "position", "sp", "scroll", "seed", "off", "slot", "si", "t", "index", "point", "timeout", "Offset", "init", "end", "ix"], "i": ["ui", "o", "status", "ie", "c", "ini", "id", "er", "in", "I", "sim", "ai", "li", "info", "ip", "ij", "y", "ci", "iu", "si", "h", "v", "ei", "ji", "ki", "\u0438", "ik", "try", "at", "gu", "io", "chain", "ind", "ims", "key", "uri", "iter", "m", "qi", "ix", "iii", "x", "multi", "ami", "ri", "iy", "di", "oi", "zi", "mi", "ii", "print", "is", "l", "bi", "dr", "vi", "xi", "im", "f", "it", "ic", "mac", "ma", "pi", "ex", "ia", "g", "me", "gi", "set", "itime", "ity", "iq", "hi", "ti", "e", "u", "t", "index", "cli", "init"], "j": ["ji", "f", "it", "job", "x", "o", "ja", "jump", "br", "att", "v", "uj", "c", "dj", "fr", "k", "at", "pr", "g", "r", "el", "jo", "kj", "sim", "jit", "J", "js", "ne", "jc", "b", "l", "ind", "bi", "ij", "bj", "z", "json", "oj", "adj", "jp", "t", "m", "jj", "jl", "im", "aj", "no", "ion"], "norm": ["note", "it", "orm", "Norm", "not", "err", "nn", "nm", "nom", "term", "eff", "nb", "unit", "normal", "iz", "mem", "dev", "loss", "non", "nc", "ord", "dist", "sim", "nu", "form", "np", "vec", "ne", "mom", "nv", "ns", "nt", "fun", "scale", "NOR", "nor", "dot", "mn", "N", " norms", "num", "net", "u", "max", "diff", "uv", "no", "alph", "init", "res"], "n": ["sn", "na", "o", "nm", "nn", "nd", "len", "nan", "nb", "normal", "d", "ln", "nr", "c", "nl", "ng", "r", "fn", "nc", "cn", "ny", "nw", "nu", "np", "ne", "nv", "ns", "yes", "nt", "y", "nor", "mn", "N", "num", "u", "ni", "t", "no", "m", "v"], "tmp": ["tar", "cmp", "perm", "tm", "upload", "appy", "obj", "xy", "uf", "temp", "tu", "mb", "mp", "nb", "v", "tf", "vp", " temp", "emp", "tc", "tt", "video", " amp", "mm", "cp", "cache", "img", "qq", "new", "ob", "resp", "proc", "to", "buf", "ctx", "ht", "amp", "np", "td", "js", "html", "rt", "b", "test", "nt", "MP", "lib", "txt", "snap", "gb", "sp", "tp", "aux", "etc", "buff", "timeout", "table", "ptr", "t", " mp", "m", "uv", "bow", "pkg", "zip", "cv"], "tmp1": ["mpOne", "txt1", " tmp5", "temp1", "cmp2", "tmp0", "tmp2", "obj0", "mp3", "tmpOne", "temp0", "mp2", " tmp3", "cmp3", "node2", "mp1", " tmpOne", "obj2", " tmp4", "obj1", "tmp3", "txt3", "cmp0", "objOne", "tmp4", " tmp0", "temp2", "mp0", "mp5", " tmp2", "txtOne", "cmp1", "node5", "node1", "txt0", "temp4", "txt2", "tempOne", "mp4", "tmp5", "node0"], "out": ["it", "x", "o", "obj", "null", "temp", "bit", "w", "c", "ex", "result", "output", "mem", "g", "in", "list", "io", "new", "set", "to", "pos", "ot", "Out", "outs", "b", "size", "nt", "net", "OUT", "off", "t", "m", "v"]}}
{"project": "qemu", "commit_id": "e91e972ccfbaeba1d1416202ad1b667810a33e1f", "target": 0, "func": "int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    int ret = 0;\n\n\n\n    switch (run->exit_reason) {\n\n        case KVM_EXIT_S390_SIEIC:\n\n            ret = handle_intercept(cpu);\n\n            break;\n\n        case KVM_EXIT_S390_RESET:\n\n            qemu_system_reset_request();\n\n            break;\n\n        case KVM_EXIT_S390_TSCH:\n\n            ret = handle_tsch(cpu);\n\n            break;\n\n        case KVM_EXIT_DEBUG:\n\n            ret = kvm_arch_handle_debug_exit(cpu);\n\n            break;\n\n        default:\n\n            fprintf(stderr, \"Unknown KVM exit: %d\\n\", run->exit_reason);\n\n            break;\n\n    }\n\n\n\n    if (ret == 0) {\n\n        ret = EXCP_INTERRUPT;\n\n    }\n\n    return ret;\n\n}\n", "idx": 27254, "substitutes": {"cs": ["ras", "css", "ms", "fs", "pc", "rs", "c", "ds", "ks", "caps", "cp", "sc", "cus", "s", "cks", "sts", "ars", "ups", "bs", "js", "ss", "is", "wcs", "ts", "CS", "ns", "ps", "ac", "acs", "cas", "ls", "cc"], "run": ["range", "job", "out", "nn", "rm", "man", "boot", "ru", "unit", "begin", "commit", "flow", "rc", "runtime", "car", "report", "row", "in", "r", "cmd", "build", "ve", "use", "render", "add", "ra", "set", "go", "call", "ran", "pass", "process", "raw", "rt", "old", "runner", "runs", "Run", "load", "work", "play", "gem", "un", "running", "name", "ro"], "cpu": ["vm", "sys", "mac", "out", "cal", "cf", "cu", "boot", "pc", "c", "ilo", "core", "gpu", "sky", "nic", "mem", "mx", "clock", "ck", "prof", "cp", "linux", "cum", "pid", "cn", "thread", "ctx", "phys", "frame", "result", "process", "processor", "lan", "CPU", "alloc", "pu", "gb", "uu", "copy", "net", "ret", "gc", "jp", "proc", "hw"]}}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)\n\n{\n\n    PCIBus *bus = PCI_BUS(dev->bus);\n\n    PCIBus *iommu_bus = bus;\n\n\n\n    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {\n\n        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);\n\n    }\n\n    if (iommu_bus && iommu_bus->iommu_fn) {\n\n        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);\n\n    }\n\n    return &address_space_memory;\n\n}\n", "idx": 27256, "substitutes": {"dev": ["priv", "block", "device", "den", "ad", "Device", "out", "cam", "err", "ev", "d", "w", "def", "debug", "phy", "mem", "wd", "var", "md", "spec", "DEV", "ver", "ve", "det", "cmd", "disc", "develop", "vol", "buf", "go", "enc", "doc", "data", "test", "desc", "nt", "de", "des", "dem", "Dev", "val", "serv", "train", "der", "end", "v", "res"], "bus": ["block", "Bus", "board", "join", "length", "full", "hand", "gen", "byte", "bridge", "home", "boot", "box", "queue", " BUS", "os", "status", "host", "us", "bolt", "disk", "proxy", "buffer", "local", "object", "book", "func", "cast", "family", "build", "cache", "BUS", "state", "di", "root", "buf", "pos", "controller", "bug", "bs", "bill", "tag", "chain", "project", "used", "way", "b", "back", "vc", "test", "base", "handle", "mask", "driver", "loop", "lock", "proc", "mount", "socket"], "iommu_bus": ["iommu5bal", "iommnu_length", "iommu1chain", "iommu_proc", "iommeu_bridge", "iommu_cache", "iommuf_bus", "iommuaterbool", "iommu00bus", "iommu_bool", "iommeu_us", "iommuit___box", "iommuf_box", "iommnu_bus", "iommcu_bus", "iommo_dev", "iommu_Bus", "iommu___Bus", "iommeu_bus", "iommu_queue", "iommu_box", "iommu_dev", "iommu1cache", "iommtu_gen", "iommu_length", "iommupybook", "iommu___bus", "iommuit_us", "iommuf_bool", "iommu___proc", "iommu_book", "iommU_bus", "iommu___bs", "iommu5dev", "iommupybus", "iommau00config", "iommupyback", "iommau_back", "iommuf_db", "iommtu_Bus", "iommu_us", "iommU_box", "iommu_bs", "iommuit_bs", "iommupybox", "iommumychain", "iommuit___us", "iommu_db", "iommau_task", "iommumylength", "iommu_boot", "iommu_back", "iommuaterbus", "iommcu_proc", "iommo_back", "iommuaterdb", "iommuaterbox", "iommuit___bs", "iommau_bus", "iommcu_Bus", "iommnu_cache", "iommu___box", "iommu5box", "iommuit_box", "iommau00back", "iommu_task", "iommu_config", "iommu_bridge", "iommU_boot", "iommu1length", "iommu___us", "iommau_config", "iommo_book", "iommu00config", "iommo_bal", "iommtu_bus", "iommu00back", "iommeu_queue", "iommumycache", "iommuit___bus", "iommu_gen", "iommtu_box", "iommumybus", "iommo_box", "iommcu_box", "iommu_chain", "iommU_bridge", "iommu00task", "iommuit_bus", "iommau00task", "iommu1bus", "iommnu_chain", "iommo_bus", "iommau00bus", "iommu5bus", "iommu_bal"]}}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_fbo(TCGv dst, TCGv src,\n\n                                    unsigned int fcc_offset)\n\n{\n\n    gen_mov_reg_FCC0(dst, src, fcc_offset);\n\n    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);\n\n    tcg_gen_and_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n", "idx": 27257, "substitutes": {"dst": ["tnd", "depsrc", "idnd", " dtt", "dsrc", "lsrc", "dnd", "dht", "lst", " dsrc", "Dtt", " dST", " dnt", "idst", "mnd", "tst", " dcp", "idnt", "Dcp", "Dst", "depST", "Dsts", "didst", "mst", "sdst", "tnt", "adest", "adht", "dest", "dcp", "adst", " dsts", "idest", "dST", "Dsrc", "Ddest", "depest", "sdcp", "Dest", "didsrc", "depst", "didest", "lest", "test", "sdsts", "sdest", " dest", " dht", "DST", " dnd", "adnd", "mht", " ddest", "dtt", "mest", "ldest", "dsts", "didtt", "ddest", "dnt"], "src": ["sys", "sn", "cur", "sb", "inc", "rl", "syn", "op", "rs", "sub", "ur", "rc", "irst", "rx", "sel", "sync", "inst", "sr", "ack", "sc", "s", "img", "ser", "dest", "sec", "scan", "rt", "start", "loc", "addr", "sur", "st", "sing", "serv", "via", "source", "ptr", "tmp", "cc", "conv", "str", "init", "ssl"], "fcc_offset": ["fCC2offset", "fccmmoffset", "fcc_error", "fCC_info", "fcc_pad", "fccmmerror", "fCC_error", "fCC_start", "fcc_info", "fcc2no", "fCC_offset", "fCC_padding", "fCC_index", "fcc2index", "fccmmstart", "fcc_index", "fCC2no", "fcc_no", "fCC_no", "fccmminfo", "fccmmno", "fccmmindex", "fCC_pad", "fcc2offset", "fcc_start", "fcc_padding", "fCC2index"]}}
{"project": "FFmpeg", "commit_id": "607ad990d31e6be52980970e5ce8cd25ab3de812", "target": 0, "func": "static int dvbsub_decode(AVCodecContext *avctx,\n\n                         void *data, int *data_size,\n\n                         AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    DVBSubContext *ctx = avctx->priv_data;\n\n    AVSubtitle *sub = data;\n\n    const uint8_t *p, *p_end;\n\n    int segment_type;\n\n    int page_id;\n\n    int segment_length;\n\n    int i;\n\n\n\n    av_dlog(avctx, \"DVB sub packet:\\n\");\n\n\n\n    for (i=0; i < buf_size; i++) {\n\n        av_dlog(avctx, \"%02x \", buf[i]);\n\n        if (i % 16 == 15)\n\n            av_dlog(avctx, \"\\n\");\n\n    }\n\n\n\n    if (i % 16)\n\n        av_dlog(avctx, \"\\n\");\n\n\n\n    if (buf_size <= 6 || *buf != 0x0f) {\n\n        av_dlog(avctx, \"incomplete or broken packet\");\n\n        return -1;\n\n    }\n\n\n\n    p = buf;\n\n    p_end = buf + buf_size;\n\n\n\n    while (p_end - p >= 6 && *p == 0x0f) {\n\n        p += 1;\n\n        segment_type = *p++;\n\n        page_id = AV_RB16(p);\n\n        p += 2;\n\n        segment_length = AV_RB16(p);\n\n        p += 2;\n\n\n\n        if (p_end - p < segment_length) {\n\n            av_dlog(avctx, \"incomplete or broken packet\");\n\n            return -1;\n\n        }\n\n\n\n        if (page_id == ctx->composition_id || page_id == ctx->ancillary_id ||\n\n            ctx->composition_id == -1 || ctx->ancillary_id == -1) {\n\n            switch (segment_type) {\n\n            case DVBSUB_PAGE_SEGMENT:\n\n                dvbsub_parse_page_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_REGION_SEGMENT:\n\n                dvbsub_parse_region_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_CLUT_SEGMENT:\n\n                dvbsub_parse_clut_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_OBJECT_SEGMENT:\n\n                dvbsub_parse_object_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_DISPLAYDEFINITION_SEGMENT:\n\n                dvbsub_parse_display_definition_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_DISPLAY_SEGMENT:\n\n                *data_size = dvbsub_display_end_segment(avctx, p, segment_length, sub);\n\n                break;\n\n            default:\n\n                av_dlog(avctx, \"Subtitling segment type 0x%x, page id %d, length %d\\n\",\n\n                        segment_type, page_id, segment_length);\n\n                break;\n\n            }\n\n        }\n\n\n\n        p += segment_length;\n\n    }\n\n\n\n    return p - buf;\n\n}\n", "idx": 27261, "substitutes": {"avctx": ["afctl", "avtmp", " avctl", "averctx", " avreq", "ajreq", "wavfc", "avetmp", "vrcontext", "avercp", "ajcli", "vrctx", "verctx", "ravctl", "averctl", "avectl", "ajcu", "avcfg", "avpkg", "ravcli", "ajconn", "averpkg", "avcmp", "ravdyl", "afcfg", "abtmp", "avecmd", "ajtx", "ajtmp", "wavctl", "vertx", "abcp", "avcu", " avcli", "verctl", "vercontext", "AVctl", " avcmd", " avjac", "avecu", " avpkg", "averconn", " avcontext", "avercmp", "avfc", "avecontext", "ajcmp", "ajctx", "afcmd", "avecmp", "ravcu", "vrctl", "abctl", "AVctx", "avectx", "afctx", "averfc", "abtx", "avtx", "avreq", "abctx", "wavcmd", "avcmd", "avecfg", " avdyl", "avecp", "avereq", "avetx", "ajcp", "aveconn", "avepkg", "avcontext", "averreq", "abcontext", "ravcontext", "averjac", " avcmp", "avedyl", " avcu", "avcp", "avctl", "ravctx", "avercfg", "ajjac", "avejp", "ajctl", "wavctx", "avjac", "avercmd", "ajjp", "avertx", "wavcp", "avcli", "avconn", "avjp", "avdyl", " avtx", "AVcontext", "AVtx", "abpkg", "ajpkg", " avjp", "wavpkg", "avefc", "vrtx"], "data": ["f", "block", "padding", "type", "join", "batch", "length", "tx", "obj", "ata", "d", "pad", "def", "map", "value", "id", "buffer", "dev", "empty", "resp", "rel", "feed", "bytes", "area", "input", "pos", "form", "message", "image", "Data", "raw", "a", "ns", "size", "info", "dat", "text", "window", "txt", "bin", "aux", "package", "DATA", "offset", "table", "t", "content", "tmp", "m", "v", "format", "pat", "name", "mu", "res"], "data_size": ["buffer_length", "buffer_len", "data_len", "data_length", "buffer_Size", "data_Size", "buffer_size"], "avpkt": ["avcpett", "avcppt", "avspkg", "avcpkt", "avppkt", "avcpck", "avpbkt", "avcpkg", "avnppt", "avppt", "avpck", "avjpacket", "afpett", "avpbj", "avenpacket", "avjpett", "AVpkg", "afpkt", "AVpacket", "avcpj", "AVcpkg", "avepacket", "avppck", "avpj", "AVcpacket", "avenpkt", "avpett", "afpacket", "avenppt", "AVpkt", "avpacket", "avnacket", "avppkg", "afcpkt", "avnpkt", "afcpacket", "avsppt", "avppacket", "avnkg", "AVcpkt", "afcpj", "avcpacket", "avnpkg", "avjpj", "avnck", "afpj", "avpkg", "avjpkt", "avnkt", "avnpacket", "AVpck", "avspacket", "afcpett", "avenpkg", "avspkt", "AVcpck", "avpbett", "avepkg", "avpbacket", "aveppt", "avepkt"], "buf": ["prop", "cur", "batch", "pack", "pb", "err", "conv", "ref", "queue", "uf", "bl", "br", "box", "ff", "bc", "len", "pad", "begin", "rc", "read", "buffer", "mem", "late", "cmd", "pool", "cp", "Buff", "arr", "img", "pg", "new", "msg", "cb", "bytes", "pos", "paste", "vec", "np", "raw", "doc", "b", "fun", "port", "dat", "wb", "loc", "txt", "window", "lim", "bin", "rb", "bp", "cap", "Buffer", "buff", "pkg", "tr", "xff", "end", "tmp", "ptr", "max", "v", "str", "aw", "cv"], "ctx": ["sys", "hw", "context", "cmp", "tm", "tx", "cf", "obj", "cu", "Context", "conn", "comm", "bc", "pc", "config", "tc", "kt", "dc", "crit", "mem", "act", "ctrl", "cmd", "ctl", "cp", "fn", "resp", "util", "cb", "cm", "np", "setup", "co", "cfg", "rt", "req", "ct", "xc", "nt", "unc", "ac", "loc", "cas", "txt", "fc", "kw", "xp", "etc", "fp", "pkg", "tmp", "cc", "jp", "conv", "wx", "cv", "this", "conf"], "sub": ["ch", "uc", "cmp", "pb", "tx", "part", " subs", "sam", "unk", "sl", "seq", "sup", "Sub", "sel", "ext", "rec", "sc", "tab", "rel", "msg", "set", "mod", "desc", "ub", "aux", "tmp", "su"], "p": ["f", "ping", "it", "pre", "x", "perm", "pb", "point", "op", "pc", "d", "pad", "vp", "part", "w", "pp", "c", "pi", "after", "at", "ptr", "pr", "g", "pool", "cp", "pid", "par", "j", "pe", "ap", "pos", "pl", "np", "up", "per", "a", "b", "l", "php", "dp", "ps", "ip", "page", "post", "pa", "wp", "port", "progress", "pro", "sp", "tp", "bp", "pod", "u", "fp", "pkg", "lp", "P", "jp", "t", "q", "m", "v", "h", "pat", "pt"], "p_end": ["p___start", "pMemfin", "ptMemmin", "p_begin", "p_off", "pwstart", "dp___end", "pt_ended", "ptMemended", "p_final", "dp_final", "p_start", "dp___final", "p_size", "p___off", "ptMemend", "pwfinal", "pt_min", "ptMemfin", "page_size", "p_min", "p_ended", "dp___off", "dp___start", "pMemended", "page_end", "pwend", "page_ends", "p_fin", "page_begin", "p___fin", "dp_off", "ap_start", "p___end", "dp_start", "ap_ended", "p___final", "dp_end", "pMemend", "p_ends", "pMemmin", "ap_end", "pt_end", "pwoff", "pt_fin", "p___ended", "p___min"], "segment_type": ["seportion_type", "segmentityid", "seportion_format", "segmentnessTYPE", "segementitylength", "seportion___format", "segementityTYPE", "segment_Type", "segment_format", "segmentationlength", "sement_id", "sement_types", "segmentitytypes", "seportion___type", "segmentnesscolor", "segement_TYPE", "seportion___id", "segment___format", "segment___id", "segment___Type", "segmentationtypes", "sement_type", "segment_types", "segment_id", "segmentityTYPE", "segment_TYPE", "seportion___Type", "segement_type", "segmentitylength", "segmentationtype", "sement_length", "segementitycolor", "segment___type", "seportion_Type", "segement_length", "segmentitytype", "seportion_id", "segment_color", "segement_color", "segmentationid", "segementitytype", "segmentnesslength", "segmentitycolor", "segmentnesstype"], "page_id": ["page____id", "page_class", "point___type", "pageityid", "page____iden", "pageacid", "pageactime", "pagevisionid", "page_pid", "page___start", "page___type", "pagevisionclass", "pagevisionstart", "page_mid", "point_class", "page___pid", " page_pid", " page_mid", " page_time", "point_start", "point_id", "pagevisiontype", "pageitypid", "point___class", "page_time", " page_ID", "point_type", "page___mid", "point___start", "pageityID", "page___class", " page_type", "page_ID", "page_no", "page_iden", "pageaciden", "page_start", "point___id", "pageitymid", "page___ID", "page_type", "pageactype", "page____time", "page____type", " page_iden", "page___id", " page_no"], "segment_length": ["segmentationlen", "seportion_type", "sement_height", "sement_duration", "segmentityname", "segmentationsize", "segmentitylength", "segment_count", "segment_len", "segmentityend", "sement_size", "segement_Length", "segmentationcount", "segment_duration", "sement_name", "seportionitytype", "segment_height", "sement_long", "segmentityheight", "segment2length", "segmentityduration", "segement2type", "segmentationlength", "segment_Length", "seportion_length", "segmentallength", "segmentalsize", "seportion_size", "segment2type", "segmentitylong", "segment2Length", "segment2len", "segement_len", "seportion_end", "segement2Length", "segement2len", "segment_size", "seportionitysize", "sement_length", "segmentitysize", "segement2length", "seportionityend", "sement_len", "segment_end", "sement_count", "segment_long", "sement_type", "seportionitylength", "segement_type", "segement_length", "segmentitytype", "segmentalheight", "segment_name", "segmentallong"], "i": ["ji", "it", "ic", "ms", "x", "ui", "ki", "multi", "o", "\u0438", "slice", "status", "ami", "pi", "c", " ii", "ini", "ex", "ri", "g", "in", "me", "gi", "I", "n", "phi", "oi", "di", "zi", "sim", "j", "ai", "span", "mi", "li", "ii", "chain", "hi", "is", "ti", "ind", "l", "info", "ip", "ims", "y", "bi", "ci", "z", "iu", "xi", "si", "im", "index", "cli", "m", "qi", "ei", "ix"]}}
{"project": "qemu", "commit_id": "04088adbe0c5adca66adb6022723362ad90ed0fc", "target": 0, "func": "static void *mpc8544_load_device_tree(target_phys_addr_t addr,\n\n                                     uint32_t ramsize,\n\n                                     target_phys_addr_t initrd_base,\n\n                                     target_phys_addr_t initrd_size,\n\n                                     const char *kernel_cmdline)\n\n{\n\n    void *fdt = NULL;\n\n#ifdef CONFIG_FDT\n\n    uint32_t mem_reg_property[] = {0, ramsize};\n\n    char *filename;\n\n    int fdt_size;\n\n    int ret;\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, BINARY_DEVICE_TREE_FILE);\n\n    if (!filename) {\n\n        goto out;\n\n    }\n\n    fdt = load_device_tree(filename, &fdt_size);\n\n    qemu_free(filename);\n\n    if (fdt == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    /* Manipulate device tree in memory. */\n\n    ret = qemu_devtree_setprop(fdt, \"/memory\", \"reg\", mem_reg_property,\n\n                               sizeof(mem_reg_property));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /memory/reg\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-start\",\n\n                                    initrd_base);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-start\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-end\",\n\n                                    (initrd_base + initrd_size));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-end\\n\");\n\n\n\n    ret = qemu_devtree_setprop_string(fdt, \"/chosen\", \"bootargs\",\n\n                                      kernel_cmdline);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n\n\n    if (kvm_enabled()) {\n\n        struct dirent *dirp;\n\n        DIR *dp;\n\n        char buf[128];\n\n\n\n        if ((dp = opendir(\"/proc/device-tree/cpus/\")) == NULL) {\n\n            printf(\"Can't open directory /proc/device-tree/cpus/\\n\");\n\n            goto out;\n\n        }\n\n\n\n        buf[0] = '\\0';\n\n        while ((dirp = readdir(dp)) != NULL) {\n\n            if (strncmp(dirp->d_name, \"PowerPC\", 7) == 0) {\n\n                snprintf(buf, 128, \"/cpus/%s\", dirp->d_name);\n\n                break;\n\n            }\n\n        }\n\n        closedir(dp);\n\n        if (buf[0] == '\\0') {\n\n            printf(\"Unknow host!\\n\");\n\n            goto out;\n\n        }\n\n\n\n        mpc8544_copy_soc_cell(fdt, buf, \"clock-frequency\");\n\n        mpc8544_copy_soc_cell(fdt, buf, \"timebase-frequency\");\n\n    }\n\n\n\n    cpu_physical_memory_write (addr, (void *)fdt, fdt_size);\n\n\n\nout:\n\n#endif\n\n\n\n    return fdt;\n\n}\n", "idx": 27266, "substitutes": {"addr": ["type", "dir", "adr", "address", "ref", "hash", "store", "conn", "mb", "host", "dh", "map", "id", "sha", "var", "db", "state", "add", "coord", "eth", "attr", "dr", "url", "Address", "handle", "ptr", "name"], "ramsize": ["gramspace", " ramspace", "ramSIZE", "RAMize", "gramsize", "gramSIZE", "ramspace", "memSize", " ramize", " ramSize", "ramcount", " ramSIZE", "RAMcount", "ramSize", "gramcount", "memspace", "memsize", " ramcount", "gramize", "ramize", "gramSize", "RAMSIZE", "RAMsize"], "initrd_base": ["initrd_bas", "initrd__count", "initaddr_base", "initrd_count", "initrend2size", "initrd2base", "initrend2name", "initrd2start", "initrend_name", "initrd__bas", "initrd__Base", "initrend_start", "initrd2name", "initrd__size", "initrend2base", "initrd_based", "initrd__based", "initrd_offset", "initaddr_bas", "initrend2start", "initrb_count", "initrend_size", "initrd__base", "initaddr_based", "initrd__offset", "initrb_base", "initrd2size", "initrd_start", "initrb_size", "initrb_offset", "initrd_name", "initrend_base", "initaddr_Base", "initrd_Base"], "initrd_size": ["initrd2base", "initrd_SIZE", "initrd67width", "initrt_name", "initrt_string", "initrb_width", "initrd67size", "initrd67base", "initrd2name", "initrt_SIZE", "initrd_string", "initrd67name", "initrb_name", "initrt_size", "initrd2width", "initrd_width", "initrb_base", "initrd2size", "initrb_size", "initrd_name"], "kernel_cmdline": ["kernel_mdline", "kernel_Cmdstring", "kernel_cmdeline", "kernel_commandline", "kernel_callline", "kernel_callLine", "kernel_mdLine", "kernel_cmdstring", "kernel_cmdLine", "kernel_Cmdline", "kernel_commandLine", "kernel_mdstring", "kernel_CmdLine", "kernel_commandstring", "kernel_Cmdeline", "kernel_calleline", "kernel_commandeline"], "fdt": ["fdte", "ddz", "fmt", "dftr", "tdwt", "dlz", "pdt", "bdt", "fdT", "aftwt", "dft", "dlT", "ddn", "tdo", "dfwt", "fint", "td2", "dbwt", "dlts", "ffts", "aftty", "fdn", "bdv", "dfv", "dlc", "fdtm", "fmte", "fdts", "finT", "fdwt", "aftt", "ftT", "dbo", "bdts", "dbt", "tdtr", "ftte", "fdc", "fmb", "fmT", "dfp", "fdo", "fft", "fdv", "ffwt", "aftT", "dlv", "dfT", "dfz", "bdT", "ftb", "ffp", "dlt", "dln", "formT", "dfc", "ftt", "formty", "dbtr", "fd2", "pdtm", "fdb", "ff2", "fftm", "dfts", "tdts", "fdty", "ddt", "finte", "dfn", "pdp", "fdtr", "df2", "formt", "fdz", "ffT", "tdt", "fdp", "finb", "ffty", "pdts", "tdT", "dfo", "formwt", "ddc", "dftm"], "mem_reg_property": ["mem_mem_attribute", "mem_reg_prop", "mem_mem_style", "mem_reg_address", "mem_mem_address", "mem_mem_prop", "mem_mem_property", "mem_reg_style", "mem_reg_attribute", "mem_reg_properties", "mem_mem_properties"], "filename": ["f", "there", "length", "lua", "knife", "latest", "nm", "fle", "ln", "journal", "Filename", "river", "sbm", "nl", "buffer", "SourceFile", "jpg", "til", "path", "ren", "FN", "family", "SOURCE", "ames", "n", "fn", "FH", "existent", "prefix", "kj", "folder", "origin", "gettable", "sql", "rir", "nil", "file", "present", "location", "ename", "username", "png", "src", "aka", "fil", "txt", "files", "directory", "ame", "json", "fd", "fp", "source", "kl", "tmp", "rn", "println", "jl", "name", "FIL"], "fdt_size": ["fdr2Size", "fdt_name", "fdt2Size", "fdT_len", "fdt_count", "fdr_name", "fdt2count", "fdt2name", "fdT_count", "fdT_size", "fdr2size", "fdr_size", "fdt2size", "fdr2name", "fdT_Size", "fdt_len", "fdr_Size", "fdr2count", "fdt_Size", "fdr_count", "fdt2len"], "ret": ["alf", "alt", "bool", "out", "err", "reset", "ll", "RET", "rm", "re", "obj", "len", "success", "try", "pas", "hash", "att", "tif", "gt", "def", "sat", "result", "rev", "cont", "mem", "del", "tn", "get", "ext", "mel", "det", "ben", "n", "backed", "arr", "cert", "compl", "resp", "rect", "usr", "rem", "j", "nz", "nil", "print", "ert", "rt", "back", "desc", "nt", "fun", "expr", "rets", " RET", "ft", " Ret", "val", "flag", "mt", "net", "Ret", "il", "tr", "iter", "t", "elt", "final", "arg", "Return", "res"], "dirp": ["dirt", "drawn", "drawjp", "drawnp", "threadp", "drawp", "threadpt", "dirsp", "DIRt", "_", "def", "Dirpt", "dialjp", "cont", "ds", "threadd", "dirpt", " dird", "dirjp", "Dird", "func", "Dirt", "ctl", "DIRd", "dialp", "Dirsp", "dialn", "dirnp", "DE", "dialnp", "dird", "dnp", "drt", "dn", "bd", "drp", "exec", "drd", "ptr", "fp", "DIRsp", " dirpt", "DIRp", "drsp", "dirn", "djp", "Dirp"], "dp": ["pd", " gp", " d", "pb", "dir", "pas", "dq", "pipe", "d", "dh", "vp", "dj", "cd", "dc", "ds", "wd", "cp", "p", "dt", "dm", "df", "np", "DP", "dl", "dr", "dd", "pa", "wp", "dn", "tp", "deb", "bp", "fp", "ptr", "lp", "pkg", "jp", "dep", "DC"], "buf": ["block", "pack", "batch", "cur", "pb", "err", "obj", "queue", "uf", "br", "font", "result", "buffer", "seq", "var", "row", "cat", "db", "pool", "cp", "Buff", "p", "img", "msg", "cb", "bytes", "bar", "vec", "raw", "b", "data", "desc", "wb", "text", "window", "alloc", "bd", " buffer", "rb", "rw", "cap", "Buffer", "buff", "pkg", "tmp", "loop", "str", "alph", "cv"]}}
{"project": "FFmpeg", "commit_id": "3a25c707fae3c6e99fdda40474c3d74be24cc4c3", "target": 0, "func": "static int mov_read_trak(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    int ret;\n\n\n\n    st = av_new_stream(c->fc, c->fc->nb_streams);\n\n    if (!st) return AVERROR(ENOMEM);\n\n    sc = av_mallocz(sizeof(MOVStreamContext));\n\n    if (!sc) return AVERROR(ENOMEM);\n\n\n\n    st->priv_data = sc;\n\n    st->codec->codec_type = CODEC_TYPE_DATA;\n\n    st->start_time = 0; /* XXX: check */\n\n\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n\n        return ret;\n\n\n\n    /* sanity checks */\n\n    if(sc->chunk_count && (!sc->stts_count || !sc->sample_to_chunk_sz ||\n\n                           (!sc->sample_size && !sc->sample_count))){\n\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n\n               st->index);\n\n        sc->sample_count = 0; //ignore track\n\n        return 0;\n\n    }\n\n    if(!sc->time_rate)\n\n        sc->time_rate=1;\n\n    if(!sc->time_scale)\n\n        sc->time_scale= c->time_scale;\n\n    av_set_pts_info(st, 64, sc->time_rate, sc->time_scale);\n\n\n\n    if (st->codec->codec_type == CODEC_TYPE_AUDIO &&\n\n        !st->codec->frame_size && sc->stts_count == 1)\n\n        st->codec->frame_size = av_rescale(sc->time_rate, st->codec->sample_rate, sc->time_scale);\n\n\n\n    if(st->duration != AV_NOPTS_VALUE){\n\n        assert(st->duration % sc->time_rate == 0);\n\n        st->duration /= sc->time_rate;\n\n    }\n\n    sc->ffindex = st->index;\n\n    mov_build_index(c, st);\n\n\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n\n        if (url_fopen(&sc->pb, sc->drefs[sc->dref_id-1].path, URL_RDONLY) < 0)\n\n            av_log(c->fc, AV_LOG_ERROR, \"stream %d, error opening file %s: %s\\n\",\n\n                   st->index, sc->drefs[sc->dref_id-1].path, strerror(errno));\n\n    } else\n\n        sc->pb = c->fc->pb;\n\n\n\n    switch (st->codec->codec_id) {\n\n#ifdef CONFIG_H261_DECODER\n\n    case CODEC_ID_H261:\n\n#endif\n\n#ifdef CONFIG_H263_DECODER\n\n    case CODEC_ID_H263:\n\n#endif\n\n#ifdef CONFIG_MPEG4_DECODER\n\n    case CODEC_ID_MPEG4:\n\n#endif\n\n        st->codec->width= 0; /* let decoder init width/height */\n\n        st->codec->height= 0;\n\n        break;\n\n#ifdef CONFIG_VORBIS_DECODER\n\n    case CODEC_ID_VORBIS:\n\n#endif\n\n        st->codec->sample_rate= 0; /* let decoder init parameters properly */\n\n        break;\n\n    }\n\n\n\n    /* Do not need those anymore. */\n\n    av_freep(&sc->chunk_offsets);\n\n    av_freep(&sc->sample_to_chunk);\n\n    av_freep(&sc->sample_sizes);\n\n    av_freep(&sc->keyframes);\n\n    av_freep(&sc->stts_data);\n\n\n\n    return 0;\n\n}\n", "idx": 27272, "substitutes": {"c": ["f", "uc", "cur", "cf", "cam", "ce", "cu", "pc", "bc", "cor", "config", "rc", "tc", "abc", "dc", "cont", "icc", "ec", "g", "cp", "p", "cache", "nc", "cs", "cb", "call", "can", "ctx", "enc", "co", "chain", "b", "l", "ct", "xc", "oc", "ac", "anc", "vc", "cr", "ci", "mc", "con", "fc", "e", "etc", "gc", "t", "cc", "C", "v", "lc", "m", "cv", "this", "conf"], "pb": ["bb", "fb", "sb", "client", "uf", "bps", "pc", "bc", "mp", "vp", "tk", "nb", "pp", "tc", "dc", "ec", "func", "cp", "p", "pg", "ob", "cb", "cm", "buf", "ctx", "PB", "phys", "pl", "np", "amp", "eb", "b", "wb", "pa", "wp", "ub", "px", "bh", "pro", "gb", "tp", "bp", "sp", "rb", "fc", "fp", "pkg", "lp", "ab", "jp", "proc", "lb", "cv", "conf"], "atom": ["tar", "prop", "orm", "other", "typ", "tm", "ata", "item", " om", "term", "op", "from", "xml", "config", "tc", "atomic", "at", "ext", " com", "tem", "p", "mat", "msg", "ym", " tem", "ap", " term", "com", "raw", " exc", "tg", "comp", "attr", "ag", "om", "oms", " plat", "chem", "tom", "t", "tmp", "m", "ot", "name"], "st": ["ost", "nd", "sta", "std", "storage", "cont", "tt", "inst", "ust", "et", "sec", "rt", "ct", " est", "src", "loc", "stable", "step", "mt", "pt", "sn", "rest", "obj", "store", "first", "at", "sl", "St", "ut", "stage", "th", "so", "desc", "ts", "ST", "sth", "net", "ist", "cl", "kt", "stra", "sts", "sw", "art", "ast", "td", "put", "test", "must", "pres", "est", "stat", "tmp", "elt", "str", "it", "se", "ste", "irst", "sh", "usr", "set", "dist", "stan", "stop", "start", "nt", "ft", "sp", "sv", "t"], "sc": ["uc", "cmp", "cer", "cu", "ca", "cle", "tc", "asc", "dc", "cont", "sync", "ctl", "soc", "ser", "sche", "isc", "ctx", "sec", "ct", "scale", "src", "ci", "fc", "scope", "gc", "sq", "ch", "bc", "pc", "usc", "squ", "scl", "ec", "ctrl", "spec", "cs", "enc", "co", "desc", "anc", " subsc", "mc", "cgi", "SC", "cl", "esc", "cam", "sic", "mp", "icc", "sch", "Sc", "nc", "disc", "sw", "cons", "sci", "must", "cr", "cas", "cc", "lc", "cv", "psc", "capt", "ok", "ka", "rc", "zero", "mic", "scrib", "tch", "sh", "sac", "decl", "osc", "ss", "acc", "sp", "sv", "proc"], "ret": ["it", "inter", "alt", "ter", "out", "red", "not", "reset", "ll", "RET", "ref", "re", "len", "status", "try", "bit", "tf", "gt", "def", " fut", "ber", "value", "result", "rev", "at", "reg", "mem", "ral", "r", "det", "resp", "rem", "print", "fit", "rt", "back", "nt", "rets", "virtual", "ft", " Ret", "val", "net", "mt", "Ret", " alt", "t", "elt", "v", "res"]}}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int libschroedinger_encode_init(AVCodecContext *avctx)\n\n{\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n    SchroVideoFormatEnum preset;\n\n\n\n    /* Initialize the libraries that libschroedinger depends on. */\n\n    schro_init();\n\n\n\n    /* Create an encoder object. */\n\n    p_schro_params->encoder = schro_encoder_new();\n\n\n\n    if (!p_schro_params->encoder) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unrecoverable Error: schro_encoder_new failed. \");\n\n        return -1;\n\n    }\n\n\n\n    /* Initialize the format. */\n\n    preset = ff_get_schro_video_format_preset(avctx);\n\n    p_schro_params->format =\n\n                    schro_encoder_get_video_format(p_schro_params->encoder);\n\n    schro_video_format_set_std_video_format(p_schro_params->format, preset);\n\n    p_schro_params->format->width  = avctx->width;\n\n    p_schro_params->format->height = avctx->height;\n\n\n\n    if (set_chroma_format(avctx) == -1)\n\n        return -1;\n\n\n\n    if (avctx->color_primaries == AVCOL_PRI_BT709) {\n\n        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_HDTV;\n\n    } else if (avctx->color_primaries == AVCOL_PRI_BT470BG) {\n\n        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_SDTV_625;\n\n    } else if (avctx->color_primaries == AVCOL_PRI_SMPTE170M) {\n\n        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_SDTV_525;\n\n    }\n\n\n\n    if (avctx->colorspace == AVCOL_SPC_BT709) {\n\n        p_schro_params->format->colour_matrix = SCHRO_COLOUR_MATRIX_HDTV;\n\n    } else if (avctx->colorspace == AVCOL_SPC_BT470BG) {\n\n        p_schro_params->format->colour_matrix = SCHRO_COLOUR_MATRIX_SDTV;\n\n    }\n\n\n\n    if (avctx->color_trc == AVCOL_TRC_BT709) {\n\n        p_schro_params->format->transfer_function = SCHRO_TRANSFER_CHAR_TV_GAMMA;\n\n    }\n\n\n\n    if (ff_get_schro_frame_format(p_schro_params->format->chroma_format,\n\n                                  &p_schro_params->frame_format) == -1) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"This codec currently supports only planar YUV 4:2:0, 4:2:2\"\n\n               \" and 4:4:4 formats.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    p_schro_params->format->frame_rate_numerator   = avctx->time_base.den;\n\n    p_schro_params->format->frame_rate_denominator = avctx->time_base.num;\n\n\n\n    p_schro_params->frame_size = avpicture_get_size(avctx->pix_fmt,\n\n                                                    avctx->width,\n\n                                                    avctx->height);\n\n\n\n    avctx->coded_frame = av_frame_alloc();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (!avctx->gop_size) {\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"gop_structure\",\n\n                                         SCHRO_ENCODER_GOP_INTRA_ONLY);\n\n\n\n        if (avctx->coder_type == FF_CODER_TYPE_VLC)\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"enable_noarith\", 1);\n\n    } else {\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"au_distance\", avctx->gop_size);\n\n        avctx->has_b_frames = 1;\n\n        p_schro_params->dts = -1;\n\n    }\n\n\n\n    /* FIXME - Need to handle SCHRO_ENCODER_RATE_CONTROL_LOW_DELAY. */\n\n    if (avctx->flags & CODEC_FLAG_QSCALE) {\n\n        if (!avctx->global_quality) {\n\n            /* lossless coding */\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"rate_control\",\n\n                                             SCHRO_ENCODER_RATE_CONTROL_LOSSLESS);\n\n        } else {\n\n            int quality;\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"rate_control\",\n\n                                             SCHRO_ENCODER_RATE_CONTROL_CONSTANT_QUALITY);\n\n\n\n            quality = avctx->global_quality / FF_QP2LAMBDA;\n\n            if (quality > 10)\n\n                quality = 10;\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"quality\", quality);\n\n        }\n\n    } else {\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"rate_control\",\n\n                                         SCHRO_ENCODER_RATE_CONTROL_CONSTANT_BITRATE);\n\n\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"bitrate\", avctx->bit_rate);\n\n    }\n\n\n\n    if (avctx->flags & CODEC_FLAG_INTERLACED_ME)\n\n        /* All material can be coded as interlaced or progressive\n\n           irrespective of the type of source material. */\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"interlaced_coding\", 1);\n\n\n\n    schro_encoder_setting_set_double(p_schro_params->encoder, \"open_gop\",\n\n                                     !(avctx->flags & CODEC_FLAG_CLOSED_GOP));\n\n\n\n    /* FIXME: Signal range hardcoded to 8-bit data until both libschroedinger\n\n     * and libdirac support other bit-depth data. */\n\n    schro_video_format_set_std_signal_range(p_schro_params->format,\n\n                                            SCHRO_SIGNAL_RANGE_8BIT_VIDEO);\n\n\n\n    /* Set the encoder format. */\n\n    schro_encoder_set_video_format(p_schro_params->encoder,\n\n                                   p_schro_params->format);\n\n\n\n    /* Set the debug level. */\n\n    schro_debug_set_level(avctx->debug);\n\n\n\n    schro_encoder_start(p_schro_params->encoder);\n\n\n\n    /* Initialize the encoded frame queue. */\n\n    ff_schro_queue_init(&p_schro_params->enc_frame_queue);\n\n    return 0;\n\n}\n", "idx": 27296, "substitutes": {"avctx": ["varvoc", "avstat", "avtmp", "uvcontext", "averctx", " avstat", "wavtx", "avesys", "vrtmp", "navkt", " avca", "vercfg", "avetmp", "vrcontext", "avercp", "ajcontext", "vrctx", "verctx", "navkj", "wavsys", "avcfg", "navqt", "avpkg", "averpkg", "wavconn", "aveca", "wavcontext", "avca", "avercf", "avecci", " avkj", "avcf", "avecmd", " avsrc", "navmsg", "avercontext", "wavcfg", "navkl", "avsrc", "navcontext", "vercontext", " avcci", " avcmd", " avContext", "avvoc", "navvoc", "avsys", "wavkt", "avekt", "uvContext", "avkj", "averconn", " avcontext", "avercci", "avecf", "avecontext", "navtmp", "avekj", "avenp", "ajctx", "avxc", "navconfig", "avemsg", "varconfig", "navnp", "avekl", "avqt", "AVctx", "avectx", "avkt", "avervoc", "avmsg", "avtx", "uvctx", "varqt", "navctx", " avcfg", "varctx", "avcmd", "avecfg", "averca", "averqt", "avecp", "avetx", "avnp", " avtmp", "aveconn", "avepkg", "avcontext", "avContext", "avkl", "avcci", "aversrc", "avestat", "avcp", "ajContext", "AVxc", " avcp", "avercfg", "wavctx", "wavnp", "aversys", "avercmd", "ajjp", "avertx", "wavcp", "wavkl", "avconn", "avjp", "averstat", " avxc", " avtx", "AVcontext", "averxc", "avernp", "AVtx", "navcfg", "averconfig", "avconfig", " avjp", "avermsg", "wavpkg", "navcf", "versrc", "vrtx", "uvjp"], "p_schro_params": ["p_schrob_ams", "p_schlo_pps", "p_schroingtypes", "p_schro_las", "p_schro_pps", "p_schros_args", "p_schro_names", "p_schro_param", "p_schroessservices", "p_schro_members", "p_schro2data", "p_schrob_plugins", "p_schlo_names", "p_schro2ams", "p_schroaphmembers", "p_schro_plugins", "p_schled_las", "p_schlo_spec", "p_schro_args", "p_schro_caps", "p_schrotparams", "p_schroingparams", "p_schroingpps", "p_schrotnames", "p_schro_resources", "p_schled_services", "p_schro_files", "p_schroingams", "p_schrob_names", "p_schro2params", "p_schlo_marks", "p_schroaphparams", "p_schrob_settings", "p_schrowmarks", "p_schro_types", "p_schro__params", "p_schlo_ports", "p_schro_points", "p_schro_settings", "p_schlo_members", "p_schro_spec", "p_schrowspec", "p_schrecingtypes", "p_schrob_marks", "p_schlo_settings", "p_schros_params", "p_schrob_params", "p_schlo_params", "p_schro_ams", "p_schros_points", "p_schrojparams", "p_schroityams", "p_schrotplugins", "p_schrogresources", "p_schrob_param", "p_schro_marks", "p_schrogtypes", "p_schroesscaps", "p_schlo_files", "p_schro__ams", "p_schrecingparams", "p_schro_manager", "p_schro_ports", "p_schroessparams", "p_schled_params", "p_schroityparams", "p_schrotmarks", "p_schro_data", "p_schlo_ams", "p_schro_services", "p_schrecingresources", "p_schros_manager", "p_schrowparams", "p_schroesslas", "p_schrec_resources", "p_schled_caps", "p_schro2args", "p_schrojmanager", "p_schrec_types", "p_schros_ams", "p_schroaphfiles", "p_schrogparams", "p_schrec_params", "p_schrojams", "p_schro2points", "p_schroitypoints", "p_schro__param", "p_schlo_args", "p_schroityargs", "p_schro__settings", "p_schros_data", "p_schroingresources"], "preset": [" presset", " prespect", "presentetter", "prespect", "reset", "PresET", "presET", " presET", "resetter", "Presset", "Presetter", "Prespect", "Presence", "respect", "resence", "presentET", "presence", "resset", "PRESet", "presentet", "PRESetter", "PRESset", "resET", "presentence", "Preset", "presetter", "presset", "PRESET"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,\n\n                                            target_phys_addr_t base,\n\n                                            qemu_irq txirq, qemu_irq rxirq,\n\n                                            qemu_irq *dma, omap_clk clk)\n\n{\n\n    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)\n\n            g_malloc0(sizeof(struct omap_mcbsp_s));\n\n\n\n    s->txirq = txirq;\n\n    s->rxirq = rxirq;\n\n    s->txdrq = dma[0];\n\n    s->rxdrq = dma[1];\n\n    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);\n\n    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);\n\n    omap_mcbsp_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, \"omap-mcbsp\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 27311, "substitutes": {"system_memory": ["system2media", " system2mem", "system2memory", "system2storage", "system_media", "system2mem", "system_storage", " system2storage", " system2memory", "system_mem", " system_media", " system_mem", " system_storage", " system2media"], "base": ["f", "ases", "sys", "space", "i", "as", "x", "bas", "server", "null", "address", " Base", "ma", "re", "bound", "mb", "os", "Base", "binding", "id", "bf", "cpu", "zero", "buffer", "p", " bases", "memory", "root", "bal", "area", "bs", "b", "eta", "data", "size", "stable", "ase", "bp", "based", "domain", "h", "m", "name"], "txirq": ["rxrinqu", "txdrch", "txmirquire", "txmirque", "txmirqi", "rxirch", "txirqi", "txvirch", "txiroq", "txpirq", "txrinch", "txirque", "hexirquire", "hexirquest", "xirq", "hexirqi", "txpirque", "txvirqu", "xirch", "txiroquest", "hexiterqi", "hexiterquire", "txiroquire", "txpirch", "txmirch", "hexirq", "rxirQ", "txvirQ", "txirch", "txirqu", "txdrq", "txiterq", "xmirq", "txrinq", "txpirQ", "rxrinQ", "txiterquest", "txmirq", "txiterqi", "txirquire", "txirQ", "xirp", "txiterquire", "txiroqi", "txpirqu", "rxrinq", "rxirqu", "hexiterquest", "txirp", "txdrp", "xmirque", "txrinqu", "rxrinch", "txvirq", "txirquest", "txmirquest", "xmirp", "hexiterq", "txmirp", "txrinQ", "xmirch", "txdrque", "txpirp", "xirque"], "rxirq": ["lexpirq", "lexirqu", "rxpirql", "lexpirch", "rxirch", "rxdrq", "rxiorqi", "fxpirql", "fxpirp", "rxpirquest", "rxiterch", "rxiorq", "rxiraq", "rxiorreq", "rxibrqq", "uxirqi", "fxirq", "uxiorqi", "rxirach", "rxirreq", "rxerquest", "rxkarqi", "rxdrp", "rxirql", "lexirch", "rxiterp", "uxirq", "rxkarq", "rxiterq", "lexirq", "rxibrqi", "lexpirquest", "rxerqu", "rxiorqq", "rxpirqu", "uxiorqq", "rxkarreq", "fxirch", "fxpirq", "rxibrreq", "fxpirch", "uxirreq", "rxiraqu", "lexpirqu", "rxerq", "rxirp", "lexirquest", "rxiterql", "rxirqu", "rxibrq", "rxdrch", "rxirqi", "fxirp", "rxiraquest", "rxkarqq", "rxpirq", "uxiorq", "uxiorreq", "rxpirp", "fxirql", "rxerch", "rxpirch", "uxirqq", "rxirqq", "rxdrql", "rxirquest"], "dma": ["ldmic", " dpa", "Dma", "mma", " dmas", "dna", "mmas", "Dmas", "nna", "dmas", "nmas", "ldna", " dna", "dpa", " dmic", "ldmas", "DMA", "dMA", "ldma", "nma", "npa", "mmic", "mna", "mMA", "mpa", "dmic", " dMA"], "clk": ["blkh", "CLz", "CLk", "clz", "CLkh", "blk", "blz", "CLks", "clks", "clkh", "blks", " clz", " clks", " clkh"], "s": ["service", "comm", "c", "sam", "comments", "tests", "r", "pers", "p", "changes", "aws", "bits", "vs", "S", "ns", "sm", "ies", "states", "less", "h", "v", "space", "i", "sa", "sb", "uploads", "args", "store", "os", "rs", "sl", "spec", "n", "cs", "services", "als", "ats", "ts", "ims", "its", "ers", "m", "ms", "ins", "has", "sts", "sw", "bs", "a", "is", "b", "l", "ps", "stats", "gs", "ls", "stat", "ports", "se", "fs", "w", "ds", "hs", "params", "details", "g", "set", "an", "js", "ss", "settings", "qs", "es", "e", "sv", "t", "conf"]}}
{"project": "FFmpeg", "commit_id": "7104c23bd1a1dcb8a7d9e2c8838c7ce55c30a331", "target": 0, "func": "static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int A[2] = {0}, B[2], C[2];\n\n    int i, j;\n\n    int mx, my;\n\n    int avail_index = avail_indexes[subblock_no];\n\n    int c_off = part_sizes_w[block_type];\n\n\n\n    mv_pos += (subblock_no & 1) + (subblock_no >> 1)*s->b8_stride;\n\n    if(subblock_no == 3)\n\n        c_off = -1;\n\n\n\n    if(r->avail_cache[avail_index - 1]){\n\n        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][0];\n\n        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][1];\n\n    }\n\n    if(r->avail_cache[avail_index - 4]){\n\n        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][0];\n\n        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][1];\n\n    }else{\n\n        B[0] = A[0];\n\n        B[1] = A[1];\n\n    }\n\n    if(!r->avail_cache[avail_index - 4 + c_off]){\n\n        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)){\n\n            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][0];\n\n            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][1];\n\n        }else{\n\n            C[0] = A[0];\n\n            C[1] = A[1];\n\n        }\n\n    }else{\n\n        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][0];\n\n        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][1];\n\n    }\n\n    mx = mid_pred(A[0], B[0], C[0]);\n\n    my = mid_pred(A[1], B[1], C[1]);\n\n    mx += r->dmv[dmv_no][0];\n\n    my += r->dmv[dmv_no][1];\n\n    for(j = 0; j < part_sizes_h[block_type]; j++){\n\n        for(i = 0; i < part_sizes_w[block_type]; i++){\n\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][0] = mx;\n\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][1] = my;\n\n        }\n\n    }\n\n}\n", "idx": 27317, "substitutes": {"r": ["f", "x", "o", "err", "re", "br", "d", "rs", "w", "rd", "nr", "c", "hr", "rc", "k", "result", "ur", "er", "rr", "or", "g", "resource", "sr", "n", "p", "ar", "gr", "kr", "rar", "usr", "rf", "rt", "b", "l", "rer", "dr", "mr", "R", "e", "rb", "rw", "tr", "h", "q", "t", "rg", "m", "v", "this", "ro", "res"], "block_type": ["pixel_no", "blockitytag", "pixel_tag", "block2no", "Block_name", "block2index", "blocklettype", "pixellettype", "block_index", "blockitytype", "blockitymode", "block_name", "blockTypetype", "block2name", "pixelletno", "blockityno", "Block_no", "block_no", "blockTypeno", "block2type", "blockletno", "blocklettag", "pixelletmode", "blockTypename", "pixellettag", "block_mode", "pixel_mode", "Block_type", "pixel_type", "blockletmode", "Block_index", "block_tag", "blockTypeindex"], "subblock_no": ["subBlock_name", "subblock08number", "subblock_number", "subBlock_type", "subblock_index", "subblock2number", "subBlock_number", "subblock_type", "subblock08sha", "subblock2nos", "subblock_sha", "subBlock_no", "subblock_name", "subblock_nos", "subblock2no", "subblock08no", "subblock08nos", "subBlock_nos", "subblock2type"], "dmv_no": ["dmv2no", "dmv_pos", "dmvjNO", "dmv2pos", "dmv2NO", "dmav_nos", "dmav_pos", "dmvjpos", "dmv2nos", "dmvjnos", "dmav_NO", "dmv_NO", "dmv_nos", "dmvjno", "dmav_no"], "s": ["o", "comm", "d", "c", "er", "times", "p", "aws", "vs", "S", "xs", "ns", "sm", "y", "ies", "z", "less", "http", "h", "v", "sq", "space", "sb", "os", "rs", "sl", "spec", "n", "sc", "cs", "session", "als", "ats", "ts", "ims", "its", "m", "sys", "ms", "x", "ins", "ses", "sts", "sw", "sql", "bs", "a", "is", "b", "l", "ps", "stats", "gs", "ls", "ssl", "f", "ears", "se", "fs", "w", "ds", "hs", "g", "sr", "js", "ss", "settings", "https", "south", "es", "sp", "sv", "u", "self", "t", "conv", "conf"], "A": ["LA", "AV", "W", "IA", "Answer", "AT", "AAA", "An", "At", " AA", "L", "AC", "UA", "D", "ACT", "CA", "AN", "I", "AF", "Array", "AR", "Area", "BA", "M", "EMA", "K", "AA", " a", "API", "GA", "S", "ACC", "JA", "SA", "V", "All", "a", "AB", "T", "AL", "AU", "AP", "R", "Ar", "N", "As", "AM", "HA", "H", "NA", "ACE", "EA", "P", "This", "G", "Alpha", "ALL", "AS"], "B": ["BER", "BC", "BY", "OB", "BR", "Bar", "Other", "L", "Z", "BE", "Builder", "D", "FB", "GB", "BL", "LB", "BM", "I", "BA", "M", "RB", "Chain", "USB", "BB", "J", "S", "PB", "BI", "TB", "V", "BF", "E", "b", "AB", "T", "DB", "NB", "VB", "R", "BT", "N", "LIB", "Buffer", "Bs", "WB", "P", "IB", "BU", "G", "Y", "OR", "Bytes", "F", "CB"], "C": ["BC", "CC", "Q", "CI", "CNN", "CG", "CON", "CN", "L", "CR", "c", "D", "CU", "CA", "YC", "CP", "Cache", "CV", "I", "CE", "M", "CL", "EC", "Chain", "CM", "X", "Co", "S", "LC", "Code", "Cl", "V", "E", "CT", "T", "CS", "R", "CW", "N", "P", "DC", "G", "Y", "F", "CB"], "i": ["f", "ic", "x", "o", "ik", "ia", "iy", "in", "I", "p", "ai", "mi", "ii", "li", "ti", "l", "bi", "ij", "ci", "ir", "iu", "xi", "h", "si", "m", "v"], "j": ["ji", "je", "o", "xy", "ja", "jump", "v", "k", "g", "n", "p", "kj", "J", "ii", "js", "jc", "b", "l", "ij", "y", "z", "jp", "q", "t", "m", "jj", "aj"], "mx": ["ms", "tx", "xy", "ll", "nm", "ma", "km", "ex", "yx", "mm", "ng", "mk", "dx", "ax", "yp", "xx", "nz", "sk", "xs", "zx", "xc", "mn", "px", "kg", "xi", "ml", "wx", "mu", "MX"], "my": ["vm", "pm", "ms", "xy", "nm", "ma", "mb", "mp", "yy", "mm", "mk", "md", "me", "ny", "mis", "mi", "yo", "gm", "py", "mr", "mn", "wn", "mc", "mt", "ml", "mid", "m"]}}
